[
  {
    "ir": "Write a PostgreSQL stored procedure named sp1 that accepts three parameters: para_function_id of type bigint which represents the unique identifier for a function, para_function_name of type text which contains the name of the function, and para_description of type text which holds the description of the function. The procedure first checks if a record exists in the functions table where the function_id column matches the provided para_function_id parameter. If such a record exists, the procedure updates the function_name column to the value of para_function_name and the description column to the value of para_description for that specific record. If no matching record is found, the procedure inserts a new row into the functions table, setting the function_id column to para_function_id, the function_name column to para_function_name, the description column to para_description, and both the created_at and updated_at columns to the current timestamp obtained from the NOW() function, which is explicitly cast to text format using the ::text operator.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp1(para_function_id bigint, para_function_name text, para_description text) LANGUAGE plpgsql AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM functions WHERE function_id = para_function_id) THEN\n        UPDATE functions SET function_name = para_function_name, description = para_description WHERE function_id = para_function_id;\n    ELSE\n        INSERT INTO functions (function_id, function_name, description, created_at, updated_at) VALUES (para_function_id, para_function_name, para_description, NOW()::text, NOW()::text);\n    END IF;\nEND;\n$$;",
    "database_name": "audio_synthesizer_parameter_management",
    "tables": [
      "functions",
      "parameters"
    ],
    "call_sqls": [
      "CALL sp1(1, 'attack', 'Attack phase of the sound');",
      "CALL sp1(2, 'decay', 'Decay phase of the sound');",
      "CALL sp1(3, 'sustain', 'Sustain phase of the sound');",
      "CALL sp1(4, 'release', 'Release phase of the sound');",
      "CALL sp1(5, 'filter_cutoff', 'Filter cutoff frequency');",
      "CALL sp1(6, 'filter_resonance', 'Filter resonance amount');",
      "CALL sp1(7, 'lfo_rate', 'LFO oscillation rate');",
      "CALL sp1(8, 'lfo_depth', 'LFO modulation depth');",
      "CALL sp1(9, 'pitch_bend', 'Pitch bend amount');",
      "CALL sp1(10, 'volume', 'Output volume level');",
      "CALL sp1(11, 'pan', 'Stereo panning position');",
      "CALL sp1(12, 'tremolo', 'Tremolo effect rate');",
      "CALL sp1(13, 'vibrato', 'Vibrato effect depth');",
      "CALL sp1(14, 'chorus', 'Chorus effect mix');",
      "CALL sp1(15, 'delay', 'Delay effect time');",
      "CALL sp1(16, 'reverb', 'Reverb effect size');",
      "CALL sp1(17, 'distortion', 'Distortion gain amount');",
      "CALL sp1(18, 'compression', 'Compression ratio');",
      "CALL sp1(19, 'envelope_amount', 'Envelope modulation amount');",
      "CALL sp1(20, 'portamento', 'Portamento glide time');"
    ],
    "id": 1
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named update_forecast_value that accepts two parameters: p_forecast_id of type bigint which represents the unique identifier of a forecast record, and p_new_value of type real which represents the new forecast value to be assigned. The function first performs a conditional check by executing a SELECT COUNT(*) query on the forecasts table to determine if a row exists where the forecast_id column matches the provided p_forecast_id parameter. If the count is greater than zero, indicating that such a forecast record exists, the function proceeds to update the forecasts table by setting the value column to the p_new_value parameter for the specific row where the forecast_id column equals the p_forecast_id parameter. If no matching forecast record is found, the function completes without performing any update operation.",
    "plsql": "CREATE OR REPLACE FUNCTION update_forecast_value(p_forecast_id bigint, p_new_value real)\nRETURNS void AS $$\nBEGIN\n    IF (SELECT COUNT(*) FROM forecasts WHERE forecasts.forecast_id = p_forecast_id) > 0 THEN\n        UPDATE forecasts SET forecasts.value = p_new_value WHERE forecasts.forecast_id = p_forecast_id;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "influenza_forecasting_and_analytics",
    "tables": [
      "forecasts",
      "forecast_history",
      "forecast_notifications",
      "forecast_types",
      "forecasts_targets"
    ],
    "call_sqls": [
      "SELECT update_forecast_value(1, 150.5);",
      "SELECT update_forecast_value(2, 89.75);",
      "SELECT update_forecast_value(3, 200.0);",
      "SELECT update_forecast_value(4, 45.25);",
      "SELECT update_forecast_value(5, 300.9);",
      "SELECT update_forecast_value(10, 125.0);",
      "SELECT update_forecast_value(15, 67.3);",
      "SELECT update_forecast_value(20, 180.6);",
      "SELECT update_forecast_value(25, 95.0);",
      "SELECT update_forecast_value(30, 210.75);",
      "SELECT update_forecast_value(35, 50.5);",
      "SELECT update_forecast_value(40, 275.25);",
      "SELECT update_forecast_value(45, 88.9);",
      "SELECT update_forecast_value(50, 142.3);",
      "SELECT update_forecast_value(55, 199.99);",
      "SELECT update_forecast_value(60, 65.0);",
      "SELECT update_forecast_value(65, 230.5);",
      "SELECT update_forecast_value(70, 110.75);",
      "SELECT update_forecast_value(75, 155.25);",
      "SELECT update_forecast_value(80, 42.8);"
    ],
    "id": 2
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_conversation_duration that accepts a single parameter conversation_id_input of type bigint and returns a bigint value, which first declares a local variable named duration of type bigint, then executes a SELECT query on the conversations table aliased as c to retrieve the duration column value where the conversation_id column matches the conversation_id_input parameter, storing this value in the duration variable, and then applies conditional logic where if the duration value is greater than 3600, the function returns the original duration value unchanged, else if the duration value equals exactly 3600, the function returns the result of dividing the duration by 2, and for all other cases where the duration is less than 3600, the function returns the result of multiplying the duration by 2.",
    "plsql": "CREATE OR REPLACE FUNCTION get_conversation_duration(conversation_id_input bigint) RETURNS bigint AS $$\nDECLARE\n  duration bigint;\nBEGIN\n  SELECT c.duration INTO duration\n  FROM conversations c\n  WHERE c.conversation_id = conversation_id_input;\n  \n  IF duration > 3600 THEN\n    RETURN duration;\n  ELSIF duration = 3600 THEN\n    RETURN duration / 2;\n  ELSE\n    RETURN duration * 2;\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conversation_analysis_and_transcription_system",
    "tables": [
      "conversations",
      "utterances"
    ],
    "call_sqls": [
      "SELECT get_conversation_duration(0);",
      "SELECT get_conversation_duration(1);",
      "SELECT get_conversation_duration(2);",
      "SELECT get_conversation_duration(3);",
      "SELECT get_conversation_duration(4);",
      "SELECT get_conversation_duration(5);",
      "SELECT get_conversation_duration(10);",
      "SELECT get_conversation_duration(15);",
      "SELECT get_conversation_duration(20);",
      "SELECT get_conversation_duration(25);",
      "SELECT get_conversation_duration(30);",
      "SELECT get_conversation_duration(35);",
      "SELECT get_conversation_duration(40);",
      "SELECT get_conversation_duration(45);",
      "SELECT get_conversation_duration(50);",
      "SELECT get_conversation_duration(100);",
      "SELECT get_conversation_duration(200);",
      "SELECT get_conversation_duration(300);",
      "SELECT get_conversation_duration(4788);",
      "SELECT get_conversation_duration(5000);"
    ],
    "id": 3
  },
  {
    "ir": "Write a PLpgSQL function that is triggered after any insert, update, or delete operation on the capital_investments table, which updates the total_capital_investment column in the process_data table for the corresponding element_id. The function first determines the target element_id based on the type of operation: for a delete operation, it uses the element_id from the OLD record, and for insert or update operations, it uses the element_id from the NEW record. It then updates the process_data table by setting the total_capital_investment to the sum of all investment_amount values from the capital_investments table where the element_id matches the target_element_id, using COALESCE to handle cases where the sum might be null. The function returns the OLD record for delete operations and the NEW record for insert or update operations. Additionally, write another PLpgSQL function that is triggered before an insert operation on the capital_investments table, which ensures that the investment_id column is populated. If the NEW record's investment_id is null, the function assigns it a new value by selecting the maximum existing investment_id from the capital_investments table, adding one to it, and using COALESCE to default to zero if no records exist. This function returns the NEW record with the potentially updated investment_id.",
    "plsql": "CREATE OR REPLACE FUNCTION update_total_investment_on_capital_change() RETURNS TRIGGER AS $$\nDECLARE\n    target_element_id bigint;\nBEGIN\n    -- Determine which element_id to use based on operation\n    IF TG_OP = 'DELETE' THEN\n        target_element_id := OLD.element_id;\n    ELSE\n        target_element_id := NEW.element_id;\n    END IF;\n    \n    -- Update process_data with the new total investment amount\n    UPDATE process_data\n    SET total_capital_investment = (\n        SELECT COALESCE(SUM(investment_amount), 0) \n        FROM capital_investments \n        WHERE element_id = target_element_id\n    )\n    WHERE element_id = target_element_id;\n    \n    -- Return appropriate value based on operation\n    IF TG_OP = 'DELETE' THEN\n        RETURN OLD;\n    ELSE\n        RETURN NEW;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE OR REPLACE FUNCTION ensure_investment_id() RETURNS TRIGGER AS $$\nBEGIN\n    -- Generate a new investment_id if it's NULL\n    IF NEW.investment_id IS NULL THEN\n        -- Use a sequence or generate from max value\n        SELECT COALESCE(MAX(investment_id), 0) + 1 \n        INTO NEW.investment_id \n        FROM capital_investments;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create trigger to ensure investment_id is populated before INSERT\nCREATE TRIGGER tr_ensure_investment_id\nBEFORE INSERT ON capital_investments\nFOR EACH ROW EXECUTE FUNCTION ensure_investment_id();\n\n-- Create trigger to update process_data after capital_investments changes\nCREATE TRIGGER tr_capital_update_process_data\nAFTER INSERT OR UPDATE OR DELETE ON capital_investments\nFOR EACH ROW EXECUTE FUNCTION update_total_investment_on_capital_change();",
    "database_name": "biochemical_process_optimization_and_cost_analysis",
    "tables": [
      "process_elements",
      "process_data",
      "parameters",
      "access_logs",
      "users",
      "capital_investments",
      "environmental_impacts"
    ],
    "call_sqls": [
      "INSERT INTO capital_investments (element_id, investment_amount, investment_date, investment_type) VALUES (1, 50000.0, '2024-01-15', 'Equipment');",
      "INSERT INTO capital_investments (element_id, investment_amount, investment_date, investment_type, investment_id) VALUES (2, 75000.5, '2024-01-16', 'Infrastructure', NULL);",
      "INSERT INTO capital_investments (element_id, investment_amount, investment_date, investment_type) VALUES (0, 120000.75, '2024-01-17', 'Software');",
      "UPDATE capital_investments SET investment_amount = 55000.0 WHERE investment_id = 1 AND element_id = 1;",
      "INSERT INTO capital_investments (element_id, investment_amount, investment_date, investment_type) VALUES (1, 25000.0, '2024-01-18', 'Maintenance');",
      "INSERT INTO capital_investments (investment_id, element_id, investment_amount, investment_date, investment_type) VALUES (NULL, 0, 15000.25, '2024-01-19', 'Training');",
      "UPDATE capital_investments SET investment_amount = investment_amount * 1.1 WHERE element_id = 0;",
      "INSERT INTO capital_investments (element_id, investment_amount, investment_date, investment_type) VALUES (2, 0.0, '2024-01-20', 'Research');",
      "DELETE FROM capital_investments WHERE investment_date < '2024-01-01';",
      "INSERT INTO capital_investments (element_id, investment_amount, investment_date, investment_type) VALUES (1, -1000.0, '2024-01-21', 'Credit');",
      "INSERT INTO capital_investments (element_id, investment_amount, investment_date, investment_type) VALUES (0, 999.99, '2024-01-22', 'Misc');",
      "UPDATE capital_investments SET element_id = 2 WHERE investment_id = 1;",
      "INSERT INTO capital_investments (investment_id, element_id, investment_amount, investment_date, investment_type) VALUES (100, 1, 500000.0, '2024-01-23', 'Major Project');",
      "DELETE FROM capital_investments WHERE element_id IN (0, 1, 2);"
    ],
    "id": 4
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_spherical_volume_from_contract_value` that accepts a single input parameter, `p_contract_id`, which is of type `bigint` and represents a unique identifier for a contract. This function is designed to return a `numeric` value, representing a calculated spherical volume. The function begins by declaring two local variables: `v_cost`, of type `numeric`, intended to store the total cost associated with a contract, and `v_volume`, also of type `numeric`, intended to store the final calculated spherical volume. The first operation performed is a `SELECT` statement that retrieves the `total_cost` column from the `contracts` table. The value of `total_cost` is explicitly cast to `numeric` type using `::numeric` and then assigned to the `v_cost` variable. This selection is filtered by a `WHERE` clause, ensuring that only the row where the `contract_id` column matches the input parameter `p_contract_id` is considered. Following this data retrieval, a conditional `IF` statement evaluates whether the `v_cost` variable is `NOT NULL`. If `v_cost` contains a non-null value, the function proceeds to calculate `v_volume` using the formula for the volume of a sphere: `(4.0/3.0) * pi() * POWER(v_cost, 3)`. This calculation involves multiplying the constant `4.0/3.0` by the mathematical constant `pi()` (a built-in PostgreSQL function that returns the value of pi) and by the cube of `v_cost`, which is computed using the `POWER()` function (a built-in PostgreSQL function that raises a number to a specified power). If, however, `v_cost` is `NULL` (meaning no contract was found for the given `p_contract_id` or its `total_cost` was null), the `ELSE` block is executed, and `v_volume` is assigned the value `0`. Finally, the function returns the calculated `v_volume` as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_spherical_volume_from_contract_value(p_contract_id bigint)\nRETURNS numeric LANGUAGE plpgsql AS $$\nDECLARE\n    v_cost numeric;\n    v_volume numeric;\nBEGIN\n    SELECT total_cost::numeric INTO v_cost\n    FROM contracts \n    WHERE contract_id = p_contract_id;\n    \n    IF v_cost IS NOT NULL THEN\n        v_volume := (4.0/3.0) * pi() * POWER(v_cost, 3);\n    ELSE\n        v_volume := 0;\n    END IF;\n    \n    RETURN v_volume;\nEND;\n$$;",
    "database_name": "contract_management_and_procurement",
    "tables": [
      "contracts",
      "permissions",
      "procurement_process",
      "reports",
      "roles",
      "users",
      "vendors"
    ],
    "call_sqls": [
      "SELECT calculate_spherical_volume_from_contract_value(1);",
      "SELECT calculate_spherical_volume_from_contract_value(2);",
      "SELECT calculate_spherical_volume_from_contract_value(3);",
      "SELECT calculate_spherical_volume_from_contract_value(4);",
      "SELECT calculate_spherical_volume_from_contract_value(5);",
      "SELECT calculate_spherical_volume_from_contract_value(10);",
      "SELECT calculate_spherical_volume_from_contract_value(15);",
      "SELECT calculate_spherical_volume_from_contract_value(20);",
      "SELECT calculate_spherical_volume_from_contract_value(25);",
      "SELECT calculate_spherical_volume_from_contract_value(30);",
      "SELECT calculate_spherical_volume_from_contract_value(35);",
      "SELECT calculate_spherical_volume_from_contract_value(40);",
      "SELECT calculate_spherical_volume_from_contract_value(45);",
      "SELECT calculate_spherical_volume_from_contract_value(50);",
      "SELECT calculate_spherical_volume_from_contract_value(55);",
      "SELECT calculate_spherical_volume_from_contract_value(60);",
      "SELECT calculate_spherical_volume_from_contract_value(65);",
      "SELECT calculate_spherical_volume_from_contract_value(70);",
      "SELECT calculate_spherical_volume_from_contract_value(75);",
      "SELECT calculate_spherical_volume_from_contract_value(80);",
      "SELECT calculate_spherical_volume_from_contract_value(85);"
    ],
    "id": 5
  },
  {
    "ir": "Write a PLpgSQL function that inserts a new record into the crime_categories table using the provided parameters: p_category_id, p_category_name, and p_is_violent. The function takes three parameters: p_category_id of type bigint, which represents the unique identifier for the crime category; p_category_name of type text, which specifies the name of the crime category; and p_is_violent of type bigint, which indicates whether the crime category is considered violent, with a value of 1 for violent and 0 for non-violent. The function performs an INSERT operation into the crime_categories table, populating the category_id column with the value of p_category_id, the category_name column with the value of p_category_name, the is_violent column with the value of p_is_violent, and the is_property column with the result of the expression ABS(p_is_violent - 1), which calculates the opposite of the p_is_violent value, effectively setting is_property to 1 if p_is_violent is 0 and to 0 if p_is_violent is 1. After successfully inserting the record, the function returns the value of p_category_id, indicating the identifier of the newly inserted crime category.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_crime_category(p_category_id bigint, p_category_name text, p_is_violent bigint)\nRETURNS bigint AS $$\nBEGIN\n    INSERT INTO crime_categories (category_id, category_name, is_violent, is_property) VALUES (p_category_id, p_category_name, p_is_violent, ABS(p_is_violent - 1));\n    RETURN p_category_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "crime_statistics_and_demographics_490046",
    "tables": [
      "crime_categories",
      "police_force",
      "state_weapon_usage",
      "weapon_types",
      "gun_ownership"
    ],
    "call_sqls": [
      "SELECT insert_crime_category(100, 'Robbery', 1);",
      "SELECT insert_crime_category(101, 'Burglary', 0);",
      "SELECT insert_crime_category(102, 'Assault', 1);",
      "SELECT insert_crime_category(103, 'Theft', 0);",
      "SELECT insert_crime_category(104, 'Arson', 1);",
      "SELECT insert_crime_category(105, 'Vandalism', 0);",
      "SELECT insert_crime_category(106, 'Kidnapping', 1);",
      "SELECT insert_crime_category(107, 'Fraud', 0);",
      "SELECT insert_crime_category(108, 'Drug Offense', 0);",
      "SELECT insert_crime_category(109, 'Homicide', 1);",
      "SELECT insert_crime_category(110, 'Sexual Assault', 1);",
      "SELECT insert_crime_category(111, 'Forgery', 0);",
      "SELECT insert_crime_category(112, 'Embezzlement', 0);",
      "SELECT insert_crime_category(113, 'Extortion', 1);",
      "SELECT insert_crime_category(114, 'Stalking', 1);",
      "SELECT insert_crime_category(115, 'Cybercrime', 0);",
      "SELECT insert_crime_category(116, 'Terrorism', 1);",
      "SELECT insert_crime_category(117, 'Human Trafficking', 1);",
      "SELECT insert_crime_category(118, 'Identity Theft', 0);",
      "SELECT insert_crime_category(119, 'Carjacking', 1);"
    ],
    "id": 6
  },
  {
    "ir": "Write a PostgreSQL function named get_total_cargo_by_type that takes no parameters and returns a table with two columns: cargo_type_code of type text and total_metric_tons of type real. The function executes a query that selects the cargo_type_code column from the cargo_activities table (aliased as ca) and calculates the sum of the cargo_metric_tons column for each distinct cargo_type_code value. The query groups the results by cargo_type_code, effectively aggregating all cargo activities by their type and computing the total metric tons for each type. The function uses the RETURN QUERY statement to return the result set directly without any additional processing or conditional logic.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_cargo_by_type()\nRETURNS TABLE(cargo_type_code text, total_metric_tons real) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT ca.cargo_type_code, SUM(ca.cargo_metric_tons) as total_metric_tons\n    FROM cargo_activities ca\n    GROUP BY ca.cargo_type_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "aviation_cargo_activity_and_operations_tracking",
    "tables": [
      "cargo_activities",
      "cargo_types"
    ],
    "call_sqls": [
      "SELECT * FROM get_total_cargo_by_type();",
      "SELECT cargo_type_code, total_metric_tons FROM get_total_cargo_by_type();",
      "SELECT * FROM get_total_cargo_by_type() ORDER BY total_metric_tons DESC;",
      "SELECT * FROM get_total_cargo_by_type() WHERE total_metric_tons > 1000;",
      "SELECT cargo_type_code, ROUND(total_metric_tons::numeric, 2) FROM get_total_cargo_by_type();",
      "SELECT * FROM get_total_cargo_by_type() WHERE cargo_type_code = 'GEN';",
      "SELECT * FROM get_total_cargo_by_type() WHERE cargo_type_code IN ('GEN', 'MAIL');",
      "SELECT * FROM get_total_cargo_by_type() WHERE total_metric_tons BETWEEN 500 AND 5000;",
      "SELECT ct.cargo_description, f.total_metric_tons FROM get_total_cargo_by_type() f JOIN cargo_types ct ON f.cargo_type_code = ct.cargo_type_code;",
      "SELECT * FROM get_total_cargo_by_type() ORDER BY cargo_type_code;",
      "SELECT * FROM get_total_cargo_by_type() WHERE total_metric_tons IS NOT NULL;",
      "SELECT cargo_type_code, total_metric_tons FROM get_total_cargo_by_type() WHERE total_metric_tons < 100;",
      "SELECT * FROM get_total_cargo_by_type() WHERE cargo_type_code LIKE 'A%';",
      "SELECT * FROM get_total_cargo_by_type() LIMIT 5;",
      "SELECT cargo_type_code, total_metric_tons FROM get_total_cargo_by_type() ORDER BY total_metric_tons ASC LIMIT 3;",
      "SELECT SUM(total_metric_tons) AS grand_total FROM get_total_cargo_by_type();",
      "SELECT AVG(total_metric_tons) AS average_total FROM get_total_cargo_by_type();",
      "SELECT cargo_type_code FROM get_total_cargo_by_type() WHERE total_metric_tons = (SELECT MAX(total_metric_tons) FROM get_total_cargo_by_type());",
      "SELECT * FROM get_total_cargo_by_type() WHERE cargo_type_code NOT IN ('UNK', 'OTH');",
      "SELECT cargo_type_code, total_metric_tons, (total_metric_tons * 1000) AS total_kilograms FROM get_total_cargo_by_type();"
    ],
    "id": 7
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_application_cost_category that accepts a single input parameter p_application_id of type NUMBER and returns a VARCHAR2 value, which declares a local variable v_cost of type NUMBER, then retrieves the application_cost value from the applications table where the application_id column matches the provided p_application_id parameter, storing this value in the v_cost variable, and subsequently evaluates the v_cost value against a threshold of 1000, returning the string 'HIGH_COST' if the v_cost exceeds 1000, or returning 'LOW_COST' if the v_cost is less than or equal to 1000.",
    "plsql": "CREATE OR REPLACE FUNCTION get_application_cost_category(p_application_id NUMBER) RETURN VARCHAR2 IS\n  v_cost NUMBER;\nBEGIN\n  SELECT application_cost INTO v_cost FROM applications WHERE application_id = p_application_id;\n  IF v_cost > 1000 THEN\n    RETURN 'HIGH_COST';\n  ELSE\n    RETURN 'LOW_COST';\n  END IF;\nEND;",
    "database_name": "agricultural_pma_applicat",
    "tables": [
      "applications"
    ],
    "call_sqls": [
      "SELECT get_application_cost_category(1) FROM DUAL",
      "SELECT get_application_cost_category(2) FROM DUAL",
      "SELECT get_application_cost_category(3) FROM DUAL",
      "SELECT get_application_cost_category(4) FROM DUAL",
      "SELECT get_application_cost_category(5) FROM DUAL",
      "SELECT get_application_cost_category(10) FROM DUAL",
      "SELECT get_application_cost_category(15) FROM DUAL",
      "SELECT get_application_cost_category(20) FROM DUAL",
      "SELECT get_application_cost_category(25) FROM DUAL",
      "SELECT get_application_cost_category(30) FROM DUAL",
      "SELECT get_application_cost_category(35) FROM DUAL",
      "SELECT get_application_cost_category(40) FROM DUAL",
      "SELECT get_application_cost_category(45) FROM DUAL",
      "SELECT get_application_cost_category(50) FROM DUAL",
      "SELECT get_application_cost_category(55) FROM DUAL",
      "SELECT get_application_cost_category(60) FROM DUAL",
      "SELECT get_application_cost_category(65) FROM DUAL",
      "SELECT get_application_cost_category(70) FROM DUAL",
      "SELECT get_application_cost_category(75) FROM DUAL",
      "SELECT get_application_cost_category(80) FROM DUAL",
      "SELECT get_application_cost_category(85) FROM DUAL"
    ],
    "id": 8
  },
  {
    "ir": "Write a PLpgSQL function that calculates the success rate of a specific treatment by taking a parameter p_treatment_id of type bigint, which represents the unique identifier of the treatment in question. The function first checks if there are any records in the patient_treatments table with a treatment_id matching the provided p_treatment_id. If such records exist, it calculates the success rate by selecting the count of rows where the treatment_outcome column equals 'Complete Response' and divides this count by the total number of rows with the same treatment_id. This ratio is then multiplied by 100 to convert it into a percentage and rounded to two decimal places using the ROUND function. The result is stored in a variable named success_rate of type numeric. If no records exist for the given treatment_id, the success_rate is set to 0. Finally, the function returns the calculated success_rate.",
    "plsql": "CREATE OR REPLACE FUNCTION get_treatment_success_rate(p_treatment_id bigint) RETURNS numeric LANGUAGE plpgsql AS $$ DECLARE success_rate numeric; BEGIN IF EXISTS (SELECT 1 FROM patient_treatments WHERE treatment_id = p_treatment_id) THEN SELECT ROUND((COUNT(*) FILTER (WHERE treatment_outcome = 'Complete Response')::numeric / COUNT(*)) * 100, 2) INTO success_rate FROM patient_treatments WHERE treatment_id = p_treatment_id; ELSE success_rate := 0; END IF; RETURN success_rate; END; $$;",
    "database_name": "breast_cancer_patient_data_analysis",
    "tables": [
      "patients",
      "patient_treatments",
      "treatments"
    ],
    "call_sqls": [
      "SELECT get_treatment_success_rate(1);",
      "SELECT get_treatment_success_rate(2);",
      "SELECT get_treatment_success_rate(3);",
      "SELECT get_treatment_success_rate(4);",
      "SELECT get_treatment_success_rate(5);",
      "SELECT get_treatment_success_rate(6);",
      "SELECT get_treatment_success_rate(7);",
      "SELECT get_treatment_success_rate(8);",
      "SELECT get_treatment_success_rate(9);",
      "SELECT get_treatment_success_rate(10);",
      "SELECT get_treatment_success_rate(0);",
      "SELECT get_treatment_success_rate(100);",
      "SELECT get_treatment_success_rate(101);",
      "SELECT get_treatment_success_rate(102);",
      "SELECT get_treatment_success_rate(103);",
      "SELECT get_treatment_success_rate(104);",
      "SELECT get_treatment_success_rate(105);",
      "SELECT get_treatment_success_rate(106);",
      "SELECT get_treatment_success_rate(107);",
      "SELECT get_treatment_success_rate(108);",
      "SELECT get_treatment_success_rate(109);"
    ],
    "id": 9
  },
  {
    "ir": "Write a PLpgSQL function named get_event_details that accepts two parameters: p_event_id of type bigint, which specifies the unique identifier of an event, and p_include_schedule of type boolean, which indicates whether to include the event's schedule activities in the result. The function returns a table with columns: event_name of type text, event_date of type text, location_name of type text, address of type text, capacity of type bigint, and schedule_activities of type text. The function executes a SELECT query that retrieves data from the events table, joining it with the locations table on the location_id column to obtain location details, and with the event_schedule table on the event_id column to gather schedule activities. The SELECT statement fetches the event_name and event_date from the events table, location_name, address, and capacity from the locations table, and uses the string_agg function to concatenate activity_name values from the event_schedule table into a single string separated by commas, assigning this result to schedule_activities. The query filters results to include only the row where the event_id matches the provided p_event_id parameter. The results are grouped by event_name, event_date, location_name, address, and capacity to ensure that the aggregation of schedule activities is correctly applied.",
    "plsql": "CREATE OR REPLACE FUNCTION get_event_details(p_event_id bigint, p_include_schedule boolean)\nRETURNS TABLE(\n    event_name text,\n    event_date text,\n    location_name text,\n    address text,\n    capacity bigint,\n    schedule_activities text\n) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        e.event_name,\n        e.event_date,\n        l.location_name,\n        l.address,\n        l.capacity,\n        string_agg(es.activity_name, ', ') as schedule_activities\n    FROM events e\n    LEFT JOIN locations l ON e.location_id = l.location_id\n    LEFT JOIN event_schedule es ON e.event_id = es.event_id\n    WHERE e.event_id = p_event_id\n    GROUP BY e.event_name, e.event_date, l.location_name, l.address, l.capacity;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "community_event_management_and_participation",
    "tables": [
      "events",
      "event_schedule",
      "registrations",
      "locations"
    ],
    "call_sqls": [
      "SELECT * FROM get_event_details(1, true);",
      "SELECT * FROM get_event_details(1, false);",
      "SELECT * FROM get_event_details(2, true);",
      "SELECT * FROM get_event_details(2, false);",
      "SELECT * FROM get_event_details(3, true);",
      "SELECT * FROM get_event_details(3, false);",
      "SELECT * FROM get_event_details(4, true);",
      "SELECT * FROM get_event_details(4, false);",
      "SELECT * FROM get_event_details(5, true);",
      "SELECT * FROM get_event_details(5, false);",
      "SELECT * FROM get_event_details(10, true);",
      "SELECT * FROM get_event_details(10, false);",
      "SELECT * FROM get_event_details(15, true);",
      "SELECT * FROM get_event_details(15, false);",
      "SELECT * FROM get_event_details(20, true);",
      "SELECT * FROM get_event_details(20, false);",
      "SELECT * FROM get_event_details(25, true);",
      "SELECT * FROM get_event_details(25, false);",
      "SELECT * FROM get_event_details(100, true);",
      "SELECT * FROM get_event_details(100, false);",
      "SELECT * FROM get_event_details(500, true);",
      "SELECT * FROM get_event_details(500, false);"
    ],
    "id": 10
  },
  {
    "ir": "Write a PLpgSQL function named get_region_network_stats that accepts an input parameter region_name_input of type text and returns a record containing two output parameters: network_count of type bigint and avg_community_structure of type real. The function performs a SELECT operation to retrieve data from three tables: brain_regions, region_networks, and region_network_properties. It joins the brain_regions table with the region_networks table using the region_id column, and then joins the region_networks table with the region_network_properties table using the network_id column. The function filters the results based on the condition where the region_name column in the brain_regions table matches the value of the region_name_input parameter. It calculates the COUNT of distinct network_id values from the region_networks table and assigns this count to the network_count output parameter. Additionally, it computes the AVG of the community_structure column from the region_network_properties table and assigns this average to the avg_community_structure output parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_network_stats(\n    IN region_name_input text,\n    OUT network_count bigint,\n    OUT avg_community_structure real\n)\nRETURNS RECORD\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT COUNT(DISTINCT rn.network_id),\n           AVG(rnp.community_structure)\n    INTO network_count, avg_community_structure\n    FROM brain_regions br\n    JOIN region_networks rn ON br.region_id = rn.region_id\n    JOIN region_network_properties rnp ON rn.network_id = rnp.network_id\n    WHERE br.region_name = region_name_input;\nEND;\n$$;",
    "database_name": "brain_region_analysis_and_connectivity",
    "tables": [
      "brain_regions",
      "cognitive_tasks",
      "region_connections",
      "region_networks",
      "region_network_properties",
      "researchers",
      "researcher_cognitive_tasks"
    ],
    "call_sqls": [
      "SELECT * FROM get_region_network_stats('lh_bankssts');",
      "SELECT * FROM get_region_network_stats('lh_caudalanteriorcingulate');",
      "SELECT * FROM get_region_network_stats('lh_caudalmiddlefrontal');",
      "SELECT * FROM get_region_network_stats('lh_cuneus');",
      "SELECT * FROM get_region_network_stats('lh_entorhinal');",
      "SELECT * FROM get_region_network_stats('lh_fusiform');",
      "SELECT * FROM get_region_network_stats('lh_inferiorparietal');",
      "SELECT * FROM get_region_network_stats('lh_inferiortemporal');",
      "SELECT * FROM get_region_network_stats('lh_isthmuscingulate');",
      "SELECT * FROM get_region_network_stats('lh_lateraloccipital');",
      "SELECT * FROM get_region_network_stats('lh_lateralorbitofrontal');",
      "SELECT * FROM get_region_network_stats('lh_lingual');",
      "SELECT * FROM get_region_network_stats('lh_medialorbitofrontal');",
      "SELECT * FROM get_region_network_stats('lh_middletemporal');",
      "SELECT * FROM get_region_network_stats('lh_parahippocampal');",
      "SELECT * FROM get_region_network_stats('lh_paracentral');",
      "SELECT * FROM get_region_network_stats('lh_parsopercularis');",
      "SELECT * FROM get_region_network_stats('lh_parsorbitalis');",
      "SELECT * FROM get_region_network_stats('lh_parstriangularis');",
      "SELECT * FROM get_region_network_stats('lh_pericalcarine');"
    ],
    "id": 11
  },
  {
    "ir": "Write a PLpgSQL function named get_permit_duration that accepts a single parameter permit_id_input of type text. This function calculates and returns the duration as an interval between the start_date and end_date for a specific permit identified by the permit_id_input from the permits table. The function begins by declaring a variable named duration of type interval to store the result. It then executes a SELECT statement to compute the difference between the end_date and start_date for the permit with the specified permit_id. The SELECT statement constructs two timestamps using the make_timestamp function, which takes the year, month, and day extracted from the end_date and start_date columns, respectively, and sets the time components to zero. The difference between these two timestamps is calculated and stored in the duration variable. The function concludes by returning the calculated duration.",
    "plsql": "CREATE OR REPLACE FUNCTION get_permit_duration(permit_id_input text) RETURNS interval AS $$\nDECLARE\n    duration interval;\nBEGIN\n    SELECT make_timestamp(EXTRACT(YEAR FROM end_date::date)::int, EXTRACT(MONTH FROM end_date::date)::int, EXTRACT(DAY FROM end_date::date)::int, 0, 0, 0) -\n           make_timestamp(EXTRACT(YEAR FROM start_date::date)::int, EXTRACT(MONTH FROM start_date::date)::int, EXTRACT(DAY FROM start_date::date)::int, 0, 0, 0)\n    INTO duration\n    FROM permits\n    WHERE permit_id = permit_id_input;\n    RETURN duration;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "business_registration_and_permit_tracking",
    "tables": [
      "permits",
      "documents",
      "inspections"
    ],
    "call_sqls": [
      "SELECT get_permit_duration('0');",
      "SELECT get_permit_duration('1');",
      "SELECT get_permit_duration('PR0032837');",
      "SELECT get_permit_duration('PR0010670');",
      "SELECT get_permit_duration('2');",
      "SELECT get_permit_duration('3');",
      "SELECT get_permit_duration('100');",
      "SELECT get_permit_duration('200');",
      "SELECT get_permit_duration('ABC123');",
      "SELECT get_permit_duration('XYZ789');",
      "SELECT get_permit_duration('F001');",
      "SELECT get_permit_duration('C002');",
      "SELECT get_permit_duration('TEST001');",
      "SELECT get_permit_duration('PERMIT-001');",
      "SELECT get_permit_duration('P-2023-001');",
      "SELECT get_permit_duration('P-2024-100');",
      "SELECT get_permit_duration('FS-001');",
      "SELECT get_permit_duration('CON-500');",
      "SELECT get_permit_duration('SAMPLE_ID');",
      "SELECT get_permit_duration('NULL_TEST');"
    ],
    "id": 12
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_visitor_satisfaction` that accepts a single input parameter, `p_visitor_id`, which is of type `bigint` and represents the unique identifier for a visitor. This function is designed to compute and return a `numeric` value representing a visitor's satisfaction score.\n\nUpon execution, the function first declares three local variables: `v_avg_rating` of type `numeric` to store the average rating, `v_revisit_count` of type `integer` to store the count of positive revisit intentions, and `v_satisfaction_score` of type `numeric` to store the final calculated satisfaction score.\n\nThe core logic begins by executing a `SELECT` statement against the `ratings` table. This `SELECT` statement performs two aggregate calculations:\n1. It calculates the average of the `rating` column for all rows where the `visitor_id` column matches the input parameter `p_visitor_id`. The result of this average is then assigned to the `v_avg_rating` variable.\n2. It counts the number of occurrences where the `revisit_intent` column is exactly equal to the string literal 'Yes' for all rows where the `visitor_id` column matches the input parameter `p_visitor_id`. This count is achieved using a `COUNT(CASE WHEN revisit_intent = 'Yes' THEN 1 END)` expression. The result of this count is then assigned to the `v_revisit_count` variable.\n\nFollowing the data retrieval, the function proceeds with a conditional logic block (`IF-ELSIF-ELSE`) to determine the `v_satisfaction_score`:\n1. The first condition checks if `v_avg_rating` is greater than or equal to `4` AND `v_revisit_count` is greater than `0`. If both conditions are true, `v_satisfaction_score` is calculated as `v_avg_rating` multiplied by `1.2`.\n2. If the first condition is false, the `ELSIF` condition is evaluated. This condition checks if `v_avg_rating` is greater than or equal to `3`. If this condition is true, `v_satisfaction_score` is calculated as `v_avg_rating` multiplied by `1.0`.\n3. If both the `IF` and `ELSIF` conditions are false, the `ELSE` block is executed. In this case, `v_satisfaction_score` is calculated as `v_avg_rating` multiplied by `0.8`.\n\nFinally, the function returns the calculated `v_satisfaction_score` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_visitor_satisfaction(p_visitor_id bigint) RETURNS numeric LANGUAGE plpgsql AS $$ DECLARE v_avg_rating numeric; v_revisit_count integer; v_satisfaction_score numeric; BEGIN SELECT AVG(rating), COUNT(CASE WHEN revisit_intent = 'Yes' THEN 1 END) INTO v_avg_rating, v_revisit_count FROM ratings WHERE visitor_id = p_visitor_id; IF v_avg_rating >= 4 AND v_revisit_count > 0 THEN v_satisfaction_score := v_avg_rating * 1.2; ELSIF v_avg_rating >= 3 THEN v_satisfaction_score := v_avg_rating * 1.0; ELSE v_satisfaction_score := v_avg_rating * 0.8; END IF; RETURN v_satisfaction_score; END; $$;",
    "database_name": "amusement_park_attractions_management",
    "tables": [
      "age_groups",
      "attractions",
      "maintenance",
      "ratings",
      "ride_types",
      "thrill_levels",
      "visitors"
    ],
    "call_sqls": [
      "SELECT calculate_visitor_satisfaction(0);",
      "SELECT calculate_visitor_satisfaction(1);",
      "SELECT calculate_visitor_satisfaction(2);",
      "SELECT calculate_visitor_satisfaction(3);",
      "SELECT calculate_visitor_satisfaction(4);",
      "SELECT calculate_visitor_satisfaction(5);",
      "SELECT calculate_visitor_satisfaction(6);",
      "SELECT calculate_visitor_satisfaction(7);",
      "SELECT calculate_visitor_satisfaction(8);",
      "SELECT calculate_visitor_satisfaction(9);",
      "SELECT calculate_visitor_satisfaction(10);",
      "SELECT calculate_visitor_satisfaction(11);",
      "SELECT calculate_visitor_satisfaction(12);",
      "SELECT calculate_visitor_satisfaction(13);",
      "SELECT calculate_visitor_satisfaction(14);",
      "SELECT calculate_visitor_satisfaction(15);",
      "SELECT calculate_visitor_satisfaction(16);",
      "SELECT calculate_visitor_satisfaction(17);",
      "SELECT calculate_visitor_satisfaction(18);",
      "SELECT calculate_visitor_satisfaction(19);"
    ],
    "id": 13
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_error_category_count` that accepts a single input parameter named `category_input` of data type `text`. This function is designed to return an integer value representing a count. Upon execution, the function declares a local variable named `category_count` of data type `integer`. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement calculates the total number of rows in the `error_codes` table. The counting is performed using the `COUNT(*)` aggregate function, which counts all rows that satisfy the specified conditions. The condition for counting is `WHERE category = category_input`, meaning only rows where the value in the `category` column of the `error_codes` table exactly matches the value provided in the `category_input` parameter will be included in the count. The result of this `COUNT(*)` operation is then assigned to the `category_count` local variable. Finally, the function returns the integer value stored in the `category_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_error_category_count(category_input text) RETURNS integer AS $$\nDECLARE\n    category_count integer;\nBEGIN\n    SELECT COUNT(*) INTO category_count\n    FROM error_codes\n    WHERE category = category_input;\n    RETURN category_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "api_response_logging_and_monitoring",
    "tables": [
      "users",
      "access_logs",
      "errors",
      "process_times",
      "extra_info",
      "error_codes",
      "http_status_codes"
    ],
    "call_sqls": [
      "SELECT get_error_category_count('System');",
      "SELECT get_error_category_count('Validation');",
      "SELECT get_error_category_count('Network');",
      "SELECT get_error_category_count('Database');",
      "SELECT get_error_category_count('Security');",
      "SELECT get_error_category_count('Application');",
      "SELECT get_error_category_count('Configuration');",
      "SELECT get_error_category_count('Authentication');",
      "SELECT get_error_category_count('Authorization');",
      "SELECT get_error_category_count('Input');",
      "SELECT get_error_category_count('Output');",
      "SELECT get_error_category_count('Timeout');",
      "SELECT get_error_category_count('Resource');",
      "SELECT get_error_category_count('Client');",
      "SELECT get_error_category_count('Server');",
      "SELECT get_error_category_count('External');",
      "SELECT get_error_category_count('Internal');",
      "SELECT get_error_category_count('Critical');",
      "SELECT get_error_category_count('Warning');",
      "SELECT get_error_category_count('Info');"
    ],
    "id": 14
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_best_treatment that accepts a single input parameter p_season of type VARCHAR2 and returns a VARCHAR2 value, which determines the best agricultural treatment based on seasonal performance metrics by executing different queries depending on the season value: when p_season equals 'spring', the function joins the treatments table with field_trials table on treatment_id, then joins with performance_metrics table on trial_id, filters for records where season equals 'spring', groups the results by treatment_name, orders by the maximum yield value in descending order, fetches only the top record, and constructs a result string concatenating the treatment_name with the maximum yield prefixed by ' - Yield: '; when p_season equals 'summer', the function performs the same joins and filtering for 'summer' season, groups by treatment_name, orders by the maximum a1_kpct value in descending order, fetches only the top record, and constructs a result string concatenating the treatment_name with the maximum a1_kpct prefixed by ' - Efficiency: '; for any other season value, the function executes the same joins but filters using the provided p_season parameter value, groups by treatment_name, orders by the average yield in descending order, fetches only the top record, and constructs a result string concatenating the treatment_name with the average yield prefixed by ' - Balanced: '; the function stores the constructed result in the local variable v_result and returns this value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_best_treatment(p_season VARCHAR2) RETURN VARCHAR2 IS\n  v_result VARCHAR2(255);\nBEGIN\n  IF p_season = 'spring' THEN\n    SELECT t.treatment_name || ' - Yield: ' || MAX(pm.yield)\n    INTO v_result\n    FROM treatments t \n    JOIN field_trials ft ON t.treatment_id = ft.treatment_id \n    JOIN performance_metrics pm ON ft.trial_id = pm.trial_id \n    WHERE ft.season = 'spring'\n    GROUP BY t.treatment_name\n    ORDER BY MAX(pm.yield) DESC\n    FETCH FIRST 1 ROW ONLY;\n  ELSIF p_season = 'summer' THEN\n    SELECT t.treatment_name || ' - Efficiency: ' || MAX(pm.a1_kpct)\n    INTO v_result\n    FROM treatments t \n    JOIN field_trials ft ON t.treatment_id = ft.treatment_id \n    JOIN performance_metrics pm ON ft.trial_id = pm.trial_id \n    WHERE ft.season = 'summer'\n    GROUP BY t.treatment_name\n    ORDER BY MAX(pm.a1_kpct) DESC\n    FETCH FIRST 1 ROW ONLY;\n  ELSE\n    SELECT t.treatment_name || ' - Balanced: ' || AVG(pm.yield)\n    INTO v_result\n    FROM treatments t \n    JOIN field_trials ft ON t.treatment_id = ft.treatment_id \n    JOIN performance_metrics pm ON ft.trial_id = pm.trial_id \n    WHERE ft.season = p_season\n    GROUP BY t.treatment_name\n    ORDER BY AVG(pm.yield) DESC\n    FETCH FIRST 1 ROW ONLY;\n  END IF;\n  RETURN v_result;\nEND;",
    "database_name": "agricultural_rada_389617",
    "tables": [
      "field_trials",
      "performance_metrics",
      "treatments"
    ],
    "call_sqls": [
      "SELECT get_best_treatment('spring') FROM DUAL",
      "SELECT get_best_treatment('summer') FROM DUAL",
      "SELECT get_best_treatment('fall') FROM DUAL",
      "SELECT get_best_treatment('winter') FROM DUAL",
      "SELECT get_best_treatment('autumn') FROM DUAL",
      "SELECT get_best_treatment('Spring') FROM DUAL",
      "SELECT get_best_treatment('Summer') FROM DUAL",
      "SELECT get_best_treatment('SPRING') FROM DUAL",
      "SELECT get_best_treatment('SUMMER') FROM DUAL",
      "SELECT get_best_treatment('monsoon') FROM DUAL",
      "SELECT get_best_treatment('rainy') FROM DUAL",
      "SELECT get_best_treatment('dry') FROM DUAL",
      "SELECT get_best_treatment('harvest') FROM DUAL",
      "SELECT get_best_treatment('planting') FROM DUAL",
      "SELECT get_best_treatment('2024') FROM DUAL",
      "SELECT get_best_treatment('Q1') FROM DUAL",
      "SELECT get_best_treatment('Q2') FROM DUAL",
      "SELECT get_best_treatment('Q3') FROM DUAL",
      "SELECT get_best_treatment('Q4') FROM DUAL",
      "SELECT get_best_treatment(NULL) FROM DUAL"
    ],
    "id": 15
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_user_status` that accepts a single input parameter, `p_user_id`, which is of data type `NUMBER`. This function is designed to return a `VARCHAR2` value, specifically a string indicating the activity status of a user. Internally, the function declares two local variables: `v_status` of type `VARCHAR2(20)` to store the determined status string, and `v_active` of type `NUMBER` to temporarily hold the activity flag retrieved from the database. The core logic of the function begins by executing a `SELECT` statement to retrieve the `is_active` column's value from the `users` table. This retrieval is conditioned by matching the `user_id` column in the `users` table with the value provided in the `p_user_id` input parameter. The retrieved `is_active` value is then immediately stored into the `v_active` local variable. Following this data retrieval, a conditional `IF` statement evaluates the value of `v_active`. If `v_active` is equal to `1`, the `v_status` variable is assigned the string literal `'Active'`. Otherwise, if `v_active` is not equal to `1` (implying it's `0` or any other value representing inactivity), the `v_status` variable is assigned the string literal `'Inactive'`. Finally, the function concludes by returning the string value stored in the `v_status` variable, which represents the determined activity status of the user identified by `p_user_id`.",
    "plsql": "CREATE OR REPLACE FUNCTION check_user_status(p_user_id NUMBER) RETURN VARCHAR2 IS\n    v_status VARCHAR2(20);\n    v_active NUMBER;\nBEGIN\n    SELECT is_active INTO v_active FROM users WHERE user_id = p_user_id;\n    IF v_active = 1 THEN\n        v_status := 'Active';\n    ELSE\n        v_status := 'Inactive';\n    END IF;\n    RETURN v_status;\nEND;",
    "database_name": "airport_n_analysis",
    "tables": [
      "airports",
      "flights",
      "roles",
      "users"
    ],
    "call_sqls": [
      "SELECT check_user_status(1) FROM dual",
      "SELECT check_user_status(2) FROM dual",
      "SELECT check_user_status(3) FROM dual",
      "SELECT check_user_status(4) FROM dual",
      "SELECT check_user_status(5) FROM dual",
      "SELECT check_user_status(10) FROM dual",
      "SELECT check_user_status(15) FROM dual",
      "SELECT check_user_status(20) FROM dual",
      "SELECT check_user_status(25) FROM dual",
      "SELECT check_user_status(30) FROM dual",
      "SELECT check_user_status(35) FROM dual",
      "SELECT check_user_status(40) FROM dual",
      "SELECT check_user_status(45) FROM dual",
      "SELECT check_user_status(50) FROM dual",
      "SELECT check_user_status(55) FROM dual",
      "SELECT check_user_status(60) FROM dual",
      "SELECT check_user_status(65) FROM dual",
      "SELECT check_user_status(70) FROM dual",
      "SELECT check_user_status(75) FROM dual",
      "SELECT check_user_status(80) FROM dual",
      "SELECT check_user_status(85) FROM dual"
    ],
    "id": 16
  },
  {
    "ir": "Write a PostgreSQL stored procedure named sp that accepts two parameters: para_status_id of type bigint which represents a status identifier, and para_min_replies of type bigint which represents a minimum number of replies threshold. The procedure first declares a variable total_comments of type bigint to store a count value. It then executes a SELECT COUNT(*) query on the comments table to count all rows where the status_id column matches the para_status_id parameter and the reply_count column is greater than or equal to the para_min_replies parameter, storing this count in the total_comments variable. The procedure then evaluates a conditional statement using the sign function applied to the numeric conversion of total_comments to check if the value is positive. If total_comments is positive (indicating there are comments meeting the criteria), the procedure performs an UPDATE operation on the comments table, incrementing the like_count column by 5 for all rows where the status_id equals para_status_id and the parent_comment_id is NULL. If total_comments is not positive (zero or negative), the procedure executes an INSERT operation into the analytics table, inserting a new row with: an analytics_id calculated as the maximum existing analytics_id plus 1 (using COALESCE to handle the case where no rows exist, defaulting to 0), a post_id retrieved from the posts table by selecting the post_id of the most recently created post (ordered by created_at in descending order with LIMIT 1), views set to 0, likes set to 0, shares set to 0, and created_at set to the current timestamp converted to text format.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_status_id bigint, para_min_replies bigint) LANGUAGE plpgsql AS $$ DECLARE total_comments bigint; BEGIN SELECT COUNT(*) INTO total_comments FROM comments WHERE status_id = para_status_id AND reply_count >= para_min_replies; IF sign(total_comments::numeric) = 1 THEN UPDATE comments SET like_count = like_count + 5 WHERE status_id = para_status_id AND parent_comment_id IS NULL; ELSE INSERT INTO analytics (analytics_id, post_id, views, likes, shares, created_at) VALUES ((SELECT COALESCE(MAX(analytics_id), 0) + 1 FROM analytics), (SELECT post_id FROM posts ORDER BY created_at DESC LIMIT 1), 0, 0, 0, CURRENT_TIMESTAMP::text); END IF; END; $$;",
    "database_name": "content_management_system_with_post_and_comment_status_tracking",
    "tables": [
      "posts",
      "comments",
      "users",
      "media",
      "analytics"
    ],
    "call_sqls": [
      "CALL sp(2, 3);",
      "CALL sp(3, 5);",
      "CALL sp(0, 10);",
      "CALL sp(5, 1);",
      "CALL sp(10, 2);",
      "CALL sp(15, 0);",
      "CALL sp(20, 3);",
      "CALL sp(25, 4);",
      "CALL sp(30, 1);",
      "CALL sp(35, 2);",
      "CALL sp(40, 5);",
      "CALL sp(45, 3);",
      "CALL sp(50, 0);",
      "CALL sp(55, 1);",
      "CALL sp(60, 2);",
      "CALL sp(65, 10);",
      "CALL sp(70, 1);"
    ],
    "id": 17
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_user_access_info that accepts two input parameters: a NUMBER parameter named p_user_id which represents the user identifier to search for, and a VARCHAR2 parameter named p_access_date which represents the specific access date to filter on, and returns a VARCHAR2 string; within the function, it declares a local VARCHAR2 variable v_access_info with a maximum length of 255 characters to hold the result; the function executes a SELECT statement that queries the access_logs table, specifically concatenating the value from the action column with the literal string ' from ' and then with the value from the ip_address column, and stores this concatenated result into the v_access_info variable; this SELECT operation is performed under the condition that the user_id column in the access_logs table must exactly equal the provided p_user_id input parameter and the access_date column must exactly equal the provided p_access_date input parameter; the function then returns the value stored in v_access_info; if the SELECT statement finds no rows that satisfy the specified conditions, a NO_DATA_FOUND exception is handled by returning the literal string 'No access record found'; if the SELECT statement finds more than one row that satisfies the conditions, a TOO_MANY_ROWS exception is handled by returning the literal string 'Multiple access records found'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_access_info(p_user_id NUMBER, p_access_date VARCHAR2) RETURN VARCHAR2 IS\n  v_access_info VARCHAR2(255);\nBEGIN\n  SELECT action || ' from ' || ip_address \n    INTO v_access_info \n    FROM access_logs \n   WHERE user_id = p_user_id \n     AND access_date = p_access_date;\n  RETURN v_access_info;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN 'No access record found';\n  WHEN TOO_MANY_ROWS THEN\n    RETURN 'Multiple access records found';\nEND;",
    "database_name": "api_rla_monitoring",
    "tables": [
      "access_logs",
      "errors",
      "error_codes",
      "extra_info",
      "process_times",
      "users",
      "http_status_codes"
    ],
    "call_sqls": [
      "SELECT get_user_access_info(1, '2023-10-01') FROM dual",
      "SELECT get_user_access_info(2, '2023-10-02') FROM dual",
      "SELECT get_user_access_info(3, '2023-10-03') FROM dual",
      "SELECT get_user_access_info(4, '2023-10-04') FROM dual",
      "SELECT get_user_access_info(5, '2023-10-05') FROM dual",
      "SELECT get_user_access_info(6, '2023-10-06') FROM dual",
      "SELECT get_user_access_info(7, '2023-10-07') FROM dual",
      "SELECT get_user_access_info(8, '2023-10-08') FROM dual",
      "SELECT get_user_access_info(9, '2023-10-09') FROM dual",
      "SELECT get_user_access_info(10, '2023-10-10') FROM dual",
      "SELECT get_user_access_info(101, '2023-11-15') FROM dual",
      "SELECT get_user_access_info(202, '2023-12-25') FROM dual",
      "SELECT get_user_access_info(0, '2023-01-01') FROM dual",
      "SELECT get_user_access_info(25, '2024-02-14') FROM dual",
      "SELECT get_user_access_info(50, '2024-03-08') FROM dual",
      "SELECT get_user_access_info(100, '2024-04-22') FROM dual",
      "SELECT get_user_access_info(150, '2024-05-30') FROM dual",
      "SELECT get_user_access_info(999, '2024-06-01') FROM dual",
      "SELECT get_user_access_info(42, '2024-07-04') FROM dual",
      "SELECT get_user_access_info(77, '2024-08-21') FROM dual"
    ],
    "id": 18
  },
  {
    "ir": "Write a PLpgSQL function that returns a table with two columns, total_runs and total_hits, both of type BIGINT, by calculating the sum of runs and hits from the player_games table for a specific game identified by the input parameter game_id_input of type BIGINT. The function begins by executing a RETURN QUERY statement, which performs a SELECT operation on the player_games table. It retrieves the sum of the runs column and the sum of the hits column, both of which are cast to BIGINT using the ::BIGINT syntax to ensure the correct data type. The COALESCE function is used to handle any NULL values that might result from the SUM operation, replacing them with 0 if no runs or hits are found for the specified game_id. The WHERE clause filters the rows in the player_games table to include only those where the game_id column matches the value of the game_id_input parameter. This ensures that the function calculates the total runs and hits specifically for the game identified by game_id_input.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_game_summary(game_id_input BIGINT)\nRETURNS TABLE(total_runs BIGINT, total_hits BIGINT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT COALESCE(SUM(runs)::BIGINT, 0), COALESCE(SUM(hits)::BIGINT, 0)\n    FROM player_games\n    WHERE game_id = game_id_input;\nEND;\n$$;",
    "database_name": "baseball_player_performance_statistics_195253",
    "tables": [
      "games",
      "player_games"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_game_summary(0);",
      "SELECT * FROM calculate_game_summary(1);",
      "SELECT * FROM calculate_game_summary(2);",
      "SELECT * FROM calculate_game_summary(3);",
      "SELECT * FROM calculate_game_summary(4);",
      "SELECT * FROM calculate_game_summary(5);",
      "SELECT * FROM calculate_game_summary(6);",
      "SELECT * FROM calculate_game_summary(7);",
      "SELECT * FROM calculate_game_summary(8);",
      "SELECT * FROM calculate_game_summary(9);",
      "SELECT * FROM calculate_game_summary(10);",
      "SELECT * FROM calculate_game_summary(11);",
      "SELECT * FROM calculate_game_summary(12);",
      "SELECT * FROM calculate_game_summary(13);",
      "SELECT * FROM calculate_game_summary(14);",
      "SELECT * FROM calculate_game_summary(15);",
      "SELECT * FROM calculate_game_summary(16);",
      "SELECT * FROM calculate_game_summary(17);",
      "SELECT * FROM calculate_game_summary(18);",
      "SELECT * FROM calculate_game_summary(19);",
      "SELECT * FROM calculate_game_summary(20);"
    ],
    "id": 19
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_regulatory_status` that takes a single input parameter `p_modality_id` of type `NUMBER`, representing the identifier of a modality, and returns a value of type `VARCHAR2` that indicates the regulatory status of the modality based on its earliest approval year. The function begins by declaring a local variable `v_earliest_approval` of type `VARCHAR2(255)` to store the earliest approval year associated with the given modality. It then executes a `SELECT` statement to retrieve the minimum value of the `approval_year` column from the `fda_regulatory` table, where the `modality_id` column matches the value of the input parameter `p_modality_id`. The result of this query is stored in the `v_earliest_approval` variable. The function then evaluates the value of `v_earliest_approval` using a series of conditional statements (`IF`, `ELSIF`, `ELSE`) to determine the regulatory status. If the earliest approval year, converted to a date using the `TO_DATE` function with the format `'YYYY-MM-DD'`, is earlier than January 1, 1980, the function returns the string `'LEGACY_APPROVAL'`. If the earliest approval year is between January 1, 1980, and December 31, 1989, the function returns `'ESTABLISHED_APPROVAL'`. If the earliest approval year is between January 1, 1990, and December 31, 1999, the function returns `'MODERN_APPROVAL'`. For any earliest approval year on or after January 1, 2000, the function returns `'RECENT_APPROVAL'`. The function uses the `TO_DATE` function to ensure proper date comparison and relies on the `MIN` aggregate function in the `SELECT` statement to identify the earliest approval year for the specified modality.",
    "plsql": "CREATE OR REPLACE FUNCTION get_regulatory_status(p_modality_id NUMBER) RETURN VARCHAR2 IS\n    v_earliest_approval VARCHAR2(255);\nBEGIN\n    SELECT MIN(approval_year) INTO v_earliest_approval FROM fda_regulatory WHERE modality_id = p_modality_id;\n    IF TO_DATE(v_earliest_approval, 'YYYY-MM-DD') < TO_DATE('1980-01-01', 'YYYY-MM-DD') THEN RETURN 'LEGACY_APPROVAL';\n    ELSIF TO_DATE(v_earliest_approval, 'YYYY-MM-DD') < TO_DATE('1990-01-01', 'YYYY-MM-DD') THEN RETURN 'ESTABLISHED_APPROVAL';\n    ELSIF TO_DATE(v_earliest_approval, 'YYYY-MM-DD') < TO_DATE('2000-01-01', 'YYYY-MM-DD') THEN RETURN 'MODERN_APPROVAL';\n    ELSE RETURN 'RECENT_APPROVAL';\n    END IF;\nEND;",
    "database_name": "breast_cdmar_milestones",
    "tables": [
      "access_logs",
      "analytics",
      "modalities",
      "cms_coverage",
      "fda_regulatory",
      "nccn_guidelines"
    ],
    "call_sqls": [
      "SELECT get_regulatory_status(0) FROM dual",
      "SELECT get_regulatory_status(1) FROM dual",
      "SELECT get_regulatory_status(2) FROM dual",
      "SELECT get_regulatory_status(3) FROM dual",
      "SELECT get_regulatory_status(4) FROM dual",
      "SELECT get_regulatory_status(5) FROM dual",
      "SELECT get_regulatory_status(6) FROM dual",
      "SELECT get_regulatory_status(7) FROM dual",
      "SELECT get_regulatory_status(8) FROM dual",
      "SELECT get_regulatory_status(9) FROM dual",
      "SELECT get_regulatory_status(10) FROM dual",
      "SELECT get_regulatory_status(11) FROM dual",
      "SELECT get_regulatory_status(12) FROM dual",
      "SELECT get_regulatory_status(13) FROM dual",
      "SELECT get_regulatory_status(14) FROM dual",
      "SELECT get_regulatory_status(15) FROM dual",
      "SELECT get_regulatory_status(16) FROM dual",
      "SELECT get_regulatory_status(17) FROM dual",
      "SELECT get_regulatory_status(18) FROM dual",
      "SELECT get_regulatory_status(19) FROM dual"
    ],
    "id": 20
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named 'sp' that accepts four input parameters: para_user_id of type bigint representing a user identifier, para_email of type text representing an email address, para_is_email_verified of type bigint representing the email verification status, and para_is_phone_verified of type bigint representing the phone verification status; the procedure begins by declaring a local integer variable named user_count, then executes a SELECT statement to query the \"users\" table, counting all rows where the \"user_id\" column equals the para_user_id parameter, the \"email\" column equals the para_email parameter, the \"is_email_verified\" column equals the para_is_email_verified parameter, and the \"is_phone_verified\" column equals the para_is_phone_verified parameter, storing the result of this count into the user_count variable; following this query, a conditional IF statement checks if the user_count variable is equal to 0, and if this condition is true, it performs an INSERT operation into the \"users\" table, creating a new row with the \"user_id\" column set to the para_user_id parameter value, the \"email\" column set to the para_email parameter value, the \"is_email_verified\" column set to the para_is_email_verified parameter value, and the \"is_phone_verified\" column set to the para_is_phone_verified parameter value.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_user_id bigint, para_email text, para_is_email_verified bigint, para_is_phone_verified bigint) LANGUAGE plpgsql AS $$ DECLARE user_count integer; BEGIN SELECT COUNT(*) INTO user_count FROM \"users\" WHERE \"user_id\" = para_user_id AND \"email\" = para_email AND \"is_email_verified\" = para_is_email_verified AND \"is_phone_verified\" = para_is_phone_verified; IF user_count = 0 THEN INSERT INTO \"users\" (\"user_id\", \"email\", \"is_email_verified\", \"is_phone_verified\") VALUES (para_user_id, para_email, para_is_email_verified, para_is_phone_verified); END IF; END; $$;",
    "database_name": "crowdfunding_campaigns_and_projects",
    "tables": [
      "projects",
      "users"
    ],
    "call_sqls": [
      "CALL sp(1001, 'john.doe@example.com', 1, 1);",
      "CALL sp(1002, 'jane.smith@example.com', 1, 0);",
      "CALL sp(1003, 'alice.jones@example.com', 0, 1);",
      "CALL sp(1004, 'bob.brown@example.com', 0, 0);",
      "CALL sp(2000, 'new.user@example.com', 1, 1);",
      "CALL sp(2001, 'test.user@example.com', 0, 1);",
      "CALL sp(2002, 'creator.one@example.com', 1, 0);",
      "CALL sp(2003, 'backer.two@example.com', 0, 0);",
      "CALL sp(3000, 'verified.both@example.com', 1, 1);",
      "CALL sp(3001, 'phone.only@example.com', 0, 1);",
      "CALL sp(3002, 'email.only@example.com', 1, 0);",
      "CALL sp(3003, 'no.verification@example.com', 0, 0);",
      "CALL sp(4000, 'project.owner@example.com', 1, 1);",
      "CALL sp(4001, 'campaign.manager@example.com', 1, 0);",
      "CALL sp(4002, 'supporter@example.com', 0, 1);",
      "CALL sp(4003, 'admin.user@example.com', 1, 1);",
      "CALL sp(5000, 'unique.email@example.com', 1, 1);",
      "CALL sp(5001, 'another.unique@example.com', 0, 1);",
      "CALL sp(5002, 'final.test@example.com', 1, 0);"
    ],
    "id": 21
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `insert_author_with_random_affiliation` that accepts six input parameters: `p_first_name` of type `text` representing the author's first name, `p_last_name` of type `text` representing the author's last name, `p_email` of type `text` representing the author's email address, `p_gender` of type `text` representing the author's gender, `p_date_of_birth` of type `text` representing the author's date of birth, and `p_biography` of type `text` representing the author's biographical information. The procedure begins by declaring two local variables: `v_author_id` of type `bigint` to store the newly generated author identifier, and `v_affiliation_id` of type `bigint` to store a randomly generated affiliation identifier. The first operation within the procedure is to determine the `v_author_id`. This is achieved by executing a `SELECT` statement that queries the `authors` table. Specifically, it calculates the maximum value of the `author_id` column. The `COALESCE` function is used to handle cases where the `authors` table might be empty, in which case `MAX(author_id)` would return `NULL`, and `COALESCE` would substitute `0`. This result is then incremented by `1` to ensure a unique `author_id` for the new author, and the final value is assigned to `v_author_id`. Concurrently, the `v_affiliation_id` is generated by first calling the `random()` function, which returns a floating-point value between 0.0 (inclusive) and 1.0 (exclusive). This random value is then multiplied by `1000`. The `floor()` function is applied to this product to round it down to the nearest whole number. Finally, the result is explicitly cast to `bigint` and assigned to `v_affiliation_id`. Following the generation of these identifiers, the procedure performs an `INSERT` operation into the `authors` table. The `author_id` column is populated with the value from `v_author_id`. The `first_name` column receives the value from the `p_first_name` parameter. The `last_name` column receives the value from the `p_last_name` parameter. The `email` column receives the value from the `p_email` parameter. The `gender` column receives the value from the `p_gender` parameter. The `date_of_birth` column receives the value from the `p_date_of_birth` parameter. The `biography` column receives the value from the `p_biography` parameter. The `created_at` column is set to the current timestamp using `CURRENT_TIMESTAMP`. The `updated_at` column is also set to the current timestamp using `CURRENT_TIMESTAMP`. The `version` column is set to the literal value `1`. Immediately after inserting the author record, a second `INSERT` operation is performed into the `author_affiliations` table. The `author_id` column is populated with the value from `v_author_id`. The `affiliation_id` column is populated with the value from `v_affiliation_id`. The `start_date` column is set to the current date using `CURRENT_DATE`. The `end_date` column is set to `NULL`, indicating an ongoing affiliation. The `position` column is set to the literal string `'New Hire'`. The `created_at` column is set to the current timestamp using `CURRENT_TIMESTAMP`. The `updated_at` column is also set to the current timestamp using `CURRENT_TIMESTAMP`.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_author_with_random_affiliation(p_first_name text, p_last_name text, p_email text, p_gender text, p_date_of_birth text, p_biography text) LANGUAGE plpgsql AS $$\nDECLARE\n  v_author_id bigint;\n  v_affiliation_id bigint;\nBEGIN\n  SELECT COALESCE(MAX(author_id), 0) + 1 INTO v_author_id FROM authors;\n  v_affiliation_id := floor(random() * 1000)::bigint;\n  \n  INSERT INTO authors (author_id, first_name, last_name, email, gender, date_of_birth, biography, created_at, updated_at, version)\n  VALUES (v_author_id, p_first_name, p_last_name, p_email, p_gender, p_date_of_birth, p_biography, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 1);\n  \n  INSERT INTO author_affiliations (author_id, affiliation_id, start_date, end_date, position, created_at, updated_at)\n  VALUES (v_author_id, v_affiliation_id, CURRENT_DATE, NULL, 'New Hire', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);\nEND;\n$$;",
    "database_name": "academic_author_and_affiliation_management",
    "tables": [
      "author_affiliations",
      "authors"
    ],
    "call_sqls": [
      "CALL insert_author_with_random_affiliation('John', 'Doe', 'john.doe@email.com', 'Male', '1990-05-15', 'John Doe is a prolific writer...');",
      "CALL insert_author_with_random_affiliation('Jane', 'Smith', 'jane.smith@email.com', 'Female', '1985-08-22', 'Jane Smith specializes in modern literature.');",
      "CALL insert_author_with_random_affiliation('Robert', 'Johnson', 'robert.j@email.com', 'Male', '1978-11-30', 'Robert Johnson has published over 50 novels.');",
      "CALL insert_author_with_random_affiliation('Emily', 'Davis', 'emily.davis@email.com', 'Female', '1992-03-10', 'Emily Davis is an award-winning poet.');",
      "CALL insert_author_with_random_affiliation('Michael', 'Brown', 'm.brown@email.com', 'Male', '1980-12-05', 'Michael Brown writes historical fiction.');",
      "CALL insert_author_with_random_affiliation('Sarah', 'Wilson', 'sarah.w@email.com', 'Female', '1995-07-18', 'Sarah Wilson is a rising star in sci-fi.');",
      "CALL insert_author_with_random_affiliation('David', 'Miller', 'd.miller@email.com', 'Male', '1975-01-25', 'David Miller is a renowned journalist.');",
      "CALL insert_author_with_random_affiliation('Lisa', 'Taylor', 'lisa.t@email.com', 'Female', '1988-09-14', 'Lisa Taylor authors bestselling mysteries.');",
      "CALL insert_author_with_random_affiliation('James', 'Anderson', 'j.anderson@email.com', 'Male', '1991-04-08', 'James Anderson focuses on technical writing.');",
      "CALL insert_author_with_random_affiliation('Amanda', 'Thomas', 'a.thomas@email.com', 'Female', '1983-06-12', 'Amanda Thomas writes children''s books.');",
      "CALL insert_author_with_random_affiliation('Christopher', 'Lee', 'chris.lee@email.com', 'Male', '1970-10-03', 'Christopher Lee is a veteran editor.');",
      "CALL insert_author_with_random_affiliation('Jessica', 'White', 'j.white@email.com', 'Female', '1993-02-28', 'Jessica White is a travel writer.');",
      "CALL insert_author_with_random_affiliation('Daniel', 'Harris', 'd.harris@email.com', 'Male', '1987-07-07', 'Daniel Harris writes political commentary.');",
      "CALL insert_author_with_random_affiliation('Megan', 'Martin', 'm.martin@email.com', 'Female', '1994-11-19', 'Megan Martin is a food critic.');",
      "CALL insert_author_with_random_affiliation('Kevin', 'Thompson', 'k.thompson@email.com', 'Male', '1982-08-09', 'Kevin Thompson authors self-help books.');",
      "CALL insert_author_with_random_affiliation('Rachel', 'Garcia', 'r.garcia@email.com', 'Female', '1979-05-23', 'Rachel Garcia writes romance novels.');",
      "CALL insert_author_with_random_affiliation('Brian', 'Martinez', 'b.martinez@email.com', 'Male', '1996-12-15', 'Brian Martinez is a new fantasy author.');",
      "CALL insert_author_with_random_affiliation('Lauren', 'Robinson', 'l.robinson@email.com', 'Female', '1986-04-01', 'Lauren Robinson specializes in biographies.');",
      "CALL insert_author_with_random_affiliation('Steven', 'Clark', 's.clark@email.com', 'Male', '1972-09-27', 'Steven Clark is an academic researcher.');",
      "CALL insert_author_with_random_affiliation('Nicole', 'Lewis', 'n.lewis@email.com', 'Female', '1990-10-11', 'Nicole Lewis writes short stories.');"
    ],
    "id": 22
  },
  {
    "ir": "Write a PLpgSQL function named manage_weather_events that accepts three input parameters: para_year of type bigint to specify a calendar year, para_region_id of type bigint to specify a geographic region identifier, and para_severity of type text to specify a severity level, and performs conditional operations on the weather_events table based on the value of the para_severity parameter; if the para_severity parameter value is exactly equal to the string 'high', the function executes an UPDATE statement on the weather_events table, setting the severity column to the new string value 'critical' for every row where the year column value matches the para_year parameter and the region_id column value matches the para_region_id parameter; if the para_severity parameter value is exactly equal to the string 'moderate', the function executes a different UPDATE statement on the weather_events table, setting the severity column to the new string value 'high' for every row where the year column value matches the para_year parameter and the region_id column value matches the para_region_id parameter; if the para_severity parameter value is any other string besides 'high' or 'moderate', the function executes a DELETE statement on the weather_events table, removing all rows where the year column value matches the para_year parameter and the region_id column value matches the para_region_id parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION manage_weather_events(para_year bigint, para_region_id bigint, para_severity text) RETURNS void LANGUAGE plpgsql AS $$\nBEGIN\n    IF para_severity = 'high' THEN\n        UPDATE weather_events\n        SET severity = 'critical'\n        WHERE year = para_year AND region_id = para_region_id;\n    ELSIF para_severity = 'moderate' THEN\n        UPDATE weather_events\n        SET severity = 'high'\n        WHERE year = para_year AND region_id = para_region_id;\n    ELSE\n        DELETE FROM weather_events\n        WHERE year = para_year AND region_id = para_region_id;\n    END IF;\nEND;\n$$;",
    "database_name": "agricultural_data_analysis_and_food_production_forecasting",
    "tables": [
      "access_logs",
      "agricultural_data",
      "crop_types",
      "food_production",
      "predictions",
      "regions",
      "users",
      "weather_events"
    ],
    "call_sqls": [
      "SELECT manage_weather_events(1956, 0, 'high');",
      "SELECT manage_weather_events(1957, 1, 'moderate');",
      "SELECT manage_weather_events(1958, 2, 'low');",
      "SELECT manage_weather_events(1959, 0, 'high');",
      "SELECT manage_weather_events(1960, 1, 'moderate');",
      "SELECT manage_weather_events(1961, 3, 'high');",
      "SELECT manage_weather_events(1962, 2, 'moderate');",
      "SELECT manage_weather_events(1956, 1, 'other');",
      "SELECT manage_weather_events(1957, 0, 'low');",
      "SELECT manage_weather_events(1963, 4, 'high');",
      "SELECT manage_weather_events(1964, 5, 'moderate');",
      "SELECT manage_weather_events(1965, 3, 'unknown');",
      "SELECT manage_weather_events(1958, 1, 'high');",
      "SELECT manage_weather_events(1959, 2, 'moderate');",
      "SELECT manage_weather_events(1960, 0, 'severe');",
      "SELECT manage_weather_events(1961, 4, 'high');",
      "SELECT manage_weather_events(1962, 5, 'moderate');",
      "SELECT manage_weather_events(1963, 0, 'minor');",
      "SELECT manage_weather_events(1964, 2, 'high');",
      "SELECT manage_weather_events(1965, 1, 'moderate');"
    ],
    "id": 23
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named process_error_batch that accepts two input parameters: a bigint parameter named p_transaction_id and a text parameter named p_status, and returns an integer value representing the number of rows processed; the function begins by declaring a local integer variable named processed_count initialized to zero, then checks the value of the p_status parameter: if p_status is exactly equal to the string 'resolved', it executes an UPDATE operation on the error_instances table, setting the resolution_date column to the current date cast to text for all rows where the transaction_id column matches the p_transaction_id parameter and the resolution_status column is exactly equal to 'pending'; if p_status is exactly equal to the string 'pending', it executes an UPDATE operation on the error_instances table, setting the resolution_date column to NULL for all rows where the transaction_id column matches the p_transaction_id parameter and the resolution_status column is exactly equal to 'resolved'; for any other value of p_status, it executes an UPDATE operation on the error_instances table, setting the resolution_status column to 'pending' for all rows where the transaction_id column matches the p_transaction_id parameter; after the conditional UPDATE, the function uses the GET DIAGNOSTICS command to assign the number of rows affected by the most recent SQL statement (the ROW_COUNT) into the processed_count variable, and finally returns the value of the processed_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION process_error_batch(p_transaction_id bigint, p_status text) RETURNS integer LANGUAGE plpgsql AS $$ DECLARE processed_count integer := 0; BEGIN IF p_status = 'resolved' THEN UPDATE error_instances SET resolution_date = CURRENT_DATE::text WHERE transaction_id = p_transaction_id AND resolution_status = 'pending'; ELSIF p_status = 'pending' THEN UPDATE error_instances SET resolution_date = NULL WHERE transaction_id = p_transaction_id AND resolution_status = 'resolved'; ELSE UPDATE error_instances SET resolution_status = 'pending' WHERE transaction_id = p_transaction_id; END IF; GET DIAGNOSTICS processed_count = ROW_COUNT; RETURN processed_count; END; $$;",
    "database_name": "bank_transaction_error_management",
    "tables": [
      "error_instances"
    ],
    "call_sqls": [
      "SELECT process_error_batch(100, 'resolved');",
      "SELECT process_error_batch(101, 'pending');",
      "SELECT process_error_batch(102, 'invalid');",
      "SELECT process_error_batch(0, 'resolved');",
      "SELECT process_error_batch(0, 'pending');",
      "SELECT process_error_batch(1, 'resolved');",
      "SELECT process_error_batch(1, 'pending');",
      "SELECT process_error_batch(500, 'resolved');",
      "SELECT process_error_batch(750, 'pending');",
      "SELECT process_error_batch(999, 'other_status');",
      "SELECT process_error_batch(12345, 'resolved');",
      "SELECT process_error_batch(54321, 'pending');",
      "SELECT process_error_batch(98765, 'unknown');",
      "SELECT process_error_batch(1000, 'resolved');",
      "SELECT process_error_batch(2000, 'pending');",
      "SELECT process_error_batch(3000, 'RESOLVED');",
      "SELECT process_error_batch(4000, 'PENDING');",
      "SELECT process_error_batch(5555, 'resolved');",
      "SELECT process_error_batch(6666, 'pending');",
      "SELECT process_error_batch(7777, 'test');"
    ],
    "id": 24
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_avg_response_time` that accepts one input parameter, `p_product_id`, which is of data type `NUMBER` and represents the unique identifier for a product. This function is designed to return a `VARCHAR2` string, which will contain a descriptive message about the average response time for complaints related to the specified product.\n\nInternally, the function declares two local variables: `v_avg_days` of data type `NUMBER`, intended to store the calculated average difference in days, and `v_result` of data type `VARCHAR2` with a maximum length of 100 characters, intended to store the final descriptive string to be returned.\n\nThe core logic begins by executing a `SELECT` statement to calculate the average response time. This `SELECT` statement queries the `complaints` table. It calculates the average difference between the `resolution_date` and `date_received` columns. Before performing the subtraction, both `resolution_date` and `date_received` are explicitly converted from their current data type (presumably `VARCHAR2` or `CHAR` given the `TO_DATE` function call) to `DATE` data types using the `TO_DATE` function with the format mask `'YYYY-MM-DD'`. The result of this average calculation, which represents the average number of days, is then stored into the `v_avg_days` local variable. This calculation is performed only for rows in the `complaints` table where the `product_id` column matches the value provided by the input parameter `p_product_id`, and where the `resolution_date` column is not `NULL`, ensuring that only resolved complaints are considered for the average calculation.\n\nFollowing the data retrieval, the function proceeds with conditional logic. It first checks if the `v_avg_days` variable is `NULL`. This condition would be true if the `SELECT` statement did not find any matching complaints (i.e., no complaints for the given `p_product_id` with a non-`NULL` `resolution_date`). If `v_avg_days` is `NULL`, the `v_result` variable is assigned the string literal `'No data available'`.\n\nIf `v_avg_days` is not `NULL`, the function enters a nested conditional block. It checks if the value of `v_avg_days` is greater than `30`. If `v_avg_days` is indeed greater than `30`, indicating a high average response time, the `v_result` variable is constructed by concatenating the string literal `'High: '` with the result of the `NUMTODSINTERVAL` function. The `NUMTODSINTERVAL` function converts the numeric value of `v_avg_days` into an `INTERVAL DAY TO SECOND` data type, with `DAY` specified as the unit, effectively formatting the number of days into a more readable interval string. If `v_avg_days` is not greater than `30` (meaning it is `30` or less), indicating a normal average response time, the `v_result` variable is constructed by concatenating the string literal `'Normal: '` with the result of the `NUMTODSINTERVAL` function, again converting `v_avg_days` into an `INTERVAL DAY TO SECOND` string.\n\nFinally, the function returns the value stored in the `v_result` variable, which will be either 'No data available', 'High: ' followed by the interval, or 'Normal: ' followed by the interval.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_avg_response_time(p_product_id IN NUMBER) RETURN VARCHAR2 IS\n    v_avg_days NUMBER;\n    v_result VARCHAR2(100);\nBEGIN\n    SELECT AVG(TO_DATE(resolution_date, 'YYYY-MM-DD') - TO_DATE(date_received, 'YYYY-MM-DD')) INTO v_avg_days\n    FROM complaints\n    WHERE product_id = p_product_id AND resolution_date IS NOT NULL;\n    \n    IF v_avg_days IS NULL THEN\n        v_result := 'No data available';\n    ELSE\n        IF v_avg_days > 30 THEN\n            v_result := 'High: ' || NUMTODSINTERVAL(v_avg_days, 'DAY');\n        ELSE\n            v_result := 'Normal: ' || NUMTODSINTERVAL(v_avg_days, 'DAY');\n        END IF;\n    END IF;\n    \n    RETURN v_result;\nEND;",
    "database_name": "consumer_fcm_407801",
    "tables": [
      "complaints",
      "products"
    ],
    "call_sqls": [
      "SELECT calculate_avg_response_time(0) FROM dual",
      "SELECT calculate_avg_response_time(1) FROM dual",
      "SELECT calculate_avg_response_time(2) FROM dual",
      "SELECT calculate_avg_response_time(10) FROM dual",
      "SELECT calculate_avg_response_time(15) FROM dual",
      "SELECT calculate_avg_response_time(25) FROM dual",
      "SELECT calculate_avg_response_time(30) FROM dual",
      "SELECT calculate_avg_response_time(45) FROM dual",
      "SELECT calculate_avg_response_time(50) FROM dual",
      "SELECT calculate_avg_response_time(100) FROM dual",
      "SELECT calculate_avg_response_time(200) FROM dual",
      "SELECT calculate_avg_response_time(500) FROM dual",
      "SELECT calculate_avg_response_time(1000) FROM dual",
      "SELECT calculate_avg_response_time(NULL) FROM dual",
      "SELECT product_id, calculate_avg_response_time(product_id) FROM products WHERE product_id = 0",
      "SELECT product_id, calculate_avg_response_time(product_id) FROM products WHERE product_id = 1",
      "SELECT product_id, calculate_avg_response_time(product_id) FROM products WHERE product_id = 2",
      "SELECT p.product_id, p.product_name, calculate_avg_response_time(p.product_id) FROM products p",
      "SELECT calculate_avg_response_time(c.product_id) FROM complaints c WHERE c.complaint_id = 0",
      "SELECT calculate_avg_response_time(c.product_id) FROM complaints c WHERE c.complaint_id = 1"
    ],
    "id": 25
  },
  {
    "ir": "Write a PL/pgSQL function named count_adverse_events_by_gender that accepts a single input parameter p_gender of type text and returns a bigint value, which first declares a local variable event_count of type bigint, then executes a SELECT COUNT(*) query that joins the protocol_data table (aliased as pd) with the patients table (aliased as p) using the join condition pd.subject_id = p.subject_id, filtering the results to include only records where p.gender equals the input parameter p_gender AND pd.adverse_events is not equal to 'No adverse events', storing the resulting count in the event_count variable, and finally implementing a conditional logic where if event_count is greater than 10, the function returns event_count multiplied by 2, otherwise it returns the original event_count value.",
    "plsql": "CREATE OR REPLACE FUNCTION count_adverse_events_by_gender(p_gender text)\nRETURNS bigint AS $$\nDECLARE\n    event_count bigint;\nBEGIN\n    SELECT COUNT(*)\n    INTO event_count\n    FROM protocol_data pd\n    JOIN patients p ON pd.subject_id = p.subject_id\n    WHERE p.gender = p_gender AND pd.adverse_events != 'No adverse events';\n    \n    IF event_count > 10 THEN\n        RETURN event_count * 2;\n    ELSE\n        RETURN event_count;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "clinical_trial_management_and_analysis",
    "tables": [
      "patients",
      "patient_visits",
      "protocol_data",
      "audit_logs"
    ],
    "call_sqls": [
      "SELECT count_adverse_events_by_gender('Male');",
      "SELECT count_adverse_events_by_gender('Female');",
      "SELECT count_adverse_events_by_gender('M');",
      "SELECT count_adverse_events_by_gender('F');",
      "SELECT count_adverse_events_by_gender('Other');",
      "SELECT count_adverse_events_by_gender('male');",
      "SELECT count_adverse_events_by_gender('female');",
      "SELECT count_adverse_events_by_gender('MALE');",
      "SELECT count_adverse_events_by_gender('FEMALE');",
      "SELECT count_adverse_events_by_gender('Non-binary');",
      "SELECT count_adverse_events_by_gender('Unknown');",
      "SELECT count_adverse_events_by_gender('Prefer not to say');",
      "SELECT count_adverse_events_by_gender('Man');",
      "SELECT count_adverse_events_by_gender('Woman');",
      "SELECT count_adverse_events_by_gender('Boy');",
      "SELECT count_adverse_events_by_gender('Girl');",
      "SELECT count_adverse_events_by_gender('Transgender male');",
      "SELECT count_adverse_events_by_gender('Transgender female');",
      "SELECT count_adverse_events_by_gender('Genderqueer');",
      "SELECT count_adverse_events_by_gender('Genderfluid');"
    ],
    "id": 26
  },
  {
    "ir": "Write a PostgreSQL database schema definition that first creates a table named \"Documents\" if it does not already exist. This \"Documents\" table is designed to store information about various documents. It includes a column named \"document_id\" of type BIGINT, which serves as the primary key and cannot be null, uniquely identifying each document. It also contains a column named \"document_status_code\" of type TEXT, intended to store the current status of a document. Another column, \"document_type_code\" of type TEXT, is for categorizing the type of document. A \"shipping_agent_code\" column of type TEXT is included to store information about the shipping agent associated with the document. The \"receipt_date\" column, of type TIMESTAMP WITH TIME ZONE, records the date and time when the document was received, including timezone information. A \"receipt_number\" column of type TEXT stores a unique identifier for the receipt. Finally, an \"other_details\" column of type TEXT is provided for any additional descriptive information about the document.\n\nFollowing the creation of the \"Documents\" table, the schema definition proceeds to create another table named \"Document_Summary\" if it does not already exist. This \"Document_Summary\" table is designed to store summarized information related to documents. It includes a column named \"summary_id\" of type BIGSERIAL, which serves as the primary key and automatically generates unique, sequential numbers for each summary record. It also contains a column named \"document_id\" of type BIGINT, which cannot be null, serving as a foreign key reference to the \"document_id\" in the \"Documents\" table, linking a summary to its corresponding document. Similar to the \"Documents\" table, it includes \"document_status_code\" of type TEXT, \"document_type_code\" of type TEXT, \"shipping_agent_code\" of type TEXT, \"receipt_date\" of type TIMESTAMP WITH TIME ZONE, and \"receipt_number\" of type TEXT, all intended to mirror relevant information from the \"Documents\" table for summary purposes. Additionally, it has a \"summary_text\" column of type TEXT, which will store a generated textual summary. Lastly, a \"created_at\" column of type TIMESTAMP WITH TIME ZONE is included, which automatically defaults to the current timestamp with timezone information when a new record is inserted, indicating when the summary was created.\n\nAfter defining the tables, the schema then defines a PL/pgSQL function named `trg_insert_document_summary`. This function is designed to be executed as a trigger. It does not accept any explicit parameters but operates on the `NEW` record, which represents the row being inserted into the \"Documents\" table. The function's purpose is to insert a new row into the \"Document_Summary\" table. Specifically, it populates the \"document_id\" column in \"Document_Summary\" with the value from `NEW.\"document_id\"`, the \"document_status_code\" column with the value from `NEW.\"document_status_code\"`, the \"document_type_code\" column with the value from `NEW.\"document_type_code\"`, the \"shipping_agent_code\" column with the value from `NEW.\"shipping_agent_code\"`, the \"receipt_date\" column with the value from `NEW.\"receipt_date\"`, and the \"receipt_number\" column with the value from `NEW.\"receipt_number\"`. For the \"summary_text\" column, it concatenates the literal string 'Summary: ' with the value from `NEW.\"document_status_code\"`. After performing this insertion, the function returns the `NEW` record, allowing the original `INSERT` operation on the \"Documents\" table to proceed.\n\nFinally, the schema defines a trigger named `trigger_insert_document_summary`. This trigger is configured to activate `AFTER INSERT` operations on the \"Documents\" table. It is set to execute `FOR EACH ROW`, meaning that for every single row inserted into the \"Documents\" table, the `trg_insert_document_summary()` function will be executed. This ensures that a corresponding summary record is automatically created in the \"Document_Summary\" table whenever a new document is added to the \"Documents\" table.",
    "plsql": "CREATE TABLE IF NOT EXISTS \"Documents\" (\n    \"document_id\" BIGINT PRIMARY KEY NOT NULL,\n    \"document_status_code\" TEXT,\n    \"document_type_code\" TEXT,\n    \"shipping_agent_code\" TEXT,\n    \"receipt_date\" TIMESTAMP WITH TIME ZONE,\n    \"receipt_number\" TEXT,\n    \"other_details\" TEXT\n);\n\nCREATE TABLE IF NOT EXISTS \"Document_Summary\" (\n    \"summary_id\" BIGSERIAL PRIMARY KEY,\n    \"document_id\" BIGINT NOT NULL,\n    \"document_status_code\" TEXT,\n    \"document_type_code\" TEXT,\n    \"shipping_agent_code\" TEXT,\n    \"receipt_date\" TIMESTAMP WITH TIME ZONE,\n    \"receipt_number\" TEXT,\n    \"summary_text\" TEXT,\n    \"created_at\" TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE OR REPLACE FUNCTION trg_insert_document_summary() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Document_Summary\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"summary_text\")\n    VALUES (NEW.\"document_id\", NEW.\"document_status_code\", NEW.\"document_type_code\", NEW.\"shipping_agent_code\", NEW.\"receipt_date\", NEW.\"receipt_number\", 'Summary: ' || NEW.\"document_status_code\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_insert_document_summary\nAFTER INSERT ON \"Documents\"\nFOR EACH ROW EXECUTE FUNCTION trg_insert_document_summary();",
    "database_name": "cre_Doc_Control_Systems",
    "tables": [
      "Documents",
      "Ref_Document_Status"
    ],
    "call_sqls": [
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1001, 'working', 'CD', 'UP', '2024-01-15 10:30:00+00', 'RN001', 'Initial draft');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1002, 'done', 'Paper', 'US', '2024-01-16 14:45:00+00', 'RN002', 'Final version');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1003, 'working', 'Paper', 'UP', '2024-01-17 09:15:00+00', 'RN003', 'Review pending');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1004, 'done', 'CD', 'US', '2024-01-18 16:20:00+00', 'RN004', 'Archived');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1005, 'working', 'CD', 'UP', '2024-01-19 11:00:00+00', 'RN005', 'Needs signature');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1006, 'done', 'Paper', 'US', '2024-01-20 13:30:00+00', 'RN006', 'Shipped to client');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1007, 'working', 'Paper', 'UP', '2024-01-21 08:45:00+00', 'RN007', 'In translation');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1008, 'done', 'CD', 'US', '2024-01-22 17:10:00+00', 'RN008', 'Digital copy stored');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1009, 'working', 'CD', 'UP', '2024-01-23 12:25:00+00', 'RN009', 'Awaiting approval');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1010, 'done', 'Paper', 'US', '2024-01-24 15:50:00+00', 'RN010', 'Filed');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1011, 'working', 'Paper', 'UP', '2024-01-25 10:05:00+00', 'RN011', 'Draft version 2');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1012, 'done', 'CD', 'US', '2024-01-26 14:30:00+00', 'RN012', 'Completed project');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1013, 'working', 'CD', 'UP', '2024-01-27 09:55:00+00', 'RN013', 'Internal review');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1014, 'done', 'Paper', 'US', '2024-01-28 18:15:00+00', 'RN014', 'Mailed to recipient');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1015, 'working', 'Paper', 'UP', '2024-01-29 11:40:00+00', 'RN015', 'Legal department');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1016, 'done', 'CD', 'US', '2024-01-30 13:05:00+00', 'RN016', 'Backup created');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1017, 'working', 'CD', 'UP', '2024-01-31 08:20:00+00', 'RN017', 'Quality check');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1018, 'done', 'Paper', 'US', '2024-02-01 16:45:00+00', 'RN018', 'Contract finalized');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1019, 'working', 'Paper', 'UP', '2024-02-02 12:10:00+00', 'RN019', 'Proofreading');",
      "INSERT INTO \"Documents\" (\"document_id\", \"document_status_code\", \"document_type_code\", \"shipping_agent_code\", \"receipt_date\", \"receipt_number\", \"other_details\") VALUES (1020, 'done', 'CD', 'US', '2024-02-03 15:35:00+00', 'RN020', 'Closed case');"
    ],
    "id": 27
  },
  {
    "ir": "Write a PLpgSQL function that retrieves data from the project_locations table, specifically selecting the location_id column and concatenating the latitude and longitude columns into a single text string formatted as 'latitude,longitude'. The function returns a table with two columns: location_id of type bigint and coordinates of type text. The coordinates are generated by converting the latitude and longitude values to text and joining them with a comma separator. The function does not take any input parameters and is designed to return all rows from the project_locations table, providing a comprehensive list of location identifiers along with their corresponding geographic coordinates in a text format.",
    "plsql": "CREATE OR REPLACE FUNCTION get_location_coordinates() RETURNS TABLE(location_id bigint, coordinates text) LANGUAGE plpgsql AS $$\nBEGIN\n  RETURN QUERY\n  SELECT pl.location_id, pl.latitude::text || ',' || pl.longitude::text AS coordinates\n  FROM project_locations pl;\nEND;\n$$;",
    "database_name": "infrastructure_project_management_and_tracking",
    "tables": [
      "project_locations",
      "project_teams",
      "projects"
    ],
    "call_sqls": [
      "SELECT * FROM get_location_coordinates();",
      "SELECT location_id, coordinates FROM get_location_coordinates();",
      "SELECT * FROM get_location_coordinates() WHERE location_id = 0;",
      "SELECT * FROM get_location_coordinates() WHERE location_id = 1;",
      "SELECT * FROM get_location_coordinates() ORDER BY location_id;",
      "SELECT * FROM get_location_coordinates() ORDER BY location_id DESC;",
      "SELECT * FROM get_location_coordinates() LIMIT 5;",
      "SELECT * FROM get_location_coordinates() OFFSET 10 LIMIT 5;",
      "SELECT coordinates FROM get_location_coordinates() WHERE location_id = 0;",
      "SELECT coordinates FROM get_location_coordinates() WHERE location_id = 1;",
      "SELECT COUNT(*) FROM get_location_coordinates();",
      "SELECT location_id FROM get_location_coordinates();",
      "SELECT * FROM get_location_coordinates() WHERE coordinates LIKE '38.9%';",
      "SELECT * FROM get_location_coordinates() WHERE coordinates LIKE '%,-77.%';",
      "SELECT * FROM get_location_coordinates() WHERE location_id IN (0, 1, 2);",
      "SELECT * FROM get_location_coordinates() WHERE location_id BETWEEN 0 AND 10;",
      "SELECT p.project_name, g.coordinates FROM projects p JOIN get_location_coordinates() g ON p.project_id = g.location_id;",
      "SELECT * FROM get_location_coordinates() WHERE location_id = (SELECT MIN(location_id) FROM project_locations);",
      "SELECT * FROM get_location_coordinates() WHERE location_id = (SELECT MAX(location_id) FROM project_locations);",
      "SELECT g.coordinates, pl.street FROM get_location_coordinates() g JOIN project_locations pl ON g.location_id = pl.location_id;"
    ],
    "id": 28
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_team_stats_on_game` that is designed to be executed before an `INSERT` operation on the `games` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables such as `NEW` (representing the new row being inserted) and `OLD` (representing the old row, which is null for `INSERT` triggers). The function's primary purpose is to conditionally insert a new record into the `teams` table. Specifically, it attempts to `INSERT` a new row into the `teams` table, populating its columns as follows: the `team_id` column is set to the value of `NEW.home_team_id` (which is the `home_team_id` from the row currently being inserted into the `games` table); the `team_name` column is set to the literal string 'Updated Team'; the `location` column is set to the literal string 'Updated Location'; the `coach` column is set to the literal string 'Updated Coach'; the `owner` column is set to the literal string 'Updated Owner'; the `stadium` column is set to the literal string 'Updated Stadium'; the `team_colors` column is set to the literal string 'Updated Colors'; the `team_history` column is set to the literal string 'Updated History'; and the `team_logo` column is set to the literal string 'Updated Logo'. This `INSERT` operation is conditional, executing `WHERE NOT EXISTS (SELECT 1 FROM teams WHERE team_id = NEW.home_team_id)`. This condition ensures that the insertion into the `teams` table only occurs if a team with the `team_id` matching `NEW.home_team_id` does not already exist in the `teams` table. After attempting this conditional insertion, the function concludes by returning `NEW`, which signifies that the `INSERT` operation on the `games` table should proceed with the new row as it was provided.\n\nA trigger named `trg_update_team_stats_on_game` is defined to execute the `update_team_stats_on_game()` function. This trigger is configured to activate `BEFORE INSERT` operations on the `games` table. The `FOR EACH ROW` clause specifies that the trigger function will be executed once for each row that is being inserted into the `games` table. The `EXECUTE FUNCTION update_team_stats_on_game()` clause explicitly calls the previously described trigger function to perform its logic.",
    "plsql": "CREATE OR REPLACE FUNCTION update_team_stats_on_game() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO teams (team_id, team_name, location, coach, owner, stadium, team_colors, team_history, team_logo) SELECT NEW.home_team_id, 'Updated Team', 'Updated Location', 'Updated Coach', 'Updated Owner', 'Updated Stadium', 'Updated Colors', 'Updated History', 'Updated Logo' WHERE NOT EXISTS (SELECT 1 FROM teams WHERE team_id = NEW.home_team_id);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_team_stats_on_game\nBEFORE INSERT ON games\nFOR EACH ROW EXECUTE FUNCTION update_team_stats_on_game();",
    "database_name": "basketball_player_performance_statistics",
    "tables": [
      "access_logs",
      "games",
      "players",
      "seasons",
      "teams",
      "user_roles",
      "users"
    ],
    "call_sqls": [
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1000, '2024-01-01', 999, 1, 110, 105, 18000, 'John Doe, Jane Smith', 'Test Arena');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1001, '2024-01-02', 1000, 2, 98, 102, 19000, 'Ref One, Ref Two', 'Test Stadium');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1002, '2024-01-03', 1001, 3, 115, 112, 17500, 'Official A, Official B', 'New Venue');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1003, '2024-01-04', 1002, 4, 105, 100, 20000, 'Crew Chief, Umpire', 'Main Court');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1004, '2024-01-05', 1003, 5, 99, 101, 16500, 'First Ref, Second Ref', 'City Arena');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1005, '2024-01-06', 1004, 6, 120, 118, 21000, 'Lead Official, Assistant', 'State Center');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1006, '2024-01-07', 1005, 7, 88, 92, 15500, 'Ref X, Ref Y', 'Local Gym');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1007, '2024-01-08', 1006, 8, 102, 98, 18500, 'Crew 1, Crew 2', 'National Stadium');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1008, '2024-01-09', 1007, 9, 113, 107, 19500, 'Official 1, Official 2', 'Regional Arena');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1009, '2024-01-10', 1008, 10, 95, 90, 17000, 'Head Ref, Side Ref', 'Metro Center');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1010, '2024-01-11', 1009, 11, 108, 104, 22000, 'Veteran Ref, Rookie Ref', 'Capital Arena');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1011, '2024-01-12', 1010, 12, 100, 105, 16000, 'Crew Alpha, Crew Beta', 'University Stadium');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1012, '2024-01-13', 1011, 13, 119, 115, 20500, 'Ref Prime, Ref Second', 'Tech Center');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1013, '2024-01-14', 1012, 14, 87, 85, 15000, 'Official Left, Official Right', 'Community Center');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1014, '2024-01-15', 1013, 15, 112, 110, 19500, 'North Ref, South Ref', 'Downtown Arena');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1015, '2024-01-16', 1014, 16, 103, 97, 18000, 'East Official, West Official', 'Riverside Stadium');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1016, '2024-01-17', 1015, 17, 96, 94, 16500, 'Senior Ref, Junior Ref', 'Mountain View Arena');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1017, '2024-01-18', 1016, 18, 124, 120, 23000, 'Crew Red, Crew Blue', 'Sunset Center');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1018, '2024-01-19', 1017, 19, 91, 89, 15500, 'Ref A1, Ref B2', 'Oceanfront Arena');",
      "INSERT INTO games (game_id, game_date, home_team_id, away_team_id, home_score, away_score, attendance, referees, location) VALUES (1019, '2024-01-20', 1018, 20, 107, 103, 19000, 'Main Official, Backup Official', 'Heritage Stadium');"
    ],
    "id": 29
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named merge_region_data that accepts two mandatory input parameters, p_source_region of type bigint and p_target_region of type bigint, and returns void, performing a conditional data merge operation where it first checks if the two provided region identifiers are not equal; if they are not equal, it executes an UPDATE statement on the locations table, setting the region_id column to the value of p_target_parameter for every row where the current region_id matches p_source_region, and simultaneously appends to the description column a concatenated string consisting of the existing description value, the literal string ' (merged from region ', the value of p_source_region, and the closing parenthesis ')'; following this update, it executes a DELETE statement on the regions table to remove the row where the region_id column equals p_source_region, but only if a subsequent subquery condition is satisfied, specifically the NOT EXISTS clause which checks for the absence of any rows in the locations table where the region_id column still holds the value of p_source_region, ensuring the source region record is deleted only after all associated locations have been successfully reassigned to the target region.",
    "plsql": "CREATE OR REPLACE FUNCTION merge_region_data(p_source_region bigint, p_target_region bigint)\nRETURNS void AS $$\nBEGIN\n    IF p_source_region != p_target_region THEN\n        UPDATE locations \n        SET region_id = p_target_region,\n            description = description || ' (merged from region ' || p_source_region || ')'\n        WHERE region_id = p_source_region;\n        \n        DELETE FROM regions \n        WHERE region_id = p_source_region \n        AND NOT EXISTS (SELECT 1 FROM locations WHERE region_id = p_source_region);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "forest_fire_prediction_and_management",
    "tables": [
      "fire_risk_assessments",
      "fire_risk_levels",
      "locations",
      "regions",
      "historical_fires"
    ],
    "call_sqls": [
      "SELECT merge_region_data(1, 2);",
      "SELECT merge_region_data(3, 4);",
      "SELECT merge_region_data(5, 6);",
      "SELECT merge_region_data(7, 8);",
      "SELECT merge_region_data(9, 10);",
      "SELECT merge_region_data(11, 12);",
      "SELECT merge_region_data(13, 14);",
      "SELECT merge_region_data(15, 16);",
      "SELECT merge_region_data(17, 18);",
      "SELECT merge_region_data(19, 20);",
      "SELECT merge_region_data(21, 22);",
      "SELECT merge_region_data(23, 24);",
      "SELECT merge_region_data(25, 26);",
      "SELECT merge_region_data(27, 28);",
      "SELECT merge_region_data(29, 30);",
      "SELECT merge_region_data(31, 32);",
      "SELECT merge_region_data(33, 34);",
      "SELECT merge_region_data(35, 36);",
      "SELECT merge_region_data(37, 38);",
      "SELECT merge_region_data(39, 40);"
    ],
    "id": 30
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter policy_id_input of type bigint and calculates the total sum of the claim_amount column from the claims table for all rows where the policy_id column matches the provided policy_id_input. The function declares a variable total_claims of type real to store the result of the aggregation. It performs a SELECT operation using the SUM() function to compute the total of claim_amount values, storing the result into the total_claims variable. The function then returns the value of total_claims as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_claims_amount(policy_id_input bigint) RETURNS real LANGUAGE plpgsql AS $$\nDECLARE\n    total_claims real;\nBEGIN\n    SELECT SUM(claim_amount) INTO total_claims\n    FROM claims\n    WHERE policy_id = policy_id_input;\n    RETURN total_claims;\nEND;\n$$;",
    "database_name": "automobile_insurance_risk_assessment_and_policy_management",
    "tables": [
      "drivers",
      "vehicles",
      "policies",
      "claims",
      "payments"
    ],
    "call_sqls": [
      "SELECT get_total_claims_amount(1);",
      "SELECT get_total_claims_amount(2);",
      "SELECT get_total_claims_amount(3);",
      "SELECT get_total_claims_amount(4);",
      "SELECT get_total_claims_amount(5);",
      "SELECT get_total_claims_amount(10);",
      "SELECT get_total_claims_amount(15);",
      "SELECT get_total_claims_amount(20);",
      "SELECT get_total_claims_amount(25);",
      "SELECT get_total_claims_amount(30);",
      "SELECT get_total_claims_amount(35);",
      "SELECT get_total_claims_amount(40);",
      "SELECT get_total_claims_amount(45);",
      "SELECT get_total_claims_amount(50);",
      "SELECT get_total_claims_amount(55);",
      "SELECT get_total_claims_amount(60);",
      "SELECT get_total_claims_amount(65);",
      "SELECT get_total_claims_amount(70);",
      "SELECT get_total_claims_amount(75);",
      "SELECT get_total_claims_amount(80);",
      "SELECT get_total_claims_amount(100);"
    ],
    "id": 31
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named evaluate_user_permissions that accepts two input parameters: check_user_id of type BIGINT, which represents the unique identifier of a user whose permissions are being evaluated, and requested_region of type TEXT, which represents the name of a geographical region for which access is being requested, and returns a BOOLEAN value indicating whether the user is granted permission for that region. The function's logic is defined by a series of conditional IF-ELSIF-ELSE statements. The first condition checks two simultaneous sub-conditions using the AND logical operator: the first sub-condition queries the users table to verify the existence of at least one row where the user_id column equals the input check_user_id and the role column has the exact string value 'researcher'; the second sub-condition performs a JOIN between the access_logs table (aliased as al) and the regions table (aliased as r) on the equality of al.region_id and r.region_id, and then checks for the existence of at least one row in the joined result where the al.user_id column equals the input check_user_id and the r.region_name column equals the input requested_region string. If both sub-conditions are true, the function immediately returns TRUE. If the first condition is false, the first ELSIF condition is evaluated, which queries the users table to check for the existence of at least one row where the user_id column equals the input check_user_id and the role column has the exact string value 'policymaker'; if such a row exists, the function immediately returns TRUE. If the previous condition is also false, the second ELSIF condition is evaluated, which performs a JOIN between the collaborations table (aliased as c) and the regions table (aliased as r) on the equality of c.region_id and r.region_id, and then checks for the existence of at least one row in the joined result where the c.user_id column equals the input check_user_id and the r.region_name column equals the input requested_region string; if such a row exists, the function returns TRUE. If none of the preceding IF or ELSIF conditions evaluate to true, the function executes the ELSE block and returns FALSE.",
    "plsql": "CREATE OR REPLACE FUNCTION evaluate_user_permissions(check_user_id BIGINT, requested_region TEXT) RETURNS BOOLEAN AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM users WHERE user_id = check_user_id AND role = 'researcher') AND EXISTS (SELECT 1 FROM access_logs al JOIN regions r ON al.region_id = r.region_id WHERE al.user_id = check_user_id AND r.region_name = requested_region) THEN\n        RETURN TRUE;\n    ELSIF EXISTS (SELECT 1 FROM users WHERE user_id = check_user_id AND role = 'policymaker') THEN\n        RETURN TRUE;\n    ELSIF EXISTS (SELECT 1 FROM collaborations c JOIN regions r ON c.region_id = r.region_id WHERE c.user_id = check_user_id AND r.region_name = requested_region) THEN\n        RETURN TRUE;\n    ELSE\n        RETURN FALSE;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "motorcycle_safety_and_statistics",
    "tables": [
      "access_logs",
      "collaborations",
      "regions",
      "users",
      "years"
    ],
    "call_sqls": [
      "SELECT evaluate_user_permissions(1, 'North');",
      "SELECT evaluate_user_permissions(2, 'South');",
      "SELECT evaluate_user_permissions(0, 'North');",
      "SELECT evaluate_user_permissions(1, 'South');",
      "SELECT evaluate_user_permissions(3, 'North');",
      "SELECT evaluate_user_permissions(0, 'South');",
      "SELECT evaluate_user_permissions(4, 'North');",
      "SELECT evaluate_user_permissions(5, 'South');",
      "SELECT evaluate_user_permissions(1, 'East');",
      "SELECT evaluate_user_permissions(2, 'West');",
      "SELECT evaluate_user_permissions(10, 'North');",
      "SELECT evaluate_user_permissions(15, 'South');",
      "SELECT evaluate_user_permissions(20, 'North');",
      "SELECT evaluate_user_permissions(25, 'South');",
      "SELECT evaluate_user_permissions(30, 'North');",
      "SELECT evaluate_user_permissions(35, 'South');",
      "SELECT evaluate_user_permissions(40, 'North');",
      "SELECT evaluate_user_permissions(45, 'South');",
      "SELECT evaluate_user_permissions(50, 'North');",
      "SELECT evaluate_user_permissions(55, 'South');"
    ],
    "id": 32
  },
  {
    "ir": "Write a PostgreSQL function named get_building_retrofit_cost that accepts a single parameter building_id_input of type bigint and returns a real value, which declares a local variable total_cost of type real, then executes a SELECT query that calculates the sum of the \"cost\" column from the retrofit_history table where the \"building_id\" column equals the building_id_input parameter, storing this sum in the total_cost variable, and then checks if total_cost is not NULL, returning the total_cost value if it contains data, otherwise returning 0.0 if no matching records were found in the retrofit_history table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_building_retrofit_cost(building_id_input bigint) RETURNS real AS $$\nDECLARE\n    total_cost real;\nBEGIN\n    SELECT SUM(\"cost\") INTO total_cost\n    FROM retrofit_history\n    WHERE \"building_id\" = building_id_input;\n\n    IF total_cost IS NOT NULL THEN\n        RETURN total_cost;\n    ELSE\n        RETURN 0.0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "building_inventory_and_structural_assessment",
    "tables": [
      "buildings",
      "building_types",
      "building_regions",
      "regions",
      "inspections",
      "inspectors",
      "retrofit_history"
    ],
    "call_sqls": [
      "SELECT get_building_retrofit_cost(1);",
      "SELECT get_building_retrofit_cost(2);",
      "SELECT get_building_retrofit_cost(3);",
      "SELECT get_building_retrofit_cost(4);",
      "SELECT get_building_retrofit_cost(5);",
      "SELECT get_building_retrofit_cost(10);",
      "SELECT get_building_retrofit_cost(15);",
      "SELECT get_building_retrofit_cost(20);",
      "SELECT get_building_retrofit_cost(25);",
      "SELECT get_building_retrofit_cost(30);",
      "SELECT get_building_retrofit_cost(35);",
      "SELECT get_building_retrofit_cost(40);",
      "SELECT get_building_retrofit_cost(45);",
      "SELECT get_building_retrofit_cost(50);",
      "SELECT get_building_retrofit_cost(55);",
      "SELECT get_building_retrofit_cost(60);",
      "SELECT get_building_retrofit_cost(65);",
      "SELECT get_building_retrofit_cost(70);",
      "SELECT get_building_retrofit_cost(75);",
      "SELECT get_building_retrofit_cost(80);",
      "SELECT get_building_retrofit_cost(85);"
    ],
    "id": 33
  },
  {
    "ir": "Write a PostgreSQL trigger that, after an update operation occurs on any row within the \"event\" table, automatically executes a trigger function named \"trigger_function_4\" for each affected row. This \"trigger_function_4\" is defined as a PL/pgSQL function that returns a TRIGGER type. Upon execution, the function performs an INSERT operation into the \"journalist\" table. The \"journalist\" table has columns \"journalist_ID\", \"Name\", \"Nationality\", \"Age\", and \"Years_working\". For the \"journalist_ID\" column, the value is derived by adding 100 to the value of the \"Event_ID\" column from the newly updated row in the \"event\" table (referenced as NEW.\"Event_ID\"). For the \"Name\" column, the value is obtained by taking the \"Name\" column from the newly updated row in the \"event\" table (referenced as NEW.\"Name\") and applying the TRIM function to remove any leading or trailing whitespace characters. For the \"Nationality\" column, a static string value of 'International' is inserted. For the \"Age\" column, a static string value of '25' is inserted. For the \"Years_working\" column, the value is calculated by dividing the value of the \"Event_Attendance\" column from the newly updated row in the \"event\" table (referenced as NEW.\"Event_Attendance\") by 100. After performing this insertion, the trigger function returns the NEW row, allowing the update operation on the \"event\" table to complete normally.",
    "plsql": "CREATE OR REPLACE FUNCTION \"trigger_function_4\"() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"journalist\" (\"journalist_ID\", \"Name\", \"Nationality\", \"Age\", \"Years_working\") \n  VALUES (NEW.\"Event_ID\" + 100, TRIM(NEW.\"Name\"), 'International', '25', NEW.\"Event_Attendance\" / 100);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_4\"\nAFTER UPDATE ON \"event\"\nFOR EACH ROW EXECUTE FUNCTION \"trigger_function_4\"();",
    "database_name": "news_report",
    "tables": [
      "event",
      "journalist",
      "news_report"
    ],
    "call_sqls": [
      "UPDATE event SET Event_Attendance = 7000 WHERE Event_ID = 1;",
      "UPDATE event SET Name = 'Updated Opening Ceremony' WHERE Event_ID = 1;",
      "UPDATE event SET Venue = 'New Stadium' WHERE Event_ID = 2;",
      "UPDATE event SET Date = '15 October 2008' WHERE Event_ID = 1;",
      "UPDATE event SET Event_Attendance = 500 WHERE Event_ID = 2;",
      "UPDATE event SET Name = TRIM('  Government Hearing Updated  ') WHERE Event_ID = 2;",
      "UPDATE event SET Event_Attendance = 2000 WHERE Event_ID = 3;",
      "UPDATE event SET Venue = 'Updated Motagua' WHERE Event_ID = 3;",
      "UPDATE event SET Name = 'Public Debating Finals', Event_Attendance = 10000 WHERE Event_ID = 3;",
      "UPDATE event SET Event_Attendance = Event_Attendance + 100 WHERE Event_ID = 1;",
      "UPDATE event SET Name = 'Olympic Games Opening' WHERE Event_ID = 1;",
      "UPDATE event SET Event_Attendance = 0 WHERE Event_ID = 2;",
      "UPDATE event SET Date = '8 October 2010', Venue = 'Main Hall' WHERE Event_ID = 3;",
      "UPDATE event SET Name = 'Test Event', Event_Attendance = 15000 WHERE Event_ID = 4;",
      "UPDATE event SET Event_Attendance = 2500 WHERE Event_ID = 5;",
      "UPDATE event SET Name = 'Annual Conference' WHERE Event_ID = 6;",
      "UPDATE event SET Venue = 'Convention Center', Event_Attendance = 8000 WHERE Event_ID = 7;",
      "UPDATE event SET Name = 'Workshop Series' WHERE Event_ID = 8;",
      "UPDATE event SET Event_Attendance = 1200 WHERE Event_ID = 9;",
      "UPDATE event SET Name = 'Charity Gala', Venue = 'Grand Hotel' WHERE Event_ID = 10;"
    ],
    "id": 34
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_garment_fabric_percentage that accepts a single input parameter p_garment_fabric_id of type bigint, which is used to identify a specific record in the garment_fabrics table, and returns a value of type real; the function declares a local variable v_percentage of type real to store the result, then executes a SELECT statement to query the garment_fabrics table, specifically retrieving the value from the percentage column and assigning it into the variable v_percentage, where the row is filtered by the condition that the garment_fabric_id column must exactly equal the value provided by the input parameter p_garment_fabric_id, and finally returns the value stored in the v_percentage variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_garment_fabric_percentage(p_garment_fabric_id bigint)\nRETURNS real AS $$\nDECLARE\n    v_percentage real;\nBEGIN\n    SELECT percentage INTO v_percentage FROM garment_fabrics WHERE garment_fabric_id = p_garment_fabric_id;\n    RETURN v_percentage;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "apparel_sizing_and_measurement_management_672975",
    "tables": [
      "fabrics",
      "care_instructions",
      "garment_fabrics"
    ],
    "call_sqls": [
      "SELECT get_garment_fabric_percentage(0);",
      "SELECT get_garment_fabric_percentage(1);",
      "SELECT get_garment_fabric_percentage(2);",
      "SELECT get_garment_fabric_percentage(3);",
      "SELECT get_garment_fabric_percentage(4);",
      "SELECT get_garment_fabric_percentage(5);",
      "SELECT get_garment_fabric_percentage(10);",
      "SELECT get_garment_fabric_percentage(15);",
      "SELECT get_garment_fabric_percentage(20);",
      "SELECT get_garment_fabric_percentage(25);",
      "SELECT get_garment_fabric_percentage(30);",
      "SELECT get_garment_fabric_percentage(35);",
      "SELECT get_garment_fabric_percentage(40);",
      "SELECT get_garment_fabric_percentage(45);",
      "SELECT get_garment_fabric_percentage(50);",
      "SELECT get_garment_fabric_percentage(55);",
      "SELECT get_garment_fabric_percentage(60);",
      "SELECT get_garment_fabric_percentage(65);",
      "SELECT get_garment_fabric_percentage(70);",
      "SELECT get_garment_fabric_percentage(75);"
    ],
    "id": 35
  },
  {
    "ir": "Write a PostgreSQL function named get_project_simulation_count that accepts a single input parameter project_input of type bigint and returns a bigint value, which declares a local variable sim_count of type bigint, then executes a SELECT COUNT(*) query on the simulations table aliased as s to count the number of rows where the project_id column equals the provided project_input parameter, stores this count in the sim_count variable, and finally returns the value of sim_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_project_simulation_count(project_input bigint)\nRETURNS bigint AS\n$$\nDECLARE\n    sim_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO sim_count\n    FROM simulations s\n    WHERE s.project_id = project_input;\n    \n    RETURN sim_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "computational_fluid_dynamics_simulation_data",
    "tables": [
      "access_logs",
      "boundary_conditions",
      "numerical_methods",
      "projects",
      "rms_values",
      "simulation_parameters",
      "simulations",
      "users"
    ],
    "call_sqls": [
      "SELECT get_project_simulation_count(0);",
      "SELECT get_project_simulation_count(1);",
      "SELECT get_project_simulation_count(2);",
      "SELECT get_project_simulation_count(10);",
      "SELECT get_project_simulation_count(100);",
      "SELECT get_project_simulation_count(5);",
      "SELECT get_project_simulation_count(7);",
      "SELECT get_project_simulation_count(12);",
      "SELECT get_project_simulation_count(15);",
      "SELECT get_project_simulation_count(20);",
      "SELECT get_project_simulation_count(25);",
      "SELECT get_project_simulation_count(30);",
      "SELECT get_project_simulation_count(35);",
      "SELECT get_project_simulation_count(40);",
      "SELECT get_project_simulation_count(45);",
      "SELECT get_project_simulation_count(50);",
      "SELECT get_project_simulation_count(55);",
      "SELECT get_project_simulation_count(60);",
      "SELECT get_project_simulation_count(65);",
      "SELECT get_project_simulation_count(70);"
    ],
    "id": 36
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_player_trade_ratio that accepts two input parameters: a player_id of type NUMBER to identify a specific player, and a min_trades of type NUMBER to serve as a minimum trade count threshold, and returns a NUMBER value representing a calculated ratio; the function initializes an internal variable ratio to 0, then executes a SELECT COUNT(*) operation on the PLAYER_TRADE_HISTORY table, counting all rows where the PLAYER_ID column matches the input player_id parameter, and stores this count in the variable player_trade_count; it then checks if player_trade_count is greater than the input min_trades parameter, and if this condition is true, it performs another SELECT COUNT(*) operation on the PLAYERS table to get the total number of players, storing this count in the variable total_players_count; it then checks if total_players_count is greater than 0, and if so, calculates the ratio by dividing the player_trade_count by the total_players_count, assigning the result to the ratio variable; if the total_players_count is not greater than 0, it explicitly sets the ratio variable to 0 to prevent division by zero; finally, the function returns the value of the ratio variable, which will be 0 if the initial condition on the trade count was not met, 0 if the total player count was zero during calculation, or the computed division result otherwise.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_player_trade_ratio(player_id IN NUMBER, min_trades IN NUMBER) RETURN NUMBER IS\n  ratio               NUMBER := 0;\n  player_trade_count  NUMBER;\n  total_players_count NUMBER;\nBEGIN\n  -- Get the number of trades for the specific player\n  SELECT COUNT(*)\n  INTO player_trade_count\n  FROM PLAYER_TRADE_HISTORY\n  WHERE PLAYER_ID = player_id;\n\n  -- Check if the player's trades exceed min_trades\n  IF player_trade_count > min_trades THEN\n    -- Get the total number of players\n    SELECT COUNT(*)\n    INTO total_players_count\n    FROM PLAYERS;\n\n    -- Calculate the ratio, handling division by zero\n    IF total_players_count > 0 THEN\n      ratio := player_trade_count / total_players_count;\n    ELSE\n      ratio := 0; -- Or handle as an error, depending on business logic\n    END IF;\n  END IF;\n\n  RETURN ratio; -- NVL is not strictly needed here if ratio is initialized to 0 and only updated if conditions are met\nEND;",
    "database_name": "baseball_ps_management",
    "tables": [
      "PLAYERS",
      "PLAYER_TRADE_HISTORY"
    ],
    "call_sqls": [
      "SELECT calculate_player_trade_ratio(101, 5) FROM dual",
      "SELECT calculate_player_trade_ratio(205, 10) FROM dual",
      "SELECT calculate_player_trade_ratio(312, 0) FROM dual",
      "SELECT calculate_player_trade_ratio(478, 20) FROM dual",
      "SELECT calculate_player_trade_ratio(533, 15) FROM dual",
      "SELECT calculate_player_trade_ratio(647, 3) FROM dual",
      "SELECT calculate_player_trade_ratio(789, 7) FROM dual",
      "SELECT calculate_player_trade_ratio(821, 25) FROM dual",
      "SELECT calculate_player_trade_ratio(904, 1) FROM dual",
      "SELECT calculate_player_trade_ratio(1001, 12) FROM dual",
      "SELECT calculate_player_trade_ratio(1150, 8) FROM dual",
      "SELECT calculate_player_trade_ratio(1225, 30) FROM dual",
      "SELECT calculate_player_trade_ratio(1337, 2) FROM dual",
      "SELECT calculate_player_trade_ratio(1408, 18) FROM dual",
      "SELECT calculate_player_trade_ratio(1555, 6) FROM dual",
      "SELECT calculate_player_trade_ratio(1699, 9) FROM dual",
      "SELECT calculate_player_trade_ratio(1776, 22) FROM dual",
      "SELECT calculate_player_trade_ratio(1888, 4) FROM dual",
      "SELECT calculate_player_trade_ratio(1999, 14) FROM dual",
      "SELECT calculate_player_trade_ratio(2000, 11) FROM dual"
    ],
    "id": 37
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_neo_alert_status_summary` that accepts a single input parameter, `p_neo_id`, which is of data type `NUMBER`, and is intended to represent a unique identifier for a Near-Earth Object (NEO). This function is designed to return a `VARCHAR2` data type, which will contain a summary string detailing the count of 'ACTIVE' and 'RESOLVED' alert statuses associated with the specified `p_neo_id`.\n\nThe function begins by declaring a local variable named `v_summary` of data type `VARCHAR2` with a maximum length of 255 characters. This variable will temporarily store the generated summary string before it is returned by the function.\n\nThe core logic of the function involves a single `SELECT` statement that retrieves data from a table named `alerts`. This `SELECT` statement performs an aggregation to count the occurrences of specific alert statuses. The `WHERE` clause of the `SELECT` statement filters the rows from the `alerts` table, considering only those records where the value in the `neo_id` column matches the value provided in the input parameter `p_neo_id`.\n\nWithin the `SELECT` statement, two `SUM` aggregate functions are used in conjunction with `CASE` expressions to conditionally count the alert statuses. The first `SUM` expression calculates the total number of 'ACTIVE' alerts: `SUM(CASE WHEN alert_status = 'ACTIVE' THEN 1 ELSE 0 END)`. This `CASE` expression evaluates the `alert_status` column for each row. If `alert_status` is equal to the literal string 'ACTIVE', it returns `1`; otherwise, it returns `0`. The `SUM` function then adds up these `1`s and `0`s to get the total count of 'ACTIVE' alerts.\n\nSimilarly, the second `SUM` expression calculates the total number of 'RESOLVED' alerts: `SUM(CASE WHEN alert_status = 'RESOLVED' THEN 1 ELSE 0 END)`. This `CASE` expression checks if `alert_status` is equal to the literal string 'RESOLVED'. If true, it returns `1`; otherwise, it returns `0`. The `SUM` function then aggregates these values to provide the total count of 'RESOLVED' alerts.\n\nThese two calculated counts are then concatenated with literal strings to form a descriptive summary string. Specifically, the string 'Active: ' is concatenated with the count of 'ACTIVE' alerts, followed by the string ', Resolved: ', and finally the count of 'RESOLVED' alerts. For example, if there are 5 active alerts and 2 resolved alerts, the resulting string would be 'Active: 5, Resolved: 2'.\n\nThe result of this concatenated string is then stored into the local variable `v_summary` using the `INTO` clause.\n\nFinally, the function returns the value stored in the `v_summary` variable, which represents the complete summary of 'ACTIVE' and 'RESOLVED' alert statuses for the given `p_neo_id`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_neo_alert_status_summary(p_neo_id IN NUMBER) RETURN VARCHAR2\nIS\n    v_summary VARCHAR2(255);\nBEGIN\n    SELECT 'Active: ' || SUM(CASE WHEN alert_status = 'ACTIVE' THEN 1 ELSE 0 END) || ', Resolved: ' || SUM(CASE WHEN alert_status = 'RESOLVED' THEN 1 ELSE 0 END)\n    INTO v_summary\n    FROM alerts\n    WHERE neo_id = p_neo_id;\n    \n    RETURN v_summary;\nEND;",
    "database_name": "asteroid_aneonta_analysis",
    "tables": [
      "neos",
      "neo_observations",
      "neo_risks",
      "hazardous_neos",
      "alerts",
      "orbits"
    ],
    "call_sqls": [
      "SELECT get_neo_alert_status_summary(1) FROM dual",
      "SELECT get_neo_alert_status_summary(2) FROM dual",
      "SELECT get_neo_alert_status_summary(3) FROM dual",
      "SELECT get_neo_alert_status_summary(4) FROM dual",
      "SELECT get_neo_alert_status_summary(5) FROM dual",
      "SELECT get_neo_alert_status_summary(10) FROM dual",
      "SELECT get_neo_alert_status_summary(15) FROM dual",
      "SELECT get_neo_alert_status_summary(20) FROM dual",
      "SELECT get_neo_alert_status_summary(25) FROM dual",
      "SELECT get_neo_alert_status_summary(30) FROM dual",
      "SELECT get_neo_alert_status_summary(35) FROM dual",
      "SELECT get_neo_alert_status_summary(40) FROM dual",
      "SELECT get_neo_alert_status_summary(45) FROM dual",
      "SELECT get_neo_alert_status_summary(50) FROM dual",
      "SELECT get_neo_alert_status_summary(55) FROM dual",
      "SELECT get_neo_alert_status_summary(60) FROM dual",
      "SELECT get_neo_alert_status_summary(65) FROM dual",
      "SELECT get_neo_alert_status_summary(70) FROM dual",
      "SELECT get_neo_alert_status_summary(75) FROM dual",
      "SELECT get_neo_alert_status_summary(80) FROM dual",
      "SELECT get_neo_alert_status_summary(100) FROM dual"
    ],
    "id": 38
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named remove_user_from_team that accepts two parameters: input_user_id of type bigint representing the identifier of the user to be removed, and input_team_id of type bigint representing the identifier of the team from which the user should be removed, and returns a boolean value indicating the success of the operation. The function first checks if a record exists in the user_teams table where the user_id column matches the input_user_id parameter AND the team_id column matches the input_team_id parameter. If such a record exists, the function proceeds to delete that specific record from the user_teams table using the same matching conditions on user_id and team_id columns. After the deletion, the function returns true to indicate successful removal. If no matching record is found in the initial check, the function skips the deletion operation and immediately returns false to indicate that the user was not a member of the specified team.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_user_from_team(input_user_id bigint, input_team_id bigint) RETURNS boolean LANGUAGE plpgsql AS $$ BEGIN IF EXISTS (SELECT 1 FROM user_teams WHERE user_id = input_user_id AND team_id = input_team_id) THEN DELETE FROM user_teams WHERE user_id = input_user_id AND team_id = input_team_id; ELSE RETURN false; END IF; RETURN true; END; $$;",
    "database_name": "electronic_device_charging_and_power_consumption",
    "tables": [
      "users",
      "roles",
      "teams",
      "user_teams",
      "devices",
      "chargers",
      "device_chargers",
      "power_consumption",
      "analytics"
    ],
    "call_sqls": [
      "SELECT remove_user_from_team(1, 1);",
      "SELECT remove_user_from_team(2, 1);",
      "SELECT remove_user_from_team(1, 2);",
      "SELECT remove_user_from_team(3, 2);",
      "SELECT remove_user_from_team(4, 3);",
      "SELECT remove_user_from_team(5, 1);",
      "SELECT remove_user_from_team(6, 2);",
      "SELECT remove_user_from_team(7, 3);",
      "SELECT remove_user_from_team(8, 4);",
      "SELECT remove_user_from_team(9, 5);",
      "SELECT remove_user_from_team(10, 1);",
      "SELECT remove_user_from_team(11, 2);",
      "SELECT remove_user_from_team(12, 3);",
      "SELECT remove_user_from_team(13, 4);",
      "SELECT remove_user_from_team(14, 5);",
      "SELECT remove_user_from_team(15, 6);",
      "SELECT remove_user_from_team(16, 7);",
      "SELECT remove_user_from_team(17, 8);",
      "SELECT remove_user_from_team(18, 9);",
      "SELECT remove_user_from_team(19, 10);",
      "SELECT remove_user_from_team(20, 1);"
    ],
    "id": 39
  },
  {
    "ir": "Write a PLpgSQL function named update_player_stats_by_weight that accepts two parameters: weight_threshold of type bigint and stat_multiplier of type double precision. The function performs different operations based on the values of these parameters. If weight_threshold is greater than 200 and stat_multiplier is greater than 1.0, it updates the player_game_statistics table by multiplying the yards_rushed column by stat_multiplier for players whose weight exceeds weight_threshold, as determined by a subquery selecting player_id from the players table. If weight_threshold is 200 or less and stat_multiplier is greater than 1.0, it updates the play_statistics table by multiplying the yards_passed column by stat_multiplier for players whose weight is 200 or less, using a similar subquery. If weight_threshold is greater than 200 and stat_multiplier is 1.0 or less, it deletes records from the injuries table for players who are quarterbacks (position = 'QB') and whose weight exceeds weight_threshold, again using a subquery to identify player_id from the players table. If none of the above conditions are met, it inserts a new record into the injuries table with a player_id from the players table where weight is 200 or less, along with a game_id of 1, an injury_type of 'Minor', and an injury_date of '2024-01-01', limiting the insertion to one record.",
    "plsql": "CREATE OR REPLACE FUNCTION update_player_stats_by_weight(weight_threshold bigint, stat_multiplier double precision)\nRETURNS void LANGUAGE plpgsql AS $$\nBEGIN\n    IF weight_threshold > 200 AND stat_multiplier > 1.0 THEN\n        UPDATE player_game_statistics SET yards_rushed = yards_rushed * stat_multiplier WHERE player_id IN (SELECT player_id FROM players WHERE weight > weight_threshold);\n    ELSIF weight_threshold <= 200 AND stat_multiplier > 1.0 THEN\n        UPDATE play_statistics SET yards_passed = yards_passed * stat_multiplier WHERE player_id IN (SELECT player_id FROM players WHERE weight <= weight_threshold);\n    ELSIF weight_threshold > 200 AND stat_multiplier <= 1.0 THEN\n        DELETE FROM injuries WHERE player_id IN (SELECT player_id FROM players WHERE weight > weight_threshold AND position = 'QB');\n    ELSE\n        INSERT INTO injuries (player_id, game_id, injury_type, injury_date) SELECT player_id, 1, 'Minor', '2024-01-01' FROM players WHERE weight <= weight_threshold LIMIT 1;\n    END IF;\nEND;\n$$;",
    "database_name": "american_football_game_data_and_analytics_649345",
    "tables": [
      "game_officials",
      "injuries",
      "play_statistics",
      "player_game_statistics",
      "players",
      "teams"
    ],
    "call_sqls": [
      "SELECT update_player_stats_by_weight(250, 1.1);",
      "SELECT update_player_stats_by_weight(300, 1.05);",
      "SELECT update_player_stats_by_weight(180, 1.2);",
      "SELECT update_player_stats_by_weight(200, 1.15);",
      "SELECT update_player_stats_by_weight(220, 0.9);",
      "SELECT update_player_stats_by_weight(280, 0.8);",
      "SELECT update_player_stats_by_weight(150, 0.95);",
      "SELECT update_player_stats_by_weight(190, 1.25);",
      "SELECT update_player_stats_by_weight(210, 1.3);",
      "SELECT update_player_stats_by_weight(230, 1.08);",
      "SELECT update_player_stats_by_weight(170, 1.12);",
      "SELECT update_player_stats_by_weight(260, 0.85);",
      "SELECT update_player_stats_by_weight(240, 1.18);",
      "SELECT update_player_stats_by_weight(195, 1.22);",
      "SELECT update_player_stats_by_weight(205, 0.75);",
      "SELECT update_player_stats_by_weight(275, 0.6);",
      "SELECT update_player_stats_by_weight(160, 0.99);",
      "SELECT update_player_stats_by_weight(290, 1.4);",
      "SELECT update_player_stats_by_weight(185, 1.07);",
      "SELECT update_player_stats_by_weight(225, 0.5);"
    ],
    "id": 40
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `transfer_registrations_to_new_course` that accepts two `bigint` parameters: `old_course_id`, representing the unique identifier of the course from which registrations are to be transferred, and `new_course_id`, representing the unique identifier of the course to which registrations are to be transferred. This function is designed to transfer all 'Registered' student registrations from an old course to a new course, provided the new course has sufficient capacity. The function returns a `bigint` value indicating the number of registrations successfully transferred, or `0` if the new course does not exist or if there is insufficient capacity.\n\nUpon execution, the function first declares four local `bigint` variables: `transferred` to store the count of successfully updated registrations, `new_course_max` to hold the maximum student capacity of the new course, `currently_registered` to store the current number of 'Registered' students in the new course, and `to_transfer_count` to store the number of 'Registered' students in the old course that are intended for transfer.\n\nThe function then proceeds with the following steps:\n1. It attempts to retrieve the `max_students` column value from the `courses` table for the row where the `course_id` matches the `new_course_id` parameter. This retrieved value is stored in the `new_course_max` variable.\n2. Immediately after this `SELECT` statement, it checks the `FOUND` status. If `NOT FOUND` is true (meaning no course with the `new_course_id` was found), the function immediately returns `0`, indicating that the new course does not exist and no transfers can occur.\n3. If the new course exists, the function then counts the number of rows in the `registrations` table where the `course_id` matches the `new_course_id` parameter and the `registration_status` is exactly 'Registered'. This count is stored in the `currently_registered` variable.\n4. Subsequently, it counts the number of rows in the `registrations` table where the `course_id` matches the `old_course_id` parameter and the `registration_status` is exactly 'Registered'. This count represents the number of registrations to be transferred and is stored in the `to_transfer_count` variable.\n5. A conditional check is then performed: `IF new_course_max >= (currently_registered + to_transfer_count) THEN`. This condition evaluates whether the maximum capacity of the new course (`new_course_max`) is greater than or equal to the sum of the currently registered students in the new course (`currently_registered`) and the students intended for transfer from the old course (`to_transfer_count`).\n6. If the condition in step 5 is true (i.e., there is enough capacity in the new course), the function proceeds to perform the transfer:\n    a. It executes an `UPDATE` statement on the `registrations` table. For all rows where the `course_id` matches the `old_course_id` parameter and the `registration_status` is exactly 'Registered', it sets the `course_id` to the `new_course_id` parameter and updates the `updated_at` column to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS')`.\n    b. After the `UPDATE` statement, it uses `GET DIAGNOSTICS transferred = ROW_COUNT;` to retrieve the number of rows that were actually affected (updated) by the preceding `UPDATE` statement. This count is stored in the `transferred` variable.\n    c. Finally, the function returns the value stored in the `transferred` variable, representing the number of registrations successfully moved.\n7. If the condition in step 5 is false (i.e., there is insufficient capacity in the new course), the function immediately returns `0`, indicating that no transfers occurred due to capacity limitations.",
    "plsql": "CREATE OR REPLACE FUNCTION transfer_registrations_to_new_course(old_course_id bigint, new_course_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    transferred bigint;\n    new_course_max bigint;\n    currently_registered bigint;\n    to_transfer_count bigint;\nBEGIN\n    -- Get new course capacity\n    SELECT max_students INTO new_course_max FROM courses WHERE course_id = new_course_id;\n    IF NOT FOUND THEN\n        RETURN 0; -- New course doesn't exist\n    END IF;\n    \n    -- Get current registrations in new course\n    SELECT COUNT(*) INTO currently_registered \n    FROM registrations \n    WHERE course_id = new_course_id AND registration_status = 'Registered';\n    \n    -- Get count of registrations to transfer\n    SELECT COUNT(*) INTO to_transfer_count\n    FROM registrations\n    WHERE course_id = old_course_id AND registration_status = 'Registered';\n    \n    -- Check if there's enough capacity\n    IF new_course_max >= (currently_registered + to_transfer_count) THEN\n        -- Perform the transfer\n        UPDATE registrations \n        SET course_id = new_course_id, \n            updated_at = TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') \n        WHERE course_id = old_course_id AND registration_status = 'Registered';\n        \n        -- Get number of rows actually updated\n        GET DIAGNOSTICS transferred = ROW_COUNT;\n        RETURN transferred;\n    ELSE\n        RETURN 0;\n    END IF;\nEND;\n$$;",
    "database_name": "university_course_management_system_460524",
    "tables": [
      "courses",
      "departments",
      "instructors",
      "registrations"
    ],
    "call_sqls": [
      "SELECT transfer_registrations_to_new_course(100, 200);",
      "SELECT transfer_registrations_to_new_course(101, 201);",
      "SELECT transfer_registrations_to_new_course(102, 202);",
      "SELECT transfer_registrations_to_new_course(103, 203);",
      "SELECT transfer_registrations_to_new_course(104, 204);",
      "SELECT transfer_registrations_to_new_course(105, 205);",
      "SELECT transfer_registrations_to_new_course(106, 206);",
      "SELECT transfer_registrations_to_new_course(107, 207);",
      "SELECT transfer_registrations_to_new_course(108, 208);",
      "SELECT transfer_registrations_to_new_course(109, 209);",
      "SELECT transfer_registrations_to_new_course(110, 210);",
      "SELECT transfer_registrations_to_new_course(111, 211);",
      "SELECT transfer_registrations_to_new_course(112, 212);",
      "SELECT transfer_registrations_to_new_course(113, 213);",
      "SELECT transfer_registrations_to_new_course(114, 214);",
      "SELECT transfer_registrations_to_new_course(115, 215);",
      "SELECT transfer_registrations_to_new_course(116, 216);",
      "SELECT transfer_registrations_to_new_course(117, 217);",
      "SELECT transfer_registrations_to_new_course(118, 218);",
      "SELECT transfer_registrations_to_new_course(119, 219);"
    ],
    "id": 41
  },
  {
    "ir": "Write a PL/pgSQL function named `adjust_series_ranking` that accepts three input parameters: `series_id` of type `REAL`, `new_share` of type `REAL`, and `new_rank` of type `REAL`. The purpose of this function is to modify existing records within the `\"TV_series\"` table. Specifically, it performs an `UPDATE` operation on the `\"TV_series\"` table. For each row in the `\"TV_series\"` table, the function checks if the value in the `\"id\"` column is equal to the value provided in the `series_id` input parameter. If this condition is met, the function updates two columns for that specific row: the `\"Share\"` column is set to the value provided in the `new_share` input parameter, and the `\"Weekly_Rank\"` column is set to the value provided in the `new_rank` input parameter. The function does not return any value, as indicated by its `RETURNS VOID` declaration.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_series_ranking(series_id REAL, new_share REAL, new_rank REAL) RETURNS VOID AS $$\nBEGIN\n  UPDATE \"TV_series\" SET \"Share\" = new_share, \"Weekly_Rank\" = new_rank WHERE \"id\" = series_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "tvshow",
    "tables": [
      "Cartoon",
      "TV_Channel",
      "TV_series"
    ],
    "call_sqls": [
      "SELECT adjust_series_ranking(1.0, 10.5, 35.0);",
      "SELECT adjust_series_ranking(2.0, 8.2, 48.0);",
      "SELECT adjust_series_ranking(3.0, 12.7, 25.0);",
      "SELECT adjust_series_ranking(4.0, 6.3, 55.0);",
      "SELECT adjust_series_ranking(5.0, 9.1, 40.0);",
      "SELECT adjust_series_ranking(6.0, 15.0, 18.0);",
      "SELECT adjust_series_ranking(7.0, 7.5, 52.0);",
      "SELECT adjust_series_ranking(8.0, 11.2, 30.0);",
      "SELECT adjust_series_ranking(9.0, 5.8, 60.0);",
      "SELECT adjust_series_ranking(10.0, 13.4, 22.0);",
      "SELECT adjust_series_ranking(11.0, 8.9, 45.0);",
      "SELECT adjust_series_ranking(12.0, 4.7, 65.0);",
      "SELECT adjust_series_ranking(13.0, 14.1, 20.0);",
      "SELECT adjust_series_ranking(14.0, 6.8, 58.0);",
      "SELECT adjust_series_ranking(15.0, 10.0, 38.0);",
      "SELECT adjust_series_ranking(16.0, 9.5, 42.0);",
      "SELECT adjust_series_ranking(17.0, 7.2, 53.0);",
      "SELECT adjust_series_ranking(18.0, 12.0, 28.0);",
      "SELECT adjust_series_ranking(19.0, 5.0, 68.0);",
      "SELECT adjust_series_ranking(20.0, 11.8, 32.0);"
    ],
    "id": 42
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `update_incentive_reward` that accepts three input parameters: `p_incentive_id` of type `bigint`, `p_new_reward` of type `text`, and `p_new_expiration` of type `text`. This function is designed to return a boolean value. Upon execution, the function performs a single `UPDATE` operation on the `incentives` table. Specifically, it sets the value of the `reward` column to the value provided by the `p_new_reward` parameter and simultaneously sets the value of the `expiration_date` column to the value provided by the `p_new_expiration` parameter. This update is conditionally applied only to those rows in the `incentives` table where the value in the `incentive_id` column exactly matches the value supplied by the `p_incentive_id` parameter. After successfully executing this update statement, the function unconditionally returns the boolean value `true`.",
    "plsql": "CREATE OR REPLACE FUNCTION update_incentive_reward(p_incentive_id bigint, p_new_reward text, p_new_expiration text)\nRETURNS boolean AS $$\nBEGIN\n    UPDATE incentives SET reward = p_new_reward, expiration_date = p_new_expiration WHERE incentive_id = p_incentive_id;\n    RETURN true;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "bike_sharing_system_usage_and_weather_data",
    "tables": [
      "incentives"
    ],
    "call_sqls": [
      "SELECT update_incentive_reward(1, '15% off next ride', '2024-06-30');",
      "SELECT update_incentive_reward(2, 'Free upgrade', '2024-07-15');",
      "SELECT update_incentive_reward(3, '$5 credit', '2024-08-01');",
      "SELECT update_incentive_reward(4, '20% off weekend rental', '2024-09-30');",
      "SELECT update_incentive_reward(5, 'One free day', '2024-10-31');",
      "SELECT update_incentive_reward(6, 'Priority booking', '2024-11-15');",
      "SELECT update_incentive_reward(7, 'Waived fees', '2024-12-25');",
      "SELECT update_incentive_reward(8, 'Double points', '2025-01-20');",
      "SELECT update_incentive_reward(9, 'Complimentary insurance', '2025-02-14');",
      "SELECT update_incentive_reward(10, '10% + free delivery', '2025-03-08');",
      "SELECT update_incentive_reward(11, 'Member exclusive rate', '2025-04-01');",
      "SELECT update_incentive_reward(12, 'Bundle discount', '2025-05-05');",
      "SELECT update_incentive_reward(13, 'Referral bonus', '2025-06-30');",
      "SELECT update_incentive_reward(14, 'Loyalty reward', '2025-07-04');",
      "SELECT update_incentive_reward(15, 'Seasonal offer', '2025-08-31');",
      "SELECT update_incentive_reward(16, 'Birthday special', '2025-09-15');",
      "SELECT update_incentive_reward(17, 'Early bird discount', '2025-10-10');",
      "SELECT update_incentive_reward(18, 'Weekday promo', '2025-11-30');",
      "SELECT update_incentive_reward(19, 'New user welcome', '2025-12-24');",
      "SELECT update_incentive_reward(20, 'Annual renewal gift', '2026-01-01');"
    ],
    "id": 43
  },
  {
    "ir": "Write a PLpgSQL function that returns a table consisting of archived_trial_id and archived_trial_name by deleting rows from the clinical_trials table where the end_date is earlier than a specified cutoff date provided as a text parameter p_cutoff_date and the status of the trial is 'Completed'. The function uses a common table expression (CTE) named archived_trials to perform the deletion operation, which removes the qualifying rows from the clinical_trials table and simultaneously returns the trial_id and trial_name of the deleted rows. The RETURNING clause in the DELETE statement captures these values, and the function then selects trial_id and trial_name from the archived_trials CTE to return them as the result set of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_completed_trials_before_date(p_cutoff_date text)\nRETURNS TABLE(archived_trial_id bigint, archived_trial_name text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    WITH archived_trials AS (\n        DELETE FROM clinical_trials \n        WHERE end_date < p_cutoff_date \n          AND status = 'Completed'\n        RETURNING trial_id, trial_name\n    )\n    SELECT trial_id, trial_name FROM archived_trials;\nEND;\n$$;",
    "database_name": "cancer_research_and_patient_data_management",
    "tables": [
      "clinical_trials",
      "investigator_triads",
      "investigators",
      "patient_trials",
      "treatment_outcomes"
    ],
    "call_sqls": [
      "SELECT * FROM archive_completed_trials_before_date('2023-12-31');",
      "SELECT * FROM archive_completed_trials_before_date('2023-06-30');",
      "SELECT * FROM archive_completed_trials_before_date('2022-12-31');",
      "SELECT * FROM archive_completed_trials_before_date('2024-01-15');",
      "SELECT * FROM archive_completed_trials_before_date('2023-03-31');",
      "SELECT * FROM archive_completed_trials_before_date('2022-06-30');",
      "SELECT * FROM archive_completed_trials_before_date('2021-12-31');",
      "SELECT * FROM archive_completed_trials_before_date('2024-03-01');",
      "SELECT * FROM archive_completed_trials_before_date('2023-09-30');",
      "SELECT * FROM archive_completed_trials_before_date('2022-09-30');",
      "SELECT * FROM archive_completed_trials_before_date('2020-12-31');",
      "SELECT * FROM archive_completed_trials_before_date('2023-12-01');",
      "SELECT * FROM archive_completed_trials_before_date('2022-03-31');",
      "SELECT * FROM archive_completed_trials_before_date('2021-06-30');",
      "SELECT * FROM archive_completed_trials_before_date('2024-02-28');",
      "SELECT * FROM archive_completed_trials_before_date('2023-07-31');",
      "SELECT * FROM archive_completed_trials_before_date('2022-01-01');",
      "SELECT * FROM archive_completed_trials_before_date('2021-03-15');",
      "SELECT * FROM archive_completed_trials_before_date('2020-06-30');",
      "SELECT * FROM archive_completed_trials_before_date('2023-11-15');"
    ],
    "id": 44
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_source_name of type text and returns a numeric value representing the average age of individuals from a specific data source. The function performs a SELECT operation to calculate the average age by joining two tables: adults and data_sources. It uses the JOIN condition where the source_id column from the adults table matches the source_id column from the data_sources table. The WHERE clause filters the results to include only those rows where the source_name column in the data_sources table matches the value of the input parameter p_source_name. The function then returns the computed average age as a numeric value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_age_by_source(p_source_name text)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (SELECT AVG(a.age) FROM adults a JOIN data_sources ds ON a.source_id = ds.source_id WHERE ds.source_name = p_source_name);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "adult_demographics_and_income_analysis",
    "tables": [
      "adults",
      "data_sources"
    ],
    "call_sqls": [
      "SELECT get_average_age_by_source('Census Data');",
      "SELECT get_average_age_by_source('Survey Data');",
      "SELECT get_average_age_by_source('Internal Database');",
      "SELECT get_average_age_by_source('Public Records');",
      "SELECT get_average_age_by_source('Government API');",
      "SELECT get_average_age_by_source('Third-Party Vendor');",
      "SELECT get_average_age_by_source('Manual Entry');",
      "SELECT get_average_age_by_source('Historical Archive');",
      "SELECT get_average_age_by_source('Research Study');",
      "SELECT get_average_age_by_source('Social Media');",
      "SELECT get_average_age_by_source('Mobile App');",
      "SELECT get_average_age_by_source('Web Scraping');",
      "SELECT get_average_age_by_source('Partner Feed');",
      "SELECT get_average_age_by_source('Legacy System');",
      "SELECT get_average_age_by_source('Cloud Storage');",
      "SELECT get_average_age_by_source('Data Warehouse');",
      "SELECT get_average_age_by_source('CRM Export');",
      "SELECT get_average_age_by_source('ERP System');",
      "SELECT get_average_age_by_source('HR Records');",
      "SELECT get_average_age_by_source('Customer Surveys');"
    ],
    "id": 45
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_plane_location_by_pilot that accepts a single input parameter called pilot_name_input of type TEXT, which represents the name of a pilot, and returns a single TEXT value; the function declares a local variable named plane_location of type TEXT; the function's logic begins by executing a SELECT query that retrieves data from the database: it queries the \"Hangar\" table (aliased as h) and performs an INNER JOIN with the \"PilotSkills\" table (aliased as ps) using the condition that the plane_name column from the \"Hangar\" table is equal to the plane_name column from the \"PilotSkills\" table; the query includes a WHERE clause that filters the joined result set to only those rows where the pilot_name column from the \"PilotSkills\" table exactly matches the value provided in the pilot_name_input parameter; from the resulting row or rows, the query specifically extracts the value from the location column of the \"Hangar\" table and assigns this value into the local plane_location variable; after the SELECT operation, the function uses an IF-THEN-ELSE conditional statement to evaluate the content of the plane_location variable: if the plane_location variable is not NULL, meaning the query successfully found a matching record, the function returns the value stored in plane_location; otherwise, if the plane_location variable is NULL, indicating that no matching record was found by the query, the function returns the literal string 'Location not found'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_plane_location_by_pilot(pilot_name_input TEXT) RETURNS TEXT AS $$\nDECLARE\n    plane_location TEXT;\nBEGIN\n    SELECT h.location INTO plane_location\n    FROM \"Hangar\" h\n    JOIN \"PilotSkills\" ps ON h.plane_name = ps.plane_name\n    WHERE ps.pilot_name = pilot_name_input;\n\n    IF plane_location IS NOT NULL THEN\n        RETURN plane_location;\n    ELSE\n        RETURN 'Location not found';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "pilot_1",
    "tables": [
      "Hangar",
      "PilotSkills"
    ],
    "call_sqls": [
      "SELECT get_plane_location_by_pilot('Celko');",
      "SELECT get_plane_location_by_pilot('Higgins');",
      "SELECT get_plane_location_by_pilot('Smith');",
      "SELECT get_plane_location_by_pilot('Jones');",
      "SELECT get_plane_location_by_pilot('Miller');",
      "SELECT get_plane_location_by_pilot('Davis');",
      "SELECT get_plane_location_by_pilot('Wilson');",
      "SELECT get_plane_location_by_pilot('Taylor');",
      "SELECT get_plane_location_by_pilot('Anderson');",
      "SELECT get_plane_location_by_pilot('Thomas');",
      "SELECT get_plane_location_by_pilot('Jackson');",
      "SELECT get_plane_location_by_pilot('White');",
      "SELECT get_plane_location_by_pilot('Harris');",
      "SELECT get_plane_location_by_pilot('Martin');",
      "SELECT get_plane_location_by_pilot('Thompson');",
      "SELECT get_plane_location_by_pilot('Garcia');",
      "SELECT get_plane_location_by_pilot('Martinez');",
      "SELECT get_plane_location_by_pilot('Robinson');",
      "SELECT get_plane_location_by_pilot('Clark');",
      "SELECT get_plane_location_by_pilot('Rodriguez');"
    ],
    "id": 46
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named classify_user_by_access that accepts a single input parameter p_user_id of type bigint, which represents the unique identifier of a user, and returns a text value. The function first declares two local variables: v_access_count as an integer and v_user_role as text. It then performs a SELECT COUNT(*) operation on the access_logs table, counting all rows where the user_id column matches the input parameter p_user_id, and stores the result in v_access_count. Next, it performs a SELECT operation on the users table to retrieve the role column value for the row where the user_id column equals p_user_id, storing this value in v_user_role. The function then evaluates a series of conditional IF-ELSIF-ELSE statements: if v_access_count is greater than 100 and v_user_role is exactly equal to the string 'researcher', it returns the text 'Active Researcher'; otherwise, if v_access_count is greater than 50 and v_user_role is exactly equal to the string 'analyst', it returns 'Active Analyst'; otherwise, if v_access_count is greater than 10, it returns 'Regular User'; and in all other cases, it returns 'Infrequent User'.",
    "plsql": "CREATE OR REPLACE FUNCTION classify_user_by_access(p_user_id bigint)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_access_count integer;\n    v_user_role text;\nBEGIN\n    SELECT COUNT(*) INTO v_access_count FROM access_logs WHERE access_logs.user_id = p_user_id;\n    SELECT users.role INTO v_user_role FROM users WHERE users.user_id = p_user_id;\n    IF v_access_count > 100 AND v_user_role = 'researcher' THEN\n        RETURN 'Active Researcher';\n    ELSIF v_access_count > 50 AND v_user_role = 'analyst' THEN\n        RETURN 'Active Analyst';\n    ELSIF v_access_count > 10 THEN\n        RETURN 'Regular User';\n    ELSE\n        RETURN 'Infrequent User';\n    END IF;\nEND;\n$$;",
    "database_name": "earth_observation_and_environmental_data_management",
    "tables": [
      "products",
      "product_versions",
      "product_dependencies",
      "metadata",
      "data_files",
      "access_logs",
      "users",
      "upstream_references"
    ],
    "call_sqls": [
      "SELECT classify_user_by_access(1);",
      "SELECT classify_user_by_access(2);",
      "SELECT classify_user_by_access(3);",
      "SELECT classify_user_by_access(4);",
      "SELECT classify_user_by_access(5);",
      "SELECT classify_user_by_access(6);",
      "SELECT classify_user_by_access(7);",
      "SELECT classify_user_by_access(8);",
      "SELECT classify_user_by_access(9);",
      "SELECT classify_user_by_access(10);",
      "SELECT classify_user_by_access(11);",
      "SELECT classify_user_by_access(12);",
      "SELECT classify_user_by_access(13);",
      "SELECT classify_user_by_access(14);",
      "SELECT classify_user_by_access(15);",
      "SELECT classify_user_by_access(16);",
      "SELECT classify_user_by_access(17);",
      "SELECT classify_user_by_access(18);",
      "SELECT classify_user_by_access(19);",
      "SELECT classify_user_by_access(20);"
    ],
    "id": 47
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_specification_unit` that accepts a single input parameter, `para_spec_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `VARCHAR2`. Upon execution, the function declares a local variable named `v_unit` of data type `VARCHAR2` with a maximum length of 255 characters. The core operation of the function involves performing a `SELECT` statement to retrieve data. Specifically, it selects the value from the `unit` column from the table named `specifications`. The retrieved value is then immediately assigned to the local variable `v_unit`. This selection is conditional, meaning only rows that satisfy a specific criterion are considered. The condition for selection is that the value in the `spec_id` column of the `specifications` table must be equal to the value provided in the input parameter `para_spec_id`. After successfully retrieving the `unit` value into `v_unit`, the function then returns the value stored in `v_unit` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_specification_unit(para_spec_id NUMBER) RETURN VARCHAR2 IS\n  v_unit VARCHAR2(255);\nBEGIN\n  SELECT unit INTO v_unit FROM specifications WHERE spec_id = para_spec_id;\n  RETURN v_unit;\nEND;",
    "database_name": "bicycle_sa_sizing",
    "tables": [
      "bicycle_models",
      "sizes",
      "specifications"
    ],
    "call_sqls": [
      "SELECT get_specification_unit(0) FROM DUAL",
      "SELECT get_specification_unit(1) FROM DUAL",
      "SELECT get_specification_unit(2) FROM DUAL",
      "SELECT get_specification_unit(3) FROM DUAL",
      "SELECT get_specification_unit(4) FROM DUAL",
      "SELECT get_specification_unit(5) FROM DUAL",
      "SELECT get_specification_unit(6) FROM DUAL",
      "SELECT get_specification_unit(7) FROM DUAL",
      "SELECT get_specification_unit(8) FROM DUAL",
      "SELECT get_specification_unit(9) FROM DUAL",
      "SELECT get_specification_unit(10) FROM DUAL",
      "SELECT get_specification_unit(11) FROM DUAL",
      "SELECT get_specification_unit(12) FROM DUAL",
      "SELECT get_specification_unit(13) FROM DUAL",
      "SELECT get_specification_unit(14) FROM DUAL",
      "SELECT get_specification_unit(15) FROM DUAL",
      "SELECT get_specification_unit(16) FROM DUAL",
      "SELECT get_specification_unit(17) FROM DUAL",
      "SELECT get_specification_unit(18) FROM DUAL",
      "SELECT get_specification_unit(19) FROM DUAL"
    ],
    "id": 48
  },
  {
    "ir": "Write a PL/pgSQL function named `update_ship_status_on_maintenance` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables like `NEW` and `OLD` representing the new and old row data, respectively. The function is declared to return `TRIGGER`, indicating its purpose as a trigger function. Upon execution, the function performs a single `UPDATE` operation on the `ships` table. Specifically, it sets the value of the `status` column to the string literal `'maintenance'`. This update is applied to rows in the `ships` table where two conditions are met: first, the `ship_id` column in the `ships` table must be equal to the `ship_id` value from the `NEW` row (which represents the data of the row that just triggered the function); and second, the `status` column in the `ships` table must currently be equal to the string literal `'active'`. After attempting this update, the function returns the `NEW` row, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL.\n\nAdditionally, there is a trigger named `trg_ship_maintenance_update_status` defined. This trigger is configured to activate `AFTER INSERT` operations on the `ship_maintenance` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is inserted into the `ship_maintenance` table. When activated, this trigger executes the previously described `update_ship_status_on_maintenance()` function. The overall effect is that whenever a new record is inserted into the `ship_maintenance` table, the `update_ship_status_on_maintenance` function is called. This function then attempts to update the `status` of the corresponding ship in the `ships` table to `'maintenance'`, but only if that ship's `status` is currently `'active'`.",
    "plsql": "CREATE OR REPLACE FUNCTION update_ship_status_on_maintenance() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE ships \n    SET status = 'maintenance' \n    WHERE ship_id = NEW.ship_id \n      AND status = 'active';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_ship_maintenance_update_status\nAFTER INSERT ON ship_maintenance\nFOR EACH ROW EXECUTE FUNCTION update_ship_status_on_maintenance();",
    "database_name": "naval_vessel_management_and_organization",
    "tables": [
      "ships",
      "fleets",
      "ship_assignments",
      "fleet_commanders",
      "ship_classes",
      "hull_numbers",
      "ship_crew",
      "ship_deployments",
      "ship_maintenance"
    ],
    "call_sqls": [
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (101, 2, '2024-01-16', 'Hull inspection', '15000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (102, 3, '2024-01-17', 'Navigation system update', '25000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (103, 4, '2024-01-18', 'Propeller repair', '18000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (104, 5, '2024-01-19', 'Radar calibration', '12000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (105, 6, '2024-01-20', 'Lifeboat maintenance', '8000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (106, 7, '2024-01-21', 'Paint job', '22000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (107, 8, '2024-01-22', 'Electrical system check', '19000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (108, 9, '2024-01-23', 'Fuel tank cleaning', '14000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (109, 10, '2024-01-24', 'Communication upgrade', '35000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (110, 11, '2024-01-25', 'Anchor chain replacement', '9000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (111, 12, '2024-01-26', 'Cabin refurbishment', '28000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (112, 13, '2024-01-27', 'Fire suppression system test', '11000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (113, 14, '2024-01-28', 'Ballast tank inspection', '16000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (114, 15, '2024-01-29', 'Winch repair', '7500.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (115, 16, '2024-01-30', 'Sonar maintenance', '32000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (116, 17, '2024-01-31', 'Rudder alignment', '21000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (117, 18, '2024-02-01', 'Bilge pump replacement', '13000.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (118, 19, '2024-02-02', 'Mast inspection', '9500.0');",
      "INSERT INTO ship_maintenance (maintenance_id, ship_id, maintenance_date, description, cost) VALUES (119, 20, '2024-02-03', 'Cargo hold cleaning', '17000.0');"
    ],
    "id": 49
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_product_media_count` that accepts a single input parameter, `product_id_input`, which is of type `bigint`. This function is designed to return a table containing two columns: `image_count` of type `bigint` and `video_count` of type `bigint`. The function's execution begins by performing a `SELECT` operation to count the total number of rows in the `product_images` table. This count is determined by applying a `WHERE` clause that filters records where the `product_id` column in the `product_images` table is exactly equal to the value provided by the `product_id_input` parameter. The resulting count from this operation is then assigned to the `image_count` variable. Subsequently, another `SELECT` operation is executed to count the total number of rows in the `product_videos` table. This count is similarly determined by applying a `WHERE` clause that filters records where the `product_id` column in the `product_videos` table is exactly equal to the value provided by the `product_id_input` parameter. The resulting count from this second operation is then assigned to the `video_count` variable. Finally, the function returns the current values held by `image_count` and `video_count` as a single row in the result table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_media_count(product_id_input bigint)\nRETURNS TABLE(image_count bigint, video_count bigint)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    SELECT COUNT(*) INTO image_count FROM product_images WHERE product_id = product_id_input;\n    SELECT COUNT(*) INTO video_count FROM product_videos WHERE product_id = product_id_input;\n    RETURN NEXT;\nEND;\n$$;",
    "database_name": "childrens_clothing_size_chart_275598",
    "tables": [
      "product_images",
      "product_videos"
    ],
    "call_sqls": [
      "SELECT * FROM get_product_media_count(1);",
      "SELECT * FROM get_product_media_count(2);",
      "SELECT * FROM get_product_media_count(3);",
      "SELECT * FROM get_product_media_count(4);",
      "SELECT * FROM get_product_media_count(5);",
      "SELECT * FROM get_product_media_count(10);",
      "SELECT * FROM get_product_media_count(15);",
      "SELECT * FROM get_product_media_count(20);",
      "SELECT * FROM get_product_media_count(25);",
      "SELECT * FROM get_product_media_count(30);",
      "SELECT * FROM get_product_media_count(35);",
      "SELECT * FROM get_product_media_count(40);",
      "SELECT * FROM get_product_media_count(45);",
      "SELECT * FROM get_product_media_count(50);",
      "SELECT * FROM get_product_media_count(55);",
      "SELECT * FROM get_product_media_count(60);",
      "SELECT * FROM get_product_media_count(65);",
      "SELECT * FROM get_product_media_count(70);",
      "SELECT * FROM get_product_media_count(75);",
      "SELECT * FROM get_product_media_count(80);",
      "SELECT * FROM get_product_media_count(85);"
    ],
    "id": 50
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_account_transaction that accepts three input parameters: a bigint parameter p_account_id representing the unique identifier for an account, a real parameter p_amount representing the monetary value of the transaction, and a text parameter p_transaction_type describing the nature of the transaction; the procedure first declares two local variables, a bigint variable v_transaction_id and a text variable v_description; it then initializes the v_transaction_id variable by executing a SELECT query on the transactions table to find the current maximum value in the transaction_id column, using the COALESCE function to substitute a value of 0 if the maximum value is null, and then adding 1 to this result to generate a new sequential identifier; it subsequently initializes the v_description variable by calling the replace function on the p_transaction_type input parameter, which searches for the substring 'Credit' and replaces every occurrence of it with the substring 'Incoming payment'; the procedure then performs an INSERT operation into the transactions table, adding a new row with the following column values: the v_transaction_id for the transaction_id column, the p_account_id for the account_id column, the result of casting the CURRENT_DATE to text for the transaction_date column, the p_amount for the amount column, the p_transaction_type for the transaction_type column, the computed v_description for the description column, and the literal string 'Pending' for the transaction_status column.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_account_transaction(\n    p_account_id bigint,\n    p_amount real,\n    p_transaction_type text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_transaction_id bigint;\n    v_description text;\nBEGIN\n    v_transaction_id := (SELECT COALESCE(MAX(transaction_id), 0) + 1 FROM transactions);\n    v_description := replace(p_transaction_type, 'Credit', 'Incoming payment');\n    \n    INSERT INTO transactions (transaction_id, account_id, transaction_date, amount, transaction_type, description, transaction_status)\n    VALUES (\n        v_transaction_id,\n        p_account_id,\n        CURRENT_DATE::text,\n        p_amount,\n        p_transaction_type,\n        v_description,\n        'Pending'\n    );\nEND;\n$$;",
    "database_name": "banking_and_financial_account_management",
    "tables": [
      "accounts",
      "banks",
      "currencies",
      "transactions",
      "users",
      "audit_logs"
    ],
    "call_sqls": [
      "CALL process_account_transaction(1, 1000.0, 'Credit');",
      "CALL process_account_transaction(1, 500.0, 'Debit');",
      "CALL process_account_transaction(0, 250.75, 'Credit');",
      "CALL process_account_transaction(0, 1200.0, 'Debit');",
      "CALL process_account_transaction(1, 75.50, 'Credit');",
      "CALL process_account_transaction(0, 300.0, 'Credit');",
      "CALL process_account_transaction(1, 1500.0, 'Debit');",
      "CALL process_account_transaction(0, 99.99, 'Debit');",
      "CALL process_account_transaction(1, 2000.0, 'Credit');",
      "CALL process_account_transaction(0, 450.25, 'Credit');",
      "CALL process_account_transaction(1, 10.0, 'Debit');",
      "CALL process_account_transaction(0, 780.0, 'Debit');",
      "CALL process_account_transaction(1, 333.33, 'Credit');",
      "CALL process_account_transaction(0, 25.0, 'Credit');",
      "CALL process_account_transaction(1, 150.0, 'Debit');",
      "CALL process_account_transaction(0, 999.99, 'Debit');",
      "CALL process_account_transaction(1, 5.0, 'Credit');",
      "CALL process_account_transaction(0, 2100.0, 'Credit');",
      "CALL process_account_transaction(1, 50.5, 'Debit');",
      "CALL process_account_transaction(0, 1234.56, 'Debit');"
    ],
    "id": 51
  },
  {
    "ir": "Write a PostgreSQL stored procedure named sync_user_created_records that accepts one input parameter p_user_id of type bigint, which represents the unique identifier for a user, and performs the following operations: first, it declares three local variables v_user_exists as a boolean to check for user existence, v_budget_count as an integer to store the count of budget records, and v_forecast_count as an integer to store the count of forecast records; then, it checks if a user with the specified p_user_id exists in the users table by using a SELECT EXISTS subquery that looks for any row where the user_id column matches p_user_id and stores the result in v_user_exists; if v_user_exists is false, it inserts a new row into the users table with the provided p_user_id, sets user_name to 'System Generated', email to 'system@example.com', role to 'system', department to 'IT', sets both created_date and last_login_date to the current date in 'YYYY-MM-DD' format using the TO_CHAR function with clock_timestamp() to get the current timestamp, and sets status to 'Active'; next, it counts the number of rows in the budgets table where the created_by column equals p_user_id and stores the result in v_budget_count, and similarly counts the number of rows in the forecasts table where the created_by column equals p_user_id and stores the result in v_forecast_count; finally, if both v_budget_count and v_forecast_count are zero, it inserts a new row into the budgets table by selecting the maximum budget_id from the budgets table, using COALESCE to handle null values by defaulting to 0, then increments it by 1 to generate a new budget_id, selects the year_id from the financial_years table by ordering year_id in descending order and taking the top row with LIMIT 1, sets budget_amount to '10000.0', budget_type to 'Default', created_by to p_user_id, and created_date to the current date in 'YYYY-MM-DD' format using TO_CHAR with clock_timestamp().",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_user_created_records(p_user_id bigint)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_user_exists boolean;\n    v_budget_count integer;\n    v_forecast_count integer;\nBEGIN\n    SELECT EXISTS(SELECT 1 FROM users WHERE user_id = p_user_id) INTO v_user_exists;\n    \n    IF NOT v_user_exists THEN\n        INSERT INTO users (user_id, user_name, email, role, department, created_date, last_login_date, status)\n        VALUES (p_user_id, 'System Generated', 'system@example.com', 'system', 'IT', TO_CHAR(clock_timestamp(), 'YYYY-MM-DD'), TO_CHAR(clock_timestamp(), 'YYYY-MM-DD'), 'Active');\n    END IF;\n\n    SELECT COUNT(*) INTO v_budget_count FROM budgets WHERE created_by = p_user_id;\n    SELECT COUNT(*) INTO v_forecast_count FROM forecasts WHERE created_by = p_user_id;\n\n    IF v_budget_count = 0 AND v_forecast_count = 0 THEN\n        INSERT INTO budgets (budget_id, year_id, budget_amount, budget_type, created_by, created_date)\n        SELECT COALESCE(MAX(budget_id), 0) + 1, \n               (SELECT year_id FROM financial_years ORDER BY year_id DESC LIMIT 1),\n               '10000.0', 'Default', p_user_id, TO_CHAR(clock_timestamp(), 'YYYY-MM-DD')\n        FROM budgets;\n    END IF;\nEND;\n$$;",
    "database_name": "corporate_financial_performance_tracking",
    "tables": [
      "financial_data",
      "financial_years",
      "budgets",
      "financial_indicators",
      "forecasts",
      "users"
    ],
    "call_sqls": [
      "CALL sync_user_created_records(100);",
      "CALL sync_user_created_records(101);",
      "CALL sync_user_created_records(102);",
      "CALL sync_user_created_records(103);",
      "CALL sync_user_created_records(104);",
      "CALL sync_user_created_records(105);",
      "CALL sync_user_created_records(106);",
      "CALL sync_user_created_records(107);",
      "CALL sync_user_created_records(108);",
      "CALL sync_user_created_records(109);",
      "CALL sync_user_created_records(110);",
      "CALL sync_user_created_records(111);",
      "CALL sync_user_created_records(112);",
      "CALL sync_user_created_records(113);",
      "CALL sync_user_created_records(114);",
      "CALL sync_user_created_records(115);",
      "CALL sync_user_created_records(116);",
      "CALL sync_user_created_records(117);",
      "CALL sync_user_created_records(118);",
      "CALL sync_user_created_records(119);"
    ],
    "id": 52
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_genre_rating_variance` that accepts two input parameters: `p_genre_name` of data type `VARCHAR2`, representing the name of a specific genre, and `p_min_members` of data type `NUMBER`, representing the minimum number of members an anime must have to be considered in the calculation. This function is designed to return a single value of data type `NUMBER`, which will represent the population variance of ratings for anime belonging to the specified genre and meeting the minimum member count criterion.\n\nThe function declares a local variable `v_variance` of data type `NUMBER` to store the calculated variance.\n\nThe core operation of the function involves a `SELECT` statement that calculates the population variance of anime ratings. This `SELECT` statement retrieves data by performing a series of `JOIN` operations:\n1. It starts by selecting from the `anime` table, aliased as `a`.\n2. It then performs an `INNER JOIN` with the `anime_genre` table, aliased as `ag`, on the condition that `a.anime_id` from the `anime` table is equal to `ag.anime_id` from the `anime_genre` table. This links anime records to their associated genres.\n3. Subsequently, it performs another `INNER JOIN` with the `genres` table, aliased as `g`, on the condition that `ag.genre_id` from the `anime_genre` table is equal to `g.genre_id` from the `genres` table. This further links the genre associations to the actual genre names.\n\nThe `WHERE` clause filters the joined records based on two conditions:\n1. `g.genre_name = p_genre_name`: This condition ensures that only records associated with the genre name provided in the `p_genre_name` input parameter are included in the calculation.\n2. `a.members >= p_min_members`: This condition further filters the records, including only those anime where the value in the `members` column of the `anime` table is greater than or equal to the value provided in the `p_min_members` input parameter.\n\nThe `VAR_POP(a.rating)` aggregate function is used to compute the population variance of the `rating` column from the `anime` table for all the records that satisfy the `WHERE` clause conditions. The result of this variance calculation is then stored into the local variable `v_variance`.\n\nFinally, the function returns the value stored in `v_variance` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_genre_rating_variance(p_genre_name IN VARCHAR2, p_min_members IN NUMBER)\nRETURN NUMBER\nIS\n    v_variance NUMBER;\nBEGIN\n    SELECT VAR_POP(a.rating)\n    INTO v_variance\n    FROM anime a\n    JOIN anime_genre ag ON a.anime_id = ag.anime_id\n    JOIN genres g ON ag.genre_id = g.genre_id\n    WHERE g.genre_name = p_genre_name\n    AND a.members >= p_min_members;\n    \n    RETURN v_variance;\nEND;",
    "database_name": "anime_daue_tracking",
    "tables": [
      "anime",
      "anime_genre",
      "genres",
      "ratings",
      "recommendations",
      "users",
      "watch_history",
      "user_role_assignment",
      "user_roles"
    ],
    "call_sqls": [
      "SELECT calculate_genre_rating_variance('Action', 1000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Romance', 5000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Fantasy', 10000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Sci-Fi', 2000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Comedy', 8000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Drama', 15000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Adventure', 3000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Mystery', 1000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Horror', 500) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Slice of Life', 4000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Supernatural', 2500) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Sports', 1200) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Mecha', 600) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Music', 800) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Ecchi', 200) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Harem', 1500) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Isekai', 7000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Shounen', 25000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Shoujo', 10000) FROM DUAL",
      "SELECT calculate_genre_rating_variance('Seinen', 5000) FROM DUAL"
    ],
    "id": 53
  },
  {
    "ir": "Write a PLpgSQL function named update_ticket_owner that accepts three parameters: para_ticket_id of type text, para_new_owner_id of type bigint, and para_updated_by of type bigint. The function first declares a local variable ticket_exists of type boolean. It then checks if a ticket with the specified para_ticket_id exists in the tickets table by executing a SELECT statement that uses the EXISTS function to determine the presence of any row with a matching ticket_id. The result of this check is stored in the ticket_exists variable. If no such ticket exists (i.e., ticket_exists is false), the function immediately returns false. If the ticket does exist, the function proceeds to update the tickets table by setting the owner_id column to the value of para_new_owner_id for the row where ticket_id matches para_ticket_id. Following the update, the function inserts a new record into the ticket_history table. This record includes a history_id, which is calculated as one more than the current maximum history_id in the ticket_history table, or 1 if no records exist. The new record also includes the para_ticket_id, para_updated_by as the user_id, a fixed string 'OWNER_CHANGE' as the update_type, the current date cast to text as the update_date, and a concatenated string 'Owner updated to user ID: ' followed by the para_new_owner_id cast to text as the update_description. Finally, the function returns true, indicating that the operation was successful.",
    "plsql": "CREATE OR REPLACE FUNCTION update_ticket_owner(para_ticket_id text, para_new_owner_id bigint, para_updated_by bigint) RETURNS boolean LANGUAGE plpgsql AS $$ \nDECLARE\n    ticket_exists boolean;\nBEGIN \n    -- Check if ticket exists\n    SELECT EXISTS(SELECT 1 FROM tickets WHERE ticket_id = para_ticket_id) INTO ticket_exists;\n    \n    IF NOT ticket_exists THEN\n        RETURN false;\n    END IF;\n    \n    UPDATE tickets SET owner_id = para_new_owner_id WHERE ticket_id = para_ticket_id; \n    \n    INSERT INTO ticket_history (history_id, ticket_id, user_id, update_type, update_date, update_description) \n    VALUES ((SELECT COALESCE(MAX(history_id), 0) + 1 FROM ticket_history), para_ticket_id, para_updated_by, 'OWNER_CHANGE', CURRENT_DATE::text, 'Owner updated to user ID: ' || para_new_owner_id::text); \n    \n    RETURN true; \nEND; $$;",
    "database_name": "bug_tracking_and_issue_management_781382",
    "tables": [
      "tickets",
      "ticket_history",
      "users",
      "projects",
      "categories"
    ],
    "call_sqls": [
      "SELECT update_ticket_owner('TICK-001', 1001, 5001);",
      "SELECT update_ticket_owner('TICK-002', 1002, 5002);",
      "SELECT update_ticket_owner('TICK-003', 1003, 5003);",
      "SELECT update_ticket_owner('TICK-004', 1004, 5004);",
      "SELECT update_ticket_owner('TICK-005', 1005, 5005);",
      "SELECT update_ticket_owner('TICK-006', 1006, 5006);",
      "SELECT update_ticket_owner('TICK-007', 1007, 5007);",
      "SELECT update_ticket_owner('TICK-008', 1008, 5008);",
      "SELECT update_ticket_owner('TICK-009', 1009, 5009);",
      "SELECT update_ticket_owner('TICK-010', 1010, 5010);",
      "SELECT update_ticket_owner('BUG-123', 2001, 6001);",
      "SELECT update_ticket_owner('FEAT-456', 2002, 6002);",
      "SELECT update_ticket_owner('SUP-789', 2003, 6003);",
      "SELECT update_ticket_owner('TASK-101', 2004, 6004);",
      "SELECT update_ticket_owner('INC-202', 2005, 6005);",
      "SELECT update_ticket_owner('CHG-303', 2006, 6006);",
      "SELECT update_ticket_owner('TICK-ABC', 3001, 7001);",
      "SELECT update_ticket_owner('TICK-XYZ', 3002, 7002);",
      "SELECT update_ticket_owner('PROJ-001', 4001, 8001);",
      "SELECT update_ticket_owner('PROJ-002', 4002, 8002);"
    ],
    "id": 54
  },
  {
    "ir": "Write a PLpgSQL function named calculate_nationality_distribution_log that accepts a single numeric input parameter named base_numeric, which serves as the base for a logarithmic calculation, and returns a numeric value. The function begins by declaring four local variables: distinct_nationalities as an integer, total_hosts as an integer, ratio as numeric, and log_result as numeric. It then executes a SELECT statement on the host table to compute two aggregate values: the count of distinct values in the Nationality column and the total count of all rows in the table, storing these results into the distinct_nationalities and total_hosts variables respectively. Following this data retrieval, the function uses a conditional IF statement to check if both total_hosts and distinct_nationalities are greater than zero. If this condition is true, it calculates a ratio by casting distinct_nationalities to numeric and dividing it by the numeric cast of total_hosts, assigning the result to the ratio variable. It then enters another nested IF statement to verify that the calculated ratio is greater than zero; if true, it computes the logarithm of the ratio using the provided base_numeric parameter as the base via the log(base, number) function and assigns this result to log_result. If the ratio is not greater than zero, or if the initial condition (total_hosts > 0 AND distinct_nationalities > 0) is false, the function assigns a value of zero to log_result. Finally, the function returns the value stored in the log_result variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_nationality_distribution_log(base_numeric numeric)\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    distinct_nationalities integer;\n    total_hosts integer;\n    ratio numeric;\n    log_result numeric;\nBEGIN\n    SELECT COUNT(DISTINCT \"Nationality\"), COUNT(*)\n    INTO distinct_nationalities, total_hosts\n    FROM host;\n    \n    IF total_hosts > 0 AND distinct_nationalities > 0 THEN\n        ratio := distinct_nationalities::numeric / total_hosts::numeric;\n        -- log(base, number) returns the logarithm of number to base base\n        -- Ensure ratio > 0 for log calculation\n        IF ratio > 0 THEN\n            log_result := log(base_numeric, ratio);\n        ELSE\n            log_result := 0;\n        END IF;\n    ELSE\n        log_result := 0;\n    END IF;\n    \n    RETURN log_result;\nEND;\n$$;",
    "database_name": "party_host",
    "tables": [
      "host",
      "party",
      "party_host"
    ],
    "call_sqls": [
      "SELECT calculate_nationality_distribution_log(2);",
      "SELECT calculate_nationality_distribution_log(10);",
      "SELECT calculate_nationality_distribution_log(2.5);",
      "SELECT calculate_nationality_distribution_log(1.5);",
      "SELECT calculate_nationality_distribution_log(3);",
      "SELECT calculate_nationality_distribution_log(5);",
      "SELECT calculate_nationality_distribution_log(2.71828);",
      "SELECT calculate_nationality_distribution_log(1.1);",
      "SELECT calculate_nationality_distribution_log(100);",
      "SELECT calculate_nationality_distribution_log(0.5);",
      "SELECT calculate_nationality_distribution_log(0.8);",
      "SELECT calculate_nationality_distribution_log(15);",
      "SELECT calculate_nationality_distribution_log(2.0);",
      "SELECT calculate_nationality_distribution_log(4.2);",
      "SELECT calculate_nationality_distribution_log(7);",
      "SELECT calculate_nationality_distribution_log(20);",
      "SELECT calculate_nationality_distribution_log(0.25);",
      "SELECT calculate_nationality_distribution_log(0.9);",
      "SELECT calculate_nationality_distribution_log(2.3);"
    ],
    "id": 55
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_average_points that accepts one input parameter p_event_id of type bigint, which is used to identify a specific event, and returns a value of type real; the function begins by declaring a local variable avg_points of type real; it then executes a SELECT statement that calculates the average value of the points column from the event_results table, specifically for all rows where the event_id column in the event_results table is equal to the provided input parameter p_event_id, and stores the result of this AVG aggregation into the local variable avg_points; following this calculation, the function uses a conditional IF-THEN-ELSE statement to check if the calculated avg_points value is NULL, which would occur if no rows were found matching the condition, and if true, the function returns the value 0, but if the avg_points value is not NULL, the function returns the calculated average value stored in the avg_points variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_points(p_event_id bigint) RETURNS real LANGUAGE plpgsql AS $$\nDECLARE\n    avg_points real;\nBEGIN\n    SELECT AVG(points) INTO avg_points\n    FROM event_results\n    WHERE event_results.event_id = p_event_id;\n\n    IF avg_points IS NULL THEN\n        RETURN 0;\n    ELSE\n        RETURN avg_points;\n    END IF;\nEND;\n$$;",
    "database_name": "athletics_performance_tracking_and_analysis_366778",
    "tables": [
      "event_results",
      "performances"
    ],
    "call_sqls": [
      "SELECT calculate_average_points(1);",
      "SELECT calculate_average_points(2);",
      "SELECT calculate_average_points(3);",
      "SELECT calculate_average_points(4);",
      "SELECT calculate_average_points(5);",
      "SELECT calculate_average_points(10);",
      "SELECT calculate_average_points(15);",
      "SELECT calculate_average_points(20);",
      "SELECT calculate_average_points(25);",
      "SELECT calculate_average_points(30);",
      "SELECT calculate_average_points(35);",
      "SELECT calculate_average_points(40);",
      "SELECT calculate_average_points(45);",
      "SELECT calculate_average_points(50);",
      "SELECT calculate_average_points(55);",
      "SELECT calculate_average_points(60);",
      "SELECT calculate_average_points(65);",
      "SELECT calculate_average_points(70);",
      "SELECT calculate_average_points(75);",
      "SELECT calculate_average_points(80);",
      "SELECT calculate_average_points(100);"
    ],
    "id": 56
  },
  {
    "ir": "Write a PostgreSQL function named get_customer_contact_info that takes no input parameters and returns a table result set with three columns: customer_name of type text, contact_number of type text, and email of type text. The function executes a single SELECT query that retrieves all records from the customers table, specifically extracting the customer_name, contact_number, and email columns from each row. The function uses the RETURN QUERY statement to return the complete result set of this query, effectively providing a comprehensive list of all customer contact information stored in the database. The function is written in the PL/pgSQL language and is designed to replace any existing function with the same name when created or replaced.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_contact_info() RETURNS TABLE(customer_name text, contact_number text, email text) LANGUAGE plpgsql AS $$\nBEGIN\nRETURN QUERY SELECT c.customer_name, c.contact_number, c.email FROM customers c;\nEND;\n$$;",
    "database_name": "telecommunication_billing_and_pricing_structure",
    "tables": [
      "customers",
      "billing_addresses",
      "users",
      "access_logs"
    ],
    "call_sqls": [
      "SELECT * FROM get_customer_contact_info();",
      "SELECT customer_name, contact_number FROM get_customer_contact_info();",
      "SELECT * FROM get_customer_contact_info() WHERE customer_name LIKE 'A%';",
      "SELECT * FROM get_customer_contact_info() ORDER BY customer_name;",
      "SELECT customer_name, email FROM get_customer_contact_info() WHERE contact_number IS NOT NULL;",
      "SELECT * FROM get_customer_contact_info() LIMIT 5;",
      "SELECT COUNT(*) FROM get_customer_contact_info();",
      "SELECT DISTINCT customer_name FROM get_customer_contact_info();",
      "SELECT * FROM get_customer_contact_info() WHERE customer_name = 'Alice Johnson';",
      "SELECT * FROM get_customer_contact_info() WHERE customer_name IN ('Alice Johnson', 'Bob Williams');",
      "SELECT customer_name, contact_number, email FROM get_customer_contact_info() OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY;",
      "SELECT * FROM get_customer_contact_info() WHERE contact_number LIKE '+91%';",
      "SELECT customer_name, LENGTH(customer_name) as name_length FROM get_customer_contact_info();",
      "SELECT * FROM get_customer_contact_info() WHERE customer_name ILIKE '%john%';",
      "SELECT customer_name, UPPER(email) FROM get_customer_contact_info();",
      "SELECT * FROM get_customer_contact_info() WHERE customer_name ~ '^[A-Z]';",
      "SELECT customer_name, contact_number FROM get_customer_contact_info() WHERE email IS NOT NULL AND contact_number IS NOT NULL;",
      "SELECT * FROM get_customer_contact_info() ORDER BY email DESC;",
      "SELECT * FROM get_customer_contact_info() CROSS JOIN (SELECT 1 as dummy) t;"
    ],
    "id": 57
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_avg_duration_atan that accepts a single input parameter p_car_id of type NUMBER, which is used to identify a specific car, and returns a value of type NUMBER; the function declares a local variable v_avg_duration of type NUMBER to store the result; the function executes a SELECT statement that retrieves data from the access_logs table, specifically calculating the arctangent (using the ATAN function) of the average value (using the AVG aggregate function) of the duration column for all rows in the access_logs table where the car_id column matches the value of the input parameter p_car_id; the result of this calculation is then stored into the local variable v_avg_duration; finally, the function returns the value stored in v_avg_duration.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_avg_duration_atan(p_car_id NUMBER) RETURN NUMBER AS\n  v_avg_duration NUMBER;\nBEGIN\n  SELECT ATAN(AVG(duration)) INTO v_avg_duration \n  FROM access_logs \n  WHERE car_id = p_car_id;\n  RETURN v_avg_duration;\nEND;",
    "database_name": "automotive_dfcpa_characte",
    "tables": [
      "cars",
      "access_logs",
      "users",
      "data_versions"
    ],
    "call_sqls": [
      "SELECT calculate_avg_duration_atan(0) FROM dual",
      "SELECT calculate_avg_duration_atan(1) FROM dual",
      "SELECT calculate_avg_duration_atan(2) FROM dual",
      "SELECT calculate_avg_duration_atan(3) FROM dual",
      "SELECT calculate_avg_duration_atan(4) FROM dual",
      "SELECT calculate_avg_duration_atan(5) FROM dual",
      "SELECT calculate_avg_duration_atan(6) FROM dual",
      "SELECT calculate_avg_duration_atan(7) FROM dual",
      "SELECT calculate_avg_duration_atan(8) FROM dual",
      "SELECT calculate_avg_duration_atan(9) FROM dual",
      "SELECT calculate_avg_duration_atan(10) FROM dual",
      "SELECT calculate_avg_duration_atan(15) FROM dual",
      "SELECT calculate_avg_duration_atan(20) FROM dual",
      "SELECT calculate_avg_duration_atan(25) FROM dual",
      "SELECT calculate_avg_duration_atan(30) FROM dual",
      "SELECT calculate_avg_duration_atan(35) FROM dual",
      "SELECT calculate_avg_duration_atan(40) FROM dual",
      "SELECT calculate_avg_duration_atan(45) FROM dual",
      "SELECT calculate_avg_duration_atan(50) FROM dual",
      "SELECT calculate_avg_duration_atan(100) FROM dual"
    ],
    "id": 58
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_region_population_category that accepts a single input parameter p_region_id of type NUMBER, which is used to identify a specific region record, and returns a VARCHAR2 string; within the function, it declares local variables v_population (NUMBER), v_region_name (VARCHAR2(255)), v_state (VARCHAR2(255)), and v_result (VARCHAR2(4000)); it then executes a SELECT statement to query the regions table, retrieving the population, region_name, and state column values for the row where the region_id column matches the provided p_region_id parameter, and stores these retrieved values into the local variables v_population, v_region_name, and v_state respectively; following the data retrieval, it uses a conditional IF-ELSIF-ELSE block to evaluate the value of v_population: if v_population is greater than 20000000, it constructs the v_result string by concatenating the literal 'Large region: ' with the v_region_name, a comma and space, the v_state, and finally a string containing the population value in parentheses; if v_population is not greater than 20000000 but is greater than 10000000, it constructs v_result by concatenating 'Medium region: ' with v_region_name, a comma and space, and v_state; if v_population is not greater than 10000000 but is greater than 0, it constructs v_result by concatenating 'Small region: ' with just the v_region_name; if none of the previous conditions are met (i.e., v_population is 0, negative, or null), it assigns the literal string 'Invalid population data' to v_result; finally, the function returns the value of the v_result variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_population_category(p_region_id NUMBER)\nRETURN VARCHAR2\nIS\n    v_population NUMBER;\n    v_region_name VARCHAR2(255);\n    v_state VARCHAR2(255);\n    v_result VARCHAR2(4000);\nBEGIN\n    SELECT population, region_name, state\n    INTO v_population, v_region_name, v_state\n    FROM regions\n    WHERE region_id = p_region_id;\n    \n    IF v_population > 20000000 THEN\n        v_result := 'Large region: ' || v_region_name || ', ' || v_state || ' (Population: ' || v_population || ')';\n    ELSIF v_population > 10000000 THEN\n        v_result := 'Medium region: ' || v_region_name || ', ' || v_state;\n    ELSIF v_population > 0 THEN\n        v_result := 'Small region: ' || v_region_name;\n    ELSE\n        v_result := 'Invalid population data';\n    END IF;\n    \n    RETURN v_result;\nEND;",
    "database_name": "baby_npa_demographics",
    "tables": [
      "names",
      "name_histories",
      "name_rankings",
      "name_sources",
      "name_trends",
      "name_variations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_region_population_category(0) FROM dual",
      "SELECT get_region_population_category(1) FROM dual",
      "SELECT get_region_population_category(2) FROM dual",
      "SELECT get_region_population_category(3) FROM dual",
      "SELECT get_region_population_category(4) FROM dual",
      "SELECT get_region_population_category(5) FROM dual",
      "SELECT get_region_population_category(6) FROM dual",
      "SELECT get_region_population_category(7) FROM dual",
      "SELECT get_region_population_category(8) FROM dual",
      "SELECT get_region_population_category(9) FROM dual",
      "SELECT get_region_population_category(10) FROM dual",
      "SELECT get_region_population_category(11) FROM dual",
      "SELECT get_region_population_category(12) FROM dual",
      "SELECT get_region_population_category(13) FROM dual",
      "SELECT get_region_population_category(14) FROM dual",
      "SELECT get_region_population_category(15) FROM dual",
      "SELECT get_region_population_category(16) FROM dual",
      "SELECT get_region_population_category(17) FROM dual",
      "SELECT get_region_population_category(18) FROM dual",
      "SELECT get_region_population_category(19) FROM dual"
    ],
    "id": 59
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter, para_restaurant_id of type bigint, and performs the following operations: It first checks if there are any rows in the loyalty_programs table where the restaurant_id column matches the value of para_restaurant_id, the program_status column is equal to 'active', and the points_expiration column, when cast to a date, is earlier than the current date. If such rows exist, it updates the loyalty_programs table by setting the program_status column to 'inactive' for all rows where the restaurant_id column matches para_restaurant_id, the program_status column is equal to 'active', and the points_expiration column, when cast to a date, is earlier than the current date.",
    "plsql": "CREATE OR REPLACE FUNCTION check_and_expire_programs(para_restaurant_id bigint) RETURNS void LANGUAGE plpgsql AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM loyalty_programs WHERE restaurant_id = para_restaurant_id AND program_status = 'active' AND points_expiration::date < CURRENT_DATE) THEN\n        UPDATE loyalty_programs \n        SET program_status = 'inactive' \n        WHERE restaurant_id = para_restaurant_id AND program_status = 'active' AND points_expiration::date < CURRENT_DATE;\n    END IF;\nEND;\n$$;",
    "database_name": "fast_food_industry_and_restaurant_management",
    "tables": [
      "loyalty_program_enrollments",
      "loyalty_programs"
    ],
    "call_sqls": [
      "SELECT check_and_expire_programs(1);",
      "SELECT check_and_expire_programs(2);",
      "SELECT check_and_expire_programs(3);",
      "SELECT check_and_expire_programs(4);",
      "SELECT check_and_expire_programs(5);",
      "SELECT check_and_expire_programs(6);",
      "SELECT check_and_expire_programs(7);",
      "SELECT check_and_expire_programs(8);",
      "SELECT check_and_expire_programs(9);",
      "SELECT check_and_expire_programs(10);",
      "SELECT check_and_expire_programs(11);",
      "SELECT check_and_expire_programs(12);",
      "SELECT check_and_expire_programs(13);",
      "SELECT check_and_expire_programs(14);",
      "SELECT check_and_expire_programs(15);",
      "SELECT check_and_expire_programs(16);",
      "SELECT check_and_expire_programs(17);",
      "SELECT check_and_expire_programs(18);",
      "SELECT check_and_expire_programs(19);",
      "SELECT check_and_expire_programs(20);"
    ],
    "id": 60
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `update_team_efficiency` that accepts one input parameter, `p_team_id`, which is of data type `bigint` and represents a unique identifier for a team. This function is designed to return a boolean value. The function's execution begins by evaluating a conditional statement. This conditional statement checks for the existence of at least one record within the `team_statistics` table where two conditions are simultaneously met: first, the value in the `team_id` column matches the value provided by the `p_team_id` input parameter, and second, the value in the `bat_avg` column is strictly greater than `0.280`. If this existence check returns true, indicating that such a record or records exist, then the function proceeds to execute an `UPDATE` operation. This `UPDATE` operation targets the `advanced_metrics` table. Specifically, it modifies the `team_efficiency` column by multiplying its current value by `1.05` (effectively increasing it by 5%). This update is applied only to those rows in the `advanced_metrics` table where the value in the `team_id` column matches the value provided by the `p_team_id` input parameter. Regardless of whether the conditional statement evaluated to true or false, the function concludes its execution by returning the boolean value `true`.",
    "plsql": "CREATE OR REPLACE FUNCTION update_team_efficiency(p_team_id bigint) RETURNS boolean AS $$\nBEGIN\n    IF EXISTS(SELECT 1 FROM team_statistics WHERE team_id = p_team_id AND bat_avg > 0.280) THEN\n        UPDATE advanced_metrics SET team_efficiency = team_efficiency * 1.05 WHERE team_id = p_team_id;\n    END IF;\n    RETURN true;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "baseball_team_statistics_and_performance_analysis",
    "tables": [
      "teams",
      "players",
      "seasons",
      "season_rosters",
      "game_logs",
      "team_statistics",
      "league_standings",
      "advanced_metrics"
    ],
    "call_sqls": [
      "SELECT update_team_efficiency(1);",
      "SELECT update_team_efficiency(2);",
      "SELECT update_team_efficiency(3);",
      "SELECT update_team_efficiency(4);",
      "SELECT update_team_efficiency(5);",
      "SELECT update_team_efficiency(6);",
      "SELECT update_team_efficiency(7);",
      "SELECT update_team_efficiency(8);",
      "SELECT update_team_efficiency(9);",
      "SELECT update_team_efficiency(10);",
      "SELECT update_team_efficiency(11);",
      "SELECT update_team_efficiency(12);",
      "SELECT update_team_efficiency(13);",
      "SELECT update_team_efficiency(14);",
      "SELECT update_team_efficiency(15);",
      "SELECT update_team_efficiency(16);",
      "SELECT update_team_efficiency(17);",
      "SELECT update_team_efficiency(18);",
      "SELECT update_team_efficiency(19);",
      "SELECT update_team_efficiency(20);"
    ],
    "id": 61
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named delete_rejected_acceptances that accepts a single input parameter p_threshold of type real, which represents a numerical score limit, and returns void, meaning it performs an operation without returning a value. The function's logic begins by evaluating a conditional IF statement to check if the provided p_threshold value is strictly greater than 70.0. If this condition is true, the function executes a DELETE operation on the database table named \"Acceptance\". The deletion targets rows in the \"Acceptance\" table where the value in the \"Result\" column is exactly equal to the string 'Rejected' and, simultaneously, the value in the \"Submission_ID\" column is found within a specific subset. This subset is determined by a subquery that selects the \"Submission_ID\" column from the table named \"submission\" for all rows where the value in the \"Scores\" column is less than the input parameter p_threshold. Consequently, the function removes all acceptance records marked as 'Rejected' that are associated with submissions having a score below the specified p_threshold, but only if the p_threshold itself exceeds 70.0; if p_threshold is 70.0 or less, the function performs no action.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_rejected_acceptances(p_threshold real)\nRETURNS void AS $$\nBEGIN\n    IF p_threshold > 70.0 THEN\n        DELETE FROM \"Acceptance\" WHERE \"Result\" = 'Rejected' AND \"Submission_ID\" IN (SELECT \"Submission_ID\" FROM \"submission\" WHERE \"Scores\" < p_threshold);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "workshop_paper",
    "tables": [
      "Acceptance",
      "submission",
      "workshop"
    ],
    "call_sqls": [
      "SELECT delete_rejected_acceptances(75.0);",
      "SELECT delete_rejected_acceptances(80.0);",
      "SELECT delete_rejected_acceptances(65.0);",
      "SELECT delete_rejected_acceptances(90.0);",
      "SELECT delete_rejected_acceptances(71.0);",
      "SELECT delete_rejected_acceptances(85.5);",
      "SELECT delete_rejected_acceptances(100.0);",
      "SELECT delete_rejected_acceptances(69.9);",
      "SELECT delete_rejected_acceptances(70.1);",
      "SELECT delete_rejected_acceptances(72.3);",
      "SELECT delete_rejected_acceptances(95.7);",
      "SELECT delete_rejected_acceptances(60.0);",
      "SELECT delete_rejected_acceptances(77.7);",
      "SELECT delete_rejected_acceptances(88.8);",
      "SELECT delete_rejected_acceptances(50.0);",
      "SELECT delete_rejected_acceptances(81.2);",
      "SELECT delete_rejected_acceptances(92.5);",
      "SELECT delete_rejected_acceptances(68.0);",
      "SELECT delete_rejected_acceptances(73.9);",
      "SELECT delete_rejected_acceptances(99.9);",
      "SELECT delete_rejected_acceptances(70.01);"
    ],
    "id": 62
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_member_title_prefix that accepts a single input parameter p_member_id of type bigint which represents the unique identifier of a member record, declares a local variable v_title of type text to temporarily store the member's title, performs a SELECT operation on the members table to retrieve the title column value where the member_id column matches the provided p_member_id parameter, stores this title value in the v_title variable, then evaluates a conditional statement that checks if the first two characters of the v_title string equal 'Mr' using the substring function with parameters (v_title from 1 for 2), and if this condition is true, returns a concatenated string consisting of 'Mr-' followed by the original v_title value, otherwise returns a concatenated string consisting of 'Ms-' followed by the original v_title value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_title_prefix(p_member_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_title text;\nBEGIN\n    SELECT title INTO v_title FROM members WHERE member_id = p_member_id;\n    IF substring(v_title from 1 for 2) = 'Mr' THEN\n        RETURN 'Mr-' || v_title;\n    ELSE\n        RETURN 'Ms-' || v_title;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "meeting_attendance_and_management",
    "tables": [
      "meetings",
      "committees",
      "members",
      "attendance",
      "action_items",
      "meeting_responsibilities"
    ],
    "call_sqls": [
      "SELECT get_member_title_prefix(0);",
      "SELECT get_member_title_prefix(1);",
      "SELECT get_member_title_prefix(2);",
      "SELECT get_member_title_prefix(101);",
      "SELECT get_member_title_prefix(102);",
      "SELECT get_member_title_prefix(10);",
      "SELECT get_member_title_prefix(20);",
      "SELECT get_member_title_prefix(30);",
      "SELECT get_member_title_prefix(40);",
      "SELECT get_member_title_prefix(50);",
      "SELECT get_member_title_prefix(60);",
      "SELECT get_member_title_prefix(70);",
      "SELECT get_member_title_prefix(80);",
      "SELECT get_member_title_prefix(90);",
      "SELECT get_member_title_prefix(100);",
      "SELECT get_member_title_prefix(110);",
      "SELECT get_member_title_prefix(120);",
      "SELECT get_member_title_prefix(130);",
      "SELECT get_member_title_prefix(140);",
      "SELECT get_member_title_prefix(150);"
    ],
    "id": 63
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_team_ranking` that returns a set of records, specifically a table with two columns: `team_name` of type `text` and `total_points` of type `bigint`. This function performs a query to calculate the total points for each team. It selects the `team_name` from the `teams` table and calculates the sum of `tot_pts` from the `team_performance` table. The `teams` table is joined with the `team_performance` table using an inner join condition where the `team_id` column from the `teams` table matches the `team_id` column from the `team_performance` table. The results are grouped by the `team_name` column from the `teams` table to aggregate the `tot_pts` for each unique team. The sum of `tot_pts` is explicitly cast to a `bigint` data type and aliased as `total_points`. Finally, the aggregated results are ordered in descending order based on the calculated `total_points`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_team_ranking() RETURNS TABLE(team_name text, total_points bigint) LANGUAGE plpgsql AS $$\nBEGIN\n    RETURN QUERY\n    SELECT\n        t.team_name,\n        SUM(tp.tot_pts)::bigint AS total_points\n    FROM\n        teams t\n    JOIN\n        team_performance tp ON t.team_id = tp.team_id\n    GROUP BY\n        t.team_name\n    ORDER BY\n        total_points DESC;\nEND;\n$$;",
    "database_name": "racing_team_performance_tracking",
    "tables": [
      "drivers",
      "team_performance",
      "teams"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_team_ranking();",
      "SELECT * FROM calculate_team_ranking() WHERE total_points > 5000;",
      "SELECT * FROM calculate_team_ranking() ORDER BY team_name;",
      "SELECT team_name FROM calculate_team_ranking() LIMIT 5;",
      "SELECT * FROM calculate_team_ranking() WHERE team_name LIKE 'NECH%';",
      "SELECT * FROM calculate_team_ranking() WHERE total_points BETWEEN 2000 AND 4000;",
      "SELECT team_name, total_points FROM calculate_team_ranking();",
      "SELECT * FROM calculate_team_ranking() OFFSET 2;",
      "SELECT COUNT(*) FROM calculate_team_ranking();",
      "SELECT AVG(total_points) FROM calculate_team_ranking();",
      "SELECT * FROM calculate_team_ranking() WHERE total_points = (SELECT MAX(total_points) FROM calculate_team_ranking());",
      "SELECT * FROM calculate_team_ranking() WHERE total_points = (SELECT MIN(total_points) FROM calculate_team_ranking());",
      "SELECT * FROM calculate_team_ranking() CROSS JOIN (SELECT SUM(total_points) AS grand_total FROM calculate_team_ranking()) AS gt;",
      "SELECT team_name, total_points, RANK() OVER (ORDER BY total_points DESC) FROM calculate_team_ranking();",
      "SELECT * FROM calculate_team_ranking() JOIN teams ON calculate_team_ranking.team_name = teams.team_name;",
      "SELECT * FROM calculate_team_ranking() WHERE team_name IN ('NECH Racing Gary Gachnang', 'Flat Land3rs Justin Thaler');",
      "SELECT * FROM calculate_team_ranking() WHERE total_points > (SELECT AVG(total_points) FROM calculate_team_ranking());",
      "SELECT * FROM calculate_team_ranking() ORDER BY total_points DESC, team_name ASC;",
      "SELECT team_name, total_points, ROUND(total_points * 100.0 / (SELECT SUM(total_points) FROM calculate_team_ranking()), 2) AS percentage FROM calculate_team_ranking();",
      "SELECT * FROM calculate_team_ranking() WHERE team_name ~ '^[A-F]';"
    ],
    "id": 64
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_jlgs_formed that accepts three input parameters: a numeric parameter named campaign_id_in, a numeric parameter named district_id_in, and a string parameter named formation_type_in, and returns a numeric value by first declaring a local numeric variable named total_jlgs, then performing a SELECT statement that uses the COUNT aggregate function on the jlg_id column from the jlg_formation table (aliased as jf), which is joined with the jlg_campaigns table (aliased as jc) on the condition that the campaign_id column from jf matches the campaign_id column from jc, and then applies a WHERE clause with three conditions: the jf.campaign_id column must equal the campaign_id_in parameter, the jc.district_id column must equal the district_id_in parameter, and the jf.formation_type column must equal the formation_type_in parameter, storing the result of this count operation into the total_jlgs variable, and finally returning the value of the total_jlgs variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_jlgs_formed(campaign_id_in NUMBER, district_id_in NUMBER, formation_type_in VARCHAR2) RETURN NUMBER IS\n  total_jlgs NUMBER;\nBEGIN\n  SELECT COUNT(jf.jlg_id)\n  INTO total_jlgs\n  FROM jlg_formation jf\n  JOIN jlg_campaigns jc ON jf.campaign_id = jc.campaign_id\n  WHERE jf.campaign_id = campaign_id_in\n  AND jc.district_id = district_id_in\n  AND jf.formation_type = formation_type_in;\n  RETURN total_jlgs;\nEND;",
    "database_name": "agricultural_daf_initiati",
    "tables": [
      "districts",
      "jlg_campaigns",
      "jlg_formation",
      "jlg_activation",
      "jlg_participation",
      "ah_units",
      "value_addition_units"
    ],
    "call_sqls": [
      "SELECT get_total_jlgs_formed(0, 0, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(1, 0, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(0, 1, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(1, 1, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(0, 0, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(1, 0, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(0, 1, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(1, 1, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(2, 0, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(2, 1, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(0, 2, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(1, 2, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(3, 3, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(4, 4, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(5, 5, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(10, 10, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(15, 15, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(20, 20, 'government-supported') FROM dual",
      "SELECT get_total_jlgs_formed(25, 25, 'community-driven') FROM dual",
      "SELECT get_total_jlgs_formed(30, 30, 'government-supported') FROM dual"
    ],
    "id": 65
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named sync_theoretical_data that accepts a single input parameter p_temp of type real, representing a temperature value, and returns void. The function first declares a local variable next_id of type bigint. It begins execution by querying the thermodynamic_properties table to calculate the next available property_id: it finds the maximum existing property_id value, uses COALESCE to treat NULL as 0, adds 1 to this value, and stores the result in next_id. It then performs an INSERT into the thermodynamic_properties table, specifying columns property_id, liquid_id, temperature, pressure, and source. The data to insert is selected from the pure_liquids table: for every row in pure_liquids where the state_of_matter column equals the string 'liquid', it includes that row's liquid_id, uses the input parameter p_temp for the temperature column, sets the pressure column to the constant 1.0, and sets the source column to the constant string 'theoretical'. The property_id for each inserted row is generated by taking the base next_id value and adding the result of a window function ROW_NUMBER() OVER () minus 1, which sequentially numbers the selected rows from pure_liquids starting at 1, thereby producing a contiguous range of new property_ids. After the insert, the function executes a conditional check: it performs a SELECT COUNT(*) query on the thermodynamic_properties table to count rows where the temperature column equals the input p_temp and the source column equals 'theoretical'. If this count exceeds 10, it executes a DELETE operation on the thermodynamic_properties table. The DELETE targets rows where the temperature equals p_temp, the source equals 'theoretical', and the property_id is not found in a subquery result. The subquery selects the property_id from thermodynamic_properties for rows matching the same temperature and source criteria, orders the results by the liquid_id column in ascending order, and limits the result set to only the first 10 rows. Consequently, the DELETE removes all but the 10 rows with the smallest liquid_id values for the given temperature and theoretical source, ensuring no more than 10 such records persist.",
    "plsql": "CREATE OR REPLACE FUNCTION sync_theoretical_data(p_temp real) RETURNS void\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    next_id bigint;\nBEGIN\n    -- Get the next available property_id\n    SELECT COALESCE(MAX(property_id), 0) + 1 INTO next_id FROM thermodynamic_properties;\n    \n    INSERT INTO thermodynamic_properties (property_id, liquid_id, temperature, pressure, source)\n    SELECT next_id + ROW_NUMBER() OVER () - 1, liquid_id, p_temp, 1.0, 'theoretical'\n    FROM pure_liquids\n    WHERE state_of_matter = 'liquid';\n\n    IF (SELECT COUNT(*) FROM thermodynamic_properties WHERE temperature = p_temp AND source = 'theoretical') > 10 THEN\n        DELETE FROM thermodynamic_properties\n        WHERE temperature = p_temp\n          AND source = 'theoretical'\n          AND property_id NOT IN (\n              SELECT property_id\n              FROM thermodynamic_properties\n              WHERE temperature = p_temp AND source = 'theoretical'\n              ORDER BY liquid_id\n              LIMIT 10\n          );\n    END IF;\nEND;\n$$;",
    "database_name": "thermodynamic_property_estimation_for_pure_liquids",
    "tables": [
      "pure_liquids",
      "experimental_data",
      "thermodynamic_properties"
    ],
    "call_sqls": [
      "SELECT sync_theoretical_data(25.0);",
      "SELECT sync_theoretical_data(30.0);",
      "SELECT sync_theoretical_data(35.0);",
      "SELECT sync_theoretical_data(40.0);",
      "SELECT sync_theoretical_data(45.0);",
      "SELECT sync_theoretical_data(50.0);",
      "SELECT sync_theoretical_data(55.0);",
      "SELECT sync_theoretical_data(60.0);",
      "SELECT sync_theoretical_data(65.0);",
      "SELECT sync_theoretical_data(70.0);",
      "SELECT sync_theoretical_data(75.0);",
      "SELECT sync_theoretical_data(80.0);",
      "SELECT sync_theoretical_data(85.0);",
      "SELECT sync_theoretical_data(90.0);",
      "SELECT sync_theoretical_data(95.0);",
      "SELECT sync_theoretical_data(100.0);",
      "SELECT sync_theoretical_data(0.0);",
      "SELECT sync_theoretical_data(10.0);",
      "SELECT sync_theoretical_data(20.0);",
      "SELECT sync_theoretical_data(-10.0);"
    ],
    "id": 66
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_agent_commission that accepts a single input parameter p_agent_id of type NUMBER, which is used to identify a specific agent, and returns a value of type NUMBER; the function declares a local variable v_total_commission of type NUMBER; the function's execution block performs a SELECT statement that queries the agent_quotes table, using the SUM aggregate function on the commission_earned column to calculate the total commission, and applies the NVL function to this sum to convert any NULL result into the numeric value 0; this SELECT statement includes a WHERE clause condition that filters the rows from the agent_quotes table where the agent_id column value is equal to the input parameter p_agent_id; the result of this SELECT statement is assigned into the local variable v_total_commission using an INTO clause; the function then concludes by using a RETURN statement to output the value stored in the v_total_commission variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_agent_commission(p_agent_id NUMBER) RETURN NUMBER\nIS\n    v_total_commission NUMBER;\nBEGIN\n    SELECT NVL(SUM(commission_earned), 0)\n      INTO v_total_commission\n      FROM agent_quotes\n     WHERE agent_id = p_agent_id;\n\n    RETURN v_total_commission;\nEND;",
    "database_name": "automotive_iq_management",
    "tables": [
      "agent_quotes",
      "agents",
      "cars",
      "insurance_companies",
      "policyholders",
      "quote_history",
      "quotes"
    ],
    "call_sqls": [
      "SELECT calculate_agent_commission(101) FROM DUAL",
      "SELECT calculate_agent_commission(102) FROM DUAL",
      "SELECT calculate_agent_commission(103) FROM DUAL",
      "SELECT calculate_agent_commission(104) FROM DUAL",
      "SELECT calculate_agent_commission(105) FROM DUAL",
      "SELECT calculate_agent_commission(106) FROM DUAL",
      "SELECT calculate_agent_commission(107) FROM DUAL",
      "SELECT calculate_agent_commission(108) FROM DUAL",
      "SELECT calculate_agent_commission(109) FROM DUAL",
      "SELECT calculate_agent_commission(110) FROM DUAL",
      "SELECT calculate_agent_commission(201) FROM DUAL",
      "SELECT calculate_agent_commission(202) FROM DUAL",
      "SELECT calculate_agent_commission(203) FROM DUAL",
      "SELECT calculate_agent_commission(204) FROM DUAL",
      "SELECT calculate_agent_commission(205) FROM DUAL",
      "SELECT calculate_agent_commission(301) FROM DUAL",
      "SELECT calculate_agent_commission(302) FROM DUAL",
      "SELECT calculate_agent_commission(303) FROM DUAL",
      "SELECT calculate_agent_commission(401) FROM DUAL",
      "SELECT calculate_agent_commission(402) FROM DUAL"
    ],
    "id": 67
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named update_question_text that accepts two input parameters: para_question_id of type bigint, which is used to identify a specific question record, and para_question_text of type text, which contains the new text content for the question; the function then checks for the existence of a record in the session_questions table by performing a SELECT operation on the session_questions table where the question_id column matches the provided para_question_id parameter; if such a record exists (i.e., the EXISTS condition returns true), the function executes an UPDATE operation on the session_questions table, setting the question_text column to the value of the para_question_text parameter specifically for the row where the question_id column equals the para_question_id parameter; if no such record exists (i.e., the EXISTS condition returns false), the function instead executes an INSERT operation into the session_questions table, creating a new row with the question_id column value set to the para_question_id parameter and the question_text column value set to the para_question_text parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION update_question_text(para_question_id bigint, para_question_text text) RETURNS void LANGUAGE plpgsql AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM session_questions WHERE question_id = para_question_id) THEN\n    UPDATE session_questions SET question_text = para_question_text WHERE question_id = para_question_id;\n  ELSE\n    INSERT INTO session_questions (question_id, question_text) VALUES (para_question_id, para_question_text);\n  END IF;\nEND;\n$$;",
    "database_name": "course_feedback_and_evaluation_management",
    "tables": [
      "feedback_sessions",
      "session_questions",
      "responses",
      "results"
    ],
    "call_sqls": [
      "SELECT update_question_text(1, 'How satisfied are you with the course content?');",
      "SELECT update_question_text(2, 'Please rate the instructor''s teaching effectiveness.');",
      "SELECT update_question_text(3, 'What aspects of the course did you find most valuable?');",
      "SELECT update_question_text(4, 'How could the course materials be improved?');",
      "SELECT update_question_text(5, 'Was the workload appropriate for this course?');",
      "SELECT update_question_text(6, 'How clear were the course objectives and expectations?');",
      "SELECT update_question_text(7, 'Please provide feedback on the assignments and assessments.');",
      "SELECT update_question_text(8, 'How effective were the learning activities and discussions?');",
      "SELECT update_question_text(9, 'What suggestions do you have for future iterations of this course?');",
      "SELECT update_question_text(10, 'How well did the course meet your learning goals?');",
      "SELECT update_question_text(11, 'Rate the overall organization and structure of the course.');",
      "SELECT update_question_text(12, 'How accessible and helpful were the course resources?');",
      "SELECT update_question_text(13, 'Please comment on the pace and timing of the course.');",
      "SELECT update_question_text(14, 'How would you rate the quality of feedback you received?');",
      "SELECT update_question_text(15, 'What technical aspects of the course platform worked well or need improvement?');",
      "SELECT update_question_text(16, 'How inclusive and engaging was the learning environment?');",
      "SELECT update_question_text(17, 'Please share any additional comments or concerns.');",
      "SELECT update_question_text(18, 'Would you recommend this course to other students?');",
      "SELECT update_question_text(19, 'How relevant was the course content to your academic or professional goals?');",
      "SELECT update_question_text(20, 'What skills or knowledge did you gain from this course?');"
    ],
    "id": 68
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named activate_user_config that accepts a single input parameter para_user_id of type bigint, which represents the unique identifier of a user, and returns void, meaning it performs an operation without returning a value; the function's logic begins by checking for the existence of a record in the users table where the user_id column matches the provided para_user_id value using a conditional IF EXISTS statement with a subquery that selects the constant 1; if such a user record exists, the function executes an UPDATE operation on the system_configurations table, setting the status column to the string literal 'active' for all rows where the created_by column value equals the username retrieved from a correlated subquery that selects the username column from the users table specifically for the row where the user_id equals the input para_user_id.",
    "plsql": "CREATE OR REPLACE FUNCTION activate_user_config(para_user_id bigint) RETURNS void LANGUAGE plpgsql AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM users WHERE users.user_id = para_user_id) THEN\n    UPDATE system_configurations\n    SET status = 'active'\n    WHERE system_configurations.created_by = (SELECT users.username FROM users WHERE users.user_id = para_user_id);\n  END IF;\nEND;\n$$;",
    "database_name": "thermal_energy_storage_and_transfer_analysis",
    "tables": [
      "materials",
      "system_configurations",
      "users"
    ],
    "call_sqls": [
      "SELECT activate_user_config(1);",
      "SELECT activate_user_config(2);",
      "SELECT activate_user_config(3);",
      "SELECT activate_user_config(5);",
      "SELECT activate_user_config(10);",
      "SELECT activate_user_config(15);",
      "SELECT activate_user_config(20);",
      "SELECT activate_user_config(25);",
      "SELECT activate_user_config(30);",
      "SELECT activate_user_config(35);",
      "SELECT activate_user_config(40);",
      "SELECT activate_user_config(45);",
      "SELECT activate_user_config(50);",
      "SELECT activate_user_config(55);",
      "SELECT activate_user_config(60);",
      "SELECT activate_user_config(65);",
      "SELECT activate_user_config(70);",
      "SELECT activate_user_config(75);",
      "SELECT activate_user_config(80);",
      "SELECT activate_user_config(85);"
    ],
    "id": 69
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named process_match_results that accepts a single input parameter para_match_id of type bigint, which represents the unique identifier of a match, and returns a bigint value. The function begins by declaring a local variable total_points of type bigint. It then executes a SELECT query on the match_results table to calculate the sum of the total_points_scored column for all rows where the match_id column equals the input para_match_id, storing the result into the total_points variable. Following this calculation, the function uses a conditional IF statement: if the calculated total_points is greater than 100, it performs an UPDATE operation on the match_results table, incrementing the streak column by 1 for every row where the match_id equals para_match_id. If the total_points is not greater than 100 (i.e., 100 or less), the function executes a DELETE operation on the match_results table, removing any rows where both the match_id equals para_match_id and the total_points_scored column value is less than 20. Finally, the function returns the value stored in the total_points variable.",
    "plsql": "CREATE OR REPLACE FUNCTION process_match_results(para_match_id bigint) RETURNS bigint LANGUAGE plpgsql AS $$ DECLARE total_points bigint; BEGIN SELECT SUM(total_points_scored) INTO total_points FROM match_results WHERE match_id = para_match_id; IF total_points > 100 THEN UPDATE match_results SET streak = streak + 1 WHERE match_id = para_match_id; ELSE DELETE FROM match_results WHERE match_id = para_match_id AND total_points_scored < 20; END IF; RETURN total_points; END; $$;",
    "database_name": "badminton_match_and_player_statistics",
    "tables": [
      "matches",
      "match_results",
      "match_details",
      "players",
      "opponents",
      "categories"
    ],
    "call_sqls": [
      "SELECT process_match_results(1);",
      "SELECT process_match_results(2);",
      "SELECT process_match_results(3);",
      "SELECT process_match_results(4);",
      "SELECT process_match_results(5);",
      "SELECT process_match_results(6);",
      "SELECT process_match_results(7);",
      "SELECT process_match_results(8);",
      "SELECT process_match_results(9);",
      "SELECT process_match_results(10);",
      "SELECT process_match_results(11);",
      "SELECT process_match_results(12);",
      "SELECT process_match_results(13);",
      "SELECT process_match_results(14);",
      "SELECT process_match_results(15);",
      "SELECT process_match_results(16);",
      "SELECT process_match_results(17);",
      "SELECT process_match_results(18);",
      "SELECT process_match_results(19);",
      "SELECT process_match_results(20);"
    ],
    "id": 70
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_image_count_for_section that accepts a single input parameter p_section_id of the NUMBER data type and returns a value of the NUMBER data type; the function declares a local variable v_count of the NUMBER data type; the function's execution block begins by performing a SELECT statement that queries the DOCUMENT_SECTIONS_IMAGES table, using the COUNT(*) aggregate function to calculate the total number of rows where the value in the SECTION_ID column is exactly equal to the value provided in the input parameter p_section_id, and stores the resulting count into the local variable v_count; the function then concludes by using a RETURN statement to output the value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_image_count_for_section(p_section_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM DOCUMENT_SECTIONS_IMAGES WHERE SECTION_ID = p_section_id;\n  RETURN v_count;\nEND;",
    "database_name": "document_management",
    "tables": [
      "DOCUMENT_SECTIONS",
      "DOCUMENT_SECTIONS_IMAGES",
      "DOCUMENT_FUNCTIONAL_AREAS"
    ],
    "call_sqls": [
      "SELECT get_image_count_for_section(15) FROM DUAL",
      "SELECT get_image_count_for_section(19) FROM DUAL",
      "SELECT get_image_count_for_section(1) FROM DUAL",
      "SELECT get_image_count_for_section(2) FROM DUAL",
      "SELECT get_image_count_for_section(3) FROM DUAL",
      "SELECT get_image_count_for_section(4) FROM DUAL",
      "SELECT get_image_count_for_section(5) FROM DUAL",
      "SELECT get_image_count_for_section(10) FROM DUAL",
      "SELECT get_image_count_for_section(20) FROM DUAL",
      "SELECT get_image_count_for_section(25) FROM DUAL",
      "SELECT get_image_count_for_section(30) FROM DUAL",
      "SELECT get_image_count_for_section(35) FROM DUAL",
      "SELECT get_image_count_for_section(40) FROM DUAL",
      "SELECT get_image_count_for_section(45) FROM DUAL",
      "SELECT get_image_count_for_section(50) FROM DUAL",
      "SELECT get_image_count_for_section(55) FROM DUAL",
      "SELECT get_image_count_for_section(60) FROM DUAL",
      "SELECT get_image_count_for_section(100) FROM DUAL",
      "SELECT get_image_count_for_section(200) FROM DUAL",
      "SELECT get_image_count_for_section(500) FROM DUAL"
    ],
    "id": 71
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_player_award_count that accepts a single input parameter p_player_id of the NUMBER data type, which is used to identify a specific player, and returns a value of the NUMBER data type; this function declares a local variable v_award_count of the NUMBER data type to store the result, then executes a SELECT statement that performs a COUNT(*) operation on the awards table, counting all rows where the player_id column value is equal to the input parameter p_player_id, and stores this count result into the local variable v_award_count, which is then returned as the function's output value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_award_count(p_player_id IN NUMBER) RETURN NUMBER\nIS\n    v_award_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_award_count\n    FROM awards\n    WHERE player_id = p_player_id;\n    \n    RETURN v_award_count;\nEND;",
    "database_name": "basketball_tpa_statistics",
    "tables": [
      "players",
      "teams",
      "games",
      "seasons",
      "leagues",
      "game_performance",
      "team_performance",
      "player_roster",
      "awards",
      "injuries"
    ],
    "call_sqls": [
      "SELECT get_player_award_count(101) FROM dual",
      "SELECT get_player_award_count(205) FROM dual",
      "SELECT get_player_award_count(312) FROM dual",
      "SELECT get_player_award_count(418) FROM dual",
      "SELECT get_player_award_count(527) FROM dual",
      "SELECT get_player_award_count(634) FROM dual",
      "SELECT get_player_award_count(741) FROM dual",
      "SELECT get_player_award_count(856) FROM dual",
      "SELECT get_player_award_count(963) FROM dual",
      "SELECT get_player_award_count(1070) FROM dual",
      "SELECT get_player_award_count(1185) FROM dual",
      "SELECT get_player_award_count(1292) FROM dual",
      "SELECT get_player_award_count(1309) FROM dual",
      "SELECT get_player_award_count(1423) FROM dual",
      "SELECT get_player_award_count(1538) FROM dual",
      "SELECT get_player_award_count(1645) FROM dual",
      "SELECT get_player_award_count(1751) FROM dual",
      "SELECT get_player_award_count(1867) FROM dual",
      "SELECT get_player_award_count(1974) FROM dual",
      "SELECT get_player_award_count(2089) FROM dual"
    ],
    "id": 72
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `update_section_population` that accepts three input parameters: `p_municipality_id` of type `bigint`, `p_population_threshold` of type `bigint`, and `p_new_area` of type `real`. This function is designed to return an integer value. Upon execution, the function declares a local variable named `updated_count` of type `integer`. The core operation of the function is an `UPDATE` statement targeting the `sections` table. This `UPDATE` statement modifies two columns: `population` and `area_km2`. The `population` column is updated by adding the value of the `p_population_threshold` parameter to its current value. Concurrently, the `area_km2` column is set to the value provided by the `p_new_area` parameter. This update is applied only to rows in the `sections` table where two conditions are met: first, the `municipality_id` column matches the value of the `p_municipality_id` parameter, and second, the `population` column has a value strictly less than the `p_population_threshold` parameter. Immediately following the `UPDATE` operation, the `GET DIAGNOSTICS` command is used to retrieve the number of rows affected by the preceding `UPDATE` statement, and this count is assigned to the `updated_count` local variable. Finally, the function returns the integer value stored in the `updated_count` variable, representing the total number of rows that were successfully updated in the `sections` table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_section_population(p_municipality_id bigint, p_population_threshold bigint, p_new_area real)\nRETURNS integer AS $$\nDECLARE\n    updated_count integer;\nBEGIN\n    UPDATE sections SET population = population + p_population_threshold, area_km2 = p_new_area WHERE municipality_id = p_municipality_id AND population < p_population_threshold;\n    GET DIAGNOSTICS updated_count = ROW_COUNT;\n    RETURN updated_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "geographic_and_demographic_data_analysis",
    "tables": [
      "municipalities",
      "sections",
      "demographic_data",
      "spatial_data"
    ],
    "call_sqls": [
      "SELECT update_section_population(1, 10000, 150.5);",
      "SELECT update_section_population(2, 15000, 200.75);",
      "SELECT update_section_population(3, 20000, 300.0);",
      "SELECT update_section_population(4, 5000, 75.25);",
      "SELECT update_section_population(5, 12000, 180.3);",
      "SELECT update_section_population(6, 8000, 95.0);",
      "SELECT update_section_population(7, 25000, 420.5);",
      "SELECT update_section_population(8, 3000, 50.0);",
      "SELECT update_section_population(9, 18000, 275.8);",
      "SELECT update_section_population(10, 22000, 350.2);",
      "SELECT update_section_population(11, 7000, 110.0);",
      "SELECT update_section_population(12, 9000, 125.5);",
      "SELECT update_section_population(13, 14000, 195.75);",
      "SELECT update_section_population(14, 16000, 240.0);",
      "SELECT update_section_population(15, 11000, 165.3);",
      "SELECT update_section_population(16, 13000, 185.6);",
      "SELECT update_section_population(17, 19000, 290.4);",
      "SELECT update_section_population(18, 21000, 320.1);",
      "SELECT update_section_population(19, 24000, 380.9);",
      "SELECT update_section_population(20, 27000, 410.0);"
    ],
    "id": 73
  },
  {
    "ir": "Write a PostgreSQL function named latest_compliance_dates that takes no parameters and returns a table with two columns: product_name of type text and latest_check_date of type text. The function executes a query that selects the product_name from the products table (aliased as p) and the maximum check_date from the compliance_logs table (aliased as cl), which is aliased as latest_check_date in the result. The query uses a LEFT JOIN to connect the products table with the compliance_logs table based on matching product_id values. The results are grouped by product_name to ensure each product appears only once with its latest compliance check date. Finally, the results are ordered alphabetically by product_name. The function returns this result set directly without performing any additional operations or transformations.",
    "plsql": "CREATE OR REPLACE FUNCTION latest_compliance_dates() \nRETURNS TABLE(product_name text, latest_check_date text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT p.product_name, MAX(cl.check_date) as latest_check_date\n    FROM products p\n    LEFT JOIN compliance_logs cl ON p.product_id = cl.product_id\n    GROUP BY p.product_name\n    ORDER BY p.product_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "chemical_composition_standards_and_specifications",
    "tables": [
      "categories",
      "chemical_standards",
      "compliance_logs",
      "products",
      "users"
    ],
    "call_sqls": [
      "SELECT * FROM latest_compliance_dates();",
      "SELECT product_name, latest_check_date FROM latest_compliance_dates();",
      "SELECT * FROM latest_compliance_dates() WHERE latest_check_date IS NOT NULL;",
      "SELECT * FROM latest_compliance_dates() WHERE latest_check_date IS NULL;",
      "SELECT * FROM latest_compliance_dates() ORDER BY latest_check_date DESC;",
      "SELECT * FROM latest_compliance_dates() WHERE product_name LIKE 'Paint%';",
      "SELECT * FROM latest_compliance_dates() WHERE product_name LIKE 'Adhesive%';",
      "SELECT * FROM latest_compliance_dates() WHERE latest_check_date < '2023-06-01';",
      "SELECT * FROM latest_compliance_dates() WHERE latest_check_date >= '2023-05-01';",
      "SELECT * FROM latest_compliance_dates() WHERE latest_check_date BETWEEN '2023-05-01' AND '2023-05-31';",
      "SELECT product_name FROM latest_compliance_dates();",
      "SELECT latest_check_date FROM latest_compliance_dates();",
      "SELECT COUNT(*) FROM latest_compliance_dates();",
      "SELECT COUNT(*) FROM latest_compliance_dates() WHERE latest_check_date IS NOT NULL;",
      "SELECT product_name, latest_check_date FROM latest_compliance_dates() ORDER BY product_name ASC;",
      "SELECT product_name, latest_check_date FROM latest_compliance_dates() ORDER BY product_name DESC;",
      "SELECT * FROM latest_compliance_dates() LIMIT 5;",
      "SELECT * FROM latest_compliance_dates() OFFSET 2 LIMIT 3;",
      "SELECT product_name FROM latest_compliance_dates() WHERE latest_check_date = (SELECT MAX(latest_check_date) FROM latest_compliance_dates());",
      "SELECT product_name FROM latest_compliance_dates() WHERE latest_check_date = (SELECT MIN(latest_check_date) FROM latest_compliance_dates() WHERE latest_check_date IS NOT NULL);"
    ],
    "id": 74
  },
  {
    "ir": "Write an Oracle PL/SQL function named process_cot_calculation that accepts a single input parameter p_input of type NUMBER and returns a value of type NUMBER, which declares a local variable v_output of type NUMBER, then checks if the input parameter p_input is greater than zero, and if true, calculates the output value v_output by first computing the trigonometric tangent of p_input using the TAN function, then computing the reciprocal of that tangent value, and finally multiplying that result by two, but if the input parameter p_input is not greater than zero, calculates the output value v_output by first computing the absolute value of p_input using the ABS function, then computing the trigonometric tangent of that absolute value using the TAN function, and finally computing the reciprocal of that tangent value, and then returns the calculated v_output value.",
    "plsql": "CREATE OR REPLACE FUNCTION process_cot_calculation(p_input NUMBER) RETURN NUMBER\nIS\n    v_output NUMBER;\nBEGIN\n    IF p_input > 0 THEN\n        v_output := (1 / TAN(p_input)) * 2;\n    ELSE\n        v_output := 1 / TAN(ABS(p_input));\n    END IF;\n    RETURN v_output;\nEND;",
    "database_name": "electronic_ciac_managemen",
    "tables": [],
    "call_sqls": [
      "SELECT process_cot_calculation(0.5) FROM DUAL",
      "SELECT process_cot_calculation(1) FROM DUAL",
      "SELECT process_cot_calculation(1.5708) FROM DUAL",
      "SELECT process_cot_calculation(0.7854) FROM DUAL",
      "SELECT process_cot_calculation(-0.5) FROM DUAL",
      "SELECT process_cot_calculation(-1) FROM DUAL",
      "SELECT process_cot_calculation(10) FROM DUAL",
      "SELECT process_cot_calculation(100) FROM DUAL",
      "SELECT process_cot_calculation(0.001) FROM DUAL",
      "SELECT process_cot_calculation(-0.001) FROM DUAL",
      "SELECT process_cot_calculation(3.1416) FROM DUAL",
      "SELECT process_cot_calculation(-3.1416) FROM DUAL",
      "SELECT process_cot_calculation(0.25) FROM DUAL",
      "SELECT process_cot_calculation(-0.25) FROM DUAL",
      "SELECT process_cot_calculation(2) FROM DUAL",
      "SELECT process_cot_calculation(-2) FROM DUAL",
      "SELECT process_cot_calculation(15) FROM DUAL",
      "SELECT process_cot_calculation(-15) FROM DUAL",
      "SELECT process_cot_calculation(0.0174533) FROM DUAL",
      "SELECT process_cot_calculation(-0.0174533) FROM DUAL"
    ],
    "id": 75
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_recent_experiment_results` that accepts a single input parameter named `experiment_id` of type `bigint`. This function is designed to return a set of records, specifically a table with three columns: `result_id` of type `bigint`, `mean_norm_counts` of type `real`, and `log2_fold_change` of type `real`. The function's execution flow begins by evaluating a conditional statement: it checks if the provided `experiment_id` parameter is not `NULL`. If `experiment_id` is indeed not `NULL`, the function proceeds to execute a `SELECT` query. This query retrieves data from a table named `results`, aliased as `r`. Specifically, it selects the `result_id` column from the `results` table, the `mean_norm_counts` column from the `results` table, and the `log2_fold_change` column from the `results` table. The selection is filtered by a `WHERE` clause, which specifies that only rows where the `experiment_id` column in the `results` table (`r.experiment_id`) is equal to the `experiment_id` parameter passed to the function (`get_recent_experiment_results.experiment_id`) are included. The results of this filtered selection are then ordered in descending order based on the `result_id` column (`r.result_id DESC`). Finally, the query limits the output to the top 5 records after sorting. The `RETURN QUERY` statement then returns these selected and ordered records as the result of the function. If the initial conditional check determines that `experiment_id` is `NULL`, the function does not execute the `SELECT` query and implicitly returns an empty set of records.",
    "plsql": "CREATE OR REPLACE FUNCTION get_recent_experiment_results(experiment_id bigint) RETURNS TABLE (\n    result_id bigint,\n    mean_norm_counts real,\n    log2_fold_change real\n) AS $$\nBEGIN\n    IF experiment_id IS NOT NULL THEN\n        RETURN QUERY \n        SELECT r.result_id, r.mean_norm_counts, r.log2_fold_change\n        FROM results r\n        WHERE r.experiment_id = get_recent_experiment_results.experiment_id\n        ORDER BY r.result_id DESC\n        LIMIT 5;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "biological_data_analysis_and_experimental_results",
    "tables": [
      "experiments",
      "results",
      "statistics",
      "users"
    ],
    "call_sqls": [
      "SELECT * FROM get_recent_experiment_results(0);",
      "SELECT * FROM get_recent_experiment_results(1);",
      "SELECT * FROM get_recent_experiment_results(2);",
      "SELECT * FROM get_recent_experiment_results(3);",
      "SELECT * FROM get_recent_experiment_results(4);",
      "SELECT * FROM get_recent_experiment_results(5);",
      "SELECT * FROM get_recent_experiment_results(6);",
      "SELECT * FROM get_recent_experiment_results(7);",
      "SELECT * FROM get_recent_experiment_results(8);",
      "SELECT * FROM get_recent_experiment_results(9);",
      "SELECT * FROM get_recent_experiment_results(10);",
      "SELECT * FROM get_recent_experiment_results(11);",
      "SELECT * FROM get_recent_experiment_results(12);",
      "SELECT * FROM get_recent_experiment_results(13);",
      "SELECT * FROM get_recent_experiment_results(14);",
      "SELECT * FROM get_recent_experiment_results(15);",
      "SELECT * FROM get_recent_experiment_results(16);",
      "SELECT * FROM get_recent_experiment_results(17);",
      "SELECT * FROM get_recent_experiment_results(18);",
      "SELECT * FROM get_recent_experiment_results(19);",
      "SELECT * FROM get_recent_experiment_results(20);"
    ],
    "id": 76
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_evaluation_weightage` that accepts a single input parameter, `subject_id_input`, which is of type `bigint`. This function is designed to calculate and return the total weightage associated with a specific subject. Upon execution, the function declares a local variable named `total_weightage` of type `bigint` to store the computed sum. It then performs a `SELECT` operation to retrieve data from the `evaluations` table. Specifically, it calculates the `SUM` of the values in the `weightage` column. This summation is conditional, applying only to those rows in the `evaluations` table where the value in the `subject_id` column exactly matches the value provided by the `subject_id_input` parameter. The result of this `SUM` aggregation is then assigned to the `total_weightage` local variable. Finally, the function returns the value stored in the `total_weightage` variable, which represents the aggregated weightage for the specified subject.",
    "plsql": "CREATE OR REPLACE FUNCTION get_evaluation_weightage(subject_id_input bigint) RETURNS bigint LANGUAGE plpgsql AS $$\nDECLARE\n  total_weightage bigint;\nBEGIN\n  SELECT SUM(weightage) INTO total_weightage\n  FROM evaluations\n  WHERE subject_id = subject_id_input;\n  RETURN total_weightage;\nEND; $$;",
    "database_name": "academic_curriculum_management_and_assessment",
    "tables": [
      "evaluations",
      "subjects"
    ],
    "call_sqls": [
      "SELECT get_evaluation_weightage(0);",
      "SELECT get_evaluation_weightage(1);",
      "SELECT get_evaluation_weightage(2);",
      "SELECT get_evaluation_weightage(3);",
      "SELECT get_evaluation_weightage(4);",
      "SELECT get_evaluation_weightage(5);",
      "SELECT get_evaluation_weightage(10);",
      "SELECT get_evaluation_weightage(15);",
      "SELECT get_evaluation_weightage(20);",
      "SELECT get_evaluation_weightage(25);",
      "SELECT get_evaluation_weightage(30);",
      "SELECT get_evaluation_weightage(35);",
      "SELECT get_evaluation_weightage(40);",
      "SELECT get_evaluation_weightage(45);",
      "SELECT get_evaluation_weightage(50);",
      "SELECT get_evaluation_weightage(55);",
      "SELECT get_evaluation_weightage(60);",
      "SELECT get_evaluation_weightage(65);",
      "SELECT get_evaluation_weightage(70);",
      "SELECT get_evaluation_weightage(75);",
      "SELECT get_evaluation_weightage(80);"
    ],
    "id": 77
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_performance_metric that accepts a single input parameter car_id_in of the NUMBER data type and returns a VARCHAR2 string, which executes a SELECT operation to query the track_performance column from the performance_metrics table where the car_id column value equals the provided car_id_in parameter, storing the result into a local variable v_performance, then checks if the retrieved v_performance value is NULL and returns the string 'No performance data available' if this condition is true, otherwise returns the value stored in the v_performance variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_performance_metric(car_id_in NUMBER) RETURN VARCHAR2 IS\n  v_performance VARCHAR2(255);\nBEGIN\n  SELECT track_performance INTO v_performance\n  FROM performance_metrics\n  WHERE car_id = car_id_in;\n  \n  IF v_performance IS NULL THEN\n    RETURN 'No performance data available';\n  ELSE\n    RETURN v_performance;\n  END IF;\nEND;",
    "database_name": "automobile_pa_specificati",
    "tables": [
      "cars",
      "engine_types",
      "performance_metrics",
      "transmission_types"
    ],
    "call_sqls": [
      "SELECT get_performance_metric(0) FROM DUAL",
      "SELECT get_performance_metric(1) FROM DUAL",
      "SELECT get_performance_metric(2) FROM DUAL",
      "SELECT get_performance_metric(3) FROM DUAL",
      "SELECT get_performance_metric(4) FROM DUAL",
      "SELECT get_performance_metric(5) FROM DUAL",
      "SELECT get_performance_metric(6) FROM DUAL",
      "SELECT get_performance_metric(7) FROM DUAL",
      "SELECT get_performance_metric(8) FROM DUAL",
      "SELECT get_performance_metric(9) FROM DUAL",
      "SELECT get_performance_metric(10) FROM DUAL",
      "SELECT get_performance_metric(11) FROM DUAL",
      "SELECT get_performance_metric(12) FROM DUAL",
      "SELECT get_performance_metric(13) FROM DUAL",
      "SELECT get_performance_metric(14) FROM DUAL",
      "SELECT get_performance_metric(15) FROM DUAL",
      "SELECT get_performance_metric(16) FROM DUAL",
      "SELECT get_performance_metric(17) FROM DUAL",
      "SELECT get_performance_metric(18) FROM DUAL",
      "SELECT get_performance_metric(19) FROM DUAL"
    ],
    "id": 78
  },
  {
    "ir": "Write a PLpgSQL trigger function that modifies the phone_number column in a table by replacing all occurrences of the hyphen character '-' with a period '.' in the NEW record being inserted or updated. This function is intended to be used as a trigger to standardize the format of phone numbers by ensuring that any hyphens are replaced with periods before the data is committed to the table. The function operates on the NEW record, which represents the row data that is being inserted or updated, and directly alters the phone_number field within this record. The function does not perform any conditional checks or interact with other tables or columns, nor does it call any other functions or perform any complex operations. It simply applies the replace function to transform the phone_number value and returns the modified NEW record to be used in the database operation.",
    "plsql": "CREATE OR REPLACE FUNCTION standardize_phone() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.phone_number = replace(NEW.phone_number, '-', '.');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "school_sports_management_and_scheduling",
    "tables": [
      "teams",
      "schools",
      "sports",
      "coaches"
    ],
    "call_sqls": [
      "CREATE TRIGGER standardize_coach_phone BEFORE INSERT OR UPDATE ON coaches FOR EACH ROW EXECUTE FUNCTION standardize_phone();",
      "CREATE TRIGGER standardize_school_phone BEFORE INSERT OR UPDATE ON schools FOR EACH ROW EXECUTE FUNCTION standardize_phone();",
      "UPDATE coaches SET phone_number = '888-999-0000' WHERE coach_id = 0;",
      "INSERT INTO schools (school_id, school_name, location, phone_number, email, website, athletic_director_id) VALUES (100, 'Test High', 'Test City', '111-222-3333', 'test@example.com', 'test.com', 1);",
      "UPDATE schools SET phone_number = '444-555-6666' WHERE school_id = 1;",
      "UPDATE coaches SET phone_number = '987-654-3210' WHERE email = 'jane.smith@example.com';",
      "INSERT INTO schools (school_id, school_name, location, phone_number, email, website, athletic_director_id) VALUES (101, 'North High', 'North City', '999-888-7777', 'north@example.com', 'north.com', 0);",
      "UPDATE schools SET phone_number = '333-444-5555', location = 'New City' WHERE school_name = 'Lincoln High School';",
      "UPDATE coaches SET first_name = 'Robert', phone_number = '777-888-9999' WHERE coach_id = 1;",
      "INSERT INTO schools (school_id, school_name, location, phone_number, email, website, athletic_director_id) VALUES (102, 'West High', 'West City', '555-666-7777', 'west@example.com', 'west.com', NULL);",
      "UPDATE schools SET website = 'new.example.com', phone_number = '222-333-4444' WHERE school_id = 0;",
      "UPDATE coaches SET last_name = 'Green', phone_number = '321-654-9870' WHERE first_name = 'John' AND last_name = 'Doe';",
      "INSERT INTO schools (school_id, school_name, location, phone_number, email, website, athletic_director_id) VALUES (103, 'East High', 'East City', '777-123-4567', 'east@example.com', 'east.com', 1);",
      "UPDATE schools SET athletic_director_id = 0, phone_number = '456-789-0123' WHERE location LIKE '%Springfield%';",
      "UPDATE coaches SET email = 'new.email@example.com', phone_number = '111-000-9999' WHERE user_id = 1;",
      "INSERT INTO schools (school_id, school_name, location, phone_number, email, website, athletic_director_id) VALUES (104, 'Central High', 'Central City', '123-987-6543', 'central@example.com', 'central.com', NULL);"
    ],
    "id": 79
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_discounted_total that accepts a single input parameter p_order_id of type BIGINT, which is used to identify a specific order record, and returns a value of type REAL; within the function, two local REAL variables v_total and v_discount are declared to hold intermediate values; the function executes a SELECT statement that retrieves the total_amount column value and the discount column value from the orders table, aliased as o, specifically from the row where the order_id column matches the provided p_order_id parameter, and stores these retrieved values into the v_total and v_discount variables respectively; the function then returns the result of the COALESCE function applied to the expression v_total minus v_discount, which computes the discounted total by subtracting the discount from the total amount, with COALESCE ensuring that if the subtraction results in a NULL value, a zero is returned instead.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_discounted_total(p_order_id BIGINT) RETURNS REAL AS $$\nDECLARE\n    v_total REAL;\n    v_discount REAL;\nBEGIN\n    SELECT o.total_amount, o.discount INTO v_total, v_discount FROM orders o WHERE o.order_id = p_order_id;\n    RETURN COALESCE(v_total - v_discount, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_commerce_sales_and_customer_analytics",
    "tables": [
      "orders",
      "payment",
      "shipping"
    ],
    "call_sqls": [
      "SELECT calculate_discounted_total(0);",
      "SELECT calculate_discounted_total(1);",
      "SELECT calculate_discounted_total(2);",
      "SELECT calculate_discounted_total(3);",
      "SELECT calculate_discounted_total(4);",
      "SELECT calculate_discounted_total(5);",
      "SELECT calculate_discounted_total(6);",
      "SELECT calculate_discounted_total(7);",
      "SELECT calculate_discounted_total(8);",
      "SELECT calculate_discounted_total(9);",
      "SELECT calculate_discounted_total(10);",
      "SELECT calculate_discounted_total(100);",
      "SELECT calculate_discounted_total(101);",
      "SELECT calculate_discounted_total(500);",
      "SELECT calculate_discounted_total(501);",
      "SELECT calculate_discounted_total(999);",
      "SELECT calculate_discounted_total(1000);",
      "SELECT calculate_discounted_total(1234);",
      "SELECT calculate_discounted_total(5678);",
      "SELECT calculate_discounted_total(9999);",
      "SELECT calculate_discounted_total(10000);"
    ],
    "id": 80
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named consolidate_user_alerts that accepts a single input parameter p_user_id of type bigint representing the identifier of a user and returns void, performing a series of operations based on aggregated counts of alerts for that user: it first executes a SELECT query joining the alerts table (aliased as a) and the users table (aliased as u) on the user_id column, filtering for rows where a.user_id equals the input p_user_id and the alert_status column equals the string 'open', grouping the results by the user_name column from the users table, and within this query it calculates the total count of rows into variable v_open_count, the count of rows where the alert_severity column equals the string 'critical' into variable v_critical_count using a CASE expression, and retrieves the user_name into variable v_user_name; then, using an IF-ELSIF-ELSE conditional block, if the v_critical_count is greater than 5, it performs an INSERT into the historical_data table, specifying values for columns history_id (by selecting the maximum existing history_id from the historical_data table, using COALESCE to default to 0 if none exist, and adding 1), iteration_id (as 0), allocation_id (as the string '0'), execution_time (as the v_open_count cast to real), date_recorded (as the current date cast to text using CURRENT_DATE), data_type (as the string 'user_alert_consolidation'), and data_description (as a concatenated string starting with 'User ', then the v_user_name, then ' has ', then the v_critical_count, then ' critical alerts'); otherwise, if the v_open_count is greater than 10, it executes an UPDATE on the alerts table, setting the alert_severity column to the string 'critical' for all rows where the user_id equals p_user_id, the alert_status equals 'open', and the current alert_severity equals 'warning'; otherwise, if the v_open_count equals 0, it executes a DELETE from the alerts table for all rows where the user_id equals p_user_id and the alert_status equals the string 'pending'; otherwise, in the final ELSE case, it executes an UPDATE on the alerts table, setting the alert_date column to the current date cast to text using CURRENT_DATE for all rows where the user_id equals p_user_id and the alert_status equals 'open'.",
    "plsql": "CREATE OR REPLACE FUNCTION consolidate_user_alerts(p_user_id bigint) RETURNS void AS $$\nDECLARE\n    v_open_count integer;\n    v_critical_count integer;\n    v_user_name text;\nBEGIN\n    SELECT COUNT(*), COUNT(CASE WHEN alert_severity = 'critical' THEN 1 END), user_name INTO v_open_count, v_critical_count, v_user_name FROM alerts a JOIN users u ON a.user_id = u.user_id WHERE a.user_id = p_user_id AND alert_status = 'open' GROUP BY user_name;\n    IF v_critical_count > 5 THEN\n        INSERT INTO historical_data (history_id, iteration_id, allocation_id, execution_time, date_recorded, data_type, data_description) VALUES ((SELECT COALESCE(MAX(history_id), 0) + 1 FROM historical_data), 0, '0', v_open_count::real, CURRENT_DATE::text, 'user_alert_consolidation', 'User ' || v_user_name || ' has ' || v_critical_count || ' critical alerts');\n    ELSIF v_open_count > 10 THEN\n        UPDATE alerts SET alert_severity = 'critical' WHERE user_id = p_user_id AND alert_status = 'open' AND alert_severity = 'warning';\n    ELSIF v_open_count = 0 THEN\n        DELETE FROM alerts WHERE user_id = p_user_id AND alert_status = 'pending';\n    ELSE\n        UPDATE alerts SET alert_date = CURRENT_DATE::text WHERE user_id = p_user_id AND alert_status = 'open';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "performance_monitoring_and_resource_management_in_computing",
    "tables": [
      "alerts",
      "historical_data",
      "performance_metrics",
      "resource_allocations",
      "users"
    ],
    "call_sqls": [
      "SELECT consolidate_user_alerts(0);",
      "SELECT consolidate_user_alerts(1);",
      "SELECT consolidate_user_alerts(2);",
      "SELECT consolidate_user_alerts(3);",
      "SELECT consolidate_user_alerts(4);",
      "SELECT consolidate_user_alerts(5);",
      "SELECT consolidate_user_alerts(6);",
      "SELECT consolidate_user_alerts(7);",
      "SELECT consolidate_user_alerts(8);",
      "SELECT consolidate_user_alerts(9);",
      "SELECT consolidate_user_alerts(10);",
      "SELECT consolidate_user_alerts(11);",
      "SELECT consolidate_user_alerts(12);",
      "SELECT consolidate_user_alerts(13);",
      "SELECT consolidate_user_alerts(14);",
      "SELECT consolidate_user_alerts(15);",
      "SELECT consolidate_user_alerts(16);",
      "SELECT consolidate_user_alerts(17);",
      "SELECT consolidate_user_alerts(18);",
      "SELECT consolidate_user_alerts(19);"
    ],
    "id": 81
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `transform_customer_measurements` that accepts two input parameters: `p_customer_id`, which is of type `bigint` and represents the unique identifier for a customer, and `p_scale_factor`, which is of type `double precision` and represents a scaling multiplier to be applied to measurement values. The function is designed to return a `text` value, which will be a JSON string representing transformed customer measurement data.\n\nUpon execution, the function declares several local variables: `v_original_data` of type `text` to store the raw measurement data retrieved from the database, `v_bust_val`, `v_waist_val`, and `v_hip_val` all of type `double precision` to hold the numerical values of bust, waist, and hip measurements respectively during processing, and `transformed_data` of type `text` to store the final JSON string of transformed measurements.\n\nThe function begins by attempting to retrieve the `measurement_data` column from the `customers` table. This retrieval is performed using a `SELECT` statement, and the result is stored into the `v_original_data` variable. The selection is conditioned by matching the `customer_id` column in the `customers` table with the input parameter `p_customer_id`.\n\nFollowing the data retrieval, a conditional block (`IF v_original_data IS NOT NULL THEN ... ELSE ... END IF;`) evaluates whether `v_original_data` contains any data.\n\nIf `v_original_data` is not `NULL`, indicating that measurement data was found for the specified customer, the function proceeds with the following operations:\n1. It extracts the 'bust' value from the `v_original_data` text, treating `v_original_data` as a JSON object. This is achieved by casting `v_original_data` to `json` (`v_original_data::json`), then using the `->>` operator to extract the value associated with the key 'bust' as text, and finally casting this extracted text to `double precision`. This numerical 'bust' value is then multiplied by the `p_scale_factor` and the result is assigned to `v_bust_val`.\n2. Similarly, it extracts the 'waist' value from `v_original_data` as a `double precision` number, multiplies it by `p_scale_factor`, and assigns the result to `v_waist_val`.\n3. In the same manner, it extracts the 'hip' value from `v_original_data` as a `double precision` number, multiplies it by `p_scale_factor`, and assigns the result to `v_hip_val`.\n\nAfter the initial scaling, the function applies a further transformation to these scaled values:\n1. For `v_bust_val`, it adds `1` to its current value, then uses the `GREATEST` function to ensure that the result is at least `1.0`. This adjusted value is then passed to the `acosh` (inverse hyperbolic cosine) function, and the output of `acosh` overwrites `v_bust_val`. This step ensures that the argument to `acosh` is always `1.0` or greater, as `acosh(x)` is only defined for `x >= 1`.\n2. The same `acosh` transformation (adding `1`, ensuring the value is at least `1.0` using `GREATEST`, and then applying `acosh`) is applied to `v_waist_val`, with the result overwriting `v_waist_val`.\n3. The identical `acosh` transformation is applied to `v_hip_val`, with the result overwriting `v_hip_val`.\n\nFinally, within this `IF` block, the function constructs a new JSON object using `json_build_object`. This object contains three key-value pairs: 'bust' with the transformed `v_bust_val`, 'waist' with the transformed `v_waist_val`, and 'hip' with the transformed `v_hip_val`. This newly built JSON object is then cast to `text` and assigned to the `transformed_data` variable.\n\nIf `v_original_data` is `NULL` (i.e., no measurement data was found for the given `p_customer_id`), the `ELSE` block is executed, and the `transformed_data` variable is assigned the string `'{}'`, representing an empty JSON object.\n\nRegardless of whether data was found or not, the function concludes by returning the final value stored in the `transformed_data` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION transform_customer_measurements(p_customer_id bigint, p_scale_factor double precision)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_original_data text;\n    v_bust_val double precision;\n    v_waist_val double precision;\n    v_hip_val double precision;\n    transformed_data text; -- Declare as a local variable\nBEGIN\n    SELECT measurement_data INTO v_original_data\n    FROM customers\n    WHERE customer_id = p_customer_id;\n\n    IF v_original_data IS NOT NULL THEN\n        v_bust_val := (v_original_data::json->>'bust')::double precision * p_scale_factor;\n        v_waist_val := (v_original_data::json->>'waist')::double precision * p_scale_factor;\n        v_hip_val := (v_original_data::json->>'hip')::double precision * p_scale_factor;\n\n        -- Ensure arguments to acosh are >= 1.0 for real results\n        -- acosh(x) is defined for x >= 1\n        v_bust_val := acosh(GREATEST(v_bust_val + 1, 1.0));\n        v_waist_val := acosh(GREATEST(v_waist_val + 1, 1.0));\n        v_hip_val := acosh(GREATEST(v_hip_val + 1, 1.0));\n\n        transformed_data := json_build_object(\n            'bust', v_bust_val,\n            'waist', v_waist_val,\n            'hip', v_hip_val\n        )::text;\n    ELSE\n        transformed_data := '{}';\n    END IF;\n\n    RETURN transformed_data;\nEND;\n$$;",
    "database_name": "apparel_size_conversion_and_cup_size_guide",
    "tables": [
      "customers",
      "orders"
    ],
    "call_sqls": [
      "SELECT transform_customer_measurements(0, 1.0);",
      "SELECT transform_customer_measurements(1, 1.0);",
      "SELECT transform_customer_measurements(0, 1.05);",
      "SELECT transform_customer_measurements(1, 1.05);",
      "SELECT transform_customer_measurements(0, 0.95);",
      "SELECT transform_customer_measurements(1, 0.95);",
      "SELECT transform_customer_measurements(10, 1.0);",
      "SELECT transform_customer_measurements(15, 1.1);",
      "SELECT transform_customer_measurements(20, 1.2);",
      "SELECT transform_customer_measurements(25, 0.9);",
      "SELECT transform_customer_measurements(30, 1.15);",
      "SELECT transform_customer_measurements(35, 0.85);",
      "SELECT transform_customer_measurements(40, 1.0);",
      "SELECT transform_customer_measurements(45, 1.25);",
      "SELECT transform_customer_measurements(50, 0.8);",
      "SELECT transform_customer_measurements(55, 1.3);",
      "SELECT transform_customer_measurements(60, 0.75);",
      "SELECT transform_customer_measurements(65, 1.5);",
      "SELECT transform_customer_measurements(70, 2.0);",
      "SELECT transform_customer_measurements(75, 0.5);"
    ],
    "id": 82
  },
  {
    "ir": "Write a PLpgSQL function named delete_constructor_results that is designed to be used as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to execute before a row is deleted from the constructors table. The function performs a DELETE operation on the constructorResults table, specifically targeting rows where the constructorId column matches the OLD.constructorId value, which represents the constructorId of the row being deleted from the constructors table. The function then returns the OLD record, which is the row that is about to be deleted from the constructors table. Additionally, a trigger named before_constructor_delete is created to invoke this function. This trigger is set to fire before a DELETE operation on the constructors table, ensuring that any associated records in the constructorResults table are removed prior to the deletion of a constructor record. The trigger is defined to execute for each row that is deleted, thereby ensuring that the function is called individually for each row affected by a DELETE operation on the constructors table.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_constructor_results() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"constructorResults\" WHERE \"constructorId\" = OLD.\"constructorId\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER before_constructor_delete\nBEFORE DELETE ON constructors\nFOR EACH ROW EXECUTE FUNCTION delete_constructor_results();",
    "database_name": "formula_1",
    "tables": [
      "constructorResults",
      "constructors"
    ],
    "call_sqls": [
      "DELETE FROM constructors WHERE \"constructorId\" = 1;",
      "DELETE FROM constructors WHERE \"constructorId\" = 2;",
      "DELETE FROM constructors WHERE \"constructorId\" = 3;",
      "DELETE FROM constructors WHERE \"constructorId\" = 4;",
      "DELETE FROM constructors WHERE \"constructorId\" = 5;",
      "DELETE FROM constructors WHERE \"constructorId\" = 6;",
      "DELETE FROM constructors WHERE \"constructorId\" = 7;",
      "DELETE FROM constructors WHERE \"constructorId\" = 8;",
      "DELETE FROM constructors WHERE \"constructorId\" = 9;",
      "DELETE FROM constructors WHERE \"constructorId\" = 10;",
      "DELETE FROM constructors WHERE \"constructorId\" = 11;",
      "DELETE FROM constructors WHERE \"constructorId\" = 12;",
      "DELETE FROM constructors WHERE \"constructorId\" = 13;",
      "DELETE FROM constructors WHERE \"constructorId\" = 14;",
      "DELETE FROM constructors WHERE \"constructorId\" = 15;",
      "DELETE FROM constructors WHERE \"constructorId\" = 16;",
      "DELETE FROM constructors WHERE \"constructorId\" = 17;",
      "DELETE FROM constructors WHERE \"constructorId\" = 18;",
      "DELETE FROM constructors WHERE \"constructorId\" = 19;",
      "DELETE FROM constructors WHERE \"constructorId\" = 20;",
      "DELETE FROM constructors WHERE \"constructorRef\" = 'mclaren';"
    ],
    "id": 83
  },
  {
    "ir": "Write a PL/pgSQL function named `maintain_publication_links` that accepts three input parameters: `p_pub_id` of type `bigint`, `p_document_type` of type `text`, and `p_page_count` of type `bigint`. This function is designed to return a boolean value. The function's core logic is a conditional structure that evaluates the provided parameters to perform specific data manipulation operations on the `project_publications` and `publications` tables.\n\nThe first condition checks if the value of the `p_page_count` parameter is strictly greater than `20`. If this condition is true, the function executes a `DELETE` statement. This `DELETE` statement targets the `project_publications` table and removes all rows where the `pub_id` column matches the value of the `p_pub_id` parameter AND the `publication_role` column is equal to the literal string `'secondary'`.\n\nIf the first condition ( `p_page_count > 20` ) is false, the function proceeds to evaluate the next condition. This `ELSIF` condition checks if the uppercase version of the `p_document_type` parameter is equal to the literal string `'ARTICLE'`. The `UPPER()` function is used to convert the `p_document_type` value to uppercase for a case-insensitive comparison. If this condition is true, the function executes an `UPDATE` statement. This `UPDATE` statement targets the `publications` table and modifies rows where the `pub_id` column matches the value of the `p_pub_id` parameter. For these matching rows, the `document_type` column is updated to the value of the `p_document_type` parameter after leading and trailing whitespace characters have been removed using the `TRIM()` function, and the `page_count` column is updated to the value of the `p_page_count` parameter incremented by `5`.\n\nIf both the first and second conditions are false, the function evaluates the third `ELSIF` condition. This condition checks if the value of the `p_document_type` parameter is exactly equal to the literal string `'conference'`. If this condition is true, the function executes an `INSERT` statement. This `INSERT` statement adds a new row into the `project_publications` table. The `proj_pub_id` column is set to the value of `p_pub_id` multiplied by `50`, the `project_id` column is set to the literal integer `1`, the `pub_id` column is set to the value of `p_pub_id`, and the `publication_role` column is set to the literal string `'primary'`.\n\nIf all the preceding conditions are false, the function executes the `ELSE` block. In this block, an `UPDATE` statement is performed on the `publications` table. This `UPDATE` statement modifies rows where the `pub_id` column matches the value of the `p_pub_id` parameter. For these matching rows, the `publication_status` column is updated to the literal string `'archived'`.\n\nRegardless of which conditional branch is executed, the function concludes by returning the boolean value `true`.",
    "plsql": "CREATE OR REPLACE FUNCTION maintain_publication_links(p_pub_id bigint, p_document_type text, p_page_count bigint) RETURNS boolean LANGUAGE plpgsql AS $$ BEGIN IF p_page_count > 20 THEN DELETE FROM project_publications WHERE pub_id = p_pub_id AND publication_role = 'secondary'; ELSIF UPPER(p_document_type) = 'ARTICLE' THEN UPDATE publications SET document_type = TRIM(p_document_type), page_count = p_page_count + 5 WHERE pub_id = p_pub_id; ELSIF p_document_type = 'conference' THEN INSERT INTO project_publications (proj_pub_id, project_id, pub_id, publication_role) VALUES (p_pub_id * 50, 1, p_pub_id, 'primary'); ELSE UPDATE publications SET publication_status = 'archived' WHERE pub_id = p_pub_id; END IF; RETURN true; END; $$;",
    "database_name": "academic_research_and_publication_management_363414",
    "tables": [
      "publications",
      "publication_authors",
      "publication_areas",
      "publication_keywords",
      "project_publications",
      "research_projects",
      "project_authors"
    ],
    "call_sqls": [
      "SELECT maintain_publication_links(1001, 'Article', 15);",
      "SELECT maintain_publication_links(1002, 'ARTICLE', 10);",
      "SELECT maintain_publication_links(1004, 'Conference', 12);",
      "SELECT maintain_publication_links(1005, 'Book', 25);",
      "SELECT maintain_publication_links(1006, 'Technical Report', 30);",
      "SELECT maintain_publication_links(1007, 'article', 18);",
      "SELECT maintain_publication_links(1008, 'ARTICLE', 22);",
      "SELECT maintain_publication_links(1010, 'Review', 35);",
      "SELECT maintain_publication_links(1011, 'Letter', 3);",
      "SELECT maintain_publication_links(1012, 'ARTICLE', 7);",
      "SELECT maintain_publication_links(1013, 'Conference Paper', 40);",
      "SELECT maintain_publication_links(1015, 'Patent', 50);",
      "SELECT maintain_publication_links(1016, 'ARTICLE', 12);",
      "SELECT maintain_publication_links(1017, 'Standard', 28);",
      "SELECT maintain_publication_links(1019, 'Dissertation', 120);",
      "SELECT maintain_publication_links(1020, 'ARTICLE', 19);"
    ],
    "id": 84
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_event_hire_summary` that accepts one input parameter, `event_id_input`, which is of type `bigint`. This function is designed to return a set of rows, effectively acting as a table, with each row containing two columns: `event_name` of type `text` and `total_hires` of type `bigint`. The primary purpose of this function is to retrieve a summary of hire data for a specific event identified by the `event_id_input`.\n\nUpon execution, the function begins by initiating a `RETURN QUERY` statement, which means it will execute a SQL `SELECT` query and return its results directly. The `SELECT` query is constructed to retrieve two pieces of information:\n1. `se.event_name`: This column is selected directly from the `special_events` table, aliased as `se`.\n2. `SUM(hd.actual_hire_count)::bigint`: This calculates the sum of the `actual_hire_count` column from the `hire_data` table, aliased as `hd`. The result of this sum is then explicitly cast to a `bigint` data type.\n\nThe `SELECT` query involves two tables:\n- `special_events` (aliased as `se`): This table presumably stores information about various special events.\n- `hire_data` (aliased as `hd`): This table presumably contains data related to hires, including the actual count of hires.\n\nThese two tables are joined using an `INNER JOIN` operation. The join condition is `se.event_zone_id = hd.zone_id`, meaning that rows from `special_events` are matched with rows from `hire_data` where the `event_zone_id` in `special_events` is equal to the `zone_id` in `hire_data`. This links event information to hire data based on a common zone identifier.\n\nA `WHERE` clause is applied to filter the results. The condition is `se.event_id = event_id_input`, which restricts the selected rows to only those where the `event_id` in the `special_events` table matches the `event_id_input` parameter provided to the function. This ensures that the summary is generated specifically for the requested event.\n\nFinally, the results are grouped using a `GROUP BY` clause on `se.event_name`. This means that if multiple entries for the same event name exist (perhaps due to different zones or hire data entries), their `actual_hire_count` values will be summed together, and a single row will be returned for each unique `event_name` associated with the specified `event_id_input`. The function then concludes, returning the aggregated results.",
    "plsql": "CREATE OR REPLACE FUNCTION get_event_hire_summary(event_id_input bigint) RETURNS TABLE(event_name text, total_hires bigint) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT se.event_name, SUM(hd.actual_hire_count)::bigint\n    FROM special_events se\n    JOIN hire_data hd ON se.event_zone_id = hd.zone_id\n    WHERE se.event_id = event_id_input\n    GROUP BY se.event_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "bike_sharing_demand_prediction",
    "tables": [
      "hire_data",
      "zones",
      "weather_data",
      "weather_conditions",
      "special_events",
      "users",
      "access_logs"
    ],
    "call_sqls": [
      "SELECT * FROM get_event_hire_summary(1);",
      "SELECT * FROM get_event_hire_summary(2);",
      "SELECT * FROM get_event_hire_summary(3);",
      "SELECT * FROM get_event_hire_summary(4);",
      "SELECT * FROM get_event_hire_summary(5);",
      "SELECT * FROM get_event_hire_summary(10);",
      "SELECT * FROM get_event_hire_summary(15);",
      "SELECT * FROM get_event_hire_summary(20);",
      "SELECT * FROM get_event_hire_summary(25);",
      "SELECT * FROM get_event_hire_summary(30);",
      "SELECT * FROM get_event_hire_summary(35);",
      "SELECT * FROM get_event_hire_summary(40);",
      "SELECT * FROM get_event_hire_summary(45);",
      "SELECT * FROM get_event_hire_summary(50);",
      "SELECT * FROM get_event_hire_summary(55);",
      "SELECT * FROM get_event_hire_summary(60);",
      "SELECT * FROM get_event_hire_summary(100);",
      "SELECT * FROM get_event_hire_summary(150);",
      "SELECT * FROM get_event_hire_summary(200);",
      "SELECT * FROM get_event_hire_summary(250);",
      "SELECT * FROM get_event_hire_summary(300);"
    ],
    "id": 85
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_uppercase_program_name` that is designed to retrieve the uppercase version of a program's name from a database table. This function accepts a single input parameter, `program_id_in`, which is of the `NUMBER` data type. The purpose of `program_id_in` is to uniquely identify the specific program whose name is to be retrieved. The function is declared to return a value of the `VARCHAR2` data type, specifically a string of up to 255 characters, which will represent the uppercase program name. Inside the function's declarative section, a local variable named `program_name_out` is declared, also of the `VARCHAR2(255)` data type, to temporarily store the retrieved program name before it is returned. The executable block of the function begins by performing a `SELECT` operation. This `SELECT` statement queries the `programs` table. It specifically selects the `program_name` column. Before assigning the selected value, the `UPPER()` function is applied to the `program_name` column. The `UPPER()` function converts all characters in the `program_name` string to their uppercase equivalents. The result of this `UPPER()` function applied to `program_name` is then stored `INTO` the `program_name_out` variable. The `SELECT` statement includes a `WHERE` clause to filter the rows from the `programs` table. The condition in the `WHERE` clause is `program_id = program_id_in`, which means that only the row where the value in the `program_id` column matches the value passed in the `program_id_in` input parameter will be considered for selection. After the `SELECT` statement successfully retrieves and processes the program name, the function concludes by returning the value currently stored in the `program_name_out` variable as its final output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_uppercase_program_name(program_id_in NUMBER) RETURN VARCHAR2 IS\n  program_name_out VARCHAR2(255);\nBEGIN\n  SELECT UPPER(program_name)\n  INTO program_name_out\n  FROM programs\n  WHERE program_id = program_id_in;\n  RETURN program_name_out;\nEND;",
    "database_name": "university_gp_management",
    "tables": [
      "award_types",
      "program_enrollments",
      "program_inquiries",
      "programs",
      "student_categories"
    ],
    "call_sqls": [
      "SELECT get_uppercase_program_name(1) FROM dual",
      "SELECT get_uppercase_program_name(2) FROM dual",
      "SELECT get_uppercase_program_name(3) FROM dual",
      "SELECT get_uppercase_program_name(4) FROM dual",
      "SELECT get_uppercase_program_name(5) FROM dual",
      "SELECT get_uppercase_program_name(10) FROM dual",
      "SELECT get_uppercase_program_name(15) FROM dual",
      "SELECT get_uppercase_program_name(20) FROM dual",
      "SELECT get_uppercase_program_name(25) FROM dual",
      "SELECT get_uppercase_program_name(30) FROM dual",
      "SELECT get_uppercase_program_name(100) FROM dual",
      "SELECT get_uppercase_program_name(101) FROM dual",
      "SELECT get_uppercase_program_name(102) FROM dual",
      "SELECT get_uppercase_program_name(200) FROM dual",
      "SELECT get_uppercase_program_name(201) FROM dual",
      "SELECT get_uppercase_program_name(202) FROM dual",
      "SELECT get_uppercase_program_name(300) FROM dual",
      "SELECT get_uppercase_program_name(301) FROM dual",
      "SELECT get_uppercase_program_name(302) FROM dual",
      "SELECT get_uppercase_program_name(999) FROM dual"
    ],
    "id": 86
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `update_access_permissions` that accepts three input parameters: `p_user_id` of type `bigint`, `p_spreadsheet_id` of type `bigint`, and `p_new_permission` of type `bigint`. This function is designed to modify access permissions for users on spreadsheets and will return a `bigint` value, specifically the `p_user_id` that was passed into the function. The function's logic proceeds through a series of conditional checks.\n\nThe first condition evaluates if `p_user_id` is greater than 0, AND `p_spreadsheet_id` is greater than 0, AND `p_new_permission` is equal to 1, AND if there EXISTS at least one record in the `spreadsheets` table where the `id` column matches the value of `p_spreadsheet_id`. If all these conditions are met, the function executes an `UPDATE` statement on the `spreadsheet_access` table. This `UPDATE` statement sets the `edit_permission` column to the value of `p_new_permission` for all rows where the `user_id` column matches `p_user_id` AND the `spreadsheet_id` column matches `p_spreadsheet_id`.\n\nIf the first condition is not met, the function proceeds to an `ELSIF` block. This second condition checks if `p_user_id` is greater than 0, AND `p_spreadsheet_id` is greater than 0, AND `p_new_permission` is equal to 0. If these conditions are met, the function executes an `UPDATE` statement on the `spreadsheet_access` table. This `UPDATE` statement sets the `edit_permission` column to 0 AND sets the `access_type` column to the string literal 'view' for all rows where the `user_id` column matches `p_user_id` AND the `spreadsheet_id` column matches `p_spreadsheet_id`.\n\nIf neither of the first two conditions is met, the function proceeds to another `ELSIF` block. This third condition checks if `p_user_id` is less than 0. If this condition is met, the function executes an `UPDATE` statement on the `spreadsheet_access` table. This `UPDATE` statement sets the `edit_permission` column to the absolute value of `p_new_permission` (using the `ABS()` function) for all rows where the `spreadsheet_id` column matches `p_spreadsheet_id`.\n\nIf none of the preceding conditions (the initial `IF` and the two `ELSIF` blocks) are met, the function executes the `ELSE` block. In this `ELSE` block, the function performs a `DELETE` operation on the `spreadsheet_access` table. This `DELETE` statement removes all rows where the `user_id` column matches `p_user_id` AND the `spreadsheet_id` column matches `p_spreadsheet_id`.\n\nFinally, regardless of which conditional path was taken, the function concludes by returning the value of the `p_user_id` parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION update_access_permissions(p_user_id bigint, p_spreadsheet_id bigint, p_new_permission bigint)\nRETURNS bigint\nAS $$\nBEGIN\n    IF p_user_id > 0 AND p_spreadsheet_id > 0 AND p_new_permission = 1 AND EXISTS(SELECT 1 FROM spreadsheets WHERE id = p_spreadsheet_id) THEN\n        UPDATE spreadsheet_access SET edit_permission = p_new_permission WHERE user_id = p_user_id AND spreadsheet_id = p_spreadsheet_id;\n    ELSIF p_user_id > 0 AND p_spreadsheet_id > 0 AND p_new_permission = 0 THEN\n        UPDATE spreadsheet_access SET edit_permission = 0, access_type = 'view' WHERE user_id = p_user_id AND spreadsheet_id = p_spreadsheet_id;\n    ELSIF p_user_id < 0 THEN\n        UPDATE spreadsheet_access SET edit_permission = ABS(p_new_permission) WHERE spreadsheet_id = p_spreadsheet_id;\n    ELSE\n        DELETE FROM spreadsheet_access WHERE user_id = p_user_id AND spreadsheet_id = p_spreadsheet_id;\n    END IF;\n    RETURN p_user_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "spreadsheet_management_for_it_systems",
    "tables": [
      "spreadsheet_access",
      "spreadsheets"
    ],
    "call_sqls": [
      "SELECT update_access_permissions(1, 1, 1);",
      "SELECT update_access_permissions(2, 5, 1);",
      "SELECT update_access_permissions(3, 10, 0);",
      "SELECT update_access_permissions(4, 2, 0);",
      "SELECT update_access_permissions(-1, 1, 1);",
      "SELECT update_access_permissions(-5, 3, 0);",
      "SELECT update_access_permissions(5, 100, 1);",
      "SELECT update_access_permissions(6, 7, 2);",
      "SELECT update_access_permissions(7, 8, -1);",
      "SELECT update_access_permissions(0, 1, 1);",
      "SELECT update_access_permissions(8, 0, 0);",
      "SELECT update_access_permissions(9, 4, 1);",
      "SELECT update_access_permissions(10, 6, 0);",
      "SELECT update_access_permissions(-10, 9, 1);",
      "SELECT update_access_permissions(11, 11, 1);",
      "SELECT update_access_permissions(12, 12, 0);",
      "SELECT update_access_permissions(-100, 15, 0);",
      "SELECT update_access_permissions(13, 20, 5);",
      "SELECT update_access_permissions(14, 25, -2);",
      "SELECT update_access_permissions(15, 30, 1);"
    ],
    "id": 87
  },
  {
    "ir": "Write a PL/pgSQL function named `trg_update_ethnicity_percentage` that is designed to be executed as a trigger. This function does not accept any explicit parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. The function's purpose is to modify data within the `ethnicities` table. Specifically, it performs an `UPDATE` operation on the `ethnicities` table. During this update, it increments the value in the `population_percentage` column by `5`. This increment is applied to the row where the `ethnicity_id` column matches the value of the `ethnicity_id` column from the `NEW` record, which represents the row that just triggered the operation. After performing this update, the function returns the `NEW` record, indicating that the original operation (e.g., `INSERT`) should proceed with the newly inserted or updated row.\n\nAdditionally, define a trigger named `update_ethnicity_percentage_after_insert`. This trigger is configured to activate `AFTER INSERT` operations on the `ethnicities` table. It is set to execute `FOR EACH ROW`, meaning that the associated function will be invoked once for every row that is inserted into the `ethnicities` table. The trigger executes the `trg_update_ethnicity_percentage()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_ethnicity_percentage() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE ethnicities SET population_percentage = population_percentage + 5 WHERE ethnicity_id = NEW.ethnicity_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_ethnicity_percentage_after_insert\nAFTER INSERT ON ethnicities\nFOR EACH ROW EXECUTE FUNCTION trg_update_ethnicity_percentage();",
    "database_name": "health_surveillance_and_demographic_analysis",
    "tables": [
      "age_categories",
      "chronic_conditions",
      "ethnicities",
      "pregnancy_status",
      "locations",
      "travel_history"
    ],
    "call_sqls": [
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (2, 'Asian', 'Asian ethnicity', 'People of Asian descent', 10.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (3, 'European', 'European ethnicity', 'People of European descent', 50.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (4, 'Maori', 'Maori ethnicity', 'Indigenous people of New Zealand', 15.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (5, 'Pacific Islander', 'Pacific Islander ethnicity', 'People from Pacific Islands', 8.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (6, 'African', 'African ethnicity', 'People of African descent', 5.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (7, 'Middle Eastern', 'Middle Eastern ethnicity', 'People from the Middle East', 7.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (8, 'Hispanic', 'Hispanic ethnicity', 'People of Hispanic or Latino origin', 25.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (9, 'Native American', 'Native American ethnicity', 'Indigenous peoples of the Americas', 3.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (10, 'Mixed', 'Mixed ethnicity', 'People of multiple ethnic backgrounds', 12.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (11, 'Other', 'Other ethnicity', 'Other ethnic background not listed', 4.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (12, 'South Asian', 'South Asian ethnicity', 'People from South Asia', 9.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (13, 'East Asian', 'East Asian ethnicity', 'People from East Asia', 11.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (14, 'Southeast Asian', 'Southeast Asian ethnicity', 'People from Southeast Asia', 6.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (15, 'Caribbean', 'Caribbean ethnicity', 'People from the Caribbean', 2.0);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (16, 'Scandinavian', 'Scandinavian ethnicity', 'People from Scandinavia', 4.5);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (17, 'Mediterranean', 'Mediterranean ethnicity', 'People from Mediterranean region', 8.5);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (18, 'Slavic', 'Slavic ethnicity', 'People of Slavic descent', 7.5);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (19, 'Jewish', 'Jewish ethnicity', 'People of Jewish heritage', 1.5);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (20, 'Indigenous Australian', 'Indigenous Australian ethnicity', 'Aboriginal and Torres Strait Islander peoples', 3.5);",
      "INSERT INTO ethnicities (ethnicity_id, ethnicity_name, description, description_long, population_percentage) VALUES (21, 'Filipino', 'Filipino ethnicity', 'People from the Philippines', 5.5);"
    ],
    "id": 88
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_lob_length that accepts a single input parameter named transaction_id_in of type NUMBER and returns a value of type NUMBER, which begins by declaring a local variable named lob_length of type NUMBER, then executes a SELECT statement to query the LENGTH of the notes column from the fraud_flags table where the transaction_id column equals the input parameter transaction_id_in, storing the result into the lob_length variable, and then returns this lob_length value, but if the SELECT statement finds no matching rows it handles the NO_DATA_FOUND exception by returning a NULL value, and if the SELECT statement finds multiple matching rows it handles the TOO_MANY_ROWS exception by executing a second SELECT statement to query the LENGTH of the notes column from the fraud_flags table where the transaction_id column equals the input parameter transaction_id_in and the ROWNUM pseudo-column equals 1, thereby retrieving the length from only the first row returned, storing this result into the lob_length variable, and then returning this lob_length value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_lob_length(transaction_id_in NUMBER) RETURN NUMBER IS\n  lob_length NUMBER;\nBEGIN\n  SELECT LENGTH(notes) INTO lob_length\n  FROM fraud_flags\n  WHERE transaction_id = transaction_id_in;\n  RETURN lob_length;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN TOO_MANY_ROWS THEN\n    SELECT LENGTH(notes) INTO lob_length\n    FROM fraud_flags\n    WHERE transaction_id = transaction_id_in\n    AND ROWNUM = 1;\n    RETURN lob_length;\nEND;",
    "database_name": "banking_t_management",
    "tables": [
      "access_logs",
      "accounts",
      "customers",
      "fraud_flags",
      "locations",
      "transaction_types",
      "transactions",
      "users"
    ],
    "call_sqls": [
      "SELECT get_lob_length(0) FROM DUAL",
      "SELECT get_lob_length(1) FROM DUAL",
      "SELECT get_lob_length(100) FROM DUAL",
      "SELECT get_lob_length(500) FROM DUAL",
      "SELECT get_lob_length(1000) FROM DUAL",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE flag_id = 0",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE flag_type = 'high amount'",
      "SELECT get_lob_length(t.transaction_id) FROM transactions t JOIN fraud_flags f ON t.transaction_id = f.transaction_id WHERE t.amount > 1000",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE status = 'open'",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE flag_severity = 'high'",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE investigator_id = 1",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE flag_date = '2023-05-01'",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE flag_id IN (0, 1, 2)",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE notes IS NOT NULL",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE last_update_date > '2023-01-01'",
      "SELECT get_lob_length(t.transaction_id) FROM transactions t JOIN fraud_flags f ON t.transaction_id = f.transaction_id WHERE t.account_number = 0",
      "SELECT get_lob_length(t.transaction_id) FROM transactions t JOIN fraud_flags f ON t.transaction_id = f.transaction_id WHERE t.transaction_type_id = 1",
      "SELECT get_lob_length(t.transaction_id) FROM transactions t JOIN fraud_flags f ON t.transaction_id = f.transaction_id WHERE t.atm_location_id = 1",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE flag_reason LIKE '%withdrawal%'",
      "SELECT get_lob_length(transaction_id) FROM fraud_flags WHERE ROWNUM <= 5"
    ],
    "id": 89
  },
  {
    "ir": "Write an Oracle PL/SQL function named update_version_notes that accepts two input parameters: a numeric parameter p_version_id which specifies the unique identifier for a version record, and a string parameter p_new_notes which contains the new text for the version notes, and this function performs an update operation on the data_versions table by setting the version_notes column to the value provided in p_new_notes specifically for the row where the version_id column matches the value provided in p_version_id, and then returns the number of rows that were affected by this update operation as a numeric value.",
    "plsql": "CREATE OR REPLACE FUNCTION update_version_notes(p_version_id NUMBER, p_new_notes VARCHAR2) RETURN NUMBER IS\n  PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN\n  UPDATE data_versions\n  SET version_notes = p_new_notes\n  WHERE version_id = p_version_id;\n\n  COMMIT;\n\n  RETURN SQL%ROWCOUNT;\nEND;",
    "database_name": "biological_rapd_managemen",
    "tables": [
      "experiments",
      "samples",
      "data_files",
      "data_versions"
    ],
    "call_sqls": [
      "SELECT update_version_notes(1, 'Initial data import') FROM dual",
      "SELECT update_version_notes(2, 'Corrected sample metadata') FROM dual",
      "SELECT update_version_notes(3, 'Added quality control metrics') FROM dual",
      "SELECT update_version_notes(4, 'Updated with replicate information') FROM dual",
      "SELECT update_version_notes(5, 'Data normalization applied') FROM dual",
      "SELECT update_version_notes(6, 'Filtered low-quality reads') FROM dual",
      "SELECT update_version_notes(7, 'Aligned to reference genome GRCh38') FROM dual",
      "SELECT update_version_notes(8, 'Peak calling completed') FROM dual",
      "SELECT update_version_notes(9, 'Differential expression analysis') FROM dual",
      "SELECT update_version_notes(10, 'Final version for publication') FROM dual",
      "SELECT update_version_notes(11, 'Batch correction applied') FROM dual",
      "SELECT update_version_notes(12, 'Annotated with gene symbols') FROM dual",
      "SELECT update_version_notes(13, 'Removed technical outliers') FROM dual",
      "SELECT update_version_notes(14, 'Pathway enrichment results added') FROM dual",
      "SELECT update_version_notes(15, 'Clinical metadata integrated') FROM dual",
      "SELECT update_version_notes(16, 'Version compatible with tool v2.1') FROM dual",
      "SELECT update_version_notes(17, 'Raw counts matrix') FROM dual",
      "SELECT update_version_notes(18, 'TPM normalized values') FROM dual",
      "SELECT update_version_notes(19, 'Confidential - internal use only') FROM dual",
      "SELECT update_version_notes(20, 'Public release version 1.0') FROM dual"
    ],
    "id": 90
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters: para_user_id of type bigint and para_new_email of type text. The function first checks if there exists a record in the users table with a user_id matching the para_user_id parameter. If such a record exists, it updates the email column in the users table to the value of para_new_email for the row where user_id equals para_user_id. Additionally, it updates the updated_at column to the current time for the same row. The function does not perform any operations if no matching user_id is found in the users table.",
    "plsql": "CREATE OR REPLACE FUNCTION update_user_email(para_user_id bigint, para_new_email text) RETURNS void LANGUAGE plpgsql AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM users WHERE user_id = para_user_id) THEN\n    UPDATE users SET email = para_new_email, updated_at = current_time WHERE user_id = para_user_id;\n  END IF;\nEND;\n$$;",
    "database_name": "parameter_configuration_and_validation_for_software_deployment",
    "tables": [
      "audit_logs",
      "config_params",
      "configurations",
      "parameter_types",
      "parameters",
      "users",
      "roles"
    ],
    "call_sqls": [
      "SELECT update_user_email(1, 'john.new@example.com');",
      "SELECT update_user_email(2, 'jane.updated@example.com');",
      "SELECT update_user_email(3, 'alex.smith@company.org');",
      "SELECT update_user_email(4, 'michael.brown@test.net');",
      "SELECT update_user_email(5, 'sarah.jones@demo.com');",
      "SELECT update_user_email(6, 'david.wilson@mail.io');",
      "SELECT update_user_email(7, 'emma.davis@web.app');",
      "SELECT update_user_email(8, 'robert.miller@cloud.co');",
      "SELECT update_user_email(9, 'lisa.taylor@server.dev');",
      "SELECT update_user_email(10, 'thomas.anderson@matrix.ai');",
      "SELECT update_user_email(11, 'olivia.moore@data.tech');",
      "SELECT update_user_email(12, 'william.jackson@api.site');",
      "SELECT update_user_email(13, 'sophia.white@service.pro');",
      "SELECT update_user_email(14, 'james.harris@platform.biz');",
      "SELECT update_user_email(15, 'ava.martin@system.info');",
      "SELECT update_user_email(16, 'benjamin.thompson@network.us');",
      "SELECT update_user_email(17, 'mia.garcia@mobile.uk');",
      "SELECT update_user_email(18, 'henry.rodriguez@secure.eu');",
      "SELECT update_user_email(19, 'charlotte.lee@private.ca');",
      "SELECT update_user_email(20, 'daniel.walker@personal.au');"
    ],
    "id": 91
  },
  {
    "ir": "Write a PostgreSQL stored procedure named 'sp' that accepts four input parameters: 'para_user_id' of type bigint representing a user identifier, 'para_credential_id' of type bigint representing a base credential identifier, 'para_token_data' of type text which is a string to be interpreted as a bit string, and 'para_check_position' of type bigint indicating a specific bit position within the token data; the procedure begins by declaring a variable 'rec' of type RECORD to hold rows from a query and a variable 'token_bit' of type integer to store a single bit value; it then initializes 'token_bit' by calling the built-in function 'get_bit' on the 'para_token_data' text cast to a fixed-length bit string of 18 bits, using the 'para_check_position' parameter cast to an integer as the bit index to extract; following this, the procedure executes a FOR loop that iterates over each row returned by a SELECT query on the 'roles' table, selecting the 'role_id' and 'role_name' columns for every row where the 'role_id' is less than or equal to the calculated value of 'token_bit + 1'; for each record 'rec' in this result set, the procedure performs an INSERT operation on the 'user_credentials' table, inserting a new row with the following values: 'user_id' is set to the input parameter 'para_user_id', 'credential_id' is set to the sum of the input parameter 'para_credential_id' and the current loop record's 'role_id' value, and both the 'created_at' and 'updated_at' columns are set to the current timestamp by casting the result of the 'clock_timestamp()' function to text; this INSERT operation uses an ON CONFLICT clause that specifies a conflict on the unique constraint of the columns 'user_id' and 'credential_id', and when such a conflict occurs, it performs an UPDATE operation that sets only the 'updated_at' column of the existing conflicting row to the new 'updated_at' value from the attempted insert (referenced via the special EXCLUDED table).",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_user_id bigint, para_credential_id bigint, para_token_data text, para_check_position bigint) LANGUAGE plpgsql AS $$\nDECLARE\n    rec RECORD;\n    token_bit integer;\nBEGIN\n    token_bit := get_bit(para_token_data::bit(18), para_check_position::integer);\n    FOR rec IN SELECT role_id, role_name FROM roles WHERE role_id <= token_bit + 1 LOOP\n        INSERT INTO user_credentials (user_id, credential_id, created_at, updated_at)\n        VALUES (para_user_id, para_credential_id + rec.role_id, CAST(clock_timestamp() AS text), CAST(clock_timestamp() AS text))\n        ON CONFLICT (user_id, credential_id) DO UPDATE SET updated_at = EXCLUDED.updated_at;\n    END LOOP;\nEND;\n$$;",
    "database_name": "authorization_and_credential_management_system",
    "tables": [
      "users",
      "credentials",
      "user_credentials",
      "access_logs",
      "roles"
    ],
    "call_sqls": [
      "CALL sp(1, 100, '110010101001101010', 0);",
      "CALL sp(2, 101, '110010101001101010', 1);",
      "CALL sp(3, 102, '001101010110010101', 2);",
      "CALL sp(4, 103, '001101010110010101', 3);",
      "CALL sp(5, 104, '111111111111111111', 4);",
      "CALL sp(6, 105, '111111111111111111', 5);",
      "CALL sp(7, 106, '000000000000000000', 6);",
      "CALL sp(8, 107, '000000000000000000', 7);",
      "CALL sp(9, 108, '101010101010101010', 8);",
      "CALL sp(10, 109, '101010101010101010', 9);",
      "CALL sp(11, 110, '010101010101010101', 10);",
      "CALL sp(12, 111, '010101010101010101', 11);",
      "CALL sp(13, 112, '100110011001100110', 12);",
      "CALL sp(14, 113, '100110011001100110', 13);",
      "CALL sp(15, 114, '011001100110011001', 14);",
      "CALL sp(16, 115, '011001100110011001', 15);",
      "CALL sp(17, 116, '111000111000111000', 16);",
      "CALL sp(18, 117, '111000111000111000', 17);",
      "CALL sp(19, 118, '000111000111000111', 0);",
      "CALL sp(20, 119, '000111000111000111', 1);"
    ],
    "id": 92
  },
  {
    "ir": "Write a PLpgSQL trigger function named `update_letter_analysis_status` that is designed to be executed in response to a specific database event, and a trigger named `after_frequency_insert` that invokes this function. The `update_letter_analysis_status` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. Upon execution, this function performs a single `UPDATE` operation on the `letters` table. Specifically, it sets the value of the `is_analyzed` column to `1`. This update is conditionally applied, targeting only those rows in the `letters` table where the `letter_id` column matches the value of `NEW.letter_id`. The `NEW.letter_id` refers to the `letter_id` value of the row that caused the trigger to fire. After performing this update, the function returns `NEW`, which represents the row that was just inserted into the `letter_frequency` table, allowing the triggering operation to complete successfully. The `after_frequency_insert` trigger is defined to activate `AFTER INSERT` operations on the `letter_frequency` table. It is configured to execute `FOR EACH ROW`, meaning that the `update_letter_analysis_status` function will be invoked once for every single row that is inserted into the `letter_frequency` table. The trigger explicitly specifies `EXECUTE FUNCTION update_letter_analysis_status()`, thereby linking the trigger event to the execution of the previously defined trigger function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_letter_analysis_status() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE letters SET is_analyzed = 1 WHERE letter_id = NEW.letter_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER after_frequency_insert\nAFTER INSERT ON letter_frequency\nFOR EACH ROW EXECUTE FUNCTION update_letter_analysis_status();",
    "database_name": "criminal_investigation_and_forensic_analysis",
    "tables": [
      "suspects",
      "letters",
      "letter_frequency",
      "investigators"
    ],
    "call_sqls": [
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (100, 'A', 8.167, 1, 5, '2024-01-15', 100);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (101, 'B', 1.492, 2, 6, '2024-01-15', 150);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (102, 'C', 2.782, 1, 7, '2024-01-16', 200);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (103, 'D', 4.253, 3, 8, '2024-01-16', 75);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (104, 'E', 12.702, 2, 9, '2024-01-17', 300);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (105, 'F', 2.228, 1, 10, '2024-01-17', 125);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (106, 'G', 2.015, 4, 11, '2024-01-18', 90);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (107, 'H', 6.094, 3, 12, '2024-01-18', 180);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (108, 'I', 6.966, 2, 13, '2024-01-19', 220);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (109, 'J', 0.153, 1, 14, '2024-01-19', 50);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (110, 'K', 0.772, 5, 15, '2024-01-20', 60);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (111, 'L', 4.025, 4, 16, '2024-01-20', 170);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (112, 'M', 2.406, 3, 17, '2024-01-21', 110);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (113, 'N', 6.749, 2, 18, '2024-01-21', 250);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (114, 'O', 7.507, 1, 19, '2024-01-22', 140);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (115, 'P', 1.929, 6, 20, '2024-01-22', 80);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (116, 'Q', 0.095, 5, 21, '2024-01-23', 30);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (117, 'R', 5.987, 4, 22, '2024-01-23', 190);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (118, 'S', 6.327, 3, 23, '2024-01-24', 210);",
      "INSERT INTO letter_frequency (frequency_id, letter, frequency, suspect_id, letter_id, analysis_date, total_letters) VALUES (119, 'T', 9.056, 2, 24, '2024-01-24', 270);"
    ],
    "id": 93
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `aggregate_team_performance_stats` that returns a table containing aggregated performance statistics for teams. This function takes no input parameters. The returned table will have four columns: `team_name` of type `text`, `total_wins` of type `bigint`, `total_losses` of type `bigint`, and `avg_win_percentage` of type `numeric`. The function's core operation is a `SELECT` query that retrieves data from two tables: `teams` (aliased as `t`) and `team_performance` (aliased as `tp`). It performs an `INNER JOIN` between these two tables based on the condition `t.team_id = tp.team_id`, linking team records with their corresponding performance records. For each joined record, it selects the `team_name` from the `teams` table. It then calculates the sum of `total_wins` from the `team_performance` table, casting the result to `bigint`, and labels this as `total_wins`. Similarly, it calculates the sum of `total_losses` from the `team_performance` table, casting the result to `bigint`, and labels this as `total_losses`. It also calculates the average of `win_percentage` from the `team_performance` table, casting the result to `numeric`, and labels this as `avg_win_percentage`. These aggregations (SUM and AVG) are performed for each distinct `team_name` due to the `GROUP BY t.team_name` clause. After grouping, the results are filtered using a `HAVING` clause, which includes only those groups (teams) where the calculated `AVG(tp.win_percentage)` is strictly greater than `0.5`. Finally, the filtered and aggregated results are ordered in descending order based on the `avg_win_percentage` column. The `RETURN QUERY` statement then outputs the result set of this `SELECT` query as the return value of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION aggregate_team_performance_stats()\nRETURNS TABLE(team_name text, total_wins bigint, total_losses bigint, avg_win_percentage numeric) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT t.team_name,\n           SUM(tp.total_wins)::bigint AS total_wins,\n           SUM(tp.total_losses)::bigint AS total_losses,\n           AVG(tp.win_percentage)::numeric AS avg_win_percentage\n    FROM teams t\n    JOIN team_performance tp ON t.team_id = tp.team_id\n    GROUP BY t.team_name\n    HAVING AVG(tp.win_percentage) > 0.5\n    ORDER BY avg_win_percentage DESC;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "baseball_player_statistics_and_financial_records",
    "tables": [
      "player_evolutions",
      "player_positions",
      "player_salaries",
      "players",
      "positions",
      "team_financials",
      "team_performance",
      "teams"
    ],
    "call_sqls": [
      "SELECT * FROM aggregate_team_performance_stats();",
      "SELECT team_name, total_wins FROM aggregate_team_performance_stats();",
      "SELECT * FROM aggregate_team_performance_stats() WHERE total_wins > 90;",
      "SELECT team_name, avg_win_percentage FROM aggregate_team_performance_stats() ORDER BY team_name;",
      "SELECT team_name, total_wins, total_losses FROM aggregate_team_performance_stats() WHERE avg_win_percentage > 0.6;",
      "SELECT COUNT(*) FROM aggregate_team_performance_stats();",
      "SELECT * FROM aggregate_team_performance_stats() WHERE team_name LIKE '%Dodgers%';",
      "SELECT team_name, (total_wins + total_losses) AS total_games FROM aggregate_team_performance_stats();",
      "SELECT team_name FROM aggregate_team_performance_stats() WHERE total_losses < 70;",
      "SELECT team_name, avg_win_percentage FROM aggregate_team_performance_stats() ORDER BY avg_win_percentage DESC LIMIT 5;",
      "SELECT AVG(avg_win_percentage) FROM aggregate_team_performance_stats();",
      "SELECT team_name, total_wins FROM aggregate_team_performance_stats() ORDER BY total_wins DESC;",
      "SELECT * FROM aggregate_team_performance_stats() WHERE team_name IN ('1948 Brooklyn Dodgers', '1949 Brooklyn Dodgers');",
      "SELECT team_name, total_wins, total_losses, ROUND(avg_win_percentage, 3) FROM aggregate_team_performance_stats();",
      "SELECT team_name FROM aggregate_team_performance_stats() WHERE total_wins > total_losses * 1.5;",
      "SELECT SUM(total_wins) AS league_wins FROM aggregate_team_performance_stats();",
      "SELECT team_name, avg_win_percentage FROM aggregate_team_performance_stats() WHERE avg_win_percentage BETWEEN 0.55 AND 0.65;",
      "SELECT team_name, total_wins, total_losses FROM aggregate_team_performance_stats() WHERE total_wins > 100;",
      "SELECT * FROM aggregate_team_performance_stats() WHERE team_name ~ '^194';",
      "SELECT team_name, (total_wins::numeric / (total_wins + total_losses)) AS calculated_percentage FROM aggregate_team_performance_stats();"
    ],
    "id": 94
  },
  {
    "ir": "Write a PostgreSQL stored procedure named assign_permissions_to_role that accepts two parameters: p_role_id of type bigint representing the identifier of the role, and p_permission_names of type text[] which is an array of permission names to be assigned to the role. The procedure first checks if a role with the specified role_id exists in the roles table by executing a SELECT EXISTS query, storing the result in the v_role_exists variable. If the role does not exist, the procedure inserts a new record into the roles table with the provided role_id, a role_name of 'New Role', and a description of 'Auto-generated role'. The procedure then enters a WHILE loop that iterates through each element in the p_permission_names array, starting with v_counter initialized to 1 and continuing until v_counter exceeds the length of the array. Within each iteration, the current permission name is extracted from the array and stored in v_permission_name. The procedure attempts to retrieve the permission_id from the permissions table where permission_name matches v_permission_name. If no permission is found (v_permission_id is NULL), the procedure calculates a new permission_id by finding the maximum existing permission_id in the permissions table, adding 1 to it (using COALESCE to handle the case where no permissions exist), and then inserts a new record into the permissions table with this generated ID, the permission name, and a description of 'Auto-generated permission'. After ensuring the permission exists, the procedure checks if the relationship between the role and permission already exists in the role_permissions table by executing a SELECT EXISTS query with conditions matching both role_id and permission_id. If this relationship does not exist, the procedure inserts a new record into the role_permissions table containing the role_id, permission_id, and the current timestamp converted to text for the assigned_at column. The counter is incremented after each iteration. Finally, the procedure counts the total number of permissions assigned to the role by executing a COUNT(*) query on the role_permissions table filtered by the role_id, storing the result in v_permission_count.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_permissions_to_role(p_role_id bigint, p_permission_names text[])\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_permission_id bigint;\n    v_permission_name text;\n    v_counter integer := 1;\n    v_exists boolean;\n    v_role_exists boolean;\n    v_permission_count integer;\nBEGIN\n    SELECT EXISTS(SELECT 1 FROM roles WHERE role_id = p_role_id) INTO v_role_exists;\n    IF NOT v_role_exists THEN\n        INSERT INTO roles (role_id, role_name, description)\n        VALUES (p_role_id, 'New Role', 'Auto-generated role');\n    END IF;\n    \n    WHILE v_counter <= array_length(p_permission_names, 1) LOOP\n        v_permission_name := p_permission_names[v_counter];\n        SELECT permission_id INTO v_permission_id FROM permissions WHERE permission_name = v_permission_name;\n        \n        IF v_permission_id IS NULL THEN\n            SELECT COALESCE(MAX(permission_id), 0) + 1 INTO v_permission_id FROM permissions;\n            INSERT INTO permissions (permission_id, permission_name, description)\n            VALUES (v_permission_id, v_permission_name, 'Auto-generated permission');\n        END IF;\n        \n        SELECT EXISTS(SELECT 1 FROM role_permissions WHERE role_id = p_role_id AND permission_id = v_permission_id) INTO v_exists;\n        IF NOT v_exists THEN\n            INSERT INTO role_permissions (role_id, permission_id, assigned_at)\n            VALUES (p_role_id, v_permission_id, CAST(localtimestamp AS text));\n        END IF;\n        \n        v_counter := v_counter + 1;\n    END LOOP;\n    \n    SELECT COUNT(*) INTO v_permission_count FROM role_permissions WHERE role_id = p_role_id;\nEND;\n$$;",
    "database_name": "automated_testing_and_validation",
    "tables": [
      "users",
      "roles",
      "permissions",
      "role_permissions"
    ],
    "call_sqls": [
      "CALL assign_permissions_to_role(100, ARRAY['View Test Cases']);",
      "CALL assign_permissions_to_role(101, ARRAY['Edit Test Cases', 'Manage Users']);",
      "CALL assign_permissions_to_role(1, ARRAY['View Test Cases', 'Edit Test Cases']);",
      "CALL assign_permissions_to_role(500, ARRAY['Create Reports']);",
      "CALL assign_permissions_to_role(3, ARRAY['Delete Users', 'Approve Changes']);",
      "CALL assign_permissions_to_role(102, ARRAY['View Dashboard', 'Export Data']);",
      "CALL assign_permissions_to_role(200, ARRAY['Admin Access', 'System Configuration']);",
      "CALL assign_permissions_to_role(150, ARRAY['Read Only']);",
      "CALL assign_permissions_to_role(10, ARRAY['View Test Cases', 'Edit Test Cases', 'Manage Users']);",
      "CALL assign_permissions_to_role(25, ARRAY['Audit Logs']);",
      "CALL assign_permissions_to_role(30, ARRAY['Backup Database', 'Restore Database']);",
      "CALL assign_permissions_to_role(99, ARRAY['Submit Bug', 'Close Bug']);",
      "CALL assign_permissions_to_role(45, ARRAY['Manage Projects']);",
      "CALL assign_permissions_to_role(60, ARRAY['View Test Cases']);",
      "CALL assign_permissions_to_role(75, ARRAY['Edit Test Cases', 'Delete Test Cases']);",
      "CALL assign_permissions_to_role(88, ARRAY['Manage Users', 'Reset Passwords']);",
      "CALL assign_permissions_to_role(123, ARRAY['Full Access']);",
      "CALL assign_permissions_to_role(999, ARRAY['Permission1', 'Permission2', 'Permission3']);"
    ],
    "id": 95
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_recent_ranking_avg` that accepts no input parameters and returns a single numeric value. This function is designed to calculate the average `ranking_score` from the `RANKINGS` table for records where the `ranking_date` is within the last 30 days, inclusive of the current date.\n\nThe function begins by declaring two local variables: `v_avg` of type `NUMBER` to store the calculated average ranking score, and `sql_stmt` of type `VARCHAR2(1000)` to hold a dynamically constructed SQL query string.\n\nNext, the `sql_stmt` variable is assigned the SQL query string: `'SELECT AVG(ranking_score) FROM RANKINGS WHERE ranking_date >= CURRENT_DATE - 30'`. This SQL statement is a `SELECT` operation that calculates the average of the `ranking_score` column. The `FROM` clause specifies the `RANKINGS` table as the data source. The `WHERE` clause filters the rows, including only those where the `ranking_date` column is greater than or equal to the current date minus 30 days. `CURRENT_DATE` is an Oracle SQL function that returns the current date.\n\nFollowing the assignment, the `EXECUTE IMMEDIATE` statement is used to execute the dynamically constructed SQL query stored in `sql_stmt`. The result of this query, which is the calculated average `ranking_score`, is then stored into the `v_avg` variable using the `INTO` clause.\n\nAfter the execution of the dynamic SQL, the function returns the value of `v_avg`. A special Oracle SQL function, `NVL(v_avg, 0)`, is used here. `NVL` stands for \"Null Value Logic\" and it checks if `v_avg` is `NULL`. If `v_avg` is `NULL` (which would happen if the `SELECT` statement returned no rows or if all `ranking_score` values for the filtered rows were `NULL`), `NVL` will return `0`. Otherwise, it returns the actual value of `v_avg`.\n\nThe function includes an `EXCEPTION` block to handle any potential errors that might occur during its execution. The `WHEN OTHERS THEN` clause catches any unhandled exception. If an exception occurs, the function will immediately return the numeric value `0`, effectively providing a default or error-handling return value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_recent_ranking_avg RETURN NUMBER IS\n    v_avg NUMBER;\n    sql_stmt VARCHAR2(1000);\nBEGIN\n    sql_stmt := 'SELECT AVG(ranking_score) FROM RANKINGS WHERE ranking_date >= CURRENT_DATE - 30';\n    EXECUTE IMMEDIATE sql_stmt INTO v_avg;\n    RETURN NVL(v_avg, 0);\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN 0;\nEND;",
    "database_name": "athlete_ptac_results",
    "tables": [
      "ATHLETES",
      "DISCIPLINES",
      "EVENTS",
      "JUDGES",
      "RANKINGS",
      "RESULTS"
    ],
    "call_sqls": [
      "SELECT get_recent_ranking_avg FROM DUAL",
      "SELECT get_recent_ranking_avg() FROM DUAL",
      "SELECT get_recent_ranking_avg AS avg_score FROM DUAL",
      "SELECT get_recent_ranking_avg FROM DUAL WHERE 1=1",
      "SELECT get_recent_ranking_avg FROM DUAL ORDER BY 1",
      "SELECT get_recent_ranking_avg FROM DUAL FETCH FIRST 1 ROWS ONLY",
      "SELECT get_recent_ranking_avg FROM DUAL WHERE ROWNUM = 1",
      "SELECT get_recent_ranking_avg FROM DUAL CONNECT BY LEVEL <= 1",
      "SELECT get_recent_ranking_avg FROM DUAL GROUP BY ()",
      "SELECT get_recent_ranking_avg FROM DUAL HAVING 1=1",
      "SELECT get_recent_ranking_avg FROM DUAL UNION SELECT 0 FROM DUAL",
      "SELECT get_recent_ranking_avg FROM DUAL MINUS SELECT 0 FROM DUAL",
      "SELECT get_recent_ranking_avg FROM DUAL INTERSECT SELECT 0 FROM DUAL",
      "SELECT get_recent_ranking_avg FROM DUAL JOIN (SELECT 1 FROM DUAL) t ON 1=1",
      "SELECT get_recent_ranking_avg FROM DUAL CROSS JOIN (SELECT 1 FROM DUAL)",
      "SELECT get_recent_ranking_avg FROM DUAL LEFT JOIN (SELECT 1 FROM DUAL) t ON 1=1",
      "SELECT get_recent_ranking_avg FROM DUAL RIGHT JOIN (SELECT 1 FROM DUAL) t ON 1=1",
      "SELECT get_recent_ranking_avg FROM DUAL FULL OUTER JOIN (SELECT 1 FROM DUAL) t ON 1=1",
      "SELECT get_recent_ranking_avg FROM DUAL WHERE get_recent_ranking_avg IS NOT NULL",
      "SELECT get_recent_ranking_avg FROM DUAL WHERE get_recent_ranking_avg > 0"
    ],
    "id": 96
  },
  {
    "ir": "Write a PLpgSQL function named get_country_trade_stats that accepts two parameters: p_country_id of type bigint, representing the ID of a country, and p_include_imports of type boolean with a default value of true, indicating whether import data should be included in the results. The function returns a table with columns year_name of type bigint, export_value of type real, import_value of type real, and trade_balance of type real. The function begins by checking the value of p_include_imports. If p_include_imports is true, it executes a query that selects data from the trade_data table, which contains trade information, and the years table, which contains year identifiers. The query joins these tables on the year column, matching trade_data.year with years.year_id. It filters rows where either the origin_country_id or destination_country_id in trade_data matches p_country_id. For each year, it calculates the export_value as the sum of trade values where trade_type is 'export', import_value as the sum of trade values where trade_type is 'import', and trade_balance as the sum of trade values where trade_type is 'export' minus the sum of trade values where trade_type is 'import'. The COALESCE function is used to ensure that null sums are replaced with zero. The results are grouped by year_name and ordered by year_name. If p_include_imports is false, the function executes a different query that selects data only for exports. It calculates export_value as the sum of trade values where trade_type is 'export', sets import_value to zero, and calculates trade_balance as the sum of trade values where trade_type is 'export'. This query filters rows where origin_country_id matches p_country_id and trade_type is 'export', groups results by year_name, and orders them by year_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_trade_stats(p_country_id bigint, p_include_imports boolean DEFAULT true)\nRETURNS TABLE(\n    year_name bigint,\n    export_value real,\n    import_value real,\n    trade_balance real\n) AS $$\nBEGIN\n    IF p_include_imports THEN\n        RETURN QUERY SELECT y.year_name, COALESCE(SUM(CASE WHEN td.trade_type = 'export' THEN td.value ELSE 0 END), 0), COALESCE(SUM(CASE WHEN td.trade_type = 'import' THEN td.value ELSE 0 END), 0), COALESCE(SUM(CASE WHEN td.trade_type = 'export' THEN td.value ELSE -td.value END), 0) FROM trade_data td JOIN years y ON td.year = y.year_id WHERE (td.origin_country_id = p_country_id OR td.destination_country_id = p_country_id) GROUP BY y.year_name ORDER BY y.year_name;\n    ELSE\n        RETURN QUERY SELECT y.year_name, COALESCE(SUM(CASE WHEN td.trade_type = 'export' THEN td.value ELSE 0 END), 0), 0, COALESCE(SUM(CASE WHEN td.trade_type = 'export' THEN td.value ELSE 0 END), 0) FROM trade_data td JOIN years y ON td.year = y.year_id WHERE td.origin_country_id = p_country_id AND td.trade_type = 'export' GROUP BY y.year_name ORDER BY y.year_name;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "international_trade_data",
    "tables": [
      "access_logs",
      "countries",
      "trade_categories",
      "trade_data",
      "trade_data_categories",
      "trade_notes",
      "users",
      "years"
    ],
    "call_sqls": [
      "SELECT * FROM get_country_trade_stats(1);",
      "SELECT * FROM get_country_trade_stats(1, true);",
      "SELECT * FROM get_country_trade_stats(2);",
      "SELECT * FROM get_country_trade_stats(2, true);",
      "SELECT * FROM get_country_trade_stats(3);",
      "SELECT * FROM get_country_trade_stats(3, true);",
      "SELECT * FROM get_country_trade_stats(4);",
      "SELECT * FROM get_country_trade_stats(4, true);",
      "SELECT * FROM get_country_trade_stats(5);",
      "SELECT * FROM get_country_trade_stats(5, true);",
      "SELECT * FROM get_country_trade_stats(10);",
      "SELECT * FROM get_country_trade_stats(10, true);",
      "SELECT * FROM get_country_trade_stats(15);",
      "SELECT * FROM get_country_trade_stats(15, true);"
    ],
    "id": 97
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_book_sales_revenue that accepts a single parameter book_id_input of type bigint and returns a numeric value, which declares a local variable total_revenue of type numeric, then executes a SQL query that joins the sales table with the editions table on their common edition_id column, calculates the sum of the revenue column from the sales table after casting it to numeric type, filters the joined results to only include rows where the book_id column in the editions table matches the input parameter book_id_input, stores this calculated sum in the total_revenue variable, and finally returns this total_revenue value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_book_sales_revenue(book_id_input bigint) RETURNS numeric AS $$\nDECLARE\n    total_revenue numeric;\nBEGIN\n    SELECT SUM(CAST(revenue AS numeric)) INTO total_revenue\n    FROM sales\n    JOIN editions ON sales.edition_id = editions.edition_id\n    WHERE editions.book_id = book_id_input;\n\n    RETURN total_revenue;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "author_management_system",
    "tables": [
      "authors",
      "books",
      "editions",
      "book_contributors",
      "reviews",
      "sales",
      "awards"
    ],
    "call_sqls": [
      "SELECT get_book_sales_revenue(0);",
      "SELECT get_book_sales_revenue(1);",
      "SELECT get_book_sales_revenue(2);",
      "SELECT get_book_sales_revenue(3);",
      "SELECT get_book_sales_revenue(4);",
      "SELECT get_book_sales_revenue(5);",
      "SELECT get_book_sales_revenue(6);",
      "SELECT get_book_sales_revenue(7);",
      "SELECT get_book_sales_revenue(8);",
      "SELECT get_book_sales_revenue(9);",
      "SELECT get_book_sales_revenue(10);",
      "SELECT get_book_sales_revenue(11);",
      "SELECT get_book_sales_revenue(12);",
      "SELECT get_book_sales_revenue(13);",
      "SELECT get_book_sales_revenue(14);",
      "SELECT get_book_sales_revenue(15);",
      "SELECT get_book_sales_revenue(16);",
      "SELECT get_book_sales_revenue(17);",
      "SELECT get_book_sales_revenue(18);",
      "SELECT get_book_sales_revenue(19);",
      "SELECT get_book_sales_revenue(20);"
    ],
    "id": 98
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_election_status_on_vote` that is designed to be executed after an `INSERT` operation on the `votes` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the row being inserted or updated. Specifically, it accesses the `NEW` record, which contains the data of the newly inserted row into the `votes` table. The primary purpose of this function is to update the `election_status` column in the `elections` table. It performs an `UPDATE` operation on the `elections` table, setting the `election_status` column to the literal string value `'Completed'`. This update is conditional, applying only to rows in the `elections` table where the `election_id` column matches any `office_id` found in the `candidates` table. The selection of `office_id` values from the `candidates` table is further constrained by a `WHERE` clause, which specifies that only `office_id` values associated with a `candidate_id` that matches the `candidate_id` from the `NEW` record (the newly inserted row in the `votes` table) are considered. After performing this update, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL.\n\nFollowing the definition of this trigger function, a trigger named `trg_update_election_status` is created. This trigger is configured to execute `AFTER INSERT` operations on the `votes` table. It is a `FOR EACH ROW` trigger, meaning that the `update_election_status_on_vote` function will be invoked once for every row that is inserted into the `votes` table. The trigger explicitly calls the `update_election_status_on_vote()` function to perform its defined logic.",
    "plsql": "CREATE OR REPLACE FUNCTION update_election_status_on_vote() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE elections SET election_status = 'Completed' WHERE election_id IN (SELECT office_id FROM candidates WHERE candidate_id = NEW.candidate_id);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_election_status\nAFTER INSERT ON votes\nFOR EACH ROW EXECUTE FUNCTION update_election_status_on_vote();",
    "database_name": "electoral_voting_and_candidate_tracking",
    "tables": [
      "candidates",
      "elections",
      "offices",
      "parties",
      "votes"
    ],
    "call_sqls": [
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1000, 0, 5, 150, 'In-person', '2024-11-05 08:00:00', 'B1000');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1001, 1, 5, 200, 'Mail-in', '2024-11-04 12:00:00', 'M1001');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1002, 0, 6, 75, 'In-person', '2024-11-05 10:30:00', 'B1002');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1003, 1, 6, 90, 'Mail-in', '2024-11-03 09:15:00', 'M1003');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1004, 0, 7, 300, 'In-person', '2024-11-05 16:45:00', 'B1004');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1005, 1, 7, 275, 'Mail-in', '2024-11-02 14:20:00', 'M1005');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1006, 0, 8, 50, 'In-person', '2024-11-05 11:00:00', 'B1006');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1007, 1, 8, 60, 'Mail-in', '2024-11-01 10:00:00', 'M1007');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1008, 0, 9, 120, 'In-person', '2024-11-05 13:30:00', 'B1008');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1009, 1, 9, 180, 'Mail-in', '2024-10-31 16:00:00', 'M1009');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1010, 0, 10, 95, 'In-person', '2024-11-05 09:45:00', 'B1010');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1011, 1, 10, 110, 'Mail-in', '2024-10-30 11:30:00', 'M1011');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1012, 0, 11, 220, 'In-person', '2024-11-05 15:15:00', 'B1012');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1013, 1, 11, 210, 'Mail-in', '2024-10-29 13:45:00', 'M1013');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1014, 0, 12, 40, 'In-person', '2024-11-05 07:30:00', 'B1014');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1015, 1, 12, 55, 'Mail-in', '2024-10-28 15:00:00', 'M1015');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1016, 0, 13, 180, 'In-person', '2024-11-05 12:00:00', 'B1016');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1017, 1, 13, 190, 'Mail-in', '2024-10-27 10:15:00', 'M1017');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1018, 0, 14, 70, 'In-person', '2024-11-05 14:20:00', 'B1018');",
      "INSERT INTO votes (vote_id, candidate_id, precinct_id, votes, vote_type, vote_time, ballot_id) VALUES (1019, 1, 14, 85, 'Mail-in', '2024-10-26 12:30:00', 'M1019');"
    ],
    "id": 99
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_team_machine_count that accepts a single input parameter named team_name of type VARCHAR2 and returns a NUMBER, which begins by declaring a local variable v_count of type NUMBER, then executes a SELECT statement to query the MACHINE table, counting all rows where the value in the TEAM column is equal to the provided team_name parameter and storing the result into the v_count variable, then evaluates a conditional IF statement to check if the value of v_count is greater than 5, and if this condition is true, the function returns the result of multiplying v_count by 2, but if the condition is false, the function returns the value of v_count directly.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_machine_count(team_name VARCHAR2) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM MACHINE WHERE TEAM = team_name;\n  IF v_count > 5 THEN\n    RETURN v_count * 2;\n  ELSE\n    RETURN v_count;\n  END IF;\nEND;",
    "database_name": "machine_repair",
    "tables": [
      "MACHINE",
      "REPAIR_ASSIGNMENT",
      "TECHNICIAN"
    ],
    "call_sqls": [
      "SELECT get_team_machine_count('Hero Sports TS- Honda') FROM dual",
      "SELECT get_team_machine_count('Marlboro Pileri - Honda') FROM dual",
      "SELECT get_team_machine_count('NYY') FROM dual",
      "SELECT get_team_machine_count('CLE') FROM dual",
      "SELECT get_team_machine_count('Team Alpha') FROM dual",
      "SELECT get_team_machine_count('Team Beta') FROM dual",
      "SELECT get_team_machine_count('Team Gamma') FROM dual",
      "SELECT get_team_machine_count('Team Delta') FROM dual",
      "SELECT get_team_machine_count('Team Epsilon') FROM dual",
      "SELECT get_team_machine_count('Team Zeta') FROM dual",
      "SELECT get_team_machine_count('Team Eta') FROM dual",
      "SELECT get_team_machine_count('Team Theta') FROM dual",
      "SELECT get_team_machine_count('Team Iota') FROM dual",
      "SELECT get_team_machine_count('Team Kappa') FROM dual",
      "SELECT get_team_machine_count('Team Lambda') FROM dual",
      "SELECT get_team_machine_count('Team Mu') FROM dual",
      "SELECT get_team_machine_count('Team Nu') FROM dual",
      "SELECT get_team_machine_count('Team Xi') FROM dual",
      "SELECT get_team_machine_count('Team Omicron') FROM dual",
      "SELECT get_team_machine_count('Team Pi') FROM dual",
      "SELECT get_team_machine_count('Team Rho') FROM dual"
    ],
    "id": 100
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_customer_email_by_order_id that accepts two input parameters: a bigint parameter named p_order_id and a text parameter named p_default_email, and returns a single text value; the function declares a local text variable v_email, then executes a SELECT INTO statement that assigns the value of the input parameter p_default_email directly to the local variable v_email, bypassing any database table queries due to an explicit comment stating there is no direct relationship between Customers and Invoices in the schema, returns the value stored in v_email, and includes an EXCEPTION handler block that catches any exception of type OTHERS and, in such an event, returns the value of the input parameter p_default_email.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_email_by_order_id(p_order_id bigint, p_default_email text)\nRETURNS text AS $$\nDECLARE\n    v_email text;\nBEGIN\n    -- Since there's no direct relationship between Customers and Invoices in the schema,\n    -- we'll return the default email\n    SELECT p_default_email INTO v_email;\n    RETURN v_email;\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN p_default_email;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Drama_Workshop_Groups",
    "tables": [
      "Customers",
      "Invoices",
      "Order_Items",
      "Products",
      "Ref_Payment_Methods"
    ],
    "call_sqls": [
      "SELECT get_customer_email_by_order_id(1, 'default@example.com');",
      "SELECT get_customer_email_by_order_id(2, 'backup@example.com');",
      "SELECT get_customer_email_by_order_id(3, 'admin@company.com');",
      "SELECT get_customer_email_by_order_id(4, 'no-reply@domain.com');",
      "SELECT get_customer_email_by_order_id(5, 'support@example.org');",
      "SELECT get_customer_email_by_order_id(6, 'info@test.com');",
      "SELECT get_customer_email_by_order_id(7, 'contact@business.com');",
      "SELECT get_customer_email_by_order_id(8, 'user@mail.net');",
      "SELECT get_customer_email_by_order_id(9, 'customer@service.com');",
      "SELECT get_customer_email_by_order_id(10, 'fallback@email.com');",
      "SELECT get_customer_email_by_order_id(11, 'placeholder@temp.com');",
      "SELECT get_customer_email_by_order_id(12, 'dummy@test.org');",
      "SELECT get_customer_email_by_order_id(13, 'unknown@email.com');",
      "SELECT get_customer_email_by_order_id(14, 'generic@mail.com');",
      "SELECT get_customer_email_by_order_id(15, 'standard@domain.org');",
      "SELECT get_customer_email_by_order_id(16, 'alternative@backup.com');",
      "SELECT get_customer_email_by_order_id(17, 'reserve@email.net');",
      "SELECT get_customer_email_by_order_id(18, 'secondary@mail.org');",
      "SELECT get_customer_email_by_order_id(19, 'emergency@contact.com');",
      "SELECT get_customer_email_by_order_id(20, 'lastresort@example.net');"
    ],
    "id": 101
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_total_expenditure_by_region` that accepts a single input parameter named `year_input` of type `bigint`. The purpose of this function is to compute and return the sum of all expenditures recorded for a specific year. Upon execution, the function declares a local variable named `total_expenditure` of type `real` to temporarily store the calculated sum. The core operation involves a `SELECT` statement that queries the `expenditure_data` table. This `SELECT` statement calculates the `SUM` of the values in the `expenditure` column. The aggregation is performed only for those rows where the value in the `year_id` column matches the value provided in the `year_input` parameter. The result of this summation is then assigned to the `total_expenditure` local variable. Finally, the function returns the value stored in the `total_expenditure` variable, which represents the total expenditure for the specified year, as a `real` data type.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_expenditure_by_region(year_input bigint) RETURNS real LANGUAGE plpgsql AS $$\nDECLARE\n    total_expenditure real;\nBEGIN\n    SELECT SUM(expenditure) INTO total_expenditure\n    FROM expenditure_data\n    WHERE year_id = year_input;\n    \n    RETURN total_expenditure;\nEND;\n$$;",
    "database_name": "consumer_expenditure_patterns_over_time",
    "tables": [
      "expenditure_data",
      "regions"
    ],
    "call_sqls": [
      "SELECT calculate_total_expenditure_by_region(2023);",
      "SELECT calculate_total_expenditure_by_region(2022);",
      "SELECT calculate_total_expenditure_by_region(2021);",
      "SELECT calculate_total_expenditure_by_region(2020);",
      "SELECT calculate_total_expenditure_by_region(2019);",
      "SELECT calculate_total_expenditure_by_region(2018);",
      "SELECT calculate_total_expenditure_by_region(2017);",
      "SELECT calculate_total_expenditure_by_region(2016);",
      "SELECT calculate_total_expenditure_by_region(2015);",
      "SELECT calculate_total_expenditure_by_region(2014);",
      "SELECT calculate_total_expenditure_by_region(2013);",
      "SELECT calculate_total_expenditure_by_region(2012);",
      "SELECT calculate_total_expenditure_by_region(2011);",
      "SELECT calculate_total_expenditure_by_region(2010);",
      "SELECT calculate_total_expenditure_by_region(2009);",
      "SELECT calculate_total_expenditure_by_region(2008);",
      "SELECT calculate_total_expenditure_by_region(2007);",
      "SELECT calculate_total_expenditure_by_region(2006);",
      "SELECT calculate_total_expenditure_by_region(2005);",
      "SELECT calculate_total_expenditure_by_region(2004);"
    ],
    "id": 102
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_stimuli_by_condition` that is designed to retrieve specific data from a database table. This function accepts a single input parameter named `para_condition_id`, which is of the `bigint` data type. The purpose of `para_condition_id` is to specify the unique identifier of a condition for which associated stimuli are to be retrieved. The function is declared to return a `TABLE` composed of two columns: `stimulus_name` of type `text` and `stimulus_duration` of type `bigint`. The core operation of this function involves executing a `SELECT` query. This query targets the `stimuli` table, aliased as `s`. From the `stimuli` table, it selects two specific columns: `s.stimulus_name` and `s.stimulus_duration`. The selection of rows from the `stimuli` table is filtered by a `WHERE` clause. This `WHERE` clause applies a condition that `s.condition_id` must be equal to the value provided by the input parameter `para_condition_id`. The `RETURN QUERY` statement is used to return the entire result set of this `SELECT` query as the output of the function, conforming to the defined `TABLE` structure.",
    "plsql": "CREATE OR REPLACE FUNCTION get_stimuli_by_condition(para_condition_id bigint) RETURNS TABLE(stimulus_name text, stimulus_duration bigint) LANGUAGE plpgsql AS $$\nBEGIN\n  RETURN QUERY SELECT s.stimulus_name, s.stimulus_duration\n  FROM stimuli s\n  WHERE s.condition_id = para_condition_id;\nEND;\n$$;",
    "database_name": "cognitive_psychology_and_behavioral_experimentation",
    "tables": [
      "experiments",
      "conditions",
      "stimuli",
      "participants",
      "sessions",
      "responses",
      "reaction_times"
    ],
    "call_sqls": [
      "SELECT * FROM get_stimuli_by_condition(0);",
      "SELECT * FROM get_stimuli_by_condition(1);",
      "SELECT * FROM get_stimuli_by_condition(2);",
      "SELECT * FROM get_stimuli_by_condition(3);",
      "SELECT * FROM get_stimuli_by_condition(4);",
      "SELECT * FROM get_stimuli_by_condition(5);",
      "SELECT * FROM get_stimuli_by_condition(6);",
      "SELECT * FROM get_stimuli_by_condition(7);",
      "SELECT * FROM get_stimuli_by_condition(8);",
      "SELECT * FROM get_stimuli_by_condition(9);",
      "SELECT * FROM get_stimuli_by_condition(10);",
      "SELECT * FROM get_stimuli_by_condition(11);",
      "SELECT * FROM get_stimuli_by_condition(12);",
      "SELECT * FROM get_stimuli_by_condition(13);",
      "SELECT * FROM get_stimuli_by_condition(14);",
      "SELECT * FROM get_stimuli_by_condition(15);",
      "SELECT * FROM get_stimuli_by_condition(16);",
      "SELECT * FROM get_stimuli_by_condition(17);",
      "SELECT * FROM get_stimuli_by_condition(18);",
      "SELECT * FROM get_stimuli_by_condition(19);",
      "SELECT * FROM get_stimuli_by_condition(20);"
    ],
    "id": 103
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `insert_brand_vehicle` that is designed to be executed after an `INSERT` operation on the `brands` table, for each row that is inserted. This function does not accept any explicit parameters but operates on the `NEW` record, which represents the newly inserted row in the `brands` table. The function's primary purpose is to insert a new record into the `vehicles` table. The `vehicle_id` column for this new record is determined by first attempting to retrieve the maximum `vehicle_id` from the `vehicles` table. If a maximum `vehicle_id` exists, it is incremented by 1; otherwise, if the `vehicles` table is empty and `MAX(vehicle_id)` returns `NULL`, the `vehicle_id` is set to `0`. The `brand_id` column of the new `vehicles` record is populated with the value from the `brand_id` column of the `NEW` record (the newly inserted row in the `brands` table). The `model` column is set to the static string literal 'New Model'. The `year` column is set to the static integer value `2023`. The `origin_id` column is set to the static integer value `0`. The `last_updated` column is populated with the value from the `last_updated` column of the `NEW` record (the newly inserted row in the `brands` table). After performing this insertion into the `vehicles` table, the function returns the `NEW` record, which is the newly inserted row in the `brands` table, allowing the original `INSERT` operation on the `brands` table to complete. This trigger function is then associated with a trigger named `brand_vehicle_insert_trigger`. This trigger is configured to activate `AFTER INSERT` operations on the `brands` table. It is set to execute `FOR EACH ROW`, meaning the `insert_brand_vehicle` function will be invoked once for every row successfully inserted into the `brands` table. The trigger executes the `insert_brand_vehicle()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_brand_vehicle() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO vehicles (vehicle_id, brand_id, model, year, origin_id, last_updated) VALUES (\n    COALESCE((SELECT MAX(vehicle_id) FROM vehicles) + 1, 0),\n    NEW.brand_id,\n    'New Model',\n    2023,\n    0,\n    NEW.last_updated\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER brand_vehicle_insert_trigger\nAFTER INSERT ON brands\nFOR EACH ROW EXECUTE FUNCTION insert_brand_vehicle();",
    "database_name": "automotive_data_analysis_and_management",
    "tables": [
      "vehicles",
      "brands",
      "origins",
      "performance_metrics"
    ],
    "call_sqls": [
      "INSERT INTO brands (brand_id, brand_name, brand_description, founded_year, headquarters_location, parent_company, website, contact_email, last_updated) VALUES (100, 'NewBrandX', 'A new innovative brand', 2020, 'Silicon Valley, USA', 'TechCorp', 'https://www.newbrandx.com', 'contact@newbrandx.com', '2024-01-15');",
      "INSERT INTO brands (brand_id, brand_name, last_updated) VALUES (101, 'QuickBrand', '2024-01-15');",
      "INSERT INTO brands (brand_id, brand_name, brand_description, last_updated) VALUES (102, 'Alpha Motors', 'Focus on electric vehicles', '2024-01-16');",
      "INSERT INTO brands (brand_id, brand_name, founded_year, last_updated) VALUES (103, 'Beta Autos', 1995, '2024-01-16');",
      "INSERT INTO brands (brand_id, brand_name, headquarters_location, last_updated) VALUES (104, 'Gamma Cars', 'Tokyo, Japan', '2024-01-17');",
      "INSERT INTO brands (brand_id, brand_name, parent_company, last_updated) VALUES (105, 'Delta Trucks', 'Heavy Industries Inc.', '2024-01-17');",
      "INSERT INTO brands (brand_id, brand_name, website, last_updated) VALUES (106, 'Epsilon EVs', 'https://www.epsilonev.com', '2024-01-18');",
      "INSERT INTO brands (brand_id, brand_name, contact_email, last_updated) VALUES (107, 'Zeta Motors', 'sales@zetamotors.com', '2024-01-18');",
      "INSERT INTO brands (brand_id, brand_name, brand_description, founded_year, last_updated) VALUES (108, 'Eta Classic', 'Restoring vintage cars', 1980, '2024-01-19');",
      "INSERT INTO brands (brand_id, brand_name, headquarters_location, parent_company, last_updated) VALUES (109, 'Theta Racing', 'Monaco', 'Speed Group', '2024-01-19');",
      "INSERT INTO brands (brand_id, brand_name, website, contact_email, last_updated) VALUES (110, 'Iota Commercial', 'https://www.iotavehicles.com', 'info@iotavehicles.com', '2024-01-20');",
      "INSERT INTO brands (brand_id, brand_name, last_updated) VALUES (111, 'Kappa Bikes', '2024-01-20');",
      "INSERT INTO brands (brand_id, brand_name, brand_description, founded_year, headquarters_location, last_updated) VALUES (112, 'Lambda Luxury', 'High-end luxury vehicles', 2010, 'Milan, Italy', '2024-01-21');",
      "INSERT INTO brands (brand_id, brand_name, parent_company, website, last_updated) VALUES (113, 'Mu Offroad', 'Adventure Corp', 'https://www.muoffroad.com', '2024-01-21');",
      "INSERT INTO brands (brand_id, brand_name, contact_email, last_updated) VALUES (114, 'Nu Electric', 'support@nuelectric.com', '2024-01-22');",
      "INSERT INTO brands (brand_id, brand_name, founded_year, headquarters_location, parent_company, last_updated) VALUES (115, 'Xi Motors', 1975, 'Seoul, South Korea', 'Global Auto', '2024-01-22');",
      "INSERT INTO brands (brand_id, brand_name, brand_description, website, last_updated) VALUES (116, 'Omicron Vans', 'Commercial and passenger vans', 'https://www.omicronvans.com', '2024-01-23');",
      "INSERT INTO brands (brand_id, brand_name, last_updated) VALUES (117, 'Pi Autos', '2024-01-23');",
      "INSERT INTO brands (brand_id, brand_name, headquarters_location, contact_email, last_updated) VALUES (118, 'Rho Motors', 'Shanghai, China', 'china@rhomotors.com', '2024-01-24');",
      "INSERT INTO brands (brand_id, brand_name, brand_description, founded_year, website, last_updated) VALUES (119, 'Sigma Fleet', 'Vehicle solutions for businesses', 2005, 'https://www.sigmafleet.com', '2024-01-24');"
    ],
    "id": 104
  },
  {
    "ir": "Write an Oracle PL/SQL function named avg_response_time_success that calculates and returns the average response time from the api_access_logs table, specifically for entries where the status_code column equals 200. The function does not take any input parameters and returns a value of type NUMBER. Inside the function, a local variable v_avg_time of type NUMBER is declared to store the result of the calculation. The function executes a SQL SELECT statement that computes the average of the response_time column from the api_access_logs table, filtering the rows to include only those where the status_code is exactly 200. The result of this average calculation is stored into the v_avg_time variable using the INTO clause. Finally, the function returns the value stored in v_avg_time, which represents the average response time for successful API access logs, as indicated by a status code of 200.",
    "plsql": "CREATE OR REPLACE FUNCTION avg_response_time_success RETURN NUMBER IS v_avg_time NUMBER; BEGIN SELECT AVG(response_time) INTO v_avg_time FROM api_access_logs WHERE status_code = 200; RETURN v_avg_time; END;",
    "database_name": "api_umat_generation",
    "tables": [
      "api_access_logs",
      "api_errors",
      "api_versions"
    ],
    "call_sqls": [
      "SELECT avg_response_time_success FROM DUAL",
      "SELECT avg_response_time_success() FROM DUAL",
      "SELECT avg_response_time_success FROM DUAL WHERE 1=1",
      "SELECT avg_response_time_success() FROM DUAL WHERE ROWNUM = 1",
      "SELECT avg_response_time_success FROM DUAL ORDER BY 1",
      "SELECT avg_response_time_success FROM DUAL FETCH FIRST 1 ROWS ONLY",
      "SELECT avg_response_time_success FROM DUAL CONNECT BY LEVEL <= 1",
      "SELECT avg_response_time_success FROM DUAL GROUP BY ()",
      "SELECT avg_response_time_success FROM DUAL HAVING 1=1",
      "SELECT avg_response_time_success FROM DUAL UNION SELECT NULL FROM DUAL",
      "SELECT avg_response_time_success FROM DUAL MINUS SELECT NULL FROM DUAL",
      "SELECT avg_response_time_success FROM DUAL INTERSECT SELECT 0 FROM DUAL",
      "SELECT avg_response_time_success FROM (SELECT 1 FROM DUAL)",
      "SELECT avg_response_time_success FROM (SELECT * FROM DUAL)",
      "SELECT avg_response_time_success FROM DUAL, (SELECT 1 FROM DUAL)",
      "SELECT avg_response_time_success FROM DUAL CROSS JOIN (SELECT 1 FROM DUAL)",
      "SELECT avg_response_time_success FROM DUAL LEFT JOIN (SELECT 1 FROM DUAL) ON 1=1",
      "SELECT avg_response_time_success FROM DUAL RIGHT JOIN (SELECT 1 FROM DUAL) ON 1=1",
      "SELECT avg_response_time_success FROM DUAL FULL JOIN (SELECT 1 FROM DUAL) ON 1=1",
      "SELECT avg_response_time_success FROM DUAL NATURAL JOIN (SELECT 1 FROM DUAL)"
    ],
    "id": 105
  },
  {
    "ir": "Write a PLpgSQL stored procedure named sp_insert_net_value that accepts three parameters: para_country_code of type text, para_industry_id of type bigint, and para_year of type bigint. This procedure performs an insertion operation into the net_values table, which consists of seven columns: country_code, industry_id, year, net_value, source, confidence_level, and last_updated. The procedure inserts a new row into this table using the values provided by the parameters para_country_code, para_industry_id, and para_year for the respective columns country_code, industry_id, and year. The net_value column is set to a default value of 0.0, indicating an initial or placeholder net value. The source column is assigned the string 'Unknown', suggesting that the origin of the data is unspecified or not yet determined. The confidence_level column is set to 'low', implying a low degree of certainty or reliability regarding the data. The last_updated column is populated with the current date and time, formatted as a text string, using the justify_days function applied to an interval of '0 days', which effectively represents the current timestamp. This procedure does not include any conditional logic or iterations, and it directly executes the insertion operation with the specified values.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_insert_net_value(para_country_code text, para_industry_id bigint, para_year bigint) LANGUAGE plpgsql AS $$ BEGIN INSERT INTO net_values (country_code, industry_id, year, net_value, source, confidence_level, last_updated) VALUES (para_country_code, para_industry_id, para_year, 0.0, 'Unknown', 'low', justify_days(interval '0 days')::text); END; $$;",
    "database_name": "country_economic_and_industrial_data_analysis",
    "tables": [
      "country_industries",
      "country_industry_indicators",
      "economic_indicators",
      "industry_sector_indicators",
      "net_values",
      "sector_indicators"
    ],
    "call_sqls": [
      "CALL sp_insert_net_value('US', 1, 2023);",
      "CALL sp_insert_net_value('GB', 2, 2022);",
      "CALL sp_insert_net_value('DE', 3, 2024);",
      "CALL sp_insert_net_value('FR', 4, 2021);",
      "CALL sp_insert_net_value('JP', 5, 2023);",
      "CALL sp_insert_net_value('CN', 6, 2022);",
      "CALL sp_insert_net_value('IN', 7, 2024);",
      "CALL sp_insert_net_value('BR', 8, 2023);",
      "CALL sp_insert_net_value('CA', 9, 2022);",
      "CALL sp_insert_net_value('AU', 10, 2021);",
      "CALL sp_insert_net_value('IT', 11, 2024);",
      "CALL sp_insert_net_value('ES', 12, 2023);",
      "CALL sp_insert_net_value('KR', 13, 2022);",
      "CALL sp_insert_net_value('MX', 14, 2024);",
      "CALL sp_insert_net_value('NL', 15, 2023);",
      "CALL sp_insert_net_value('CH', 16, 2022);",
      "CALL sp_insert_net_value('SE', 17, 2021);",
      "CALL sp_insert_net_value('SG', 18, 2024);",
      "CALL sp_insert_net_value('ZA', 19, 2023);",
      "CALL sp_insert_net_value('AE', 20, 2022);"
    ],
    "id": 106
  },
  {
    "ir": "Write a PLpgSQL function that accepts two parameters: p_participant_id of type BIGINT and p_group_id of type TEXT. The function is designed to update the group_id column in the participants table for a specific participant. It begins by checking if there exists a row in the participants table where the participant_id column matches the value of the p_participant_id parameter. This is done using a SELECT statement with a condition that searches for the participant_id equal to p_participant_id. If such a row exists, the function proceeds to update the group_id column of that row, setting it to the value provided in the p_group_id parameter. The update operation is performed using an UPDATE statement that targets the participants table, specifically modifying the group_id column for the row where participant_id matches p_participant_id. If no matching row is found, the function does not perform any update operation. The function is defined using the PLpgSQL language and does not return any value, as indicated by the RETURNS VOID clause.",
    "plsql": "CREATE OR REPLACE FUNCTION update_participant_group(p_participant_id BIGINT, p_group_id TEXT) RETURNS VOID AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM participants WHERE participant_id = p_participant_id) THEN\n    UPDATE participants SET group_id = p_group_id WHERE participant_id = p_participant_id;\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "psychological_research_and_analysis_of_cognitive_abilities",
    "tables": [
      "groups",
      "participant_study",
      "participants",
      "studies",
      "users"
    ],
    "call_sqls": [
      "SELECT update_participant_group(0, '1');",
      "SELECT update_participant_group(1, '0');",
      "SELECT update_participant_group(2, '1');",
      "SELECT update_participant_group(3, '0');",
      "SELECT update_participant_group(4, '1');",
      "SELECT update_participant_group(5, '0');",
      "SELECT update_participant_group(6, '1');",
      "SELECT update_participant_group(7, '0');",
      "SELECT update_participant_group(8, '1');",
      "SELECT update_participant_group(9, '0');",
      "SELECT update_participant_group(10, '1');",
      "SELECT update_participant_group(11, '0');",
      "SELECT update_participant_group(12, '1');",
      "SELECT update_participant_group(13, '0');",
      "SELECT update_participant_group(14, '1');",
      "SELECT update_participant_group(15, '0');",
      "SELECT update_participant_group(16, '1');",
      "SELECT update_participant_group(17, '0');",
      "SELECT update_participant_group(18, '1');",
      "SELECT update_participant_group(19, '0');",
      "SELECT update_participant_group(20, '1');"
    ],
    "id": 107
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_event_participant_scores` that is designed to return a set of records, effectively acting as a table-valued function. This function takes no input parameters. The function's return type is a table structure defined by three columns: `ep_id` of type `bigint`, `participant_name` of type `text`, and `total_score` of type `real`. The core operation of this function is to execute a `SELECT` query and return its results. The `SELECT` statement retrieves data from three tables: `event_participants` (aliased as `ep`), `participants` (aliased as `p`), and `scores` (aliased as `s`). The selection criteria involve joining these tables. Specifically, the `event_participants` table (`ep`) is joined with the `participants` table (`p`) using an `INNER JOIN` condition where the `participant_id` column from `ep` matches the `participant_id` column from `p`. Subsequently, the result of this join is further joined with the `scores` table (`s`) using another `INNER JOIN` condition where the `ep_id` column from `ep` matches the `ep_id` column from `s`. From the joined dataset, the query selects the `ep_id` column from the `event_participants` table (`ep`), the `name` column from the `participants` table (`p`), and the `total_score` column from the `scores` table (`s`). A crucial filtering condition is applied using a `WHERE` clause: `s.total_score = (SELECT MAX(s2.total_score) FROM scores s2 WHERE s2.ep_id = s.ep_id)`. This condition ensures that only those records from the `scores` table (`s`) are included where the `total_score` for a given `ep_id` is equal to the maximum `total_score` found for that specific `ep_id` within the `scores` table. This subquery, `(SELECT MAX(s2.total_score) FROM scores s2 WHERE s2.ep_id = s.ep_id)`, independently queries the `scores` table (aliased as `s2`) to find the highest `total_score` for each distinct `ep_id`. The outer query then uses this maximum value to filter the main result set, effectively returning only the highest score for each event participant. The `RETURN QUERY` statement then outputs the entire result set generated by this `SELECT` statement.",
    "plsql": "CREATE OR REPLACE FUNCTION get_event_participant_scores()\nRETURNS TABLE(ep_id bigint, participant_name text, total_score real) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT ep.ep_id, p.name, s.total_score\n    FROM event_participants ep\n    JOIN participants p ON ep.participant_id = p.participant_id\n    JOIN scores s ON ep.ep_id = s.ep_id\n    WHERE s.total_score = (SELECT MAX(s2.total_score) FROM scores s2 WHERE s2.ep_id = s.ep_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "sports_competition_scoring_system",
    "tables": [
      "event_participants",
      "events",
      "participants",
      "scores"
    ],
    "call_sqls": [
      "SELECT * FROM get_event_participant_scores();",
      "SELECT * FROM get_event_participant_scores() WHERE total_score > 10.0;",
      "SELECT * FROM get_event_participant_scores() ORDER BY total_score DESC;",
      "SELECT * FROM get_event_participant_scores() WHERE participant_name LIKE 'A%';",
      "SELECT * FROM get_event_participant_scores() WHERE total_score BETWEEN 8.0 AND 12.0;",
      "SELECT participant_name, total_score FROM get_event_participant_scores();",
      "SELECT ep_id, participant_name FROM get_event_participant_scores();",
      "SELECT COUNT(*) FROM get_event_participant_scores();",
      "SELECT AVG(total_score) FROM get_event_participant_scores();",
      "SELECT MAX(total_score) FROM get_event_participant_scores();",
      "SELECT MIN(total_score) FROM get_event_participant_scores();",
      "SELECT * FROM get_event_participant_scores() LIMIT 5;",
      "SELECT * FROM get_event_participant_scores() OFFSET 10;",
      "SELECT DISTINCT participant_name FROM get_event_participant_scores();",
      "SELECT * FROM get_event_participant_scores() WHERE ep_id = 1;",
      "SELECT * FROM get_event_participant_scores() WHERE ep_id IN (1, 2, 3);",
      "SELECT * FROM get_event_participant_scores() WHERE participant_name = 'Matilda Bowron';",
      "SELECT * FROM get_event_participant_scores() WHERE total_score >= 15.0;",
      "SELECT * FROM get_event_participant_scores() ORDER BY participant_name;",
      "SELECT ep_id, total_score FROM get_event_participant_scores() ORDER BY ep_id;",
      "SELECT * FROM get_event_participant_scores() WHERE total_score < 5.0;"
    ],
    "id": 108
  },
  {
    "ir": "Write a PostgreSQL trigger function named check_enrollment_capacity that is executed automatically by a trigger named trg_check_enrollment_capacity after every insert operation on the students table for each new row, which first declares a local variable next_id of type bigint, then checks if the newly inserted student_id value from the NEW pseudo-row is not null, and if this condition is true, performs a SELECT query on the student_terms table to calculate the next sequential student_term_id by using the COALESCE function to return 0 if the maximum existing student_term_id is null and then adding 1 to this maximum value, assigning the result into the next_id variable, and subsequently performs an INSERT operation into the student_terms table, populating the student_term_id column with the calculated next_id value, the student_id column with the NEW.student_id value from the triggering insert on students, the term_id column with a hard-coded integer value of 1, and the status column with a hard-coded string value of 'Pending', and finally returns the NEW row record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION check_enrollment_capacity() RETURNS TRIGGER AS $$\nDECLARE\n    next_id bigint;\nBEGIN\n    IF NEW.student_id IS NOT NULL THEN\n        SELECT COALESCE(MAX(student_term_id), 0) + 1 INTO next_id FROM student_terms;\n        INSERT INTO student_terms (student_term_id, student_id, term_id, status) \n        VALUES (next_id, NEW.student_id, 1, 'Pending');\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_enrollment_capacity\nAFTER INSERT ON students\nFOR EACH ROW\nEXECUTE FUNCTION check_enrollment_capacity();",
    "database_name": "student_course_performance_and_progress_tracking",
    "tables": [
      "grades",
      "student_courses",
      "student_terms",
      "students",
      "terms"
    ],
    "call_sqls": [
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (100, 'Alice Johnson', 'alice@example.com', '1998-03-22', 'Biology', 1, '555-1234', '789 Oak St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (101, 'Bob Williams', 'bob@example.com', '1999-07-14', 'Chemistry', 1, '555-5678', '321 Pine St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (102, 'Charlie Brown', 'charlie@example.com', '1997-11-30', 'Physics', 2, '555-9012', '654 Maple St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (103, 'Diana Prince', 'diana@example.com', '1996-05-18', 'Engineering', 3, '555-3456', '987 Cedar St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (104, 'Edward Norton', 'edward@example.com', '1998-12-05', 'Mathematics', 1, '555-7890', '147 Birch St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (105, 'Fiona Gallagher', 'fiona@example.com', '1999-02-28', 'Computer Science', 2, '555-2345', '258 Walnut St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (106, 'George Miller', 'george@example.com', '1997-08-12', 'History', 3, '555-6789', '369 Spruce St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (107, 'Hannah Lee', 'hannah@example.com', '1996-01-25', 'Economics', 4, '555-0123', '741 Ash St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (108, 'Ian Smith', 'ian@example.com', '1998-09-09', 'Psychology', 2, '555-4567', '852 Poplar St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (109, 'Julia Roberts', 'julia@example.com', '1999-04-17', 'Sociology', 1, '555-8901', '963 Fir St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (110, 'Kevin Hart', 'kevin@example.com', '1997-06-21', 'Business', 3, '555-2345', '159 Redwood St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (111, 'Lisa Simpson', 'lisa@example.com', '1998-10-11', 'Music', 2, '555-6789', '357 Sequoia St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (112, 'Michael Jordan', 'michael@example.com', '1996-03-03', 'Sports Science', 4, '555-0123', '456 Willow St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (113, 'Nancy Drew', 'nancy@example.com', '1999-07-07', 'Criminal Justice', 1, '555-4567', '753 Sycamore St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (114, 'Oliver Twist', 'oliver@example.com', '1997-12-15', 'English Literature', 2, '555-8901', '951 Magnolia St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (115, 'Peter Parker', 'peter@example.com', '1998-05-19', 'Photography', 3, '555-2345', '357 Dogwood St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (116, 'Quincy Jones', 'quincy@example.com', '1996-09-23', 'Music Production', 4, '555-6789', '159 Hickory St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (117, 'Rachel Green', 'rachel@example.com', '1999-01-31', 'Fashion Design', 1, '555-0123', '753 Beech St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (118, 'Steve Rogers', 'steve@example.com', '1997-04-08', 'Political Science', 2, '555-4567', '951 Chestnut St', '2023-09-01');",
      "INSERT INTO students (student_id, student_name, email, date_of_birth, major, year_of_study, phone_number, address, enrollment_date) VALUES (119, 'Tina Fey', 'tina@example.com', '1998-08-26', 'Theater Arts', 3, '555-8901', '357 Cypress St', '2023-09-01');"
    ],
    "id": 109
  },
  {
    "ir": "Write a PL/pgSQL trigger function named `prevent_customer_order_deletion` that is designed to be executed before a `DELETE` operation on the `\"Customer_Orders\"` table. This function takes no explicit parameters but implicitly receives special `OLD` and `NEW` records from the trigger context. The `OLD` record represents the row that is about to be deleted from the `\"Customer_Orders\"` table. The function's primary purpose is to prevent the deletion of a customer order if any of its associated order items have a status of 'Delivered'. Inside the function, a conditional statement `IF EXISTS (...) THEN ... END IF;` is evaluated. The condition checks for the existence of at least one row in the `\"Order_Items\"` table. This check is performed by executing a `SELECT 1` statement. The `SELECT` statement filters rows from the `\"Order_Items\"` table based on two criteria: first, the `\"order_id\"` column in `\"Order_Items\"` must be equal to the `\"order_id\"` column from the `OLD` record (the customer order being considered for deletion); and second, the `\"order_item_status_code\"` column in `\"Order_Items\"` must be equal to the literal string value 'Delivered'. If this `SELECT` statement finds any matching rows, meaning there is at least one delivered item associated with the order being deleted, the function immediately returns `NULL`. A `NULL` return value from a `BEFORE DELETE` trigger function in PostgreSQL signifies that the `DELETE` operation should be aborted, effectively preventing the deletion of the `OLD` row. If the `SELECT` statement does not find any matching rows (i.e., no delivered items are associated with the order), the conditional statement's `THEN` block is skipped, and the function proceeds to the next statement, which is `RETURN OLD;`. Returning `OLD` from a `BEFORE DELETE` trigger function indicates that the `DELETE` operation should proceed as normal with the row represented by `OLD`.\n\nThis trigger function is then associated with a trigger named `trg_prevent_customer_order_deletion`. This trigger is configured to activate `BEFORE DELETE` operations on the `\"Customer_Orders\"` table. It is set to execute `FOR EACH ROW`, meaning the `prevent_customer_order_deletion()` function will be invoked once for every row that is targeted for deletion in a `DELETE` statement on the `\"Customer_Orders\"` table. The trigger explicitly executes the `prevent_customer_order_deletion()` function.",
    "plsql": "CREATE OR REPLACE FUNCTION prevent_customer_order_deletion() RETURNS TRIGGER AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM \"Order_Items\" WHERE \"order_id\" = OLD.\"order_id\" AND \"order_item_status_code\" = 'Delivered') THEN\n    RETURN NULL;\n  END IF;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_prevent_customer_order_deletion\nBEFORE DELETE ON \"Customer_Orders\"\nFOR EACH ROW EXECUTE FUNCTION prevent_customer_order_deletion();",
    "database_name": "customers_campaigns_ecommerce",
    "tables": [
      "Customer_Addresses",
      "Customer_Orders",
      "Customers",
      "Mailshot_Campaigns",
      "Mailshot_Customers",
      "Order_Items",
      "Premises",
      "Products"
    ],
    "call_sqls": [
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 2;",
      "DELETE FROM \"Customer_Orders\" WHERE customer_id = 2;",
      "DELETE FROM \"Customer_Orders\" WHERE order_status_code = 'Cancelled';",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 10;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 6;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 8;",
      "DELETE FROM \"Customer_Orders\" WHERE order_placed_datetime < '2010-01-01';",
      "DELETE FROM \"Customer_Orders\" WHERE shipping_method_code = 'Unspecified';",
      "DELETE FROM \"Customer_Orders\" WHERE order_id IN (1, 2, 3, 4, 5);",
      "DELETE FROM \"Customer_Orders\" WHERE order_id BETWEEN 1 AND 10;",
      "DELETE FROM \"Customer_Orders\" WHERE customer_id IN (SELECT customer_id FROM Customers WHERE customer_name = 'Wendell');",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = (SELECT MAX(order_id) FROM \"Customer_Orders\");",
      "DELETE FROM \"Customer_Orders\" WHERE order_shipping_charges::numeric > 50;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 15;",
      "DELETE FROM \"Customer_Orders\";"
    ],
    "id": 110
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_company_funding_details that returns a table with columns funding_round_type of type text, total_raised of type real, avg_valuation of type real, and investor_count of type bigint, accepting a single input parameter p_company_id of type bigint, which determines the scope of the analysis on the funding_rounds table; the function uses a conditional block where, if the p_company_id parameter is NULL, it returns a query that selects the funding_round_type column, calculates the sum of the raised_amount_usd column cast to real as total_raised, calculates the average of the post_money_valuation_usd column cast to real as avg_valuation, and counts the distinct investor_id values cast to bigint as investor_count from the funding_rounds table, filtering for rows where the funding_round_status column equals the string 'completed', grouping the results by the funding_round_type column, and ordering the final result set in descending order based on the sum of the raised_amount_usd column; if the p_company_id parameter is less than zero, it returns a query that selects the funding_round_type column, the raised_amount_usd column cast to real as total_raised, the post_money_valuation_usd column cast to real as avg_valuation, and the num_investors column cast to bigint as investor_count from the funding_rounds table, filtering for rows where the company_id column equals the negated value of the p_company_id parameter and the funding_round_status column equals 'completed', ordering the result set in descending order based on the funded_year column; otherwise, for any other positive or zero p_company_id value, it returns a query that selects the funding_round_type column, calculates the sum of the raised_amount_usd column cast to real as total_raised, calculates the average of the post_money_valuation_usd column cast to real as avg_valuation, and counts the distinct investor_id values cast to bigint as investor_count from the funding_rounds table, filtering for rows where the company_id column equals the p_company_id parameter and the funding_round_status column equals 'completed', grouping the results by the funding_round_type column, and ordering the final result set in descending order based on the sum of the raised_amount_usd column.",
    "plsql": "CREATE OR REPLACE FUNCTION get_company_funding_details(p_company_id bigint)\nRETURNS TABLE(funding_round_type text, total_raised real, avg_valuation real, investor_count bigint) AS $$\nBEGIN\n    IF p_company_id IS NULL THEN\n        RETURN QUERY\n        SELECT fr.funding_round_type,\n               SUM(fr.raised_amount_usd)::real,\n               AVG(fr.post_money_valuation_usd)::real,\n               COUNT(DISTINCT fr.investor_id)::bigint\n        FROM funding_rounds fr\n        WHERE fr.funding_round_status = 'completed'\n        GROUP BY fr.funding_round_type\n        ORDER BY SUM(fr.raised_amount_usd) DESC;\n    ELSIF p_company_id < 0 THEN\n        RETURN QUERY\n        SELECT fr.funding_round_type,\n               fr.raised_amount_usd::real,\n               fr.post_money_valuation_usd::real,\n               fr.num_investors::bigint\n        FROM funding_rounds fr\n        WHERE fr.company_id = -p_company_id\n          AND fr.funding_round_status = 'completed'\n        ORDER BY fr.funded_year DESC;\n    ELSE\n        RETURN QUERY\n        SELECT fr.funding_round_type,\n               SUM(fr.raised_amount_usd)::real,\n               AVG(fr.post_money_valuation_usd)::real,\n               COUNT(DISTINCT fr.investor_id)::bigint\n        FROM funding_rounds fr\n        WHERE fr.company_id = p_company_id\n          AND fr.funding_round_status = 'completed'\n        GROUP BY fr.funding_round_type\n        ORDER BY SUM(fr.raised_amount_usd) DESC;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "venture_capital_and_private_equity_funding",
    "tables": [
      "companies",
      "funding_rounds",
      "investors",
      "investor_investments"
    ],
    "call_sqls": [
      "SELECT * FROM get_company_funding_details(NULL);",
      "SELECT * FROM get_company_funding_details(1);",
      "SELECT * FROM get_company_funding_details(2);",
      "SELECT * FROM get_company_funding_details(5);",
      "SELECT * FROM get_company_funding_details(10);",
      "SELECT * FROM get_company_funding_details(15);",
      "SELECT * FROM get_company_funding_details(20);",
      "SELECT * FROM get_company_funding_details(25);",
      "SELECT * FROM get_company_funding_details(30);",
      "SELECT * FROM get_company_funding_details(50);",
      "SELECT * FROM get_company_funding_details(100);",
      "SELECT * FROM get_company_funding_details(200);",
      "SELECT * FROM get_company_funding_details(-1);",
      "SELECT * FROM get_company_funding_details(-5);",
      "SELECT * FROM get_company_funding_details(-10);",
      "SELECT * FROM get_company_funding_details(-15);",
      "SELECT * FROM get_company_funding_details(-20);",
      "SELECT * FROM get_company_funding_details(-25);",
      "SELECT * FROM get_company_funding_details(-30);",
      "SELECT * FROM get_company_funding_details(-50);"
    ],
    "id": 111
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `manage_policy_premiums` that accepts three input parameters: `para_coverage_id` of type `bigint`, `para_premium_increase` of type `real`, and `para_vehicle_year` of type `bigint`. This procedure first performs a `DELETE` operation on the `policies` table. The rows to be deleted are identified by two conditions: the `coverage_id` column in the `policies` table must exactly match the value provided in the `para_coverage_id` input parameter, AND the `policy_status` column in the `policies` table must have the exact string value 'Expired'. Following the deletion, the procedure executes an `UPDATE` operation on the `policies` table. For the rows targeted by this update, the value in the `monthly_premium_auto` column is increased by adding the value provided in the `para_premium_increase` input parameter to its current value. The specific rows to be updated are determined by a subquery. This subquery selects distinct `policy_id` values from the `policies` table, aliased as `p`. It joins the `policies` table (`p`) with the `vehicles` table, aliased as `v`, using an equality condition where `p.policy_id` matches `v.policy_id`. From this joined set, only those `policy_id` values are considered where the `year` column in the `vehicles` table (`v.year`) is strictly less than the value provided in the `para_vehicle_year` input parameter. The `policy_id` values returned by this subquery define the set of policies that will have their `monthly_premium_auto` updated.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_policy_premiums(para_coverage_id bigint, para_premium_increase real, para_vehicle_year bigint) LANGUAGE plpgsql AS $$ BEGIN DELETE FROM policies WHERE coverage_id = para_coverage_id AND policy_status = 'Expired'; UPDATE policies SET monthly_premium_auto = monthly_premium_auto + para_premium_increase WHERE policy_id IN (SELECT DISTINCT p.policy_id FROM policies p JOIN vehicles v ON p.policy_id = v.policy_id WHERE v.year < para_vehicle_year); END; $$;",
    "database_name": "automobile_insurance_customer_data",
    "tables": [
      "policies",
      "claims",
      "vehicles",
      "coverages"
    ],
    "call_sqls": [
      "CALL manage_policy_premiums(0, 25.50, 2015);",
      "CALL manage_policy_premiums(1, 15.00, 2010);",
      "CALL manage_policy_premiums(0, 10.75, 2020);",
      "CALL manage_policy_premiums(2, 30.00, 2018);",
      "CALL manage_policy_premiums(3, 12.50, 2012);",
      "CALL manage_policy_premiums(0, 18.90, 2008);",
      "CALL manage_policy_premiums(1, 22.00, 2016);",
      "CALL manage_policy_premiums(5, 40.00, 2022);",
      "CALL manage_policy_premiums(0, 9.99, 1995);",
      "CALL manage_policy_premiums(6, 27.30, 2019);",
      "CALL manage_policy_premiums(7, 11.00, 2011);",
      "CALL manage_policy_premiums(0, 33.75, 2007);",
      "CALL manage_policy_premiums(1, 19.50, 2014);",
      "CALL manage_policy_premiums(9, 45.00, 2023);",
      "CALL manage_policy_premiums(0, 8.25, 2001);",
      "CALL manage_policy_premiums(1, 16.80, 2017);"
    ],
    "id": 112
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_region_type that accepts a single input parameter, region_name_in, of type VARCHAR2, which represents the name of a region. The function is designed to return a value of type VARCHAR2, specifically the type of the region associated with the provided region name. Within the function, a local variable named region_type of type VARCHAR2 with a maximum length of 255 characters is declared to store the result of a database query. The function executes a SELECT statement to retrieve the region_type column from the regions table, aliased as r, where the region_name column matches the input parameter region_name_in. The result of this query is stored in the region_type variable. Finally, the function returns the value stored in region_type, effectively providing the type of the specified region as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_type(region_name_in VARCHAR2) RETURN VARCHAR2 IS\n  region_type VARCHAR2(255);\nBEGIN\n  SELECT r.region_type\n  INTO region_type\n  FROM regions r\n  WHERE r.region_name = region_name_in;\n  RETURN region_type;\nEND;",
    "database_name": "agricultural_pp_tracking",
    "tables": [
      "price_change_records",
      "price_records",
      "products",
      "regions",
      "units_of_measurement"
    ],
    "call_sqls": [
      "SELECT get_region_type('National Average') FROM dual",
      "SELECT get_region_type('New York') FROM dual",
      "SELECT get_region_type('California') FROM dual",
      "SELECT get_region_type('Texas') FROM dual",
      "SELECT get_region_type('Florida') FROM dual",
      "SELECT get_region_type('Illinois') FROM dual",
      "SELECT get_region_type('Pennsylvania') FROM dual",
      "SELECT get_region_type('Ohio') FROM dual",
      "SELECT get_region_type('Georgia') FROM dual",
      "SELECT get_region_type('North Carolina') FROM dual",
      "SELECT get_region_type('Michigan') FROM dual",
      "SELECT get_region_type('New Jersey') FROM dual",
      "SELECT get_region_type('Virginia') FROM dual",
      "SELECT get_region_type('Washington') FROM dual",
      "SELECT get_region_type('Arizona') FROM dual",
      "SELECT get_region_type('Massachusetts') FROM dual",
      "SELECT get_region_type('Tennessee') FROM dual",
      "SELECT get_region_type('Indiana') FROM dual",
      "SELECT get_region_type('Missouri') FROM dual",
      "SELECT get_region_type('Maryland') FROM dual"
    ],
    "id": 113
  },
  {
    "ir": "Write a PLpgSQL function that updates the address_validation table by setting the is_valid column to the value of the parameter p_is_valid, the validation_message column to the value of the parameter p_message, and the validation_date column to the current date for the row where the address_id column matches the value of the parameter p_address_id.",
    "plsql": "CREATE OR REPLACE FUNCTION update_address_validation(p_address_id BIGINT, p_is_valid BIGINT, p_message TEXT) \nRETURNS VOID AS $$\nBEGIN\nUPDATE address_validation \nSET is_valid = p_is_valid, validation_message = p_message, validation_date = CURRENT_DATE\nWHERE address_id = p_address_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_and_administrative_unit_management",
    "tables": [
      "addresses",
      "address_audits",
      "address_history",
      "address_validation",
      "address_languages",
      "users"
    ],
    "call_sqls": [
      "SELECT update_address_validation(0, 1, 'Address is valid');",
      "SELECT update_address_validation(1, 0, 'Address is not valid');",
      "SELECT update_address_validation(0, 0, 'Invalid postal code');",
      "SELECT update_address_validation(1, 1, 'Validation successful');",
      "SELECT update_address_validation(2, 1, 'Address verified');",
      "SELECT update_address_validation(3, 0, 'Missing street number');",
      "SELECT update_address_validation(4, 1, 'All fields are correct');",
      "SELECT update_address_validation(5, 0, 'Invalid administrative unit');",
      "SELECT update_address_validation(6, 1, 'Geocoding successful');",
      "SELECT update_address_validation(7, 0, 'Coordinates out of range');",
      "SELECT update_address_validation(8, 1, 'Address format is valid');",
      "SELECT update_address_validation(9, 0, 'Duplicate address found');",
      "SELECT update_address_validation(10, 1, 'Validation completed');",
      "SELECT update_address_validation(11, 0, 'Incomplete address data');",
      "SELECT update_address_validation(12, 1, 'Address exists in database');",
      "SELECT update_address_validation(13, 0, 'Invalid latitude/longitude');",
      "SELECT update_address_validation(14, 1, 'Postal code validated');",
      "SELECT update_address_validation(15, 0, 'Address marked as inactive');",
      "SELECT update_address_validation(16, 1, 'Manual validation approved');",
      "SELECT update_address_validation(17, 0, 'Failed automated validation');",
      "SELECT update_address_validation(18, 1, 'Address confirmed');"
    ],
    "id": 114
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_vehicle_features that accepts a single parameter, para_vehicle_type_id, of type NUMBER, which represents the identifier of a vehicle type. The function returns a VARCHAR2 value containing the concatenated features of the specified vehicle type. It performs a SELECT operation on the vehicle_types table, retrieving the standard_features and optional_features columns for the row where the vehicle_type_id matches the provided para_vehicle_type_id. The function uses the NVL function to handle potential NULL values in these columns, concatenating them with a separator ' | '. If both features are NULL, resulting in the string ' | ', the function returns the message 'No features found for given vehicle type'. If the concatenated string starts with ' | ', indicating that standard_features is NULL, the function removes the leading separator using the SUBSTR function and returns the remaining string. Similarly, if the concatenated string ends with ' | ', indicating that optional_features is NULL, the function removes the trailing separator using the SUBSTR function and returns the remaining string. If neither feature is NULL, the function returns the concatenated string as is. The function includes an exception handler for the NO_DATA_FOUND exception, which returns the message 'No features found for given vehicle type' if no matching row is found in the vehicle_types table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_vehicle_features(para_vehicle_type_id NUMBER) RETURN VARCHAR2 IS\n  v_features VARCHAR2(500);\nBEGIN\n  SELECT NVL(standard_features, '') || ' | ' || NVL(optional_features, '')\n  INTO v_features\n  FROM vehicle_types\n  WHERE vehicle_type_id = para_vehicle_type_id;\n  \n  -- Remove leading/trailing ' | ' if one of the features is null\n  IF v_features = ' | ' THEN\n    RETURN 'No features found for given vehicle type';\n  ELSIF SUBSTR(v_features, 1, 3) = ' | ' THEN\n    RETURN SUBSTR(v_features, 4);\n  ELSIF SUBSTR(v_features, LENGTH(v_features) - 2, 3) = ' | ' THEN\n    RETURN SUBSTR(v_features, 1, LENGTH(v_features) - 3);\n  ELSE\n    RETURN v_features;\n  END IF;\n\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN 'No features found for given vehicle type';\nEND;",
    "database_name": "automotive_sd_analysis",
    "tables": [
      "geographic_locations",
      "manufacturers",
      "sales_metrics",
      "vehicle_types"
    ],
    "call_sqls": [
      "SELECT get_vehicle_features(0) FROM dual",
      "SELECT get_vehicle_features(1) FROM dual",
      "SELECT get_vehicle_features(2) FROM dual",
      "SELECT get_vehicle_features(3) FROM dual",
      "SELECT get_vehicle_features(4) FROM dual",
      "SELECT get_vehicle_features(5) FROM dual",
      "SELECT get_vehicle_features(6) FROM dual",
      "SELECT get_vehicle_features(7) FROM dual",
      "SELECT get_vehicle_features(8) FROM dual",
      "SELECT get_vehicle_features(9) FROM dual",
      "SELECT get_vehicle_features(10) FROM dual",
      "SELECT get_vehicle_features(11) FROM dual",
      "SELECT get_vehicle_features(12) FROM dual",
      "SELECT get_vehicle_features(13) FROM dual",
      "SELECT get_vehicle_features(14) FROM dual",
      "SELECT get_vehicle_features(15) FROM dual",
      "SELECT get_vehicle_features(16) FROM dual",
      "SELECT get_vehicle_features(17) FROM dual",
      "SELECT get_vehicle_features(18) FROM dual",
      "SELECT get_vehicle_features(19) FROM dual"
    ],
    "id": 115
  },
  {
    "ir": "Write a PLpgSQL function named update_immigration_count_by_region that accepts two input parameters: a bigint parameter named p_year_id and a real parameter named p_multiplier, and returns an integer value; the function's logic begins by checking for the existence of at least one record in the countries table where the region column contains the substring 'Asia' anywhere within its text, using the strpos function to evaluate if the position of 'Asia' within the region string is greater than zero; if such a record exists, the function proceeds to update the immigration_data table by multiplying the immigrants_count column by the value of the p_multiplier parameter for every row where the year_id column exactly matches the provided p_year_id parameter value; regardless of whether the update operation was performed, the function concludes by returning the integer value 1.",
    "plsql": "CREATE OR REPLACE FUNCTION update_immigration_count_by_region(p_year_id bigint, p_multiplier real) \nRETURNS integer AS $$\nBEGIN\n    IF EXISTS(SELECT 1 FROM countries WHERE strpos(region, 'Asia') > 0) THEN\n        UPDATE immigration_data SET immigrants_count = immigrants_count * p_multiplier WHERE year_id = p_year_id;\n    END IF;\n    RETURN 1;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "immigration_statistics_and_analysis",
    "tables": [
      "countries",
      "immigration_categories",
      "immigration_data",
      "immigration_records",
      "years"
    ],
    "call_sqls": [
      "SELECT update_immigration_count_by_region(1, 1.05);",
      "SELECT update_immigration_count_by_region(2, 1.10);",
      "SELECT update_immigration_count_by_region(3, 0.95);",
      "SELECT update_immigration_count_by_region(4, 1.15);",
      "SELECT update_immigration_count_by_region(5, 1.20);",
      "SELECT update_immigration_count_by_region(6, 0.90);",
      "SELECT update_immigration_count_by_region(7, 1.25);",
      "SELECT update_immigration_count_by_region(8, 1.30);",
      "SELECT update_immigration_count_by_region(9, 0.85);",
      "SELECT update_immigration_count_by_region(10, 1.35);",
      "SELECT update_immigration_count_by_region(11, 1.40);",
      "SELECT update_immigration_count_by_region(12, 0.80);",
      "SELECT update_immigration_count_by_region(13, 1.50);",
      "SELECT update_immigration_count_by_region(14, 1.60);",
      "SELECT update_immigration_count_by_region(15, 0.75);",
      "SELECT update_immigration_count_by_region(16, 1.75);",
      "SELECT update_immigration_count_by_region(17, 2.00);",
      "SELECT update_immigration_count_by_region(18, 0.50);",
      "SELECT update_immigration_count_by_region(19, 1.00);",
      "SELECT update_immigration_count_by_region(20, 1.01);"
    ],
    "id": 116
  },
  {
    "ir": "Write an Oracle PL/SQL function named analyze_trend_pattern that accepts a single input parameter p_trend_type of type VARCHAR2 and returns a VARCHAR2 value, which declares a local variable v_result of type VARCHAR2 with a maximum length of 4000 characters, then executes a SELECT query against the trends table (aliased as t) that uses the LISTAGG aggregate function to concatenate all values from the trend_description column into a single string, with each description separated by '; ', ordered by the year column in ascending order, filtering only rows where the trend_type column matches the input parameter p_trend_type, grouping the results by trend_type, storing this concatenated string in the v_result variable, and finally returning the value of v_result.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_trend_pattern(p_trend_type VARCHAR2) RETURN VARCHAR2 IS\n    v_result VARCHAR2(4000);\nBEGIN\n    SELECT LISTAGG(t.trend_description, '; ') WITHIN GROUP (ORDER BY t.year)\n    INTO v_result\n    FROM trends t\n    WHERE t.trend_type = p_trend_type\n    GROUP BY t.trend_type;\n    RETURN v_result;\nEND;",
    "database_name": "agricultural_aetd_analysi",
    "tables": [
      "trade_data",
      "trade_categories",
      "trends",
      "total_trade_values"
    ],
    "call_sqls": [
      "SELECT analyze_trend_pattern('increase') FROM dual",
      "SELECT analyze_trend_pattern('stabilization') FROM dual",
      "SELECT analyze_trend_pattern('decrease') FROM dual",
      "SELECT analyze_trend_pattern('growth') FROM dual",
      "SELECT analyze_trend_pattern('decline') FROM dual",
      "SELECT analyze_trend_pattern('fluctuation') FROM dual",
      "SELECT analyze_trend_pattern('peak') FROM dual",
      "SELECT analyze_trend_pattern('recovery') FROM dual",
      "SELECT analyze_trend_pattern('boom') FROM dual",
      "SELECT analyze_trend_pattern('slump') FROM dual",
      "SELECT analyze_trend_pattern('surge') FROM dual",
      "SELECT analyze_trend_pattern('plunge') FROM dual",
      "SELECT analyze_trend_pattern('steady') FROM dual",
      "SELECT analyze_trend_pattern('volatile') FROM dual",
      "SELECT analyze_trend_pattern('upward') FROM dual",
      "SELECT analyze_trend_pattern('downward') FROM dual",
      "SELECT analyze_trend_pattern('expansion') FROM dual",
      "SELECT analyze_trend_pattern('contraction') FROM dual",
      "SELECT analyze_trend_pattern('acceleration') FROM dual",
      "SELECT analyze_trend_pattern('slowdown') FROM dual"
    ],
    "id": 117
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_mutation_count_by_type` that accepts a single input parameter. This input parameter, `p_mutation_type`, is of data type `VARCHAR2` and is intended to represent a specific type of mutation for which a count is desired. The function is designed to return a single value of data type `NUMBER`, which will represent the total count of mutations matching the specified type.\n\nUpon execution, the function declares a local variable named `v_mutation_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which calculates the total number of rows. The rows being counted are retrieved from a table named `mutations`. A `WHERE` clause is applied to filter the rows from the `mutations` table. This `WHERE` clause specifies a condition: `mutation_type = p_mutation_type`. This condition ensures that only those rows where the value in the `mutation_type` column of the `mutations` table exactly matches the value provided in the input parameter `p_mutation_type` are included in the count. The result of this `COUNT(*)` aggregation is then stored into the local variable `v_mutation_count`. Finally, the function returns the value currently held by the `v_mutation_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_mutation_count_by_type(p_mutation_type IN VARCHAR2) RETURN NUMBER IS\n    v_mutation_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_mutation_count FROM mutations WHERE mutation_type = p_mutation_type;\n    RETURN v_mutation_count;\nEND;",
    "database_name": "software_tam_analysis",
    "tables": [
      "testing_results",
      "coverage_details",
      "mutations",
      "mutation_pipelines"
    ],
    "call_sqls": [
      "SELECT get_mutation_count_by_type('INSERT') FROM dual",
      "SELECT get_mutation_count_by_type('DELETE') FROM dual",
      "SELECT get_mutation_count_by_type('UPDATE') FROM dual",
      "SELECT get_mutation_count_by_type('SELECT') FROM dual",
      "SELECT get_mutation_count_by_type('Substitution') FROM dual",
      "SELECT get_mutation_count_by_type('Boundary') FROM dual",
      "SELECT get_mutation_count_by_type('Logical') FROM dual",
      "SELECT get_mutation_count_by_type('Arithmetic') FROM dual",
      "SELECT get_mutation_count_by_type('Relational') FROM dual",
      "SELECT get_mutation_count_by_type('Statement') FROM dual",
      "SELECT get_mutation_count_by_type('KILLED') FROM dual",
      "SELECT get_mutation_count_by_type('SURVIVED') FROM dual",
      "SELECT get_mutation_count_by_type('NO_COVERAGE') FROM dual",
      "SELECT get_mutation_count_by_type('TIMED_OUT') FROM dual",
      "SELECT get_mutation_count_by_type('COMPILE_ERROR') FROM dual",
      "SELECT get_mutation_count_by_type('RUNTIME_ERROR') FROM dual",
      "SELECT get_mutation_count_by_type('Conditional') FROM dual",
      "SELECT get_mutation_count_by_type('Loop') FROM dual",
      "SELECT get_mutation_count_by_type('Exception') FROM dual",
      "SELECT get_mutation_count_by_type('Operator') FROM dual",
      "SELECT get_mutation_count_by_type('Constant') FROM dual"
    ],
    "id": 118
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_ascii_membership_score` that accepts one input parameter, `p_customer_id`, which is of type `text` and represents the unique identifier for a customer. This function is designed to return a `bigint` value, representing a calculated membership score.\n\nUpon execution, the function declares a local variable `v_score` of type `bigint` to temporarily store the calculated score. The core logic of the function involves a single `SELECT` statement that uses a `CASE` expression to determine the final `v_score`.\n\nThe `CASE` expression evaluates a specific numerical value, which is derived by calculating the sum of the ASCII values of each character in the `first_name` column for the customer identified by `p_customer_id` from the `customers` table. This sum is computed by:\n1. Selecting from the `customers` table, aliased as `c`.\n2. Joining with `generate_series(1, LENGTH(c.first_name))`, aliased as `i`. This `generate_series` function dynamically creates a sequence of numbers from 1 up to the length of the `first_name` of the current customer.\n3. Filtering these records using the condition `c.customer_id = p_customer_id` to ensure only the specified customer's data is processed.\n4. For each character position `i` in the `first_name`, `SUBSTRING(c.first_name FROM i FOR 1)` extracts a single character.\n5. The `ascii()` function then converts this single character to its corresponding ASCII integer value.\n6. Finally, `SUM()` aggregates all these ASCII values for the customer's `first_name`.\n\nThis calculated sum of ASCII values is then compared against two thresholds within the `CASE` statement:\n\n1.  **First Condition:** If the calculated sum of ASCII values for the customer's `first_name` is strictly greater than `1000`, then the `v_score` is set to the calculated sum of ASCII values minus `500`. The calculation of the sum of ASCII values is repeated here: `(SELECT SUM(ascii(SUBSTRING(c.first_name FROM i FOR 1))) FROM customers c, generate_series(1, LENGTH(c.first_name)) i WHERE c.customer_id = p_customer_id) - 500`.\n\n2.  **Second Condition (ELSE WHEN):** If the first condition is false (i.e., the sum is not greater than `1000`), and the calculated sum of ASCII values for the customer's `first_name` is strictly greater than `500`, then the `v_score` is set to the calculated sum of ASCII values multiplied by `2`. The calculation of the sum of ASCII values is repeated here: `(SELECT SUM(ascii(SUBSTRING(c.first_name FROM i FOR 1))) FROM customers c, generate_series(1, LENGTH(c.first_name)) i WHERE c.customer_id = p_customer_id) * 2`.\n\n3.  **Default Condition (ELSE):** If neither of the above conditions is met (i.e., the sum of ASCII values is `500` or less), then the `v_score` is set to the calculated sum of ASCII values plus `100`. The calculation of the sum of ASCII values is repeated here: `(SELECT SUM(ascii(SUBSTRING(c.first_name FROM i FOR 1))) FROM customers c, generate_series(1, LENGTH(c.first_name)) i WHERE c.customer_id = p_customer_id) + 100`.\n\nThe result of this `CASE` expression is then assigned to the `v_score` variable using `INTO v_score`.\n\nFinally, the function returns the value of `v_score`. To handle potential scenarios where `v_score` might be `NULL` (though unlikely given the current logic, as the sum of ASCII values will always be a number or `NULL` if no customer is found, and the `CASE` statement will always produce a value if the subquery returns a sum), the `COALESCE(v_score, 0)` function is used. This ensures that if `v_score` is `NULL`, the function will return `0` instead; otherwise, it returns the calculated `v_score`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_ascii_membership_score(p_customer_id text) RETURNS bigint LANGUAGE plpgsql AS $$ DECLARE v_score bigint; BEGIN SELECT CASE WHEN (SELECT SUM(ascii(SUBSTRING(c.first_name FROM i FOR 1))) FROM customers c, generate_series(1, LENGTH(c.first_name)) i WHERE c.customer_id = p_customer_id) > 1000 THEN (SELECT SUM(ascii(SUBSTRING(c.first_name FROM i FOR 1))) FROM customers c, generate_series(1, LENGTH(c.first_name)) i WHERE c.customer_id = p_customer_id) - 500 WHEN (SELECT SUM(ascii(SUBSTRING(c.first_name FROM i FOR 1))) FROM customers c, generate_series(1, LENGTH(c.first_name)) i WHERE c.customer_id = p_customer_id) > 500 THEN (SELECT SUM(ascii(SUBSTRING(c.first_name FROM i FOR 1))) FROM customers c, generate_series(1, LENGTH(c.first_name)) i WHERE c.customer_id = p_customer_id) * 2 ELSE (SELECT SUM(ascii(SUBSTRING(c.first_name FROM i FOR 1))) FROM customers c, generate_series(1, LENGTH(c.first_name)) i WHERE c.customer_id = p_customer_id) + 100 END INTO v_score; RETURN COALESCE(v_score, 0); END; $$;",
    "database_name": "customer_information_management_for_a_retail_chain",
    "tables": [
      "customers",
      "memberships",
      "customer_membership_history"
    ],
    "call_sqls": [
      "SELECT calculate_ascii_membership_score('0');",
      "SELECT calculate_ascii_membership_score('1');",
      "SELECT calculate_ascii_membership_score('2');",
      "SELECT calculate_ascii_membership_score('3');",
      "SELECT calculate_ascii_membership_score('4');",
      "SELECT calculate_ascii_membership_score('5');",
      "SELECT calculate_ascii_membership_score('6');",
      "SELECT calculate_ascii_membership_score('7');",
      "SELECT calculate_ascii_membership_score('8');",
      "SELECT calculate_ascii_membership_score('9');",
      "SELECT calculate_ascii_membership_score('10');",
      "SELECT calculate_ascii_membership_score('11');",
      "SELECT calculate_ascii_membership_score('12');",
      "SELECT calculate_ascii_membership_score('13');",
      "SELECT calculate_ascii_membership_score('14');",
      "SELECT calculate_ascii_membership_score('15');",
      "SELECT calculate_ascii_membership_score('16');",
      "SELECT calculate_ascii_membership_score('17');",
      "SELECT calculate_ascii_membership_score('18');",
      "SELECT calculate_ascii_membership_score('19');",
      "SELECT calculate_ascii_membership_score('20');"
    ],
    "id": 119
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named update_referee_ratings that accepts three input parameters: an integer parameter min_experience which defines a threshold for years of experience, a real parameter high_rating which defines a high rating threshold, and a real parameter low_rating which defines a value to be assigned as a new rating; the function performs a conditional update on the referees table by first checking if there exists at least one row in the referees table where the years_of_experience column value is greater than the min_experience parameter and the rating column value is greater than the high_rating parameter, and if this condition is met, it updates all rows in the referees table that satisfy these same conditions by increasing the rating column value by 0.1; if the first condition is not met, it then checks if there exists at least one row in the referees table where the years_of_experience column value is less than the min_experience parameter, and if this condition is met, it updates all rows in the referees table that satisfy this condition by setting the rating column value to the value of the low_rating parameter; if neither of the first two conditions is met, it performs an update on all rows in the referees table by decreasing the rating column value by 0.1 for every row.",
    "plsql": "CREATE OR REPLACE FUNCTION update_referee_ratings(min_experience integer, high_rating real, low_rating real) RETURNS void LANGUAGE plpgsql AS $$ BEGIN IF EXISTS(SELECT 1 FROM referees WHERE years_of_experience > min_experience AND rating > high_rating) THEN UPDATE referees SET rating = rating + 0.1 WHERE years_of_experience > min_experience AND rating > high_rating; ELSIF EXISTS(SELECT 1 FROM referees WHERE years_of_experience < min_experience) THEN UPDATE referees SET rating = low_rating WHERE years_of_experience < min_experience; ELSE UPDATE referees SET rating = rating - 0.1; END IF; END; $$;",
    "database_name": "american_football_penalty_tracking_and_analytics",
    "tables": [
      "games",
      "penalty_types",
      "referees",
      "teams",
      "users"
    ],
    "call_sqls": [
      "SELECT update_referee_ratings(10, 4.5, 3.0);",
      "SELECT update_referee_ratings(5, 4.0, 2.5);",
      "SELECT update_referee_ratings(15, 4.7, 3.2);",
      "SELECT update_referee_ratings(0, 3.5, 1.0);",
      "SELECT update_referee_ratings(20, 4.8, 3.8);",
      "SELECT update_referee_ratings(8, 4.2, 2.8);",
      "SELECT update_referee_ratings(12, 4.3, 3.1);",
      "SELECT update_referee_ratings(3, 3.8, 2.0);",
      "SELECT update_referee_ratings(25, 4.9, 4.0);",
      "SELECT update_referee_ratings(7, 4.1, 2.7);",
      "SELECT update_referee_ratings(18, 4.6, 3.5);",
      "SELECT update_referee_ratings(1, 3.0, 1.5);",
      "SELECT update_referee_ratings(30, 5.0, 4.2);",
      "SELECT update_referee_ratings(6, 4.0, 2.6);",
      "SELECT update_referee_ratings(22, 4.7, 3.9);",
      "SELECT update_referee_ratings(4, 3.9, 2.2);",
      "SELECT update_referee_ratings(9, 4.2, 2.9);",
      "SELECT update_referee_ratings(14, 4.4, 3.3);",
      "SELECT update_referee_ratings(2, 3.5, 1.8);",
      "SELECT update_referee_ratings(11, 4.3, 3.0);"
    ],
    "id": 120
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_trimmed_username` that accepts a single input parameter. This parameter, `p_user_id`, is of data type `NUMBER` and represents the unique identifier for a user whose username is to be retrieved and processed. The function is designed to return a value of data type `VARCHAR2`, which will be the trimmed username. Internally, the function declares a local variable named `v_username` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved username. The core operation involves executing a `SELECT` statement. This `SELECT` statement queries the `users` table. It specifically selects the `username` column. Before assigning the value to the `v_username` variable, the `LTRIM` function is applied to the `username` column. The `LTRIM` function removes any leading spaces from the `username` string. The `WHERE` clause of the `SELECT` statement filters the rows in the `users` table, ensuring that only the row where the `user_id` column matches the value provided in the `p_user_id` input parameter is considered. The result of this `SELECT` operation, which is the `username` with leading spaces removed, is then stored in the `v_username` local variable. Finally, the function returns the value stored in the `v_username` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_trimmed_username(p_user_id NUMBER) RETURN VARCHAR2 IS\nv_username VARCHAR2(255);\nBEGIN\nSELECT LTRIM(username) INTO v_username FROM users WHERE user_id = p_user_id;\nRETURN v_username;\nEND;",
    "database_name": "authorization_acm_system",
    "tables": [
      "users",
      "user_credentials",
      "credentials"
    ],
    "call_sqls": [
      "SELECT get_trimmed_username(0) FROM dual",
      "SELECT get_trimmed_username(1) FROM dual",
      "SELECT get_trimmed_username(10) FROM dual",
      "SELECT get_trimmed_username(25) FROM dual",
      "SELECT get_trimmed_username(50) FROM dual",
      "SELECT get_trimmed_username(100) FROM dual",
      "SELECT get_trimmed_username(500) FROM dual",
      "SELECT get_trimmed_username(1000) FROM dual",
      "SELECT get_trimmed_username(1234) FROM dual",
      "SELECT get_trimmed_username(9999) FROM dual",
      "SELECT get_trimmed_username(15) FROM dual",
      "SELECT get_trimmed_username(42) FROM dual",
      "SELECT get_trimmed_username(77) FROM dual",
      "SELECT get_trimmed_username(88) FROM dual",
      "SELECT get_trimmed_username(101) FROM dual",
      "SELECT get_trimmed_username(202) FROM dual",
      "SELECT get_trimmed_username(303) FROM dual",
      "SELECT get_trimmed_username(404) FROM dual",
      "SELECT get_trimmed_username(505) FROM dual",
      "SELECT get_trimmed_username(777) FROM dual"
    ],
    "id": 121
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_latest_configuration that accepts a single input parameter repeater_id_in of type NUMBER and returns a VARCHAR2 value, which declares a local variable latest_config of type VARCHAR2(255), then executes a SELECT statement on the repeater_configuration table that concatenates the config_type column with a colon and space and the config_value column, filters the rows to only include those where the repeater_id column matches the input parameter repeater_id_in, orders the filtered results by the log_date column converted to a date using the format 'YYYY-MM-DD' in descending order to get the most recent entry first, retrieves only the first row from this ordered result set using the FETCH FIRST ROW ONLY clause, stores this concatenated configuration string in the latest_config variable, and finally returns the value of latest_config.",
    "plsql": "CREATE OR REPLACE FUNCTION get_latest_configuration(repeater_id_in NUMBER) RETURN VARCHAR2 IS\n  latest_config VARCHAR2(255);\nBEGIN\n  SELECT config_type || ': ' || config_value\n  INTO latest_config\n  FROM repeater_configuration\n  WHERE repeater_id = repeater_id_in\n  ORDER BY TO_DATE(log_date, 'YYYY-MM-DD') DESC\n  FETCH FIRST ROW ONLY;\n  RETURN latest_config;\nEND;",
    "database_name": "amateur_rrnm_126248",
    "tables": [
      "repeaters",
      "repeater_configuration",
      "repeater_performance",
      "repeater_comments"
    ],
    "call_sqls": [
      "SELECT get_latest_configuration(1) FROM dual",
      "SELECT get_latest_configuration(2) FROM dual",
      "SELECT get_latest_configuration(3) FROM dual",
      "SELECT get_latest_configuration(4) FROM dual",
      "SELECT get_latest_configuration(5) FROM dual",
      "SELECT get_latest_configuration(10) FROM dual",
      "SELECT get_latest_configuration(15) FROM dual",
      "SELECT get_latest_configuration(20) FROM dual",
      "SELECT get_latest_configuration(25) FROM dual",
      "SELECT get_latest_configuration(30) FROM dual",
      "SELECT get_latest_configuration(35) FROM dual",
      "SELECT get_latest_configuration(40) FROM dual",
      "SELECT get_latest_configuration(45) FROM dual",
      "SELECT get_latest_configuration(50) FROM dual",
      "SELECT get_latest_configuration(55) FROM dual",
      "SELECT get_latest_configuration(60) FROM dual",
      "SELECT get_latest_configuration(65) FROM dual",
      "SELECT get_latest_configuration(70) FROM dual",
      "SELECT get_latest_configuration(75) FROM dual",
      "SELECT get_latest_configuration(80) FROM dual",
      "SELECT get_latest_configuration(85) FROM dual"
    ],
    "id": 122
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `validate_claim_integrity` that accepts two input parameters: `p_policy_threshold` of type `bigint` and `p_claim_limit` of type `integer`. The purpose of this procedure is to validate and potentially clean up data within the \"Claims\" table based on its relationship with the \"First_Notification_of_Loss\" table and internal consistency.\n\nThe procedure begins by declaring two local variables: `v_orphaned_claims` of type `integer` and `v_duplicate_count` of type `integer`.\n\nFirst, the procedure executes a `SELECT COUNT(*)` statement to determine the number of \"orphaned\" claims. This count is stored in the `v_orphaned_claims` variable. A claim is considered \"orphaned\" if it exists in the \"Claims\" table but does not have a corresponding entry in the \"First_Notification_of_Loss\" table that satisfies a specific condition. Specifically, for each row in the \"Claims\" table aliased as `c`, the `WHERE NOT EXISTS` clause checks if there is no row in the \"First_Notification_of_Loss\" table aliased as `f` such that `f.\"FNOL_ID\"` is equal to `c.\"FNOL_ID\"` AND `f.\"Policy_ID\"` is greater than the input parameter `p_policy_threshold`.\n\nSecond, the procedure executes another `SELECT COUNT(*)` statement to determine the number of \"duplicate\" claim groups. This count is stored in the `v_duplicate_count` variable. This count is derived from a subquery aliased as `dup_claims`. The subquery first selects the `FNOL_ID` column from the \"Claims\" table, then groups these results by `FNOL_ID`, and finally filters these groups using a `HAVING COUNT(*) > 1` clause to identify `FNOL_ID` values that appear more than once in the \"Claims\" table. The outer `SELECT COUNT(*)` then counts how many such `FNOL_ID` groups exist.\n\nFollowing these two counting operations, the procedure enters a conditional block (`IF...ELSIF...END IF`).\n\nThe first condition checks if the value of `v_orphaned_claims` is greater than the input parameter `p_claim_limit`. If this condition is true, the procedure executes a `DELETE` statement on the \"Claims\" table. This `DELETE` statement removes all rows from the \"Claims\" table where the `FNOL_ID` column is NOT present in a subquery's result set. The subquery selects the `FNOL_ID` column from the \"First_Notification_of_Loss\" table where the `Policy_ID` column is greater than the input parameter `p_policy_threshold`. In essence, this deletes claims that are not linked to a \"First_Notification_of_Loss\" record meeting the specified policy threshold.\n\nIf the first condition (`v_orphaned_claims > p_claim_limit`) is false, the procedure then evaluates the `ELSIF` condition, which checks if the value of `v_duplicate_count` is greater than 0. If this condition is true, the procedure executes a `DELETE` statement on the \"Claims\" table. This `DELETE` statement removes all rows from the \"Claims\" table where the `Claim_ID` column is NOT present in a subquery's result set. The subquery selects the minimum `Claim_ID` for each distinct `FNOL_ID` from the \"Claims\" table, effectively keeping only one claim (the one with the lowest `Claim_ID`) for each `FNOL_ID` group and deleting the others. This action aims to remove duplicate claims based on `FNOL_ID`, retaining the oldest (assuming `Claim_ID` is sequential).\n\nThe procedure concludes after the conditional block.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_claim_integrity(p_policy_threshold bigint, p_claim_limit integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_orphaned_claims integer;\n    v_duplicate_count integer;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_orphaned_claims\n    FROM \"Claims\" c\n    WHERE NOT EXISTS (\n        SELECT 1\n        FROM \"First_Notification_of_Loss\" f\n        WHERE f.\"FNOL_ID\" = c.\"FNOL_ID\"\n        AND f.\"Policy_ID\" > p_policy_threshold\n    );\n    \n    SELECT COUNT(*)\n    INTO v_duplicate_count\n    FROM (\n        SELECT \"FNOL_ID\", COUNT(*)\n        FROM \"Claims\"\n        GROUP BY \"FNOL_ID\"\n        HAVING COUNT(*) > 1\n    ) dup_claims;\n    \n    IF v_orphaned_claims > p_claim_limit THEN\n        DELETE FROM \"Claims\"\n        WHERE \"FNOL_ID\" NOT IN (\n            SELECT \"FNOL_ID\"\n            FROM \"First_Notification_of_Loss\"\n            WHERE \"Policy_ID\" > p_policy_threshold\n        );\n    ELSIF v_duplicate_count > 0 THEN\n        DELETE FROM \"Claims\"\n        WHERE \"Claim_ID\" NOT IN (\n            SELECT MIN(\"Claim_ID\")\n            FROM \"Claims\"\n            GROUP BY \"FNOL_ID\"\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "insurance_fnol",
    "tables": [
      "Claims",
      "First_Notification_of_Loss"
    ],
    "call_sqls": [
      "CALL validate_claim_integrity(100, 5);",
      "CALL validate_claim_integrity(500, 10);",
      "CALL validate_claim_integrity(1000, 2);",
      "CALL validate_claim_integrity(0, 1);",
      "CALL validate_claim_integrity(200, 0);",
      "CALL validate_claim_integrity(750, 20);",
      "CALL validate_claim_integrity(50, 15);",
      "CALL validate_claim_integrity(300, 3);",
      "CALL validate_claim_integrity(1500, 25);",
      "CALL validate_claim_integrity(10, 30);",
      "CALL validate_claim_integrity(999, 7);",
      "CALL validate_claim_integrity(2500, 12);",
      "CALL validate_claim_integrity(80, 8);",
      "CALL validate_claim_integrity(600, 18);",
      "CALL validate_claim_integrity(1200, 6);",
      "CALL validate_claim_integrity(400, 4);",
      "CALL validate_claim_integrity(900, 9);",
      "CALL validate_claim_integrity(1800, 22);",
      "CALL validate_claim_integrity(30, 11);",
      "CALL validate_claim_integrity(2200, 14);"
    ],
    "id": 123
  },
  {
    "ir": "Write a PLpgSQL function that returns a table consisting of two columns: role_name of type text and permission_name of type text. The function, named get_role_permissions, performs a query operation to retrieve data from multiple tables. It selects the role_name from the roles table and the permission_name from the permissions table. The function joins the roles table with the contact_roles table using the role_id column, ensuring that each role is associated with the correct contact. It then joins the contact_roles table with the user_permissions table using the contact_id column, which corresponds to the user_id in the user_permissions table, to link each contact to their respective permissions. Finally, it joins the user_permissions table with the permissions table using the permission_id column to obtain the name of each permission associated with the user. The function does not take any parameters and is designed to return all combinations of roles and permissions that are linked through these relationships.",
    "plsql": "CREATE OR REPLACE FUNCTION get_role_permissions()\nRETURNS TABLE(role_name text, permission_name text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT r.role_name, p.permission_name\n    FROM roles r\n    JOIN contact_roles cr ON r.role_id = cr.role_id\n    JOIN user_permissions up ON cr.contact_id = up.user_id\n    JOIN permissions p ON up.permission_id = p.permission_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "business_contact_directory",
    "tables": [
      "users",
      "roles",
      "permissions",
      "user_permissions",
      "contact_roles"
    ],
    "call_sqls": [
      "SELECT * FROM get_role_permissions();",
      "SELECT role_name, permission_name FROM get_role_permissions();",
      "SELECT * FROM get_role_permissions() WHERE role_name = 'Analyst';",
      "SELECT * FROM get_role_permissions() WHERE role_name = 'Medical Engineer';",
      "SELECT DISTINCT role_name FROM get_role_permissions();",
      "SELECT DISTINCT permission_name FROM get_role_permissions();",
      "SELECT role_name, COUNT(*) as permission_count FROM get_role_permissions() GROUP BY role_name;",
      "SELECT * FROM get_role_permissions() ORDER BY role_name, permission_name;",
      "SELECT * FROM get_role_permissions() WHERE permission_name LIKE '%View%';",
      "SELECT * FROM get_role_permissions() WHERE permission_name LIKE '%Edit%';",
      "SELECT * FROM get_role_permissions() LIMIT 10;",
      "SELECT * FROM get_role_permissions() OFFSET 0 LIMIT 5;",
      "SELECT * FROM get_role_permissions() WHERE role_name IN ('Analyst', 'Medical Engineer');",
      "SELECT role_name, STRING_AGG(permission_name, ', ') as permissions FROM get_role_permissions() GROUP BY role_name;",
      "SELECT * FROM get_role_permissions() WHERE permission_name = 'View Contacts';",
      "SELECT * FROM get_role_permissions() WHERE permission_name = 'Edit Contacts';",
      "SELECT * FROM get_role_permissions() WHERE role_name = 'Analyst' AND permission_name = 'View Contacts';",
      "SELECT * FROM get_role_permissions() WHERE role_name = 'Medical Engineer' AND permission_name = 'Edit Contacts';",
      "SELECT COUNT(*) as total_role_permissions FROM get_role_permissions();",
      "SELECT * FROM get_role_permissions() WHERE role_name ILIKE '%engineer%';",
      "SELECT * FROM get_role_permissions() WHERE role_name ILIKE '%analyst%';"
    ],
    "id": 124
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_measurement that accepts three input parameters: p_measurement_id of type BIGINT which identifies the specific measurement to calculate, p_designer_id of type BIGINT which identifies the designer associated with the measurements, and p_category_id of type BIGINT which identifies the category of measurements to include in the calculation, and returns a BIGINT value representing the calculated average. The function declares a local variable v_avg_value of type BIGINT to store the intermediate result. It then executes a SELECT query that calculates the average of the value column from the customer_measurements table (aliased as cm), joining it with the measurements table (aliased as m) on the measurement_id column. The query filters the results to only include rows where cm.measurement_id equals the p_measurement_id parameter, cm.designer_id equals the p_designer_id parameter, and m.category_id equals the p_category_id parameter. The calculated average value is explicitly cast to BIGINT using the PostgreSQL casting operator ::BIGINT and stored in the v_avg_value variable. Finally, the function returns the calculated average value stored in v_avg_value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_measurement(\n    p_measurement_id BIGINT,\n    p_designer_id BIGINT,\n    p_category_id BIGINT\n)\nRETURNS BIGINT\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_value BIGINT;\nBEGIN\n    SELECT AVG(cm.value)::BIGINT\n    INTO v_avg_value\n    FROM customer_measurements cm\n    JOIN measurements m ON cm.measurement_id = m.measurement_id\n    WHERE cm.measurement_id = p_measurement_id\n    AND cm.designer_id = p_designer_id\n    AND m.category_id = p_category_id;\n\n    RETURN v_avg_value;\nEND;\n$$;",
    "database_name": "clothing_design_and_anthropometric_data_management",
    "tables": [
      "customers",
      "customer_measurements",
      "measurements",
      "designers",
      "genders",
      "age_groups",
      "measurement_categories"
    ],
    "call_sqls": [
      "SELECT calculate_average_measurement(1, 1, 1);",
      "SELECT calculate_average_measurement(0, 0, 0);",
      "SELECT calculate_average_measurement(2, 3, 1);",
      "SELECT calculate_average_measurement(1, 5, 2);",
      "SELECT calculate_average_measurement(3, 2, 0);",
      "SELECT calculate_average_measurement(0, 4, 3);",
      "SELECT calculate_average_measurement(4, 1, 1);",
      "SELECT calculate_average_measurement(1, 0, 2);",
      "SELECT calculate_average_measurement(5, 2, 0);",
      "SELECT calculate_average_measurement(2, 1, 1);",
      "SELECT calculate_average_measurement(3, 3, 2);",
      "SELECT calculate_average_measurement(0, 2, 0);",
      "SELECT calculate_average_measurement(1, 3, 1);",
      "SELECT calculate_average_measurement(4, 0, 2);",
      "SELECT calculate_average_measurement(2, 4, 0);",
      "SELECT calculate_average_measurement(3, 1, 3);",
      "SELECT calculate_average_measurement(5, 5, 1);",
      "SELECT calculate_average_measurement(0, 1, 2);",
      "SELECT calculate_average_measurement(1, 2, 0);",
      "SELECT calculate_average_measurement(4, 3, 1);"
    ],
    "id": 125
  },
  {
    "ir": "Write a PostgreSQL trigger function named insert_year that is designed to be executed after an insert operation on the co2_emissions table, which inserts a new record into the years table with a sequentially generated year_id and the year value from the newly inserted co2_emissions row. The function begins by calculating the next available year_id by querying the years table to find the maximum existing year_id value, using the COALESCE function to return 0 if the table is empty, and then adding 1 to this value. The function then inserts a new row into the years table, setting the year_id column to this calculated value and the year column to NEW.year, where NEW refers to the row that triggered the function. Finally, the function returns NEW, allowing the original insert operation on the co2_emissions table to proceed. The trigger trg_insert_year is defined to execute this function after each row is inserted into the co2_emissions table, ensuring that for every new co2_emissions record, a corresponding entry is created in the years table with the same year value and a unique, sequential identifier.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_year() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO years (year_id, year) VALUES ((SELECT COALESCE(MAX(year_id), 0) + 1 FROM years), NEW.year);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_year\nAFTER INSERT ON co2_emissions\nFOR EACH ROW EXECUTE FUNCTION insert_year();",
    "database_name": "environmental_carbon_emissions_data_analysis",
    "tables": [
      "co2_emissions",
      "sectors",
      "years",
      "emission_types",
      "data_sources",
      "data_uploads",
      "users"
    ],
    "call_sqls": [
      "INSERT INTO co2_emissions (sector_id, year, total_co2_emissions) VALUES (1, 2020, 1000.5);",
      "INSERT INTO co2_emissions (sector_id, year, transportation, coal) VALUES (2, 2021, 250.3, 450.7);",
      "INSERT INTO co2_emissions (sector_id, year, natural_gas, electricity) VALUES (3, 2022, 300.0, 150.0);",
      "INSERT INTO co2_emissions (sector_id, year, petroleum, motor_gasoline) VALUES (4, 2023, 500.2, 200.1);",
      "INSERT INTO co2_emissions (sector_id, year, jet_fuel, distillate_fuel_oil) VALUES (5, 2024, 75.5, 120.3);",
      "INSERT INTO co2_emissions (sector_id, year, residual_fuel_oil, lubricants) VALUES (6, 2025, 90.0, 15.8);",
      "INSERT INTO co2_emissions (sector_id, year, aviation_gas, industrial) VALUES (7, 2026, 5.2, 600.4);",
      "INSERT INTO co2_emissions (sector_id, year, residential, commercial) VALUES (8, 2027, 180.9, 220.7);",
      "INSERT INTO co2_emissions (sector_id, year, emission_type_id, data_source_id) VALUES (9, 2028, 1, 1);",
      "INSERT INTO co2_emissions (sector_id, year, upload_id, total_co2_emissions_tons) VALUES (10, 2029, 1, 1000000.0);",
      "INSERT INTO co2_emissions (sector_id, year, total_co2_emissions_mt) VALUES (11, 2030, 500.75);",
      "INSERT INTO co2_emissions (sector_id, year, hydrocarbon_liquids) VALUES (12, 1990, 45.6);",
      "INSERT INTO co2_emissions (sector_id, year, total_co2_emissions, transportation, coal, natural_gas) VALUES (13, 1995, 1500.0, 400.0, 700.0, 400.0);",
      "INSERT INTO co2_emissions (sector_id, year, electricity, petroleum, motor_gasoline) VALUES (14, 2000, 300.5, 800.2, 350.8);",
      "INSERT INTO co2_emissions (sector_id, year, jet_fuel, distillate_fuel_oil, residual_fuel_oil) VALUES (15, 2005, 100.0, 200.0, 150.0);",
      "INSERT INTO co2_emissions (sector_id, year, lubricants, aviation_gas, industrial, residential) VALUES (16, 2010, 20.5, 3.1, 750.3, 210.9);",
      "INSERT INTO co2_emissions (sector_id, year, commercial, emission_type_id, data_source_id, upload_id) VALUES (17, 2015, 310.4, 2, 3, 5);",
      "INSERT INTO co2_emissions (sector_id, year, total_co2_emissions_tons, total_co2_emissions_mt) VALUES (18, 1985, 2000000.0, 1000.0);",
      "INSERT INTO co2_emissions (sector_id, year, total_co2_emissions, hydrocarbon_liquids, jet_fuel) VALUES (19, 1975, 800.25, 30.0, 50.5);",
      "INSERT INTO co2_emissions (sector_id, year, coal, natural_gas, electricity, petroleum) VALUES (20, 1960, 1000.8, 200.1, 100.5, 600.9);"
    ],
    "id": 126
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_player_performance` that accepts five input parameters: `player_id_input` of type `BIGINT`, `start_date` of type `TEXT`, `end_date` of type `TEXT`, and `min_ab` of type `BIGINT`. This function is designed to return a table with five columns: `player_id` of type `BIGINT`, `period_start` of type `TEXT`, `period_end` of type `TEXT`, `avg_performance` of type `REAL`, and `total_ab` of type `BIGINT`.\n\nUpon execution, the function declares three local variables: `total_hits` of type `BIGINT`, `total_at_bats` of type `BIGINT`, and `performance_avg` of type `REAL`.\n\nThe function then proceeds to execute a `SELECT` statement to retrieve aggregated statistics. This `SELECT` statement queries the `player_game_stats` table, aliased as `pgs`, and joins it with the `games` table, aliased as `g`, using the `game_id` column from both tables (`pgs.game_id = g.game_id`). The `SELECT` statement calculates the sum of the `h` column from `player_game_stats` and the sum of the `ab` column from `player_game_stats`. The `COALESCE` function is applied to both sums, ensuring that if no rows match the criteria or if the sums result in `NULL`, a value of `0` is used instead. The calculated sum of `h` is assigned to the `total_hits` variable, and the calculated sum of `ab` is assigned to the `total_at_bats` variable.\n\nThe `WHERE` clause of this `SELECT` statement filters the records based on three conditions:\n1. `pgs.player_id = player_id_input`: Matches records where the `player_id` in `player_game_stats` is equal to the provided `player_id_input` parameter.\n2. `g.game_date BETWEEN start_date AND end_date`: Filters records where the `game_date` in the `games` table falls inclusively between the `start_date` and `end_date` parameters.\n3. `pgs.ab >= min_ab`: Includes only records where the `ab` (at-bats) column in `player_game_stats` is greater than or equal to the `min_ab` parameter.\n\nFollowing the data retrieval, the function enters a conditional block (`IF total_at_bats > 0 THEN`).\nIf the `total_at_bats` variable is greater than `0`, the `performance_avg` variable is calculated by dividing `total_hits` (cast to `REAL`) by `total_at_bats` (cast to `REAL`). The result of this division is then rounded to three decimal places using the `ROUND` function.\nIf `total_at_bats` is not greater than `0` (i.e., it is `0` or less), the `performance_avg` variable is set to `0.0`.\n\nFinally, the function uses `RETURN QUERY` to return a single row as a table. This row consists of the `player_id_input` parameter, the `start_date` parameter, the `end_date` parameter, the calculated `performance_avg` variable, and the `total_at_bats` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_player_performance(player_id_input BIGINT, start_date TEXT, end_date TEXT, min_ab BIGINT)\nRETURNS TABLE(player_id BIGINT, period_start TEXT, period_end TEXT, avg_performance REAL, total_ab BIGINT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_hits BIGINT;\n    total_at_bats BIGINT;\n    performance_avg REAL;\nBEGIN\n    SELECT COALESCE(SUM(h), 0), COALESCE(SUM(ab), 0) INTO total_hits, total_at_bats\n    FROM player_game_stats pgs\n    JOIN games g ON pgs.game_id = g.game_id\n    WHERE pgs.player_id = player_id_input\n    AND g.game_date BETWEEN start_date AND end_date\n    AND pgs.ab >= min_ab;\n    \n    IF total_at_bats > 0 THEN\n        performance_avg := ROUND(total_hits::REAL / total_at_bats::REAL, 3);\n    ELSE\n        performance_avg := 0.0;\n    END IF;\n    \n    RETURN QUERY SELECT player_id_input, start_date, end_date, performance_avg, total_at_bats;\nEND;\n$$;",
    "database_name": "baseball_player_statistics_60633",
    "tables": [
      "games",
      "teams",
      "players",
      "player_game_stats",
      "games_box_scores",
      "games_umpires"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_player_performance(1001, '2023-04-01', '2023-04-30', 10);",
      "SELECT * FROM calculate_player_performance(1002, '2023-05-01', '2023-05-31', 5);",
      "SELECT * FROM calculate_player_performance(1003, '2023-06-01', '2023-06-30', 15);",
      "SELECT * FROM calculate_player_performance(1004, '2023-07-01', '2023-07-31', 20);",
      "SELECT * FROM calculate_player_performance(1005, '2023-08-01', '2023-08-31', 8);",
      "SELECT * FROM calculate_player_performance(1006, '2023-09-01', '2023-09-30', 12);",
      "SELECT * FROM calculate_player_performance(1007, '2023-04-15', '2023-05-15', 25);",
      "SELECT * FROM calculate_player_performance(1008, '2023-05-15', '2023-06-15', 18);",
      "SELECT * FROM calculate_player_performance(1009, '2023-06-15', '2023-07-15', 7);",
      "SELECT * FROM calculate_player_performance(1010, '2023-07-15', '2023-08-15', 30);",
      "SELECT * FROM calculate_player_performance(1011, '2023-08-15', '2023-09-15', 3);",
      "SELECT * FROM calculate_player_performance(1012, '2023-04-01', '2023-09-30', 100);",
      "SELECT * FROM calculate_player_performance(1013, '2023-05-01', '2023-08-31', 50);",
      "SELECT * FROM calculate_player_performance(1014, '2023-06-01', '2023-07-31', 40);",
      "SELECT * FROM calculate_player_performance(1015, '2023-04-10', '2023-04-20', 2);",
      "SELECT * FROM calculate_player_performance(1016, '2023-05-10', '2023-05-20', 1);",
      "SELECT * FROM calculate_player_performance(1017, '2023-06-10', '2023-06-20', 0);",
      "SELECT * FROM calculate_player_performance(1018, '2023-07-10', '2023-07-20', 5);",
      "SELECT * FROM calculate_player_performance(1019, '2023-08-10', '2023-08-20', 10);",
      "SELECT * FROM calculate_player_performance(1020, '2023-09-10', '2023-09-20', 15);"
    ],
    "id": 127
  },
  {
    "ir": "Write a PLpgSQL function named create_risk_assessment_entry that accepts two parameters: p_operation_id of type bigint, representing the unique identifier of an operation, and p_risk_name of type text, representing the name of the risk to be assessed. The function returns a bigint value. Within the function, declare a local variable v_new_id of type bigint to store the new risk factor ID, and another local variable v_operation_status of type text to store the status of the operation. The function begins by selecting the status column from the operations table where the operation_id matches the provided p_operation_id, and stores this value in v_operation_status. Next, it calculates the new risk factor ID by selecting the maximum value of the risk_factor_id column from the risk_factors table, using the COALESCE function to default to 0 if no rows exist, and adds 1 to this maximum value, storing the result in v_new_id. The function then evaluates the value of v_operation_status using conditional statements. If v_operation_status equals 'open', it inserts a new row into the risk_factors table with the risk_factor_id set to v_new_id, risk_factor_name set to p_risk_name, and description set to 'High priority assessment', and returns v_new_id. If v_operation_status equals 'partially closed', it inserts a new row into the risk_factors table with the risk_factor_id set to v_new_id, risk_factor_name set to p_risk_name, and description set to 'Medium priority assessment', and returns v_new_id. If v_operation_status is not null, it inserts a new row into the risk_factors table with the risk_factor_id set to v_new_id, risk_factor_name set to p_risk_name, and description set to 'Low priority assessment', and returns v_new_id. If none of these conditions are met, the function returns -1.",
    "plsql": "CREATE OR REPLACE FUNCTION create_risk_assessment_entry(p_operation_id bigint, p_risk_name text)\nRETURNS bigint AS $$\nDECLARE\n    v_new_id bigint;\n    v_operation_status text;\nBEGIN\n    SELECT status INTO v_operation_status FROM operations WHERE operation_id = p_operation_id;\n    SELECT COALESCE(MAX(risk_factor_id), 0) + 1 INTO v_new_id FROM risk_factors;\n    \n    IF v_operation_status = 'open' THEN\n        INSERT INTO risk_factors (risk_factor_id, risk_factor_name, description) VALUES (v_new_id, p_risk_name, 'High priority assessment');\n        RETURN v_new_id;\n    ELSIF v_operation_status = 'partially closed' THEN\n        INSERT INTO risk_factors (risk_factor_id, risk_factor_name, description) VALUES (v_new_id, p_risk_name, 'Medium priority assessment');\n        RETURN v_new_id;\n    ELSIF v_operation_status IS NOT NULL THEN\n        INSERT INTO risk_factors (risk_factor_id, risk_factor_name, description) VALUES (v_new_id, p_risk_name, 'Low priority assessment');\n        RETURN v_new_id;\n    ELSE\n        RETURN -1;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "traffic_accident_data_analysis_and_prevention",
    "tables": [
      "access_logs",
      "accident_risk_factors",
      "risk_factors",
      "reports",
      "users",
      "operations"
    ],
    "call_sqls": [
      "SELECT create_risk_assessment_entry(1, 'Weather Hazard');",
      "SELECT create_risk_assessment_entry(2, 'Equipment Failure');",
      "SELECT create_risk_assessment_entry(3, 'Human Error');",
      "SELECT create_risk_assessment_entry(1, 'Slippery Surface');",
      "SELECT create_risk_assessment_entry(2, 'Inadequate Signage');",
      "SELECT create_risk_assessment_entry(3, 'Fatigue');",
      "SELECT create_risk_assessment_entry(1, 'Night Work');",
      "SELECT create_risk_assessment_entry(2, 'Heavy Traffic');",
      "SELECT create_risk_assessment_entry(3, 'Unstable Ground');",
      "SELECT create_risk_assessment_entry(1, 'Chemical Exposure');",
      "SELECT create_risk_assessment_entry(2, 'Noise Pollution');",
      "SELECT create_risk_assessment_entry(3, 'Electrical Hazard');",
      "SELECT create_risk_assessment_entry(1, 'Fire Risk');",
      "SELECT create_risk_assessment_entry(2, 'Confined Space');",
      "SELECT create_risk_assessment_entry(3, 'Falling Objects');",
      "SELECT create_risk_assessment_entry(1, 'Vehicle Collision');",
      "SELECT create_risk_assessment_entry(2, 'Data Breach');",
      "SELECT create_risk_assessment_entry(3, 'Supply Chain Disruption');",
      "SELECT create_risk_assessment_entry(1, 'Regulatory Change');",
      "SELECT create_risk_assessment_entry(2, 'Training Deficiency');",
      "SELECT create_risk_assessment_entry(3, 'Communication Breakdown');"
    ],
    "id": 128
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named update_customer_balance_after_loan_delete that is automatically executed after a row is deleted from the LOAN table, and it executes once for each deleted row; the trigger performs two distinct update operations: first, it updates the CUSTOMER table by setting the ACC_BAL column to the result of the current ACC_BAL value plus the value from the deleted row's AMOUNT column, specifically for the row in the CUSTOMER table where the CUST_ID column matches the deleted row's CUST_ID value; second, it updates the BANK table by setting the NO_OF_CUSTOMERS column to the result of the current NO_OF_CUSTOMERS value minus one, specifically for the row in the BANK table where the BRANCH_ID column matches the deleted row's BRANCH_ID value.",
    "plsql": "CREATE OR REPLACE TRIGGER update_customer_balance_after_loan_delete\nAFTER DELETE ON LOAN\nFOR EACH ROW\nBEGIN\n  UPDATE CUSTOMER SET ACC_BAL = ACC_BAL + :OLD.AMOUNT WHERE CUST_ID = :OLD.CUST_ID;\n  UPDATE BANK SET NO_OF_CUSTOMERS = NO_OF_CUSTOMERS - 1 WHERE BRANCH_ID = :OLD.BRANCH_ID;\nEND;",
    "database_name": "loan_1",
    "tables": [
      "BANK",
      "CUSTOMER",
      "LOAN"
    ],
    "call_sqls": [
      "DELETE FROM LOAN WHERE LOAN_ID = '1'",
      "DELETE FROM LOAN WHERE LOAN_ID = '2'",
      "DELETE FROM LOAN WHERE LOAN_ID = '3'",
      "DELETE FROM LOAN WHERE CUST_ID = '1'",
      "DELETE FROM LOAN WHERE CUST_ID = '3'",
      "DELETE FROM LOAN WHERE BRANCH_ID = '1'",
      "DELETE FROM LOAN WHERE BRANCH_ID = '2'",
      "DELETE FROM LOAN WHERE BRANCH_ID = '3'",
      "DELETE FROM LOAN WHERE LOAN_TYPE = 'Mortgages'",
      "DELETE FROM LOAN WHERE LOAN_TYPE = 'Auto'",
      "DELETE FROM LOAN WHERE LOAN_TYPE = 'Business'",
      "DELETE FROM LOAN WHERE AMOUNT = 2050",
      "DELETE FROM LOAN WHERE AMOUNT = 3000",
      "DELETE FROM LOAN WHERE AMOUNT = 5000",
      "DELETE FROM LOAN WHERE AMOUNT > 2500",
      "DELETE FROM LOAN WHERE AMOUNT < 4000",
      "DELETE FROM LOAN WHERE CUST_ID = '1' AND BRANCH_ID = '1'",
      "DELETE FROM LOAN WHERE CUST_ID = '3' AND BRANCH_ID = '3'",
      "DELETE FROM LOAN WHERE BRANCH_ID = '2' AND LOAN_TYPE = 'Auto'",
      "DELETE FROM LOAN"
    ],
    "id": 129
  },
  {
    "ir": "Write a PLpgSQL function named process_cars_by_fuel_capacity that accepts a single parameter p_fuel_threshold of type real, which represents a threshold value for fuel capacity. The function returns an integer indicating the number of rows affected by the operations within the function. The function begins by declaring a local variable v_processed of type integer to store the number of rows processed. The function then evaluates the value of p_fuel_threshold using a series of conditional statements. If p_fuel_threshold is greater than 70.0, it deletes rows from the car_images table where the car_id matches any car_id from the cars table with a fuel_capacity greater than 70.0. If p_fuel_threshold is greater than 50.0 but not greater than 70.0, it updates the image_caption column in the car_images table by appending the string ' - High Fuel' to the existing caption for rows where the car_id matches any car_id from the cars table with a fuel_capacity between 50.1 and 70.0. If p_fuel_threshold is greater than 30.0 but not greater than 50.0, it updates the image_caption column in the car_images table by appending the string ' - Medium Fuel' to the existing caption for rows where the car_id matches any car_id from the cars table with a fuel_capacity between 30.1 and 50.0. If none of the above conditions are met, meaning p_fuel_threshold is 30.0 or less, it inserts new rows into the car_images table for each car_id from the cars table with a fuel_capacity of 30.0 or less. The inserted rows have a fixed image_path of 'images/low_fuel_default.jpg', an image_size of 1.8, the current date as upload_date, an image_caption of 'Low fuel capacity car', and an image_alt_text of 'Default image for low fuel capacity car'. After executing the appropriate operation based on the conditions, the function retrieves the number of rows affected by the last SQL command using the GET DIAGNOSTICS statement and assigns this value to v_processed. Finally, the function returns the value of v_processed, indicating the total number of rows processed by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION process_cars_by_fuel_capacity(p_fuel_threshold real)\nRETURNS integer AS $$\nDECLARE\n    v_processed integer;\nBEGIN\n    IF p_fuel_threshold > 70.0 THEN\n        DELETE FROM car_images WHERE car_id IN (SELECT car_id FROM cars WHERE fuel_capacity > 70.0);\n    ELSIF p_fuel_threshold > 50.0 THEN\n        UPDATE car_images SET image_caption = CONCAT(image_caption, ' - High Fuel') WHERE car_id IN (SELECT car_id FROM cars WHERE fuel_capacity BETWEEN 50.1 AND 70.0);\n    ELSIF p_fuel_threshold > 30.0 THEN\n        UPDATE car_images SET image_caption = CONCAT(image_caption, ' - Medium Fuel') WHERE car_id IN (SELECT car_id FROM cars WHERE fuel_capacity BETWEEN 30.1 AND 50.0);\n    ELSE\n        INSERT INTO car_images (car_id, image_path, image_size, upload_date, image_caption, image_alt_text)\n        SELECT car_id, 'images/low_fuel_default.jpg', 1.8, CURRENT_DATE, 'Low fuel capacity car', 'Default image for low fuel capacity car'\n        FROM cars WHERE fuel_capacity <= 30.0;\n    END IF;\n    GET DIAGNOSTICS v_processed = ROW_COUNT;\n    RETURN v_processed;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "automotive_performance_and_specifications",
    "tables": [
      "car_images",
      "cars"
    ],
    "call_sqls": [
      "SELECT process_cars_by_fuel_capacity(80.0);",
      "SELECT process_cars_by_fuel_capacity(75.5);",
      "SELECT process_cars_by_fuel_capacity(70.0);",
      "SELECT process_cars_by_fuel_capacity(65.0);",
      "SELECT process_cars_by_fuel_capacity(60.0);",
      "SELECT process_cars_by_fuel_capacity(55.0);",
      "SELECT process_cars_by_fuel_capacity(50.0);",
      "SELECT process_cars_by_fuel_capacity(45.0);",
      "SELECT process_cars_by_fuel_capacity(40.0);",
      "SELECT process_cars_by_fuel_capacity(35.0);",
      "SELECT process_cars_by_fuel_capacity(30.0);",
      "SELECT process_cars_by_fuel_capacity(25.0);",
      "SELECT process_cars_by_fuel_capacity(20.0);",
      "SELECT process_cars_by_fuel_capacity(15.0);",
      "SELECT process_cars_by_fuel_capacity(10.0);",
      "SELECT process_cars_by_fuel_capacity(5.0);",
      "SELECT process_cars_by_fuel_capacity(0.0);",
      "SELECT process_cars_by_fuel_capacity(71.0);",
      "SELECT process_cars_by_fuel_capacity(51.0);",
      "SELECT process_cars_by_fuel_capacity(31.0);",
      "SELECT process_cars_by_fuel_capacity(29.9);"
    ],
    "id": 130
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters: department_code of type text and new_head_id of type integer. This function returns a table with columns update_status of type text and old_head_id of type integer. The function begins by selecting the current head's employee number (EMP_NUM) from the DEPARTMENT table where the department code (DEPT_CODE) matches the provided department_code parameter, storing this value in the variable old_head_id. It then updates the DEPARTMENT table by setting the EMP_NUM column to the new_head_id for the row where DEPT_CODE equals the department_code. After the update, the function checks if any row was affected using the FOUND condition. If a row was updated, it sets the update_status to 'Department head updated successfully'. If no row was found with the given department_code, it sets update_status to 'Department not found' and assigns NULL to old_head_id. The function then returns the result. If any exception occurs during execution, the function catches it, sets update_status to 'Error updating department head: ' followed by the error message (SQLERRM), assigns NULL to old_head_id, and returns the result.",
    "plsql": "CREATE OR REPLACE FUNCTION update_department_head(\n    department_code text,\n    new_head_id integer\n)\nRETURNS TABLE(update_status text, old_head_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    -- Get the current head ID\n    SELECT EMP_NUM INTO old_head_id FROM DEPARTMENT WHERE DEPT_CODE = department_code;\n    \n    -- Update the department head\n    UPDATE DEPARTMENT\n    SET EMP_NUM = new_head_id\n    WHERE DEPT_CODE = department_code;\n    \n    -- Set the status message\n    IF FOUND THEN\n        update_status := 'Department head updated successfully';\n    ELSE\n        update_status := 'Department not found';\n        old_head_id := NULL;\n    END IF;\n    \n    RETURN NEXT;\n    RETURN;\nEXCEPTION\n    WHEN OTHERS THEN\n        update_status := 'Error updating department head: ' || SQLERRM;\n        old_head_id := NULL;\n        RETURN NEXT;\n        RETURN;\nEND;\n$$;",
    "database_name": "college_1",
    "tables": [
      "CLASS",
      "COURSE",
      "DEPARTMENT",
      "ENROLL",
      "PROFESSOR",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT * FROM update_department_head('ACCT', 114);",
      "SELECT * FROM update_department_head('ART', 435);",
      "SELECT * FROM update_department_head('BIOL', 387);",
      "SELECT * FROM update_department_head('CIS', 222);",
      "SELECT * FROM update_department_head('HIST', 103);",
      "SELECT * FROM update_department_head('ENG', 104);",
      "SELECT * FROM update_department_head('ACCT', 105);",
      "SELECT * FROM update_department_head('ART', 205);",
      "SELECT * FROM update_department_head('BIOL', 228);",
      "SELECT * FROM update_department_head('CIS', 342);",
      "SELECT * FROM update_department_head('ACCT', 435);",
      "SELECT * FROM update_department_head('BIOL', 114);",
      "SELECT * FROM update_department_head('ART', 387);",
      "SELECT * FROM update_department_head('HIST', 222);",
      "SELECT * FROM update_department_head('ENG', 205);",
      "SELECT * FROM update_department_head('ACCT', 103);",
      "SELECT * FROM update_department_head('CIS', 104);",
      "SELECT * FROM update_department_head('BIOL', 105);",
      "SELECT * FROM update_department_head('ART', 228);",
      "SELECT * FROM update_department_head('HIST', 342);"
    ],
    "id": 131
  },
  {
    "ir": "Write a PLpgSQL function that returns a table consisting of two columns: problem_name of type text and performance_category of type text. The function performs a query operation that selects the problem_name from the problem_instances table and determines the performance_category based on the success_rate column from the performance_metrics table. Specifically, it joins the performance_metrics table (aliased as pm) with the problem_instances table (aliased as pi) using the problem_id column as the joining key. For each row in the result set, it evaluates the success_rate column from the performance_metrics table; if the success_rate is greater than 90, it assigns the performance_category as 'High Performance', otherwise, it assigns 'Standard Performance'. After executing the query, the function checks if any rows were found using the FOUND condition, and if so, it raises a notice with the message 'Performance categories calculated successfully'. The function is defined using the PLpgSQL language and is intended to be used in PostgreSQL databases.",
    "plsql": "CREATE OR REPLACE FUNCTION get_performance_category()\nRETURNS TABLE(problem_name text, performance_category text) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT pi.problem_name,\n         CASE \n           WHEN pm.success_rate > 90 THEN 'High Performance'\n           ELSE 'Standard Performance'\n         END as performance_category\n  FROM performance_metrics pm\n  JOIN problem_instances pi ON pm.problem_id = pi.problem_id;\n  \n  IF FOUND THEN\n    RAISE NOTICE 'Performance categories calculated successfully';\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "algorithm_performance_benchmarking_and_analysis",
    "tables": [
      "problem_instances",
      "performance_metrics"
    ],
    "call_sqls": [
      "SELECT * FROM get_performance_category();",
      "SELECT problem_name, performance_category FROM get_performance_category();",
      "SELECT * FROM get_performance_category() WHERE performance_category = 'High Performance';",
      "SELECT problem_name FROM get_performance_category() WHERE performance_category = 'Standard Performance';",
      "SELECT COUNT(*) FROM get_performance_category();",
      "SELECT performance_category, COUNT(*) FROM get_performance_category() GROUP BY performance_category;",
      "SELECT * FROM get_performance_category() ORDER BY problem_name;",
      "SELECT * FROM get_performance_category() ORDER BY performance_category, problem_name;",
      "SELECT * FROM get_performance_category() WHERE problem_name LIKE '%easy%';",
      "SELECT * FROM get_performance_category() WHERE problem_name ILIKE '%depot%';",
      "SELECT * FROM get_performance_category() LIMIT 5;",
      "SELECT * FROM get_performance_category() OFFSET 10 LIMIT 10;",
      "SELECT DISTINCT performance_category FROM get_performance_category();",
      "SELECT problem_name FROM get_performance_category() WHERE performance_category = 'High Performance' ORDER BY problem_name DESC;",
      "SELECT * FROM get_performance_category() WHERE problem_name IN ('depot_easy (10)', 'driverlog_easy (16)');",
      "SELECT performance_category, STRING_AGG(problem_name, ', ') FROM get_performance_category() GROUP BY performance_category;",
      "SELECT * FROM get_performance_category() WHERE problem_name ~ '^depot';",
      "SELECT * FROM get_performance_category() WHERE problem_name !~ 'easy';",
      "SELECT problem_name FROM get_performance_category() WHERE performance_category = 'Standard Performance' LIMIT 3;",
      "SELECT * FROM get_performance_category() CROSS JOIN (SELECT 1) AS t;"
    ],
    "id": 132
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_most_active_author_id` that is designed to return a single `BIGINT` value. This function operates by executing a `SELECT` statement against the `post_comments` table. The `SELECT` statement's primary objective is to identify the `author_id` that has the highest number of associated comments within the `post_comments` table. To achieve this, the `SELECT` statement first groups all rows in the `post_comments` table by their respective `author_id` values. For each distinct `author_id` group, it then calculates the total count of comments using the `COUNT(*)` aggregate function. Subsequently, these grouped results are ordered in descending order based on the calculated count of comments, ensuring that the `author_id` with the most comments appears first. Finally, the `LIMIT 1` clause restricts the result set to only the top row, effectively selecting the `author_id` that corresponds to the highest comment count. The `author_id` retrieved from this subquery is then returned as the output of the `get_most_active_author_id` function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_most_active_author_id()\nRETURNS BIGINT\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN (SELECT author_id FROM post_comments GROUP BY author_id ORDER BY COUNT(*) DESC LIMIT 1);\nEND;\n$$;",
    "database_name": "blog_post_and_author_management",
    "tables": [
      "authors",
      "post_comments"
    ],
    "call_sqls": [
      "SELECT get_most_active_author_id();",
      "SELECT * FROM authors WHERE author_id = get_most_active_author_id();",
      "SELECT get_most_active_author_id() AS most_active_author;",
      "SELECT name FROM authors WHERE author_id = get_most_active_author_id();",
      "SELECT get_most_active_author_id() INTO my_variable;",
      "SELECT author_id, name FROM authors WHERE author_id = get_most_active_author_id();",
      "SELECT get_most_active_author_id() AS top_commenter_id;",
      "SELECT get_most_active_author_id() FROM authors LIMIT 1;",
      "SELECT get_most_active_author_id() WHERE 1=1;",
      "SELECT get_most_active_author_id() AS result;",
      "SELECT get_most_active_author_id() AS most_active;",
      "SELECT get_most_active_author_id() FROM generate_series(1,1);",
      "SELECT get_most_active_author_id() AS author_id;",
      "SELECT get_most_active_author_id() FROM (VALUES (1)) AS t;",
      "SELECT get_most_active_author_id() AS active_author_id;",
      "SELECT get_most_active_author_id() FROM pg_catalog.pg_class LIMIT 1;",
      "SELECT get_most_active_author_id() AS top_author;",
      "SELECT get_most_active_author_id() FROM information_schema.tables LIMIT 1;",
      "SELECT get_most_active_author_id() AS most_active_author_id;",
      "SELECT get_most_active_author_id() FROM (SELECT 1) AS dummy;"
    ],
    "id": 133
  },
  {
    "ir": "Write a PostgreSQL trigger function named trigger_function_5 that is executed by a trigger named trigger_5, which is defined to fire BEFORE INSERT on the projects table FOR EACH ROW, and within this function, a conditional check is performed on the NEW.project_id value using the modulus operator to determine if it is an even number by evaluating if NEW.project_id % 2 = 0, and if this condition is true, the NEW.name field is assigned the string literal value 'Even Project', but if the condition is false, indicating the NEW.project_id is an odd number, the NEW.name field is assigned the string literal value 'Odd Project', and finally, the modified NEW row is returned to the database engine to proceed with the insert operation.",
    "plsql": "CREATE OR REPLACE FUNCTION trigger_function_5() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.project_id % 2 = 0 THEN\n    NEW.name := 'Even Project';\n  ELSE\n    NEW.name := 'Odd Project';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_5\nBEFORE INSERT ON projects\nFOR EACH ROW EXECUTE FUNCTION trigger_function_5();",
    "database_name": "actionscript_compiler_tools_and_testing_framework_management",
    "tables": [
      "projects"
    ],
    "call_sqls": [
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (1, 'Temp', 'Test project 1', 1, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (2, 'Temp', 'Test project 2', 1, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (3, 'Temp', 'Test project 3', 2, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (4, 'Temp', 'Test project 4', 2, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (5, 'Temp', 'Test project 5', 1, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (6, 'Temp', 'Test project 6', 2, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (7, 'Temp', 'Test project 7', 1, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (8, 'Temp', 'Test project 8', 1, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (9, 'Temp', 'Test project 9', 2, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (10, 'Temp', 'Test project 10', 2, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (11, 'Temp', 'Test project 11', 1, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (12, 'Temp', 'Test project 12', 2, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (13, 'Temp', 'Test project 13', 1, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (14, 'Temp', 'Test project 14', 1, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (15, 'Temp', 'Test project 15', 2, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (16, 'Temp', 'Test project 16', 2, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (17, 'Temp', 'Test project 17', 1, 2);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (18, 'Temp', 'Test project 18', 2, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (19, 'Temp', 'Test project 19', 1, 1);",
      "INSERT INTO projects (project_id, name, description, compiler_id, framework_id) VALUES (20, 'Temp', 'Test project 20', 1, 1);"
    ],
    "id": 134
  },
  {
    "ir": "Write a PLpgSQL function that returns a table with columns account_type of type text and total_balance of type real. The function executes a query that selects the account_type from the accounts table and calculates the sum of the balance from the account_balances table. It performs an inner join operation between the accounts table and the account_balances table on the account_id column, ensuring that only rows with matching account_id values in both tables are considered. The results are grouped by the account_type column from the accounts table, and for each group, the total balance is computed by summing the balance column from the account_balances table. The function does not take any input parameters and directly returns the result set of the query.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_balance_by_type()\nRETURNS TABLE(account_type text, total_balance real) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT a.account_type, SUM(ab.balance)\n    FROM accounts a\n    JOIN account_balances ab ON a.account_id = ab.account_id\n    GROUP BY a.account_type;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "accounting_and_financial_transaction_management",
    "tables": [
      "accounts",
      "account_balances"
    ],
    "call_sqls": [
      "SELECT * FROM get_total_balance_by_type();",
      "SELECT account_type, total_balance FROM get_total_balance_by_type();",
      "SELECT * FROM get_total_balance_by_type() WHERE total_balance > 10000;",
      "SELECT * FROM get_total_balance_by_type() ORDER BY total_balance DESC;",
      "SELECT * FROM get_total_balance_by_type() WHERE account_type = 'Asset';",
      "SELECT * FROM get_total_balance_by_type() WHERE account_type = 'Liability';",
      "SELECT * FROM get_total_balance_by_type() WHERE account_type = 'Equity';",
      "SELECT * FROM get_total_balance_by_type() WHERE account_type = 'Revenue';",
      "SELECT * FROM get_total_balance_by_type() WHERE account_type = 'Expense';",
      "SELECT account_type, total_balance FROM get_total_balance_by_type() ORDER BY account_type;",
      "SELECT SUM(total_balance) AS grand_total FROM get_total_balance_by_type();",
      "SELECT COUNT(*) AS type_count FROM get_total_balance_by_type();",
      "SELECT * FROM get_total_balance_by_type() WHERE total_balance < 0;",
      "SELECT account_type, total_balance FROM get_total_balance_by_type() WHERE total_balance BETWEEN 1000 AND 50000;",
      "SELECT account_type, total_balance FROM get_total_balance_by_type() WHERE account_type LIKE 'Current%';",
      "SELECT account_type, total_balance FROM get_total_balance_by_type() WHERE account_type IN ('Asset', 'Liability');",
      "SELECT account_type, total_balance FROM get_total_balance_by_type() WHERE total_balance = (SELECT MAX(total_balance) FROM get_total_balance_by_type());",
      "SELECT account_type, total_balance FROM get_total_balance_by_type() WHERE total_balance = (SELECT MIN(total_balance) FROM get_total_balance_by_type());",
      "SELECT AVG(total_balance) AS average_balance FROM get_total_balance_by_type();",
      "SELECT account_type, total_balance FROM get_total_balance_by_type() WHERE total_balance > (SELECT AVG(total_balance) FROM get_total_balance_by_type());"
    ],
    "id": 135
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_region_popularity that accepts two input parameters: a bigint parameter named p_name_id representing a unique identifier for a name, and a bigint parameter named p_region_id representing a unique identifier for a region. The function returns a text value. The function begins by declaring a local variable v_popularity_score of type real to store a numeric popularity value. The function executes a SELECT query on the name_region_popularity table, aliased as nrp, to retrieve a single value. The query selects the value from the popularity_score column of the nrp table and assigns it to the v_popularity_score variable. The query includes a WHERE clause with two conditions joined by an AND operator: the first condition checks that the name_id column of the nrp table is equal to the input parameter p_name_id, and the second condition checks that the region_id column of the nrp table is equal to the input parameter p_region_id. After the SELECT operation, the function uses a series of conditional IF-ELSIF-ELSE statements to evaluate the value stored in v_popularity_score and return a corresponding descriptive text label. If v_popularity_score is greater than or equal to 0.7, the function returns the text 'Very Popular'. Otherwise, if v_popularity_score is greater than or equal to 0.4, the function returns the text 'Popular'. Otherwise, if v_popularity_score is greater than or equal to 0.1, the function returns the text 'Less Popular'. If none of the previous conditions are met, meaning v_popularity_score is less than 0.1, the function returns the text 'Not Popular'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_popularity(p_name_id bigint, p_region_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_popularity_score real;\nBEGIN\n    SELECT nrp.popularity_score INTO v_popularity_score\n    FROM name_region_popularity nrp\n    WHERE nrp.name_id = p_name_id AND nrp.region_id = p_region_id;\n    \n    IF v_popularity_score >= 0.7 THEN\n        RETURN 'Very Popular';\n    ELSIF v_popularity_score >= 0.4 THEN\n        RETURN 'Popular';\n    ELSIF v_popularity_score >= 0.1 THEN\n        RETURN 'Less Popular';\n    ELSE\n        RETURN 'Not Popular';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "baby_name_popularity_tracking_and_analytics",
    "tables": [
      "baby_names",
      "name_collection_names",
      "name_collections",
      "name_cultural_significance",
      "name_popularity_trends",
      "name_region_popularity",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_region_popularity(1, 1);",
      "SELECT get_region_popularity(0, 0);",
      "SELECT get_region_popularity(5, 3);",
      "SELECT get_region_popularity(10, 2);",
      "SELECT get_region_popularity(15, 4);",
      "SELECT get_region_popularity(20, 1);",
      "SELECT get_region_popularity(25, 5);",
      "SELECT get_region_popularity(30, 0);",
      "SELECT get_region_popularity(35, 2);",
      "SELECT get_region_popularity(40, 3);",
      "SELECT get_region_popularity(45, 4);",
      "SELECT get_region_popularity(50, 5);",
      "SELECT get_region_popularity(55, 1);",
      "SELECT get_region_popularity(60, 0);",
      "SELECT get_region_popularity(65, 2);",
      "SELECT get_region_popularity(70, 3);",
      "SELECT get_region_popularity(75, 4);",
      "SELECT get_region_popularity(80, 5);",
      "SELECT get_region_popularity(85, 1);",
      "SELECT get_region_popularity(90, 0);",
      "SELECT get_region_popularity(95, 2);"
    ],
    "id": 136
  },
  {
    "ir": "Write a PLpgSQL function named analyze_crime_distribution that accepts two parameters: para_location of type text, representing the location of the crime, and para_status of type text, indicating the status of the crime. The function returns a double precision value. The function begins by checking the value of para_status. If para_status is 'Cleared', it returns the cumulative distribution of crime_id values from the crime_data table, ordered by crime_id, for records where the location matches para_location and the status is 'Cleared'. This is achieved using the cume_dist() window function, and only the first result is returned due to the LIMIT 1 clause. If para_status is 'Pending', the function updates the crime_data table by setting the cleared_by column to 'Auto-Assignment' for all records where the location matches para_location. If para_status is 'Under Investigation', the function deletes records from the crime_data table where the location matches para_location and the status is 'Closed'. If para_status does not match any of the specified conditions, the function inserts a new record into the crime_data table with a crime_id that is one greater than the current maximum crime_id, the specified para_location, and para_status. The crime_id is determined using a subquery that selects the maximum crime_id from the crime_data table, defaulting to 0 if no records exist, and adding 1 to this value. After performing the appropriate operation based on the para_status, the function returns a constant value of 1.0.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_crime_distribution(para_location text, para_status text) RETURNS double precision LANGUAGE plpgsql AS $$\nBEGIN\n    IF para_status = 'Cleared' THEN\n        RETURN (SELECT cume_dist() OVER (ORDER BY crime_id) FROM crime_data WHERE location = para_location AND status = para_status LIMIT 1);\n    ELSIF para_status = 'Pending' THEN\n        UPDATE crime_data SET cleared_by = 'Auto-Assignment' WHERE location = para_location;\n    ELSIF para_status = 'Under Investigation' THEN\n        DELETE FROM crime_data WHERE location = para_location AND status = 'Closed';\n    ELSE\n        INSERT INTO crime_data (crime_id, location, status) VALUES ((SELECT COALESCE(MAX(crime_id), 0) + 1 FROM crime_data), para_location, para_status);\n    END IF;\n    RETURN 1.0;\nEND;\n$$;",
    "database_name": "municipal_performance_and_crime_rate_tracking",
    "tables": [
      "citizen_satisfaction",
      "crime_data",
      "performance_measures",
      "users"
    ],
    "call_sqls": [
      "SELECT analyze_crime_distribution('Downtown', 'Cleared');",
      "SELECT analyze_crime_distribution('Northside', 'Pending');",
      "SELECT analyze_crime_distribution('West End', 'Under Investigation');",
      "SELECT analyze_crime_distribution('Eastside', 'Open');",
      "SELECT analyze_crime_distribution('Central Park', 'Cleared');",
      "SELECT analyze_crime_distribution('Suburbs', 'Pending');",
      "SELECT analyze_crime_distribution('Industrial Zone', 'Under Investigation');",
      "SELECT analyze_crime_distribution('University District', 'Reported');",
      "SELECT analyze_crime_distribution('Financial District', 'Cleared');",
      "SELECT analyze_crime_distribution('Waterfront', 'Pending');",
      "SELECT analyze_crime_distribution('Old Town', 'Under Investigation');",
      "SELECT analyze_crime_distribution('Shopping Mall', 'New');",
      "SELECT analyze_crime_distribution('Airport', 'Cleared');",
      "SELECT analyze_crime_distribution('Train Station', 'Pending');",
      "SELECT analyze_crime_distribution('Hospital Area', 'Under Investigation');",
      "SELECT analyze_crime_distribution('Residential Block A', 'Active');",
      "SELECT analyze_crime_distribution('City Hall', 'Cleared');",
      "SELECT analyze_crime_distribution('Police Precinct', 'Pending');",
      "SELECT analyze_crime_distribution('Library', 'Under Investigation');",
      "SELECT analyze_crime_distribution('Parking Garage', 'Unassigned');"
    ],
    "id": 137
  },
  {
    "ir": "Write a PostgreSQL stored procedure named sp_analyze_fuel_efficiency_trends that accepts one input parameter para_min_horsepower of type bigint, which is used as the minimum horsepower threshold for filtering engine configurations, then declares two local real variables v_avg_efficiency and v_max_efficiency, and proceeds to calculate and store into these variables the average and maximum mpg values from the performance_metrics table by performing a join with the vehicles table on vehicle_id, a join with the vehicle_engines table on vehicle_id, and a join with the engine_configurations table on engine_id, specifically selecting only those records where the horsepower from engine_configurations is greater than or equal to the provided para_min_horsepower, then evaluates the calculated average efficiency: if v_avg_efficiency is less than 20.0, it inserts a new record into the fuel_types table with a fuel_id calculated as the current maximum fuel_id value from the fuel_types table (or 0 if the table is empty, using COALESCE) incremented by 1, a fuel_type set to 'Premium Synthetic', a description set to 'High-performance synthetic fuel blend', an octane_rating of 98, and a fuel_efficiency calculated as the stored v_max_efficiency multiplied by 1.1; else if v_avg_efficiency is greater than 30.0, it inserts a new record into fuel_types with a similarly calculated fuel_id, a fuel_type set to 'Eco Blend', a description set to 'Environmentally friendly fuel mixture', an octane_rating of 91, and a fuel_efficiency calculated as the stored v_avg_efficiency multiplied by 1.05; otherwise, for the case where the average efficiency is between 20.0 and 30.0 inclusive, it updates the fuel_types table by increasing the fuel_efficiency column value by 2 percent (multiplying by 1.02) for all existing records where the octane_rating is greater than 90.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_analyze_fuel_efficiency_trends(para_min_horsepower bigint) LANGUAGE plpgsql AS $$\nDECLARE\n    v_avg_efficiency real;\n    v_max_efficiency real;\nBEGIN\n    SELECT AVG(pm.mpg), MAX(pm.mpg) INTO v_avg_efficiency, v_max_efficiency\n    FROM performance_metrics pm\n    JOIN vehicles v ON pm.vehicle_id = v.vehicle_id\n    JOIN vehicle_engines ve ON v.vehicle_id = ve.vehicle_id\n    JOIN engine_configurations ec ON ve.engine_id = ec.engine_id\n    WHERE ec.horsepower >= para_min_horsepower;\n    \n    IF v_avg_efficiency < 20.0 THEN\n        INSERT INTO fuel_types (fuel_id, fuel_type, description, octane_rating, fuel_efficiency)\n        VALUES (\n            (SELECT COALESCE(MAX(fuel_id), 0) FROM fuel_types) + 1,\n            'Premium Synthetic',\n            'High-performance synthetic fuel blend',\n            98,\n            v_max_efficiency * 1.1\n        );\n    ELSIF v_avg_efficiency > 30.0 THEN\n        INSERT INTO fuel_types (fuel_id, fuel_type, description, octane_rating, fuel_efficiency)\n        VALUES (\n            (SELECT COALESCE(MAX(fuel_id), 0) FROM fuel_types) + 1,\n            'Eco Blend',\n            'Environmentally friendly fuel mixture',\n            91,\n            v_avg_efficiency * 1.05\n        );\n    ELSE\n        UPDATE fuel_types \n        SET fuel_efficiency = fuel_efficiency * 1.02\n        WHERE octane_rating > 90;\n    END IF;\nEND;\n$$;",
    "database_name": "automobile_performance_and_specifications_608088",
    "tables": [
      "vehicles",
      "vehicle_engines",
      "engine_configurations",
      "fuel_types",
      "performance_metrics"
    ],
    "call_sqls": [
      "CALL sp_analyze_fuel_efficiency_trends(100);",
      "CALL sp_analyze_fuel_efficiency_trends(150);",
      "CALL sp_analyze_fuel_efficiency_trends(200);",
      "CALL sp_analyze_fuel_efficiency_trends(250);",
      "CALL sp_analyze_fuel_efficiency_trends(300);",
      "CALL sp_analyze_fuel_efficiency_trends(50);",
      "CALL sp_analyze_fuel_efficiency_trends(75);",
      "CALL sp_analyze_fuel_efficiency_trends(125);",
      "CALL sp_analyze_fuel_efficiency_trends(175);",
      "CALL sp_analyze_fuel_efficiency_trends(225);",
      "CALL sp_analyze_fuel_efficiency_trends(275);",
      "CALL sp_analyze_fuel_efficiency_trends(325);",
      "CALL sp_analyze_fuel_efficiency_trends(350);",
      "CALL sp_analyze_fuel_efficiency_trends(400);",
      "CALL sp_analyze_fuel_efficiency_trends(450);",
      "CALL sp_analyze_fuel_efficiency_trends(500);",
      "CALL sp_analyze_fuel_efficiency_trends(0);",
      "CALL sp_analyze_fuel_efficiency_trends(600);",
      "CALL sp_analyze_fuel_efficiency_trends(700);",
      "CALL sp_analyze_fuel_efficiency_trends(800);"
    ],
    "id": 138
  },
  {
    "ir": "Write a PLpgSQL function named calculate_employee_cbrt_age that accepts three parameters: p_emp_id of type BIGINT, p_first_name of type TEXT, and p_last_name of type TEXT. This function is designed to calculate the cube root of an employee's age based on their date of birth stored in the employees table. The function begins by declaring three local variables: birth_date of type DATE, age of type DOUBLE PRECISION, and cbrt_age_val of type DOUBLE PRECISION. It then performs a SELECT operation to retrieve the date_of_birth column from the employees table, casting it to DATE, where the employee_id matches the p_emp_id parameter, and both the first_name and last_name match the p_first_name and p_last_name parameters, respectively. The result of this query is stored in the birth_date variable. The function checks if birth_date is not NULL, indicating that a matching employee record was found. If so, it calculates the age by extracting the year component from the interval between the current date and the birth_date using the AGE function, and assigns this value to the age variable. Subsequently, it computes the cube root of the age using the cbrt function and stores the result in cbrt_age_val. If no matching employee record is found, the function assigns NULL to cbrt_age_val. Finally, the function returns the value of cbrt_age_val.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_employee_cbrt_age(\n    p_emp_id BIGINT,\n    p_first_name TEXT,\n    p_last_name TEXT\n)\nRETURNS DOUBLE PRECISION\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    birth_date DATE;\n    age DOUBLE PRECISION;\n    cbrt_age_val DOUBLE PRECISION;\nBEGIN\n    SELECT date_of_birth::DATE\n    INTO birth_date\n    FROM employees\n    WHERE employee_id = p_emp_id\n      AND first_name = p_first_name\n      AND last_name = p_last_name;\n\n    IF birth_date IS NOT NULL THEN\n        age := EXTRACT(YEAR FROM AGE(birth_date));\n        cbrt_age_val := cbrt(age);\n    ELSE\n        cbrt_age_val := NULL; -- Or raise an exception if an employee must be found\n    END IF;\n\n    RETURN cbrt_age_val;\nEND;\n$$;",
    "database_name": "work_shift_scheduling_and_management",
    "tables": [
      "employees"
    ],
    "call_sqls": [
      "SELECT calculate_employee_cbrt_age(0, 'Alice', 'Johnson');",
      "SELECT calculate_employee_cbrt_age(1, 'Bob', 'Smith');",
      "SELECT calculate_employee_cbrt_age(2, 'Charlie', 'Brown');",
      "SELECT calculate_employee_cbrt_age(3, 'Diana', 'Prince');",
      "SELECT calculate_employee_cbrt_age(4, 'Edward', 'King');",
      "SELECT calculate_employee_cbrt_age(5, 'Fiona', 'Green');",
      "SELECT calculate_employee_cbrt_age(6, 'George', 'Lucas');",
      "SELECT calculate_employee_cbrt_age(7, 'Hannah', 'Montana');",
      "SELECT calculate_employee_cbrt_age(8, 'Ian', 'Fleming');",
      "SELECT calculate_employee_cbrt_age(9, 'Julia', 'Roberts');",
      "SELECT calculate_employee_cbrt_age(10, 'Kevin', 'Bacon');",
      "SELECT calculate_employee_cbrt_age(11, 'Laura', 'Palmer');",
      "SELECT calculate_employee_cbrt_age(12, 'Michael', 'Scott');",
      "SELECT calculate_employee_cbrt_age(13, 'Nancy', 'Drew');",
      "SELECT calculate_employee_cbrt_age(14, 'Oscar', 'Wilde');",
      "SELECT calculate_employee_cbrt_age(15, 'Pamela', 'Anderson');",
      "SELECT calculate_employee_cbrt_age(16, 'Quentin', 'Tarantino');",
      "SELECT calculate_employee_cbrt_age(17, 'Rachel', 'Green');",
      "SELECT calculate_employee_cbrt_age(18, 'Steve', 'Jobs');",
      "SELECT calculate_employee_cbrt_age(19, 'Tina', 'Fey');"
    ],
    "id": 139
  },
  {
    "ir": "Write a PostgreSQL function named get_video_file_info that accepts a single parameter video_id of type TEXT and returns a table with three columns: file_name of type TEXT, upload_date of type TEXT, and file_size of type REAL, where the function first checks if a record exists in the video_files table with a video_file_id matching the provided video_id parameter, and if such a record exists, the function returns a query result that selects the file_name, upload_date, and file_size columns from the video_files table (aliased as vf) where the video_file_id equals the provided video_id parameter, otherwise the function returns an empty result set.",
    "plsql": "CREATE OR REPLACE FUNCTION get_video_file_info(video_id TEXT) RETURNS TABLE(file_name TEXT, upload_date TEXT, file_size REAL) AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM video_files WHERE video_file_id = video_id) THEN\n        RETURN QUERY\n        SELECT vf.file_name, vf.upload_date, vf.file_size\n        FROM video_files AS vf\n        WHERE vf.video_file_id = video_id;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "video_activity_analysis_and_tracking",
    "tables": [
      "annotations",
      "video_files"
    ],
    "call_sqls": [
      "SELECT * FROM get_video_file_info('0');",
      "SELECT * FROM get_video_file_info('1');",
      "SELECT * FROM get_video_file_info('2');",
      "SELECT * FROM get_video_file_info('3');",
      "SELECT * FROM get_video_file_info('4');",
      "SELECT * FROM get_video_file_info('5');",
      "SELECT * FROM get_video_file_info('6');",
      "SELECT * FROM get_video_file_info('7');",
      "SELECT * FROM get_video_file_info('8');",
      "SELECT * FROM get_video_file_info('9');",
      "SELECT * FROM get_video_file_info('10');",
      "SELECT * FROM get_video_file_info('video_001');",
      "SELECT * FROM get_video_file_info('video_002');",
      "SELECT * FROM get_video_file_info('sample_video');",
      "SELECT * FROM get_video_file_info('test_video');",
      "SELECT * FROM get_video_file_info('demo_video');",
      "SELECT * FROM get_video_file_info('V12345');",
      "SELECT * FROM get_video_file_info('V67890');",
      "SELECT * FROM get_video_file_info('abc123');",
      "SELECT * FROM get_video_file_info('xyz789');",
      "SELECT * FROM get_video_file_info('movie_clip');"
    ],
    "id": 140
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_user_id of type bigint and returns a bigint. The function begins by declaring a local variable v_model_count of type bigint. It then performs a SELECT operation to count the number of rows in the cinematic_models table where the created_by column matches the provided p_user_id parameter, storing the result into the v_model_count variable. If the count of models is zero, the function sets v_model_count to -1. Finally, the function returns the value of v_model_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_model_stats(p_user_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    v_model_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_model_count\n    FROM cinematic_models\n    WHERE created_by = p_user_id;\n    \n    IF v_model_count = 0 THEN\n        v_model_count := -1;\n    END IF;\n    \n    RETURN v_model_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cinematic_modeling_and_annotation_management",
    "tables": [
      "cinematic_models",
      "cinematic_elements",
      "element_attributes",
      "model_versions",
      "users"
    ],
    "call_sqls": [
      "SELECT get_user_model_stats(1);",
      "SELECT get_user_model_stats(2);",
      "SELECT get_user_model_stats(3);",
      "SELECT get_user_model_stats(4);",
      "SELECT get_user_model_stats(5);",
      "SELECT get_user_model_stats(10);",
      "SELECT get_user_model_stats(15);",
      "SELECT get_user_model_stats(20);",
      "SELECT get_user_model_stats(25);",
      "SELECT get_user_model_stats(30);",
      "SELECT get_user_model_stats(35);",
      "SELECT get_user_model_stats(40);",
      "SELECT get_user_model_stats(45);",
      "SELECT get_user_model_stats(50);",
      "SELECT get_user_model_stats(55);",
      "SELECT get_user_model_stats(60);",
      "SELECT get_user_model_stats(65);",
      "SELECT get_user_model_stats(70);",
      "SELECT get_user_model_stats(75);",
      "SELECT get_user_model_stats(80);",
      "SELECT get_user_model_stats(100);"
    ],
    "id": 141
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `insert_researcher` that accepts five input parameters: `p_first_name` of type `text`, intended to represent the first name of the researcher; `p_last_name` of type `text`, intended to represent the last name of the researcher; `p_email` of type `text`, intended to represent the email address of the researcher; `p_role` of type `text`, intended to represent the role of the researcher; and `p_department` of type `text`, intended to represent the department of the researcher. The procedure declares a local variable named `next_id` of type `bigint`. The procedure's execution begins by performing a `SELECT` operation on the `researchers` table. Specifically, it calculates the maximum value present in the `researcher_id` column. If no rows exist in the `researchers` table, or if the `MAX(researcher_id)` returns `NULL`, the `COALESCE` function ensures that `0` is used instead. This result is then incremented by `1`, and the final calculated value is assigned to the `next_id` variable. Following this, the procedure executes an `INSERT` operation into the `researchers` table. The `INSERT` statement populates the `researcher_id` column with the value stored in the `next_id` variable, the `first_name` column with the value from the `p_first_name` input parameter, the `last_name` column with the value from the `p_last_name` input parameter, the `email` column with the value from the `p_email` input parameter, the `role` column with the value from the `p_role` input parameter, and the `department` column with the value from the `p_department` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_researcher(\n    IN p_first_name text,\n    IN p_last_name text,\n    IN p_email text,\n    IN p_role text,\n    IN p_department text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    next_id bigint;\nBEGIN\n    SELECT COALESCE(MAX(researcher_id), 0) + 1 INTO next_id FROM researchers;\n    \n    INSERT INTO researchers (researcher_id, first_name, last_name, email, role, department)\n    VALUES (next_id, p_first_name, p_last_name, p_email, p_role, p_department);\nEND;\n$$;",
    "database_name": "behavioral_psychology_experiment_data_management",
    "tables": [
      "experiments",
      "exp_types",
      "researchers",
      "blocks",
      "conditions",
      "exp_conditions",
      "block_conditions",
      "trials",
      "trial_conditions"
    ],
    "call_sqls": [
      "CALL insert_researcher('John', 'Smith', 'john.smith@research.edu', 'Senior Researcher', 'Neuroscience');",
      "CALL insert_researcher('Emma', 'Johnson', 'emma.johnson@lab.org', 'Lab Technician', 'Psychology');",
      "CALL insert_researcher('Michael', 'Brown', 'm.brown@institute.com', 'Principal Investigator', 'Cognitive Science');",
      "CALL insert_researcher('Sarah', 'Davis', 'sarah.davis@uni.edu', 'Postdoctoral Fellow', 'Biology');",
      "CALL insert_researcher('David', 'Wilson', 'dwilson@research.edu', 'Research Assistant', 'Engineering');",
      "CALL insert_researcher('Lisa', 'Miller', 'lisa.miller@lab.org', 'Data Analyst', 'Statistics');",
      "CALL insert_researcher('James', 'Taylor', 'j.taylor@institute.com', 'Graduate Student', 'Computer Science');",
      "CALL insert_researcher('Maria', 'Anderson', 'manderson@uni.edu', 'Professor', 'Physics');",
      "CALL insert_researcher('Robert', 'Thomas', 'robert.thomas@research.edu', 'Technician', 'Chemistry');",
      "CALL insert_researcher('Jennifer', 'Jackson', 'j.jackson@lab.org', 'Coordinator', 'Administration');",
      "CALL insert_researcher('William', 'White', 'wwhite@institute.com', 'Ethics Officer', 'Compliance');",
      "CALL insert_researcher('Patricia', 'Harris', 'p.harris@uni.edu', 'Statistician', 'Mathematics');",
      "CALL insert_researcher('Charles', 'Martin', 'charles.martin@research.edu', 'Engineer', 'Robotics');",
      "CALL insert_researcher('Elizabeth', 'Thompson', 'e.thompson@lab.org', 'Psychologist', 'Clinical Research');",
      "CALL insert_researcher('Joseph', 'Garcia', 'j.garcia@institute.com', 'Biologist', 'Genetics');",
      "CALL insert_researcher('Susan', 'Martinez', 's.martinez@uni.edu', 'Researcher', 'Environmental Science');",
      "CALL insert_researcher('Thomas', 'Robinson', 't.robinson@research.edu', 'Assistant Professor', 'Sociology');",
      "CALL insert_researcher('Karen', 'Clark', 'k.clark@lab.org', 'Lab Manager', 'Operations');",
      "CALL insert_researcher('Christopher', 'Rodriguez', 'c.rodriguez@institute.com', 'Developer', 'Software');",
      "CALL insert_researcher('Nancy', 'Lewis', 'n.lewis@uni.edu', 'Archivist', 'Data Management');"
    ],
    "id": 142
  },
  {
    "ir": "Write a PLpgSQL function named get_palette_summary_text that accepts a single input parameter p_palette_id of type bigint and returns a text value, which first declares three local variables: palette_name of type text, palette_type of type text, and summary_text of type text, then executes a SELECT query on the color_palettes table (aliased as cp) to retrieve the values from the name and palette_type columns where the palette_id column matches the input parameter p_palette_id, storing these values in the palette_name and palette_type variables respectively, then evaluates a conditional statement that checks if the palette_type variable equals the string 'marketing', and if this condition is true, constructs the summary_text variable by concatenating the result of the repeat function call with arguments 'PROMO-' and 3 (which produces 'PROMO-PROMO-PROMO-') with the palette_name variable, otherwise if the condition is false, constructs the summary_text variable by concatenating the palette_name variable with the string ' Standard', and finally returns the constructed summary_text value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_palette_summary_text(p_palette_id bigint)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    palette_name text;\n    palette_type text;\n    summary_text text;\nBEGIN\n    SELECT cp.name, cp.palette_type INTO palette_name, palette_type\n    FROM color_palettes cp\n    WHERE cp.palette_id = p_palette_id;\n    \n    IF palette_type = 'marketing' THEN\n        summary_text := repeat('PROMO-', 3) || palette_name;\n    ELSE\n        summary_text := palette_name || ' Standard';\n    END IF;\n    \n    RETURN summary_text;\nEND;\n$$;",
    "database_name": "color_management_system",
    "tables": [
      "colors",
      "color_versions",
      "color_palettes",
      "palette_colors",
      "projects",
      "color_usage"
    ],
    "call_sqls": [
      "SELECT get_palette_summary_text(1);",
      "SELECT get_palette_summary_text(2);",
      "SELECT get_palette_summary_text(3);",
      "SELECT get_palette_summary_text(4);",
      "SELECT get_palette_summary_text(5);",
      "SELECT get_palette_summary_text(6);",
      "SELECT get_palette_summary_text(7);",
      "SELECT get_palette_summary_text(8);",
      "SELECT get_palette_summary_text(9);",
      "SELECT get_palette_summary_text(10);",
      "SELECT get_palette_summary_text(11);",
      "SELECT get_palette_summary_text(12);",
      "SELECT get_palette_summary_text(13);",
      "SELECT get_palette_summary_text(14);",
      "SELECT get_palette_summary_text(15);",
      "SELECT get_palette_summary_text(16);",
      "SELECT get_palette_summary_text(17);",
      "SELECT get_palette_summary_text(18);",
      "SELECT get_palette_summary_text(19);",
      "SELECT get_palette_summary_text(20);"
    ],
    "id": 143
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_project_status that accepts a single input parameter p_project_id of type NUMBER, which represents the unique identifier for a project, and returns a VARCHAR2 value; this function declares a local variable v_status of type VARCHAR2(255) to store the result, then executes a SELECT statement that queries the project_assignments table, specifically counting the number of assignment_id entries for the row where the project_id column matches the provided p_project_id parameter, and uses a CASE expression to evaluate this count: if the count of assignment_id is greater than 3, the function assigns the string 'fully_staffed' to v_status; if the count is greater than 0 but not greater than 3, it assigns the string 'partially_staffed' to v_status; if the count is 0, it assigns the string 'unstaffed' to v_status, and finally, the function returns the value stored in v_status.",
    "plsql": "CREATE OR REPLACE FUNCTION get_project_status(p_project_id NUMBER) RETURN VARCHAR2 IS\n  v_status VARCHAR2(255);\nBEGIN\n  SELECT CASE \n    WHEN COUNT(pa.assignment_id) > 3 THEN 'fully_staffed'\n    WHEN COUNT(pa.assignment_id) > 0 THEN 'partially_staffed'\n    ELSE 'unstaffed'\n  END INTO v_status\n  FROM project_assignments pa\n  WHERE pa.project_id = p_project_id;\n  RETURN v_status;\nEND;",
    "database_name": "astronomical_dca_analysis",
    "tables": [
      "project_assignments",
      "research_projects"
    ],
    "call_sqls": [
      "SELECT get_project_status(0) FROM DUAL",
      "SELECT get_project_status(1) FROM DUAL",
      "SELECT get_project_status(2) FROM DUAL",
      "SELECT get_project_status(10) FROM DUAL",
      "SELECT get_project_status(15) FROM DUAL",
      "SELECT get_project_status(25) FROM DUAL",
      "SELECT get_project_status(100) FROM DUAL",
      "SELECT get_project_status(500) FROM DUAL",
      "SELECT get_project_status(1000) FROM DUAL",
      "SELECT get_project_status(p_project_id => 7) FROM DUAL",
      "SELECT get_project_status(p_project_id => 12) FROM DUAL",
      "SELECT get_project_status(p_project_id => 18) FROM DUAL",
      "SELECT get_project_status(p_project_id => 22) FROM DUAL",
      "SELECT get_project_status(p_project_id => 30) FROM DUAL",
      "SELECT get_project_status(p_project_id => 42) FROM DUAL",
      "SELECT get_project_status(p_project_id => 55) FROM DUAL",
      "SELECT get_project_status(p_project_id => 67) FROM DUAL",
      "SELECT get_project_status(p_project_id => 73) FROM DUAL",
      "SELECT get_project_status(p_project_id => 88) FROM DUAL",
      "SELECT get_project_status(p_project_id => 99) FROM DUAL"
    ],
    "id": 144
  },
  {
    "ir": "Write a PLpgSQL function that calculates the total maintenance cost for a specific piece of equipment identified by the parameter equip_id of type text. This function declares a variable total_cost of type real to store the result. It performs a SELECT operation to sum the values in the maintenance_cost column from the equipment_maintenance_history table, where the equipment_id column matches the provided equip_id parameter. The result of this summation is stored into the total_cost variable. The function then returns the total_cost, using the COALESCE function to ensure that if the total_cost is NULL, it returns 0 instead.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_maintenance_cost(equip_id text) RETURNS real AS $$\nDECLARE\n    total_cost real;\nBEGIN\n    SELECT SUM(maintenance_cost) INTO total_cost\n    FROM equipment_maintenance_history\n    WHERE equipment_id = equip_id;\n    RETURN COALESCE(total_cost, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "construction_equipment_management_and_operations",
    "tables": [
      "equipment",
      "equipment_maintenance_history",
      "maintenance_schedules"
    ],
    "call_sqls": [
      "SELECT calculate_total_maintenance_cost('EQP-001');",
      "SELECT calculate_total_maintenance_cost('EQP-002');",
      "SELECT calculate_total_maintenance_cost('CRANE-101');",
      "SELECT calculate_total_maintenance_cost('EXCAV-202');",
      "SELECT calculate_total_maintenance_cost('TRUCK-305');",
      "SELECT calculate_total_maintenance_cost('GEN-450');",
      "SELECT calculate_total_maintenance_cost('COMP-789');",
      "SELECT calculate_total_maintenance_cost('LIFT-556');",
      "SELECT calculate_total_maintenance_cost('PUMP-321');",
      "SELECT calculate_total_maintenance_cost('TOOL-999');",
      "SELECT calculate_total_maintenance_cost('EQP-12345');",
      "SELECT calculate_total_maintenance_cost('MACH-888');",
      "SELECT calculate_total_maintenance_cost('VEH-777');",
      "SELECT calculate_total_maintenance_cost('SYS-654');",
      "SELECT calculate_total_maintenance_cost('UNIT-333');",
      "SELECT calculate_total_maintenance_cost('DEV-222');",
      "SELECT calculate_total_maintenance_cost('APP-111');",
      "SELECT calculate_total_maintenance_cost('EQP-ABC-2024');",
      "SELECT calculate_total_maintenance_cost('EQP-XYZ-2023');",
      "SELECT calculate_total_maintenance_cost('TEST-001');"
    ],
    "id": 145
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_user_permission_name that accepts a single input parameter p_permission_id of the NUMBER data type and returns a VARCHAR2 value, which executes a SELECT operation on the user_permissions table to retrieve the permission_name column value by querying the row where the permission_id column exactly matches the provided input parameter p_permission_id, storing the result into a local variable v_permission_name, and then returns this retrieved permission_name value, while also handling the specific exception condition NO_DATA_FOUND by returning a NULL value if no row is found in the user_permissions table with the given permission_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_permission_name(p_permission_id NUMBER) RETURN VARCHAR2 IS\n  v_permission_name VARCHAR2(255);\nBEGIN\n  SELECT permission_name\n    INTO v_permission_name\n    FROM user_permissions\n   WHERE permission_id = p_permission_id;\n  \n  RETURN v_permission_name;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\nEND;",
    "database_name": "airport_i_management",
    "tables": [
      "users",
      "user_permissions",
      "user_role_permissions",
      "airport_versions",
      "airport_types"
    ],
    "call_sqls": [
      "SELECT get_user_permission_name(1) FROM DUAL",
      "SELECT get_user_permission_name(2) FROM DUAL",
      "SELECT get_user_permission_name(3) FROM DUAL",
      "SELECT get_user_permission_name(4) FROM DUAL",
      "SELECT get_user_permission_name(5) FROM DUAL",
      "SELECT get_user_permission_name(10) FROM DUAL",
      "SELECT get_user_permission_name(15) FROM DUAL",
      "SELECT get_user_permission_name(20) FROM DUAL",
      "SELECT get_user_permission_name(25) FROM DUAL",
      "SELECT get_user_permission_name(50) FROM DUAL",
      "SELECT get_user_permission_name(100) FROM DUAL",
      "SELECT get_user_permission_name(101) FROM DUAL",
      "SELECT get_user_permission_name(102) FROM DUAL",
      "SELECT get_user_permission_name(103) FROM DUAL",
      "SELECT get_user_permission_name(104) FROM DUAL",
      "SELECT get_user_permission_name(105) FROM DUAL",
      "SELECT get_user_permission_name(106) FROM DUAL",
      "SELECT get_user_permission_name(107) FROM DUAL",
      "SELECT get_user_permission_name(108) FROM DUAL",
      "SELECT get_user_permission_name(109) FROM DUAL",
      "SELECT get_user_permission_name(110) FROM DUAL"
    ],
    "id": 146
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_best_performance_in_meet that accepts a single input parameter p_meet_id of type bigint and returns a bigint value. The function declares two local variables: v_best_points of type bigint and v_meet_name of type text. The function first executes a SELECT query on the performances table to find the maximum value in the points column for all rows where the meet_id column matches the input parameter p_meet_id, storing this maximum value in the v_best_points variable. Then, the function executes a second SELECT query on the meets table to retrieve the meet_name value for the row where the meet_id column matches the input parameter p_meet_id, storing this value in the v_meet_name variable. Finally, the function returns the value stored in v_best_points, which represents the highest points achieved in the specified meet.",
    "plsql": "CREATE OR REPLACE FUNCTION get_best_performance_in_meet(p_meet_id bigint) RETURNS bigint AS $$\nDECLARE\n    v_best_points bigint;\n    v_meet_name text;\nBEGIN\n    SELECT MAX(points) INTO v_best_points FROM performances WHERE meet_id = p_meet_id;\n    SELECT meet_name INTO v_meet_name FROM meets WHERE meet_id = p_meet_id;\n    RETURN v_best_points;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "collegiate_track_and_field_performance_tracking",
    "tables": [
      "athletes",
      "performances",
      "meets",
      "teams",
      "athlete_statistics"
    ],
    "call_sqls": [
      "SELECT get_best_performance_in_meet(0);",
      "SELECT get_best_performance_in_meet(1);",
      "SELECT get_best_performance_in_meet(2);",
      "SELECT get_best_performance_in_meet(3);",
      "SELECT get_best_performance_in_meet(4);",
      "SELECT get_best_performance_in_meet(5);",
      "SELECT get_best_performance_in_meet(6);",
      "SELECT get_best_performance_in_meet(7);",
      "SELECT get_best_performance_in_meet(8);",
      "SELECT get_best_performance_in_meet(9);",
      "SELECT get_best_performance_in_meet(10);",
      "SELECT get_best_performance_in_meet(11);",
      "SELECT get_best_performance_in_meet(12);",
      "SELECT get_best_performance_in_meet(13);",
      "SELECT get_best_performance_in_meet(14);",
      "SELECT get_best_performance_in_meet(15);",
      "SELECT get_best_performance_in_meet(16);",
      "SELECT get_best_performance_in_meet(17);",
      "SELECT get_best_performance_in_meet(18);",
      "SELECT get_best_performance_in_meet(19);"
    ],
    "id": 147
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_player_stats_on_injury that is automatically executed by a trigger named trg_update_player_stats_on_injury after every INSERT operation on the player_injuries table for each newly inserted row; the function takes no explicit parameters but accesses the new row's data via the special NEW record variable, which contains the column values of the inserted row in player_injuries; the function performs a DELETE operation on the player_stats table where the condition matches the player_id column from the NEW record and the season_id column from the NEW record, thereby removing any existing record in player_stats for that specific player and season combination whenever a new injury record is added; the function concludes by returning the NEW row to the invoking AFTER INSERT trigger.",
    "plsql": "CREATE OR REPLACE FUNCTION update_player_stats_on_injury() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM player_stats\n    WHERE player_id = NEW.player_id AND season_id = NEW.season_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_player_stats_on_injury\nAFTER INSERT ON player_injuries\nFOR EACH ROW EXECUTE FUNCTION update_player_stats_on_injury();",
    "database_name": "professional_basketball_player_and_team_management",
    "tables": [
      "game_statistics",
      "games",
      "leagues",
      "player_injuries",
      "player_stats",
      "players",
      "seasons",
      "team_rosters",
      "team_schedules",
      "teams"
    ],
    "call_sqls": [
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (100, 0, 0, '2023-12-01', '2024-01-15', 'Knee sprain', 'Sprain', 'Moderate');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (101, 1, 0, '2023-11-10', '2024-02-01', 'Hamstring tear', 'Strain', 'Major');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (103, 2, 0, '2023-10-05', '2023-12-01', 'Concussion', 'Head', 'Minor');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (104, 3, 1, '2024-02-15', NULL, 'Shoulder dislocation', 'Dislocation', 'Moderate');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (105, 5, 0, '2023-09-01', '2023-09-15', 'Calf tightness', 'Strain', 'Minor');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (106, 7, 1, '2024-03-01', '2024-04-01', 'Wrist sprain', 'Sprain', 'Moderate');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (107, 10, 0, '2023-12-25', '2024-01-10', 'Back spasms', 'Muscle', 'Minor');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (108, 0, 2, '2024-10-01', '2024-11-01', 'Groin strain', 'Strain', 'Moderate');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (109, 15, 1, '2024-01-05', '2024-05-01', 'ACL tear', 'Ligament', 'Major');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (110, 8, 0, '2023-11-30', '2024-01-30', 'Foot stress fracture', 'Fracture', 'Major');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (111, 12, 1, '2024-02-28', NULL, 'Elbow tendinitis', 'Tendon', 'Minor');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (112, 4, 0, '2023-10-20', '2023-11-05', 'Hip pointer', 'Contusion', 'Minor');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (113, 6, 1, '2024-03-15', '2024-06-01', 'Achilles tear', 'Tendon', 'Major');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (114, 9, 0, '2023-12-10', '2024-01-01', 'Finger dislocation', 'Dislocation', 'Minor');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (115, 11, 1, '2024-01-15', '2024-02-15', 'Quadriceps strain', 'Strain', 'Moderate');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (116, 13, 0, '2023-09-15', '2023-10-01', 'Rib contusion', 'Contusion', 'Minor');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (117, 14, 1, '2024-02-01', '2024-03-01', 'Knee contusion', 'Contusion', 'Minor');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (118, 16, 0, '2023-11-05', '2023-12-01', 'Ankle sprain', 'Sprain', 'Moderate');",
      "INSERT INTO player_injuries (injury_id, player_id, season_id, injury_date, recovery_date, description, injury_type, injury_severity) VALUES (119, 17, 1, '2024-03-20', NULL, 'Shoulder impingement', 'Joint', 'Moderate');"
    ],
    "id": 148
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_model_performance_summary` that accepts a single input parameter, `p_model_id`, which is of type `bigint`. This function is designed to return a `text` value representing a performance summary for a specific model. The function's core logic involves executing a `SELECT` statement against the `model_evaluations` table. This `SELECT` statement filters records where the `model_id` column matches the value provided by the `p_model_id` input parameter. Within the filtered results, the function calculates the average of the `value` column specifically for rows where the `metric` column is equal to the string literal 'accuracy'. This average accuracy value is then used in a `CASE` expression to determine the performance summary. If the calculated average accuracy is greater than or equal to `0.9`, the function returns the string literal 'Excellent Performance'. If the average accuracy is not greater than or equal to `0.9` but is greater than or equal to `0.8`, it returns the string literal 'Good Performance'. If the average accuracy is not greater than or equal to `0.8` but is greater than or equal to `0.7`, it returns the string literal 'Average Performance'. In all other scenarios, meaning if the average accuracy is less than `0.7`, the function returns the string literal 'Poor Performance'. The result of this `CASE` expression is the final `text` value returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_model_performance_summary(p_model_id bigint)\nRETURNS text AS $$\nBEGIN\n    RETURN (\n        SELECT CASE \n            WHEN AVG(CASE WHEN metric = 'accuracy' THEN value END) >= 0.9 THEN 'Excellent Performance'\n            WHEN AVG(CASE WHEN metric = 'accuracy' THEN value END) >= 0.8 THEN 'Good Performance'\n            WHEN AVG(CASE WHEN metric = 'accuracy' THEN value END) >= 0.7 THEN 'Average Performance'\n            ELSE 'Poor Performance'\n        END\n        FROM model_evaluations \n        WHERE model_id = p_model_id\n    );\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "machine_learning_model_analysis_and_evaluation",
    "tables": [
      "models",
      "model_versions",
      "model_evaluations",
      "hyperparameters"
    ],
    "call_sqls": [
      "SELECT get_model_performance_summary(1);",
      "SELECT get_model_performance_summary(2);",
      "SELECT get_model_performance_summary(3);",
      "SELECT get_model_performance_summary(4);",
      "SELECT get_model_performance_summary(5);",
      "SELECT get_model_performance_summary(6);",
      "SELECT get_model_performance_summary(7);",
      "SELECT get_model_performance_summary(8);",
      "SELECT get_model_performance_summary(9);",
      "SELECT get_model_performance_summary(10);",
      "SELECT get_model_performance_summary(11);",
      "SELECT get_model_performance_summary(12);",
      "SELECT get_model_performance_summary(13);",
      "SELECT get_model_performance_summary(14);",
      "SELECT get_model_performance_summary(15);",
      "SELECT get_model_performance_summary(16);",
      "SELECT get_model_performance_summary(17);",
      "SELECT get_model_performance_summary(18);",
      "SELECT get_model_performance_summary(19);",
      "SELECT get_model_performance_summary(20);"
    ],
    "id": 149
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_region_computer_usage_stats` that accepts two input parameters: `p_region_id` of type `NUMBER`, which represents the unique identifier for a specific region, and `p_min_internet_speed` of type `VARCHAR2`, which specifies the minimum internet speed threshold as a string. This function is designed to return a `VARCHAR2` string containing aggregated computer usage statistics for bookkeeping and email activities within the specified region, filtered by the minimum internet speed.\n\nUpon execution, the function declares two local variables: `v_bookkeeping_total` of type `NUMBER`, initialized to `0`, to store the sum of bookkeeping usage, and `v_email_total` of type `NUMBER`, initialized to `0`, to store the sum of email usage. It then proceeds to execute a `SELECT` statement to retrieve the aggregated data. This `SELECT` statement calculates the sum of values from the `bookkeeping` column and the sum of values from the `email` column, both originating from the `computer_usage` table. These aggregated sums are then assigned respectively to the `v_bookkeeping_total` and `v_email_total` variables using the `INTO` clause.\n\nThe data for aggregation is sourced from the `computer_usage` table, aliased as `cu`. This `computer_usage` table is joined with the `farm_data` table, aliased as `fd`, using an inner join condition where the `farm_id` column from `computer_usage` (`cu.farm_id`) matches the `farm_id` column from `farm_data` (`fd.farm_id`).\n\nThe `WHERE` clause of the `SELECT` statement applies two filtering conditions:\n1. It filters records where the `region_id` column from the `farm_data` table (`fd.region_id`) is equal to the value provided by the `p_region_id` input parameter.\n2. It further filters records where the numeric value of the `internet_speed` column from the `computer_usage` table (`cu.internet_speed`), obtained by explicitly converting the `VARCHAR2` `internet_speed` column to a `NUMBER` using `TO_NUMBER(cu.internet_speed)`, is greater than or equal to the numeric value of the `p_min_internet_speed` input parameter, which is also explicitly converted to a `NUMBER` using `TO_NUMBER(p_min_internet_speed)`.\n\nAfter the `SELECT` statement completes and the aggregated totals are stored in `v_bookkeeping_total` and `v_email_total`, the function constructs a `VARCHAR2` string and assigns it to the `v_result` variable. This string is formatted to display the \"Bookkeeping\" total followed by its calculated value, a separator \" | \", and then the \"Email\" total followed by its calculated value. Finally, the function returns this `v_result` string.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_computer_usage_stats(p_region_id IN NUMBER, p_min_internet_speed IN VARCHAR2) RETURN VARCHAR2\nIS\n    v_bookkeeping_total NUMBER := 0;\n    v_email_total NUMBER := 0;\n    v_result VARCHAR2(1000);\nBEGIN\n    SELECT SUM(cu.bookkeeping), SUM(cu.email)\n    INTO v_bookkeeping_total, v_email_total\n    FROM computer_usage cu\n    JOIN farm_data fd ON cu.farm_id = fd.farm_id\n    WHERE fd.region_id = p_region_id\n    AND TO_NUMBER(cu.internet_speed) >= TO_NUMBER(p_min_internet_speed);\n    \n    v_result := 'Bookkeeping: ' || v_bookkeeping_total || ' | Email: ' || v_email_total;\n    RETURN v_result;\nEND;",
    "database_name": "agricultural_dca_analysis",
    "tables": [
      "agricultural_regions",
      "farm_data",
      "computer_usage",
      "provinces"
    ],
    "call_sqls": [
      "SELECT get_region_computer_usage_stats(0, '10') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '10') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '25') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '25') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '50') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '50') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '5') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '5') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '100') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '100') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '1') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '1') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '75') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '75') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '150') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '150') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '200') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '200') FROM dual",
      "SELECT get_region_computer_usage_stats(0, '0') FROM dual",
      "SELECT get_region_computer_usage_stats(1, '0') FROM dual"
    ],
    "id": 150
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns a table consisting of two columns: project_id and next_usage_category. The function accepts two parameters: project_id_input of type bigint, which specifies the project_id to filter the projects table, and offset_input of type integer, which determines the offset for the lead function. The function performs a SELECT operation on the projects table, filtering rows where the project_id column matches the project_id_input parameter. It orders the filtered results by the project_id column and applies the lead window function to the usage_category column, using the offset_input parameter to determine how many rows forward to look for the next usage_category value. The lead function provides the usage_category from a subsequent row based on the specified offset, and the function returns the project_id and the calculated next_usage_category for the matching project_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_project_usage_lead(project_id_input bigint, offset_input integer) RETURNS TABLE(project_id bigint, next_usage_category text) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT p.project_id, lead(p.usage_category, offset_input) OVER (ORDER BY p.project_id) AS next_usage_category\n  FROM projects p\n  WHERE p.project_id = project_id_input;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "building_permits_and_construction_projects",
    "tables": [
      "projects",
      "permits",
      "inspections",
      "project_contractors",
      "contractors"
    ],
    "call_sqls": [
      "SELECT * FROM get_project_usage_lead(1, 1);",
      "SELECT * FROM get_project_usage_lead(1, 2);",
      "SELECT * FROM get_project_usage_lead(2, 1);",
      "SELECT * FROM get_project_usage_lead(2, 3);",
      "SELECT * FROM get_project_usage_lead(3, 0);",
      "SELECT * FROM get_project_usage_lead(5, 1);",
      "SELECT * FROM get_project_usage_lead(10, 5);",
      "SELECT * FROM get_project_usage_lead(15, 2);",
      "SELECT * FROM get_project_usage_lead(20, 1);",
      "SELECT * FROM get_project_usage_lead(25, 10);",
      "SELECT * FROM get_project_usage_lead(30, 1);",
      "SELECT * FROM get_project_usage_lead(35, 2);",
      "SELECT * FROM get_project_usage_lead(40, 3);",
      "SELECT * FROM get_project_usage_lead(50, 1);",
      "SELECT * FROM get_project_usage_lead(55, 4);",
      "SELECT * FROM get_project_usage_lead(60, 1);",
      "SELECT * FROM get_project_usage_lead(70, 2);",
      "SELECT * FROM get_project_usage_lead(80, 1);",
      "SELECT * FROM get_project_usage_lead(90, 3);",
      "SELECT * FROM get_project_usage_lead(100, 1);"
    ],
    "id": 151
  },
  {
    "ir": "Write a PLpgSQL trigger function that, upon the insertion of a new row into the pitching_performance table, automatically inserts a new record into the seasonal_comparisons table. The new record in the seasonal_comparisons table will have the following values: the comparison_id is calculated as the product of the season_id from the newly inserted row and 100; the season_id is directly taken from the newly inserted row; the metric is set to the string 'Game Score'; the previous_year_value is computed using the hyperbolic sine function sinh applied to the game_score from the new row divided by 100; the current_year_value is directly taken as the game_score from the new row; and the difference is calculated as the current_year_value minus the previous_year_value. The trigger is defined to execute this function after each row is inserted into the pitching_performance table.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_seasonal_comparison() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO seasonal_comparisons (comparison_id, season_id, metric, previous_year_value, current_year_value, difference) VALUES (NEW.season_id * 100, NEW.season_id, 'Game Score', sinh(NEW.game_score / 100), NEW.game_score, NEW.game_score - sinh(NEW.game_score / 100));\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_calculate_seasonal_comparison\n    AFTER INSERT ON pitching_performance\n    FOR EACH ROW\n    EXECUTE FUNCTION calculate_seasonal_comparison();",
    "database_name": "baseball_pitching_analytics",
    "tables": [
      "players",
      "seasons",
      "pitching_performance",
      "advanced_analytics",
      "seasonal_comparisons"
    ],
    "call_sqls": [
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (100, 1, 1, 85.0);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (101, 1, 2, 72.5);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (102, 2, 1, 90.0);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (103, 2, 3, 68.3);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (104, 3, 5, 55.0);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (105, 3, 7, 79.9);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (106, 4, 10, 95.2);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (107, 4, 12, 81.7);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (108, 5, 15, 63.4);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (109, 5, 18, 88.1);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (110, 6, 22, 74.5);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (111, 6, 25, 92.0);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (112, 7, 30, 50.5);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (113, 7, 35, 76.8);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (114, 8, 40, 84.3);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (115, 8, 45, 69.2);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (116, 9, 50, 97.5);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (117, 9, 55, 71.0);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (118, 10, 60, 83.6);",
      "INSERT INTO pitching_performance (performance_id, season_id, player_id, game_score) VALUES (119, 10, 65, 59.8);"
    ],
    "id": 152
  },
  {
    "ir": "Write a PostgreSQL trigger function named archive_old_address_on_new_insert that is executed automatically by a trigger named trg_archive_old_address_on_new_insert, which is defined to fire BEFORE INSERT on the People_Addresses table for each new row, where the function performs an UPDATE operation on the People_Addresses table, setting the date_to column to the current date and time value returned by the CURRENT_TIMESTAMP function for all existing rows where the person_id column matches the NEW.person_id value from the incoming insert, and where the date_to column is currently NULL, and where the person_address_id column of the existing row does not equal the NEW.person_address_id value from the incoming insert, thereby archiving any previously active address record for the same person before the new address record is inserted, and the function concludes by returning the NEW row to allow the insert operation to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_old_address_on_new_insert() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"People_Addresses\" SET \"date_to\" = CURRENT_TIMESTAMP WHERE \"person_id\" = NEW.\"person_id\" AND \"date_to\" IS NULL AND \"person_address_id\" != NEW.\"person_address_id\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_archive_old_address_on_new_insert\n    BEFORE INSERT ON \"People_Addresses\"\n    FOR EACH ROW\n    EXECUTE FUNCTION archive_old_address_on_new_insert();",
    "database_name": "student_assessment",
    "tables": [
      "People",
      "Addresses",
      "People_Addresses",
      "Candidates"
    ],
    "call_sqls": [
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (300, 111, 5, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (301, 121, 9, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (302, 131, 29, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (303, 111, 9, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (304, 121, 5, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (305, 131, 5, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (306, 111, 29, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (307, 121, 29, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (308, 131, 9, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (309, 111, 88, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (310, 121, 88, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (311, 131, 88, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (312, 200, 5, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (313, 200, 9, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (314, 210, 29, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (315, 210, 88, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (316, 220, 5, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (317, 220, 9, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (318, 230, 29, CURRENT_TIMESTAMP, NULL);",
      "INSERT INTO \"People_Addresses\" (\"person_address_id\", \"person_id\", \"address_id\", \"date_from\", \"date_to\") VALUES (319, 230, 88, CURRENT_TIMESTAMP, NULL);"
    ],
    "id": 153
  },
  {
    "ir": "Write a PostgreSQL trigger function named validate_access_log_entry that is executed before each row insertion on the access_logs table, which first checks if the new row's resource_id value exists in the resources table by performing a SELECT query on the resources table for a row where the resource_id column matches NEW.resource_id; if no such resource exists, the function returns NULL to prevent the insertion of the new access_logs row, and if the resource does exist, the function proceeds to check if the new row's access_type column equals the string literal 'guest', and if this condition is true, it performs another existence check by SELECTing from the users table for a row where the user_id column matches NEW.user_id, and if such a user exists, it executes an UPDATE statement on the users table to set the profile_picture column to the string 'default.jpg' specifically for that user_id, and finally, if all checks pass, the function returns the NEW row to allow the insertion into the access_logs table to proceed.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_access_log_entry() RETURNS TRIGGER AS $$\nBEGIN\n  IF NOT EXISTS (SELECT 1 FROM resources WHERE resource_id = NEW.resource_id) THEN\n    -- Log the issue or handle it gracefully without raising an exception\n    -- For example, we could insert a log entry into a separate table or simply skip the operation\n    RETURN NULL; -- Skip the insert operation\n  END IF;\n\n  IF NEW.access_type = 'guest' THEN\n    IF EXISTS (SELECT 1 FROM users WHERE user_id = NEW.user_id) THEN\n      UPDATE users SET profile_picture = 'default.jpg' WHERE user_id = NEW.user_id;\n    END IF;\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS trg_update_user_profile_picture ON access_logs;\nCREATE TRIGGER trg_validate_access_log_entry\nBEFORE INSERT ON access_logs\nFOR EACH ROW EXECUTE FUNCTION validate_access_log_entry();",
    "database_name": "resource_management_and_access_control",
    "tables": [
      "resources",
      "users",
      "access_logs",
      "resource_evaluations",
      "resource_owners",
      "resource_links"
    ],
    "call_sqls": [
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1001, 1, 101, '2024-01-15', 'guest', '192.168.1.1', 'Mozilla/5.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1002, 999, 102, '2024-01-15', 'member', '192.168.1.2', 'Mozilla/5.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1003, 2, 103, '2024-01-15', 'guest', '192.168.1.3', 'Chrome/120.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1004, 3, 104, '2024-01-16', 'admin', '192.168.1.4', 'Safari/17.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1005, 1, 105, '2024-01-16', 'guest', '192.168.1.5', 'Edge/120.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1006, 4, 106, '2024-01-17', 'member', '192.168.1.6', 'Firefox/122.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1007, 5, 107, '2024-01-17', 'guest', '192.168.1.7', 'Mozilla/5.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1008, 2, 108, '2024-01-18', 'guest', '192.168.1.8', 'Chrome/121.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1009, 6, 109, '2024-01-18', 'member', '192.168.1.9', 'Safari/17.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1010, 3, 110, '2024-01-19', 'guest', '192.168.1.10', 'Edge/121.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1011, 7, 111, '2024-01-19', 'admin', '192.168.1.11', 'Firefox/123.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1012, 8, 112, '2024-01-20', 'guest', '192.168.1.12', 'Mozilla/5.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1013, 4, 113, '2024-01-20', 'member', '192.168.1.13', 'Chrome/122.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1014, 9, 114, '2024-01-21', 'guest', '192.168.1.14', 'Safari/17.1');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1015, 5, 115, '2024-01-21', 'guest', '192.168.1.15', 'Edge/122.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1016, 10, 116, '2024-01-22', 'member', '192.168.1.16', 'Firefox/124.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1017, 6, 117, '2024-01-22', 'guest', '192.168.1.17', 'Mozilla/5.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1018, 11, 118, '2024-01-23', 'admin', '192.168.1.18', 'Chrome/123.0');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1019, 7, 119, '2024-01-23', 'guest', '192.168.1.19', 'Safari/17.2');",
      "INSERT INTO access_logs (access_id, resource_id, user_id, access_date, access_type, ip_address, user_agent) VALUES (1020, 12, 120, '2024-01-24', 'member', '192.168.1.20', 'Edge/123.0');"
    ],
    "id": 154
  },
  {
    "ir": "Write a PLpgSQL function named `get_recent_comments` that takes no explicit input parameters. This function is designed to return a set of records, specifically a table with two columns: `comment_text` of type `text` and `comment_date` of type `text`. The core operation of this function is to execute a `SELECT` query. This query retrieves the `comment_text` and `comment_date` columns from the `comments` table. To filter and enrich the results, it performs an `INNER JOIN` operation between the `comments` table (aliased as `c`) and the `campaign_updates` table (aliased as `cu`). The join condition specifies that rows from `comments` and `campaign_updates` are matched when the `update_id` column in the `comments` table is equal to the `update_id` column in the `campaign_updates` table. Furthermore, the results are filtered using a `WHERE` clause, which includes only those records where the `update_date` column from the `campaign_updates` table is strictly greater than the literal date string '2023-01-01'. The `RETURN QUERY` statement then returns the entire result set of this `SELECT` statement as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_recent_comments() RETURNS TABLE(comment_text text, comment_date text) LANGUAGE plpgsql AS $$\nBEGIN\n  RETURN QUERY SELECT c.comment_text, c.comment_date\n  FROM comments c\n  JOIN campaign_updates cu ON c.update_id = cu.update_id\n  WHERE cu.update_date > '2023-01-01';\nEND;\n$$;",
    "database_name": "crowdfunding_platform_and_campaign_management",
    "tables": [
      "backers",
      "campaigns",
      "pledges",
      "payments",
      "rewards",
      "campaign_updates",
      "comments"
    ],
    "call_sqls": [
      "SELECT * FROM get_recent_comments();",
      "SELECT comment_text, comment_date FROM get_recent_comments();",
      "SELECT comment_text FROM get_recent_comments() WHERE comment_date > '2023-06-01';",
      "SELECT * FROM get_recent_comments() ORDER BY comment_date DESC;",
      "SELECT * FROM get_recent_comments() ORDER BY comment_date ASC;",
      "SELECT comment_text FROM get_recent_comments() LIMIT 10;",
      "SELECT comment_text FROM get_recent_comments() WHERE comment_text LIKE '%great%';",
      "SELECT COUNT(*) FROM get_recent_comments();",
      "SELECT DISTINCT comment_date FROM get_recent_comments();",
      "SELECT * FROM get_recent_comments() WHERE comment_date BETWEEN '2023-03-01' AND '2023-06-30';",
      "SELECT comment_text FROM get_recent_comments() WHERE LENGTH(comment_text) > 100;",
      "SELECT comment_date, COUNT(*) FROM get_recent_comments() GROUP BY comment_date;",
      "SELECT * FROM get_recent_comments() OFFSET 5 LIMIT 5;",
      "SELECT comment_text FROM get_recent_comments() WHERE comment_text IS NOT NULL;",
      "SELECT * FROM get_recent_comments() WHERE comment_date = '2023-05-15';",
      "SELECT * FROM get_recent_comments() WHERE comment_date IN ('2023-04-01', '2023-07-01', '2023-10-01');",
      "SELECT SUBSTRING(comment_text FROM 1 FOR 50) FROM get_recent_comments();",
      "SELECT * FROM get_recent_comments() WHERE comment_text ~ 'thank you';",
      "SELECT comment_date, comment_text FROM get_recent_comments() ORDER BY comment_date DESC LIMIT 3;",
      "SELECT * FROM get_recent_comments() WHERE comment_date > '2023-08-01' ORDER BY comment_date;"
    ],
    "id": 155
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named update_brand_measurements that accepts three input parameters: a bigint parameter p_brand_id to identify a specific brand, a text parameter p_size_category to specify a size category, and a real parameter p_adjustment_factor to determine the type of operation to perform, and returns an integer value representing the number of rows affected by the operation; the function logic uses a conditional IF-ELSIF-ELSE block where, if the p_adjustment_factor is greater than 1.0, it executes an UPDATE operation on the apparel_size_guides table, modifying the bust_in column by multiplying its current value by p_adjustment_factor and the waist_in column by multiplying its current value by p_adjustment_factor, for all rows where the brand_id column equals the p_brand_id parameter and the size_category column equals the p_size_category parameter, and then uses the GET DIAGNOSTICS command to set the return variable updated_count to the number of rows updated by this statement; if the p_adjustment_factor is exactly equal to 1.0, it executes a different UPDATE operation on the apparel_size_guides table, modifying the hip_in column by adding 2.0 to its current value and the hip_cm column by adding 5.0 to its current value, for all rows where the brand_id column equals the p_brand_id parameter and the size_category column equals the p_size_category parameter, and then uses the GET DIAGNOSTICS command to set the return variable updated_count to the number of rows updated by this statement; if the p_adjustment_factor is any other value (i.e., less than or equal to 1.0 but not equal to 1.0), it executes a DELETE operation on the apparel_size_guide_details table, removing all rows where the brand_id column equals the p_brand_id parameter and the measurement_value column is less than 15.0, and then uses the GET DIAGNOSTICS command to set the return variable updated_count to the number of rows deleted by this statement; finally, the function returns the value of the updated_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION update_brand_measurements(p_brand_id bigint, p_size_category text, p_adjustment_factor real) RETURNS integer LANGUAGE plpgsql AS $$ DECLARE updated_count integer := 0; BEGIN IF p_adjustment_factor > 1.0 THEN UPDATE apparel_size_guides SET bust_in = bust_in * p_adjustment_factor, waist_in = waist_in * p_adjustment_factor WHERE brand_id = p_brand_id AND size_category = p_size_category; GET DIAGNOSTICS updated_count = ROW_COUNT; ELSIF p_adjustment_factor = 1.0 THEN UPDATE apparel_size_guides SET hip_in = hip_in + 2.0, hip_cm = hip_cm + 5.0 WHERE brand_id = p_brand_id AND size_category = p_size_category; GET DIAGNOSTICS updated_count = ROW_COUNT; ELSE DELETE FROM apparel_size_guide_details WHERE brand_id = p_brand_id AND measurement_value < 15.0; GET DIAGNOSTICS updated_count = ROW_COUNT; END IF; RETURN updated_count; END; $$;",
    "database_name": "apparel_size_measurement_reference",
    "tables": [
      "apparel_size_guides",
      "apparel_size_guide_details",
      "brands"
    ],
    "call_sqls": [
      "SELECT update_brand_measurements(1, 'Women''s', 1.2);",
      "SELECT update_brand_measurements(0, 'Men''s', 1.1);",
      "SELECT update_brand_measurements(1, 'Women''s', 1.0);",
      "SELECT update_brand_measurements(0, 'Men''s', 1.0);",
      "SELECT update_brand_measurements(2, 'Women''s', 0.9);",
      "SELECT update_brand_measurements(3, 'Men''s', 0.8);",
      "SELECT update_brand_measurements(1, 'Unisex', 1.15);",
      "SELECT update_brand_measurements(0, 'Women''s', 1.05);",
      "SELECT update_brand_measurements(2, 'Men''s', 1.0);",
      "SELECT update_brand_measurements(3, 'Women''s', 0.5);",
      "SELECT update_brand_measurements(4, 'Men''s', 1.25);",
      "SELECT update_brand_measurements(5, 'Women''s', 1.0);",
      "SELECT update_brand_measurements(6, 'Men''s', 0.75);",
      "SELECT update_brand_measurements(1, 'Plus Size', 1.3);",
      "SELECT update_brand_measurements(0, 'Petite', 1.0);",
      "SELECT update_brand_measurements(2, 'Tall', 0.6);",
      "SELECT update_brand_measurements(7, 'Women''s', 1.08);",
      "SELECT update_brand_measurements(8, 'Men''s', 1.0);",
      "SELECT update_brand_measurements(9, 'Women''s', 0.3);",
      "SELECT update_brand_measurements(10, 'Men''s', 1.18);"
    ],
    "id": 156
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `log_citation_activity_with_timestamp` that returns a table with three columns: `operation_time` of type `text`, `total_citations` of type `bigint`, and `recent_papers` of type `bigint`. This function first declares a local variable named `operation_timestamp` of type `text`. Inside the function's `BEGIN` block, it assigns the current date and time, including the time zone, as a text string to the `operation_timestamp` variable by calling the `timeofday()` function. Subsequently, the function executes a `SELECT` query and returns its results as the output table. The `SELECT` statement retrieves three values: the `operation_timestamp` variable's current value, which is cast implicitly to `text` for the `operation_time` column; the total count of all rows resulting from the join operation, aliased as `total_citations`, which is implicitly cast to `bigint`; and the count of distinct `paper_id` values from the `papers` table, aliased as `recent_papers`, which is also implicitly cast to `bigint`. These counts are derived from a join operation between the `citations` table (aliased as `c`) and the `papers` table (aliased as `p`). The join condition specifies that `c.paper_id` must be equal to `p.paper_id`. The results are filtered by a `WHERE` clause that includes only those records where the `year` column from the `papers` table (`p.year`) is greater than or equal to the current year minus five. The current year is obtained by first getting the current date using `CURRENT_DATE` and then extracting the year component from it using the `EXTRACT(YEAR FROM ...)` function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_citation_activity_with_timestamp()\nRETURNS TABLE(operation_time text, total_citations bigint, recent_papers bigint) AS $$\nDECLARE\n    operation_timestamp text;\nBEGIN\n    operation_timestamp := timeofday();\n    \n    RETURN QUERY \n    SELECT operation_timestamp, \n           COUNT(*) as total_citations,\n           COUNT(DISTINCT p.paper_id) as recent_papers\n    FROM citations c\n    JOIN papers p ON c.paper_id = p.paper_id\n    WHERE p.year >= EXTRACT(YEAR FROM CURRENT_DATE) - 5;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "academic_research_and_citation_management",
    "tables": [
      "papers",
      "citations",
      "references",
      "authors"
    ],
    "call_sqls": [
      "SELECT * FROM log_citation_activity_with_timestamp();",
      "SELECT operation_time, total_citations FROM log_citation_activity_with_timestamp();",
      "SELECT * FROM log_citation_activity_with_timestamp() WHERE total_citations > 100;",
      "SELECT operation_time, recent_papers FROM log_citation_activity_with_timestamp();",
      "SELECT operation_time, total_citations, recent_papers FROM log_citation_activity_with_timestamp() WHERE recent_papers > 50;",
      "SELECT * FROM log_citation_activity_with_timestamp() ORDER BY total_citations DESC;",
      "SELECT operation_time FROM log_citation_activity_with_timestamp();",
      "SELECT total_citations FROM log_citation_activity_with_timestamp();",
      "SELECT recent_papers FROM log_citation_activity_with_timestamp();",
      "SELECT operation_time, total_citations FROM log_citation_activity_with_timestamp() WHERE total_citations BETWEEN 10 AND 1000;",
      "SELECT * FROM log_citation_activity_with_timestamp() WHERE operation_time LIKE '%PM%';",
      "SELECT operation_time, total_citations, recent_papers FROM log_citation_activity_with_timestamp() WHERE recent_papers = 0;",
      "SELECT operation_time, (total_citations * 1.0) / NULLIF(recent_papers, 0) AS avg_citations FROM log_citation_activity_with_timestamp();",
      "SELECT COUNT(*) FROM log_citation_activity_with_timestamp();",
      "SELECT operation_time, total_citations FROM log_citation_activity_with_timestamp() LIMIT 1;",
      "SELECT * FROM log_citation_activity_with_timestamp() FETCH FIRST 5 ROWS ONLY;",
      "SELECT operation_time FROM log_citation_activity_with_timestamp() WHERE total_citations > (SELECT AVG(total_citations) FROM log_citation_activity_with_timestamp());",
      "SELECT operation_time, total_citations FROM log_citation_activity_with_timestamp() ORDER BY operation_time;",
      "SELECT MAX(total_citations) FROM log_citation_activity_with_timestamp();",
      "SELECT MIN(recent_papers) FROM log_citation_activity_with_timestamp();"
    ],
    "id": 157
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_book_id of type bigint, which represents the unique identifier of a book. The function begins by declaring a local variable v_total_sold of type bigint to store the total quantity of the specified book sold. It then executes a SELECT statement to calculate the sum of the quantity column from the order_items table where the book_id matches the provided p_book_id. The COALESCE function is used to ensure that if no rows are found, v_total_sold is set to 0. The result of this sum is stored in the v_total_sold variable. The function then evaluates a conditional statement: if v_total_sold is greater than 100, it updates the books table by setting the status column to 'bestseller' for the row where book_id equals p_book_id. If v_total_sold is not greater than 100, it updates the books table by setting the status column to 'available' for the row where book_id equals p_book_id. The function does not return any value, as indicated by the RETURNS void clause.",
    "plsql": "CREATE OR REPLACE FUNCTION update_book_status(p_book_id bigint)\nRETURNS void AS $$\nDECLARE\n    v_total_sold bigint;\nBEGIN\n    SELECT COALESCE(SUM(quantity), 0) INTO v_total_sold \n    FROM order_items \n    WHERE book_id = p_book_id;\n    \n    IF v_total_sold > 100 THEN\n        UPDATE books SET status = 'bestseller' WHERE book_id = p_book_id;\n    ELSE\n        UPDATE books SET status = 'available' WHERE book_id = p_book_id;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_catalog_and_review_management_121085",
    "tables": [
      "orders",
      "order_items",
      "books"
    ],
    "call_sqls": [
      "SELECT update_book_status(1);",
      "SELECT update_book_status(2);",
      "SELECT update_book_status(3);",
      "SELECT update_book_status(4);",
      "SELECT update_book_status(5);",
      "SELECT update_book_status(6);",
      "SELECT update_book_status(7);",
      "SELECT update_book_status(8);",
      "SELECT update_book_status(9);",
      "SELECT update_book_status(10);",
      "SELECT update_book_status(11);",
      "SELECT update_book_status(12);",
      "SELECT update_book_status(13);",
      "SELECT update_book_status(14);",
      "SELECT update_book_status(15);",
      "SELECT update_book_status(16);",
      "SELECT update_book_status(17);",
      "SELECT update_book_status(18);",
      "SELECT update_book_status(19);",
      "SELECT update_book_status(20);"
    ],
    "id": 158
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `evaluate_disease_impact` that accepts four input parameters: `p_disease_id` of type `bigint`, representing the unique identifier for a disease; `p_region_id` of type `bigint`, representing the unique identifier for a geographical region; `p_start_date` of type `text`, representing the beginning date of a period for evaluation; and `p_end_date` of type `text`, representing the ending date of a period for evaluation. The procedure declares a local variable `v_outbreak_count` of type `bigint` to store the count of disease outbreaks. The procedure then executes a `SELECT` statement to count the number of records in the `disease_outbreaks` table. This count is filtered by three conditions: the `disease_id` column must be equal to the value provided in the `p_disease_id` parameter, the `region_id` column must be equal to the value provided in the `p_region_id` parameter, and the `outbreak_date` column must fall inclusively between the `p_start_date` and `p_end_date` parameters. The resulting count is stored in the `v_outbreak_count` variable. Following this, a conditional `IF` statement evaluates the value of `v_outbreak_count`. If `v_outbreak_count` is greater than 20, the procedure executes an `INSERT` statement into the `recognition_status` table. For this insertion, the `recognition_id` column is populated by calculating the maximum existing `recognition_id` in the `recognition_status` table using a subquery `(SELECT MAX(recognition_id) FROM recognition_status)`, applying the `COALESCE` function to default to 0 if no `recognition_id` exists, and then adding 1 to the result. The `disease_id` column is set to the value of `p_disease_id`. The `recognized_by_oie` column is set to the integer value `1`. The `recognized_by_eu` column is set to the integer value `1`. The `recognized_date` column is set to the current date formatted as 'YYYY-MM-DD' using `TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD')`. The `status_notes` column is set to the string literal 'Significant disease impact'. If `v_outbreak_count` is not greater than 20 (i.e., it is less than or equal to 20), the procedure executes an `INSERT` statement into the `recognition_status` table. For this insertion, the `recognition_id` column is populated by calculating the maximum existing `recognition_id` in the `recognition_status` table using a subquery `(SELECT MAX(recognition_id) FROM recognition_status)`, applying the `COALESCE` function to default to 0 if no `recognition_id` exists, and then adding 1 to the result. The `disease_id` column is set to the value of `p_disease_id`. The `recognized_by_oie` column is set to the integer value `0`. The `recognized_by_eu` column is set to the integer value `0`. The `recognized_date` column is set to the current date formatted as 'YYYY-MM-DD' using `TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD')`. The `status_notes` column is set to the string literal 'Minimal disease impact'.",
    "plsql": "CREATE OR REPLACE PROCEDURE evaluate_disease_impact(\n    p_disease_id bigint,\n    p_region_id bigint,\n    p_start_date text,\n    p_end_date text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_outbreak_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_outbreak_count\n    FROM disease_outbreaks\n    WHERE disease_id = p_disease_id\n    AND region_id = p_region_id\n    AND outbreak_date BETWEEN p_start_date AND p_end_date;\n    \n    IF v_outbreak_count > 20 THEN\n        INSERT INTO recognition_status (\n            recognition_id,\n            disease_id,\n            recognized_by_oie,\n            recognized_by_eu,\n            recognized_date,\n            status_notes\n        )\n        VALUES (\n            COALESCE((SELECT MAX(recognition_id) FROM recognition_status), 0) + 1,\n            p_disease_id,\n            1,\n            1,\n            TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'),\n            'Significant disease impact'\n        );\n    ELSE\n        INSERT INTO recognition_status (\n            recognition_id,\n            disease_id,\n            recognized_by_oie,\n            recognized_by_eu,\n            recognized_date,\n            status_notes\n        )\n        VALUES (\n            COALESCE((SELECT MAX(recognition_id) FROM recognition_status), 0) + 1,\n            p_disease_id,\n            0,\n            0,\n            TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'),\n            'Minimal disease impact'\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "animal_disease_recognition_and_management",
    "tables": [
      "disease_outbreaks",
      "regions",
      "recognition_status"
    ],
    "call_sqls": [
      "CALL evaluate_disease_impact(1, 1, '2023-01-01', '2023-12-31');",
      "CALL evaluate_disease_impact(2, 0, '2023-06-01', '2023-08-31');",
      "CALL evaluate_disease_impact(1, 0, '2022-01-01', '2022-12-31');",
      "CALL evaluate_disease_impact(3, 1, '2023-03-01', '2023-05-31');",
      "CALL evaluate_disease_impact(2, 1, '2023-09-01', '2023-11-30');",
      "CALL evaluate_disease_impact(1, 2, '2023-04-01', '2023-07-31');",
      "CALL evaluate_disease_impact(4, 0, '2023-02-15', '2023-10-15');",
      "CALL evaluate_disease_impact(5, 1, '2023-07-01', '2023-09-30');",
      "CALL evaluate_disease_impact(3, 0, '2023-01-15', '2023-12-15');",
      "CALL evaluate_disease_impact(2, 2, '2023-05-01', '2023-08-31');",
      "CALL evaluate_disease_impact(1, 3, '2023-10-01', '2023-12-31');",
      "CALL evaluate_disease_impact(6, 1, '2023-11-01', '2023-11-30');",
      "CALL evaluate_disease_impact(4, 1, '2023-08-01', '2023-10-31');",
      "CALL evaluate_disease_impact(7, 0, '2023-03-15', '2023-06-15');",
      "CALL evaluate_disease_impact(5, 0, '2023-12-01', '2023-12-31');",
      "CALL evaluate_disease_impact(3, 2, '2023-02-01', '2023-04-30');",
      "CALL evaluate_disease_impact(8, 1, '2023-06-01', '2023-09-30');",
      "CALL evaluate_disease_impact(2, 3, '2023-07-15', '2023-10-15');",
      "CALL evaluate_disease_impact(9, 0, '2023-01-01', '2023-03-31');",
      "CALL evaluate_disease_impact(1, 4, '2023-09-01', '2023-11-30');"
    ],
    "id": 159
  },
  {
    "ir": "Write a PLpgSQL function named update_data_source_location that accepts two parameters: p_source_id of type bigint and p_new_location of type text. The function is designed to update the location column in the data_sources table for a specific row identified by the source_id column. The function begins by checking if there exists at least one row in the data_sources table where the source_id matches the value provided in the p_source_id parameter. This is done using a conditional statement with the EXISTS keyword, which performs a subquery to select a constant value of 1 from the data_sources table where the source_id equals p_source_id. If such a row exists, the function proceeds to execute an UPDATE operation on the data_sources table, setting the location column to the value specified in the p_new_location parameter for the row where the source_id matches p_source_id. If no matching row is found, the function does not perform any update operation. The function is defined using the PLpgSQL language and does not return any value, as indicated by the RETURNS void clause.",
    "plsql": "CREATE OR REPLACE FUNCTION update_data_source_location(p_source_id bigint, p_new_location text)\nRETURNS void AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM data_sources WHERE source_id = p_source_id) THEN\n        UPDATE data_sources SET location = p_new_location WHERE source_id = p_source_id;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "gnss_navigation_data_management",
    "tables": [
      "datasets",
      "data_sources",
      "data_types",
      "datasets_sources",
      "access_logs"
    ],
    "call_sqls": [
      "SELECT update_data_source_location(0, '41.8781, -87.6298');",
      "SELECT update_data_source_location(1, '34.0522, -118.2437');",
      "SELECT update_data_source_location(2, '51.5074, -0.1278');",
      "SELECT update_data_source_location(3, '48.8566, 2.3522');",
      "SELECT update_data_source_location(4, '35.6762, 139.6503');",
      "SELECT update_data_source_location(5, '-33.8688, 151.2093');",
      "SELECT update_data_source_location(6, '55.7558, 37.6173');",
      "SELECT update_data_source_location(7, '39.9042, 116.4074');",
      "SELECT update_data_source_location(8, '28.6139, 77.2090');",
      "SELECT update_data_source_location(9, '-23.5505, -46.6333');",
      "SELECT update_data_source_location(10, '43.6532, -79.3832');",
      "SELECT update_data_source_location(11, '52.5200, 13.4050');",
      "SELECT update_data_source_location(12, '40.4168, -3.7038');",
      "SELECT update_data_source_location(13, '41.9028, 12.4964');",
      "SELECT update_data_source_location(14, '37.5665, 126.9780');",
      "SELECT update_data_source_location(15, '25.2048, 55.2708');",
      "SELECT update_data_source_location(16, '19.4326, -99.1332');",
      "SELECT update_data_source_location(17, '-34.6037, -58.3816');",
      "SELECT update_data_source_location(18, '30.0444, 31.2357');",
      "SELECT update_data_source_location(19, '1.3521, 103.8198');"
    ],
    "id": 160
  },
  {
    "ir": "Write a PostgreSQL trigger function and trigger definition that automatically copies and modifies material composition data when a new material version is inserted, where the function trg_copy_previous_compositions declares a local variable max_version_num of type bigint, then queries the material_versions table to find the maximum version_number for the same material_id as the newly inserted record while excluding the current version_id, using COALESCE to return 0 if no previous versions exist, and if max_version_num is greater than 0 (indicating a previous version exists), the function inserts new records into the material_compositions table by selecting from the material_compositions table of the previous version (identified by querying material_versions for the version_id where material_id matches and version_number equals max_version_num), copying the element_id and tolerance values unchanged while modifying the percentage value by multiplying it with (1 + sinh(0.01)), and assigning the NEW.version_id to all inserted composition records, then returns NEW to complete the trigger execution, with the trigger itself being defined to fire AFTER INSERT operations on the material_versions table for each row affected.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_copy_previous_compositions() RETURNS TRIGGER AS $$\nDECLARE\n  max_version_num bigint;\nBEGIN\n  SELECT COALESCE(MAX(version_number), 0) INTO max_version_num \n  FROM material_versions \n  WHERE material_id = NEW.material_id AND version_id <> NEW.version_id;\n  \n  IF max_version_num > 0 THEN\n    INSERT INTO material_compositions (version_id, element_id, percentage, tolerance)\n    SELECT NEW.version_id, element_id, percentage * (1 + sinh(0.01)), tolerance\n    FROM material_compositions \n    WHERE version_id = (SELECT version_id FROM material_versions WHERE material_id = NEW.material_id AND version_number = max_version_num);\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_copy_previous_compositions\nAFTER INSERT ON material_versions\nFOR EACH ROW EXECUTE FUNCTION trg_copy_previous_compositions();",
    "database_name": "ceramic_material_composition_analysis",
    "tables": [
      "materials",
      "material_versions",
      "material_compositions",
      "elements",
      "material_categories",
      "suppliers"
    ],
    "call_sqls": [
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (100, 0, 1, '2024-01-01', 'First version');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (101, 0, 2, '2024-01-02', 'Second version');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (104, 2, 1, '2024-01-05', 'New material version');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (105, 2, 2, '2024-01-06', 'Second version for new material');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (106, 3, 1, '2024-01-07', 'Version 1 material 3');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (107, 3, 2, '2024-01-08', 'Version 2 material 3');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (108, 3, 3, '2024-01-09', 'Version 3 material 3');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (109, 4, 1, '2024-01-10', 'Electronics material v1');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (110, 4, 2, '2024-01-11', 'Electronics material v2');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (111, 5, 1, '2024-01-12', 'Construction material initial');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (112, 5, 2, '2024-01-13', 'Construction material revised');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (113, 6, 1, '2024-01-14', 'Special alloy v1');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (114, 6, 2, '2024-01-15', 'Special alloy v2');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (115, 7, 1, '2024-01-16', 'Ceramic composite v1');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (116, 7, 2, '2024-01-17', 'Ceramic composite v2');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (117, 8, 1, '2024-01-18', 'Polymer blend initial');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (118, 8, 2, '2024-01-19', 'Polymer blend updated');",
      "INSERT INTO material_versions (version_id, material_id, version_number, date_created, description) VALUES (119, 9, 1, '2024-01-20', 'Experimental material v1');"
    ],
    "id": 161
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_discounted_price that accepts a single input parameter p_vehicle_id of type NUMBER and returns a NUMBER value, which declares a local variable v_price of type NUMBER, then executes a SELECT statement that retrieves the most recent pricing record from the vehicle_pricing table by selecting the price and discount columns where the vehicle_id matches the input parameter p_vehicle_id, ordering the results by created_at in descending order to ensure the most recent record is first, and limiting the result to only one row using ROWNUM = 1, calculates the discounted price by subtracting the discount from the price, stores this result in the v_price variable, returns this calculated value, and handles the NO_DATA_FOUND exception by returning NULL when no matching vehicle pricing record exists.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_discounted_price(p_vehicle_id NUMBER) RETURN NUMBER IS\n  v_price NUMBER;\nBEGIN\n  SELECT (price - discount)\n    INTO v_price\n    FROM (SELECT price, discount\n            FROM vehicle_pricing\n           WHERE vehicle_id = p_vehicle_id\n           ORDER BY created_at DESC)\n   WHERE ROWNUM = 1;\n\n  RETURN v_price;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\nEND;",
    "database_name": "automotive_di_management",
    "tables": [
      "dealers",
      "vehicles",
      "makes",
      "vehicle_types",
      "sales",
      "vehicle_pricing"
    ],
    "call_sqls": [
      "SELECT calculate_discounted_price(0) FROM dual",
      "SELECT calculate_discounted_price(1) FROM dual",
      "SELECT calculate_discounted_price(2) FROM dual",
      "SELECT calculate_discounted_price(3) FROM dual",
      "SELECT calculate_discounted_price(4) FROM dual",
      "SELECT calculate_discounted_price(5) FROM dual",
      "SELECT calculate_discounted_price(6) FROM dual",
      "SELECT calculate_discounted_price(7) FROM dual",
      "SELECT calculate_discounted_price(8) FROM dual",
      "SELECT calculate_discounted_price(9) FROM dual",
      "SELECT calculate_discounted_price(10) FROM dual",
      "SELECT calculate_discounted_price(11) FROM dual",
      "SELECT calculate_discounted_price(12) FROM dual",
      "SELECT calculate_discounted_price(13) FROM dual",
      "SELECT calculate_discounted_price(14) FROM dual",
      "SELECT calculate_discounted_price(15) FROM dual",
      "SELECT calculate_discounted_price(16) FROM dual",
      "SELECT calculate_discounted_price(17) FROM dual",
      "SELECT calculate_discounted_price(18) FROM dual",
      "SELECT calculate_discounted_price(19) FROM dual"
    ],
    "id": 162
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_tax_by_category that accepts a single parameter p_category_id of type NUMBER, which represents the identifier of a category. The function calculates the total tax for all beverages within the specified category and returns this calculated tax amount as a NUMBER. The function begins by declaring a local variable v_total_tax of type NUMBER to store the computed total tax. It then performs a SELECT operation to calculate the sum of the product of warehouse_stock and tax_rate for all beverages that belong to the category specified by p_category_id. This calculation involves joining the beverages table, which contains columns such as warehouse_stock and category_id, with the categories table, which includes columns like category_id and tax_rate, based on the matching category_id values. The result of this summation is stored in the v_total_tax variable. Following the SELECT operation, the function evaluates a conditional statement: if the value of v_total_tax exceeds 1000, the function returns 95% of v_total_tax, effectively applying a 5% discount to the total tax; otherwise, it returns the full value of v_total_tax without any discount.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_tax_by_category(p_category_id NUMBER) RETURN NUMBER IS\n  v_total_tax NUMBER;\nBEGIN\n  SELECT SUM(b.warehouse_stock * c.tax_rate) INTO v_total_tax\n  FROM beverages b\n  JOIN categories c ON b.category_id = c.category_id\n  WHERE b.category_id = p_category_id;\n  IF v_total_tax > 1000 THEN\n    RETURN v_total_tax * 0.95;\n  ELSE\n    RETURN v_total_tax;\n  END IF;\nEND;",
    "database_name": "alcoholic_bi_management",
    "tables": [
      "beverages",
      "categories",
      "sizes",
      "types",
      "warehouse_stock"
    ],
    "call_sqls": [
      "SELECT calculate_tax_by_category(1) FROM dual",
      "SELECT calculate_tax_by_category(2) FROM dual",
      "SELECT calculate_tax_by_category(3) FROM dual",
      "SELECT calculate_tax_by_category(4) FROM dual",
      "SELECT calculate_tax_by_category(5) FROM dual",
      "SELECT calculate_tax_by_category(6) FROM dual",
      "SELECT calculate_tax_by_category(7) FROM dual",
      "SELECT calculate_tax_by_category(8) FROM dual",
      "SELECT calculate_tax_by_category(9) FROM dual",
      "SELECT calculate_tax_by_category(10) FROM dual",
      "SELECT calculate_tax_by_category(11) FROM dual",
      "SELECT calculate_tax_by_category(12) FROM dual",
      "SELECT calculate_tax_by_category(13) FROM dual",
      "SELECT calculate_tax_by_category(14) FROM dual",
      "SELECT calculate_tax_by_category(15) FROM dual",
      "SELECT calculate_tax_by_category(16) FROM dual",
      "SELECT calculate_tax_by_category(17) FROM dual",
      "SELECT calculate_tax_by_category(18) FROM dual",
      "SELECT calculate_tax_by_category(19) FROM dual",
      "SELECT calculate_tax_by_category(20) FROM dual"
    ],
    "id": 163
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_rank_text of type text and returns a numeric value. The function performs a conversion operation by calling the PostgreSQL built-in function to_number, which transforms the input text p_rank_text into a numeric format using the pattern '999'. This pattern specifies that the input text should be interpreted as a numeric value with up to three digits, allowing for conversion of text representations of numbers into actual numeric data types. The function does not interact with any tables, columns, or perform any conditional logic, and it simply returns the result of the conversion operation.",
    "plsql": "CREATE OR REPLACE FUNCTION convert_rank_to_number(p_rank_text text)\nRETURNS numeric AS $$\nBEGIN\n    RETURN to_number(p_rank_text, '999');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cricket_team_performance_analysis",
    "tables": [
      "access_logs",
      "matches",
      "seasons",
      "team_performance",
      "teams",
      "users"
    ],
    "call_sqls": [
      "SELECT convert_rank_to_number('001');",
      "SELECT convert_rank_to_number('100');",
      "SELECT convert_rank_to_number('050');",
      "SELECT convert_rank_to_number('999');",
      "SELECT convert_rank_to_number('123');",
      "SELECT convert_rank_to_number('456');",
      "SELECT convert_rank_to_number('789');",
      "SELECT convert_rank_to_number('010');",
      "SELECT convert_rank_to_number('020');",
      "SELECT convert_rank_to_number('030');",
      "SELECT convert_rank_to_number('005');",
      "SELECT convert_rank_to_number('042');",
      "SELECT convert_rank_to_number('255');",
      "SELECT convert_rank_to_number('777');",
      "SELECT convert_rank_to_number('888');",
      "SELECT convert_rank_to_number('111');",
      "SELECT convert_rank_to_number('222');",
      "SELECT convert_rank_to_number('333');",
      "SELECT convert_rank_to_number('444');",
      "SELECT convert_rank_to_number('555');"
    ],
    "id": 164
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_vehicle_power_to_weight that accepts two input parameters: a numeric parameter named vehicle_id_in and a numeric parameter named scn_in, and returns a numeric value; this function declares a local numeric variable named power_to_weight_ratio, then executes a SELECT statement that retrieves data from the performance_metrics table (aliased as pm) by dividing the value in the hp column by the value in the wt column for the specific row where the vehicle_id column value is equal to the provided vehicle_id_in parameter, and stores the result of this division into the power_to_weight_ratio variable; the function then returns the value of the power_to_weight_ratio variable; if the SELECT statement finds no rows that match the specified condition, the function handles the NO_DATA_FOUND exception by returning a NULL value, and if the division operation in the SELECT statement attempts to divide by zero because the wt column value is zero, the function handles the ZERO_DIVIDE exception by also returning a NULL value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_vehicle_power_to_weight(vehicle_id_in NUMBER, scn_in NUMBER) RETURN NUMBER IS\n  power_to_weight_ratio NUMBER;\nBEGIN\n  SELECT pm.hp / pm.wt\n  INTO power_to_weight_ratio\n  FROM performance_metrics pm\n  WHERE pm.vehicle_id = vehicle_id_in; -- Removed the SCN_TO_TIMESTAMP condition\n  RETURN power_to_weight_ratio;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL; -- Or raise an application-specific error\n  WHEN ZERO_DIVIDE THEN\n    RETURN NULL; -- Handle division by zero if wt can be 0\nEND;",
    "database_name": "automobile_pas_608088",
    "tables": [
      "vehicles",
      "vehicle_engines",
      "engine_configurations",
      "fuel_types",
      "vehicle_transmissions",
      "transmissions",
      "performance_metrics",
      "vehicle_versions"
    ],
    "call_sqls": [
      "SELECT calculate_vehicle_power_to_weight(1, 123456) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(2, 234567) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(3, 345678) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(4, 456789) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(5, 567890) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(10, 100001) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(15, 150002) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(20, 200003) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(25, 250004) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(30, 300005) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(35, 350006) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(40, 400007) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(45, 450008) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(50, 500009) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(55, 550010) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(60, 600011) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(65, 650012) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(70, 700013) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(75, 750014) FROM DUAL",
      "SELECT calculate_vehicle_power_to_weight(80, 800015) FROM DUAL"
    ],
    "id": 165
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named update_user_reviews_count that accepts a single parameter input_user_id of type BIGINT and returns VOID, which first checks if the input_user_id value is greater than zero, and if this condition is met, performs an UPDATE operation on the users table by incrementing the reviews_count column by one (setting reviews_count = reviews_count + 1) specifically for the row where the user_id column matches the provided input_user_id parameter value, while doing nothing if the input_user_id is zero or negative.",
    "plsql": "CREATE OR REPLACE FUNCTION update_user_reviews_count(input_user_id BIGINT) RETURNS VOID AS $$\nBEGIN\n    IF input_user_id > 0 THEN\n        UPDATE users SET reviews_count = reviews_count + 1 WHERE user_id = input_user_id;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_commerce_product_review_management_817278",
    "tables": [
      "moderators",
      "product_categories",
      "products",
      "review_helpfulness",
      "review_reports",
      "users"
    ],
    "call_sqls": [
      "SELECT update_user_reviews_count(1);",
      "SELECT update_user_reviews_count(2);",
      "SELECT update_user_reviews_count(3);",
      "SELECT update_user_reviews_count(5);",
      "SELECT update_user_reviews_count(10);",
      "SELECT update_user_reviews_count(15);",
      "SELECT update_user_reviews_count(20);",
      "SELECT update_user_reviews_count(25);",
      "SELECT update_user_reviews_count(30);",
      "SELECT update_user_reviews_count(35);",
      "SELECT update_user_reviews_count(40);",
      "SELECT update_user_reviews_count(45);",
      "SELECT update_user_reviews_count(50);",
      "SELECT update_user_reviews_count(55);",
      "SELECT update_user_reviews_count(60);",
      "SELECT update_user_reviews_count(65);",
      "SELECT update_user_reviews_count(70);",
      "SELECT update_user_reviews_count(75);",
      "SELECT update_user_reviews_count(80);",
      "SELECT update_user_reviews_count(85);",
      "SELECT update_user_reviews_count(100);"
    ],
    "id": 166
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `update_content_expiry` that accepts two input parameters: `p_content_id` of type `bigint` representing the unique identifier of the content item to be updated, and `p_days` of type `integer` representing the number of days to add to the current date to calculate the new expiry date. This function is designed to return a `boolean` value indicating whether the update operation successfully modified at least one row. Upon execution, the function first declares a local variable `row_count` of type `integer` to store the number of rows affected by the subsequent `UPDATE` statement. The core operation involves updating the `content` table. Specifically, it sets the `expiry_date` column for a particular row. The new value for `expiry_date` is calculated by taking the current timestamp (`NOW()`) and adding an interval of days specified by the `p_days` parameter using the `make_interval(days := p_days)` function. The resulting timestamp is then explicitly cast to a `text` data type before being assigned to the `expiry_date` column. This update is conditionally applied only to the row where the `content_id` column matches the value provided in the `p_content_id` input parameter. Immediately after the `UPDATE` statement, the function retrieves the number of rows affected by the preceding `UPDATE` operation and assigns this count to the `row_count` variable using the `GET DIAGNOSTICS row_count = ROW_COUNT;` command. Finally, the function returns a `boolean` value which is the result of evaluating the condition `row_count > 0`. This means it returns `TRUE` if one or more rows were updated, and `FALSE` if no rows were updated (i.e., `row_count` was 0).",
    "plsql": "CREATE OR REPLACE FUNCTION update_content_expiry(p_content_id bigint, p_days integer) \nRETURNS boolean \nLANGUAGE plpgsql \nAS $$ \nDECLARE \n    row_count integer;\nBEGIN \n    UPDATE content \n    SET expiry_date = (NOW() + make_interval(days := p_days))::text \n    WHERE content_id = p_content_id; \n    \n    GET DIAGNOSTICS row_count = ROW_COUNT; \n    \n    RETURN row_count > 0; \nEND; \n$$;",
    "database_name": "content_management_and_revision_tracking",
    "tables": [
      "content",
      "content_categories",
      "content_tags",
      "content_translations",
      "revisions",
      "search_index",
      "users",
      "user_roles"
    ],
    "call_sqls": [
      "SELECT update_content_expiry(1001, 30);",
      "SELECT update_content_expiry(1002, 60);",
      "SELECT update_content_expiry(1003, 7);",
      "SELECT update_content_expiry(1004, 365);",
      "SELECT update_content_expiry(1005, 14);",
      "SELECT update_content_expiry(1006, 90);",
      "SELECT update_content_expiry(1007, 1);",
      "SELECT update_content_expiry(1008, 180);",
      "SELECT update_content_expiry(1009, 45);",
      "SELECT update_content_expiry(1010, 730);",
      "SELECT update_content_expiry(1011, 21);",
      "SELECT update_content_expiry(1012, 0);",
      "SELECT update_content_expiry(1013, 120);",
      "SELECT update_content_expiry(1014, 2);",
      "SELECT update_content_expiry(1015, 500);",
      "SELECT update_content_expiry(1016, 10);",
      "SELECT update_content_expiry(1017, 28);",
      "SELECT update_content_expiry(1018, 400);",
      "SELECT update_content_expiry(1019, 3);",
      "SELECT update_content_expiry(1020, 15);"
    ],
    "id": 167
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `manage_customer_discount_relationships` that accepts three input parameters: `p_discount_id` of type `integer`, `p_min_age` of type `integer`, and `p_max_age` of type `integer`. The purpose of this procedure is to establish relationships between a specific discount and eligible customers by inserting records into a renting history table.\n\nFirst, the procedure declares two local variables: `v_discount_credit` of type `integer` to store the `membership_credit` associated with the provided discount ID, and `v_customer_record` of type `RECORD` to temporarily hold customer data during iteration.\n\nThe procedure begins by executing a `SELECT` statement to retrieve the `membership_credit` value from the `\"Discount\"` table. It filters records in `\"Discount\"` where the `id` column matches the input parameter `p_discount_id`. The retrieved `membership_credit` value is then assigned to the `v_discount_credit` variable.\n\nFollowing this, the procedure enters a `FOR` loop that iterates over a set of customer records. The `FOR` loop's cursor is defined by a `SELECT` statement that retrieves `id`, `name`, `age`, and `membership_credit` columns from the `\"Customers\"` table, aliased as `c`. The `WHERE` clause of this `SELECT` statement applies two conditions:\n1. `c.age BETWEEN p_min_age AND p_max_age`: This condition filters customers whose `age` falls inclusively between the input parameters `p_min_age` and `p_max_age`.\n2. `c.membership_credit >= v_discount_credit`: This condition further filters customers whose `membership_credit` is greater than or equal to the `v_discount_credit` value previously retrieved from the `\"Discount\"` table.\n\nFor each `v_customer_record` that satisfies these conditions, the procedure executes an `INSERT` statement into the `\"Renting_history\"` table. The `INSERT` statement populates the `id`, `customer_id`, `discount_id`, `vehicles_id`, and `total_hours` columns. The values for these columns are determined as follows:\n- For the `id` column: A subquery `(SELECT COALESCE(MAX(id), 0) + 1 FROM \"Renting_history\")` is used. This subquery finds the maximum `id` currently present in the `\"Renting_history\"` table. If no records exist (i.e., `MAX(id)` returns `NULL`), `COALESCE` ensures that `0` is used instead. `1` is then added to this result to generate a new, unique `id`.\n- For the `customer_id` column: The `id` of the current customer record from the loop, `v_customer_record.id`, is used.\n- For the `discount_id` column: The input parameter `p_discount_id` is used.\n- For the `vehicles_id` column: A subquery `(SELECT id FROM \"Vehicles\" ORDER BY RANDOM() LIMIT 1)` is used. This subquery randomly selects one `id` from the `\"Vehicles\"` table.\n- For the `total_hours` column: The `age` of the current customer record, `v_customer_record.age`, is multiplied by `0.5`, and the result is then explicitly cast to an `integer` type using `CAST(... AS integer)`.\n\nThe `FOR` loop continues until all eligible customer records have been processed, and for each, a new entry is inserted into the `\"Renting_history\"` table. The procedure concludes after the `FOR` loop finishes.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_customer_discount_relationships(p_discount_id integer, p_min_age integer, p_max_age integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_discount_credit integer;\n    v_customer_record RECORD;\nBEGIN\n    SELECT membership_credit INTO v_discount_credit FROM \"Discount\" WHERE id = p_discount_id;\n    \n    FOR v_customer_record IN \n        SELECT c.id, c.name, c.age, c.membership_credit\n        FROM \"Customers\" c\n        WHERE c.age BETWEEN p_min_age AND p_max_age\n        AND c.membership_credit >= v_discount_credit\n    LOOP\n        INSERT INTO \"Renting_history\" (id, customer_id, discount_id, vehicles_id, total_hours)\n        VALUES (\n            (SELECT COALESCE(MAX(id), 0) + 1 FROM \"Renting_history\"),\n            v_customer_record.id,\n            p_discount_id,\n            (SELECT id FROM \"Vehicles\" ORDER BY RANDOM() LIMIT 1),\n            CAST(v_customer_record.age * 0.5 AS integer)\n        );\n    END LOOP;\nEND;\n$$;",
    "database_name": "vehicle_rent",
    "tables": [
      "Customers",
      "Discount",
      "Renting_history",
      "Vehicles"
    ],
    "call_sqls": [
      "CALL manage_customer_discount_relationships(1, 20, 30);",
      "CALL manage_customer_discount_relationships(2, 25, 40);",
      "CALL manage_customer_discount_relationships(3, 30, 50);",
      "CALL manage_customer_discount_relationships(2, 35, 45);",
      "CALL manage_customer_discount_relationships(3, 40, 60);",
      "CALL manage_customer_discount_relationships(1, 22, 28);",
      "CALL manage_customer_discount_relationships(2, 28, 38);",
      "CALL manage_customer_discount_relationships(3, 45, 55);",
      "CALL manage_customer_discount_relationships(1, 30, 35);",
      "CALL manage_customer_discount_relationships(2, 20, 35);",
      "CALL manage_customer_discount_relationships(3, 25, 45);",
      "CALL manage_customer_discount_relationships(1, 40, 50);",
      "CALL manage_customer_discount_relationships(2, 50, 65);",
      "CALL manage_customer_discount_relationships(1, 55, 70);",
      "CALL manage_customer_discount_relationships(2, 32, 42);",
      "CALL manage_customer_discount_relationships(3, 38, 48);",
      "CALL manage_customer_discount_relationships(1, 26, 34);",
      "CALL manage_customer_discount_relationships(2, 42, 52);"
    ],
    "id": 168
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_team_player_count` that accepts a single input parameter, `p_team_name`, of type `text`. This function is designed to return a `bigint` value representing the count of players associated with the specified team. Upon execution, the function first declares a local variable named `player_count` of type `bigint` to store the result of a database query. It then proceeds to execute a `SELECT` statement to count the number of rows in the `players` table. The `COUNT(*)` aggregate function is used to determine the total number of players. This count is filtered by a `WHERE` clause, which ensures that only players whose `current_team` column matches the value provided in the `p_team_name` input parameter are included in the count. The result of this `COUNT(*)` operation is then assigned to the `player_count` variable. Following this, the function evaluates a conditional `IF` statement. It checks if the value stored in `player_count` is strictly greater than `10`. If this condition evaluates to true, an `UPDATE` statement is executed on the `teams` table. This `UPDATE` statement sets the `division` column to the literal string value `'Large'` for any row in the `teams` table where the `team_name` column matches the value provided in the `p_team_name` input parameter. Regardless of whether the `IF` condition was met or not, the function concludes by returning the final value stored in the `player_count` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_team_player_count(p_team_name text) RETURNS bigint LANGUAGE plpgsql AS $$ DECLARE player_count bigint; BEGIN SELECT COUNT(*) INTO player_count FROM players WHERE current_team = p_team_name; IF player_count > 10 THEN UPDATE teams SET division = 'Large' WHERE team_name = p_team_name; END IF; RETURN player_count; END; $$;",
    "database_name": "american_football_player_information_and_statistics",
    "tables": [
      "players",
      "deaths",
      "draft_info",
      "player_college",
      "player_position",
      "positions",
      "teams"
    ],
    "call_sqls": [
      "SELECT calculate_team_player_count('Miami Dolphins');",
      "SELECT calculate_team_player_count('New England Patriots');",
      "SELECT calculate_team_player_count('Buffalo Bills');",
      "SELECT calculate_team_player_count('New York Jets');",
      "SELECT calculate_team_player_count('Kansas City Chiefs');",
      "SELECT calculate_team_player_count('Philadelphia Eagles');",
      "SELECT calculate_team_player_count('San Francisco 49ers');",
      "SELECT calculate_team_player_count('Dallas Cowboys');",
      "SELECT calculate_team_player_count('Green Bay Packers');",
      "SELECT calculate_team_player_count('Los Angeles Rams');",
      "SELECT calculate_team_player_count('Cincinnati Bengals');",
      "SELECT calculate_team_player_count('Baltimore Ravens');",
      "SELECT calculate_team_player_count('Cleveland Browns');",
      "SELECT calculate_team_player_count('Pittsburgh Steelers');",
      "SELECT calculate_team_player_count('Tennessee Titans');",
      "SELECT calculate_team_player_count('Jacksonville Jaguars');",
      "SELECT calculate_team_player_count('Indianapolis Colts');",
      "SELECT calculate_team_player_count('Houston Texans');",
      "SELECT calculate_team_player_count('Denver Broncos');",
      "SELECT calculate_team_player_count('Las Vegas Raiders');"
    ],
    "id": 169
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named update_player_team that accepts two mandatory input parameters: para_player_id of type bigint, which specifies the unique identifier of the player to be updated, and para_new_team_id of type bigint, which specifies the new team identifier to be assigned to that player. The function returns void, meaning it does not return a value. The function's logic begins by checking for the existence of a record in the players table where the player_id column exactly matches the provided para_player_id input parameter; this is done using a conditional IF statement with an EXISTS subquery that selects the constant value 1 from the players table filtered by the condition player_id = para_player_id. If the subquery returns at least one row, confirming the player exists, the function proceeds to execute an UPDATE operation on the players table, setting the team_id column to the value of the para_new_team_id input parameter specifically for the row where the player_id column equals the para_player_id input parameter. If the EXISTS check finds no matching player, the function takes no action and simply concludes.",
    "plsql": "CREATE OR REPLACE FUNCTION update_player_team(para_player_id bigint, para_new_team_id bigint) RETURNS void LANGUAGE plpgsql AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM players WHERE player_id = para_player_id) THEN\n        UPDATE players SET team_id = para_new_team_id WHERE player_id = para_player_id;\n    END IF;\nEND;\n$$;",
    "database_name": "soccer_match_statistics_and_player_performance_tracking",
    "tables": [
      "matches",
      "players",
      "teams",
      "player_performance",
      "player_transfers",
      "seasons"
    ],
    "call_sqls": [
      "SELECT update_player_team(5, 3);",
      "SELECT update_player_team(10, 1);",
      "SELECT update_player_team(15, 4);",
      "SELECT update_player_team(20, 5);",
      "SELECT update_player_team(25, 6);",
      "SELECT update_player_team(30, 7);",
      "SELECT update_player_team(35, 8);",
      "SELECT update_player_team(40, 9);",
      "SELECT update_player_team(45, 10);",
      "SELECT update_player_team(50, 11);",
      "SELECT update_player_team(55, 12);",
      "SELECT update_player_team(60, 13);",
      "SELECT update_player_team(65, 14);",
      "SELECT update_player_team(70, 15);",
      "SELECT update_player_team(75, 16);",
      "SELECT update_player_team(80, 17);",
      "SELECT update_player_team(85, 18);",
      "SELECT update_player_team(90, 19);",
      "SELECT update_player_team(95, 20);",
      "SELECT update_player_team(100, 21);"
    ],
    "id": 170
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_aircraft_status` that accepts two input parameters: `p_aircraft_id`, which is of data type `NUMBER` and represents the unique identifier for an aircraft, and `p_date`, which is of data type `VARCHAR2` and represents a specific date in a string format. This function is designed to return a single value of data type `VARCHAR2`, representing the status of the aircraft. Upon execution, the function declares a local variable named `v_status` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved aircraft status. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `aircraft` table. Specifically, it selects the value from the `status` column and attempts to store this value into the `v_status` local variable. This selection is performed under two conditions combined with a logical `AND` operator: first, the value in the `aircraft_id` column of the `aircraft` table must be equal to the value provided in the `p_aircraft_id` input parameter; and second, the value in the `next_maintenance_date` column of the `aircraft` table must be strictly greater than the value provided in the `p_date` input parameter. After successfully retrieving the `status` value into `v_status` based on these conditions, the function then returns the final value stored in the `v_status` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_aircraft_status(p_aircraft_id NUMBER, p_date VARCHAR2) RETURN VARCHAR2 IS\n  v_status VARCHAR2(255);\nBEGIN\n  SELECT status INTO v_status\n  FROM aircraft\n  WHERE aircraft_id = p_aircraft_id AND next_maintenance_date > p_date;\n  RETURN v_status;\nEND;",
    "database_name": "aircraft_fdap_analysis",
    "tables": [
      "flights",
      "aircraft",
      "flight_types",
      "users",
      "flight_data",
      "sensors",
      "data_units",
      "flight_parameters"
    ],
    "call_sqls": [
      "SELECT get_aircraft_status(101, '2024-01-15') FROM dual",
      "SELECT get_aircraft_status(102, '2024-02-20') FROM dual",
      "SELECT get_aircraft_status(103, '2024-03-10') FROM dual",
      "SELECT get_aircraft_status(104, '2024-04-05') FROM dual",
      "SELECT get_aircraft_status(105, '2024-05-22') FROM dual",
      "SELECT get_aircraft_status(106, '2024-06-30') FROM dual",
      "SELECT get_aircraft_status(107, '2024-07-18') FROM dual",
      "SELECT get_aircraft_status(108, '2024-08-11') FROM dual",
      "SELECT get_aircraft_status(109, '2024-09-25') FROM dual",
      "SELECT get_aircraft_status(110, '2024-10-03') FROM dual",
      "SELECT get_aircraft_status(201, '2024-11-14') FROM dual",
      "SELECT get_aircraft_status(202, '2024-12-01') FROM dual",
      "SELECT get_aircraft_status(203, '2025-01-19') FROM dual",
      "SELECT get_aircraft_status(204, '2025-02-28') FROM dual",
      "SELECT get_aircraft_status(205, '2025-03-15') FROM dual",
      "SELECT get_aircraft_status(301, '2025-04-10') FROM dual",
      "SELECT get_aircraft_status(302, '2025-05-05') FROM dual",
      "SELECT get_aircraft_status(303, '2025-06-20') FROM dual",
      "SELECT get_aircraft_status(304, '2025-07-07') FROM dual",
      "SELECT get_aircraft_status(305, '2025-08-31') FROM dual"
    ],
    "id": 171
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_team_dataset_count that accepts three input parameters: a bigint parameter named p_team_id representing a specific research team identifier, a text parameter named p_start_date representing the inclusive lower bound of a date range, and a text parameter named p_end_date representing the inclusive upper bound of a date range, and returns a single bigint value. The function executes a single SQL SELECT statement that queries the datasets table, applying a condition where the research_team_id column must exactly equal the provided p_team_id parameter value and simultaneously the upload_date column must fall within the inclusive range specified by the p_start_date and p_end_date parameters. The function performs an aggregation using the COUNT(*) operation on all rows from the datasets table that satisfy these combined conditions, thereby calculating the total number of dataset records associated with the given research team and uploaded within the specified date interval, and returns this computed count as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_dataset_count(p_team_id bigint, p_start_date text, p_end_date text)\nRETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM datasets WHERE research_team_id = p_team_id AND upload_date BETWEEN p_start_date AND p_end_date);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "geographical_and_river_basin_analysis",
    "tables": [
      "datasets",
      "data_files",
      "access_logs",
      "users",
      "research_teams"
    ],
    "call_sqls": [
      "SELECT get_team_dataset_count(0, '2023-01-01', '2023-12-31');",
      "SELECT get_team_dataset_count(1, '2023-01-01', '2023-12-31');",
      "SELECT get_team_dataset_count(0, '2023-06-01', '2023-06-30');",
      "SELECT get_team_dataset_count(1, '2023-06-01', '2023-06-30');",
      "SELECT get_team_dataset_count(2, '2023-01-01', '2023-12-31');",
      "SELECT get_team_dataset_count(0, '2023-03-01', '2023-03-31');",
      "SELECT get_team_dataset_count(1, '2023-03-01', '2023-03-31');",
      "SELECT get_team_dataset_count(0, '2023-07-01', '2023-07-31');",
      "SELECT get_team_dataset_count(1, '2023-07-01', '2023-07-31');",
      "SELECT get_team_dataset_count(3, '2023-01-01', '2023-12-31');",
      "SELECT get_team_dataset_count(0, '2023-09-01', '2023-09-30');",
      "SELECT get_team_dataset_count(1, '2023-09-01', '2023-09-30');",
      "SELECT get_team_dataset_count(4, '2023-01-01', '2023-12-31');",
      "SELECT get_team_dataset_count(0, '2023-11-01', '2023-11-30');",
      "SELECT get_team_dataset_count(1, '2023-11-01', '2023-11-30');",
      "SELECT get_team_dataset_count(5, '2023-01-01', '2023-12-31');",
      "SELECT get_team_dataset_count(0, '2023-12-01', '2023-12-31');",
      "SELECT get_team_dataset_count(1, '2023-12-01', '2023-12-31');",
      "SELECT get_team_dataset_count(10, '2023-01-01', '2023-12-31');",
      "SELECT get_team_dataset_count(0, '2023-04-15', '2023-05-15');"
    ],
    "id": 172
  },
  {
    "ir": "Write a PLpgSQL function that calculates the total delegation amount for a specific validator by taking a single parameter, para_validator_id, of type bigint, which represents the unique identifier of the validator. The function declares a variable total_delegation of type real to store the result of the calculation. It performs a SELECT operation on the delegations table, specifically summing up the values in the delegation_amount column for all rows where the validator_id column matches the provided para_validator_id parameter. The result of this aggregation is stored into the total_delegation variable. Finally, the function returns the calculated total_delegation value as a real number.",
    "plsql": "CREATE OR REPLACE FUNCTION sp_calculate_total_delegation(para_validator_id bigint) RETURNS real LANGUAGE plpgsql AS $$\nDECLARE\n  total_delegation real;\nBEGIN\n  SELECT SUM(delegation_amount) INTO total_delegation\n  FROM delegations\n  WHERE validator_id = para_validator_id;\n  \n  RETURN total_delegation;\nEND;\n$$;",
    "database_name": "blockchain_validator_and_delegation_management",
    "tables": [
      "delegations",
      "undelegations",
      "validator_delegation_history"
    ],
    "call_sqls": [
      "SELECT sp_calculate_total_delegation(1001);",
      "SELECT sp_calculate_total_delegation(1002);",
      "SELECT sp_calculate_total_delegation(1003);",
      "SELECT sp_calculate_total_delegation(1004);",
      "SELECT sp_calculate_total_delegation(1005);",
      "SELECT sp_calculate_total_delegation(1006);",
      "SELECT sp_calculate_total_delegation(1007);",
      "SELECT sp_calculate_total_delegation(1008);",
      "SELECT sp_calculate_total_delegation(1009);",
      "SELECT sp_calculate_total_delegation(1010);",
      "SELECT sp_calculate_total_delegation(1011);",
      "SELECT sp_calculate_total_delegation(1012);",
      "SELECT sp_calculate_total_delegation(1013);",
      "SELECT sp_calculate_total_delegation(1014);",
      "SELECT sp_calculate_total_delegation(1015);",
      "SELECT sp_calculate_total_delegation(1016);",
      "SELECT sp_calculate_total_delegation(1017);",
      "SELECT sp_calculate_total_delegation(1018);",
      "SELECT sp_calculate_total_delegation(1019);",
      "SELECT sp_calculate_total_delegation(1020);"
    ],
    "id": 173
  },
  {
    "ir": "Write a PLpgSQL function that is triggered after a new row is inserted into the complaints table, which automatically assigns an engineer to handle the complaint. The function inserts a new record into the assignments table with the following details: a unique assignment_id calculated as one more than the current maximum assignment_id in the assignments table, the complain_id from the newly inserted row in the complaints table, the engineer_id of an engineer whose specialization matches the appliance_type of the appliance associated with the complaint, which is determined by looking up the appliance_id from the newly inserted row in the appliances table, the complain_date from the newly inserted row as the assignment_date, a status set to 'In Progress', an assignment_priority set to 'Medium', and the complain_date again as the estimated_completion_date. The function uses a subquery to find the first engineer with the required specialization and defaults to a new assignment_id of 0 if no assignments currently exist. The trigger named trg_auto_assign_engineer is defined to execute this function for each new row inserted into the complaints table.",
    "plsql": "CREATE OR REPLACE FUNCTION auto_assign_engineer() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO assignments (assignment_id, complain_id, engineer_id, assignment_date, status, assignment_priority, estimated_completion_date)\n    VALUES ((SELECT COALESCE(MAX(assignment_id), -1) + 1 FROM assignments), NEW.complain_id, \n           (SELECT engineer_id FROM engineers WHERE specialization = (SELECT appliance_type FROM appliances WHERE appliance_id = NEW.appliance_id) LIMIT 1),\n           NEW.complain_date, 'In Progress', 'Medium', NEW.complain_date);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_auto_assign_engineer\n    AFTER INSERT ON complaints\n    FOR EACH ROW\n    EXECUTE FUNCTION auto_assign_engineer();",
    "database_name": "appliance_maintenance_and_repair_management",
    "tables": [
      "appliances",
      "assignments",
      "complaint_channel",
      "complaints",
      "customers",
      "engineers",
      "repair_metrics"
    ],
    "call_sqls": [
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (100, '2024-01-15', 5, 1, 'Not cooling properly', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (101, '2024-01-16', 6, 0, 'Door not sealing', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (102, '2024-01-17', 7, 1, 'Making loud noise', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (103, '2024-01-18', 8, 0, 'Water dispenser not working', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (104, '2024-01-19', 9, 1, 'Freezer not freezing', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (105, '2024-01-20', 10, 0, 'Light not working', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (106, '2024-01-21', 11, 1, 'Temperature fluctuation', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (107, '2024-01-22', 12, 0, 'Ice maker broken', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (108, '2024-01-23', 13, 1, 'Condensation issue', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (109, '2024-01-24', 14, 0, 'Control panel faulty', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (110, '2024-01-25', 15, 1, 'Compressor failure', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (111, '2024-01-26', 16, 0, 'Defrost system problem', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (112, '2024-01-27', 17, 1, 'Fan motor noisy', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (113, '2024-01-28', 18, 0, 'Drain clogged', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (114, '2024-01-29', 19, 1, 'Evaporator coils frozen', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (115, '2024-01-30', 20, 0, 'Gasket torn', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (116, '2024-01-31', 21, 1, 'Thermostat inaccurate', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (117, '2024-02-01', 22, 0, 'Start relay faulty', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (118, '2024-02-02', 23, 1, 'Capacitor failed', 'Open');",
      "INSERT INTO complaints (complain_id, complain_date, customer_id, appliance_id, complaint_description, complaint_status) VALUES (119, '2024-02-03', 24, 0, 'Overheating', 'Open');"
    ],
    "id": 174
  },
  {
    "ir": "Write a PLpgSQL stored procedure named synchronize_algorithm_versions that accepts three input parameters: p_source_algorithm_id of type bigint which identifies the source algorithm record to be copied, p_target_version of type text which represents the new version number to be applied, and p_modifier_user_id of type bigint which identifies the user performing the synchronization operation. The procedure first declares a RECORD variable named source_data to store algorithm data and two text array variables named version_parts and new_version_parts to handle version string manipulation. The procedure then executes a SELECT statement to retrieve the name, typical_code_framework, description, order_of_growth, example_use_case, and version columns from the algorithms table where the algorithm_id column matches the p_source_algorithm_id parameter, storing these values in the source_data record. Next, the procedure uses the string_to_array function to split the version string from source_data.version using '.' as a delimiter, storing the result in the version_parts array. The procedure then employs the array_replace function to create new_version_parts by replacing the first element of version_parts (version_parts[1]) with the p_target_version parameter value. Finally, the procedure performs an INSERT operation into the algorithms table, creating a new algorithm record with: an algorithm_id calculated as the maximum existing algorithm_id plus one (using a COALESCE function to handle the case of no existing records), a name constructed by concatenating the source_data.name with '_v' and the new version string (using array_to_string to join new_version_parts with '.'), the same typical_code_framework, description, order_of_growth, and example_use_case values from the source_data record, a time_complexity_ratio set to 1.0, the new version string (again using array_to_string to join new_version_parts with '.'), both created_by and last_modified_by set to p_modifier_user_id, both created_date and last_modified_date set to the current date (converted to text), and the status column set to 'active'.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_algorithm_versions(\n    p_source_algorithm_id bigint,\n    p_target_version text,\n    p_modifier_user_id bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    source_data RECORD;\n    version_parts text[];\n    new_version_parts text[];\nBEGIN\n    SELECT name, typical_code_framework, description, order_of_growth, example_use_case, version\n    INTO source_data\n    FROM algorithms\n    WHERE algorithm_id = p_source_algorithm_id;\n    \n    version_parts := string_to_array(source_data.version, '.');\n    new_version_parts := array_replace(version_parts, version_parts[1], p_target_version);\n    \n    INSERT INTO algorithms (\n        algorithm_id,\n        name,\n        typical_code_framework,\n        description,\n        order_of_growth,\n        example_use_case,\n        time_complexity_ratio,\n        version,\n        created_by,\n        created_date,\n        last_modified_by,\n        last_modified_date,\n        status\n    )\n    SELECT \n        (SELECT COALESCE(MAX(algorithm_id), 0) + 1 FROM algorithms),\n        source_data.name || '_v' || array_to_string(new_version_parts, '.'),\n        source_data.typical_code_framework,\n        source_data.description,\n        source_data.order_of_growth,\n        source_data.example_use_case,\n        1.0,\n        array_to_string(new_version_parts, '.'),\n        p_modifier_user_id,\n        CURRENT_DATE::text,\n        p_modifier_user_id,\n        CURRENT_DATE::text,\n        'active';\nEND;\n$$;",
    "database_name": "algorithm_performance_analysis_and_benchmarking",
    "tables": [
      "access_logs",
      "algorithms",
      "benchmarks",
      "performance_metrics",
      "users"
    ],
    "call_sqls": [
      "CALL synchronize_algorithm_versions(1, '2', 100);",
      "CALL synchronize_algorithm_versions(2, '3', 101);",
      "CALL synchronize_algorithm_versions(3, '2', 102);",
      "CALL synchronize_algorithm_versions(1, '4', 103);",
      "CALL synchronize_algorithm_versions(4, '5', 100);",
      "CALL synchronize_algorithm_versions(5, '2', 101);",
      "CALL synchronize_algorithm_versions(2, '6', 102);",
      "CALL synchronize_algorithm_versions(6, '3', 103);",
      "CALL synchronize_algorithm_versions(3, '7', 100);",
      "CALL synchronize_algorithm_versions(7, '2', 101);",
      "CALL synchronize_algorithm_versions(4, '8', 102);",
      "CALL synchronize_algorithm_versions(8, '3', 103);",
      "CALL synchronize_algorithm_versions(5, '9', 100);",
      "CALL synchronize_algorithm_versions(9, '2', 101);",
      "CALL synchronize_algorithm_versions(6, '10', 102);",
      "CALL synchronize_algorithm_versions(10, '3', 103);",
      "CALL synchronize_algorithm_versions(7, '11', 100);",
      "CALL synchronize_algorithm_versions(11, '2', 101);",
      "CALL synchronize_algorithm_versions(8, '12', 102);",
      "CALL synchronize_algorithm_versions(12, '3', 103);"
    ],
    "id": 175
  },
  {
    "ir": "Write a PLpgSQL function named calculate_seasonal_yield_variance that accepts two parameters: p_treatment_id of type bigint, which specifies the treatment identifier, and p_yield_unit of type text, which specifies the unit of yield measurement. The function returns a real number representing the variance of yield values. It begins by declaring local variables: v_yield_values as an array of real numbers to store yield values, v_avg_yield as a real number to store the average yield, v_variance as a real number to store the calculated variance, and v_count as an integer to store the count of yield records. The function executes a SELECT statement to populate v_yield_values with an array of yield values from the performance_metrics table, joined with the field_trials table on the trial_id column, filtered by the specified treatment_id and yield_unit. It then calculates the average yield and the count of records by executing another SELECT statement, storing the results in v_avg_yield and v_count, respectively. If v_count is greater than 1, indicating more than one yield record, the function calculates the variance by executing a SELECT statement that computes the sum of squared differences between each yield and the average yield, divided by v_count minus one, storing the result in v_variance. If v_count is not greater than 1, the function sets v_variance to 0. Finally, the function returns the calculated variance.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_seasonal_yield_variance(p_treatment_id bigint, p_yield_unit text)\nRETURNS real AS $$\nDECLARE\n    v_yield_values real[];\n    v_avg_yield real;\n    v_variance real;\n    v_count integer;\nBEGIN\n    SELECT ARRAY(SELECT yield FROM performance_metrics pm\n                JOIN field_trials ft ON pm.trial_id = ft.trial_id\n                WHERE ft.treatment_id = p_treatment_id AND pm.yield_unit = p_yield_unit)\n    INTO v_yield_values;\n    \n    SELECT AVG(yield), COUNT(*) INTO v_avg_yield, v_count\n    FROM performance_metrics pm\n    JOIN field_trials ft ON pm.trial_id = ft.trial_id\n    WHERE ft.treatment_id = p_treatment_id AND pm.yield_unit = p_yield_unit;\n    \n    IF v_count > 1 THEN\n        SELECT SUM(POWER(yield - v_avg_yield, 2)) / (v_count - 1) INTO v_variance\n        FROM performance_metrics pm\n        JOIN field_trials ft ON pm.trial_id = ft.trial_id\n        WHERE ft.treatment_id = p_treatment_id AND pm.yield_unit = p_yield_unit;\n    ELSE\n        v_variance := 0;\n    END IF;\n    \n    RETURN v_variance;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "agricultural_research_and_data_analysis_389617",
    "tables": [
      "field_trials",
      "performance_metrics",
      "treatments",
      "treatment_inputs"
    ],
    "call_sqls": [
      "SELECT calculate_seasonal_yield_variance(0, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(1, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(2, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(3, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(4, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(0, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(1, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(2, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(3, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(4, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(5, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(6, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(7, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(8, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(9, 'bushels per acre');",
      "SELECT calculate_seasonal_yield_variance(5, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(6, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(7, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(8, 'tons per hectare');",
      "SELECT calculate_seasonal_yield_variance(9, 'tons per hectare');"
    ],
    "id": 176
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_permission_asin that accepts three parameters: p_role_id, p_permission_id, and p_dummy_param, all of which are of the NUMBER data type. The function is designed to return a NUMBER. Within the function, a local variable v_count of type NUMBER is declared. The function performs a SELECT operation to count the number of rows in the role_permissions table where the role_id column matches the value of the p_role_id parameter and the permission_id column matches the value of the p_permission_id parameter. The result of this count is stored in the v_count variable. The function is intended to return the count of matching rows, which represents the number of permissions associated with the specified role. The comment within the code indicates that the ASIN function, which calculates the arc sine of a number, expects an argument between -1 and 1, and directly applying ASIN to a count greater than 1 would result in an error (ORA-01428). However, the function does not actually apply the ASIN function; instead, it simply returns the count of matching permissions.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_permission_asin(p_role_id NUMBER, p_permission_id NUMBER, p_dummy_param NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM role_permissions WHERE role_id = p_role_id AND permission_id = p_permission_id;\n  -- The ASIN function expects an argument between -1 and 1.\n  -- Directly applying ASIN to a count (which can be > 1) would cause ORA-01428.\n  -- Assuming the intent was to return the count of matching permissions.\n  RETURN v_count;\nEND;",
    "database_name": "apartment_r_management",
    "tables": [
      "roles",
      "role_permissions"
    ],
    "call_sqls": [
      "SELECT calculate_permission_asin(1, 101, 0) FROM dual",
      "SELECT calculate_permission_asin(2, 102, 0) FROM dual",
      "SELECT calculate_permission_asin(3, 103, 0) FROM dual",
      "SELECT calculate_permission_asin(1, 201, 0) FROM dual",
      "SELECT calculate_permission_asin(2, 202, 0) FROM dual",
      "SELECT calculate_permission_asin(3, 203, 0) FROM dual",
      "SELECT calculate_permission_asin(10, 5, 0) FROM dual",
      "SELECT calculate_permission_asin(15, 25, 0) FROM dual",
      "SELECT calculate_permission_asin(100, 50, 0) FROM dual",
      "SELECT calculate_permission_asin(500, 600, 0) FROM dual",
      "SELECT calculate_permission_asin(999, 888, 0) FROM dual",
      "SELECT calculate_permission_asin(7, 14, 0) FROM dual",
      "SELECT calculate_permission_asin(42, 24, 0) FROM dual",
      "SELECT calculate_permission_asin(77, 33, 0) FROM dual",
      "SELECT calculate_permission_asin(0, 0, 0) FROM dual",
      "SELECT calculate_permission_asin(1, 9999, 0) FROM dual",
      "SELECT calculate_permission_asin(9999, 1, 0) FROM dual",
      "SELECT calculate_permission_asin(123, 456, 0) FROM dual",
      "SELECT calculate_permission_asin(789, 101, 0) FROM dual",
      "SELECT calculate_permission_asin(50, 50, 0) FROM dual"
    ],
    "id": 177
  },
  {
    "ir": "Write a PL/pgSQL function named `update_register_value` that accepts two input parameters: `register_id_input` of type `bigint` representing the unique identifier of a register, and `new_value` of type `text` representing the new textual value to be assigned to the register. This function is designed to return a `text` value indicating the outcome of its execution. The function's execution begins by declaring a local variable named `result` of type `text` to store the status message. It then proceeds with a conditional check: it queries the `register_versions` table to determine if any record exists where the `register_id` column matches the provided `register_id_input` and the `is_default` column has a value of `1`. If such a record is found, indicating the presence of a default version for the specified register, the function executes an `UPDATE` operation on the `register_versions` table. This `UPDATE` statement sets the `register_value` column to the `new_value` for all rows where the `register_id` column matches `register_id_input` and the `is_default` column is `1`. Following this update, the `result` variable is assigned the string literal 'Updated'. If, however, the initial conditional check finds no records in the `register_versions` table where `register_id` matches `register_id_input` and `is_default` is `1`, meaning no default register version is found, the `result` variable is assigned the string literal 'No default register found'. Finally, the function returns the value stored in the `result` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION update_register_value(register_id_input bigint, new_value text) RETURNS text AS $$\nDECLARE\n    result text;\nBEGIN\n    IF EXISTS (SELECT 1 FROM register_versions WHERE register_id = register_id_input AND is_default = 1) THEN\n        UPDATE register_versions SET register_value = new_value WHERE register_id = register_id_input AND is_default = 1;\n        result := 'Updated';\n    ELSE\n        result := 'No default register found';\n    END IF;\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "chroma_resampler_register_management",
    "tables": [
      "register_versions"
    ],
    "call_sqls": [
      "SELECT update_register_value(2, 'New_Value_001');",
      "SELECT update_register_value(3, 'Updated_Release_Info');",
      "SELECT update_register_value(5, 'Test_Value_123');",
      "SELECT update_register_value(1, 'Initial_Setup');",
      "SELECT update_register_value(4, 'Configuration_A');",
      "SELECT update_register_value(6, 'Debug_Mode_On');",
      "SELECT update_register_value(7, 'Production_Ready');",
      "SELECT update_register_value(8, 'Beta_Feature_Enabled');",
      "SELECT update_register_value(9, 'Security_Patch_v2');",
      "SELECT update_register_value(10, 'User_Preference_Saved');",
      "SELECT update_register_value(11, 'System_Default_Reset');",
      "SELECT update_register_value(12, 'New_Firmware_Loaded');",
      "SELECT update_register_value(13, 'Calibration_Complete');",
      "SELECT update_register_value(14, 'Network_Config');",
      "SELECT update_register_value(15, 'Log_Level_Info');",
      "SELECT update_register_value(16, 'Backup_Restored');",
      "SELECT update_register_value(17, 'Time_Zone_EST');",
      "SELECT update_register_value(18, 'Language_EN');",
      "SELECT update_register_value(19, 'Auto_Update_On');",
      "SELECT update_register_value(20, 'Final_Value_Test');"
    ],
    "id": 178
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_part_category that accepts a single input parameter p_part_id of type NUMBER and returns a VARCHAR2 value, which declares a local variable v_category_name of type VARCHAR2(255) to store the intermediate result, then executes a SELECT query that joins the part_categories table (aliased as pc) with the part_category_map table (aliased as pcm) using the condition pc.category_id = pcm.category_id, filters the joined result set to only include rows where pcm.part_id equals the input parameter p_part_id, retrieves the category_name column from the part_categories table into the v_category_name variable, and finally returns the value stored in v_category_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_part_category(p_part_id NUMBER) RETURN VARCHAR2 IS\n    v_category_name VARCHAR2(255);\nBEGIN\n    SELECT pc.category_name\n    INTO v_category_name\n    FROM part_categories pc\n    JOIN part_category_map pcm ON pc.category_id = pcm.category_id\n    WHERE pcm.part_id = p_part_id;\n    \n    RETURN v_category_name;\nEND;",
    "database_name": "aerospace_pi_management",
    "tables": [
      "aircraft_models",
      "parts",
      "part_categories",
      "part_category_map",
      "inventory",
      "maintenance_records",
      "purchase_orders",
      "safety_compliance"
    ],
    "call_sqls": [
      "SELECT get_part_category(0) FROM DUAL",
      "SELECT get_part_category(1) FROM DUAL",
      "SELECT get_part_category(10) FROM DUAL",
      "SELECT get_part_category(25) FROM DUAL",
      "SELECT get_part_category(50) FROM DUAL",
      "SELECT get_part_category(100) FROM DUAL",
      "SELECT get_part_category(150) FROM DUAL",
      "SELECT get_part_category(200) FROM DUAL",
      "SELECT get_part_category(300) FROM DUAL",
      "SELECT get_part_category(500) FROM DUAL",
      "SELECT p.part_id, get_part_category(p.part_id) FROM parts p WHERE p.part_id = 1",
      "SELECT p.part_id, get_part_category(p.part_id) FROM parts p WHERE p.part_id = 5",
      "SELECT i.inventory_id, i.part_id, get_part_category(i.part_id) FROM inventory i WHERE i.part_id = 15",
      "SELECT mr.record_id, mr.part_id, get_part_category(mr.part_id) FROM maintenance_records mr WHERE mr.part_id = 20",
      "SELECT po.order_id, po.part_id, get_part_category(po.part_id) FROM purchase_orders po WHERE po.part_id = 30",
      "SELECT sc.compliance_id, sc.part_id, get_part_category(sc.part_id) FROM safety_compliance sc WHERE sc.part_id = 40",
      "SELECT get_part_category(p.part_id) FROM parts p WHERE p.part_number = 'PHCD-R-001'",
      "SELECT get_part_category(p.part_id) FROM parts p WHERE p.part_number = 'PHCD-R-002'",
      "SELECT get_part_category(NULL) FROM DUAL"
    ],
    "id": 179
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_dataset_priority_score that takes a single input parameter p_dataset_id of type bigint and returns a bigint value representing a priority score. The function first declares two local variables v_published and v_sector_id, both of type bigint. It then executes a SELECT statement on the economic_datasets table to retrieve the values of the published and economic_sector_id columns for the row where dataset_id equals the input parameter p_dataset_id, storing these values in the local variables v_published and v_sector_id respectively. The function then evaluates a series of conditional statements to determine the priority score: if v_published equals 1 and v_sector_id is not NULL, it returns 100; else if v_published equals 1 and v_sector_id is NULL, it returns 75; else if v_published equals 0 and v_sector_id is not NULL, it returns 50; otherwise, which would be when v_published equals 0 and v_sector_id is NULL, it returns 25.",
    "plsql": "CREATE OR REPLACE FUNCTION get_dataset_priority_score(p_dataset_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    v_published bigint;\n    v_sector_id bigint;\nBEGIN\n    SELECT published, economic_sector_id INTO v_published, v_sector_id\n    FROM economic_datasets WHERE dataset_id = p_dataset_id;\n    \n    IF v_published = 1 AND v_sector_id IS NOT NULL THEN\n        RETURN 100;\n    ELSIF v_published = 1 AND v_sector_id IS NULL THEN\n        RETURN 75;\n    ELSIF v_published = 0 AND v_sector_id IS NOT NULL THEN\n        RETURN 50;\n    ELSE\n        RETURN 25;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "economic_data_analysis_and_time_series",
    "tables": [
      "economic_datasets"
    ],
    "call_sqls": [
      "SELECT get_dataset_priority_score(1);",
      "SELECT get_dataset_priority_score(2);",
      "SELECT get_dataset_priority_score(3);",
      "SELECT get_dataset_priority_score(4);",
      "SELECT get_dataset_priority_score(5);",
      "SELECT get_dataset_priority_score(10);",
      "SELECT get_dataset_priority_score(15);",
      "SELECT get_dataset_priority_score(20);",
      "SELECT get_dataset_priority_score(25);",
      "SELECT get_dataset_priority_score(30);",
      "SELECT get_dataset_priority_score(35);",
      "SELECT get_dataset_priority_score(40);",
      "SELECT get_dataset_priority_score(45);",
      "SELECT get_dataset_priority_score(50);",
      "SELECT get_dataset_priority_score(55);",
      "SELECT get_dataset_priority_score(60);",
      "SELECT get_dataset_priority_score(65);",
      "SELECT get_dataset_priority_score(70);",
      "SELECT get_dataset_priority_score(75);",
      "SELECT get_dataset_priority_score(80);",
      "SELECT get_dataset_priority_score(100);"
    ],
    "id": 180
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_portfolio_risk that accepts a single input parameter named portfolio_threshold of type NUMBER and returns a value of type NUMBER, which initializes a local variable total_risk to zero, then declares and opens a cursor named asset_cursor that performs a SELECT operation joining the assets, trades, and trade_executions tables to retrieve each unique asset_id from the assets table and the sum of the product of the quantity and execution_price columns from the trade_executions table for all associated trades, aliased as position_value, grouped by the asset_id column, then iterates through each record from this cursor and, for each record, checks if the position_value is greater than the portfolio_threshold input parameter, and if true, adds 10 percent of the position_value to the total_risk variable, or else checks if the position_value is greater than 50 percent of the portfolio_threshold, and if true, adds 5 percent of the position_value to the total_risk variable, or else adds 2 percent of the position_value to the total_risk variable, and after processing all cursor records, returns the final accumulated total_risk value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_portfolio_risk(portfolio_threshold NUMBER) RETURN NUMBER IS\n  total_risk NUMBER := 0;\n  CURSOR asset_cursor IS\n    SELECT a.asset_id, SUM(te.quantity * te.execution_price) as position_value\n    FROM assets a\n    JOIN trades t ON a.asset_id = t.asset_id\n    JOIN trade_executions te ON t.trade_id = te.trade_id\n    GROUP BY a.asset_id;\nBEGIN\n  FOR asset_rec IN asset_cursor LOOP\n    IF asset_rec.position_value > portfolio_threshold THEN\n      total_risk := total_risk + (asset_rec.position_value * 0.1);\n    ELSIF asset_rec.position_value > portfolio_threshold * 0.5 THEN\n      total_risk := total_risk + (asset_rec.position_value * 0.05);\n    ELSE\n      total_risk := total_risk + (asset_rec.position_value * 0.02);\n    END IF;\n  END LOOP;\n  \n  RETURN total_risk;\nEND;",
    "database_name": "algorithmic_tap_managemen",
    "tables": [
      "assets",
      "market_data",
      "trades",
      "trade_executions",
      "performance_metrics",
      "strategies"
    ],
    "call_sqls": [
      "SELECT calculate_portfolio_risk(10000) FROM dual",
      "SELECT calculate_portfolio_risk(50000) FROM dual",
      "SELECT calculate_portfolio_risk(25000) FROM dual",
      "SELECT calculate_portfolio_risk(75000) FROM dual",
      "SELECT calculate_portfolio_risk(150000) FROM dual",
      "SELECT calculate_portfolio_risk(1000) FROM dual",
      "SELECT calculate_portfolio_risk(5000) FROM dual",
      "SELECT calculate_portfolio_risk(20000) FROM dual",
      "SELECT calculate_portfolio_risk(30000) FROM dual",
      "SELECT calculate_portfolio_risk(40000) FROM dual",
      "SELECT calculate_portfolio_risk(60000) FROM dual",
      "SELECT calculate_portfolio_risk(80000) FROM dual",
      "SELECT calculate_portfolio_risk(90000) FROM dual",
      "SELECT calculate_portfolio_risk(120000) FROM dual",
      "SELECT calculate_portfolio_risk(180000) FROM dual",
      "SELECT calculate_portfolio_risk(220000) FROM dual",
      "SELECT calculate_portfolio_risk(350000) FROM dual",
      "SELECT calculate_portfolio_risk(1000000) FROM dual",
      "SELECT calculate_portfolio_risk(500000) FROM dual",
      "SELECT calculate_portfolio_risk(250000) FROM dual"
    ],
    "id": 181
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `update_publication_price` that accepts two input parameters: `pub_id`, an integer representing the unique identifier of a publication, and `new_price`, a real number representing the new price to be assigned to the publication. The function is designed to return no value, indicated by `RETURNS void`. Upon execution, the function first performs a conditional check: it verifies the existence of a record within the `publication` table where the column `\"Publication_ID\"` exactly matches the value provided by the `pub_id` input parameter. This check is performed using a `SELECT 1 FROM publication WHERE \"Publication_ID\" = pub_id` query within an `IF EXISTS` statement. If at least one such record is found, indicating that a publication with the specified `pub_id` exists, the function then proceeds to update the `publication` table. Specifically, it sets the value of the `\"Price\"` column to the value provided by the `new_price` input parameter for all rows where the `\"Publication_ID\"` column matches the `pub_id` input parameter. If no record in the `publication` table has a `\"Publication_ID\"` matching the `pub_id` input parameter, the update operation is skipped, and the function completes without making any changes to the database.",
    "plsql": "CREATE OR REPLACE FUNCTION update_publication_price(pub_id integer, new_price real) RETURNS void AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM publication WHERE \"Publication_ID\" = pub_id) THEN\n        UPDATE publication SET \"Price\" = new_price WHERE \"Publication_ID\" = pub_id;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_2",
    "tables": [
      "book",
      "publication"
    ],
    "call_sqls": [
      "SELECT update_publication_price(1, 15500000.0);",
      "SELECT update_publication_price(2, 6200000.0);",
      "SELECT update_publication_price(3, 4150000.0);",
      "SELECT update_publication_price(1, 16000000.0);",
      "SELECT update_publication_price(2, 6500000.0);",
      "SELECT update_publication_price(3, 4200000.0);",
      "SELECT update_publication_price(4, 5000000.0);",
      "SELECT update_publication_price(5, 7000000.0);",
      "SELECT update_publication_price(1, 14500000.0);",
      "SELECT update_publication_price(2, 5800000.0);",
      "SELECT update_publication_price(3, 4000000.0);",
      "SELECT update_publication_price(6, 3000000.0);",
      "SELECT update_publication_price(7, 8500000.0);",
      "SELECT update_publication_price(8, 12000000.0);",
      "SELECT update_publication_price(1, 0.0);",
      "SELECT update_publication_price(2, 1.5);",
      "SELECT update_publication_price(3, 9999999.99);",
      "SELECT update_publication_price(9, 2500000.0);",
      "SELECT update_publication_price(10, 11000000.0);",
      "SELECT update_publication_price(1, NULL);",
      "SELECT update_publication_price(2, -100.0);"
    ],
    "id": 182
  },
  {
    "ir": "Write a PostgreSQL function named get_wrestler_latest_rank that accepts a single input parameter p_wrestler_id of type bigint, which represents the unique identifier of a wrestler, and returns a bigint value. The function declares a local variable v_latest_rank of type bigint to store the intermediate result. The function then executes a SELECT query on the rankings table to find the maximum rank value for the specified wrestler by filtering rows where the wrestler_id column matches the p_wrestler_id parameter. The query applies the sign() function to the maximum rank value, which returns -1 if the maximum rank is negative, 0 if it is zero, or 1 if it is positive. The result of this operation is stored in the v_latest_rank variable using the INTO clause. Finally, the function returns the value of v_latest_rank, which represents the sign of the highest rank associated with the specified wrestler.",
    "plsql": "CREATE OR REPLACE FUNCTION get_wrestler_latest_rank(p_wrestler_id bigint) RETURNS bigint AS $$\nDECLARE\n    v_latest_rank bigint;\nBEGIN\n    SELECT sign(MAX(rank))\n    INTO v_latest_rank\n    FROM rankings\n    WHERE wrestler_id = p_wrestler_id;\n    RETURN v_latest_rank;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "college_wrestling_rankings_and_statistics",
    "tables": [
      "conferences",
      "matches",
      "rankings",
      "seasons",
      "teams",
      "users",
      "weeks",
      "weight_classes",
      "wrestlers"
    ],
    "call_sqls": [
      "SELECT get_wrestler_latest_rank(0);",
      "SELECT get_wrestler_latest_rank(1);",
      "SELECT get_wrestler_latest_rank(2);",
      "SELECT get_wrestler_latest_rank(3);",
      "SELECT get_wrestler_latest_rank(4);",
      "SELECT get_wrestler_latest_rank(5);",
      "SELECT get_wrestler_latest_rank(6);",
      "SELECT get_wrestler_latest_rank(7);",
      "SELECT get_wrestler_latest_rank(8);",
      "SELECT get_wrestler_latest_rank(9);",
      "SELECT get_wrestler_latest_rank(10);",
      "SELECT get_wrestler_latest_rank(11);",
      "SELECT get_wrestler_latest_rank(12);",
      "SELECT get_wrestler_latest_rank(13);",
      "SELECT get_wrestler_latest_rank(14);",
      "SELECT get_wrestler_latest_rank(15);",
      "SELECT get_wrestler_latest_rank(16);",
      "SELECT get_wrestler_latest_rank(17);",
      "SELECT get_wrestler_latest_rank(18);",
      "SELECT get_wrestler_latest_rank(19);",
      "SELECT get_wrestler_latest_rank(20);"
    ],
    "id": 183
  },
  {
    "ir": "Write a PLpgSQL function that takes a parameter p_category_id of type bigint and returns a real number representing the maximum expenditure cost within a specified category. The function begins by declaring a variable max_cost of type real to store the result. It then executes a SELECT statement to retrieve the maximum value from the cost column in the expenditures table, where the category_id matches the provided p_category_id. The COALESCE function is used to ensure that if no expenditures are found for the given category_id, the function will return 0 instead of a NULL value. The result of this SELECT statement is stored in the max_cost variable. Finally, the function returns the value of max_cost.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_expenditure_in_category(p_category_id bigint)\nRETURNS real AS $$\nDECLARE\n    max_cost real;\nBEGIN\n    SELECT COALESCE(MAX(cost), 0) INTO max_cost FROM expenditures WHERE category_id = p_category_id;\n    RETURN max_cost;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "capital_expenditures_in_residential_energy_systems",
    "tables": [
      "expenditures",
      "expenditure_categories",
      "regions",
      "years",
      "expenditure_sources",
      "data_sources"
    ],
    "call_sqls": [
      "SELECT get_max_expenditure_in_category(0);",
      "SELECT get_max_expenditure_in_category(1);",
      "SELECT get_max_expenditure_in_category(2);",
      "SELECT get_max_expenditure_in_category(3);",
      "SELECT get_max_expenditure_in_category(4);",
      "SELECT get_max_expenditure_in_category(5);",
      "SELECT get_max_expenditure_in_category(10);",
      "SELECT get_max_expenditure_in_category(15);",
      "SELECT get_max_expenditure_in_category(20);",
      "SELECT get_max_expenditure_in_category(25);",
      "SELECT get_max_expenditure_in_category(30);",
      "SELECT get_max_expenditure_in_category(35);",
      "SELECT get_max_expenditure_in_category(40);",
      "SELECT get_max_expenditure_in_category(45);",
      "SELECT get_max_expenditure_in_category(50);",
      "SELECT get_max_expenditure_in_category(55);",
      "SELECT get_max_expenditure_in_category(60);",
      "SELECT get_max_expenditure_in_category(65);",
      "SELECT get_max_expenditure_in_category(70);",
      "SELECT get_max_expenditure_in_category(75);"
    ],
    "id": 184
  },
  {
    "ir": "Write a PLpgSQL function that calculates the total sales amount for a specified sales channel by taking a parameter named channel of type TEXT, which represents the sales channel to filter by. The function declares a variable total_sales of type REAL to store the result of the calculation. It performs a SELECT operation to compute the sum of the total_amount column from the sales table, where the sale_channel column matches the provided channel parameter. The result of this aggregation is stored into the total_sales variable. Finally, the function returns the value of total_sales, which represents the total sales amount for the specified sales channel.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_sales_by_channel(channel TEXT) RETURNS REAL AS $$\nDECLARE\n    total_sales REAL;\nBEGIN\n    SELECT SUM(total_amount) INTO total_sales\n    FROM sales\n    WHERE sale_channel = channel;\n    RETURN total_sales;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_and_audio_book_production_and_sales_management",
    "tables": [
      "sales"
    ],
    "call_sqls": [
      "SELECT get_total_sales_by_channel('Online');",
      "SELECT get_total_sales_by_channel('Retail');",
      "SELECT get_total_sales_by_channel('Wholesale');",
      "SELECT get_total_sales_by_channel('Direct');",
      "SELECT get_total_sales_by_channel('Amazon');",
      "SELECT get_total_sales_by_channel('Ebay');",
      "SELECT get_total_sales_by_channel('Website');",
      "SELECT get_total_sales_by_channel('Mobile App');",
      "SELECT get_total_sales_by_channel('Telephone');",
      "SELECT get_total_sales_by_channel('Email');",
      "SELECT get_total_sales_by_channel('In-Store');",
      "SELECT get_total_sales_by_channel('Marketplace');",
      "SELECT get_total_sales_by_channel('Affiliate');",
      "SELECT get_total_sales_by_channel('Social Media');",
      "SELECT get_total_sales_by_channel('Kiosk');",
      "SELECT get_total_sales_by_channel('Catalog');",
      "SELECT get_total_sales_by_channel('B2B');",
      "SELECT get_total_sales_by_channel('B2C');",
      "SELECT get_total_sales_by_channel('Partner');",
      "SELECT get_total_sales_by_channel('Distributor');",
      "SELECT get_total_sales_by_channel('Reseller');"
    ],
    "id": 185
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_deployment_status that accepts a single input parameter app_id_in of type NUMBER, which represents the application ID for which the deployment status is to be retrieved. The function returns a value of type VARCHAR2, specifically the deployment status associated with the most recent deployment date for the given application ID. Within the function, a local variable deployment_status_out of type VARCHAR2 with a maximum length of 255 characters is declared to store the result of the query. The function executes a SELECT statement to retrieve the status column from the deployment_logs table, where the app_id column matches the input parameter app_id_in. Additionally, the query includes a subquery that determines the most recent deployment_date for the specified app_id by selecting the maximum deployment_date from the deployment_logs table where the app_id matches app_id_in. The result of the SELECT statement is assigned to the deployment_status_out variable, which is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_deployment_status(app_id_in NUMBER) RETURN VARCHAR2 IS\n  deployment_status_out VARCHAR2(255);\nBEGIN\n  SELECT status INTO deployment_status_out\n  FROM deployment_logs\n  WHERE app_id = app_id_in\n  AND deployment_date = (SELECT MAX(deployment_date) FROM deployment_logs WHERE app_id = app_id_in);\n  RETURN deployment_status_out;\nEND;",
    "database_name": "application_da_management",
    "tables": [
      "applications",
      "application_versions",
      "application_parameters",
      "deployment_logs"
    ],
    "call_sqls": [
      "SELECT get_deployment_status(0) FROM dual",
      "SELECT get_deployment_status(1) FROM dual",
      "SELECT get_deployment_status(2) FROM dual",
      "SELECT get_deployment_status(10) FROM dual",
      "SELECT get_deployment_status(15) FROM dual",
      "SELECT get_deployment_status(25) FROM dual",
      "SELECT get_deployment_status(30) FROM dual",
      "SELECT get_deployment_status(100) FROM dual",
      "SELECT get_deployment_status(101) FROM dual",
      "SELECT get_deployment_status(200) FROM dual",
      "SELECT get_deployment_status(250) FROM dual",
      "SELECT get_deployment_status(300) FROM dual",
      "SELECT get_deployment_status(500) FROM dual",
      "SELECT get_deployment_status(1000) FROM dual",
      "SELECT get_deployment_status(1500) FROM dual",
      "SELECT get_deployment_status(9999) FROM dual",
      "SELECT get_deployment_status(app_id) FROM applications WHERE app_id = 0",
      "SELECT get_deployment_status(app_id) FROM applications WHERE app_id = 1",
      "SELECT get_deployment_status(a.app_id) FROM applications a WHERE a.application_name = 'MyApp1'",
      "SELECT get_deployment_status(a.app_id) FROM applications a WHERE a.application_name = 'MyApp2'",
      "SELECT app_id, get_deployment_status(app_id) FROM deployment_logs GROUP BY app_id"
    ],
    "id": 186
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_composer_performance_count` that accepts a single input parameter, `p_composer_id`, which is of type `bigint` and represents the unique identifier for a composer. This function is designed to return a single value of type `bigint`, representing the total count of performances associated with the specified composer. The function's execution begins by declaring a local variable named `v_count`, also of type `bigint`, which will be used to store the result of a database query. The core operation of the function involves executing a `SELECT` statement to retrieve data from the database. This `SELECT` statement calculates the `COUNT(*)` of rows, effectively counting the number of records that satisfy the specified conditions. The result of this count operation is then stored into the `v_count` local variable. The data for this count is sourced from two tables: `performances` (aliased as `p`) and `music_pieces` (aliased as `mp`). These two tables are joined together using an `INNER JOIN` operation. The join condition specifies that records from `performances` and `music_pieces` are linked when the `piece_id` column in the `performances` table (`p.piece_id`) is equal to the `piece_id` column in the `music_pieces` table (`mp.piece_id`). After the join, a `WHERE` clause is applied to filter the joined results. This `WHERE` clause ensures that only those records where the `composer_id` column in the `music_pieces` table (`mp.composer_id`) matches the value provided in the input parameter `p_composer_id` are considered for the count. Finally, after the `SELECT` statement has executed and the count has been stored in `v_count`, the function returns the value currently held by the `v_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_composer_performance_count(p_composer_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM performances p\n    JOIN music_pieces mp ON p.piece_id = mp.piece_id\n    WHERE mp.composer_id = p_composer_id;\n    \n    RETURN v_count;\nEND;\n$$;",
    "database_name": "classical_music_composition_and_performance_tracking",
    "tables": [
      "composers",
      "music_pieces",
      "music_types",
      "performances",
      "performers"
    ],
    "call_sqls": [
      "SELECT get_composer_performance_count(0);",
      "SELECT get_composer_performance_count(1);",
      "SELECT get_composer_performance_count(2);",
      "SELECT get_composer_performance_count(3);",
      "SELECT get_composer_performance_count(4);",
      "SELECT get_composer_performance_count(5);",
      "SELECT get_composer_performance_count(6);",
      "SELECT get_composer_performance_count(7);",
      "SELECT get_composer_performance_count(8);",
      "SELECT get_composer_performance_count(9);",
      "SELECT get_composer_performance_count(10);",
      "SELECT get_composer_performance_count(100);",
      "SELECT get_composer_performance_count(101);",
      "SELECT get_composer_performance_count(1770);",
      "SELECT get_composer_performance_count(1879);",
      "SELECT get_composer_performance_count(NULL);",
      "SELECT composer_id, composer_name, get_composer_performance_count(composer_id) FROM composers;",
      "SELECT get_composer_performance_count(composer_id) FROM composers WHERE composer_name = 'Ludwig van Beethoven';",
      "SELECT get_composer_performance_count(composer_id) FROM composers WHERE composer_name = 'Frank Bridge';",
      "SELECT get_composer_performance_count(mp.composer_id) FROM music_pieces mp WHERE mp.title = 'Unfinished Symphony';",
      "SELECT get_composer_performance_count(c.composer_id) FROM composers c WHERE c.nationality = 'German';"
    ],
    "id": 187
  },
  {
    "ir": "Write a PostgreSQL trigger function named update_no2_change that is automatically executed after every INSERT operation on the air_quality_data table for each new row, which first declares a local variable base_no2 of type REAL, then performs a SELECT query on the air_quality_data table to retrieve the avg_no2 value for the row where the city_id equals the newly inserted row's city_id (accessed via the NEW record) and the year is exactly 2005, limiting the result to a single row and storing the value into the base_no2 variable, and subsequently performs an INSERT into the no2_changes table, populating the change_id column with a value calculated by selecting the current maximum change_id from the no2_changes table, using the COALESCE function to substitute 0 if the maximum is null, and then adding 1 to it, the city_id column with the NEW record's city_id, the start_year column with the fixed value 2005, the end_year column with the NEW record's year value, and the change_since_2005 column with the result of the arithmetic expression subtracting the base_no2 variable value from the NEW record's avg_no2 value, and finally returns the NEW record to the trigger execution context.",
    "plsql": "CREATE OR REPLACE FUNCTION update_no2_change() RETURNS TRIGGER AS $$\nDECLARE\n  base_no2 REAL;\nBEGIN\n  SELECT avg_no2 INTO base_no2 FROM air_quality_data WHERE city_id = NEW.city_id AND year = 2005 LIMIT 1;\n  INSERT INTO no2_changes (change_id, city_id, start_year, end_year, change_since_2005)\n  VALUES ((SELECT COALESCE(MAX(change_id), 0) + 1 FROM no2_changes), NEW.city_id, 2005, NEW.year, NEW.avg_no2 - base_no2);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_no2_change\nAFTER INSERT ON air_quality_data\nFOR EACH ROW EXECUTE FUNCTION update_no2_change();",
    "database_name": "air_quality_and_pollution_monitoring",
    "tables": [
      "air_quality_data",
      "cities",
      "no2_changes",
      "states"
    ],
    "call_sqls": [
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (100, 1, 2010, 1, 15, 8.5, 1.2, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (101, 1, 2011, 3, 20, 7.8, 1.5, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (102, 1, 2012, 7, 10, 6.2, 0.9, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (103, 1, 2013, 9, 5, 5.9, 1.1, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (104, 1, 2014, 11, 30, 4.5, 0.8, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (105, 1, 2015, 2, 14, 3.8, 0.7, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (106, 1, 2016, 6, 25, 2.0, 0.5, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (107, 1, 2017, 8, 18, 1.5, 0.4, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (108, 1, 2018, 12, 1, 1.2, 0.3, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (109, 1, 2019, 4, 22, 0.9, 0.2, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (110, 2, 2010, 5, 10, 12.3, 2.1, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (111, 2, 2011, 7, 19, 11.5, 2.0, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (112, 2, 2012, 10, 3, 10.8, 1.9, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (113, 2, 2013, 1, 28, 9.7, 1.7, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (114, 2, 2014, 3, 15, 8.4, 1.5, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (115, 2, 2015, 9, 8, 7.1, 1.3, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (116, 2, 2016, 11, 12, 5.47, 1.0, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (117, 3, 2017, 2, 5, 15.0, 3.0, 'satellite', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (118, 3, 2018, 6, 30, 14.2, 2.8, 'ground station', '10^15 molec cm^-2');",
      "INSERT INTO air_quality_data (data_id, city_id, year, month, day, avg_no2, uncertainty, data_source, measurement_unit) VALUES (119, 3, 2019, 8, 14, 13.5, 2.6, 'satellite', '10^15 molec cm^-2');"
    ],
    "id": 188
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_instance_type_expiration` that accepts five input parameters: `p_instance_type_id` of type `BIGINT`, `p_expiration_year` of type `INT`, `p_expiration_month` of type `INT`, `p_expiration_day` of type `INT`, and `p_expiration_hour` of type `INT`. The purpose of this procedure is to modify existing records within the `instance_types_historic` table. Specifically, it performs an `UPDATE` operation on the `instance_types_historic` table. The `SET` clause of this `UPDATE` statement targets the `expiration_date` column. The new value for `expiration_date` is generated by calling the `make_timestamptz` function. This `make_timestamptz` function constructs a `TIMESTAMP WITH TIME ZONE` value using the provided input parameters: `p_expiration_year` for the year component, `p_expiration_month` for the month component, `p_expiration_day` for the day component, and `p_expiration_hour` for the hour component. The minute and second components are explicitly set to `0` and `0` respectively within the `make_timestamptz` function call. The `WHERE` clause of the `UPDATE` statement specifies that only rows where the value in the `instance_type_id` column matches the value provided in the `p_instance_type_id` input parameter will be affected by this update operation.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_instance_type_expiration(\n    p_instance_type_id BIGINT,\n    p_expiration_year INT,\n    p_expiration_month INT,\n    p_expiration_day INT,\n    p_expiration_hour INT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE instance_types_historic\n    SET expiration_date = make_timestamptz(p_expiration_year, p_expiration_month, p_expiration_day, p_expiration_hour, 0, 0)\n    WHERE instance_type_id = p_instance_type_id;\nEND;\n$$;",
    "database_name": "cloud_service_pricing_and_resource_allocation",
    "tables": [
      "instance_types_historic",
      "reporting",
      "roles",
      "user_roles"
    ],
    "call_sqls": [
      "CALL update_instance_type_expiration(0, 2024, 12, 31, 23);",
      "CALL update_instance_type_expiration(1, 2025, 1, 15, 0);",
      "CALL update_instance_type_expiration(0, 2024, 6, 30, 18);",
      "CALL update_instance_type_expiration(1, 2024, 12, 31, 23);",
      "CALL update_instance_type_expiration(0, 2025, 3, 10, 12);",
      "CALL update_instance_type_expiration(1, 2024, 8, 1, 0);",
      "CALL update_instance_type_expiration(0, 2024, 11, 11, 11);",
      "CALL update_instance_type_expiration(1, 2025, 2, 28, 23);",
      "CALL update_instance_type_expiration(0, 2024, 9, 30, 15);",
      "CALL update_instance_type_expiration(1, 2024, 7, 4, 20);",
      "CALL update_instance_type_expiration(0, 2025, 4, 1, 8);",
      "CALL update_instance_type_expiration(1, 2024, 10, 31, 23);",
      "CALL update_instance_type_expiration(0, 2024, 5, 31, 0);",
      "CALL update_instance_type_expiration(1, 2025, 6, 30, 12);",
      "CALL update_instance_type_expiration(0, 2024, 12, 25, 0);",
      "CALL update_instance_type_expiration(1, 2024, 3, 15, 9);",
      "CALL update_instance_type_expiration(0, 2025, 8, 31, 17);",
      "CALL update_instance_type_expiration(1, 2024, 4, 30, 23);",
      "CALL update_instance_type_expiration(0, 2025, 5, 20, 14);",
      "CALL update_instance_type_expiration(1, 2024, 2, 29, 23);"
    ],
    "id": 189
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `check_infinite_production` that accepts a single input parameter, `para_vehicle_id`, which is of type `bigint`. This function is designed to determine if a specific vehicle's production period is considered \"infinite\" based on its associated production year's date range. Inside the function, a local variable named `is_infinite` of type `boolean` is declared to store the result of the primary query. The core operation involves a `SELECT` statement that retrieves a boolean value into the `is_infinite` variable. This `SELECT` statement joins two tables: `vehicle_production` (aliased as `vp`) and `production_years` (aliased as `p`). The join condition is `vp.year_id = p.year_id`, linking vehicle production records to their corresponding production year details. The `WHERE` clause filters these joined records to specifically target the vehicle identified by the input parameter, `para_vehicle_id`, using the condition `vp.vehicle_id = para_vehicle_id`. For the selected record, the `upper_inf()` function is applied to a `daterange`. This `daterange` is constructed using the `start_date` and `end_date` columns from the `production_years` table (aliased as `p`), both explicitly cast to the `date` data type. The `upper_inf()` function checks if the upper bound of the generated date range is infinite. The boolean result of this `upper_inf()` function call is then assigned to the `is_infinite` variable. Finally, the function returns the value stored in the `is_infinite` variable, indicating whether the production period for the specified vehicle is infinite.",
    "plsql": "CREATE OR REPLACE FUNCTION check_infinite_production(para_vehicle_id bigint) RETURNS boolean LANGUAGE plpgsql AS $$\nDECLARE\n  is_infinite boolean;\nBEGIN\n  SELECT upper_inf(daterange(p.start_date::date, p.end_date::date))\n  INTO is_infinite\n  FROM vehicle_production vp\n  JOIN production_years p ON vp.year_id = p.year_id\n  WHERE vp.vehicle_id = para_vehicle_id;\n  RETURN is_infinite;\nEND;\n$$;",
    "database_name": "automotive_color_catalog_and_vehicle_information_management",
    "tables": [
      "color_types",
      "color_usage",
      "colors",
      "locales",
      "production_years",
      "users",
      "vehicle_colors",
      "vehicle_production",
      "vehicles"
    ],
    "call_sqls": [
      "SELECT check_infinite_production(0);",
      "SELECT check_infinite_production(1);",
      "SELECT check_infinite_production(2);",
      "SELECT check_infinite_production(3);",
      "SELECT check_infinite_production(4);",
      "SELECT check_infinite_production(5);",
      "SELECT check_infinite_production(6);",
      "SELECT check_infinite_production(7);",
      "SELECT check_infinite_production(8);",
      "SELECT check_infinite_production(9);",
      "SELECT check_infinite_production(10);",
      "SELECT check_infinite_production(11);",
      "SELECT check_infinite_production(12);",
      "SELECT check_infinite_production(13);",
      "SELECT check_infinite_production(14);",
      "SELECT check_infinite_production(15);",
      "SELECT check_infinite_production(16);",
      "SELECT check_infinite_production(17);",
      "SELECT check_infinite_production(18);",
      "SELECT check_infinite_production(19);",
      "SELECT check_infinite_production(20);"
    ],
    "id": 190
  },
  {
    "ir": "Write a PLpgSQL function that takes a parameter p_borough_id of type bigint and calculates the total sum of the community_district column from the community_districts table where the borough_id column matches the provided p_borough_id. The function begins by declaring a variable district_sum of type bigint to store the result of the calculation. It then performs a SELECT operation using the COALESCE function to ensure that if the SUM of the community_district column is NULL, it defaults to 0. The result of this SELECT operation is stored into the district_sum variable. Finally, the function returns the value of district_sum, which represents the total sum of community districts for the specified borough_id.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_districts(p_borough_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    district_sum bigint;\nBEGIN\n    SELECT COALESCE(SUM(community_district), 0) INTO district_sum FROM community_districts WHERE borough_id = p_borough_id;\n    RETURN district_sum;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "animal_licensing_and_registration",
    "tables": [
      "boroughs",
      "city_council_districts",
      "community_districts",
      "congressional_districts"
    ],
    "call_sqls": [
      "SELECT calculate_total_districts(0);",
      "SELECT calculate_total_districts(1);",
      "SELECT calculate_total_districts(2);",
      "SELECT calculate_total_districts(3);",
      "SELECT calculate_total_districts(4);",
      "SELECT calculate_total_districts(5);",
      "SELECT calculate_total_districts(6);",
      "SELECT calculate_total_districts(7);",
      "SELECT calculate_total_districts(8);",
      "SELECT calculate_total_districts(9);",
      "SELECT calculate_total_districts(10);",
      "SELECT calculate_total_districts(11);",
      "SELECT calculate_total_districts(12);",
      "SELECT calculate_total_districts(13);",
      "SELECT calculate_total_districts(14);",
      "SELECT calculate_total_districts(15);",
      "SELECT calculate_total_districts(16);",
      "SELECT calculate_total_districts(17);",
      "SELECT calculate_total_districts(18);",
      "SELECT calculate_total_districts(19);",
      "SELECT calculate_total_districts(20);"
    ],
    "id": 191
  },
  {
    "ir": "Write a PostgreSQL function named analyze_treatment_compliance that accepts a single parameter trial_id_input of type BIGINT and returns a table with two columns: agent_id of type BIGINT and compliance_category of type TEXT. The function first declares three variables: trial_status of type TEXT to store the status of the trial, agent_rec of type RECORD to iterate through agent records, and comp_rate of type NUMERIC to store calculated compliance rates. The function then queries the trials table to retrieve the status value where the trial_id column matches the trial_id_input parameter and stores this in the trial_status variable. If the trial_status equals 'completed', the function enters a loop that iterates through each distinct agent_id from the treatments table where the trial_id column matches the trial_id_input parameter. For each agent in this loop, the function calculates the average compliance_rate (explicitly cast to NUMERIC type) from the treatments table where both the trial_id matches the input parameter and the agent_id matches the current agent in the loop, storing this average in the comp_rate variable. The function then evaluates the comp_rate against four thresholds: if comp_rate is greater than or equal to 0.9, it assigns 'Excellent' to compliance_category; if comp_rate is greater than or equal to 0.7 but less than 0.9, it assigns 'Good'; if comp_rate is greater than or equal to 0.5 but less than 0.7, it assigns 'Fair'; and if comp_rate is less than 0.5, it assigns 'Poor'. In each case, the function sets the agent_id to the current agent's ID and returns a row containing both the agent_id and the determined compliance_category. If the trial_status is not equal to 'completed', the function instead returns a query result that selects all agent_id values from the treatments table where the trial_id matches the input parameter, grouped by agent_id, with 'Pending analysis' as the compliance_category for each returned row.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_treatment_compliance(trial_id_input BIGINT) RETURNS TABLE(agent_id BIGINT, compliance_category TEXT) AS $$\nDECLARE\n    trial_status TEXT;\n    agent_rec RECORD;\n    comp_rate NUMERIC;\nBEGIN\n    SELECT status INTO trial_status FROM trials WHERE trial_id = trial_id_input;\n    IF trial_status = 'completed' THEN\n        FOR agent_rec IN SELECT DISTINCT t.agent_id FROM treatments t WHERE t.trial_id = trial_id_input LOOP\n            SELECT AVG(compliance_rate::NUMERIC) INTO comp_rate FROM treatments WHERE trial_id = trial_id_input AND agent_id = agent_rec.agent_id;\n            IF comp_rate >= 0.9 THEN\n                agent_id := agent_rec.agent_id;\n                compliance_category := 'Excellent';\n                RETURN NEXT;\n            ELSIF comp_rate >= 0.7 THEN\n                agent_id := agent_rec.agent_id;\n                compliance_category := 'Good';\n                RETURN NEXT;\n            ELSIF comp_rate >= 0.5 THEN\n                agent_id := agent_rec.agent_id;\n                compliance_category := 'Fair';\n                RETURN NEXT;\n            ELSE\n                agent_id := agent_rec.agent_id;\n                compliance_category := 'Poor';\n                RETURN NEXT;\n            END IF;\n        END LOOP;\n    ELSE\n        RETURN QUERY SELECT t.agent_id, 'Pending analysis' FROM treatments t WHERE t.trial_id = trial_id_input GROUP BY t.agent_id;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "clinical_trial_data_management_and_analysis_222212",
    "tables": [
      "agents",
      "treatments",
      "trials",
      "reports"
    ],
    "call_sqls": [
      "SELECT * FROM analyze_treatment_compliance(0);",
      "SELECT * FROM analyze_treatment_compliance(1);",
      "SELECT * FROM analyze_treatment_compliance(2);",
      "SELECT * FROM analyze_treatment_compliance(3);",
      "SELECT * FROM analyze_treatment_compliance(4);",
      "SELECT * FROM analyze_treatment_compliance(5);",
      "SELECT * FROM analyze_treatment_compliance(6);",
      "SELECT * FROM analyze_treatment_compliance(7);",
      "SELECT * FROM analyze_treatment_compliance(8);",
      "SELECT * FROM analyze_treatment_compliance(9);",
      "SELECT * FROM analyze_treatment_compliance(10);",
      "SELECT * FROM analyze_treatment_compliance(11);",
      "SELECT * FROM analyze_treatment_compliance(12);",
      "SELECT * FROM analyze_treatment_compliance(13);",
      "SELECT * FROM analyze_treatment_compliance(14);",
      "SELECT * FROM analyze_treatment_compliance(15);",
      "SELECT * FROM analyze_treatment_compliance(16);",
      "SELECT * FROM analyze_treatment_compliance(17);",
      "SELECT * FROM analyze_treatment_compliance(18);",
      "SELECT * FROM analyze_treatment_compliance(19);"
    ],
    "id": 192
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the reporting compliance status from the bank_reporting_dates table for a given certificate identifier. The function, named get_reporting_compliance_status, accepts a single parameter cert_id of type bigint, which represents the certificate identifier used to query the table. Within the function, a local variable result of type text is declared to store the compliance status. The function executes a SELECT statement to fetch the value from the reporting_compliance_status column of the bank_reporting_dates table where the cert column matches the provided cert_id parameter. The retrieved value is stored in the result variable, which is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_reporting_compliance_status(cert_id bigint) RETURNS text AS $$\nDECLARE\n    result text;\nBEGIN\n    SELECT reporting_compliance_status INTO result\n    FROM bank_reporting_dates\n    WHERE cert = cert_id;\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "banking_institution_data_and_regulatory_information",
    "tables": [
      "bank_FDIC_details",
      "bank_classifications",
      "bank_electronic_reporting",
      "bank_federal_reserve_details",
      "bank_holding_companies",
      "bank_regulatory_agents",
      "bank_regulatory_codes",
      "bank_reporting_dates"
    ],
    "call_sqls": [
      "SELECT get_reporting_compliance_status(1001);",
      "SELECT get_reporting_compliance_status(1002);",
      "SELECT get_reporting_compliance_status(1003);",
      "SELECT get_reporting_compliance_status(1004);",
      "SELECT get_reporting_compliance_status(1005);",
      "SELECT get_reporting_compliance_status(2001);",
      "SELECT get_reporting_compliance_status(2002);",
      "SELECT get_reporting_compliance_status(2003);",
      "SELECT get_reporting_compliance_status(2004);",
      "SELECT get_reporting_compliance_status(2005);",
      "SELECT get_reporting_compliance_status(3001);",
      "SELECT get_reporting_compliance_status(3002);",
      "SELECT get_reporting_compliance_status(3003);",
      "SELECT get_reporting_compliance_status(3004);",
      "SELECT get_reporting_compliance_status(3005);",
      "SELECT get_reporting_compliance_status(4001);",
      "SELECT get_reporting_compliance_status(4002);",
      "SELECT get_reporting_compliance_status(4003);",
      "SELECT get_reporting_compliance_status(4004);",
      "SELECT get_reporting_compliance_status(4005);"
    ],
    "id": 193
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_hex_department_code that does not take any input parameters and returns a VARCHAR2 value. The function begins by declaring a local variable named hex_code of type VARCHAR2 with a maximum length of 100 characters, which will be used to store the hexadecimal representation of a specific string. Inside the function body, a SELECT statement is executed to retrieve the hexadecimal representation of the string 'DEPT_A'. This is achieved by first converting the string 'DEPT_A' into its raw binary format using the UTL_RAW.CAST_TO_RAW function, and then converting this raw binary format into a hexadecimal string using the RAWTOHEX function. The SELECT statement retrieves the resulting hexadecimal string from the pseudo-table DUAL, which is a special one-row, one-column table used in Oracle for operations that do not require actual table data. The hexadecimal string is stored in the hex_code variable. Finally, the function returns the value of hex_code, which contains the hexadecimal representation of the string 'DEPT_A'.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_hex_department_code RETURN VARCHAR2 IS\n  hex_code VARCHAR2(100);\nBEGIN\n  SELECT RAWTOHEX(UTL_RAW.CAST_TO_RAW('DEPT_A')) INTO hex_code FROM DUAL;\n  RETURN hex_code;\nEND;",
    "database_name": "fashion_aasd_257731",
    "tables": [],
    "call_sqls": [
      "SELECT fn_get_hex_department_code FROM DUAL",
      "SELECT fn_get_hex_department_code() FROM DUAL",
      "SELECT fn_get_hex_department_code FROM DUAL WHERE 1=1",
      "SELECT fn_get_hex_department_code AS hex_code FROM DUAL",
      "SELECT fn_get_hex_department_code FROM DUAL UNION SELECT 'TEST' FROM DUAL",
      "SELECT fn_get_hex_department_code FROM DUAL WHERE ROWNUM = 1",
      "SELECT fn_get_hex_department_code FROM DUAL CONNECT BY LEVEL <= 2",
      "SELECT fn_get_hex_department_code FROM DUAL ORDER BY 1",
      "SELECT fn_get_hex_department_code FROM DUAL FETCH FIRST 1 ROWS ONLY",
      "SELECT fn_get_hex_department_code FROM DUAL CROSS JOIN (SELECT 1 FROM DUAL)",
      "SELECT fn_get_hex_department_code FROM DUAL GROUP BY ()",
      "SELECT fn_get_hex_department_code FROM DUAL HAVING 1=1",
      "SELECT fn_get_hex_department_code FROM DUAL MINUS SELECT NULL FROM DUAL",
      "SELECT fn_get_hex_department_code FROM DUAL INTERSECT SELECT '444550545F41' FROM DUAL",
      "SELECT fn_get_hex_department_code FROM DUAL JOIN (SELECT 1 AS id FROM DUAL) t ON 1=1",
      "SELECT fn_get_hex_department_code FROM DUAL WHERE fn_get_hex_department_code IS NOT NULL",
      "SELECT fn_get_hex_department_code FROM DUAL WHERE LENGTH(fn_get_hex_department_code) > 0",
      "SELECT fn_get_hex_department_code FROM DUAL MODEL DIMENSION BY (1 AS id) MEASURES ('X' AS val) RULES ()"
    ],
    "id": 194
  },
  {
    "ir": "Write a PLpgSQL stored procedure named sp that accepts four input parameters: para_route_id of type bigint to identify a specific route, para_duration_threshold of type bigint to set a maximum duration limit, para_quality_min of type bigint to define a minimum ride quality value, and para_weather of type text to specify a weather condition string; this procedure performs a sequence of data manipulation operations on the trips table, starting by updating the duration column, adding 1000 to its current value for every row where the route_id column matches the para_route_id parameter, then it deletes all rows from the trips table where the duration column exceeds the para_duration_threshold parameter and the ride_quality column is less than the para_quality_min parameter, followed by an update that sets the weather_conditions column to the value of the para_weather parameter for rows where the route_id matches para_route_id and the maintenance_flag column equals 0, then it deletes all rows from the trips table where the start_station_number column is equal to the end_station_number column, then it updates the ride_quality column to the value of the para_quality_min parameter for every row where the weather_conditions column matches the para_weather parameter, then it deletes all rows from the trips table where the member_type column contains a NULL value, then it updates the maintenance_flag column to 1 for every row where the duration column is less than 60000, then it deletes all rows from the trips table where the bike_number column equals the string '999', and finally it updates the route_id column, setting it to the value of the para_route_id parameter plus 1000, for every row where the ride_quality column is greater than or equal to 4.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_route_id bigint, para_duration_threshold bigint, para_quality_min bigint, para_weather text) LANGUAGE plpgsql AS $$ BEGIN UPDATE \"trips\" SET \"duration\" = \"duration\" + 1000 WHERE \"route_id\" = para_route_id; DELETE FROM \"trips\" WHERE \"duration\" > para_duration_threshold AND \"ride_quality\" < para_quality_min; UPDATE \"trips\" SET \"weather_conditions\" = para_weather WHERE \"route_id\" = para_route_id AND \"maintenance_flag\" = 0; DELETE FROM \"trips\" WHERE \"start_station_number\" = \"end_station_number\"; UPDATE \"trips\" SET \"ride_quality\" = para_quality_min WHERE \"weather_conditions\" = para_weather; DELETE FROM \"trips\" WHERE \"member_type\" IS NULL; UPDATE \"trips\" SET \"maintenance_flag\" = 1 WHERE \"duration\" < 60000; DELETE FROM \"trips\" WHERE \"bike_number\" = '999'; UPDATE \"trips\" SET \"route_id\" = para_route_id + 1000 WHERE \"ride_quality\" >= 4; END; $$;",
    "database_name": "bike_rental_and_trip_management",
    "tables": [
      "trips"
    ],
    "call_sqls": [
      "CALL sp(101, 3600000, 3, 'Sunny');",
      "CALL sp(102, 7200000, 2, 'Rainy');",
      "CALL sp(103, 1800000, 4, 'Cloudy');",
      "CALL sp(104, 5400000, 1, 'Snow');",
      "CALL sp(105, 900000, 5, 'Clear');",
      "CALL sp(201, 3600000, 3, 'Fog');",
      "CALL sp(202, 4800000, 2, 'Windy');",
      "CALL sp(203, 1200000, 4, 'Sunny');",
      "CALL sp(204, 6000000, 1, 'Storm');",
      "CALL sp(205, 2400000, 3, 'Rainy');",
      "CALL sp(301, 1500000, 5, 'Clear');",
      "CALL sp(302, 3000000, 2, 'Cloudy');",
      "CALL sp(303, 4200000, 3, 'Sunny');",
      "CALL sp(304, 6600000, 1, 'Rainy');",
      "CALL sp(305, 1800000, 4, 'Snow');",
      "CALL sp(401, 500000, 5, 'Clear');",
      "CALL sp(402, 3800000, 2, 'Fog');",
      "CALL sp(403, 2200000, 3, 'Windy');",
      "CALL sp(404, 5900000, 1, 'Sunny');",
      "CALL sp(405, 1000000, 4, 'Rainy');"
    ],
    "id": 195
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_high_yield_prediction that accepts two parameters: p_crop_type of type VARCHAR2, which specifies the type of crop, and p_threshold of type NUMBER, which represents a yield threshold value. The function is designed to simulate the retrieval of predicted yield values for different crop types, as the actual PREDICTIONS table is not available, ensuring the function remains compilable and testable. Within the function, a local variable v_predicted_yield of type NUMBER is declared to store the simulated predicted yield value. The function uses a CASE statement to assign specific yield values to v_predicted_yield based on the value of p_crop_type: 85 for 'Wheat', 150 for 'Corn', 65 for 'Soybean', and 40 for any other crop type. After determining the predicted yield, the function evaluates whether v_predicted_yield exceeds the provided p_threshold using an IF statement. If v_predicted_yield is greater than p_threshold, the function returns the string 'HIGH'; otherwise, it returns 'LOW'. This logic flow ensures that the function provides a categorical yield prediction based on the simulated data and the specified threshold.",
    "plsql": "CREATE OR REPLACE FUNCTION check_high_yield_prediction(p_crop_type VARCHAR2, p_threshold NUMBER)\nRETURN VARCHAR2\nIS\n    v_predicted_yield NUMBER;\nBEGIN\n    -- Simulate fetching a prediction since the PREDICTIONS table is not available.\n    -- This makes the function compilable and testable.\n    v_predicted_yield := CASE p_crop_type\n                           WHEN 'Wheat' THEN 85\n                           WHEN 'Corn' THEN 150\n                           WHEN 'Soybean' THEN 65\n                           ELSE 40\n                         END;\n\n    IF v_predicted_yield > p_threshold THEN\n        RETURN 'HIGH';\n    ELSE\n        RETURN 'LOW';\n    END IF;\nEND;",
    "database_name": "agricultural_daacy_predic",
    "tables": [
      "CROPS",
      "CROP_YIELDS",
      "SITES",
      "SOIL_COMPOSITION",
      "ENVIRONMENTAL_DATA",
      "PREDICTIONS"
    ],
    "call_sqls": [
      "SELECT check_high_yield_prediction('Wheat', 80) FROM DUAL",
      "SELECT check_high_yield_prediction('Corn', 100) FROM DUAL",
      "SELECT check_high_yield_prediction('Soybean', 60) FROM DUAL",
      "SELECT check_high_yield_prediction('Rice', 50) FROM DUAL",
      "SELECT check_high_yield_prediction('Wheat', 90) FROM DUAL",
      "SELECT check_high_yield_prediction('Corn', 200) FROM DUAL",
      "SELECT check_high_yield_prediction('Soybean', 70) FROM DUAL",
      "SELECT check_high_yield_prediction('Barley', 30) FROM DUAL",
      "SELECT check_high_yield_prediction('Wheat', 50) FROM DUAL",
      "SELECT check_high_yield_prediction('Corn', 120) FROM DUAL",
      "SELECT check_high_yield_prediction('Soybean', 64) FROM DUAL",
      "SELECT check_high_yield_prediction('Oats', 45) FROM DUAL",
      "SELECT check_high_yield_prediction('Wheat', 85) FROM DUAL",
      "SELECT check_high_yield_prediction('Corn', 150) FROM DUAL",
      "SELECT check_high_yield_prediction('Soybean', 65) FROM DUAL",
      "SELECT check_high_yield_prediction('Rye', 40) FROM DUAL",
      "SELECT check_high_yield_prediction('Wheat', 0) FROM DUAL",
      "SELECT check_high_yield_prediction('Corn', 1) FROM DUAL",
      "SELECT check_high_yield_prediction('Soybean', 1000) FROM DUAL",
      "SELECT check_high_yield_prediction('Millet', 10) FROM DUAL"
    ],
    "id": 196
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `atan_for_adverse_events` that accepts two input parameters: `patient_id_param` of type `TEXT` and `event_date_param` of type `TEXT`. This function is designed to return a single value of type `DOUBLE PRECISION`. The function's primary operation involves querying the `adverse_events` table. Specifically, it performs a `SELECT` operation to retrieve data. Within this `SELECT` statement, it applies the `atan` (arctangent) mathematical function to the `event_id` column. Before applying `atan`, the `event_id` column, which is presumably of an integer or similar numeric type, is explicitly `CAST` to `DOUBLE PRECISION` to ensure accurate floating-point calculation for the `atan` function. The result of this `atan` calculation is then stored into a local variable named `atan_result`, which is declared within the function's `DECLARE` block as `DOUBLE PRECISION`. The `SELECT` statement includes a `WHERE` clause to filter the rows from the `adverse_events` table. This `WHERE` clause specifies two conditions that must both be met: first, the `patient_id` column in the `adverse_events` table must be equal to the value provided by the `patient_id_param` input parameter; and second, the `event_date` column in the `adverse_events` table must be equal to the value provided by the `event_date_param` input parameter. After the `SELECT` operation has completed and the calculated `atan` value has been assigned to `atan_result`, the function then `RETURN`s the value stored in the `atan_result` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION atan_for_adverse_events(patient_id_param TEXT, event_date_param TEXT)\nRETURNS DOUBLE PRECISION\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    atan_result DOUBLE PRECISION;\nBEGIN\n    SELECT atan(CAST(event_id AS DOUBLE PRECISION))\n    INTO atan_result\n    FROM adverse_events\n    WHERE patient_id = patient_id_param AND event_date = event_date_param;\n\n    RETURN atan_result;\nEND;\n$$;",
    "database_name": "clinical_trials_and_patient_management",
    "tables": [
      "adverse_events",
      "medical_history",
      "patient_regimens",
      "patient_visits"
    ],
    "call_sqls": [
      "SELECT atan_for_adverse_events('k403', '2023-01-15');",
      "SELECT atan_for_adverse_events('s185', '2023-01-20');",
      "SELECT atan_for_adverse_events('k403', '2023-01-20');",
      "SELECT atan_for_adverse_events('s185', '2023-01-15');",
      "SELECT atan_for_adverse_events('p001', '2023-02-10');",
      "SELECT atan_for_adverse_events('p002', '2023-02-15');",
      "SELECT atan_for_adverse_events('p003', '2023-02-20');",
      "SELECT atan_for_adverse_events('p004', '2023-02-25');",
      "SELECT atan_for_adverse_events('p005', '2023-03-01');",
      "SELECT atan_for_adverse_events('p006', '2023-03-05');",
      "SELECT atan_for_adverse_events('p007', '2023-03-10');",
      "SELECT atan_for_adverse_events('p008', '2023-03-15');",
      "SELECT atan_for_adverse_events('p009', '2023-03-20');",
      "SELECT atan_for_adverse_events('p010', '2023-03-25');",
      "SELECT atan_for_adverse_events('a123', '2023-04-01');",
      "SELECT atan_for_adverse_events('b456', '2023-04-05');",
      "SELECT atan_for_adverse_events('c789', '2023-04-10');",
      "SELECT atan_for_adverse_events('d012', '2023-04-15');",
      "SELECT atan_for_adverse_events('e345', '2023-04-20');",
      "SELECT atan_for_adverse_events('f678', '2023-04-25');"
    ],
    "id": 197
  },
  {
    "ir": "Write a PLpgSQL function that accepts two input parameters: p_type_name of type text, which represents the name of the incident type to be counted, and p_min_count of type bigint, which specifies the minimum count threshold. The function operates by first declaring a local variable v_incident_count of type bigint to store the count of incidents. It then performs a SELECT operation to count the number of rows in the incident_types table where the type_name column matches the value of p_type_name, storing the result in v_incident_count. Following this, the function evaluates a conditional statement: if the value of v_incident_count is less than p_min_count, it sets v_incident_count to zero. Finally, the function returns the value of v_incident_count, which represents either the actual count of incidents of the specified type or zero if the count was below the specified minimum threshold.",
    "plsql": "CREATE OR REPLACE FUNCTION count_incidents_by_type(IN p_type_name text, IN p_min_count bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_incident_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_incident_count\n    FROM incident_types it\n    WHERE it.type_name = p_type_name;\n    \n    IF v_incident_count < p_min_count THEN\n        v_incident_count := 0;\n    END IF;\n    \n    RETURN v_incident_count;\nEND;\n$$;",
    "database_name": "police_involved_shooting_incident_tracking_and_analysis",
    "tables": [
      "fleeing_status",
      "incident_tags",
      "incident_types",
      "officer_training",
      "threat_levels"
    ],
    "call_sqls": [
      "SELECT count_incidents_by_type('Shooting', 5);",
      "SELECT count_incidents_by_type('Taser Incident', 10);",
      "SELECT count_incidents_by_type('Shooting', 0);",
      "SELECT count_incidents_by_type('Taser Incident', 1);",
      "SELECT count_incidents_by_type('Shooting', 100);",
      "SELECT count_incidents_by_type('Taser Incident', 50);",
      "SELECT count_incidents_by_type('Shooting', 2);",
      "SELECT count_incidents_by_type('Taser Incident', 3);",
      "SELECT count_incidents_by_type('Shooting', 15);",
      "SELECT count_incidents_by_type('Taser Incident', 20);",
      "SELECT count_incidents_by_type('Shooting', 7);",
      "SELECT count_incidents_by_type('Taser Incident', 8);",
      "SELECT count_incidents_by_type('Shooting', 12);",
      "SELECT count_incidents_by_type('Taser Incident', 25);",
      "SELECT count_incidents_by_type('Shooting', 30);",
      "SELECT count_incidents_by_type('Taser Incident', 40);",
      "SELECT count_incidents_by_type('Shooting', 1);",
      "SELECT count_incidents_by_type('Taser Incident', 2);",
      "SELECT count_incidents_by_type('Shooting', 18);",
      "SELECT count_incidents_by_type('Taser Incident', 22);"
    ],
    "id": 198
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_latest_transaction_description that accepts a single input parameter para_item_id of type NUMBER and returns a VARCHAR2 value, which executes a SELECT statement on the transactions table to retrieve the description column value for a specific row, where the row is identified by the condition that the item_id column must equal the provided para_item_id parameter and the trans_date column must equal the maximum trans_date value found in the transactions table for rows sharing the same para_item_id value, and it further restricts the result set to a single row using the ROWNUM = 1 condition, then assigns the selected description value to the local variable latest_description and returns this value, but if the SELECT statement finds no matching rows and raises a NO_DATA_FOUND exception, the function returns NULL, and if any other type of exception occurs during execution, the function also returns NULL.",
    "plsql": "CREATE OR REPLACE FUNCTION get_latest_transaction_description(para_item_id NUMBER) RETURN VARCHAR2 IS\n  latest_description VARCHAR2(255);\nBEGIN\n  SELECT description\n  INTO latest_description\n  FROM transactions\n  WHERE item_id = para_item_id\n    AND trans_date = (SELECT MAX(trans_date) FROM transactions WHERE item_id = para_item_id)\n    AND ROWNUM = 1;\n\n  RETURN latest_description;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN OTHERS THEN\n    RETURN NULL;\nEND;",
    "database_name": "warehouse_mai_tracking",
    "tables": [
      "inventory",
      "transaction_history",
      "transactions",
      "tenants"
    ],
    "call_sqls": [
      "SELECT get_latest_transaction_description(0) FROM dual",
      "SELECT get_latest_transaction_description(1) FROM dual",
      "SELECT get_latest_transaction_description(10) FROM dual",
      "SELECT get_latest_transaction_description(100) FROM dual",
      "SELECT get_latest_transaction_description(5) FROM dual",
      "SELECT get_latest_transaction_description(7) FROM dual",
      "SELECT get_latest_transaction_description(12) FROM dual",
      "SELECT get_latest_transaction_description(15) FROM dual",
      "SELECT get_latest_transaction_description(20) FROM dual",
      "SELECT get_latest_transaction_description(25) FROM dual",
      "SELECT get_latest_transaction_description(30) FROM dual",
      "SELECT get_latest_transaction_description(35) FROM dual",
      "SELECT get_latest_transaction_description(40) FROM dual",
      "SELECT get_latest_transaction_description(45) FROM dual",
      "SELECT get_latest_transaction_description(50) FROM dual",
      "SELECT get_latest_transaction_description(55) FROM dual",
      "SELECT get_latest_transaction_description(60) FROM dual",
      "SELECT get_latest_transaction_description(65) FROM dual",
      "SELECT get_latest_transaction_description(70) FROM dual",
      "SELECT get_latest_transaction_description(75) FROM dual",
      "SELECT get_latest_transaction_description(80) FROM dual"
    ],
    "id": 199
  },
  {
    "ir": "Write a PLpgSQL function named create_balance_record that is designed to be executed as a trigger function. This function is triggered after a new row is inserted into the satisfaction_levels table. It performs an insert operation into the work_life_balance table, adding a new record with the following values: the balance_id column is set to the value of the satisfaction_id column from the newly inserted row in the satisfaction_levels table, the specialty_id column is set to the value of the specialty_id column from the same newly inserted row, and the burned_out column is calculated by subtracting the medicine_satisfaction value from 1.0, casting the result to a numeric type, rounding it to two decimal places, and then converting it to a text type. The function returns the newly inserted row, allowing the trigger to continue processing. The trigger named auto_balance_creation is defined to automatically execute this function after each row insertion into the satisfaction_levels table, ensuring that a corresponding record is created in the work_life_balance table for every new satisfaction level entry.",
    "plsql": "CREATE OR REPLACE FUNCTION create_balance_record() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO work_life_balance (balance_id, specialty_id, burned_out) VALUES (NEW.satisfaction_id, NEW.specialty_id, ROUND(1.0 - CAST(NEW.medicine_satisfaction AS NUMERIC), 2)::TEXT);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER auto_balance_creation\n    AFTER INSERT ON satisfaction_levels\n    FOR EACH ROW\n    EXECUTE FUNCTION create_balance_record();",
    "database_name": "medical_specialty_comparison_and_satisfaction_analysis",
    "tables": [
      "specialties",
      "physician_stats",
      "satisfaction_levels",
      "work_life_balance"
    ],
    "call_sqls": [
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (100, 0, '0.62', '0.47', '0.88', '0.75', '0.8', '0.85', '0.7');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (101, 1, '0.76', '0.65', '0.85', '0.78', '0.82', '0.87', '0.72');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (102, 0, '0.50', '0.40', '0.90', '0.70', '0.75', '0.80', '0.65');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (103, 1, '0.90', '0.80', '0.95', '0.85', '0.90', '0.92', '0.88');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (104, 0, '0.30', '0.20', '0.60', '0.50', '0.55', '0.65', '0.40');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (105, 1, '0.10', '0.15', '0.30', '0.25', '0.35', '0.40', '0.20');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (106, 0, '1.00', '0.95', '0.99', '0.98', '0.97', '0.96', '0.94');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (107, 1, '0.00', '0.05', '0.10', '0.12', '0.08', '0.15', '0.03');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (108, 0, '0.82', '0.77', '0.91', '0.83', '0.86', '0.89', '0.79');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (109, 1, '0.45', '0.55', '0.72', '0.68', '0.71', '0.74', '0.62');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (110, 0, '0.67', '0.59', '0.81', '0.73', '0.77', '0.82', '0.68');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (111, 1, '0.23', '0.33', '0.44', '0.39', '0.42', '0.48', '0.37');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (112, 0, '0.55', '0.48', '0.78', '0.66', '0.70', '0.75', '0.60');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (113, 1, '0.88', '0.79', '0.93', '0.87', '0.89', '0.91', '0.85');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (114, 0, '0.71', '0.63', '0.84', '0.76', '0.79', '0.83', '0.71');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (115, 1, '0.95', '0.88', '0.97', '0.92', '0.94', '0.95', '0.90');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (116, 0, '0.15', '0.10', '0.25', '0.18', '0.22', '0.28', '0.12');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (117, 1, '0.33', '0.41', '0.52', '0.47', '0.50', '0.54', '0.45');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (118, 0, '0.60', '0.52', '0.80', '0.69', '0.73', '0.78', '0.63');",
      "INSERT INTO satisfaction_levels (satisfaction_id, specialty_id, medicine_satisfaction, income_satisfaction, specialty_satisfaction, work_environment_satisfaction, peer_relationship_satisfaction, patient_relationship_satisfaction, career_advancement_satisfaction) VALUES (119, 1, '0.40', '0.50', '0.65', '0.60', '0.63', '0.67', '0.58');"
    ],
    "id": 200
  }
]