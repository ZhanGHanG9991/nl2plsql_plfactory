[
  {
    "ir": "Write an Oracle PL/SQL trigger named log_market_data_insert that is defined to execute automatically before any new row is inserted into the MARKET_DATA table, and it executes once for each individual row being inserted. The trigger performs a single INSERT operation into a separate table named ALERTS. For the new ALERTS row, it explicitly sets the ALERT_ID column to the constant integer value 2, the USER_ID column to the constant integer value 1, and the INSTRUMENT_ID column to the value of the INSTRUMENT_ID column from the newly inserted MARKET_DATA row, which is referenced using the :NEW.INSTRUMENT_ID bind variable. It sets the ALERT_PRICE column to the value of the CLOSE_PRICE column from the new MARKET_DATA row, referenced as :NEW.CLOSE_PRICE. The ALERT_TYPE column is populated with the constant string literal 'above', and the IS_ACTIVE column is set to the constant integer value 1. For the CREATION_DATE column, it uses the TO_CHAR function to convert the result of the CURRENT_DATE function into a string with the format 'YYYY-MM-DD'. Similarly, for the EXPIRATION_DATE column, it uses the TO_CHAR function to convert the date value of CURRENT_DATE plus 30 days into a string with the same 'YYYY-MM-DD' format.",
    "plsql": "CREATE OR REPLACE TRIGGER log_market_data_insert\nBEFORE INSERT ON MARKET_DATA\nFOR EACH ROW\nBEGIN\n    INSERT INTO ALERTS (ALERT_ID, USER_ID, INSTRUMENT_ID, ALERT_PRICE, ALERT_TYPE, IS_ACTIVE, CREATION_DATE, EXPIRATION_DATE) VALUES (2, 1, :NEW.INSTRUMENT_ID, :NEW.CLOSE_PRICE, 'above', 1, TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), TO_CHAR(CURRENT_DATE + 30, 'YYYY-MM-DD'));\nEND;",
    "database_name": "financial_mda_404480",
    "tables": [
      "ALERTS",
      "INSTRUMENTS",
      "MARKET_DATA",
      "PORTFOLIO",
      "PORTFOLIO_POSITIONS",
      "TRADING_SESSIONS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO MARKET_DATA (DATA_ID, TRADE_DATE, TRADE_TIME, OPEN_PRICE, HIGH_PRICE, LOW_PRICE, CLOSE_PRICE, TOTAL_TICKS, INSTRUMENT_ID, MARKET_VOLATILITY, TRADING_VOLUME, DATA_CAPTURE_METHOD) VALUES (2, '2023-10-01', '10:00:00', 85.000, 86.000, 84.500, 85.500, 2000, 1, 0.04, 12000, 'API')",
      "INSERT INTO MARKET_DATA (DATA_ID, TRADE_DATE, TRADE_TIME, OPEN_PRICE, HIGH_PRICE, LOW_PRICE, CLOSE_PRICE, TOTAL_TICKS, INSTRUMENT_ID, MARKET_VOLATILITY, TRADING_VOLUME, DATA_CAPTURE_METHOD) VALUES (3, '2023-10-02', '11:00:00', 86.000, 87.000, 85.500, 86.500, 2100, 1, 0.05, 13000, 'API')",
      "INSERT INTO MARKET_DATA (DATA_ID, TRADE_DATE, TRADE_TIME, OPEN_PRICE, HIGH_PRICE, LOW_PRICE, CLOSE_PRICE, TOTAL_TICKS, INSTRUMENT_ID, MARKET_VOLATILITY, TRADING_VOLUME, DATA_CAPTURE_METHOD) VALUES (4, '2023-10-03', '12:00:00', 87.000, 88.000, 86.500, 87.500, 2200, 1, 0.06, 14000, 'API')",
      "INSERT INTO MARKET_DATA (DATA_ID, TRADE_DATE, TRADE_TIME, OPEN_PRICE, HIGH_PRICE, LOW_PRICE, CLOSE_PRICE, TOTAL_TICKS, INSTRUMENT_ID, MARKET_VOLATILITY, TRADING_VOLUME, DATA_CAPTURE_METHOD) VALUES (5, '2023-10-04', '13:00:00', 88.000, 89.000, 87.500, 88.500, 2300, 1, 0.07, 15000, 'API')",
      "INSERT INTO MARKET_DATA (DATA_ID, TRADE_DATE, TRADE_TIME, OPEN_PRICE, HIGH_PRICE, LOW_PRICE, CLOSE_PRICE, TOTAL_TICKS, INSTRUMENT_ID, MARKET_VOLATILITY, TRADING_VOLUME, DATA_CAPTURE_METHOD) VALUES (6, '2023-10-05', '14:00:00', 89.000, 90.000, 88.500, 89.500, 2400, 1, 0.08, 16000, 'API')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named log_market_data_insert that fires BEFORE INSERT on the MARKET_DATA table for each new row, inserting a corresponding record into the ALERTS table with ALERT_ID set to 2, USER_ID set to 1, INSTRUMENT_ID taken from the new row's INSTRUMENT_ID, ALERT_PRICE taken from the new row's CLOSE_PRICE, ALERT_TYPE set to 'above', IS_ACTIVE set to 1, CREATION_DATE set to the current date formatted as 'YYYY-MM-DD', and EXPIRATION_DATE set to 30 days from the current date formatted as 'YYYY-MM-DD'.",
    "natural_language": "Write a Oracle PL/SQL trigger named log_market_data_insert that, before each new row is inserted into the MARKET_DATA table, automatically creates a corresponding record in the ALERTS table, setting ALERT_ID to 2, USER_ID to 1, taking INSTRUMENT_ID from the new row, using the new row's CLOSE_PRICE as ALERT_PRICE, specifying ALERT_TYPE as 'above', marking IS_ACTIVE as 1, and formatting both CREATION_DATE as today and EXPIRATION_DATE as thirty days from today in 'YYYY-MM-DD' format.",
    "id": 1,
    "generated_ir": "Write an Oracle PL/SQL trigger named log_market_data_insert that is defined to execute before any insert operation on the MARKET_DATA table for each individual row being inserted. The trigger does not declare any local variables. Within its execution block, it performs a single INSERT statement into the ALERTS table. The INSERT statement specifies explicit values for all columns of the ALERTS table. The ALERT_ID column is set to the numeric literal 2. The USER_ID column is set to the numeric literal 1. The INSTRUMENT_ID column is populated by referencing the INSTRUMENT_ID column from the new row being inserted into the MARKET_DATA table, using the bind variable :NEW.INSTRUMENT_ID. The ALERT_PRICE column is populated by referencing the CLOSE_PRICE column from the new row being inserted into the MARKET_DATA table, using the bind variable :NEW.CLOSE_PRICE. The ALERT_TYPE column is set to the string literal 'above'. The IS_ACTIVE column is set to the numeric literal 1. The CREATION_DATE column is set to the current system date, formatted as a string in 'YYYY-MM-DD' format using the TO_CHAR function with SYSDATE as the input. The EXPIRATION_DATE column is set to a date thirty days in the future from the current system date, also formatted as a string in 'YYYY-MM-DD' format. This is achieved by adding 30 to SYSDATE and then applying the TO_CHAR function with the 'YYYY-MM-DD' format mask. The trigger's purpose is to automatically generate an alert record whenever a new market data record is inserted.",
    "original_summary": "Create a BEFORE INSERT row-level trigger on MARKET_DATA named log_market_data_insert. For each new row, insert a corresponding record into the ALERTS table with ALERT_ID=2, USER_ID=1, INSTRUMENT_ID from the new row, ALERT_PRICE from the new CLOSE_PRICE, ALERT_TYPE='above', IS_ACTIVE=1, and CREATION_DATE and EXPIRATION_DATE (CURRENT_DATE + 30) formatted as 'YYYY-MM-DD'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a BEFORE INSERT row-level trigger for the MARKET_DATA table, which you should name log_market_data_insert. This trigger must be designed to execute for each individual new row being added. Its function is to meticulously insert a matching record into the ALERTS table, carefully populating the fields as follows: set the ALERT_ID to the constant value 2, assign USER_ID to 1, take the INSTRUMENT_ID directly from the newly inserted row, and derive the ALERT_PRICE from the new row's CLOSE_PRICE value. Furthermore, you must specify the ALERT_TYPE as 'above', ensure IS_ACTIVE is set to 1, and format both the CREATION_DATE and the EXPIRATION_DATE—the latter being calculated as the current date plus thirty days—using the unambiguous 'YYYY-MM-DD' date format."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_test_case_execution_check that fires before any insert or update operation on the TEST_CASE_EXECUTION table for each affected row, which declares a local variable v_defect_status of type VARCHAR2 with a maximum length of 255 characters, and then executes a SELECT statement to query the STATUS column from the DEFECTS table, retrieving the status value into v_defect_status where the DEFECT_ID column in the DEFECTS table matches the new value of the DEFECT_ID column being inserted or updated in the TEST_CASE_EXECUTION table (referenced as :NEW.DEFECT_ID), and subsequently uses a conditional IF statement to check if the retrieved v_defect_status value is exactly equal to the string 'Closed', and if true, assigns the string 'Passed' to the new value of the EXECUTION_STATUS column in the TEST_CASE_EXECUTION table (referenced as :NEW.EXECUTION_STATUS), or else checks with an ELSIF condition if v_defect_status is exactly equal to the string 'Open', and if true, assigns the string 'Failed' to :NEW.EXECUTION_STATUS.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_test_case_execution_check\nBEFORE INSERT OR UPDATE ON TEST_CASE_EXECUTION\nFOR EACH ROW\nDECLARE\n    v_defect_status VARCHAR2(255);\nBEGIN\n    SELECT STATUS INTO v_defect_status\n    FROM DEFECTS\n    WHERE DEFECT_ID = :NEW.DEFECT_ID;\n    IF v_defect_status = 'Closed' THEN\n        :NEW.EXECUTION_STATUS := 'Passed';\n    ELSIF v_defect_status = 'Open' THEN\n        :NEW.EXECUTION_STATUS := 'Failed';\n    END IF;\nEND;",
    "database_name": "software_taqa_890020",
    "tables": [
      "PROJECTS",
      "RELEASES",
      "TEST_PLANS",
      "TEST_CASES",
      "TEST_CASE_EXECUTION",
      "DEFECTS"
    ],
    "call_sqls": [
      "INSERT INTO TEST_CASE_EXECUTION (EXECUTION_ID, TEST_CASE_ID, TEST_PLAN_ID, EXECUTION_STATUS, EXECUTION_DATE, EXECUTOR, EXECUTION_NOTES, DEFECT_ID) VALUES (100, 1, 1, NULL, '2023-10-01', 'John Doe', 'Testing with closed defect', 1)",
      "INSERT INTO TEST_CASE_EXECUTION (EXECUTION_ID, TEST_CASE_ID, TEST_PLAN_ID, EXECUTION_STATUS, EXECUTION_DATE, EXECUTOR, EXECUTION_NOTES, DEFECT_ID) VALUES (101, 2, 1, NULL, '2023-10-01', 'Jane Doe', 'Testing with open defect', 0)",
      "UPDATE TEST_CASE_EXECUTION SET DEFECT_ID = 1, EXECUTION_NOTES = 'Updated to closed defect' WHERE EXECUTION_ID = 101",
      "UPDATE TEST_CASE_EXECUTION SET DEFECT_ID = 0, EXECUTION_DATE = '2023-10-02' WHERE EXECUTION_ID = 100",
      "INSERT INTO TEST_CASE_EXECUTION (EXECUTION_ID, TEST_CASE_ID, TEST_PLAN_ID, EXECUTION_DATE, EXECUTOR, DEFECT_ID) VALUES (102, 3, 2, '2023-10-03', 'Bob Smith', 1)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_test_case_execution_check that fires before each insert or update on the TEST_CASE_EXECUTION table. For each row, it retrieves the STATUS from the DEFECTS table based on the new DEFECT_ID. If the defect status is 'Closed', set the new EXECUTION_STATUS to 'Passed'; if the defect status is 'Open', set the new EXECUTION_STATUS to 'Failed'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_test_case_execution_check that, before inserting or updating a row in the TEST_CASE_EXECUTION table, sets the EXECUTION_STATUS to 'Passed' if the corresponding DEFECT_ID in the DEFECTS table has a status of 'Closed', or sets it to 'Failed' if the status is 'Open'.",
    "id": 2,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_test_case_execution_check that fires before any insert or update operation on the TEST_CASE_EXECUTION table for each affected row, which declares a local variable v_defect_status of type VARCHAR2 with a maximum length of 255 characters, and then executes a SELECT statement to query the STATUS column from the DEFECTS table, retrieving the status value into v_defect_status where the DEFECT_ID column in the DEFECTS table matches the new value of the DEFECT_ID column being inserted or updated in the TEST_CASE_EXECUTION table (referenced as :NEW.DEFECT_ID), and subsequently uses a conditional IF statement to check if the retrieved v_defect_status value is exactly equal to the string 'Closed', and if true, assigns the string 'Passed' to the new value of the EXECUTION_STATUS column in the TEST_CASE_EXECUTION table (referenced as :NEW.EXECUTION_STATUS), or else checks with an ELSIF condition if v_defect_status is exactly equal to the string 'Open', and if true, assigns the string 'Failed' to :NEW.EXECUTION_STATUS.",
    "original_summary": "Create a trigger named trg_test_case_execution_check that fires before insert or update on TEST_CASE_EXECUTION for each row. It retrieves the STATUS from DEFECTS based on the new DEFECT_ID. If the defect status is 'Closed', set the new EXECUTION_STATUS to 'Passed'. If the defect status is 'Open', set the new EXECUTION_STATUS to 'Failed'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Before inserting or updating TEST_CASE_EXECUTION, set EXECUTION_STATUS to 'Passed' if its DEFECT_ID's status in DEFECTS is 'Closed', or to 'Failed' if 'Open'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_climate_data that is defined to fire automatically after any row in the REGIONS table is updated, and for each updated row, it executes a DELETE operation on the CLIMATE_DATA table where the condition requires that the CLIMATE_DATA.REGION_ID column matches the old REGION_ID value from the REGIONS row before the update, which is referenced as :OLD.REGION_ID, and simultaneously requires that the CLIMATE_DATA.LATITUDE column is less than the new LATITUDE_MIN value from the updated REGIONS row, which is referenced as :NEW.LATITUDE_MIN.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_climate_data\nAFTER UPDATE ON REGIONS\nFOR EACH ROW\nBEGIN\n    DELETE FROM CLIMATE_DATA WHERE REGION_ID = :OLD.REGION_ID AND LATITUDE < :NEW.LATITUDE_MIN;\nEND;",
    "database_name": "climate_daa_prediction",
    "tables": [
      "CLIMATE_DATA",
      "DATASETS",
      "MODEL_PERFORMANCE",
      "MODEL_PARAMETERS",
      "REGIONS"
    ],
    "call_sqls": [
      "UPDATE REGIONS SET LATITUDE_MIN = 35.0000 WHERE REGION_ID = 0",
      "UPDATE REGIONS SET LATITUDE_MIN = 40.0000 WHERE REGION_ID = 1",
      "UPDATE REGIONS SET LATITUDE_MIN = 30.0000 WHERE REGION_ID = 0",
      "UPDATE REGIONS SET LATITUDE_MIN = 45.0000 WHERE REGION_ID = 1",
      "UPDATE REGIONS SET LATITUDE_MIN = 38.0000 WHERE REGION_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL trigger named `trg_update_climate_data` that fires AFTER UPDATE on the REGIONS table for each row, and deletes all rows from the CLIMATE_DATA table where the CLIMATE_DATA.REGION_ID matches the old REGION_ID from the updated row and the CLIMATE_DATA.LATITUDE is less than the new LATITUDE_MIN value from the updated row.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_climate_data that, after updating a row in the REGIONS table, deletes any records from the CLIMATE_DATA table where the REGION_ID matches the old REGION_ID from REGIONS, but only if the LATITUDE in CLIMATE_DATA is below the new LATITUDE_MIN value set in the update.",
    "id": 3,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_update_climate_data` that is configured to execute automatically after an `UPDATE` operation is performed on the `REGIONS` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is updated in the `REGIONS` table.\n\nThe trigger's primary purpose is to conditionally delete records from the `CLIMATE_DATA` table based on the values involved in the update of a `REGIONS` row. Specifically, for each row being updated in the `REGIONS` table, the trigger executes a `DELETE` statement targeting the `CLIMATE_DATA` table.\n\nThe `DELETE` statement includes a `WHERE` clause that defines two conditions that must both be true for a `CLIMATE_DATA` record to be deleted. The first condition is `CLIMATE_DATA.REGION_ID = :OLD.REGION_ID`. This condition checks if the `REGION_ID` column in the `CLIMATE_DATA` table matches the value of the `REGION_ID` column from the `REGIONS` table row before it was updated. This value is accessed using the `:OLD.REGION_ID` pseudorecord.\n\nThe second condition in the `WHERE` clause is `CLIMATE_DATA.LATITUDE < :NEW.LATITUDE_MIN`. This condition checks if the `LATITUDE` column in the `CLIMATE_DATA` table is strictly less than the new value assigned to the `LATITUDE_MIN` column in the `REGIONS` table row as a result of the `UPDATE` operation. This new value is accessed using the `:NEW.LATITUDE_MIN` pseudorecord.\n\nThe `DELETE` operation will only remove rows from the `CLIMATE_DATA` table where both conditions are satisfied: the `REGION_ID` matches the old region identifier from the updated `REGIONS` row, and the associated `LATITUDE` in the climate data is below the newly specified minimum latitude threshold for that region. If either condition is false for a given row in `CLIMATE_DATA`, that row will not be deleted. The trigger performs this cleanup action automatically following the successful update of a row in the `REGIONS` table.",
    "original_summary": "Create a trigger named `trg_update_climate_data` that fires AFTER UPDATE on the REGIONS table for each row. It deletes rows from the CLIMATE_DATA table where CLIMATE_DATA.REGION_ID equals the :OLD.REGION_ID and CLIMATE_DATA.LATITUDE is less than the :NEW.LATITUDE_MIN.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger called `trg_update_climate_data`. Set it up so that after we update a row in the REGIONS table, it goes and cleans out any old climate data. Specifically, it should delete any records from the CLIMATE_DATA table where the region ID matches the old one from REGIONS, but only if that climate data's latitude is below the new minimum latitude we just set."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_property_from_prediction that is executed automatically after a new row is inserted into the PREDICTIONS table. This trigger operates on each row that is inserted into the PREDICTIONS table. When a new row is inserted, the trigger performs an insert operation into the PROPERTIES table. Specifically, it inserts a new row into the PROPERTIES table with the following values: the PROPERTY_ID column is set to the value of the PROPERTY_ID column from the newly inserted row in the PREDICTIONS table, the MEDIAN_VALUE column is set to the value of the PREDICTED_VALUE column from the newly inserted row in the PREDICTIONS table, and the CATEGORICAL_MEDIAN_VALUE column is set to the constant string 'NEW'. The trigger does not perform any updates, deletes, or selects, nor does it involve any function calls or special operations. There are no conditional statements or logic flow variations within this trigger; it simply executes the described insert operation for each new row added to the PREDICTIONS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_property_from_prediction\nAFTER INSERT ON PREDICTIONS\nFOR EACH ROW\nBEGIN\n  INSERT INTO PROPERTIES (PROPERTY_ID, MEDIAN_VALUE, CATEGORICAL_MEDIAN_VALUE)\n  VALUES (:NEW.PROPERTY_ID, :NEW.PREDICTED_VALUE, 'NEW');\nEND;",
    "database_name": "real_eauda_73520",
    "tables": [
      "PROPERTIES",
      "PROPERTY_VALUES",
      "PREDICTIONS"
    ],
    "call_sqls": [
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1001, 5001, 350000, '2024-01-15', 'Linear Regression')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1002, 5002, 425000, '2024-01-16', 'Random Forest')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1003, 5003, 275000, '2024-01-17', 'Neural Network')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1004, 5004, 520000, '2024-01-18', 'Gradient Boosting')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1005, 5005, 310000, '2024-01-19', 'SVM')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_insert_property_from_prediction that fires after each new row is inserted into the PREDICTIONS table, and for each such insertion, it automatically adds a corresponding record to the PROPERTIES table, setting the PROPERTY_ID to the new prediction's PROPERTY_ID, the MEDIAN_VALUE to the new prediction's PREDICTED_VALUE, and the CATEGORICAL_MEDIAN_VALUE to the fixed value 'NEW'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_insert_property_from_prediction that, after each new row is inserted into the PREDICTIONS table, automatically creates a corresponding record in the PROPERTIES table, using the new prediction's PROPERTY_ID for the PROPERTY_ID column, its PREDICTED_VALUE for the MEDIAN_VALUE column, and setting the CATEGORICAL_MEDIAN_VALUE column to 'NEW'.",
    "id": 4,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_insert_property_from_prediction` that is configured to execute `AFTER` any `INSERT` operation on the `PREDICTIONS` table. This trigger is a `FOR EACH ROW` trigger, meaning it will execute once for every row inserted into the `PREDICTIONS` table. The trigger does not declare any local variables. The trigger's `BEGIN` block starts by performing an `INSERT` operation into the `PROPERTIES` table. This `INSERT` statement specifies three columns in the `PROPERTIES` table: `PROPERTY_ID`, `MEDIAN_VALUE`, and `CATEGORICAL_MEDIAN_VALUE`. The values for these columns are sourced from the newly inserted row in the `PREDICTIONS` table. Specifically, the value for the `PROPERTY_ID` column in the `PROPERTIES` table is set to the value of the `PROPERTY_ID` column from the new row in the `PREDICTIONS` table, which is accessed via `:NEW.PROPERTY_ID`. The value for the `MEDIAN_VALUE` column in the `PROPERTIES` table is set to the value of the `PREDICTED_VALUE` column from the new row in the `PREDICTIONS` table, which is accessed via `:NEW.PREDICTED_VALUE`. The value for the `CATEGORICAL_MEDIAN_VALUE` column in the `PROPERTIES` table is set to the string literal `'NEW'`. The trigger concludes after this single `INSERT` operation.",
    "original_summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_insert_property_from_prediction on the PREDICTIONS table. For each new prediction, insert a row into the PROPERTIES table. Set PROPERTY_ID to :NEW.PROPERTY_ID, MEDIAN_VALUE to :NEW.PREDICTED_VALUE, and CATEGORICAL_MEDIAN_VALUE to the constant string 'NEW'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger designated as trg_insert_property_from_prediction on the PREDICTIONS table. The trigger's function is to insert a corresponding record into the PROPERTIES table for each newly inserted prediction. The values to be inserted are as follows: assign the PROPERTY_ID column the value from :NEW.PROPERTY_ID, set the MEDIAN_VALUE column to the value from :NEW.PREDICTED_VALUE, and populate the CATEGORICAL_MEDIAN_VALUE column with the constant string 'NEW'."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `update_player_statistics` that is defined to execute `AFTER` an `INSERT` operation occurs on the `PLAYER_STATISTICS` table. This trigger is a `FOR EACH ROW` trigger, meaning its body will execute once for each row that is inserted into the `PLAYER_STATISTICS` table. Within the trigger body, two separate `UPDATE` statements are executed against the `PLAYERS` table. The first `UPDATE` statement increments the `WINS` column in the `PLAYERS` table by `1`. This update is applied to rows in the `PLAYERS` table where the `PLAYER_ID` column matches the `PLAYER_ID` value of the newly inserted row in `PLAYER_STATISTICS` (referenced as `:NEW.PLAYER_ID`). Additionally, this update is conditional on the existence of at least one row in the `GAMES` table where the `GAME_ID` column matches the `GAME_ID` value of the newly inserted row in `PLAYER_STATISTICS` (referenced as `:NEW.GAME_ID`) AND the `GAME_RESULT` column in that `GAMES` table row is equal to the string literal `'W'`. The second `UPDATE` statement increments the `LOSSES` column in the `PLAYERS` table by `1`. This update is applied to rows in the `PLAYERS` table where the `PLAYER_ID` column matches the `PLAYER_ID` value of the newly inserted row in `PLAYER_STATISTICS` (referenced as `:NEW.PLAYER_ID`). Furthermore, this update is conditional on the existence of at least one row in the `GAMES` table where the `GAME_ID` column matches the `GAME_ID` value of the newly inserted row in `PLAYER_STATISTICS` (referenced as `:NEW.GAME_ID`) AND the `GAME_RESULT` column in that `GAMES` table row is equal to the string literal `'L'`.",
    "plsql": "CREATE OR REPLACE TRIGGER update_player_statistics\nAFTER INSERT ON PLAYER_STATISTICS\nFOR EACH ROW\nBEGIN\n    UPDATE PLAYERS SET WINS = WINS + 1 WHERE PLAYER_ID = :NEW.PLAYER_ID AND EXISTS (SELECT 1 FROM GAMES WHERE GAME_ID = :NEW.GAME_ID AND GAME_RESULT = 'W');\n    UPDATE PLAYERS SET LOSSES = LOSSES + 1 WHERE PLAYER_ID = :NEW.PLAYER_ID AND EXISTS (SELECT 1 FROM GAMES WHERE GAME_ID = :NEW.GAME_ID AND GAME_RESULT = 'L');\nEND;",
    "database_name": "basketball_gsap_tracking",
    "tables": [
      "GAMES",
      "PLAYERS",
      "PLAYER_STATISTICS"
    ],
    "call_sqls": [
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS) VALUES (100, 0, 1, 25)",
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, DRB) VALUES (101, 1, 0, 30, 5)",
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, ASSISTS) VALUES (102, 0, 0, 18, 8)",
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, BLOCKS) VALUES (103, 1, 1, 22, 2)",
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, STL) VALUES (104, 0, 1, 15, 3)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named update_player_statistics that fires after each new row is inserted into the PLAYER_STATISTICS table. For each insertion, update the PLAYERS table by incrementing the WINS column by 1 for the matching PLAYER_ID only if a corresponding game exists in the GAMES table with the same GAME_ID and a GAME_RESULT of 'W', and increment the LOSSES column by 1 for the matching PLAYER_ID only if a corresponding game exists in the GAMES table with the same GAME_ID and a GAME_RESULT of 'L'.",
    "natural_language": "Write a Oracle PL/SQL trigger called update_player_statistics that fires AFTER INSERT on the PLAYER_STATISTICS table, and for each new row, conditionally updates the PLAYERS table: increment the WINS column by 1 for the matching PLAYER_ID only if the corresponding game in the GAMES table has the same GAME_ID and a GAME_RESULT of 'W', and increment the LOSSES column by 1 for the matching PLAYER_ID only if the corresponding game in the GAMES table has the same GAME_ID and a GAME_RESULT of 'L'.",
    "id": 5,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `update_player_statistics` that is defined to execute `AFTER` an `INSERT` operation occurs on the `PLAYER_STATISTICS` table. This trigger is a `FOR EACH ROW` trigger, meaning its body will execute once for each row that is inserted into the `PLAYER_STATISTICS` table. Within the trigger body, two separate `UPDATE` statements are executed against the `PLAYERS` table. The first `UPDATE` statement increments the `WINS` column in the `PLAYERS` table by `1`. This update is applied to rows in the `PLAYERS` table where the `PLAYER_ID` column matches the `PLAYER_ID` value of the newly inserted row in `PLAYER_STATISTICS` (referenced as `:NEW.PLAYER_ID`). Additionally, this update is conditional on the existence of at least one row in the `GAMES` table where the `GAME_ID` column matches the `GAME_ID` value of the newly inserted row in `PLAYER_STATISTICS` (referenced as `:NEW.GAME_ID`) AND the `GAME_RESULT` column in that `GAMES` table row is equal to the string literal `'W'`. The second `UPDATE` statement increments the `LOSSES` column in the `PLAYERS` table by `1`. This update is applied to rows in the `PLAYERS` table where the `PLAYER_ID` column matches the `PLAYER_ID` value of the newly inserted row in `PLAYER_STATISTICS` (referenced as `:NEW.PLAYER_ID`). Furthermore, this update is conditional on the existence of at least one row in the `GAMES` table where the `GAME_ID` column matches the `GAME_ID` value of the newly inserted row in `PLAYER_STATISTICS` (referenced as `:NEW.GAME_ID`) AND the `GAME_RESULT` column in that `GAMES` table row is equal to the string literal `'L'`.",
    "original_summary": "Create an AFTER INSERT row-level trigger named update_player_statistics on the PLAYER_STATISTICS table. For each new row, execute two updates on the PLAYERS table. First, increment the WINS column by 1 for the matching PLAYER_ID, but only if a corresponding game exists in the GAMES table with the same GAME_ID and a GAME_RESULT of 'W'. Second, increment the LOSSES column by 1 for the matching PLAYER_ID, but only if a corresponding game exists in the GAMES table with the same GAME_ID and a GAME_RESULT of 'L'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a row-level trigger called update_player_statistics that fires AFTER INSERT on the PLAYER_STATISTICS table. For each inserted row, perform two conditional updates on the PLAYERS table. First, add 1 to the WINS column for the matching PLAYER_ID, but only when a corresponding game in the GAMES table has the same GAME_ID and a GAME_RESULT of 'W'. Second, add 1 to the LOSSES column for the matching PLAYER_ID, but only when a corresponding game in the GAMES table has the same GAME_ID and a GAME_RESULT of 'L'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_after_login that is executed after a new row is inserted into the LOGIN_HISTORY table. This trigger operates for each row inserted and performs the following actions: it inserts a new record into the USER_ACTIVITY table with the following values: the ACTIVITY_ID is determined by selecting the maximum existing ACTIVITY_ID from the USER_ACTIVITY table, using the NVL function to handle null values by defaulting to 0, and then incrementing this value by 1; the USER_ID is taken from the newly inserted row in the LOGIN_HISTORY table, referenced as :NEW.USER_ID; the ACTIVITY_TIME is set to the LOGIN_TIME from the new row, referenced as :NEW.LOGIN_TIME; the ACTIVITY_TYPE is hardcoded as the string 'login'; the IP_ADDRESS is taken from the new row, referenced as :NEW.IP_ADDRESS; the DEVICE is taken from the new row, referenced as :NEW.DEVICE; and the LOCATION is taken from the new row, referenced as :NEW.LOCATION.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_login\nAFTER INSERT ON LOGIN_HISTORY\nFOR EACH ROW\nBEGIN\n  INSERT INTO USER_ACTIVITY (ACTIVITY_ID, USER_ID, ACTIVITY_TIME, ACTIVITY_TYPE, IP_ADDRESS, DEVICE, LOCATION)\n  VALUES ((SELECT NVL(MAX(ACTIVITY_ID), 0) + 1 FROM USER_ACTIVITY), :NEW.USER_ID, :NEW.LOGIN_TIME, 'login', :NEW.IP_ADDRESS, :NEW.DEVICE, :NEW.LOCATION);\nEND;",
    "database_name": "user_maa_syste",
    "tables": [
      "USERS",
      "LOGIN_HISTORY",
      "USER_ACTIVITY",
      "PASSWORD_RESET",
      "NOTIFICATIONS",
      "TEAM_INVITATIONS",
      "TEAM_MEMBERS",
      "TEAMS"
    ],
    "call_sqls": [
      "INSERT INTO LOGIN_HISTORY (LOGIN_ID, USER_ID, LOGIN_TIME, IP_ADDRESS, DEVICE, LOCATION) VALUES (1, 100, '2024-01-15 09:30:45.123456', '192.168.10.101', 'desktop', 'San Francisco, CA')",
      "INSERT INTO LOGIN_HISTORY (LOGIN_ID, USER_ID, LOGIN_TIME, IP_ADDRESS, DEVICE, LOCATION) VALUES (2, 101, '2024-01-15 10:15:22.654321', '10.0.0.5', 'mobile', 'New York, NY')",
      "INSERT INTO LOGIN_HISTORY (LOGIN_ID, USER_ID, LOGIN_TIME, IP_ADDRESS, DEVICE, LOCATION) VALUES (3, 102, '2024-01-15 11:45:10.987654', '172.16.254.1', 'tablet', 'Chicago, IL')",
      "INSERT INTO LOGIN_HISTORY (LOGIN_ID, USER_ID, LOGIN_TIME, IP_ADDRESS, DEVICE, LOCATION) VALUES (4, 100, '2024-01-15 14:20:33.456789', '192.168.10.101', 'desktop', 'San Francisco, CA')",
      "INSERT INTO LOGIN_HISTORY (LOGIN_ID, USER_ID, LOGIN_TIME, IP_ADDRESS, DEVICE, LOCATION) VALUES (5, 103, '2024-01-15 16:05:18.111222', '203.0.113.195', 'mobile', 'London, UK')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_AFTER_LOGIN that fires after each new row is inserted into the LOGIN_HISTORY table, and for each insertion, it records a corresponding activity in the USER_ACTIVITY table. The trigger should generate a new ACTIVITY_ID by taking the maximum existing ACTIVITY_ID from USER_ACTIVITY (or starting at 1 if none exist), and populate the USER_ACTIVITY record with the USER_ID, LOGIN_TIME (as ACTIVITY_TIME), a fixed ACTIVITY_TYPE of 'login', IP_ADDRESS, DEVICE, and LOCATION from the newly inserted LOGIN_HISTORY row.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_AFTER_LOGIN that, after each new row is inserted into the LOGIN_HISTORY table, inserts a corresponding record into the USER_ACTIVITY table, setting ACTIVITY_ID to the next sequential number based on the maximum existing ACTIVITY_ID, USER_ID to the new USER_ID, ACTIVITY_TIME to the new LOGIN_TIME, ACTIVITY_TYPE to 'login', IP_ADDRESS to the new IP_ADDRESS, DEVICE to the new DEVICE, and LOCATION to the new LOCATION.",
    "id": 6,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_AFTER_LOGIN that automatically executes after a new row is inserted into the LOGIN_HISTORY table. This trigger operates for each row inserted and begins by inserting a new record into the USER_ACTIVITY table. The columns populated in the USER_ACTIVITY table include ACTIVITY_ID, USER_ID, ACTIVITY_TIME, ACTIVITY_TYPE, IP_ADDRESS, DEVICE, and LOCATION. The ACTIVITY_ID is determined by selecting the maximum existing ACTIVITY_ID from the USER_ACTIVITY table, adding 1 to it, and using NVL to default to 0 if no records exist. The USER_ID is directly taken from the newly inserted row in the LOGIN_HISTORY table using the :NEW pseudo-record. The ACTIVITY_TIME is set to the LOGIN_TIME from the new LOGIN_HISTORY record. The ACTIVITY_TYPE is hardcoded as 'login'. The IP_ADDRESS is taken from the new LOGIN_HISTORY record. The DEVICE is taken from the new LOGIN_HISTORY record. The LOCATION is taken from the new LOGIN_HISTORY record. The insertion into USER_ACTIVITY occurs unconditionally for every new row inserted into LOGIN_HISTORY.",
    "original_summary": "Create an AFTER INSERT FOR EACH ROW trigger named TRG_AFTER_LOGIN on the LOGIN_HISTORY table. For each new row, insert a record into USER_ACTIVITY. The ACTIVITY_ID should be NVL((select max(ACTIVITY_ID) from USER_ACTIVITY), 0) + 1. Set USER_ID to :NEW.USER_ID, ACTIVITY_TIME to :NEW.LOGIN_TIME, ACTIVITY_TYPE to 'login', IP_ADDRESS to :NEW.IP_ADDRESS, DEVICE to :NEW.DEVICE, and LOCATION to :NEW.LOCATION.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER INSERT FOR EACH ROW trigger named TRG_AFTER_LOGIN on the LOGIN_HISTORY table so that for each new row, a record is inserted into USER_ACTIVITY? The ACTIVITY_ID should be set to NVL((select max(ACTIVITY_ID) from USER_ACTIVITY), 0) + 1, USER_ID to :NEW.USER_ID, ACTIVITY_TIME to :NEW.LOGIN_TIME, ACTIVITY_TYPE to 'login', IP_ADDRESS to :NEW.IP_ADDRESS, DEVICE to :NEW.DEVICE, and LOCATION to :NEW.LOCATION."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named TRG_EMPLOYMENT_STAT that is activated AFTER any INSERT, UPDATE, or DELETE operation is performed on the EMPLOYMENT table. This trigger declares a local numeric variable named new_stat_id. Upon activation, the trigger first executes a SELECT statement to determine the next available statistic identifier. This SELECT statement queries the STATISTICS table, specifically retrieving the maximum value from the STAT_ID column. The NVL function is applied to this maximum value, ensuring that if no records exist in the STATISTICS table (and thus MAX(STAT_ID) returns NULL), the value 0 is used instead. This result is then incremented by 1 to generate a unique new_stat_id, which is subsequently stored in the new_stat_id local variable. Following this, the trigger performs an INSERT operation into the STATISTICS table. The columns being populated in the STATISTICS table are STAT_ID, STAT_NAME, STAT_VALUE, STAT_DATE, STATISTIC_TYPE, STATISTIC_DESCRIPTION, and STATISTIC_SOURCE. The values for these columns are derived from a subquery. For the STAT_ID column, the value is taken directly from the new_stat_id local variable. For the STAT_NAME column, a literal string 'average wage' is used. For the STAT_VALUE column, the AVG aggregate function is applied to the WAGE column from the EMPLOYMENT table. For the STAT_DATE column, the current system date and time (SYSDATE) is formatted into a 'YYYY-MM-DD' string using the TO_CHAR function. For the STATISTIC_TYPE column, a literal string 'financial' is used. For the STATISTIC_DESCRIPTION column, a literal string 'Average wage of employed individuals' is used. For the STATISTIC_SOURCE column, a literal string 'Internal Data' is used. The data for this INSERT statement is selected from the EMPLOYMENT table, but only for those rows where the EMPLOYED column has a value of 1.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_EMPLOYMENT_STAT\nAFTER INSERT OR UPDATE OR DELETE ON EMPLOYMENT\nDECLARE\n   new_stat_id NUMBER;\nBEGIN\n   SELECT NVL(MAX(STAT_ID), 0) + 1 INTO new_stat_id FROM STATISTICS;\n\n   INSERT INTO STATISTICS (STAT_ID, STAT_NAME, STAT_VALUE, STAT_DATE, STATISTIC_TYPE, STATISTIC_DESCRIPTION, STATISTIC_SOURCE)\n   SELECT new_stat_id, 'average wage', AVG(WAGE), TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'financial', 'Average wage of employed individuals', 'Internal Data'\n   FROM EMPLOYMENT\n   WHERE EMPLOYED = 1;\nEND;",
    "database_name": "demographic_aeda_192071",
    "tables": [
      "ACCESS_LOGS",
      "DEMOGRAPHICS",
      "EDUCATION",
      "EMPLOYMENT",
      "FINANCIAL_AID",
      "HOUSEHOLD",
      "INDIVIDUALS",
      "STATISTICS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO EMPLOYMENT (ID, EMPLOYED, WAGE, COLLGRAD, EMPLOYMENT_SECTOR, EMPLOYMENT_START_DATE, EMPLOYMENT_END_DATE, JOB_TITLE, EMPLOYER_NAME, INCOME_SOURCE, HEALTH_INSURANCE) VALUES (2, 1, 25.50, 1, 'Technology', '2022-01-15', NULL, 'Software Engineer', 'Tech Solutions Inc.', 'Wage', 1)",
      "UPDATE EMPLOYMENT SET WAGE = 28.00 WHERE ID = 2",
      "DELETE FROM EMPLOYMENT WHERE ID = 0",
      "INSERT INTO EMPLOYMENT (ID, EMPLOYED, WAGE, COLLGRAD, EMPLOYMENT_SECTOR, EMPLOYMENT_START_DATE, EMPLOYMENT_END_DATE, JOB_TITLE, EMPLOYER_NAME, INCOME_SOURCE, HEALTH_INSURANCE) VALUES (3, 0, 0, 0, NULL, NULL, NULL, NULL, NULL, 'Unemployed', 0)",
      "UPDATE EMPLOYMENT SET EMPLOYED = 1, WAGE = 15.00 WHERE ID = 3"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_EMPLOYMENT_STAT that fires after any INSERT, UPDATE, or DELETE operation on the EMPLOYMENT table, and for each such event, it calculates the next available STAT_ID from the STATISTICS table, then inserts a new record into the STATISTICS table with that ID, using 'average wage' as the STAT_NAME, the average WAGE from EMPLOYMENT where EMPLOYED equals 1 as the STAT_VALUE, the current date as STAT_DATE, 'financial' as STATISTIC_TYPE, 'Average wage of employed individuals' as STATISTIC_DESCRIPTION, and 'Internal Data' as STATISTIC_SOURCE.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_EMPLOYMENT_STAT that fires after any insert, update, or delete on the EMPLOYMENT table to automatically record a new financial statistic. It should generate the next available STAT_ID from the STATISTICS table, then insert a new row into STATISTICS with the name 'average wage', the calculated average WAGE from currently employed individuals (where EMPLOYED = 1), today's date as STAT_DATE, the type 'financial', a description 'Average wage of employed individuals', and the source 'Internal Data'.",
    "id": 7,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_EMPLOYMENT_STAT that is executed after any insert, update, or delete operation on the EMPLOYMENT table. The trigger is a statement-level trigger, meaning it fires once per triggering statement, not per row. It declares a local variable v_next_stat_id of type NUMBER to store the next available STAT_ID from the STATISTICS table. It also declares a local variable v_avg_wage of type NUMBER to store the calculated average WAGE from the EMPLOYMENT table.\n\nThe trigger performs a SELECT statement to retrieve the maximum STAT_ID value from the STATISTICS table, using the NVL function to default to 0 if no rows are found, and then adds 1 to this value to generate the next available STAT_ID, assigning this result to v_next_stat_id. It then performs another SELECT statement to calculate the average WAGE from the EMPLOYMENT table, specifically from rows where the EMPLOYED column equals 1, and assigns this average value to v_avg_wage.\n\nAfter obtaining these values, the trigger executes an INSERT statement into the STATISTICS table. The inserted row includes the following values: v_next_stat_id for the STAT_ID column, the string 'average wage' for the NAME column, v_avg_wage for the VALUE column, the current date (using SYSDATE) for the STAT_DATE column, the string 'financial' for the TYPE column, the string 'Average wage of employed individuals' for the DESCRIPTION column, and the string 'Internal Data' for the SOURCE column. This ensures that after any data modification on the EMPLOYMENT table, a new financial statistic recording the average wage of employed individuals is automatically created in the STATISTICS table.",
    "original_summary": "Create an AFTER INSERT, UPDATE, or DELETE trigger named TRG_EMPLOYMENT_STAT on the EMPLOYMENT table. For each triggering event, calculate the next STAT_ID from the STATISTICS table. Insert a new statistic record with this ID, name 'average wage', value as the average WAGE from EMPLOYMENT where EMPLOYED=1, current date, type 'financial', description 'Average wage of employed individuals', and source 'Internal Data'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the EMPLOYMENT table for when data is added, changed, or removed. Call it something like TRG_EMPLOYMENT_STAT. Whenever it fires, figure out the next available ID from the statistics records. Then, put in a new stat entry using that ID. For the name, use something like 'average wage'. For the value, work out the typical wage amount for people who are currently employed. Use today's date, mark it as a 'financial' type, add a note like 'Average wage of employed individuals', and say the source is our internal info."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_calculate_total_exec_time that is executed before an insert operation on the EXECUTION_TIMES table for each row being inserted. The trigger declares a local variable v_total_time of type NUMBER to store the cumulative execution time. It performs a SELECT statement to calculate the sum of the ITR_TIME column from the EXECUTION_TIMES table where the EXPERIMENT_ID matches the EXPERIMENT_ID of the row being inserted, using the :NEW.EXPERIMENT_ID bind variable to reference the new row's EXPERIMENT_ID. The result of this sum is stored in the v_total_time variable. The trigger then assigns the TOTAL_EXEC_TIME column of the new row, referenced by :NEW.TOTAL_EXEC_TIME, to the sum of v_total_time and the ITR_TIME of the new row, using the NVL function to handle cases where v_total_time is NULL by defaulting to 0. This ensures that the TOTAL_EXEC_TIME for the new row includes its own ITR_TIME in addition to the sum of all previous ITR_TIME values for the same EXPERIMENT_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_calculate_total_exec_time\nBEFORE INSERT ON EXECUTION_TIMES\nFOR EACH ROW\nDECLARE\n  v_total_time NUMBER;\nBEGIN\n  SELECT SUM(ITR_TIME) INTO v_total_time FROM EXECUTION_TIMES WHERE EXPERIMENT_ID = :NEW.EXPERIMENT_ID;\n  :NEW.TOTAL_EXEC_TIME := NVL(v_total_time, 0) + :NEW.ITR_TIME;\nEND;",
    "database_name": "reinforcement_letaa_93121",
    "tables": [
      "EXPERIMENTS",
      "EXPERIMENT_METRICS",
      "EXPERIMENT_PARAMETERS",
      "EXECUTION_TIMES",
      "EXPERIMENT_VERSIONS",
      "COMMENTS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO EXECUTION_TIMES (EXECUTION_ID, EXPERIMENT_ID, ITR_TIME, ITERATION_NUMBER) VALUES (0, 0, 10.7091, 1)",
      "INSERT INTO EXECUTION_TIMES (EXECUTION_ID, EXPERIMENT_ID, ITR_TIME, ITERATION_NUMBER) VALUES (1, 0, 5.0, 2)",
      "INSERT INTO EXECUTION_TIMES (EXECUTION_ID, EXPERIMENT_ID, ITR_TIME, ITERATION_NUMBER) VALUES (2, 1, 12.3, 1)",
      "INSERT INTO EXECUTION_TIMES (EXECUTION_ID, EXPERIMENT_ID, ITR_TIME, ITERATION_NUMBER) VALUES (3, 0, 7.5, 3)",
      "INSERT INTO EXECUTION_TIMES (EXECUTION_ID, EXPERIMENT_ID, ITR_TIME, ITERATION_NUMBER) VALUES (4, 1, 8.0, 2)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_calculate_total_exec_time that fires BEFORE INSERT on the EXECUTION_TIMES table for each new row, calculating the TOTAL_EXEC_TIME by adding the new row's ITR_TIME to the sum of all existing ITR_TIME values for the same EXPERIMENT_ID, defaulting the previous total to 0 if no existing rows are found.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_calculate_total_exec_time for the EXECUTION_TIMES table that runs before inserting a new record. For each new entry, it should calculate the TOTAL_EXEC_TIME by adding the new row's ITR_TIME to the sum of all existing ITR_TIME values for the same EXPERIMENT_ID in the EXECUTION_TIMES table; if no previous entries exist for that EXPERIMENT_ID, use zero for that sum.",
    "id": 8,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_calculate_total_exec_time that is executed before an insert operation on the EXECUTION_TIMES table for each row being inserted. The trigger declares a local variable v_total_time of type NUMBER to store the cumulative execution time. It performs a SELECT statement to calculate the sum of the ITR_TIME column from the EXECUTION_TIMES table where the EXPERIMENT_ID matches the EXPERIMENT_ID of the row being inserted, using the :NEW.EXPERIMENT_ID bind variable to reference the new row's EXPERIMENT_ID. The result of this sum is stored in the v_total_time variable. The trigger then assigns the TOTAL_EXEC_TIME column of the new row, referenced by :NEW.TOTAL_EXEC_TIME, to the sum of v_total_time and the ITR_TIME of the new row, using the NVL function to handle cases where v_total_time is NULL by defaulting to 0. This ensures that the TOTAL_EXEC_TIME for the new row includes its own ITR_TIME in addition to the sum of all previous ITR_TIME values for the same EXPERIMENT_ID.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_calculate_total_exec_time on the EXECUTION_TIMES table. For each new row, calculate the TOTAL_EXEC_TIME by summing the new row's ITR_TIME with the total of all existing ITR_TIME values for the same EXPERIMENT_ID (defaulting previous total to 0 if none exist).",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger called trg_calculate_total_exec_time for the EXECUTION_TIMES table that runs before adding a new entry. For each new record, it should figure out the TOTAL_EXEC_TIME. This is done by taking the new row's ITR_TIME and adding it to the combined total of all the other ITR_TIME values linked to the same EXPERIMENT_ID. If there aren't really any previous entries for that experiment, just treat that total as zero."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_patient_allergies that is automatically executed after a new row is inserted into the PATIENTS table for each affected row, and within its body, it performs a single INSERT operation into the PATIENT_ALLERGIES table, specifying values for the columns ALLERGY_ID, PATIENT_ID, ALLERGY_NAME, ALLERGY_TYPE, REACTION, CREATED_AT, and UPDATED_AT, where the ALLERGY_ID value is derived by executing a subquery that selects the maximum existing ALLERGY_ID from the PATIENT_ALLERGIES table, applies the NVL function to convert a potential NULL result to 0, and adds 1 to this result, the PATIENT_ID value is taken from the :NEW pseudorecord's PATIENT_ID column representing the newly inserted row in the PATIENTS table, the ALLERGY_NAME value is statically set to the string 'Peanuts', the ALLERGY_TYPE value is statically set to the string 'Food', the REACTION value is statically set to the string 'Anaphylaxis', and both the CREATED_AT and UPDATED_AT values are set to the current system date converted to a string in the 'YYYY-MM-DD' format using the TO_CHAR function with the SYSDATE function as its argument.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_patient_allergies\nAFTER INSERT ON PATIENTS\nFOR EACH ROW\nBEGIN\n  INSERT INTO PATIENT_ALLERGIES (ALLERGY_ID, PATIENT_ID, ALLERGY_NAME, ALLERGY_TYPE, REACTION, CREATED_AT, UPDATED_AT)\n  VALUES ((SELECT NVL(MAX(ALLERGY_ID), 0) + 1 FROM PATIENT_ALLERGIES), :NEW.PATIENT_ID, 'Peanuts', 'Food', 'Anaphylaxis', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\nEND;",
    "database_name": "medical_daph_monitoring",
    "tables": [
      "PATIENTS",
      "DIAGNOSES",
      "HEALTH_MONITORING",
      "PATIENT_ALLERGIES",
      "PATIENT_MEDICATIONS"
    ],
    "call_sqls": [
      "INSERT INTO PATIENTS (PATIENT_ID, FIRST_NAME, LAST_NAME, DATE_OF_BIRTH, GENDER, ADDRESS, CONTACT_NUMBER, EMERGENCY_CONTACT, MEDICAL_HISTORY, ALLERGIES, CURRENT_MEDICATIONS, SOCIAL_HISTORY, FAMILY_HISTORY, CREATED_AT, UPDATED_AT) VALUES (1, 'John', 'Doe', '1980-01-01', 'Male', '123 Main St', '555-1234', '555-5678', 'None', 'None', 'None', 'None', 'None', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'YYYY-MM-DD'))",
      "INSERT INTO PATIENTS (PATIENT_ID, FIRST_NAME, LAST_NAME, DATE_OF_BIRTH, GENDER, ADDRESS, CONTACT_NUMBER, EMERGENCY_CONTACT, MEDICAL_HISTORY, ALLERGIES, CURRENT_MEDICATIONS, SOCIAL_HISTORY, FAMILY_HISTORY, CREATED_AT, UPDATED_AT) VALUES (2, 'Jane', 'Smith', '1990-02-02', 'Female', '456 Elm St', '555-5678', '555-1234', 'Asthma', 'None', 'None', 'None', 'None', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'YYYY-MM-DD'))",
      "INSERT INTO PATIENTS (PATIENT_ID, FIRST_NAME, LAST_NAME, DATE_OF_BIRTH, GENDER, ADDRESS, CONTACT_NUMBER, EMERGENCY_CONTACT, MEDICAL_HISTORY, ALLERGIES, CURRENT_MEDICATIONS, SOCIAL_HISTORY, FAMILY_HISTORY, CREATED_AT, UPDATED_AT) VALUES (3, 'Alice', 'Johnson', '1975-03-03', 'Female', '789 Oak St', '555-6789', '555-9876', 'Diabetes', 'None', 'None', 'None', 'None', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'YYYY-MM-DD'))",
      "INSERT INTO PATIENTS (PATIENT_ID, FIRST_NAME, LAST_NAME, DATE_OF_BIRTH, GENDER, ADDRESS, CONTACT_NUMBER, EMERGENCY_CONTACT, MEDICAL_HISTORY, ALLERGIES, CURRENT_MEDICATIONS, SOCIAL_HISTORY, FAMILY_HISTORY, CREATED_AT, UPDATED_AT) VALUES (4, 'Bob', 'Brown', '1985-04-04', 'Male', '321 Pine St', '555-7890', '555-6543', 'Hypertension', 'None', 'None', 'None', 'None', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'YYYY-MM-DD'))",
      "INSERT INTO PATIENTS (PATIENT_ID, FIRST_NAME, LAST_NAME, DATE_OF_BIRTH, GENDER, ADDRESS, CONTACT_NUMBER, EMERGENCY_CONTACT, MEDICAL_HISTORY, ALLERGIES, CURRENT_MEDICATIONS, SOCIAL_HISTORY, FAMILY_HISTORY, CREATED_AT, UPDATED_AT) VALUES (5, 'Charlie', 'Davis', '2000-05-05', 'Male', '654 Maple St', '555-8901', '555-4321', 'None', 'None', 'None', 'None', 'None', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'YYYY-MM-DD'))"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_insert_patient_allergies that fires after each new row is inserted into the PATIENTS table, and for each insertion, it automatically adds a corresponding record to the PATIENT_ALLERGIES table. The trigger sets the ALLERGY_ID to the next available number (the highest existing ALLERGY_ID plus one, starting at 0 if no records exist), uses the newly inserted PATIENT_ID from PATIENTS, assigns 'Peanuts' as the ALLERGY_NAME, 'Food' as the ALLERGY_TYPE, 'Anaphylaxis' as the REACTION, and sets both CREATED_AT and UPDATED_AT to the current date in 'YYYY-MM-DD' format.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_insert_patient_allergies that, after each row is inserted into the PATIENTS table, automatically adds a new record to the PATIENT_ALLERGIES table, setting the ALLERGY_ID to one more than the highest existing ALLERGY_ID (or to 0 if there are no previous records), using the newly inserted PATIENT_ID, assigning 'Peanuts' as the ALLERGY_NAME, 'Food' as the ALLERGY_TYPE, 'Anaphylaxis' as the REACTION, and filling both CREATED_AT and UPDATED_AT with the current date in 'YYYY-MM-DD' format.",
    "id": 9,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_insert_patient_allergies that is executed automatically after a new row is inserted into the PATIENTS table. This trigger operates on each row that is inserted. The trigger's purpose is to insert a corresponding new record into the PATIENT_ALLERGIES table for every newly inserted patient. The trigger uses the :NEW pseudorecord to access the PATIENT_ID of the newly inserted patient row. It performs a SELECT operation on the PATIENT_ALLERGIES table to find the maximum existing value of the ALLERGY_ID column. This query uses the MAX aggregate function. If there are no existing records in the PATIENT_ALLERGIES table, the MAX function will return NULL. The trigger then uses the NVL function to handle this NULL value; if the result of the MAX(ALLERGY_ID) is NULL, it is converted to -1, and then 1 is added to this value, resulting in an ALLERGY_ID of 0. If a maximum value exists, 1 is added to that value to generate the new ALLERGY_ID. Following this calculation, the trigger performs an INSERT operation into the PATIENT_ALLERGIES table. The inserted record includes the following column values: the calculated ALLERGY_ID, the :NEW.PATIENT_ID from the trigger context, a static string 'Peanuts' for the ALLERGY_NAME column, a static string 'Food' for the ALLERGY_TYPE column, a static string 'Anaphylaxis' for the REACTION column, and both the CREATED_AT and UPDATED_AT columns are populated with the current system date formatted as 'YYYY-MM-DD' using the TO_CHAR function with the SYSDATE function. This ensures a default allergy entry is created for every new patient.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_insert_patient_allergies on the PATIENTS table. For each inserted row, insert a corresponding record into the PATIENT_ALLERGIES table. Set ALLERGY_ID to the maximum existing ALLERGY_ID plus 1 (defaulting to 0 if none exist), PATIENT_ID to the new PATIENT_ID, ALLERGY_NAME to 'Peanuts', ALLERGY_TYPE to 'Food', REACTION to 'Anaphylaxis', and both CREATED_AT and UPDATED_AT to the current date in 'YYYY-MM-DD' format.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER INSERT row-level trigger designated as trg_insert_patient_allergies for the PATIENTS table. Upon each row insertion, it is required to insert a corresponding record into the PATIENT_ALLERGIES table. The ALLERGY_ID should be assigned as the maximum existing ALLERGY_ID incremented by one, defaulting to 0 should no prior records exist. The PATIENT_ID must be set to the newly inserted PATIENT_ID. Furthermore, assign the ALLERGY_NAME as 'Peanuts', the ALLERGY_TYPE as 'Food', and the REACTION as 'Anaphylaxis'. Both the CREATED_AT and UPDATED_AT timestamps should be populated with the current date, formatted as 'YYYY-MM-DD'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_model_version that is defined to fire automatically after a new row is inserted into the MODELS table, executing once for each inserted row, and within its execution block, it first declares a local variable v_version_id of type NUMBER, then performs a SELECT query on the MODEL_VERSIONS table to calculate the next version identifier by finding the maximum existing value in the VERSION_ID column, using the NVL function to substitute a 0 if the column contains only NULLs, and adding 1 to that result, storing the outcome into the v_version_id variable, and subsequently performs an INSERT operation into the MODEL_VERSIONS table, populating the columns VERSION_ID with the calculated v_version_id, MODEL_ID with the newly inserted MODEL_ID value from the MODELS table (accessed via the :NEW.MODEL_ID trigger pseudorecord), VERSION_NUMBER with the literal number 1, DESCRIPTION with the literal string 'Initial version', CREATED_AT with the current system date and time formatted as a string in 'YYYY-MM-DD HH24:MI:SS' format using the TO_CHAR and SYSDATE functions, UPDATED_AT with the same formatted current date and time string, VERSION_DESCRIPTION with the literal string 'Initial version with default hyperparameters', and PARENT_VERSION with a NULL value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_model_version\nAFTER INSERT ON MODELS\nFOR EACH ROW\nDECLARE\n    v_version_id NUMBER;\nBEGIN\n    -- Generate a new VERSION_ID using a sequence or logic\n    SELECT NVL(MAX(VERSION_ID), 0) + 1 INTO v_version_id FROM MODEL_VERSIONS;\n    \n    INSERT INTO MODEL_VERSIONS (\n        VERSION_ID,\n        MODEL_ID,\n        VERSION_NUMBER,\n        DESCRIPTION,\n        CREATED_AT,\n        UPDATED_AT,\n        VERSION_DESCRIPTION,\n        PARENT_VERSION\n    ) VALUES (\n        v_version_id,\n        :NEW.MODEL_ID,\n        1,\n        'Initial version',\n        TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'),\n        TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'),\n        'Initial version with default hyperparameters',\n        NULL\n    );\nEND;",
    "database_name": "machine_lmtae_720211",
    "tables": [
      "MODELS",
      "MODEL_VERSIONS"
    ],
    "call_sqls": [
      "INSERT INTO MODELS (MODEL_ID, MODEL_NAME, MODEL_TYPE, DESCRIPTION, CREATED_AT, UPDATED_AT, TRAINED_BY, HYPERPARAMETERS) VALUES (100, 'New Neural Network', 'classification', 'Image classification model', '2024-01-15 10:30:00', '2024-01-15 10:30:00', 5, '{learning_rate: 0.005}')",
      "INSERT INTO MODELS (MODEL_ID, MODEL_NAME, MODEL_TYPE, DESCRIPTION, CREATED_AT, UPDATED_AT, TRAINED_BY, HYPERPARAMETERS) VALUES (101, 'Sales Predictor', 'regression', 'Quarterly sales forecasting', '2024-01-15 11:00:00', '2024-01-15 11:00:00', 3, '{epochs: 100}')",
      "INSERT INTO MODELS (MODEL_ID, MODEL_NAME, MODEL_TYPE, DESCRIPTION, CREATED_AT, UPDATED_AT, TRAINED_BY, HYPERPARAMETERS) VALUES (102, 'Fraud Detector', 'classification', 'Credit card fraud detection', '2024-01-15 12:00:00', '2024-01-15 12:00:00', 7, '{layers: 3}')",
      "INSERT INTO MODELS (MODEL_ID, MODEL_NAME, MODEL_TYPE, DESCRIPTION, CREATED_AT, UPDATED_AT, TRAINED_BY, HYPERPARAMETERS) VALUES (103, 'Price Optimizer', 'regression', 'Dynamic pricing model', '2024-01-15 14:30:00', '2024-01-15 14:30:00', 2, '{batch_size: 64}')",
      "INSERT INTO MODELS (MODEL_ID, MODEL_NAME, MODEL_TYPE, DESCRIPTION, CREATED_AT, UPDATED_AT, TRAINED_BY, HYPERPARAMETERS) VALUES (104, 'Churn Predictor', 'classification', 'Customer churn prediction', '2024-01-15 16:45:00', '2024-01-15 16:45:00', 4, '{dropout: 0.2}')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_insert_model_version that fires after each new row is inserted into the MODELS table. For each new model, it automatically creates an initial version record in the MODEL_VERSIONS table by generating a new VERSION_ID as the next available number (the highest existing VERSION_ID plus one, starting from 0 if none exist), setting the VERSION_NUMBER to 1, using 'Initial version' for DESCRIPTION, capturing the current timestamp for both CREATED_AT and UPDATED_AT, setting VERSION_DESCRIPTION to 'Initial version with default hyperparameters', and leaving PARENT_VERSION as NULL.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_insert_model_version that fires after a new row is inserted into the MODELS table, and for each new row, it automatically creates a corresponding initial version record in the MODEL_VERSIONS table by generating the next VERSION_ID (incrementing the highest existing VERSION_ID from MODEL_VERSIONS by 1, or starting at 0 if none exist), using the new MODEL_ID, setting VERSION_NUMBER to 1, DESCRIPTION to 'Initial version', CREATED_AT and UPDATED_AT to the current date and time, VERSION_DESCRIPTION to 'Initial version with default hyperparameters', and leaving PARENT_VERSION as NULL.",
    "id": 10,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_insert_model_version that is defined to fire automatically after a new row is inserted into the MODELS table, executing once for each inserted row, and within its execution block, it first declares a local variable v_version_id of type NUMBER, then performs a SELECT query on the MODEL_VERSIONS table to calculate the next version identifier by finding the maximum existing value in the VERSION_ID column, using the NVL function to substitute a 0 if the column contains only NULLs, and adding 1 to that result, storing the outcome into the v_version_id variable, and subsequently performs an INSERT operation into the MODEL_VERSIONS table, populating the columns VERSION_ID with the calculated v_version_id, MODEL_ID with the newly inserted MODEL_ID value from the MODELS table (accessed via the :NEW.MODEL_ID trigger pseudorecord), VERSION_NUMBER with the literal number 1, DESCRIPTION with the literal string 'Initial version', CREATED_AT with the current system date and time formatted as a string in 'YYYY-MM-DD HH24:MI:SS' format using the TO_CHAR and SYSDATE functions, UPDATED_AT with the same formatted current date and time string, VERSION_DESCRIPTION with the literal string 'Initial version with default hyperparameters', and PARENT_VERSION with a NULL value.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_insert_model_version on the MODELS table. It calculates the next VERSION_ID for MODEL_VERSIONS by finding the maximum existing value plus one (defaulting to 0), then inserts a new row into MODEL_VERSIONS with this ID, the new MODEL_ID, version number 1, description 'Initial version', the current timestamp for CREATED_AT and UPDATED_AT, version description 'Initial version with default hyperparameters', and a NULL PARENT_VERSION.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires after a new row is added to the MODELS table. Let's call it trg_insert_model_version. What it should do is: figure out the next VERSION_ID for the MODEL_VERSIONS table by taking the highest current ID and adding 1 to it (if there's none, just start at 0). Then, it pops a fresh row into MODEL_VERSIONS with that new ID, grabs the new MODEL_ID, sets the version number to 1, slaps in 'Initial version' as the description, uses the current date and time for both CREATED_AT and UPDATED_AT, puts 'Initial version with default hyperparameters' for the version description, and leaves PARENT_VERSION as NULL."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_DEL_TEST_CASE_STEPS` that is activated `AFTER` a `DELETE` operation occurs on the `TEST_CASE_STEPS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every individual row that is deleted from the `TEST_CASE_STEPS` table. Upon activation, for each deleted row, the trigger performs an `UPDATE` operation on the `TEST_CASES` table. Specifically, it modifies the `STABILITY` column in the `TEST_CASES` table by decrementing its current value by `1`. This `UPDATE` operation is conditional, applying only to those rows in the `TEST_CASES` table where the value in the `TEST_CASE_ID` column matches the value of the `TEST_CASE_ID` column from the row that was just deleted from the `TEST_CASE_STEPS` table. The `:OLD.TEST_CASE_ID` refers to the value of the `TEST_CASE_ID` column in the row that existed in the `TEST_CASE_STEPS` table immediately before it was deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_DEL_TEST_CASE_STEPS\nAFTER DELETE ON TEST_CASE_STEPS\nFOR EACH ROW\nBEGIN\n    UPDATE TEST_CASES SET STABILITY = STABILITY - 1 WHERE TEST_CASE_ID = :OLD.TEST_CASE_ID;\nEND;",
    "database_name": "software_taqam_71174",
    "tables": [
      "TEST_CASES",
      "TEST_CASE_STEPS",
      "TEST_CASE_ACTUAL_RESULTS",
      "TEST_RESULTS"
    ],
    "call_sqls": [
      "DELETE FROM TEST_CASE_STEPS WHERE STEP_ID = 0",
      "DELETE FROM TEST_CASE_STEPS WHERE STEP_ID = 1",
      "DELETE FROM TEST_CASE_STEPS WHERE STEP_ID = 2",
      "DELETE FROM TEST_CASE_STEPS WHERE STEP_ID = 3",
      "DELETE FROM TEST_CASE_STEPS WHERE STEP_ID = 4"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_DEL_TEST_CASE_STEPS that fires AFTER DELETE on the TEST_CASE_STEPS table for each deleted row, and for each deletion, updates the TEST_CASES table by decrementing the STABILITY column by 1 for the row where TEST_CASE_ID matches the TEST_CASE_ID from the deleted step.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_DEL_TEST_CASE_STEPS that runs after a row is deleted from the TEST_CASE_STEPS table, and for each deleted row, reduces the STABILITY value by one in the TEST_CASES table for the matching TEST_CASE_ID from the deleted step.",
    "id": 11,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_DEL_TEST_CASE_STEPS` that is activated `AFTER` a `DELETE` operation occurs on the `TEST_CASE_STEPS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row being deleted from the `TEST_CASE_STEPS` table. Upon activation, the trigger performs an `UPDATE` operation on the `TEST_CASES` table. The `UPDATE` statement targets a specific row in the `TEST_CASES` table where the `TEST_CASE_ID` column value equals the `TEST_CASE_ID` column value from the row that was just deleted from the `TEST_CASE_STEPS` table. This deleted row's `TEST_CASE_ID` value is accessed via the `:OLD` pseudorecord. The `UPDATE` operation modifies the `STABILITY` column in the `TEST_CASES` table by decreasing its current value by exactly one. This is achieved by setting the new `STABILITY` value to the result of the expression `STABILITY - 1`. The trigger concludes its execution for the current row after performing this single `UPDATE` statement.",
    "original_summary": "Create a trigger named TRG_DEL_TEST_CASE_STEPS that fires AFTER DELETE on TEST_CASE_STEPS for each row. For every deleted row, update the TEST_CASES table. Decrement the STABILITY column by 1 for the row in TEST_CASES where its TEST_CASE_ID matches the :OLD.TEST_CASE_ID from the deleted step.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger called TRG_DEL_TEST_CASE_STEPS to run after something gets removed from TEST_CASE_STEPS. Whenever a row is taken out, you should adjust the related record in TEST_CASES. Find the matching TEST_CASE_ID from the old step data and then lower the STABILITY value by a bit, say one, for that particular test case."
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT OR UPDATE` row-level trigger named `trg_enforce_user_email` on the `USERS` table. This trigger is activated for each row immediately before an `INSERT` operation or an `UPDATE` operation is performed on the `USERS` table. Upon activation, the trigger declares two local PL/SQL variables: `v_email_length` of type `NUMBER` to store the length of the email address, and `v_at_position` of type `NUMBER` to store the starting position of the '@' character within the email address. The trigger then proceeds to calculate the length of the `EMAIL` column value for the row currently being inserted or updated (referred to as `:NEW.EMAIL`) using the `LENGTH` built-in SQL function, and assigns this calculated length to the `v_email_length` variable. Subsequently, it determines the starting position of the '@' character within the `:NEW.EMAIL` value using the `INSTR` built-in SQL function, and assigns this position to the `v_at_position` variable. Following these calculations, the trigger evaluates a conditional `IF` statement. The first condition checks if the `v_email_length` is less than 5. If this condition is true, the trigger immediately raises an application error with the error number -20003 and the error message 'Email too short', preventing the `INSERT` or `UPDATE` operation from completing. If the first condition is false, the trigger proceeds to an `ELSIF` condition which checks if `v_at_position` is equal to 0. If this second condition is true, meaning the '@' character was not found in the email address, the trigger raises an application error with the error number -20004 and the error message 'Email must contain @', also preventing the `INSERT` or `UPDATE` operation. If neither of the `IF` or `ELSIF` conditions are met, indicating that the email address is at least 5 characters long and contains an '@' symbol, the trigger then converts the value of the `:NEW.EMAIL` column to its lowercase equivalent using the `LOWER` built-in SQL function and assigns this lowercase value back to the `:NEW.EMAIL` column. This modification ensures that the email address is stored in a consistent lowercase format in the `USERS` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_enforce_user_email\nBEFORE INSERT OR UPDATE ON USERS\nFOR EACH ROW\nDECLARE\n    v_email_length NUMBER;\n    v_at_position NUMBER;\nBEGIN\n    v_email_length := LENGTH(:NEW.EMAIL);\n    v_at_position := INSTR(:NEW.EMAIL, '@');\n    IF v_email_length < 5 THEN\n        RAISE_APPLICATION_ERROR(-20003, 'Email too short');\n    ELSIF v_at_position = 0 THEN\n        RAISE_APPLICATION_ERROR(-20004, 'Email must contain @');\n    END IF;\n    :NEW.EMAIL := LOWER(:NEW.EMAIL);\nEND;",
    "database_name": "biomedical_rad_management",
    "tables": [
      "DATASETS",
      "DATASET_DETAILS",
      "DONORS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, INSTITUTION, DEPARTMENT, LAB_NAME) VALUES (100, 'Test User', 'a@b.c', 'researcher', 'Test Uni', 'Test Dept', 'Test Lab')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, INSTITUTION, DEPARTMENT, LAB_NAME) VALUES (101, 'Jane Doe', 'jane.doe@example.org', 'analyst', 'Harvard', 'CS', 'AI Lab')",
      "UPDATE USERS SET EMAIL = 'NEW.EMAIL@DOMAIN.COM' WHERE USER_ID = 0",
      "UPDATE USERS SET EMAIL = 'short' WHERE USER_ID = 1",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, INSTITUTION) VALUES (102, 'Bad Email', 'noatsign.com', 'guest', 'Somewhere')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_enforce_user_email that fires BEFORE INSERT OR UPDATE on the USERS table for each row, ensuring the EMAIL value meets business rules: it must be at least 5 characters long and contain an '@' symbol, otherwise raising specific errors, and then converting the EMAIL to lowercase.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_enforce_user_email that activates before any insert or update on the USERS table to validate and format the email address. For each row, it must check if the provided email in the EMAIL field is at least five characters long; if not, raise an error 'Email too short'. It must also verify that the email contains an '@' symbol; if missing, raise an error 'Email must contain @'. If both validations pass, convert the EMAIL value to lowercase.",
    "id": 12,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT OR UPDATE` row-level trigger named `trg_enforce_user_email` on the `USERS` table. This trigger is activated for each row immediately before an `INSERT` operation or an `UPDATE` operation is performed on the `USERS` table. Upon activation, the trigger declares two local PL/SQL variables: `v_email_length` of type `NUMBER` to store the length of the email address, and `v_at_position` of type `NUMBER` to store the starting position of the '@' character within the email address. The trigger then proceeds to calculate the length of the `EMAIL` column value for the row currently being inserted or updated (referred to as `:NEW.EMAIL`) using the `LENGTH` built-in SQL function, and assigns this calculated length to the `v_email_length` variable. Subsequently, it determines the starting position of the '@' character within the `:NEW.EMAIL` value using the `INSTR` built-in SQL function, and assigns this position to the `v_at_position` variable. Following these calculations, the trigger evaluates a conditional `IF` statement. The first condition checks if the `v_email_length` is less than 5. If this condition is true, the trigger immediately raises an application error with the error number -20003 and the error message 'Email too short', preventing the `INSERT` or `UPDATE` operation from completing. If the first condition is false, the trigger proceeds to an `ELSIF` condition which checks if `v_at_position` is equal to 0. If this second condition is true, meaning the '@' character was not found in the email address, the trigger raises an application error with the error number -20004 and the error message 'Email must contain @', also preventing the `INSERT` or `UPDATE` operation. If neither of the `IF` or `ELSIF` conditions are met, indicating that the email address is at least 5 characters long and contains an '@' symbol, the trigger then converts the value of the `:NEW.EMAIL` column to its lowercase equivalent using the `LOWER` built-in SQL function and assigns this lowercase value back to the `:NEW.EMAIL` column. This modification ensures that the email address is stored in a consistent lowercase format in the `USERS` table.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_enforce_user_email on the USERS table. For each row, calculate the email length and the position of '@'. If length < 5, raise error 'Email too short'. If '@' not found, raise error 'Email must contain @'. Otherwise, convert :NEW.EMAIL to lowercase.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Develop a row-level trigger called trg_enforce_user_email, which is designed to activate before any insert or update operation on the USERS table. For every individual row being processed, the trigger must meticulously compute the total length of the provided email address and precisely determine the location of the '@' symbol within it. Should the calculated length be disappointingly less than five characters, the trigger must promptly raise a specific application error with the detailed message 'Email too short'. Alternatively, if the crucial '@' symbol is completely absent and cannot be found, it must instead raise a distinct error stating clearly that 'Email must contain @'. Only when both of these thorough validations are successfully passed should the trigger proceed to gracefully convert the value in the :NEW.EMAIL field entirely to lowercase letters."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_class_room that is defined to execute before any insert or update operation on the CLASSES table for each affected row, and within its execution block, it performs a conditional check on the new value of the CLASS_ROOM column, referenced as :NEW.CLASS_ROOM, to determine if it is null, and if this condition evaluates to true, the trigger invokes the RAISE_APPLICATION_ERROR built-in procedure with an error number argument of -20004 and an error message argument of 'Class room cannot be null.', which immediately terminates the triggering statement and raises an exception.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_class_room\nBEFORE INSERT OR UPDATE ON CLASSES\nFOR EACH ROW\nBEGIN\n  IF :NEW.CLASS_ROOM IS NULL THEN\n    RAISE_APPLICATION_ERROR(-20004, 'Class room cannot be null.');\n  END IF;\nEND;",
    "database_name": "educational_aaspt_766875",
    "tables": [
      "ASSESSMENTS",
      "ASSESSMENT_FORMS",
      "ASSESSMENT_QUESTIONS",
      "CLASSES",
      "STUDENTS",
      "TEACHERS"
    ],
    "call_sqls": [
      "INSERT INTO CLASSES (CLASS_ID, CLASS_NAME, TEACHER_ID, SCHOOL_ID, CLASS_DESCRIPTION, CLASS_ROOM) VALUES (100, 'Test Class', 1, 1, 'A test class', 'Room 201')",
      "INSERT INTO CLASSES (CLASS_ID, CLASS_NAME, TEACHER_ID, SCHOOL_ID, CLASS_DESCRIPTION) VALUES (101, 'Invalid Class', 1, 1, 'A class with no room')",
      "UPDATE CLASSES SET CLASS_ROOM = 'Room 301' WHERE CLASS_ID = 0",
      "UPDATE CLASSES SET CLASS_ROOM = NULL WHERE CLASS_ID = 1",
      "INSERT INTO CLASSES (CLASS_ID, CLASS_NAME, TEACHER_ID, SCHOOL_ID, CLASS_DESCRIPTION, CLASS_ROOM) VALUES (102, 'Another Test', 0, 1, 'Description', 'Lab 5')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_check_class_room that fires BEFORE INSERT OR UPDATE on the CLASSES table for each row, ensuring that the CLASS_ROOM value is never set to NULL by raising an error with the message 'Class room cannot be null.' if it is.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_check_class_room on the CLASSES table that fires BEFORE INSERT OR UPDATE FOR EACH ROW to ensure that the CLASS_ROOM value is never null, raising an application error with the message 'Class room cannot be null.' if it is.",
    "id": 13,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_check_class_room that is defined to execute before any insert or update operation on the CLASSES table for each affected row, and within its execution block, it performs a conditional check on the new value of the CLASS_ROOM column, referenced as :NEW.CLASS_ROOM, to determine if it is null, and if this condition evaluates to true, the trigger invokes the RAISE_APPLICATION_ERROR built-in procedure with an error number argument of -20004 and an error message argument of 'Class room cannot be null.', which immediately terminates the triggering statement and raises an exception.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_check_class_room on the CLASSES table. For each new or updated row, if :NEW.CLASS_ROOM is NULL, raise application error -20004 with message 'Class room cannot be null.'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a trigger named trg_check_class_room on the CLASSES table that fires BEFORE INSERT OR UPDATE FOR EACH ROW. For every new or updated row, check if the CLASS_ROOM value is NULL. If it is, raise an application error -20004 with the message 'Class room cannot be null.'."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_error_margin` that is activated `BEFORE` any `INSERT` or `UPDATE` operation occurs on the `PREDICTIONS` table. This trigger is defined to execute `FOR EACH ROW` affected by the `INSERT` or `UPDATE` statement, meaning its logic will be applied individually to each new or modified row.\n\nUpon activation for a specific row, the trigger first declares a local variable named `v_accuracy` of data type `NUMBER`. It then proceeds to execute a `SELECT` statement to retrieve the `ACCURACY` column value from the `PREDICTION_MODELS` table. This retrieved `ACCURACY` value is stored into the `v_accuracy` variable. The `SELECT` statement includes a `WHERE` clause that filters the `PREDICTION_MODELS` table, ensuring that only the row where the `MODEL_ID` column matches the `MODEL_ID` value of the `NEW` row being inserted or updated in the `PREDICTIONS` table (referenced as `:NEW.MODEL_ID`) is considered.\n\nFollowing the retrieval of `v_accuracy`, the trigger enters a conditional block (`IF-ELSIF-ELSE`) to determine how to modify the `ERROR_MARGIN` column of the `NEW` row (`:NEW.ERROR_MARGIN`).\n\nThe first condition checks if the `v_accuracy` variable is less than `0.8`. If this condition evaluates to `TRUE`, the `ERROR_MARGIN` of the `NEW` row (`:NEW.ERROR_MARGIN`) is updated by multiplying its current value by `1.1`.\n\nIf the first condition (`v_accuracy < 0.8`) evaluates to `FALSE`, the trigger proceeds to the `ELSIF` condition. This condition checks if the `CONFIDENCE` column value of the `NEW` row (`:NEW.CONFIDENCE`) is less than `0.6`. If this `ELSIF` condition evaluates to `TRUE`, the `ERROR_MARGIN` of the `NEW` row (`:NEW.ERROR_MARGIN`) is updated by multiplying its current value by `1.2`.\n\nIf both the `IF` and `ELSIF` conditions evaluate to `FALSE`, the trigger executes the `ELSE` block. In this case, the `ERROR_MARGIN` of the `NEW` row (`:NEW.ERROR_MARGIN`) is updated by multiplying its current value by `0.9`.\n\nAfter one of these conditional updates to `:NEW.ERROR_MARGIN` is performed, the trigger's execution for that specific row concludes. The modified `:NEW.ERROR_MARGIN` value will then be used as the actual `ERROR_MARGIN` value for the `PREDICTIONS` table row being inserted or updated.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_error_margin\nBEFORE INSERT OR UPDATE ON PREDICTIONS\nFOR EACH ROW\nDECLARE\n  v_accuracy NUMBER;\nBEGIN\n  SELECT ACCURACY INTO v_accuracy\n  FROM PREDICTION_MODELS\n  WHERE MODEL_ID = :NEW.MODEL_ID;\n\n  IF v_accuracy < 0.8 THEN\n    :NEW.ERROR_MARGIN := :NEW.ERROR_MARGIN * 1.1;\n  ELSIF :NEW.CONFIDENCE < 0.6 THEN\n    :NEW.ERROR_MARGIN := :NEW.ERROR_MARGIN * 1.2;\n  ELSE\n    :NEW.ERROR_MARGIN := :NEW.ERROR_MARGIN * 0.9;\n  END IF;\nEND;",
    "database_name": "weather_oaf_92747",
    "tables": [
      "PREDICTIONS",
      "PREDICTION_MODELS"
    ],
    "call_sqls": [
      "INSERT INTO PREDICTIONS (PREDICTION_ID, MODEL_ID, STATION_ID, EST, PREDICTED_CONDITION_ID, CONFIDENCE, ACTUAL_CONDITION_ID, ERROR_MARGIN, ALERT_STATUS) \nVALUES (2, 0, 0, '1993-1-3', 1, 0.7, 1, 0.05, 'inactive')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, MODEL_ID, STATION_ID, EST, PREDICTED_CONDITION_ID, CONFIDENCE, ACTUAL_CONDITION_ID, ERROR_MARGIN, ALERT_STATUS) \nVALUES (3, 1, 1, '1993-1-4', 0, 0.5, 0, 0.1, 'active')",
      "UPDATE PREDICTIONS \nSET CONFIDENCE = 0.55, ERROR_MARGIN = 0.08 \nWHERE PREDICTION_ID = 0",
      "UPDATE PREDICTIONS \nSET CONFIDENCE = 0.75, ERROR_MARGIN = 0.07 \nWHERE PREDICTION_ID = 1",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, MODEL_ID, STATION_ID, EST, PREDICTED_CONDITION_ID, CONFIDENCE, ACTUAL_CONDITION_ID, ERROR_MARGIN, ALERT_STATUS) \nVALUES (4, 0, 1, '1993-1-5', 1, 0.65, 1, 0.09, 'inactive')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_error_margin that fires before each row is inserted or updated in the PREDICTIONS table, and adjusts the ERROR_MARGIN based on business rules: first, retrieve the ACCURACY from the PREDICTION_MODELS table for the MODEL_ID being inserted or updated; if that ACCURACY is less than 0.8, increase the new ERROR_MARGIN by 10%; otherwise, if the new CONFIDENCE value is less than 0.6, increase the new ERROR_MARGIN by 20%; in all other cases, decrease the new ERROR_MARGIN by 10%.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_error_margin on the PREDICTIONS table that fires BEFORE INSERT OR UPDATE for each row, adjusting the new row's ERROR_MARGIN based on business rules: retrieve the ACCURACY from the PREDICTION_MODELS table where MODEL_ID matches the new row's MODEL_ID; if that accuracy is less than 0.8, multiply the new row's ERROR_MARGIN by 1.1; otherwise, if the new row's CONFIDENCE is less than 0.6, multiply its ERROR_MARGIN by 1.2; in all other cases, multiply the new row's ERROR_MARGIN by 0.9.",
    "id": 14,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_error_margin that executes before each insert or update operation on the PREDICTIONS table for each row. The trigger automatically adjusts the value of the ERROR_MARGIN column in the new row being inserted or updated based on specific business rules. Upon activation, the trigger first retrieves the ACCURACY value from the PREDICTION_MODELS table by executing a SELECT statement that queries the ACCURACY column from the PREDICTION_MODELS table where the MODEL_ID column matches the MODEL_ID value of the new row in the PREDICTIONS table, referenced as :NEW.MODEL_ID. This SELECT statement is performed using an implicit cursor, fetching the ACCURACY value into a local variable. If the retrieved ACCURACY value is less than 0.8, the trigger multiplies the new row's ERROR_MARGIN value (referenced as :NEW.ERROR_MARGIN) by 1.1, updating :NEW.ERROR_MARGIN to this new calculated value. Otherwise, if the ACCURACY is 0.8 or greater, the trigger evaluates a second condition: it checks if the new row's CONFIDENCE value (referenced as :NEW.CONFIDENCE) is less than 0.6. If this condition is true, the trigger multiplies :NEW.ERROR_MARGIN by 1.2, updating :NEW.ERROR_MARGIN accordingly. In all other cases, meaning the ACCURACY is 0.8 or greater and the CONFIDENCE is 0.6 or greater, the trigger multiplies :NEW.ERROR_MARGIN by 0.9, updating :NEW.ERROR_MARGIN to this reduced value. The trigger uses the :NEW qualifier to reference and modify the column values of the row being inserted or updated in the PREDICTIONS table.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_update_error_margin on the PREDICTIONS table. For each row, retrieve the ACCURACY from PREDICTION_MODELS where MODEL_ID matches :NEW.MODEL_ID. If accuracy < 0.8, set :NEW.ERROR_MARGIN = :NEW.ERROR_MARGIN * 1.1. Else if :NEW.CONFIDENCE < 0.6, set :NEW.ERROR_MARGIN = :NEW.ERROR_MARGIN * 1.2. Otherwise, set :NEW.ERROR_MARGIN = :NEW.ERROR_MARGIN * 0.9.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a row-level trigger named trg_update_error_margin on the PREDICTIONS table that fires BEFORE INSERT OR UPDATE. For each new row, fetch the ACCURACY from the PREDICTION_MODELS table where the MODEL_ID matches the new row's MODEL_ID. If the fetched accuracy is less than 0.8, multiply the new row's ERROR_MARGIN by 1.1. Otherwise, if the new row's CONFIDENCE is less than 0.6, multiply its ERROR_MARGIN by 1.2. In all other cases, multiply the new row's ERROR_MARGIN by 0.9."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_user_activity_insert that is executed automatically after a new row is inserted into the USER_ACTIVITY table. This trigger operates on each row that is inserted. The trigger performs an insert operation into the USER_SERVER_SYNC table, specifically inserting values into the columns SYNC_ID, USER_ID, SERVER_ID, and SYNC_TS. The value for SYNC_ID is taken from the STREAM_ID column of the newly inserted row in the USER_ACTIVITY table, accessed using the :NEW pseudorecord. The USER_ID column in USER_SERVER_SYNC is populated with the USER_ID from the newly inserted row in USER_ACTIVITY, also accessed via the :NEW pseudorecord. The SERVER_ID column is assigned a constant value of 1. The SYNC_TS column is populated with the current system date and time, formatted as a string in the 'YYYYMMDDHH24MISS' format using the TO_CHAR function applied to the SYSDATE function, which retrieves the current date and time from the system.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_user_activity_insert\nAFTER INSERT ON USER_ACTIVITY\nFOR EACH ROW\nBEGIN\n    INSERT INTO USER_SERVER_SYNC (SYNC_ID, USER_ID, SERVER_ID, SYNC_TS)\n    VALUES (:NEW.STREAM_ID, :NEW.USER_ID, 1, TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'));\nEND;",
    "database_name": "user_aas_tracking",
    "tables": [
      "SERVER_INFO",
      "USER_ACTIVITY",
      "USER_SERVER_SYNC",
      "USER_STATUS"
    ],
    "call_sqls": [
      "INSERT INTO USER_ACTIVITY (STREAM_ID, USER_ID, STATE, LAST_ACTIVE_TS) VALUES (100, '@testuser:server.com', 'online', '20240101120000')",
      "INSERT INTO USER_ACTIVITY (STREAM_ID, USER_ID, STATE, LAST_ACTIVE_TS, DEVICE_INFO) VALUES (101, '@alice:matrix.org', 'away', '20240101120001', 'iPhone, Safari')",
      "INSERT INTO USER_ACTIVITY (STREAM_ID, USER_ID, STATE, LAST_ACTIVE_TS, LOCATION, IP_ADDRESS) VALUES (102, '@bob:example.com', 'offline', '20240101120002', 'Paris', '10.0.0.1')",
      "INSERT INTO USER_ACTIVITY (STREAM_ID, USER_ID, STATE, LAST_ACTIVE_TS, CURRENTLY_ACTIVE, SESSION_ID) VALUES (103, '@charlie:test.net', 'online', '20240101120003', 1, 'sess_abc123')",
      "INSERT INTO USER_ACTIVITY (STREAM_ID, USER_ID, STATE, LAST_ACTIVE_TS, LOGIN_METHOD, STATUS_MSG) VALUES (104, '@dana:local.host', 'dnd', '20240101120004', 'email', 'In a meeting')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_user_activity_insert that fires after each new row is inserted into the USER_ACTIVITY table, and for each insertion, it adds a corresponding record to the USER_SERVER_SYNC table. The trigger populates SYNC_ID with the new STREAM_ID from USER_ACTIVITY, USER_ID with the new USER_ID from USER_ACTIVITY, SERVER_ID with the constant value 1, and SYNC_TS with the current system timestamp formatted as 'YYYYMMDDHH24MISS'.",
    "natural_language": "Hey, write a Oracle PL/SQL trigger named trg_user_activity_insert that fires after a new row is inserted into the USER_ACTIVITY table. For each new entry, it should automatically create a corresponding record in the USER_SERVER_SYNC table by copying the new STREAM_ID into SYNC_ID, the new USER_ID into USER_ID, setting SERVER_ID to 1, and using the current system time formatted as 'YYYYMMDDHH24MISS' for SYNC_TS.",
    "id": 15,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_user_activity_insert that is executed automatically after a new row is inserted into the USER_ACTIVITY table. This trigger operates on each row that is inserted. The trigger performs an insert operation into the USER_SERVER_SYNC table, specifically inserting values into the columns SYNC_ID, USER_ID, SERVER_ID, and SYNC_TS. The value for SYNC_ID is taken from the STREAM_ID column of the newly inserted row in the USER_ACTIVITY table, accessed using the :NEW pseudorecord. The USER_ID column in USER_SERVER_SYNC is populated with the USER_ID from the newly inserted row in USER_ACTIVITY, also accessed via the :NEW pseudorecord. The SERVER_ID column is assigned a constant value of 1. The SYNC_TS column is populated with the current system date and time, formatted as a string in the 'YYYYMMDDHH24MISS' format using the TO_CHAR function applied to the SYSDATE function, which retrieves the current date and time from the system.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_user_activity_insert on the USER_ACTIVITY table. For each new row, insert a corresponding record into the USER_SERVER_SYNC table. Populate SYNC_ID with the new STREAM_ID, USER_ID with the new USER_ID, SERVER_ID with the constant 1, and SYNC_TS with the current system timestamp formatted as 'YYYYMMDDHH24MISS'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, set up a trigger called trg_user_activity_insert that fires after a new row is added to the USER_ACTIVITY table. For each fresh entry, it should automatically add a matching record to the USER_SERVER_SYNC table. Just copy the new STREAM_ID into SYNC_ID, the new USER_ID into USER_ID, stick the number 1 into SERVER_ID, and for SYNC_TS, grab the current system time and format it like 'YYYYMMDDHH24MISS'."
  },
  {
    "ir": "Write an Oracle PL/SQL AFTER INSERT OR DELETE row-level trigger named `trg_sizes_measurement_count` that automatically executes after an `INSERT` operation or a `DELETE` operation occurs on the `MEASUREMENTS` table. This trigger declares two local PL/SQL variables: `v_total_measurements` of type `NUMBER` and `v_next_update_id` of type `NUMBER`. Upon activation, the trigger first executes a `SELECT` statement to count the total number of rows currently present in the `MEASUREMENTS` table and stores this count into the `v_total_measurements` variable. Subsequently, it executes another `SELECT` statement to determine the next available `UPDATE_ID` for the `SIZE_UPDATES` table. This is achieved by selecting the maximum value from the `UPDATE_ID` column in the `SIZE_UPDATES` table, applying the `NVL` function to treat a `NULL` result (indicating an empty table) as `0`, and then adding `1` to this result to ensure a unique, incrementing `UPDATE_ID`. This calculated value is stored in the `v_next_update_id` variable. Finally, the trigger performs an `INSERT` operation into the `SIZE_UPDATES` table. The `UPDATE_ID` column is populated with the value from `v_next_update_id`. The `MEASUREMENT_ID` column is set to `NULL`. The `UPDATE_DATE` column is populated with the current system date formatted as 'YYYY-MM-DD' using the `TO_CHAR` function with `SYSDATE`. The `UPDATED_BY` column is set to the numeric literal `0`. The `UPDATE_REASON` column is set to the string literal `'COUNT_UPDATE'`. The `UPDATE_DESCRIPTION` column is constructed by concatenating the string literal `'Total measurements: '` with the current value of the `v_total_measurements` variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sizes_measurement_count\nAFTER INSERT OR DELETE ON MEASUREMENTS\nDECLARE\n    v_total_measurements NUMBER;\n    v_next_update_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_measurements FROM MEASUREMENTS;\n    \n    SELECT NVL(MAX(UPDATE_ID), 0) + 1 INTO v_next_update_id FROM SIZE_UPDATES;\n    \n    INSERT INTO SIZE_UPDATES (UPDATE_ID, MEASUREMENT_ID, UPDATE_DATE, UPDATED_BY, UPDATE_REASON, UPDATE_DESCRIPTION) \n    VALUES (v_next_update_id, NULL, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 0, 'COUNT_UPDATE', 'Total measurements: ' || v_total_measurements);\nEND;",
    "database_name": "apparel_sams_543314",
    "tables": [
      "SIZES",
      "MEASUREMENTS",
      "SIZE_UPDATES"
    ],
    "call_sqls": [
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (2, 1, 37.5, 98.0, 98.0, 117.0, 108.0, 93.0, 77.0, 61.0)",
      "DELETE FROM MEASUREMENTS WHERE MEASUREMENT_ID = 1",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (3, 0, 39.0, 102.0, 102.0, 118.0, 112.0, 97.0, 79.0, 63.0)",
      "DELETE FROM MEASUREMENTS WHERE MEASUREMENT_ID = 0",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (4, 1, 38.5, 100.0, 100.0, 119.0, 110.0, 95.0, 78.0, 62.5)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named `trg_sizes_measurement_count` that fires after each INSERT or DELETE operation on the MEASUREMENTS table, and for each such change, it calculates the total number of rows currently in the MEASUREMENTS table, determines the next UPDATE_ID for the SIZE_UPDATES table by taking the maximum existing UPDATE_ID plus one (starting at 0 if none exist), and then inserts a new record into the SIZE_UPDATES table with that UPDATE_ID, a NULL MEASUREMENT_ID, the current date in 'YYYY-MM-DD' format, UPDATED_BY as 0, UPDATE_REASON as 'COUNT_UPDATE', and an UPDATE_DESCRIPTION that states 'Total measurements: ' followed by the total row count.",
    "natural_language": "Write a Oracle PL/SQL trigger named `trg_sizes_measurement_count` that fires after inserting or deleting a row in the MEASUREMENTS table, which calculates the total number of rows in MEASUREMENTS, determines the next UPDATE_ID for the SIZE_UPDATES table by taking the maximum existing UPDATE_ID plus one (or starting at 0 if the table is empty), and inserts a new record into SIZE_UPDATES with that UPDATE_ID, a null MEASUREMENT_ID, today's date in 'YYYY-MM-DD' format, UPDATED_BY set to 0, UPDATE_REASON as 'COUNT_UPDATE', and UPDATE_DESCRIPTION as 'Total measurements: ' followed by the row count.",
    "id": 16,
    "generated_ir": "Write an Oracle PL/SQL AFTER INSERT OR DELETE row-level trigger named `trg_sizes_measurement_count` that automatically executes after an `INSERT` operation or a `DELETE` operation occurs on the `MEASUREMENTS` table. This trigger declares two local PL/SQL variables: `v_total_measurements` of type `NUMBER` and `v_next_update_id` of type `NUMBER`. Upon activation, the trigger first executes a `SELECT` statement to count the total number of rows currently present in the `MEASUREMENTS` table and stores this count into the `v_total_measurements` variable. Subsequently, it executes another `SELECT` statement to determine the next available `UPDATE_ID` for the `SIZE_UPDATES` table. This is achieved by selecting the maximum value from the `UPDATE_ID` column in the `SIZE_UPDATES` table, applying the `NVL` function to treat a `NULL` result (indicating an empty table) as `0`, and then adding `1` to this result to ensure a unique, incrementing `UPDATE_ID`. This calculated value is stored in the `v_next_update_id` variable. Finally, the trigger performs an `INSERT` operation into the `SIZE_UPDATES` table. The `UPDATE_ID` column is populated with the value from `v_next_update_id`. The `MEASUREMENT_ID` column is set to `NULL`. The `UPDATE_DATE` column is populated with the current system date formatted as 'YYYY-MM-DD' using the `TO_CHAR` function with `SYSDATE`. The `UPDATED_BY` column is set to the numeric literal `0`. The `UPDATE_REASON` column is set to the string literal `'COUNT_UPDATE'`. The `UPDATE_DESCRIPTION` column is constructed by concatenating the string literal `'Total measurements: '` with the current value of the `v_total_measurements` variable.",
    "original_summary": "Create an AFTER INSERT OR DELETE row-level trigger named `trg_sizes_measurement_count` on the MEASUREMENTS table. It counts the total rows in MEASUREMENTS, calculates the next UPDATE_ID from SIZE_UPDATES (max+1, defaulting to 0), and inserts a record into SIZE_UPDATES with UPDATE_ID from the calculation, NULL MEASUREMENT_ID, current date as 'YYYY-MM-DD', UPDATED_BY as 0, UPDATE_REASON as 'COUNT_UPDATE', and UPDATE_DESCRIPTION as 'Total measurements: ' concatenated with the row count.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires after we add or delete a row in the MEASUREMENTS table. Let's call it `trg_sizes_measurement_count`. Here's what it's gotta do: first, figure out how many rows are in MEASUREMENTS. Then, peek at the SIZE_UPDATES table to get the next ID number—just take the biggest one already there and add 1 to it. If that table's empty, start at 0. Finally, slap a new record into SIZE_UPDATES. Use that new ID we just figured out, leave MEASUREMENT_ID blank, put today's date in 'YYYY-MM-DD' format, set UPDATED_BY to 0, make UPDATE_REASON say 'COUNT_UPDATE', and for the description, just write 'Total measurements: ' followed by the row count we got earlier."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_climate_data_region_check that executes before an insert or update operation on the CLIMATE_DATA table for each row. The trigger begins by declaring four local variables: v_region_count, v_user_count, v_dataset_count, and v_report_id, all of type NUMBER. It first performs a SELECT COUNT(*) operation to determine the number of records in the REGIONS table where the REGION_ID matches the REGION_ID of the new or updated row in CLIMATE_DATA, storing the result in v_region_count. If v_region_count equals zero, indicating no matching region exists, the trigger inserts a new record into the ACCESS_LOGS table with an ACCESS_ID generated by selecting the maximum ACCESS_ID from ACCESS_LOGS and adding one, a RECORD_ID from the new or updated row, a USER_ID of 0, the current date formatted as 'YYYY-MM-DD', an ACCESS_TYPE of 'ERROR', an IP_ADDRESS of '0.0.0.0', a USER_AGENT of 'Trigger', and a STATUS_CODE of 404. If the AREA value of the new or updated row exceeds 1000, the trigger performs a SELECT COUNT(*) operation to count the number of records in the USERS table where USER_ID equals 1, storing the result in v_user_count. If v_user_count is greater than zero, the trigger updates the REGIONS table by increasing the AREA_KM2 column by the AREA value of the new or updated row for the matching REGION_ID. If the RAINFALL_MM value of the new or updated row is less than 50, the trigger performs a SELECT COUNT(*) operation to count the number of records in the DATASETS table where DATASET_ID equals 1, storing the result in v_dataset_count. If v_dataset_count is greater than zero, the trigger inserts a new record into the MODEL_PERFORMANCE table with a PERFORMANCE_ID generated by selecting the maximum PERFORMANCE_ID from MODEL_PERFORMANCE and adding one, a RECORD_ID from the new or updated row, R2_TRAIN and R2_VAL values of 0.9 and 0.85 respectively, a LOSS_TO_MINIMIZE value of 0.1, a MODEL_ID of 1, a DATASET_ID of 1, the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS', and a CREATED_BY value of 1. If none of the previous conditions are met, the trigger selects the maximum REPORT_ID from the REPORTS table, adds one, and stores the result in v_report_id. It then inserts a new record into the REPORTS table with the generated REPORT_ID, a REPORT_NAME of 'Climate Data Report', the current date formatted as 'YYYY-MM-DD', a USER_ID of 1, CONTENT set to 'Auto-generated report', a DATASET_ID of 1, the REGION_ID from the new or updated row, a STATUS of 'draft', and SHARED_WITH set to NULL.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_climate_data_region_check\nBEFORE INSERT OR UPDATE ON CLIMATE_DATA\nFOR EACH ROW\nDECLARE\n    v_region_count NUMBER;\n    v_user_count NUMBER;\n    v_dataset_count NUMBER;\n    v_report_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_region_count FROM REGIONS WHERE REGION_ID = :NEW.REGION_ID;\n    IF v_region_count = 0 THEN\n        INSERT INTO ACCESS_LOGS (ACCESS_ID, RECORD_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, STATUS_CODE)\n        VALUES ((SELECT NVL(MAX(ACCESS_ID), 0) + 1 FROM ACCESS_LOGS), :NEW.RECORD_ID, 0, TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), 'ERROR', '0.0.0.0', 'Trigger', 404);\n    ELSIF :NEW.AREA > 1000 THEN\n        SELECT COUNT(*) INTO v_user_count FROM USERS WHERE USER_ID = 1;\n        IF v_user_count > 0 THEN\n            UPDATE REGIONS SET AREA_KM2 = AREA_KM2 + :NEW.AREA WHERE REGION_ID = :NEW.REGION_ID;\n        END IF;\n    ELSIF :NEW.RAINFALL_MM < 50 THEN\n        SELECT COUNT(*) INTO v_dataset_count FROM DATASETS WHERE DATASET_ID = 1;\n        IF v_dataset_count > 0 THEN\n            INSERT INTO MODEL_PERFORMANCE (PERFORMANCE_ID, RECORD_ID, R2_TRAIN, R2_VAL, LOSS_TO_MINIMIZE, MODEL_ID, DATASET_ID, CREATED_AT, CREATED_BY)\n            VALUES ((SELECT NVL(MAX(PERFORMANCE_ID), 0) + 1 FROM MODEL_PERFORMANCE), :NEW.RECORD_ID, 0.9, 0.85, 0.1, 1, 1, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'), 1);\n        END IF;\n    ELSE\n        SELECT NVL(MAX(REPORT_ID), 0) + 1 INTO v_report_id FROM REPORTS;\n        INSERT INTO REPORTS (REPORT_ID, REPORT_NAME, GENERATED_DATE, USER_ID, CONTENT, DATASET_ID, REGION_ID, STATUS, SHARED_WITH)\n        VALUES (v_report_id, 'Climate Data Report', TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), 1, 'Auto-generated report', 1, :NEW.REGION_ID, 'draft', NULL);\n    END IF;\nEND;",
    "database_name": "climate_daa_prediction",
    "tables": [
      "ACCESS_LOGS",
      "CLIMATE_DATA",
      "DATASETS",
      "MODEL_PARAMETERS",
      "MODEL_PERFORMANCE",
      "REGIONS",
      "REPORTS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO CLIMATE_DATA (RECORD_ID, ANOMALY_RAINFALL, AREA, DAY, FCG, FATALITIES, LATITUDE, LONGITUDE, MONTH, NDVI, POPULATION, CEREAL_PRICE, RAINFALL_MM, RAMADAN, WATERWAYS, YEAR, TEMPERATURE, HUMIDITY, WIND_SPEED, PRECIPITATION_TYPE, SOIL_MOISTURE, CROP_TYPE, REGION_ID) VALUES (100, 0, 500, 15, 1, 0, 34.0522, -118.2437, 7, 0.7, 50000, 2.8, 120, 0, 1, 2023, 28, 70, 8, 'rain', 0.6, 'corn', 999)",
      "INSERT INTO CLIMATE_DATA (RECORD_ID, ANOMALY_RAINFALL, AREA, DAY, FCG, FATALITIES, LATITUDE, LONGITUDE, MONTH, NDVI, POPULATION, CEREAL_PRICE, RAINFALL_MM, RAMADAN, WATERWAYS, YEAR, TEMPERATURE, HUMIDITY, WIND_SPEED, PRECIPITATION_TYPE, SOIL_MOISTURE, CROP_TYPE, REGION_ID) VALUES (101, 0, 1500, 10, 1, 0, 36.7783, -119.4179, 6, 0.8, 20000, 3.0, 180, 0, 0, 2023, 25, 75, 10, 'rain', 0.5, 'wheat', 0)",
      "INSERT INTO CLIMATE_DATA (RECORD_ID, ANOMALY_RAINFALL, AREA, DAY, FCG, FATALITIES, LATITUDE, LONGITUDE, MONTH, NDVI, POPULATION, CEREAL_PRICE, RAINFALL_MM, RAMADAN, WATERWAYS, YEAR, TEMPERATURE, HUMIDITY, WIND_SPEED, PRECIPITATION_TYPE, SOIL_MOISTURE, CROP_TYPE, REGION_ID) VALUES (102, 0, 800, 20, 1, 0, 40.7128, -74.0060, 8, 0.6, 10000, 2.5, 40, 0, 1, 2023, 22, 80, 5, 'rain', 0.4, 'corn', 1)",
      "INSERT INTO CLIMATE_DATA (RECORD_ID, ANOMALY_RAINFALL, AREA, DAY, FCG, FATALITIES, LATITUDE, LONGITUDE, MONTH, NDVI, POPULATION, CEREAL_PRICE, RAINFALL_MM, RAMADAN, WATERWAYS, YEAR, TEMPERATURE, HUMIDITY, WIND_SPEED, PRECIPITATION_TYPE, SOIL_MOISTURE, CROP_TYPE, REGION_ID) VALUES (103, 0, 700, 5, 1, 0, 30.2672, -97.7431, 9, 0.75, 15000, 2.9, 100, 0, 0, 2023, 30, 65, 12, 'rain', 0.7, 'wheat', 0)",
      "UPDATE CLIMATE_DATA SET AREA = 1200 WHERE RECORD_ID = 1"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_CLIMATE_DATA_REGION_CHECK that fires BEFORE INSERT OR UPDATE on each row of the CLIMATE_DATA table to: if the new REGION_ID does not exist in the REGIONS table, log an error in ACCESS_LOGS; if AREA is greater than 1000 and USER_ID 1 exists in the USERS table, update the corresponding region's AREA_KM2 in the REGIONS table by adding the new AREA; if RAINFALL_MM is less than 50 and DATASET_ID 1 exists in the DATASETS table, insert a new record into MODEL_PERFORMANCE with predefined values; otherwise, insert a new draft report into the REPORTS table.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_CLIMATE_DATA_REGION_CHECK that fires BEFORE INSERT OR UPDATE on each row of the CLIMATE_DATA table to: first, if the new REGION_ID does not exist in the REGIONS table, log an error in the ACCESS_LOGS; second, if the new AREA exceeds 1000 and a USER_ID of 1 exists in the USERS table, update the AREA_KM2 field in the REGIONS table for that region; third, if the new RAINFALL_MM is below 50 and a DATASET_ID of 1 exists in the DATASETS table, insert a new entry into the MODEL_PERFORMANCE table; and finally, if none of these conditions are met, insert a new draft report into the REPORTS table.",
    "id": 17,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_CLIMATE_DATA_REGION_CHECK that activates before an insert or update operation on each row of the CLIMATE_DATA table. The trigger begins by checking if the new REGION_ID value from the inserted or updated row exists in the REGIONS table. If it does not exist, the trigger logs an error by inserting a new record into the ACCESS_LOGS table. This log entry includes a message indicating the invalid region, the current system date and time, and the user performing the operation, using the USER function.\n\nIf the REGION_ID is valid, the trigger proceeds to evaluate the second condition. It checks if the new AREA value from the inserted or updated row exceeds 1000 and if a USER_ID of 1 exists in the USERS table. If both conditions are true, the trigger updates the AREA_KM2 field in the REGIONS table for the row where the REGION_ID matches the new REGION_ID, setting it to the new AREA value.\n\nIf the second condition is not met, the trigger evaluates the third condition. It checks if the new RAINFALL_MM value from the inserted or updated row is below 50 and if a DATASET_ID of 1 exists in the DATASETS table. If both conditions are true, the trigger inserts a new entry into the MODEL_PERFORMANCE table. This entry includes the new REGION_ID, the new RAINFALL_MM value, a performance score calculated as RAINFALL_MM multiplied by 0.1, the current system date, and a status of 'LOW_RAINFALL'.\n\nIf none of the above conditions are met, the trigger inserts a new draft report into the REPORTS table. This report includes the new REGION_ID, a report title concatenated from the string 'Draft Report for Region ' and the new REGION_ID, a report body containing the new AREA and RAINFALL_MM values, the current system date, and a status of 'DRAFT'.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named TRG_CLIMATE_DATA_REGION_CHECK on the CLIMATE_DATA table. The trigger must: 1) If the new REGION_ID does not exist in the REGIONS table, log an error in ACCESS_LOGS. 2) If AREA > 1000 and USER_ID 1 exists, update the corresponding region's AREA_KM2. 3) If RAINFALL_MM < 50 and DATASET_ID 1 exists, insert a record into MODEL_PERFORMANCE. 4) If none of the above, insert a new draft report into the REPORTS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Generate a BEFORE INSERT OR UPDATE FOR EACH ROW trigger designated as TRG_CLIMATE_DATA_REGION_CHECK for the CLIMATE_DATA table. The trigger's operations are as follows: Firstly, should the newly provided REGION_ID not be present within the REGIONS table, an error must be recorded in the ACCESS_LOGS. Secondly, in the event that the AREA value exceeds 1000 and a USER_ID of 1 exists, the corresponding region's AREA_KM2 field is to be updated. Thirdly, if the RAINFALL_MM is below 50 and a DATASET_ID of 1 exists, a new entry must be inserted into the MODEL_PERFORMANCE table. Finally, if none of the preceding conditions are satisfied, a new draft report is to be inserted into the REPORTS table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_access_logs_insert that activates after a new row is inserted into the ACCESS_LOGS table. This trigger performs an insert operation into the NOTIFICATIONS table, populating the columns NOTIFICATION_ID, CASE_ID, USER_ID, NOTIFICATION_DATE, NOTIFICATION_TYPE, MESSAGE, and STATUS. The NOTIFICATION_ID is determined by selecting the maximum existing NOTIFICATION_ID from the NOTIFICATIONS table, using the NVL function to handle null values, and incrementing it by one to ensure a unique identifier. The CASE_ID and USER_ID are directly taken from the newly inserted row in the ACCESS_LOGS table, referenced using the :NEW prefix. The NOTIFICATION_DATE is set to the current date, formatted as 'YYYY-MM-DD' using the TO_CHAR function. The NOTIFICATION_TYPE is assigned the string 'access log'. The MESSAGE column is constructed by concatenating the string 'New access log recorded from ' with the IP_ADDRESS from the new ACCESS_LOGS row. Finally, the STATUS column is set to 'sent'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_access_logs_insert\nAFTER INSERT ON ACCESS_LOGS\nFOR EACH ROW\nBEGIN\n  INSERT INTO NOTIFICATIONS (NOTIFICATION_ID, CASE_ID, USER_ID, NOTIFICATION_DATE, NOTIFICATION_TYPE, MESSAGE, STATUS)\n  VALUES ((SELECT NVL(MAX(NOTIFICATION_ID), 0) + 1 FROM NOTIFICATIONS), :NEW.CASE_ID, :NEW.USER_ID, TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), 'access log', 'New access log recorded from ' || :NEW.IP_ADDRESS, 'sent');\nEND;",
    "database_name": "covid_1cta_statistics",
    "tables": [
      "CASES",
      "CASE_UPDATES",
      "ACCESS_LOGS",
      "NOTIFICATIONS"
    ],
    "call_sqls": [
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, CASE_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, DEVICE) VALUES (2, 1, 1, '2023-05-03', 'view', '192.168.1.3', 'desktop')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, CASE_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, DEVICE) VALUES (3, 1, 0, '2023-05-04', 'download', '192.168.1.4', 'mobile')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, CASE_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, DEVICE) VALUES (4, 1, 1, '2023-05-05', 'view', '192.168.1.5', 'desktop')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, CASE_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, DEVICE) VALUES (5, 1, 0, '2023-05-06', 'download', '192.168.1.6', 'mobile')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, CASE_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, DEVICE) VALUES (6, 1, 1, '2023-05-07', 'view', '192.168.1.7', 'desktop')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_access_logs_insert that fires after each new row is inserted into the ACCESS_LOGS table. For every insertion, it should automatically create a corresponding notification in the NOTIFICATIONS table. The notification should use a new NOTIFICATION_ID generated by incrementing the highest existing ID, take the CASE_ID and USER_ID from the newly inserted ACCESS_LOGS row, set the NOTIFICATION_DATE to today's date in 'YYYY-MM-DD' format, set NOTIFICATION_TYPE to 'access log', build the MESSAGE by combining 'New access log recorded from ' with the new row's IP_ADDRESS, and set the STATUS to 'sent'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_access_logs_insert that, after each new row is inserted into the ACCESS_LOGS table, automatically creates a corresponding record in the NOTIFICATIONS table. For each new notification, generate a unique NOTIFICATION_ID by taking the highest current NOTIFICATION_ID from the NOTIFICATIONS table and adding one to it, use the CASE_ID and USER_ID from the newly inserted ACCESS_LOGS row, set the NOTIFICATION_DATE to today's date in 'YYYY-MM-DD' format, set the NOTIFICATION_TYPE to 'access log', compose the MESSAGE by combining the phrase 'New access log recorded from ' with the IP_ADDRESS from the new ACCESS_LOGS entry, and mark the STATUS as 'sent'.",
    "id": 18,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_access_logs_insert that activates after a new row is inserted into the ACCESS_LOGS table. This trigger performs an insert operation into the NOTIFICATIONS table, populating the columns NOTIFICATION_ID, CASE_ID, USER_ID, NOTIFICATION_DATE, NOTIFICATION_TYPE, MESSAGE, and STATUS. The NOTIFICATION_ID is determined by selecting the maximum existing NOTIFICATION_ID from the NOTIFICATIONS table, using the NVL function to handle null values, and incrementing it by one to ensure a unique identifier. The CASE_ID and USER_ID are directly taken from the newly inserted row in the ACCESS_LOGS table, referenced using the :NEW prefix. The NOTIFICATION_DATE is set to the current date, formatted as 'YYYY-MM-DD' using the TO_CHAR function. The NOTIFICATION_TYPE is assigned the string 'access log'. The MESSAGE column is constructed by concatenating the string 'New access log recorded from ' with the IP_ADDRESS from the new ACCESS_LOGS row. Finally, the STATUS column is set to 'sent'.",
    "original_summary": "Create an AFTER INSERT trigger on the ACCESS_LOGS table named trg_access_logs_insert. For each new row, insert a corresponding record into the NOTIFICATIONS table. Generate a new NOTIFICATION_ID by incrementing the maximum existing ID, use the new row's CASE_ID and USER_ID, set NOTIFICATION_DATE to the current date in 'YYYY-MM-DD' format, set NOTIFICATION_TYPE to 'access log', construct the MESSAGE by concatenating 'New access log recorded from ' with the new IP_ADDRESS, and set STATUS to 'sent'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the ACCESS_LOGS table for new entries. When a row is added, you should also put a record into the NOTIFICATIONS table. For the ID, just take whatever the highest current one is and add one to it. Use the new row's case and user details. The date should be today, formatted in the usual way. Mark the type as something like 'access log'. For the message, combine a phrase about a new access log with the IP address from the new entry. Finally, set its status to something that indicates it's been sent."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_adjust_demographics_on_cause_update that fires automatically after any row in the COUNTRY_CAUSE_OF_DEATH_DATA table is updated specifically for the NUMBER_OF_DEATHS column, and for each affected row, it performs the following sequence of operations: first, it calculates a variable v_delta as the difference between the new NUMBER_OF_DEATHS value and the old NUMBER_OF_DEATHS value; then, it selects the current TOTAL_DEATHS value from the DEMOGRAPHICS table into a variable v_new_total for the specific row where the COUNTRY_ID matches the new COUNTRY_ID from the updated row and the YEAR matches the new YEAR from the updated row; it then increments this v_new_total by the calculated v_delta; it updates the DEMOGRAPHICS table, setting the TOTAL_DEATHS column to this new v_new_total value for the row identified by the matching COUNTRY_ID and YEAR; it subsequently updates the same DEMOGRAPHICS row again, recalculating the DEATH_RATE column as the quotient of the new total deaths (v_new_total) divided by the POPULATION column, multiplied by 1000; finally, it checks a conditional statement: if the new NUMBER_OF_DEATHS value is strictly greater than the old NUMBER_OF_DEATHS value, it performs a third update on the same DEMOGRAPHICS row, decreasing the LIFE_EXPECTANCY column by 0.1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_adjust_demographics_on_cause_update\nAFTER UPDATE OF NUMBER_OF_DEATHS ON COUNTRY_CAUSE_OF_DEATH_DATA\nFOR EACH ROW\nDECLARE\n    v_delta NUMBER;\n    v_new_total NUMBER;\nBEGIN\n    v_delta := :NEW.NUMBER_OF_DEATHS - :OLD.NUMBER_OF_DEATHS;\n    SELECT TOTAL_DEATHS INTO v_new_total FROM DEMOGRAPHICS WHERE COUNTRY_ID = :NEW.COUNTRY_ID AND YEAR = :NEW.YEAR;\n    v_new_total := v_new_total + v_delta;\n    UPDATE DEMOGRAPHICS SET TOTAL_DEATHS = v_new_total WHERE COUNTRY_ID = :NEW.COUNTRY_ID AND YEAR = :NEW.YEAR;\n    UPDATE DEMOGRAPHICS SET DEATH_RATE = (v_new_total / POPULATION) * 1000 WHERE COUNTRY_ID = :NEW.COUNTRY_ID AND YEAR = :NEW.YEAR;\n    IF :NEW.NUMBER_OF_DEATHS > :OLD.NUMBER_OF_DEATHS THEN\n        UPDATE DEMOGRAPHICS SET LIFE_EXPECTANCY = LIFE_EXPECTANCY - 0.1 WHERE COUNTRY_ID = :NEW.COUNTRY_ID AND YEAR = :NEW.YEAR;\n    END IF;\nEND;",
    "database_name": "global_hsa_trends",
    "tables": [
      "COUNTRIES",
      "CAUSES_OF_DEATH",
      "COUNTRY_CAUSE_OF_DEATH_DATA",
      "DISEASES",
      "COUNTRY_DISEASE_DATA",
      "DEMOGRAPHICS"
    ],
    "call_sqls": [
      "UPDATE COUNTRY_CAUSE_OF_DEATH_DATA SET NUMBER_OF_DEATHS = 150000 WHERE COUNTRY_CAUSE_OF_DEATH_ID = 1",
      "UPDATE COUNTRY_CAUSE_OF_DEATH_DATA SET NUMBER_OF_DEATHS = 120000 WHERE COUNTRY_ID = 0 AND CAUSE_OF_DEATH_ID = 0 AND YEAR = 2007",
      "UPDATE COUNTRY_CAUSE_OF_DEATH_DATA SET NUMBER_OF_DEATHS = NUMBER_OF_DEATHS + 5000 WHERE COUNTRY_ID = 1 AND YEAR = 2008",
      "UPDATE COUNTRY_CAUSE_OF_DEATH_DATA SET NUMBER_OF_DEATHS = 90000 WHERE COUNTRY_CAUSE_OF_DEATH_ID = 0",
      "UPDATE COUNTRY_CAUSE_OF_DEATH_DATA SET NUMBER_OF_DEATHS = 100000, INCIDENCE_RATE = 0.0003 WHERE COUNTRY_CAUSE_OF_DEATH_ID = 2"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_adjust_demographics_on_cause_update that fires after updating the NUMBER_OF_DEATHS column in the COUNTRY_CAUSE_OF_DEATH_DATA table for each row, and for each update, it calculates the change in deaths, then updates the matching row in the DEMOGRAPHICS table for the same COUNTRY_ID and YEAR by adjusting the TOTAL_DEATHS accordingly, recalculating the DEATH_RATE as (TOTAL_DEATHS divided by POPULATION) multiplied by 1000, and if the deaths increased, also decreases the LIFE_EXPECTANCY by 0.1.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_adjust_demographics_on_cause_update that runs after an update to the NUMBER_OF_DEATHS column in the COUNTRY_CAUSE_OF_DEATH_DATA table. For each updated row, calculate the change in deaths, then update the matching record in the DEMOGRAPHICS table by adjusting the TOTAL_DEATHS accordingly and recalculating the DEATH_RATE as (TOTAL_DEATHS / POPULATION) * 1000. Additionally, if the change indicates an increase in deaths, reduce the LIFE_EXPECTANCY by 0.1.",
    "id": 19,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_adjust_demographics_on_cause_update that fires automatically after any row in the COUNTRY_CAUSE_OF_DEATH_DATA table is updated specifically for the NUMBER_OF_DEATHS column, and for each affected row, it performs the following sequence of operations: first, it calculates a variable v_delta as the difference between the new NUMBER_OF_DEATHS value and the old NUMBER_OF_DEATHS value; then, it selects the current TOTAL_DEATHS value from the DEMOGRAPHICS table into a variable v_new_total for the specific row where the COUNTRY_ID matches the new COUNTRY_ID from the updated row and the YEAR matches the new YEAR from the updated row; it then increments this v_new_total by the calculated v_delta; it updates the DEMOGRAPHICS table, setting the TOTAL_DEATHS column to this new v_new_total value for the row identified by the matching COUNTRY_ID and YEAR; it subsequently updates the same DEMOGRAPHICS row again, recalculating the DEATH_RATE column as the quotient of the new total deaths (v_new_total) divided by the POPULATION column, multiplied by 1000; finally, it checks a conditional statement: if the new NUMBER_OF_DEATHS value is strictly greater than the old NUMBER_OF_DEATHS value, it performs a third update on the same DEMOGRAPHICS row, decreasing the LIFE_EXPECTANCY column by 0.1.",
    "original_summary": "Create an AFTER UPDATE row-level trigger named trg_adjust_demographics_on_cause_update on the COUNTRY_CAUSE_OF_DEATH_DATA table, firing when the NUMBER_OF_DEATHS column is updated. Calculate the change in deaths. Update the matching row in the DEMOGRAPHICS table by adjusting the TOTAL_DEATHS, recalculating the DEATH_RATE as (TOTAL_DEATHS / POPULATION) * 1000. If deaths increased, also decrease the LIFE_EXPECTANCY by 0.1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a row-level trigger designated as trg_adjust_demographics_on_cause_update, to be executed subsequent to an update operation on the COUNTRY_CAUSE_OF_DEATH_DATA table. This trigger should be activated specifically upon modification of the NUMBER_OF_DEATHS column. Within the trigger's procedure, compute the differential in the number of deaths. Subsequently, proceed to update the corresponding entry within the DEMOGRAPHICS table by modifying the TOTAL_DEATHS value and recomputing the DEATH_RATE according to the formula (TOTAL_DEATHS / POPULATION) * 1000. Furthermore, in instances where the computed change reflects an increase in deaths, it is required to decrement the LIFE_EXPECTANCY value by 0.1."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_access_logs_type_default that is executed before an insert operation on the ACCESS_LOGS table for each row being inserted. The trigger checks the value of the ACCESS_TYPE column in the new row being inserted. If the ACCESS_TYPE column is found to be NULL, the trigger assigns the default value 'view' to the ACCESS_TYPE column of the new row. This ensures that any row inserted into the ACCESS_LOGS table without a specified ACCESS_TYPE will automatically have its ACCESS_TYPE set to 'view'. The trigger does not perform any other operations such as updates, deletes, or selects, and does not involve any function calls or special operations. The logic flow consists of a single conditional statement that checks for a NULL value in the ACCESS_TYPE column and assigns a default value if the condition is met.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_access_logs_type_default\nBEFORE INSERT ON ACCESS_LOGS\nFOR EACH ROW\nBEGIN\n    IF :NEW.ACCESS_TYPE IS NULL THEN\n        :NEW.ACCESS_TYPE := 'view';\n    END IF;\nEND;",
    "database_name": "economic_daar_473112",
    "tables": [
      "ACCESS_LOGS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, ACCESS_LOCATION) VALUES (100, 1, 0, '2024-01-15', 'United States')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, ACCESS_LOCATION) VALUES (101, 1, 1, '2024-01-15', NULL, 'Canada')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE) VALUES (102, 1, 0, '2024-01-16')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE) VALUES (103, 1, 1, '2024-01-16', 'download')",
      "INSERT INTO ACCESS_LOGS VALUES (104, 2, 0, '2024-01-17', NULL, 'Germany')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_access_logs_type_default that fires BEFORE INSERT on the ACCESS_LOGS table for each row, and if the new ACCESS_TYPE is NULL, sets it to 'view'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_access_logs_type_default that runs before inserting new rows into the ACCESS_LOGS table, and if the ACCESS_TYPE is missing or not set, automatically sets it to 'view' as a default.",
    "id": 20,
    "generated_ir": "Write an Oracle PL/SQL BEFORE INSERT trigger named trg_access_logs_type_default that fires for each row being inserted into the ACCESS_LOGS table. The trigger does not declare any local variables. It checks the value of the ACCESS_TYPE column in the new row being inserted. If the ACCESS_TYPE is missing, meaning it is NULL, or if it is not set, meaning it is an empty string, then the trigger automatically updates the ACCESS_TYPE column of the new row to the default value 'view'. This ensures that every new row inserted into the ACCESS_LOGS table has a non-null and non-empty ACCESS_TYPE, defaulting to 'view' when no other value is provided. The trigger does not perform any other operations such as SELECT, UPDATE, DELETE, or function calls, and it does not interact with any other tables or columns.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_access_logs_type_default on the ACCESS_LOGS table. If the new ACCESS_TYPE is NULL, set it to 'view'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the ACCESS_LOGS table that runs before adding new entries. The trigger should handle cases where the access type isn't clearly specified, defaulting it to something like 'view' if it seems to be missing or not properly set."
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_maintain_author_order` that automatically executes before a new row is inserted into the `PAPER_AUTHORS` table. This trigger is designed to perform two primary actions: first, it assigns a sequential `AUTHOR_ORDER` to the new author within the context of a specific paper, and second, it conditionally inserts a 'SELF' citation into the `CITATIONS` table if the `PAPER_ID` of the new author record corresponds to an existing paper in the `PAPERS` table.\n\nUpon activation for each new row being inserted into `PAPER_AUTHORS`, the trigger declares two local variables: `v_max_order` of type `NUMBER` to store the maximum existing author order for a given paper, and `v_exists` of type `NUMBER` to store a count indicating the presence of a paper.\n\nThe trigger's execution begins by querying the `PAPER_AUTHORS` table to determine the highest `AUTHOR_ORDER` currently associated with the `PAPER_ID` of the new record being inserted. This is achieved by executing a `SELECT` statement that retrieves the maximum value of the `AUTHOR_ORDER` column. The `NVL` function is applied to this maximum value, ensuring that if no existing `AUTHOR_ORDER` is found for the `PAPER_ID` (i.e., `MAX(AUTHOR_ORDER)` returns `NULL`), the value defaults to `0`. The result of this query is then stored in the `v_max_order` variable. The condition for this `SELECT` statement is `PAPER_ID = :NEW.PAPER_ID`, where `:NEW.PAPER_ID` refers to the `PAPER_ID` value of the row currently being inserted into `PAPER_AUTHORS`.\n\nFollowing this, the trigger assigns a new `AUTHOR_ORDER` to the record being inserted. It sets the `AUTHOR_ORDER` column of the new row (`:NEW.AUTHOR_ORDER`) to the value of `v_max_order` incremented by `1`. This ensures that each author for a specific paper receives a unique, sequentially increasing order.\n\nNext, the trigger performs a check to determine if the `PAPER_ID` associated with the new `PAPER_AUTHORS` record exists in the `PAPERS` table. This is done by executing a `SELECT COUNT(*)` statement on the `PAPERS` table, counting the number of rows where the `PAPER_ID` column matches `:NEW.PAPER_ID`. The result of this count is stored in the `v_exists` variable.\n\nA conditional block (`IF v_exists > 0 THEN`) then evaluates the value of `v_exists`. If `v_exists` is greater than `0`, indicating that the `PAPER_ID` of the new author record corresponds to an existing paper in the `PAPERS` table, the trigger proceeds to insert a new record into the `CITATIONS` table.\n\nThe `INSERT` statement into the `CITATIONS` table populates the following columns:\n- `CITATION_ID`: This is generated by querying the `CITATIONS` table to find the maximum existing `CITATION_ID`, applying `NVL` to default to `0` if no `CITATION_ID` exists, and then incrementing the result by `1`. This ensures a unique, sequentially increasing `CITATION_ID`.\n- `PAPER_ID`: This is set to `:NEW.PAPER_ID`, linking the citation to the paper for which the author is being added.\n- `CITED_PAPER_ID`: This is also set to `:NEW.PAPER_ID`, indicating a self-citation where the paper cites itself.\n- `CITATION_TYPE`: This is set to the literal string `'SELF'`.\n- `CITATION_YEAR`: This is set to the literal numeric value `2024`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_author_order\nBEFORE INSERT ON PAPER_AUTHORS\nFOR EACH ROW\nDECLARE\n  v_max_order NUMBER;\n  v_exists NUMBER;\nBEGIN\n  SELECT NVL(MAX(AUTHOR_ORDER), 0) INTO v_max_order FROM PAPER_AUTHORS WHERE PAPER_ID = :NEW.PAPER_ID;\n  :NEW.AUTHOR_ORDER := v_max_order + 1;\n\n  -- Check if PAPER_ID exists in PAPERS table\n  SELECT COUNT(*) INTO v_exists FROM PAPERS WHERE PAPER_ID = :NEW.PAPER_ID;\n  \n  IF v_exists > 0 THEN\n    -- Generate a unique CITATION_ID\n    INSERT INTO CITATIONS (CITATION_ID, PAPER_ID, CITED_PAPER_ID, CITATION_TYPE, CITATION_YEAR)\n    VALUES ((SELECT NVL(MAX(CITATION_ID), 0) + 1 FROM CITATIONS), :NEW.PAPER_ID, :NEW.PAPER_ID, 'SELF', 2024);\n  END IF;\nEND;",
    "database_name": "academic_rapm_450452",
    "tables": [
      "AUTHORS",
      "PAPERS",
      "CITATIONS",
      "REVIEWS",
      "PAPER_AUTHORS"
    ],
    "call_sqls": [
      "INSERT INTO PAPER_AUTHORS (PAPER_ID, AUTHOR_ID) VALUES (1, 101)",
      "INSERT INTO PAPER_AUTHORS (PAPER_ID, AUTHOR_ID) VALUES (2, 102)",
      "INSERT INTO PAPER_AUTHORS (PAPER_ID, AUTHOR_ID) VALUES (3, 103)",
      "INSERT INTO PAPER_AUTHORS (PAPER_ID, AUTHOR_ID) VALUES (4, 104)",
      "INSERT INTO PAPER_AUTHORS (PAPER_ID, AUTHOR_ID) VALUES (5, 105)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_maintain_author_order that fires BEFORE INSERT on the PAPER_AUTHORS table for each row, setting the AUTHOR_ORDER to one more than the current maximum AUTHOR_ORDER for that PAPER_ID, and then, if the PAPER_ID exists in the PAPERS table, inserting a new 'SELF' citation into the CITATIONS table for that paper with a unique CITATION_ID and the year 2024.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_maintain_author_order on the PAPER_AUTHORS table that, before each insert, sets the AUTHOR_ORDER to the maximum existing value for that PAPER_ID plus one, and if the PAPER_ID exists in the PAPERS table, also inserts a 'SELF' citation for it in the CITATIONS table with a new CITATION_ID and the year 2024.",
    "id": 21,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_maintain_author_order` that automatically executes before a new row is inserted into the `PAPER_AUTHORS` table. This trigger is designed to perform two primary actions: first, it assigns a sequential `AUTHOR_ORDER` to the new author within the context of a specific paper, and second, it conditionally inserts a 'SELF' citation into the `CITATIONS` table if the `PAPER_ID` of the new author record corresponds to an existing paper in the `PAPERS` table.\n\nUpon activation for each new row being inserted into `PAPER_AUTHORS`, the trigger declares two local variables: `v_max_order` of type `NUMBER` to store the maximum existing author order for a given paper, and `v_exists` of type `NUMBER` to store a count indicating the presence of a paper.\n\nThe trigger's execution begins by querying the `PAPER_AUTHORS` table to determine the highest `AUTHOR_ORDER` currently associated with the `PAPER_ID` of the new record being inserted. This is achieved by executing a `SELECT` statement that retrieves the maximum value of the `AUTHOR_ORDER` column. The `NVL` function is applied to this maximum value, ensuring that if no existing `AUTHOR_ORDER` is found for the `PAPER_ID` (i.e., `MAX(AUTHOR_ORDER)` returns `NULL`), the value defaults to `0`. The result of this query is then stored in the `v_max_order` variable. The condition for this `SELECT` statement is `PAPER_ID = :NEW.PAPER_ID`, where `:NEW.PAPER_ID` refers to the `PAPER_ID` value of the row currently being inserted into `PAPER_AUTHORS`.\n\nFollowing this, the trigger assigns a new `AUTHOR_ORDER` to the record being inserted. It sets the `AUTHOR_ORDER` column of the new row (`:NEW.AUTHOR_ORDER`) to the value of `v_max_order` incremented by `1`. This ensures that each author for a specific paper receives a unique, sequentially increasing order.\n\nNext, the trigger performs a check to determine if the `PAPER_ID` associated with the new `PAPER_AUTHORS` record exists in the `PAPERS` table. This is done by executing a `SELECT COUNT(*)` statement on the `PAPERS` table, counting the number of rows where the `PAPER_ID` column matches `:NEW.PAPER_ID`. The result of this count is stored in the `v_exists` variable.\n\nA conditional block (`IF v_exists > 0 THEN`) then evaluates the value of `v_exists`. If `v_exists` is greater than `0`, indicating that the `PAPER_ID` of the new author record corresponds to an existing paper in the `PAPERS` table, the trigger proceeds to insert a new record into the `CITATIONS` table.\n\nThe `INSERT` statement into the `CITATIONS` table populates the following columns:\n- `CITATION_ID`: This is generated by querying the `CITATIONS` table to find the maximum existing `CITATION_ID`, applying `NVL` to default to `0` if no `CITATION_ID` exists, and then incrementing the result by `1`. This ensures a unique, sequentially increasing `CITATION_ID`.\n- `PAPER_ID`: This is set to `:NEW.PAPER_ID`, linking the citation to the paper for which the author is being added.\n- `CITED_PAPER_ID`: This is also set to `:NEW.PAPER_ID`, indicating a self-citation where the paper cites itself.\n- `CITATION_TYPE`: This is set to the literal string `'SELF'`.\n- `CITATION_YEAR`: This is set to the literal numeric value `2024`.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_maintain_author_order on the PAPER_AUTHORS table. For each new row, set the AUTHOR_ORDER to one more than the current maximum for that PAPER_ID. Then, if the PAPER_ID exists in the PAPERS table, insert a new 'SELF' citation into the CITATIONS table for that paper with a unique CITATION_ID and the year 2024.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create trigger trg_maintain_author_order on PAPER_AUTHORS. Before insert, set AUTHOR_ORDER to max for that PAPER_ID plus one. If PAPER_ID is in PAPERS, also insert a 'SELF' citation for it in CITATIONS with a new CITATION_ID and year 2024."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_stock_and_check_brand that is executed before an insert or update operation on the ORDER_ITEMS table for each row affected. The trigger declares two local variables: v_stock of type NUMBER to store the stock quantity of a product, and v_is_active of type NUMBER to store the active status of a brand. It begins by selecting the STOCK_QUANTITY from the PRODUCTS table where the PRODUCT_ID matches the PRODUCT_ID of the new or updated row in ORDER_ITEMS, storing the result in v_stock. It then selects the IS_ACTIVE status from the BRANDS table where the BRAND_ID corresponds to the BRAND_ID retrieved from the PRODUCTS table for the same PRODUCT_ID, storing the result in v_is_active. The trigger checks if the value of v_stock is less than the QUANTITY specified in the new or updated row of ORDER_ITEMS; if true, it raises an application error with code -20001 and message 'Insufficient stock'. If the brand is not active, indicated by v_is_active being equal to 0, it raises another application error with code -20002 and message 'Brand is not active'. If neither condition is met, it updates the PRODUCTS table by subtracting the QUANTITY from the STOCK_QUANTITY for the row where the PRODUCT_ID matches the PRODUCT_ID of the new or updated ORDER_ITEMS row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_stock_and_check_brand\nBEFORE INSERT OR UPDATE ON ORDER_ITEMS\nFOR EACH ROW\nDECLARE\n  v_stock NUMBER;\n  v_is_active NUMBER;\nBEGIN\n  SELECT STOCK_QUANTITY INTO v_stock FROM PRODUCTS WHERE PRODUCT_ID = :NEW.PRODUCT_ID;\n  SELECT IS_ACTIVE INTO v_is_active FROM BRANDS WHERE BRAND_ID = (SELECT BRAND_ID FROM PRODUCTS WHERE PRODUCT_ID = :NEW.PRODUCT_ID);\n  \n  IF v_stock < :NEW.QUANTITY THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Insufficient stock');\n  ELSIF v_is_active = 0 THEN\n    RAISE_APPLICATION_ERROR(-20002, 'Brand is not active');\n  ELSE\n    UPDATE PRODUCTS SET STOCK_QUANTITY = STOCK_QUANTITY - :NEW.QUANTITY WHERE PRODUCT_ID = :NEW.PRODUCT_ID;\n  END IF;\nEND;",
    "database_name": "fashion_scam_tracking",
    "tables": [
      "BRANDS",
      "PRODUCTS",
      "ORDER_ITEMS",
      "USER_PROFILES"
    ],
    "call_sqls": [
      "INSERT INTO ORDER_ITEMS (ITEM_ID, ORDER_ID, PRODUCT_ID, SIZE_ID, QUANTITY, CREATED_AT, UPDATED_AT, PRICE_PER_UNIT) VALUES (2, 1, 0, 1, 1, '2023-05-03 12:00:00', '2023-05-03 12:00:00', '19.99')",
      "INSERT INTO ORDER_ITEMS (ITEM_ID, ORDER_ID, PRODUCT_ID, SIZE_ID, QUANTITY, CREATED_AT, UPDATED_AT, PRICE_PER_UNIT) VALUES (3, 2, 1, 1, 2, '2023-05-04 12:00:00', '2023-05-04 12:00:00', '99.99')",
      "UPDATE ORDER_ITEMS SET QUANTITY = 3 WHERE ITEM_ID = 0",
      "UPDATE ORDER_ITEMS SET QUANTITY = 4 WHERE ITEM_ID = 1",
      "INSERT INTO ORDER_ITEMS (ITEM_ID, ORDER_ID, PRODUCT_ID, SIZE_ID, QUANTITY, CREATED_AT, UPDATED_AT, PRICE_PER_UNIT) VALUES (4, 3, 0, 1, 5, '2023-05-05 12:00:00', '2023-05-05 12:00:00', '19.99')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_stock_and_check_brand that fires BEFORE INSERT or UPDATE on each row of the ORDER_ITEMS table. For each new or updated order item, check the stock quantity for the corresponding product from the PRODUCTS table and verify that the product's brand is active (IS_ACTIVE = 1) in the BRANDS table. If the stock quantity is less than the order quantity, raise an error for insufficient stock. If the brand is not active, raise an error for inactive brand. If both checks pass, reduce the product's stock quantity in the PRODUCTS table by the order quantity.",
    "natural_language": "Hey, write a Oracle PL/SQL trigger called trg_update_stock_and_check_brand for the ORDER_ITEMS table that fires before any new row is inserted or an existing row is updated. For each item, it needs to check the product's current stock from the PRODUCTS table and verify if its brand is active in the BRANDS table. If there isn't enough stock, raise an error with code -20001. If the brand is inactive (IS_ACTIVE is 0), raise an error with code -20002. If both checks pass, reduce the product's stock in the PRODUCTS table by the ordered quantity.",
    "id": 22,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_stock_and_check_brand that is configured to execute BEFORE any INSERT or UPDATE operation is performed on the ORDER_ITEMS table in the fashion_scam_tracking database. This trigger is defined as a FOR EACH ROW trigger, meaning its logic will be executed once for every row that is being inserted or updated in the ORDER_ITEMS table. The trigger's primary purpose is to enforce business rules related to product stock availability and brand status before allowing an order item to be created or modified.\n\nInside the trigger's DECLARE section, two local variables are declared: v_current_stock of type NUMBER to hold the current stock quantity of the product, and v_brand_active of type NUMBER to hold the active status flag of the product's brand.\n\nThe trigger's execution block begins with a SELECT statement that queries the PRODUCTS table to retrieve the stock_quantity column for the specific product, storing the value into the variable v_current_stock. This selection is conditioned on the product_id column in the PRODUCTS table being equal to the newly provided product_id value from the :NEW pseudorecord. Simultaneously, a second SELECT statement queries the BRANDS table by joining it with the PRODUCTS table. The join condition is that the brand_id column from the BRANDS table matches the brand_id column from the PRODUCTS table. The query retrieves the IS_ACTIVE column from the BRANDS table, storing its value into the variable v_brand_active. This selection is also conditioned on the product_id column in the PRODUCTS table being equal to the :NEW.product_id value.\n\nFollowing the data retrieval, a conditional check is performed. First, an IF statement evaluates if the value in v_current_stock is less than the ordered quantity provided in the :NEW.quantity value. If this condition is TRUE, meaning there is insufficient stock for the product, the trigger immediately raises an application error. The RAISE_APPLICATION_ERROR procedure is called with the error number -20001 and a descriptive error message.\n\nIf the stock check passes, a second IF statement evaluates the value in v_brand_active. If this value is equal to 0, indicating the brand is inactive, the trigger immediately raises a different application error. The RAISE_APPLICATION_ERROR procedure is called with the error number -20002 and a corresponding descriptive error message.\n\nIf both conditional checks evaluate to FALSE, meaning there is sufficient stock and the brand is active, the trigger proceeds to perform an UPDATE operation on the PRODUCTS table. This update sets the stock_quantity column to a new value calculated by subtracting the ordered quantity (the :NEW.quantity value) from the current stock_quantity. The update is applied specifically to the row in the PRODUCTS table whose product_id column matches the :NEW.product_id value, thereby reducing the product's stock by the ordered quantity.",
    "original_summary": "Create a BEFORE INSERT or UPDATE row-level trigger named trg_update_stock_and_check_brand on the ORDER_ITEMS table. For each row, check the product's stock from the PRODUCTS table and its brand's active status from the BRANDS table. Raise error -20001 for insufficient stock, or error -20002 if the brand is not active (IS_ACTIVE = 0). If checks pass, decrement the product's stock by the order quantity.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, set up a trigger called trg_update_stock_and_check_brand for the ORDER_ITEMS table that fires before any new row is added or an existing one is updated. For each item, it's gotta look up the product's current stock from PRODUCTS and check if its brand is still active over in the BRANDS table. If there's not enough stuff in stock, throw an error with code -20001. If the brand is inactive (like, IS_ACTIVE is 0), then error out with -20002. If everything's cool and both checks pass, just reduce the product's stock by the amount ordered."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_player_games_cleanup that is defined to execute automatically after a delete operation occurs on the PLAYER_GAMES table, and it is configured to fire once for each individual row that is deleted from that table; the trigger performs a single delete operation on the PLAYER_STATS table, using the condition that the PLAYER_ID column in PLAYER_STATS must be equal to the old value of the PLAYER_ID column from the deleted PLAYER_GAMES row, which is referenced as :OLD.PLAYER_ID, and simultaneously the GAME_ID column in PLAYER_STATS must be equal to the old value of the GAME_ID column from the deleted PLAYER_GAMES row, which is referenced as :OLD.GAME_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_player_games_cleanup\nAFTER DELETE ON PLAYER_GAMES\nFOR EACH ROW\nBEGIN\n    DELETE FROM PLAYER_STATS WHERE PLAYER_ID = :OLD.PLAYER_ID AND GAME_ID = :OLD.GAME_ID;\nEND;",
    "database_name": "sports_daa_visualization",
    "tables": [
      "PLAYERS",
      "PLAYER_GAMES",
      "PLAYER_STATS"
    ],
    "call_sqls": [
      "DELETE FROM PLAYER_GAMES WHERE PLAYER_ID = 1 AND GAME_ID = 0",
      "DELETE FROM PLAYER_GAMES WHERE PLAYER_ID = 0 AND GAME_ID = 0",
      "DELETE FROM PLAYER_GAMES WHERE PLAYER_ID = 1 AND GAME_ID = 1",
      "DELETE FROM PLAYER_GAMES WHERE PLAYER_ID = 2 AND GAME_ID = 0",
      "DELETE FROM PLAYER_GAMES WHERE PLAYER_ID = 3 AND GAME_ID = 1"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_player_games_cleanup that fires after each row is deleted from the PLAYER_GAMES table, and for each deleted row, removes any corresponding records from the PLAYER_STATS table where the PLAYER_ID matches the deleted PLAYER_ID and the GAME_ID matches the deleted GAME_ID.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_player_games_cleanup that runs after each row is deleted from the PLAYER_GAMES table, and for every deleted row, it removes the corresponding record from the PLAYER_STATS table where the PLAYER_ID matches the deleted PLAYER_ID and the GAME_ID matches the deleted GAME_ID.",
    "id": 23,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_player_games_cleanup that is defined to execute automatically after a delete operation occurs on the PLAYER_GAMES table, and it is configured to fire once for each individual row that is deleted from that table; the trigger performs a single delete operation on the PLAYER_STATS table, using the condition that the PLAYER_ID column in PLAYER_STATS must be equal to the old value of the PLAYER_ID column from the deleted PLAYER_GAMES row, which is referenced as :OLD.PLAYER_ID, and simultaneously the GAME_ID column in PLAYER_STATS must be equal to the old value of the GAME_ID column from the deleted PLAYER_GAMES row, which is referenced as :OLD.GAME_ID.",
    "original_summary": "Create an AFTER DELETE row-level trigger named trg_player_games_cleanup on the PLAYER_GAMES table. For each deleted row, delete from the PLAYER_STATS table where PLAYER_ID equals the old :OLD.PLAYER_ID and GAME_ID equals the old :OLD.GAME_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER DELETE row-level trigger designated as trg_player_games_cleanup on the PLAYER_GAMES table. The trigger's function is to execute a deletion from the PLAYER_STATS table for each row removed, specifically where the PLAYER_ID matches the former :OLD.PLAYER_ID value and the GAME_ID matches the former :OLD.GAME_ID value."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_after_assessment_insert` that is activated `AFTER` an `INSERT` operation occurs on the `ASSESSMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `ASSESSMENTS` table. Upon activation, for each newly inserted row in the `ASSESSMENTS` table, the trigger performs a single `INSERT` operation into the `ASSESSMENT_FORMS` table. The `INSERT` statement populates the columns of the `ASSESSMENT_FORMS` table with specific values. For the `FORM_ID` column, it calculates a new identifier by selecting the maximum existing `FORM_ID` from the `ASSESSMENT_FORMS` table using `SELECT MAX(FORM_ID) FROM ASSESSMENT_FORMS`, handles cases where no `FORM_ID` exists by defaulting to `0` using the `NVL` function (`NVL(MAX(FORM_ID), 0)`), and then increments this value by `1`. For the `ASSESSMENT_ID` column, it uses the `ASSESSMENT_ID` from the newly inserted row in the `ASSESSMENTS` table, referenced as `:NEW.ASSESSMENT_ID`. The `FORM_NAME` column is assigned the literal string value `'Default Form'`. The `TOTAL_QUESTIONS` column is set to the numeric literal `0`. The `DIFFICULTY_LEVEL` column is assigned the literal string value `'Moderate'`. The `DATE_CREATED` column is populated with the current system date, formatted as a string in 'YYYY-MM-DD' format using the `TO_CHAR` function with `SYSDATE`. Finally, the `FORM_DESCRIPTION` column is assigned the literal string value `'Auto-generated form'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_assessment_insert\nAFTER INSERT ON ASSESSMENTS\nFOR EACH ROW\nBEGIN\n   INSERT INTO ASSESSMENT_FORMS (FORM_ID, ASSESSMENT_ID, FORM_NAME, TOTAL_QUESTIONS, DIFFICULTY_LEVEL, DATE_CREATED, FORM_DESCRIPTION)\n   VALUES ((SELECT NVL(MAX(FORM_ID), 0) + 1 FROM ASSESSMENT_FORMS), :NEW.ASSESSMENT_ID, 'Default Form', 0, 'Moderate', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'Auto-generated form');\nEND;",
    "database_name": "educational_aaspt_766875",
    "tables": [
      "ASSESSMENTS",
      "ASSESSMENT_FORMS",
      "ASSESSMENT_QUESTIONS"
    ],
    "call_sqls": [
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (2, 'History Final', 'C', 60, '2024-05-20', 3, 'Final', 120)",
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (3, 'English Quiz', 'D', 10, '2024-05-21', 2, 'Quiz', 30)",
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (4, 'Physics Lab Test', 'E', 25, '2024-05-22', 5, 'Lab', 90)",
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (5, 'Chemistry Midterm', 'F', 40, '2024-05-23', 4, 'Midterm', 80)",
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (6, 'Biology Assessment', 'G', 35, '2024-05-24', 1, 'Assessment', 75)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_after_assessment_insert that fires after each row is inserted into the ASSESSMENTS table, and for each new row, automatically creates a corresponding record in the ASSESSMENT_FORMS table. The new record should assign a unique FORM_ID by taking the next available number after the highest existing FORM_ID in ASSESSMENT_FORMS, set the ASSESSMENT_ID to match the newly inserted ASSESSMENT_ID from ASSESSMENTS, and populate the remaining fields with default values: FORM_NAME as 'Default Form', TOTAL_QUESTIONS as 0, DIFFICULTY_LEVEL as 'Moderate', DATE_CREATED as today's date formatted as 'YYYY-MM-DD', and FORM_DESCRIPTION as 'Auto-generated form'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_after_assessment_insert that fires after each insert on the ASSESSMENTS table, and for every new row inserted, add a corresponding record to the ASSESSMENT_FORMS table, setting FORM_ID to one more than the current maximum FORM_ID from ASSESSMENT_FORMS (or 0 if none exist), ASSESSMENT_ID to the newly inserted ASSESSMENT_ID, FORM_NAME to 'Default Form', TOTAL_QUESTIONS to 0, DIFFICULTY_LEVEL to 'Moderate', DATE_CREATED to today's date in 'YYYY-MM-DD' format, and FORM_DESCRIPTION to 'Auto-generated form'.",
    "id": 24,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_after_assessment_insert` that is activated `AFTER` an `INSERT` operation occurs on the `ASSESSMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `ASSESSMENTS` table. Upon activation, for each newly inserted row in the `ASSESSMENTS` table, the trigger performs a single `INSERT` operation into the `ASSESSMENT_FORMS` table. The `INSERT` statement populates the columns of the `ASSESSMENT_FORMS` table with specific values. For the `FORM_ID` column, it calculates a new identifier by selecting the maximum existing `FORM_ID` from the `ASSESSMENT_FORMS` table using `SELECT MAX(FORM_ID) FROM ASSESSMENT_FORMS`, handles cases where no `FORM_ID` exists by defaulting to `0` using the `NVL` function (`NVL(MAX(FORM_ID), 0)`), and then increments this value by `1`. For the `ASSESSMENT_ID` column, it uses the `ASSESSMENT_ID` from the newly inserted row in the `ASSESSMENTS` table, referenced as `:NEW.ASSESSMENT_ID`. The `FORM_NAME` column is assigned the literal string value `'Default Form'`. The `TOTAL_QUESTIONS` column is set to the numeric literal `0`. The `DIFFICULTY_LEVEL` column is assigned the literal string value `'Moderate'`. The `DATE_CREATED` column is populated with the current system date, formatted as a string in 'YYYY-MM-DD' format using the `TO_CHAR` function with `SYSDATE`. Finally, the `FORM_DESCRIPTION` column is assigned the literal string value `'Auto-generated form'`.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_after_assessment_insert on the ASSESSMENTS table. For each inserted row, insert a new row into the ASSESSMENT_FORMS table. Set FORM_ID to NVL(MAX(FORM_ID), 0) + 1 from ASSESSMENT_FORMS. Set ASSESSMENT_ID to :NEW.ASSESSMENT_ID. Set FORM_NAME to 'Default Form', TOTAL_QUESTIONS to 0, DIFFICULTY_LEVEL to 'Moderate', DATE_CREATED to TO_CHAR(SYSDATE, 'YYYY-MM-DD'), and FORM_DESCRIPTION to 'Auto-generated form'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a row-level trigger called trg_after_assessment_insert that fires after each insert on the ASSESSMENTS table. For every new row inserted, add a corresponding record to the ASSESSMENT_FORMS table. Populate the fields as follows: set FORM_ID to one more than the current maximum FORM_ID from ASSESSMENT_FORMS (use 0 if none exist), set ASSESSMENT_ID to the newly inserted ASSESSMENT_ID, and set FORM_NAME to 'Default Form', TOTAL_QUESTIONS to 0, DIFFICULTY_LEVEL to 'Moderate', DATE_CREATED to today's date in 'YYYY-MM-DD' format, and FORM_DESCRIPTION to 'Auto-generated form'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_components_update that executes automatically before any row is updated in the COMPONENTS table, and within its execution block, it first declares three local NUMBER variables: v_count, v_notification_id, and v_history_id; then it calculates a new notification identifier by selecting the maximum existing NOTIFICATION_ID value from the NOTIFICATIONS table, using the NVL function to treat NULL as zero, and adding one to that result, storing it in v_notification_id; it similarly calculates a new history identifier by selecting the maximum existing HISTORY_ID value from the COMPONENT_SPECIFICATIONS_HISTORY table, using NVL to treat NULL as zero, and adding one, storing it in v_history_id; then, using a conditional IF statement, it checks if the new STOCK_QUANTITY value for the updated component row (referenced as :NEW.STOCK_QUANTITY) is less than 50, and if this condition is true, it performs an INSERT into the NOTIFICATIONS table, specifying columns NOTIFICATION_ID with the generated v_notification_id, COMPONENT_ID with the new COMPONENT_ID value (:NEW.COMPONENT_ID), USER_ID as NULL, NOTIFICATION_DATE as the current system date converted to a 'YYYY-MM-DD' format string using TO_CHAR(SYSDATE, 'YYYY-MM-DD'), NOTIFICATION_TYPE as the literal string 'low_stock', STATUS as 'sent', MESSAGE as 'Stock is low', and LAST_UPDATED as the same formatted system date; following this conditional insert, it performs an unconditional INSERT into the COMPONENT_SPECIFICATIONS_HISTORY table, specifying columns HISTORY_ID with the generated v_history_id, COMPONENT_ID with :NEW.COMPONENT_ID, SPECIFICATION_ID as NULL, UPDATE_DATE as the formatted system date, CHANGE_DESCRIPTION as 'Component updated', CHANGED_BY as 'System', and LAST_UPDATED as the formatted system date; then it executes a DELETE operation on the ACCESS_LOGS table, removing any rows where the COMPONENT_ID column matches the new COMPONENT_ID (:NEW.COMPONENT_ID) and the ACCESS_TYPE column equals the literal string 'view'; subsequently, it performs a SELECT COUNT(*) query on the SPECIFICATIONS table, counting all rows where the COMPONENT_ID matches :NEW.COMPONENT_ID, and stores the result in the v_count variable; finally, it executes an UPDATE on the VERSIONS table, setting the APPROVED_BY column to the literal string 'System' for every row where the SPECIFICATION_ID is found in the result set of a subquery that selects SPECIFICATION_ID from the SPECIFICATIONS table for rows where the COMPONENT_ID equals :NEW.COMPONENT_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_components_update\nBEFORE UPDATE ON COMPONENTS\nFOR EACH ROW\nDECLARE\n  v_count NUMBER;\n  v_notification_id NUMBER;\n  v_history_id NUMBER;\nBEGIN\n  -- Generate IDs manually\n  SELECT NVL(MAX(NOTIFICATION_ID), 0) + 1 INTO v_notification_id FROM NOTIFICATIONS;\n  SELECT NVL(MAX(HISTORY_ID), 0) + 1 INTO v_history_id FROM COMPONENT_SPECIFICATIONS_HISTORY;\n  \n  IF :NEW.STOCK_QUANTITY < 50 THEN\n    INSERT INTO NOTIFICATIONS (NOTIFICATION_ID, COMPONENT_ID, USER_ID, NOTIFICATION_DATE, NOTIFICATION_TYPE, STATUS, MESSAGE, LAST_UPDATED)\n    VALUES (v_notification_id, :NEW.COMPONENT_ID, NULL, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'low_stock', 'sent', 'Stock is low', TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\n  END IF;\n  \n  INSERT INTO COMPONENT_SPECIFICATIONS_HISTORY (HISTORY_ID, COMPONENT_ID, SPECIFICATION_ID, UPDATE_DATE, CHANGE_DESCRIPTION, CHANGED_BY, LAST_UPDATED)\n  VALUES (v_history_id, :NEW.COMPONENT_ID, NULL, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'Component updated', 'System', TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\n  \n  DELETE FROM ACCESS_LOGS WHERE COMPONENT_ID = :NEW.COMPONENT_ID AND ACCESS_TYPE = 'view';\n  \n  SELECT COUNT(*) INTO v_count FROM SPECIFICATIONS WHERE COMPONENT_ID = :NEW.COMPONENT_ID;\n  \n  UPDATE VERSIONS SET APPROVED_BY = 'System' \n  WHERE SPECIFICATION_ID IN (SELECT SPECIFICATION_ID FROM SPECIFICATIONS WHERE COMPONENT_ID = :NEW.COMPONENT_ID);\nEND;",
    "database_name": "electronic_csa_documentat",
    "tables": [
      "COMPONENTS",
      "SPECIFICATIONS",
      "COMPONENT_SPECIFICATIONS_HISTORY",
      "VERSIONS",
      "ACCESS_LOGS",
      "USERS",
      "NOTIFICATIONS"
    ],
    "call_sqls": [
      "UPDATE COMPONENTS SET STOCK_QUANTITY = 40 WHERE COMPONENT_ID = 0",
      "UPDATE COMPONENTS SET STOCK_QUANTITY = 100 WHERE COMPONENT_ID = 1",
      "UPDATE COMPONENTS SET COMPONENT_NAME = 'New Microcontroller', STOCK_QUANTITY = 30 WHERE COMPONENT_ID = 0",
      "UPDATE COMPONENTS SET DESCRIPTION = 'Updated description for NPN Transistor', STOCK_QUANTITY = 45 WHERE COMPONENT_ID = 1",
      "UPDATE COMPONENTS SET MANUFACTURER = 'STMicroelectronics', STOCK_QUANTITY = 20 WHERE COMPONENT_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_components_update that fires before each row is updated in the COMPONENTS table. If the updated STOCK_QUANTITY falls below 50, insert a 'low_stock' notification into the NOTIFICATIONS table for that component. Then, always insert a history record into COMPONENT_SPECIFICATIONS_HISTORY for the component. Next, delete all 'view' type entries from ACCESS_LOGS for the component. Finally, count the related specifications for the component and update the VERSIONS table to set APPROVED_BY to 'System' for those specifications.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_components_update that fires before each update on the COMPONENTS table. If the updated STOCK_QUANTITY is less than 50, insert a low_stock notification into the NOTIFICATIONS table for that component. Then, insert a record into COMPONENT_SPECIFICATIONS_HISTORY to log the update. Also, delete any 'view' entries from ACCESS_LOGS for this component, count the related specifications, and update the VERSIONS table to set APPROVED_BY to 'System' for those specifications.",
    "id": 25,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_components_update` that is activated `BEFORE` an `UPDATE` operation occurs on the `COMPONENTS` table. This trigger is configured to execute `FOR EACH ROW` that is updated in the `COMPONENTS` table. Within the `DECLARE` section, a local variable named `v_spec_count` of data type `NUMBER` is declared to temporarily store the count of related specifications. The `BEGIN` block initiates the trigger's logic. The first operation is a conditional check using an `IF` statement. The condition evaluates whether the new value of the `STOCK_QUANTITY` column from the updated row, referenced as `:NEW.STOCK_QUANTITY`, is less than the numeric literal `50`. If this condition is true, the trigger executes an `INSERT` statement into the `NOTIFICATIONS` table. This `INSERT` statement specifies values for the following columns: the `component_id` column is set to the new value of the `COMPONENT_ID` column from the updated row in the `COMPONENTS` table, referenced as `:NEW.COMPONENT_ID`; the `notification_type` column is set to the string literal `'low_stock'`; the `message` column is set to a concatenated string formed by joining the string literal `'Low stock alert for component ID: '` with the character string representation of `:NEW.COMPONENT_ID`; the `created_at` column is set to the current system date and time using `SYSDATE`. Following this conditional block, the trigger executes an `INSERT` statement into the `COMPONENT_SPECIFICATIONS_HISTORY` table to log the update. This `INSERT` statement specifies values for the following columns: the `component_id` column is set to `:NEW.COMPONENT_ID`; the `old_stock_quantity` column is set to the old value of the `STOCK_QUANTITY` column from the updated row, referenced as `:OLD.STOCK_QUANTITY`; the `new_stock_quantity` column is set to `:NEW.STOCK_QUANTITY`; the `updated_at` column is set to `SYSDATE`. Next, the trigger executes a `DELETE` statement on the `ACCESS_LOGS` table. This `DELETE` statement removes rows where the `component_id` column equals `:NEW.COMPONENT_ID` and the `action` column equals the string literal `'view'`. After the deletion, the trigger executes a `SELECT` statement with a `COUNT` aggregation. This statement counts the number of rows in the `COMPONENT_SPECIFICATIONS` table where the `component_id` column equals `:NEW.COMPONENT_ID`. The result of this count is stored into the local variable `v_spec_count`. Finally, the trigger executes an `UPDATE` statement on the `VERSIONS` table. This `UPDATE` statement sets the `APPROVED_BY` column to the string literal `'System'`. The update is conditioned by a `WHERE` clause that uses a subquery. The subquery selects the `specification_id` column from the `COMPONENT_SPECIFICATIONS` table where the `component_id` column equals `:NEW.COMPONENT_ID`. The main `UPDATE` statement's `WHERE` clause then specifies that the `specification_id` column in the `VERSIONS` table must be `IN` the set of `specification_id` values returned by the subquery.",
    "original_summary": "Create a BEFORE UPDATE row-level trigger named trg_components_update on the COMPONENTS table. If the new STOCK_QUANTITY is below 50, insert a 'low_stock' notification into the NOTIFICATIONS table with a generated ID. Then, insert a history record into COMPONENT_SPECIFICATIONS_HISTORY. Next, delete 'view' type entries from ACCESS_LOGS for this component. Finally, count related specifications and update the VERSIONS table to set APPROVED_BY to 'System' for those specifications.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create trigger trg_components_update on COMPONENTS before update. If new STOCK_QUANTITY < 50, insert low_stock notification into NOTIFICATIONS. Then insert record into COMPONENT_SPECIFICATIONS_HISTORY. Delete 'view' entries from ACCESS_LOGS for this component. Count related specs and update VERSIONS to set APPROVED_BY to 'System'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named deactivate_alert_on_trade that executes automatically before any new row is inserted into the TRADING_SESSIONS table for each individual row being inserted, and its operation is to delete rows from the ALERTS table where the USER_ID column matches the new USER_ID value from the inserted TRADING_SESSIONS row and the INSTRUMENT_ID column matches the new INSTRUMENT_ID value from the inserted TRADING_SESSIONS row and the IS_ACTIVE column has a value of 1.",
    "plsql": "CREATE OR REPLACE TRIGGER deactivate_alert_on_trade\nBEFORE INSERT ON TRADING_SESSIONS\nFOR EACH ROW\nBEGIN\n    DELETE FROM ALERTS WHERE USER_ID = :NEW.USER_ID AND INSTRUMENT_ID = :NEW.INSTRUMENT_ID AND IS_ACTIVE = 1;\nEND;",
    "database_name": "financial_mda_404480",
    "tables": [
      "ALERTS",
      "INSTRUMENTS",
      "MARKET_DATA",
      "PORTFOLIO",
      "PORTFOLIO_POSITIONS",
      "TRADING_SESSIONS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO TRADING_SESSIONS (SESSION_ID, USER_ID, INSTRUMENT_ID, SESSION_DATE, START_TIME, END_TIME, SESSION_STATUS, SESSION_NOTES) VALUES (0, 0, 0, '2023-09-01', '09:00:00', '09:30:00', 'active', 'Initial session for user 0, instrument 0')",
      "INSERT INTO TRADING_SESSIONS (SESSION_ID, USER_ID, INSTRUMENT_ID, SESSION_DATE, START_TIME, END_TIME, SESSION_STATUS, SESSION_NOTES) VALUES (1, 1, 1, '2023-09-02', '10:00:00', '10:30:00', 'active', 'Session for user 1, instrument 1')",
      "INSERT INTO TRADING_SESSIONS (SESSION_ID, USER_ID, INSTRUMENT_ID, SESSION_DATE, START_TIME, END_TIME, SESSION_STATUS, SESSION_NOTES) VALUES (2, 0, 1, '2023-09-03', '11:00:00', '11:30:00', 'active', 'Another session for user 0, instrument 1')",
      "INSERT INTO TRADING_SESSIONS (SESSION_ID, USER_ID, INSTRUMENT_ID, SESSION_DATE, START_TIME, END_TIME, SESSION_STATUS, SESSION_NOTES) VALUES (3, 1, 0, '2023-09-04', '12:00:00', '12:30:00', 'active', 'Session for user 1, instrument 0')",
      "INSERT INTO TRADING_SESSIONS (SESSION_ID, USER_ID, INSTRUMENT_ID, SESSION_DATE, START_TIME, END_TIME, SESSION_STATUS, SESSION_NOTES) VALUES (4, 0, 0, '2023-09-05', '13:00:00', '13:30:00', 'active', 'Repeated session for user 0, instrument 0')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named deactivate_alert_on_trade that fires BEFORE INSERT on the TRADING_SESSIONS table for each new row, and deletes any records from the ALERTS table where the USER_ID and INSTRUMENT_ID match the new TRADING_SESSIONS row's USER_ID and INSTRUMENT_ID and the ALERTS record has IS_ACTIVE set to 1.",
    "natural_language": "Hey, write a Oracle PL/SQL trigger called deactivate_alert_on_trade for the TRADING_SESSIONS table that fires before a new row is inserted. Whenever a new trade session is added, it should remove any active alerts for that same user and instrument by deleting records from the ALERTS table where USER_ID and INSTRUMENT_ID match the new session and IS_ACTIVE is 1.",
    "id": 26,
    "generated_ir": "Write an Oracle PL/SQL trigger named deactivate_alert_on_trade that executes automatically before any new row is inserted into the TRADING_SESSIONS table for each individual row being inserted, and its operation is to delete rows from the ALERTS table where the USER_ID column matches the new USER_ID value from the inserted TRADING_SESSIONS row and the INSTRUMENT_ID column matches the new INSTRUMENT_ID value from the inserted TRADING_SESSIONS row and the IS_ACTIVE column has a value of 1.",
    "original_summary": "Create a BEFORE INSERT row-level trigger on TRADING_SESSIONS named deactivate_alert_on_trade. For each new row, delete records from the ALERTS table where the USER_ID and INSTRUMENT_ID match the new row's values and IS_ACTIVE equals 1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, set up a trigger called deactivate_alert_on_trade for the TRADING_SESSIONS table that fires before a new row is inserted. Every time a new trade session pops in, it should clean out any active alerts for that same user and instrument by deleting matching records from the ALERTS table where IS_ACTIVE is set to 1."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CRIME_DATA_YEAR_CHECK that executes automatically before each row insertion into the CRIME_DATA table, declaring a local variable v_max_year of type NUMBER, then performing a SELECT query on the CRIME_DATA table to retrieve the maximum existing YEAR value for rows where the STATION_ID column matches the new row's STATION_ID value (referenced as :NEW.STATION_ID) and the CATEGORY_ID column matches the new row's CATEGORY_ID value (referenced as :NEW.CATEGORY_ID), storing the result into v_max_year, and subsequently assigning a value to the new row's YEAR column (referenced as :NEW.YEAR) by using the NVL function to evaluate v_max_year, returning v_max_year if it is not null or returning the literal value 2000 if v_max_year is null, and then adding 1 to that result.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CRIME_DATA_YEAR_CHECK\nBEFORE INSERT ON CRIME_DATA\nFOR EACH ROW\nDECLARE\n    v_max_year NUMBER;\nBEGIN\n    SELECT MAX(YEAR)\n    INTO v_max_year\n    FROM CRIME_DATA\n    WHERE STATION_ID = :NEW.STATION_ID\n      AND CATEGORY_ID = :NEW.CATEGORY_ID;\n    \n    :NEW.YEAR := NVL(v_max_year, 2000) + 1;\nEND;",
    "database_name": "crime_saa_9910",
    "tables": [
      "CRIME_CATEGORIES",
      "CRIME_DATA",
      "DATA_METADATA",
      "DATA_SOURCES",
      "POLICE_STATIONS",
      "PROVINCES"
    ],
    "call_sqls": [
      "INSERT INTO CRIME_DATA (DATA_ID, STATION_ID, CATEGORY_ID, COUNT) VALUES (100, 1, 1, 500)",
      "INSERT INTO CRIME_DATA (DATA_ID, STATION_ID, CATEGORY_ID, COUNT) VALUES (101, 1, 1, 600)",
      "INSERT INTO CRIME_DATA (DATA_ID, STATION_ID, CATEGORY_ID, COUNT) VALUES (102, 2, 0, 700)",
      "INSERT INTO CRIME_DATA (DATA_ID, STATION_ID, CATEGORY_ID, COUNT) VALUES (103, 1, 0, 800)",
      "INSERT INTO CRIME_DATA (DATA_ID, STATION_ID, CATEGORY_ID, COUNT) VALUES (104, 2, 1, 900)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_CRIME_DATA_YEAR_CHECK that fires BEFORE INSERT on the CRIME_DATA table for each new row, and automatically sets the YEAR column for the new record by finding the maximum existing YEAR for matching STATION_ID and CATEGORY_ID, defaulting to 2000 if no previous records exist, then incrementing that value by 1.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_CRIME_DATA_YEAR_CHECK that runs before inserting each new row into the CRIME_DATA table. For each insertion, it should determine the next year number by finding the highest existing YEAR for rows with the same STATION_ID and CATEGORY_ID as the new row; if no such row exists, use 2000 as the base. Then, increment that value by one and assign it to the YEAR field of the new row.",
    "id": 27,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_CRIME_DATA_YEAR_CHECK that is executed before an insert operation on each row of the CRIME_DATA table. This trigger operates on each row before it is inserted into the table. The trigger declares a local NUMBER variable named v_next_year. The trigger's logic begins by performing a SELECT operation on the CRIME_DATA table. It selects the maximum existing value of the YEAR column, using the MAX aggregate function, for rows where the STATION_ID column matches the value of :NEW.STATION_ID and the CATEGORY_ID column matches the value of :NEW.CATEGORY_ID. This query is executed with the INTO clause to store the result directly into the v_next_year variable. If the SELECT statement finds no matching rows, the MAX function returns NULL. The trigger uses the NVL function to handle this NULL case: if the result is NULL, the NVL function substitutes the value 2000. After obtaining this base value, the trigger increments it by 1. The trigger then assigns this calculated value, which is the incremented base year, to the YEAR field of the new row being inserted, specifically by setting :NEW.YEAR equal to v_next_year + 1.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named TRG_CRIME_DATA_YEAR_CHECK on the CRIME_DATA table. For each new row, calculate the next YEAR value by selecting the maximum existing YEAR for matching STATION_ID and CATEGORY_ID, using NVL to default to 2000 if null, then adding 1. Assign this result to :NEW.YEAR.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the crime data table that runs before adding new entries. For each new row, it should figure out the next year number. Do this by looking at the most recent year for similar station and category combinations, and if there isn't one, just start from around 2000, then bump it up by one. Put that calculated value into the new row's year field."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_coordinates that is defined to fire automatically after each new row is inserted into the LATITUDE_DATA table, and for each row inserted, it declares a local variable v_dataset_name of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT query on the DATASETS table to retrieve the NAME column value for the row where the DATASET_ID column matches the newly inserted DATASET_ID value from the LATITUDE_DATA row (referenced as :NEW.DATASET_ID), storing the result into the v_dataset_name variable, and subsequently executes an INSERT operation into the LONGITUDE_DATA table, populating its columns with the following values: the LONGITUDE_ID column is set to the newly inserted LATITUDE_ID value (referenced as :NEW.LATITUDE_ID) incremented by 1000, the DATASET_ID column is set to the same :NEW.DATASET_ID value, the LONGITUDE column is set to a constant numeric value of 0.0, the GEOGRAPHICAL_ACCURACY column is set to the newly inserted GEOGRAPHICAL_ACCURACY value (referenced as :NEW.GEOGRAPHICAL_ACCURACY), and the SOURCE_OF_COORDINATES column is set to the v_dataset_name value retrieved from the DATASETS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_coordinates\nAFTER INSERT ON LATITUDE_DATA\nFOR EACH ROW\nDECLARE\n  v_dataset_name VARCHAR2(255);\nBEGIN\n  SELECT NAME INTO v_dataset_name FROM DATASETS WHERE DATASET_ID = :NEW.DATASET_ID;\n  INSERT INTO LONGITUDE_DATA (LONGITUDE_ID, DATASET_ID, LONGITUDE, GEOGRAPHICAL_ACCURACY, SOURCE_OF_COORDINATES)\n  VALUES (:NEW.LATITUDE_ID + 1000, :NEW.DATASET_ID, 0.0, :NEW.GEOGRAPHICAL_ACCURACY, v_dataset_name);\nEND;",
    "database_name": "geographic_adda_941845",
    "tables": [
      "DATASETS",
      "DATASET_CATEGORIES",
      "DATA_FILES",
      "LATITUDE_DATA",
      "LONGITUDE_DATA"
    ],
    "call_sqls": [
      "INSERT INTO LATITUDE_DATA (LATITUDE_ID, DATASET_ID, LATITUDE, GEOGRAPHICAL_ACCURACY, SOURCE_OF_COORDINATES) VALUES (2, 0, 34.05, '10 meters', 'GPS')",
      "INSERT INTO LATITUDE_DATA (LATITUDE_ID, DATASET_ID, LATITUDE, GEOGRAPHICAL_ACCURACY, SOURCE_OF_COORDINATES) VALUES (3, 1, 37.77, '5 meters', 'Survey')",
      "INSERT INTO LATITUDE_DATA (LATITUDE_ID, DATASET_ID, LATITUDE, GEOGRAPHICAL_ACCURACY, SOURCE_OF_COORDINATES) VALUES (4, 0, 33.99, '20 meters', 'Manual')",
      "INSERT INTO LATITUDE_DATA (LATITUDE_ID, DATASET_ID, LATITUDE, GEOGRAPHICAL_ACCURACY, SOURCE_OF_COORDINATES) VALUES (5, 1, 34.00, '15 meters', 'GPS')",
      "INSERT INTO LATITUDE_DATA (LATITUDE_ID, DATASET_ID, LATITUDE, GEOGRAPHICAL_ACCURACY, SOURCE_OF_COORDINATES) VALUES (6, 0, 35.12, '10 meters', 'Survey')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_sync_coordinates that fires after each new row is inserted into the LATITUDE_DATA table. For each insertion, retrieve the NAME from the DATASETS table corresponding to the new row's DATASET_ID, then insert a matching record into the LONGITUDE_DATA table with LONGITUDE_ID set to the new LATITUDE_ID plus 1000, DATASET_ID set to the new DATASET_ID, LONGITUDE set to 0.0, GEOGRAPHICAL_ACCURACY set to the new GEOGRAPHICAL_ACCURACY, and SOURCE_OF_COORDINATES set to the retrieved dataset name.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_sync_coordinates that fires after a new row is inserted into the LATITUDE_DATA table, and for each new row, retrieves the NAME from the DATASETS table using the new row's DATASET_ID, then inserts a corresponding row into the LONGITUDE_DATA table with LONGITUDE_ID set to the new LATITUDE_ID plus 1000, the same DATASET_ID, LONGITUDE set to 0.0, the same GEOGRAPHICAL_ACCURACY, and SOURCE_OF_COORDINATES set to the retrieved dataset name.",
    "id": 28,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_sync_coordinates that is defined to fire automatically after each new row is inserted into the LATITUDE_DATA table, and for each row inserted, it declares a local variable v_dataset_name of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT query on the DATASETS table to retrieve the NAME column value for the row where the DATASET_ID column matches the newly inserted DATASET_ID value from the LATITUDE_DATA row (referenced as :NEW.DATASET_ID), storing the result into the v_dataset_name variable, and subsequently executes an INSERT operation into the LONGITUDE_DATA table, populating its columns with the following values: the LONGITUDE_ID column is set to the newly inserted LATITUDE_ID value (referenced as :NEW.LATITUDE_ID) incremented by 1000, the DATASET_ID column is set to the same :NEW.DATASET_ID value, the LONGITUDE column is set to a constant numeric value of 0.0, the GEOGRAPHICAL_ACCURACY column is set to the newly inserted GEOGRAPHICAL_ACCURACY value (referenced as :NEW.GEOGRAPHICAL_ACCURACY), and the SOURCE_OF_COORDINATES column is set to the v_dataset_name value retrieved from the DATASETS table.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_sync_coordinates on the LATITUDE_DATA table. For each new row, get the DATASET NAME from the DATASETS table using the new DATASET_ID. Then insert a corresponding row into the LONGITUDE_DATA table, setting LONGITUDE_ID to :NEW.LATITUDE_ID + 1000, DATASET_ID to :NEW.DATASET_ID, LONGITUDE to 0.0, GEOGRAPHICAL_ACCURACY to :NEW.GEOGRAPHICAL_ACCURACY, and SOURCE_OF_COORDINATES to the retrieved dataset name.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires after a new row is added to the LATITUDE_DATA table. Let's call it trg_sync_coordinates. Every time a new entry pops in, we gotta look up the DATASET NAME from the DATASETS table using the new row's DATASET_ID. Then, we'll toss a matching row into the LONGITUDE_DATA table. For that new row, set LONGITUDE_ID to the new LATITUDE_ID plus 1000, keep the same DATASET_ID, set LONGITUDE to 0.0, copy over the GEOGRAPHICAL_ACCURACY, and for the SOURCE_OF_COORDINATES, just plug in the dataset name we just fetched."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named create_user_portfolio that is defined to fire automatically after a new row is inserted into the USERS table, executing once for each inserted row, and within its body performs a single INSERT operation into the PORTFOLIO table, specifying values for the columns PORTFOLIO_ID, USER_ID, PORTFOLIO_NAME, and CREATION_DATE, where the PORTFOLIO_ID is statically set to the integer 3, the USER_ID is dynamically bound to the newly inserted USER_ID value from the triggering USERS table row using the :NEW.USER_ID reference, the PORTFOLIO_NAME is statically set to the string literal 'Default Portfolio', and the CREATION_DATE is derived by calling the TO_CHAR function on the result of the CURRENT_DATE function, using the date format model 'YYYY-MM-DD' to convert the current date into a string representation.",
    "plsql": "CREATE OR REPLACE TRIGGER create_user_portfolio\nAFTER INSERT ON USERS\nFOR EACH ROW\nBEGIN\n    INSERT INTO PORTFOLIO (PORTFOLIO_ID, USER_ID, PORTFOLIO_NAME, CREATION_DATE) VALUES (3, :NEW.USER_ID, 'Default Portfolio', TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'));\nEND;",
    "database_name": "financial_mda_404480",
    "tables": [
      "ALERTS",
      "INSTRUMENTS",
      "MARKET_DATA",
      "PORTFOLIO",
      "PORTFOLIO_POSITIONS",
      "TRADING_SESSIONS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, ORGANIZATION, PHONE_NUMBER, CREATION_DATE) VALUES (2, 'Charlie Brown', 'charlie.brown@fintech.com', 'manager', 'Fintech Inc.', '+1 555 222 3333', '2023-10-01')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, ORGANIZATION, PHONE_NUMBER, CREATION_DATE) VALUES (3, 'Diana Prince', 'diana.prince@fintech.com', 'analyst', 'Fintech Inc.', '+1 555 444 5555', '2023-10-02')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, ORGANIZATION, PHONE_NUMBER, CREATION_DATE) VALUES (4, 'Eve Adams', 'eve.adams@fintech.com', 'trader', 'Fintech Inc.', '+1 555 666 7777', '2023-10-03')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, ORGANIZATION, PHONE_NUMBER, CREATION_DATE) VALUES (5, 'Frank Castle', 'frank.castle@fintech.com', 'analyst', 'Fintech Inc.', '+1 555 888 9999', '2023-10-04')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, ORGANIZATION, PHONE_NUMBER, CREATION_DATE) VALUES (6, 'Grace Hopper', 'grace.hopper@fintech.com', 'developer', 'Fintech Inc.', '+1 555 000 1111', '2023-10-05')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named create_user_portfolio that fires after each new row is inserted into the USERS table, and for each new user, automatically inserts a default portfolio record into the PORTFOLIO table with a PORTFOLIO_ID of 3, the USER_ID from the new user, a PORTFOLIO_NAME set to 'Default Portfolio', and the CREATION_DATE as the current date formatted as 'YYYY-MM-DD'.",
    "natural_language": "Write a Oracle PL/SQL trigger named create_user_portfolio that runs after each new row is inserted into the USERS table, automatically adding a default portfolio entry into the PORTFOLIO table for every new user, assigning a PORTFOLIO_ID of 3, using the inserted user's USER_ID, setting the PORTFOLIO_NAME to 'Default Portfolio', and recording the CREATION_DATE as the current date formatted as 'YYYY-MM-DD'.",
    "id": 29,
    "generated_ir": "Write an Oracle PL/SQL trigger named create_user_portfolio that is executed automatically after an INSERT operation is performed on the USERS table. This trigger operates for each row affected by the INSERT statement. The trigger's main functionality is to insert a new record into the PORTFOLIO table for every newly inserted user. The trigger uses the USER_ID from the newly inserted row in the USERS table, referenced as :NEW.USER_ID, to populate the corresponding column in the PORTFOLIO table. It assigns a fixed PORTFOLIO_ID value of 3 to the new portfolio entry. The PORTFOLIO_NAME column is set to the string 'Default Portfolio'. The CREATION_DATE column is populated with the current system date, formatted as a string in the 'YYYY-MM-DD' format, which is obtained by applying the TO_CHAR function to the SYSDATE function. This ensures that each new user automatically receives a default portfolio entry with predefined attributes upon their creation in the USERS table.",
    "original_summary": "Create an AFTER INSERT row-level trigger on USERS named create_user_portfolio. For each new user, insert a default portfolio into the PORTFOLIO table with PORTFOLIO_ID=3, USER_ID from the new row, PORTFOLIO_NAME='Default Portfolio', and CREATION_DATE as the current date formatted 'YYYY-MM-DD'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create an AFTER INSERT row-level trigger called create_user_portfolio on the USERS table. For every new user inserted, have the trigger insert a default portfolio into the PORTFOLIO table. Set the PORTFOLIO_ID to 3, use the new row's USER_ID, set the PORTFOLIO_NAME to 'Default Portfolio', and set the CREATION_DATE to the current date in 'YYYY-MM-DD' format."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_countries_before_update_currency` that is configured to execute `BEFORE` any `UPDATE` operation on the `CURRENCY` column of the `COUNTRIES` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for each individual row that is being updated. The purpose of this trigger is to automatically set the `TIME_ZONE` column of the row being updated based on the new value of the `CURRENCY` column. Specifically, within the trigger's `BEGIN...END` block, the `TIME_ZONE` column of the `NEW` row image (represented by `:NEW.TIME_ZONE`) is assigned a value determined by a `CASE` statement. The `CASE` statement evaluates the new value of the `CURRENCY` column (represented by `:NEW.CURRENCY`). If the `:NEW.CURRENCY` value contains the substring 'Euro' (case-sensitive match, e.g., 'Eurozone', 'Euro'), then `:NEW.TIME_ZONE` is set to the string literal 'CET'. If the `:NEW.CURRENCY` value contains the substring 'Dollar' (case-sensitive match, e.g., 'US Dollar', 'Dollar'), then `:NEW.TIME_ZONE` is set to the string literal 'EST'. If neither of these conditions is met, meaning the `:NEW.CURRENCY` value does not contain 'Euro' and does not contain 'Dollar', then `:NEW.TIME_ZONE` is set to the string literal 'UTC'. This assignment to `:NEW.TIME_ZONE` occurs before the actual update operation is committed to the `COUNTRIES` table, effectively modifying the `TIME_ZONE` column as part of the same update statement that changed the `CURRENCY` column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_countries_before_update_currency\nBEFORE UPDATE OF CURRENCY ON COUNTRIES\nFOR EACH ROW\nBEGIN\n  :NEW.TIME_ZONE := CASE \n    WHEN :NEW.CURRENCY LIKE '%Euro%' THEN 'CET'\n    WHEN :NEW.CURRENCY LIKE '%Dollar%' THEN 'EST'\n    ELSE 'UTC'\n  END;\nEND;",
    "database_name": "global_haed_analysis",
    "tables": [
      "COUNTRIES"
    ],
    "call_sqls": [
      "UPDATE COUNTRIES SET CURRENCY = 'Euro' WHERE COUNTRY_ID = 0",
      "UPDATE COUNTRIES SET CURRENCY = 'US Dollar' WHERE COUNTRY_ID = 1",
      "UPDATE COUNTRIES SET CURRENCY = 'Canadian Dollar' WHERE COUNTRY_ID = 0",
      "UPDATE COUNTRIES SET CURRENCY = 'Australian Dollar' WHERE COUNTRY_ID = 1",
      "UPDATE COUNTRIES SET CURRENCY = 'Euro' WHERE COUNTRY_ID = 1"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_countries_before_update_currency that fires before updating the CURRENCY column on the COUNTRIES table for each row, and sets the TIME_ZONE to 'CET' if the new CURRENCY value contains 'Euro', to 'EST' if it contains 'Dollar', or to 'UTC' otherwise.",
    "natural_language": "Hey, can you write a Oracle PL/SQL trigger called trg_countries_before_update_currency that fires before an update on the COUNTRIES table, specifically when the CURRENCY column is being changed? For each updated row, determine the TIME_ZONE based on the new CURRENCY value: if it contains 'Euro', set TIME_ZONE to 'CET'; if it contains 'Dollar', set it to 'EST'; otherwise, default to 'UTC'.",
    "id": 30,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_countries_before_update_currency` that is configured to execute `BEFORE` any `UPDATE` operation on the `CURRENCY` column of the `COUNTRIES` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for each individual row that is being updated. The purpose of this trigger is to automatically set the `TIME_ZONE` column of the row being updated based on the new value of the `CURRENCY` column. Specifically, within the trigger's `BEGIN...END` block, the `TIME_ZONE` column of the `NEW` row image (represented by `:NEW.TIME_ZONE`) is assigned a value determined by a `CASE` statement. The `CASE` statement evaluates the new value of the `CURRENCY` column (represented by `:NEW.CURRENCY`). If the `:NEW.CURRENCY` value contains the substring 'Euro' (case-sensitive match, e.g., 'Eurozone', 'Euro'), then `:NEW.TIME_ZONE` is set to the string literal 'CET'. If the `:NEW.CURRENCY` value contains the substring 'Dollar' (case-sensitive match, e.g., 'US Dollar', 'Dollar'), then `:NEW.TIME_ZONE` is set to the string literal 'EST'. If neither of these conditions is met, meaning the `:NEW.CURRENCY` value does not contain 'Euro' and does not contain 'Dollar', then `:NEW.TIME_ZONE` is set to the string literal 'UTC'. This assignment to `:NEW.TIME_ZONE` occurs before the actual update operation is committed to the `COUNTRIES` table, effectively modifying the `TIME_ZONE` column as part of the same update statement that changed the `CURRENCY` column.",
    "original_summary": "Create a BEFORE UPDATE row-level trigger named trg_countries_before_update_currency on the COUNTRIES table that fires when the CURRENCY column is updated. For each updated row, set the TIME_ZONE based on the new CURRENCY value: 'CET' if it contains 'Euro', 'EST' if it contains 'Dollar', otherwise 'UTC'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, can you set up a trigger for me? I need a row-level trigger called trg_countries_before_update_currency on the COUNTRIES table. It should kick in right before an update, but only when someone's messing with the CURRENCY column. For each row that gets updated, we gotta figure out the TIME_ZONE based on the new currency. If the new currency's got 'Euro' in it, set the time zone to 'CET'. If it's got 'Dollar', go with 'EST'. For anything else, just default it to 'UTC'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_reports_upper_report_type that is executed before an insert or update operation on the REPORTS table for each row being affected. The trigger first converts the value of the REPORT_TYPE column in the new row to uppercase using the UPPER() function, ensuring that the report type is stored in a consistent format. It then checks if the USER_ID column in the new row is not null. If USER_ID is not null, the trigger attempts to validate the existence of this USER_ID in the USERS table. It does this by selecting a constant value of 1 into a local variable v_user_exists from the DUAL table, conditioned on the existence of a row in the USERS table with a matching USER_ID. If no such row exists, a NO_DATA_FOUND exception is raised, which is caught by the exception handling block. In this case, the trigger sets the USER_ID column in the new row to null, assuming that the constraint allows for null values or a default valid USER_ID. This ensures that only valid USER_IDs are stored in the REPORTS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_reports_upper_report_type\nBEFORE INSERT OR UPDATE ON REPORTS\nFOR EACH ROW\nDECLARE\n    v_user_exists NUMBER;\nBEGIN\n    -- Convert REPORT_TYPE to uppercase\n    :NEW.REPORT_TYPE := UPPER(:NEW.REPORT_TYPE);\n    \n    -- Validate USER_ID exists (assuming USERS table exists)\n    IF :NEW.USER_ID IS NOT NULL THEN\n        BEGIN\n            SELECT 1 INTO v_user_exists \n            FROM DUAL \n            WHERE EXISTS (SELECT 1 FROM USERS WHERE USER_ID = :NEW.USER_ID);\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n                -- Set to NULL or a default valid USER_ID if constraint allows\n                :NEW.USER_ID := NULL;\n        END;\n    END IF;\nEND;",
    "database_name": "meteorological_dcaa_67637",
    "tables": [
      "REPORTS",
      "REPORT_CONFIGS",
      "METRICS"
    ],
    "call_sqls": [
      "INSERT INTO REPORTS (REPORT_ID, USER_ID, REPORT_DATE, REPORT_TYPE, REPORT_DATA) VALUES (1, 101, '2023-10-01', 'monthly', 'Data1')",
      "INSERT INTO REPORTS (REPORT_ID, USER_ID, REPORT_DATE, REPORT_TYPE, REPORT_DATA) VALUES (2, 102, '2023-10-02', 'weekly', 'Data2')",
      "INSERT INTO REPORTS (REPORT_ID, USER_ID, REPORT_DATE, REPORT_TYPE, REPORT_DATA) VALUES (3, 103, '2023-10-03', 'daily', 'Data3')",
      "INSERT INTO REPORTS (REPORT_ID, USER_ID, REPORT_DATE, REPORT_TYPE, REPORT_DATA) VALUES (4, 104, '2023-10-04', 'annual', 'Data4')",
      "INSERT INTO REPORTS (REPORT_ID, USER_ID, REPORT_DATE, REPORT_TYPE, REPORT_DATA) VALUES (5, 105, '2023-10-05', 'quarterly', 'Data5')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named `trg_reports_upper_report_type` that fires before each INSERT or UPDATE on the REPORTS table, converting the REPORT_TYPE to uppercase and, if USER_ID is provided, validating it against the USERS table; if the USER_ID does not exist in USERS, it is set to null.",
    "natural_language": "Write a Oracle PL/SQL trigger named `trg_reports_upper_report_type` that executes before each insertion or update on the REPORTS table, converting the REPORT_TYPE value to uppercase for every row and validating that if the USER_ID is provided, it must exist in the USERS table; if not found, set USER_ID to null.",
    "id": 31,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_reports_upper_report_type that is executed before an insert or update operation on the REPORTS table for each row being affected. The trigger first converts the value of the REPORT_TYPE column in the new row to uppercase using the UPPER() function, ensuring that the report type is stored in a consistent format. It then checks if the USER_ID column in the new row is not null. If USER_ID is not null, the trigger attempts to validate the existence of this USER_ID in the USERS table. It does this by selecting a constant value of 1 into a local variable v_user_exists from the DUAL table, conditioned on the existence of a row in the USERS table with a matching USER_ID. If no such row exists, a NO_DATA_FOUND exception is raised, which is caught by the exception handling block. In this case, the trigger sets the USER_ID column in the new row to null, assuming that the constraint allows for null values or a default valid USER_ID. This ensures that only valid USER_IDs are stored in the REPORTS table.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE trigger named `trg_reports_upper_report_type` on the `REPORTS` table. For each affected row, convert the `REPORT_TYPE` to uppercase. Then, if the `USER_ID` is not null, validate it against the `USERS` table. If the `USER_ID` does not exist, set it to null.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a trigger to be executed before any insertion or update operation on the REPORTS table, naming it `trg_reports_upper_report_type`. For every individual row that is being processed, the trigger must first transform the value in the REPORT_TYPE column entirely to uppercase letters. Subsequently, it should perform a detailed validation check: if the USER_ID for that row contains a non-null value, the trigger must meticulously verify that this identifier actually exists within the primary records of the USERS table. In the specific scenario where the provided USER_ID cannot be located, the trigger must then carefully assign a null value to that field."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_countries_before_insert_capital` that is configured to execute `BEFORE INSERT` operations on the `COUNTRIES` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is being inserted into the `COUNTRIES` table. The trigger declares a local PL/SQL variable named `v_hex_capital` of type `VARCHAR2` with a maximum length of 255 characters. When an `INSERT` operation is initiated on the `COUNTRIES` table, for each row being inserted, the trigger first accesses the value of the `CAPITAL` column from the new row being inserted, referenced as `:NEW.CAPITAL`. This `CAPITAL` value is then converted from its original data type to a `RAW` data type using the `UTL_RAW.CAST_TO_RAW` function. The resulting `RAW` value is subsequently converted into its hexadecimal string representation using the `RAWTOHEX` function. The hexadecimal string output from `RAWTOHEX` is then assigned to the `v_hex_capital` variable. Following this, the trigger modifies the `CAPITAL` column of the new row being inserted, again referenced as `:NEW.CAPITAL`. The new value assigned to `:NEW.CAPITAL` is a substring of the `v_hex_capital` variable. Specifically, it takes the first 10 characters of the `v_hex_capital` string, starting from the first position (index 1) and extending for a length of 10 characters. This modified value then replaces the original `CAPITAL` value for the row being inserted before the actual `INSERT` operation completes and the row is committed to the `COUNTRIES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_countries_before_insert_capital\nBEFORE INSERT ON COUNTRIES\nFOR EACH ROW\nDECLARE\n  v_hex_capital VARCHAR2(255);\nBEGIN\n  v_hex_capital := RAWTOHEX(UTL_RAW.CAST_TO_RAW(:NEW.CAPITAL));\n  :NEW.CAPITAL := SUBSTR(v_hex_capital, 1, 10);\nEND;",
    "database_name": "global_haed_analysis",
    "tables": [
      "COUNTRIES"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRIES (COUNTRY_ID, COUNTRY_NAME, REGION, ISO_CODE, POPULATION, AREA, CAPITAL, CURRENCY, GOVERNMENT_TYPE, OFFICIAL_LANGUAGE, TIME_ZONE) VALUES (2, 'France', 'Western Europe', 'FRA', '67081000', 551695, 'Paris', 'Euro', 'Unitary semi-presidential republic', 'French', 'CET')",
      "INSERT INTO COUNTRIES (COUNTRY_ID, COUNTRY_NAME, REGION, ISO_CODE, POPULATION, AREA, CAPITAL, CURRENCY, GOVERNMENT_TYPE, OFFICIAL_LANGUAGE, TIME_ZONE) VALUES (3, 'Germany', 'Western Europe', 'DEU', '83166711', 357022, 'Berlin', 'Euro', 'Federal parliamentary republic', 'German', 'CET')",
      "INSERT INTO COUNTRIES (COUNTRY_ID, COUNTRY_NAME, REGION, ISO_CODE, POPULATION, AREA, CAPITAL, CURRENCY, GOVERNMENT_TYPE, OFFICIAL_LANGUAGE, TIME_ZONE) VALUES (4, 'Italy', 'Southern Europe', 'ITA', '60317116', 301340, 'Rome', 'Euro', 'Unitary parliamentary republic', 'Italian', 'CET')",
      "INSERT INTO COUNTRIES (COUNTRY_ID, COUNTRY_NAME, REGION, ISO_CODE, POPULATION, AREA, CAPITAL, CURRENCY, GOVERNMENT_TYPE, OFFICIAL_LANGUAGE, TIME_ZONE) VALUES (5, 'Spain', 'Southern Europe', 'ESP', '47351567', 505990, 'Madrid', 'Euro', 'Constitutional monarchy', 'Spanish', 'CET')",
      "INSERT INTO COUNTRIES (COUNTRY_ID, COUNTRY_NAME, REGION, ISO_CODE, POPULATION, AREA, CAPITAL, CURRENCY, GOVERNMENT_TYPE, OFFICIAL_LANGUAGE, TIME_ZONE) VALUES (6, 'Portugal', 'Southern Europe', 'PRT', '10276617', 92212, 'Lisbon', 'Euro', 'Unitary semi-presidential republic', 'Portuguese', 'WET')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_countries_before_insert_capital that fires BEFORE INSERT on the COUNTRIES table for each row, converting the CAPITAL value to its hexadecimal representation, taking the first 10 characters of that result, and assigning it back to the CAPITAL column.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_countries_before_insert_capital that, before inserting a row into the COUNTRIES table, converts the CAPITAL column value to its hexadecimal representation, takes the first ten characters of that result, and updates the CAPITAL column with this new value.",
    "id": 32,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_countries_before_insert_capital` on the `COUNTRIES` table in the `global_haed_analysis` database. This trigger executes automatically before any `INSERT` operation is performed on a row in the `COUNTRIES` table.\n\nUpon activation, the trigger operates on the new row being inserted, represented by the `:NEW` pseudorecord. The trigger's logic focuses on the `CAPITAL` column of this new row.\n\nThe trigger performs the following operations in sequence:\n\n1.  It accesses the current value of the `CAPITAL` column from the row being inserted, which is `:NEW.CAPITAL`.\n2.  It converts this string value into its hexadecimal representation. This conversion transforms each character of the `CAPITAL` string into its corresponding two-digit hexadecimal code.\n3.  It extracts a substring from the resulting hexadecimal string. Specifically, it takes the first ten characters from the beginning of the hexadecimal string.\n4.  It assigns this extracted ten-character hexadecimal substring back to the `CAPITAL` column of the row being inserted, thereby updating `:NEW.CAPITAL` with this new value.\n\nThe trigger does not declare any local variables. Its sole purpose is to transform the incoming `CAPITAL` data by replacing it with a truncated hexadecimal representation before the row is physically inserted into the `COUNTRIES` table.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_countries_before_insert_capital on the COUNTRIES table. For each new row, convert the CAPITAL value to its hexadecimal representation, take the first 10 characters, and assign this back to the CAPITAL column.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please implement a BEFORE INSERT row-level trigger designated as trg_countries_before_insert_capital on the COUNTRIES table. For each inserted row, the procedure must convert the value within the CAPITAL column into its hexadecimal representation, extract the initial ten characters from this result, and subsequently reassign this derived value to the CAPITAL column."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_adjust_version_quality` that is configured to execute `BEFORE` any `INSERT` operation on the `DATASETS` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row being inserted into the `DATASETS` table. Upon activation, the trigger evaluates a conditional statement: it checks if the value of the `DATA_QUALITY` column in the new row being inserted (referenced as `:NEW.DATA_QUALITY`) is exactly equal to the string literal `'high'`. This comparison is case-sensitive. If this condition evaluates to `TRUE`, indicating that the data quality of the new row is 'high', then the trigger proceeds to modify the value of the `DATA_VERSION` column for that same new row (referenced as `:NEW.DATA_VERSION`). The modification involves a series of operations: first, the current value of `:NEW.DATA_VERSION` is explicitly converted from its original data type to a `NUMBER` data type using the `TO_NUMBER()` function. Next, the `FLOOR()` function is applied to this numeric value, which truncates any fractional part, effectively rounding the number down to the nearest whole integer. Finally, this resulting integer value is converted back to a `VARCHAR2` data type using the `TO_CHAR()` function, and this character string is then assigned as the new value for `:NEW.DATA_VERSION`. If the initial condition (`:NEW.DATA_QUALITY = 'high'`) evaluates to `FALSE`, the trigger's logic for that specific row concludes without any modification to the `:NEW.DATA_VERSION` column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_adjust_version_quality\nBEFORE INSERT ON DATASETS\nFOR EACH ROW\nBEGIN\n  IF :NEW.DATA_QUALITY = 'high' THEN\n    :NEW.DATA_VERSION := TO_CHAR(FLOOR(TO_NUMBER(:NEW.DATA_VERSION)));\n  END IF;\nEND;",
    "database_name": "weather_dcaa_492266",
    "tables": [
      "DATASETS",
      "DATASET_VERSIONS"
    ],
    "call_sqls": [
      "INSERT INTO DATASETS (DATASET_ID, STATION_ID, YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DATA_TYPE, DATA_SOURCE, DATA_QUALITY, DATA_VERSION, CREATED_BY, LAST_MODIFIED_BY, CREATED_AT, LAST_MODIFIED_AT) VALUES (2, 1, 2008, 10, 8, 0, 0, 0, 'temperature', 'sensor', 'high', '1.0', 1, 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00')",
      "INSERT INTO DATASETS (DATASET_ID, STATION_ID, YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DATA_TYPE, DATA_SOURCE, DATA_QUALITY, DATA_VERSION, CREATED_BY, LAST_MODIFIED_BY, CREATED_AT, LAST_MODIFIED_AT) VALUES (3, 1, 2008, 10, 8, 0, 1, 0, 'humidity', 'sensor', 'high', '1.0', 1, 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00')",
      "INSERT INTO DATASETS (DATASET_ID, STATION_ID, YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DATA_TYPE, DATA_SOURCE, DATA_QUALITY, DATA_VERSION, CREATED_BY, LAST_MODIFIED_BY, CREATED_AT, LAST_MODIFIED_AT) VALUES (4, 1, 2008, 10, 8, 0, 0, 0, 'temperature', 'sensor', 'high', '1.0', 1, 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00')",
      "INSERT INTO DATASETS (DATASET_ID, STATION_ID, YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DATA_TYPE, DATA_SOURCE, DATA_QUALITY, DATA_VERSION, CREATED_BY, LAST_MODIFIED_BY, CREATED_AT, LAST_MODIFIED_AT) VALUES (5, 1, 2008, 10, 8, 0, 1, 0, 'humidity', 'sensor', 'high', '1.0', 1, 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00')",
      "INSERT INTO DATASETS (DATASET_ID, STATION_ID, YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, DATA_TYPE, DATA_SOURCE, DATA_QUALITY, DATA_VERSION, CREATED_BY, LAST_MODIFIED_BY, CREATED_AT, LAST_MODIFIED_AT) VALUES (6, 1, 2008, 10, 8, 0, 0, 0, 'temperature', 'sensor', 'high', '1.0', 1, 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_adjust_version_quality that fires BEFORE INSERT on the DATASETS table for each new row. If the new row's DATA_QUALITY is 'high', adjust the new row's DATA_VERSION by rounding its numeric value down to the nearest whole number and storing it as a string.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_adjust_version_quality that fires before each new row is inserted into the DATASETS table. If the new row's DATA_QUALITY is 'high', adjust its DATA_VERSION by taking its numeric value, rounding it down to the nearest whole number, and updating the DATA_VERSION with that whole number as a string.",
    "id": 33,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_adjust_version_quality` that is configured to execute `BEFORE` any `INSERT` operation on the `DATASETS` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row being inserted into the `DATASETS` table. Upon activation, the trigger evaluates a conditional statement: it checks if the value of the `DATA_QUALITY` column in the new row being inserted (referenced as `:NEW.DATA_QUALITY`) is exactly equal to the string literal `'high'`. This comparison is case-sensitive. If this condition evaluates to `TRUE`, indicating that the data quality of the new row is 'high', then the trigger proceeds to modify the value of the `DATA_VERSION` column for that same new row (referenced as `:NEW.DATA_VERSION`). The modification involves a series of operations: first, the current value of `:NEW.DATA_VERSION` is explicitly converted from its original data type to a `NUMBER` data type using the `TO_NUMBER()` function. Next, the `FLOOR()` function is applied to this numeric value, which truncates any fractional part, effectively rounding the number down to the nearest whole integer. Finally, this resulting integer value is converted back to a `VARCHAR2` data type using the `TO_CHAR()` function, and this character string is then assigned as the new value for `:NEW.DATA_VERSION`. If the initial condition (`:NEW.DATA_QUALITY = 'high'`) evaluates to `FALSE`, the trigger's logic for that specific row concludes without any modification to the `:NEW.DATA_VERSION` column.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named `trg_adjust_version_quality` on the DATASETS table. If the new row's DATA_QUALITY is 'high', set the new row's DATA_VERSION to the floor of its numeric value converted back to a string.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires before a new row goes into the DATASETS table. Let's call it `trg_adjust_version_quality`. Here's the deal: whenever a new record is added, if its DATA_QUALITY is marked as 'high', we gotta tweak the DATA_VERSION. Take the numeric value of that version, round it down to the nearest whole number, and then stick that number back in as a string. Just make sure the trigger runs for each new row."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_shipping_info that is defined to execute automatically after each row is updated in the ORDERS table, declaring a local variable v_path of type VARCHAR2 with a maximum length of 4000 characters, and within its execution block, first checking if the new value of the STATUS column in the updated ORDERS row is exactly equal to the string 'shipped', and if this condition is true, performing an update on the ORDER_ITEMS table to set its ITEM_STATUS column to the string 'shipped' for all rows where the ORDER_ITEMS.ORDER_ID column matches the new ORDER_ID value from the updated ORDERS row, but if the first condition is false, then checking if the new STATUS value is exactly equal to the string 'delivered', and if this second condition is true, performing an update on the ORDER_ITEMS table to set its ITEM_STATUS column to the string 'delivered' for all rows where the ORDER_ITEMS.ORDER_ID column matches the new ORDER_ID value from the updated ORDERS row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_shipping_info\nAFTER UPDATE ON ORDERS\nFOR EACH ROW\nDECLARE\n  v_path VARCHAR2(4000); -- Declare v_path\nBEGIN\n  IF :NEW.STATUS = 'shipped' THEN\n    UPDATE ORDER_ITEMS SET ITEM_STATUS = 'shipped' WHERE ORDER_ID = :NEW.ORDER_ID;\n  ELSIF :NEW.STATUS = 'delivered' THEN\n    UPDATE ORDER_ITEMS SET ITEM_STATUS = 'delivered' WHERE ORDER_ID = :NEW.ORDER_ID;\n  END IF;\n  -- Removed the following lines as ORDER_LOG table is not in the schema and v_path was not declared\n  -- SELECT SYS_CONNECT_BY_PATH(ORDER_ID, '/') INTO v_path FROM ORDERS WHERE ORDER_ID = :NEW.ORDER_ID;\n  -- INSERT INTO ORDER_LOG (ORDER_ID, LOG_MESSAGE) VALUES (:NEW.ORDER_ID, v_path);\nEND;",
    "database_name": "e_comast_345211",
    "tables": [
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "UPDATE ORDERS SET STATUS = 'shipped' WHERE ORDER_ID = 0",
      "UPDATE ORDERS SET STATUS = 'delivered' WHERE ORDER_ID = 1",
      "UPDATE ORDERS SET STATUS = 'shipped', SHIP_DATE = '2024-05-20' WHERE ORDER_ID = 2",
      "UPDATE ORDERS SET STATUS = 'delivered', DELIVERY_DATE = '2024-05-22' WHERE ORDER_ID = 3",
      "UPDATE ORDERS SET STATUS = 'shipped', PAYMENT_STATUS = 'paid' WHERE ORDER_ID = 4"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_shipping_info that fires after each row is updated in the ORDERS table, and when the new STATUS is set to 'shipped', updates all matching rows in the ORDER_ITEMS table for that ORDER_ID to set ITEM_STATUS to 'shipped', or when the new STATUS is set to 'delivered', updates all matching ORDER_ITEMS rows to set ITEM_STATUS to 'delivered'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_shipping_info that fires after each row is updated in the ORDERS table, so that when the new STATUS becomes 'shipped', it updates all matching ORDER_ITEMS to set ITEM_STATUS to 'shipped', and when the new STATUS becomes 'delivered', it updates all matching ORDER_ITEMS to set ITEM_STATUS to 'delivered'.",
    "id": 34,
    "generated_ir": "Write an Oracle PL/SQL AFTER UPDATE row-level trigger named trg_update_shipping_info on the ORDERS table in the e_comast_345211 database. This trigger executes after an UPDATE operation is performed on any row in the ORDERS table, firing once for each individual row being updated. The trigger's logic begins by evaluating a conditional statement: IF :NEW.STATUS = 'shipped' THEN. This condition checks if the value of the STATUS column in the newly updated row (:NEW.STATUS) is exactly equal to the string literal 'shipped'. If this condition is true, the trigger performs an UPDATE operation on the ORDER_ITEMS table. This UPDATE statement sets the ITEM_STATUS column to the string literal 'shipped' for all rows in the ORDER_ITEMS table where the ORDER_ID column matches the ORDER_ID from the newly updated ORDERS row (:NEW.ORDER_ID). If the initial condition is false, the trigger proceeds to evaluate a second conditional statement: ELSIF :NEW.STATUS = 'delivered' THEN. This condition checks if the value of the STATUS column in the newly updated row (:NEW.STATUS) is exactly equal to the string literal 'delivered'. If this condition is true, the trigger performs an UPDATE operation on the ORDER_ITEMS table. This UPDATE statement sets the ITEM_STATUS column to the string literal 'delivered' for all rows in the ORDER_ITEMS table where the ORDER_ID column matches the ORDER_ID from the newly updated ORDERS row (:NEW.ORDER_ID). If neither condition is met, the trigger does not execute any UPDATE operations on the ORDER_ITEMS table. The trigger does not declare any local variables and does not include an explicit EXCEPTION handling block.",
    "original_summary": "Create an AFTER UPDATE row-level trigger named trg_update_shipping_info on the ORDERS table. If the new STATUS is 'shipped', update all matching ORDER_ITEMS to set ITEM_STATUS to 'shipped'. If the new STATUS is 'delivered', update all matching ORDER_ITEMS to set ITEM_STATUS to 'delivered'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER UPDATE row-level trigger named trg_update_shipping_info on the ORDERS table that updates all matching ORDER_ITEMS to set ITEM_STATUS to 'shipped' when the new STATUS is 'shipped', and to 'delivered' when the new STATUS is 'delivered'?"
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_measurements_size_check` on the `MEASUREMENTS` table. This trigger executes for each row *before* an `INSERT` operation is performed on the `MEASUREMENTS` table. The trigger declares a local PL/SQL variable named `v_size_exists` of type `NUMBER`. The primary purpose of this trigger is to ensure referential integrity for the `SIZE_ID` column by automatically inserting a new record into the `SIZES` table if the `SIZE_ID` being inserted into `MEASUREMENTS` does not already exist in the `SIZES` table.\n\nThe trigger begins by executing a `SELECT` statement to count the number of existing records in the `SIZES` table where the `SIZE_ID` column matches the `SIZE_ID` value of the new row being inserted into the `MEASUREMENTS` table. The value for the new row's `SIZE_ID` is accessed using the `:NEW.SIZE_ID` pseudorecord. The result of this count operation is stored into the `v_size_exists` variable.\n\nFollowing the `SELECT` statement, the trigger evaluates a conditional `IF` statement. It checks if the value of `v_size_exists` is equal to `0`. This condition evaluates to `TRUE` if no record with the specified `SIZE_ID` was found in the `SIZES` table.\n\nIf the condition `v_size_exists = 0` is `TRUE`, indicating that the `SIZE_ID` from the new `MEASUREMENTS` row does not exist in the `SIZES` table, the trigger then executes an `INSERT` statement. This `INSERT` statement adds a new row into the `SIZES` table. The `SIZE_ID` column of the new `SIZES` record is populated with the value from `:NEW.SIZE_ID`. The `SIZE_LABEL` column is set to the string literal `'AUTO'`. The `SIZE_DESCRIPTION` column is set to the string literal `'Auto-generated size'`. The `SIZE_CATEGORY` column is set to the string literal `'unknown'`. Finally, the `SIZE_TYPE` column is set to the string literal `'auto'`.\n\nIf the condition `v_size_exists = 0` is `FALSE`, meaning a record with the specified `SIZE_ID` already exists in the `SIZES` table, no `INSERT` operation is performed on the `SIZES` table, and the trigger simply completes its execution for the current row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_measurements_size_check\nBEFORE INSERT ON MEASUREMENTS\nFOR EACH ROW\nDECLARE\n    v_size_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_size_exists FROM SIZES WHERE SIZE_ID = :NEW.SIZE_ID;\n    IF v_size_exists = 0 THEN\n        INSERT INTO SIZES (SIZE_ID, SIZE_LABEL, SIZE_DESCRIPTION, SIZE_CATEGORY, SIZE_TYPE) VALUES (:NEW.SIZE_ID, 'AUTO', 'Auto-generated size', 'unknown', 'auto');\n    END IF;\nEND;",
    "database_name": "apparel_sams_543314",
    "tables": [
      "SIZES",
      "MEASUREMENTS",
      "SIZE_UPDATES"
    ],
    "call_sqls": [
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (2, 2, 37.5, 98.0, 98.0, 117.0, 108.0, 93.0, 77.0, 61.0)",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (3, 3, 39.0, 103.0, 103.0, 118.0, 113.0, 98.0, 79.0, 63.0)",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (4, 4, 40.0, 105.0, 105.0, 119.0, 115.0, 100.0, 80.0, 64.0)",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (5, 5, 41.0, 107.0, 107.0, 120.0, 117.0, 102.0, 81.0, 65.0)",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (6, 6, 42.0, 109.0, 109.0, 121.0, 119.0, 104.0, 82.0, 66.0)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_measurements_size_check that fires BEFORE INSERT on each row of the MEASUREMENTS table to check if the SIZE_ID being inserted exists in the SIZES table; if it does not exist, automatically insert a new row into SIZES with that SIZE_ID, setting SIZE_LABEL to 'AUTO', SIZE_DESCRIPTION to 'Auto-generated size', SIZE_CATEGORY to 'unknown', and SIZE_TYPE to 'auto'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_measurements_size_check that, before inserting each new row into the MEASUREMENTS table, checks if the inserted SIZE_ID already exists in the SIZES table. If the SIZE_ID is not found, the trigger should automatically create a new record in the SIZES table using that SIZE_ID, setting SIZE_LABEL to 'AUTO', SIZE_DESCRIPTION to 'Auto-generated size', SIZE_CATEGORY to 'unknown', and SIZE_TYPE to 'auto'.",
    "id": 35,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_measurements_size_check` on the `MEASUREMENTS` table. This trigger executes for each row *before* an `INSERT` operation is performed on the `MEASUREMENTS` table. The trigger declares a local PL/SQL variable named `v_size_exists` of type `NUMBER`. The primary purpose of this trigger is to ensure referential integrity for the `SIZE_ID` column by automatically inserting a new record into the `SIZES` table if the `SIZE_ID` being inserted into `MEASUREMENTS` does not already exist in the `SIZES` table.\n\nThe trigger begins by executing a `SELECT` statement to count the number of existing records in the `SIZES` table where the `SIZE_ID` column matches the `SIZE_ID` value of the new row being inserted into the `MEASUREMENTS` table. The value for the new row's `SIZE_ID` is accessed using the `:NEW.SIZE_ID` pseudorecord. The result of this count operation is stored into the `v_size_exists` variable.\n\nFollowing the `SELECT` statement, the trigger evaluates a conditional `IF` statement. It checks if the value of `v_size_exists` is equal to `0`. This condition evaluates to `TRUE` if no record with the specified `SIZE_ID` was found in the `SIZES` table.\n\nIf the condition `v_size_exists = 0` is `TRUE`, indicating that the `SIZE_ID` from the new `MEASUREMENTS` row does not exist in the `SIZES` table, the trigger then executes an `INSERT` statement. This `INSERT` statement adds a new row into the `SIZES` table. The `SIZE_ID` column of the new `SIZES` record is populated with the value from `:NEW.SIZE_ID`. The `SIZE_LABEL` column is set to the string literal `'AUTO'`. The `SIZE_DESCRIPTION` column is set to the string literal `'Auto-generated size'`. The `SIZE_CATEGORY` column is set to the string literal `'unknown'`. Finally, the `SIZE_TYPE` column is set to the string literal `'auto'`.\n\nIf the condition `v_size_exists = 0` is `FALSE`, meaning a record with the specified `SIZE_ID` already exists in the `SIZES` table, no `INSERT` operation is performed on the `SIZES` table, and the trigger simply completes its execution for the current row.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_measurements_size_check on the MEASUREMENTS table. Check if the SIZE_ID being inserted exists in the SIZES table. If it doesn't exist, insert a new row into SIZES with the SIZE_ID from the new row, SIZE_LABEL as 'AUTO', SIZE_DESCRIPTION as 'Auto-generated size', SIZE_CATEGORY as 'unknown', and SIZE_TYPE as 'auto'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE INSERT FOR EACH ROW trigger, designated as trg_measurements_size_check, for the MEASUREMENTS table. The trigger's function is to verify the existence of the inserted SIZE_ID within the SIZES table. Should the SIZE_ID not be present, the trigger must insert a corresponding record into the SIZES table. This new record shall utilize the SIZE_ID from the inserted MEASUREMENTS row, assign 'AUTO' to the SIZE_LABEL, 'Auto-generated size' to the SIZE_DESCRIPTION, 'unknown' to the SIZE_CATEGORY, and 'auto' to the SIZE_TYPE."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_check_file_size` that is activated `BEFORE` any `INSERT` operation occurs on the `DATA_FILES` table, and executes `FOR EACH ROW` being inserted. This trigger declares a local numeric variable named `v_current_total_size` to temporarily store a calculated sum. Within the trigger's execution block, it first performs a `SELECT` operation to calculate the sum of all `FILE_SIZE` column values from the `DATA_FILES` table. This sum is filtered by a `WHERE` clause, ensuring that only rows where the `DATASET_ID` column matches the `DATASET_ID` of the `NEW` row currently being inserted (`:NEW.DATASET_ID`) are included in the sum. The `NVL` function is applied to the `SUM(FILE_SIZE)` result, ensuring that if no matching rows are found (and thus `SUM(FILE_SIZE)` would return `NULL`), a value of `0` is used instead. The result of this `SELECT` statement is then stored into the `v_current_total_size` variable. Following this, an `IF` conditional statement evaluates whether the sum of `v_current_total_size` and the `FILE_SIZE` of the `NEW` row being inserted (`:NEW.FILE_SIZE`) is `GREATER THAN` the numeric literal value `10000`. If this condition evaluates to `TRUE`, the trigger executes the `RAISE_APPLICATION_ERROR` procedure, which immediately stops the `INSERT` operation and returns a user-defined error. This error is identified by the error number `-20001` and includes the error message string `'Total file size for dataset would exceed 10000 limit'`. If the condition in the `IF` statement evaluates to `FALSE`, the trigger completes its execution without raising an error, allowing the `INSERT` operation to proceed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_file_size\nBEFORE INSERT ON DATA_FILES\nFOR EACH ROW\nDECLARE\n  v_current_total_size NUMBER;\nBEGIN\n  SELECT NVL(SUM(FILE_SIZE), 0) INTO v_current_total_size \n  FROM DATA_FILES \n  WHERE DATASET_ID = :NEW.DATASET_ID;\n  \n  IF (v_current_total_size + :NEW.FILE_SIZE) > 10000 THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Total file size for dataset would exceed 10000 limit');\n  END IF;\nEND;",
    "database_name": "biomedical_rad_management",
    "tables": [
      "DATASETS",
      "DATASET_DETAILS",
      "CELL_TYPES",
      "TISSUE_TYPES",
      "DATASET_VERSIONS",
      "DATA_FILES",
      "DATA_ANALYSIS"
    ],
    "call_sqls": [
      "INSERT INTO DATA_FILES (FILE_ID, DATASET_ID, FILE_PATH, FILE_SIZE, UPLOAD_DATE, FILE_TYPE, FILE_FORMAT, FILE_DESCRIPTION) VALUES (100, '0', '/data/file1.txt', 5000, '2024-01-01', 'raw', 'txt', 'Initial data file')",
      "INSERT INTO DATA_FILES (FILE_ID, DATASET_ID, FILE_PATH, FILE_SIZE, UPLOAD_DATE, FILE_TYPE, FILE_FORMAT, FILE_DESCRIPTION) VALUES (101, '0', '/data/file2.txt', 4000, '2024-01-02', 'raw', 'txt', 'Second data file')",
      "INSERT INTO DATA_FILES (FILE_ID, DATASET_ID, FILE_PATH, FILE_SIZE, UPLOAD_DATE, FILE_TYPE, FILE_FORMAT, FILE_DESCRIPTION) VALUES (102, '0', '/data/file3.txt', 2000, '2024-01-03', 'raw', 'txt', 'Third data file')",
      "INSERT INTO DATA_FILES (FILE_ID, DATASET_ID, FILE_PATH, FILE_SIZE, UPLOAD_DATE, FILE_TYPE, FILE_FORMAT, FILE_DESCRIPTION) VALUES (103, '1', '/data/fileA.txt', 8000, '2024-01-01', 'raw', 'txt', 'Dataset 1 file')",
      "INSERT INTO DATA_FILES (FILE_ID, DATASET_ID, FILE_PATH, FILE_SIZE, UPLOAD_DATE, FILE_TYPE, FILE_FORMAT, FILE_DESCRIPTION) VALUES (104, '1', '/data/fileB.txt', 3000, '2024-01-02', 'raw', 'txt', 'Dataset 1 second file')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named `trg_check_file_size` that fires BEFORE INSERT on each row of the `DATA_FILES` table to ensure that the total `FILE_SIZE` for a given `DATASET_ID` does not exceed 10000. For each new row being inserted, calculate the sum of existing `FILE_SIZE` values in the `DATA_FILES` table for the same `DATASET_ID`, add the new row's `FILE_SIZE` to this total, and if the result exceeds 10000, prevent the insert by raising an error.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_check_file_size that runs before each insert into the DATA_FILES table, ensuring that for a given DATASET_ID, the total FILE_SIZE across all rows—including the new row's FILE_SIZE—does not exceed 10000; if it would, raise an error to prevent the insert.",
    "id": 36,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_check_file_size` that is activated `BEFORE` any `INSERT` operation occurs on the `DATA_FILES` table, and executes `FOR EACH ROW` being inserted. This trigger declares a local numeric variable named `v_current_total_size` to temporarily store a calculated sum. Within the trigger's execution block, it first performs a `SELECT` operation to calculate the sum of all `FILE_SIZE` column values from the `DATA_FILES` table. This sum is filtered by a `WHERE` clause, ensuring that only rows where the `DATASET_ID` column matches the `DATASET_ID` of the `NEW` row currently being inserted (`:NEW.DATASET_ID`) are included in the sum. The `NVL` function is applied to the `SUM(FILE_SIZE)` result, ensuring that if no matching rows are found (and thus `SUM(FILE_SIZE)` would return `NULL`), a value of `0` is used instead. The result of this `SELECT` statement is then stored into the `v_current_total_size` variable. Following this, an `IF` conditional statement evaluates whether the sum of `v_current_total_size` and the `FILE_SIZE` of the `NEW` row being inserted (`:NEW.FILE_SIZE`) is `GREATER THAN` the numeric literal value `10000`. If this condition evaluates to `TRUE`, the trigger executes the `RAISE_APPLICATION_ERROR` procedure, which immediately stops the `INSERT` operation and returns a user-defined error. This error is identified by the error number `-20001` and includes the error message string `'Total file size for dataset would exceed 10000 limit'`. If the condition in the `IF` statement evaluates to `FALSE`, the trigger completes its execution without raising an error, allowing the `INSERT` operation to proceed.",
    "original_summary": "Create a trigger named `trg_check_file_size` that fires BEFORE INSERT on each row of the `DATA_FILES` table. Calculate the total existing FILE_SIZE for the new row's DATASET_ID. If adding the new FILE_SIZE to this total would exceed 10000, raise an application error to prevent the insert.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Before inserting a row into the DATA_FILES table, check the total existing FILE_SIZE for the new row's DATASET_ID. If adding the new FILE_SIZE would make the total exceed 10000, raise an error to stop the insert. Create a trigger named `trg_check_file_size` to perform this check."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_response_status_check` that is configured to execute automatically after an `UPDATE` operation occurs on any row within the `RESPONSES` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for each individual row that is updated in the `RESPONSES` table. The trigger's execution is conditional: it first evaluates an `IF` statement. This `IF` statement checks the value of the `STATUS` column in the row *after* the update operation has completed. Specifically, it compares the new value of the `STATUS` column, referenced as `:NEW.STATUS`, to the literal string `'success'`. If the new `STATUS` value is exactly equal to `'success'`, then the trigger proceeds to execute a `DELETE` operation. This `DELETE` operation targets rows in the `DISPENSES` table. The rows to be deleted are identified by two conditions combined with an `AND` operator: first, the `RESPONSE_ID` column in the `DISPENSES` table must match the `RESPONSE_ID` of the row that was just updated in the `RESPONSES` table (referenced as `:NEW.RESPONSE_ID`); and second, the `STATUS` column in the `DISPENSES` table must be equal to the literal string `'completed'`. Only rows in `DISPENSES` that satisfy both of these conditions will be removed from the table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_response_status_check\nAFTER UPDATE ON RESPONSES\nFOR EACH ROW\nBEGIN\n  IF :NEW.STATUS = 'success' THEN\n    DELETE FROM DISPENSES WHERE RESPONSE_ID = :NEW.RESPONSE_ID AND STATUS = 'completed';\n  END IF;\nEND;",
    "database_name": "healthcare_dma_analytics",
    "tables": [
      "RESPONSES",
      "DISPENSES"
    ],
    "call_sqls": [
      "UPDATE RESPONSES SET STATUS = 'success' WHERE RESPONSE_ID = 0",
      "UPDATE RESPONSES SET STATUS = 'success' WHERE RESPONSE_ID = 1",
      "UPDATE RESPONSES SET STATUS = 'success' WHERE RESPONSE_ID = 0 AND QUERY_ID = 0",
      "UPDATE RESPONSES SET STATUS = 'success' WHERE RESPONSE_ID = 1 AND EXECUTED_BY = 1",
      "UPDATE RESPONSES SET STATUS = 'success' WHERE RESPONSE_ID = 0 AND EXECUTION_TIME = '5 minutes'"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_RESPONSE_STATUS_CHECK on the RESPONSES table that fires after each row is updated. When the STATUS column of an updated row changes to 'success', delete all rows from the DISPENSES table where the RESPONSE_ID matches the updated row's RESPONSE_ID and the STATUS is 'completed'.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_RESPONSE_STATUS_CHECK that, after each update on the RESPONSES table, checks if the STATUS is changed to 'success', and if so, deletes any records from the DISPENSES table that have the same RESPONSE_ID and a STATUS of 'completed'.",
    "id": 37,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_RESPONSE_STATUS_CHECK` that is activated `AFTER` an `UPDATE` operation occurs on the `RESPONSES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row being updated in the `RESPONSES` table.\n\nUpon activation, the trigger first checks a condition using an `IF` statement. The condition compares the new value of the `STATUS` column in the updated row, referenced by `:NEW.STATUS`, to the string literal `'success'`. It also checks if the `STATUS` column's value has changed from its previous value by comparing `:NEW.STATUS` to the old value of the `STATUS` column, referenced by `:OLD.STATUS`. The condition is true only if the new `STATUS` is exactly `'success'` and the old `STATUS` is not equal to `'success'` (i.e., the status has been changed to 'success').\n\nIf the condition is true, the trigger executes a `DELETE` operation on the `DISPENSES` table. The `DELETE` statement includes a `WHERE` clause that filters the rows to be deleted based on two conditions:\n1. The `RESPONSE_ID` column in the `DISPENSES` table must be equal to the `RESPONSE_ID` of the updated row in the `RESPONSES` table, which is referenced by `:NEW.RESPONSE_ID`.\n2. The `STATUS` column in the `DISPENSES` table must be equal to the string literal `'completed'`.\n\nIf the condition in the `IF` statement is false (i.e., the new `STATUS` is not `'success'` or the `STATUS` has not changed from `'success'`), the trigger does nothing and exits without performing any operations.\n\nThe trigger does not declare any local variables, perform any `SELECT` or `INSERT` operations, or include any other control flow logic beyond the described `IF` statement. It operates solely based on the update event on the `RESPONSES` table and conditionally deletes matching records from the `DISPENSES` table.",
    "original_summary": "Create an AFTER UPDATE FOR EACH ROW trigger named TRG_RESPONSE_STATUS_CHECK on the RESPONSES table. When a row's STATUS is updated to 'success', delete all rows from the DISPENSES table where RESPONSE_ID matches the updated row's RESPONSE_ID and STATUS is 'completed'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires after each update on the RESPONSES table. Call it TRG_RESPONSE_STATUS_CHECK. Basically, whenever a row's STATUS gets changed to 'success', we gotta go into the DISPENSES table and wipe out any records that have the same RESPONSE_ID and a STATUS of 'completed'."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_INS_TEST_CASE_ACTUAL_RESULTS` that is activated `AFTER` an `INSERT` operation occurs on the `TEST_CASE_ACTUAL_RESULTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `TEST_CASE_ACTUAL_RESULTS` table. Upon activation, the trigger performs a single `INSERT` operation into the `TEST_RESULTS` table. The `INSERT` operation populates the following columns in the `TEST_RESULTS` table:\n- `RESULT_ID`: This column is populated with the value from the `RESULT_ID` column of the newly inserted row in the `TEST_CASE_ACTUAL_RESULTS` table, referenced as `:NEW.RESULT_ID`.\n- `TEST_CASE_ID`: This column is populated with the value from the `TEST_CASE_ID` column of the newly inserted row in the `TEST_CASE_ACTUAL_RESULTS` table, referenced as `:NEW.TEST_CASE_ID`.\n- `EXECUTION_DATE`: This column is populated with a character string representing the current timestamp. The `CURRENT_TIMESTAMP` function retrieves the current date and time, including fractional seconds and time zone information. This timestamp is then formatted into a specific string representation using the `TO_CHAR` function with the format model `'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"'`. This format model specifies a four-digit year, two-digit month, two-digit day, followed by the literal character 'T', a two-digit hour in 24-hour format, two-digit minute, two-digit second, a period, three digits for fractional seconds, and finally the literal character 'Z'.\n- `OUTCOME`: This column is populated with the literal string value `'PENDING'`.\n- `DURATION`: This column is populated with the numeric literal value `0`.\n- `CREATED_AT`: This column is populated with a character string representing the current timestamp, formatted identically to the `EXECUTION_DATE` column using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')`.\n- `UPDATED_AT`: This column is populated with a character string representing the current timestamp, formatted identically to the `EXECUTION_DATE` and `CREATED_AT` columns using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')`.\n- `CREATED_BY`: This column is populated with the value from the `RESULT_ID` column of the newly inserted row in the `TEST_CASE_ACTUAL_RESULTS` table, referenced as `:NEW.RESULT_ID`.\n- `UPDATED_BY`: This column is populated with the value from the `RESULT_ID` column of the newly inserted row in the `TEST_CASE_ACTUAL_RESULTS` table, referenced as `:NEW.RESULT_ID`.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_INS_TEST_CASE_ACTUAL_RESULTS\nAFTER INSERT ON TEST_CASE_ACTUAL_RESULTS\nFOR EACH ROW\nBEGIN\n    INSERT INTO TEST_RESULTS (RESULT_ID, TEST_CASE_ID, EXECUTION_DATE, OUTCOME, DURATION, CREATED_AT, UPDATED_AT, CREATED_BY, UPDATED_BY)\n    VALUES (:NEW.RESULT_ID, :NEW.TEST_CASE_ID, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"'), 'PENDING', 0, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"'), TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"'), :NEW.RESULT_ID, :NEW.RESULT_ID);\nEND;",
    "database_name": "software_taqam_71174",
    "tables": [
      "TEST_CASES",
      "TEST_CASE_STEPS",
      "TEST_CASE_ACTUAL_RESULTS",
      "TEST_RESULTS"
    ],
    "call_sqls": [
      "INSERT INTO TEST_CASE_ACTUAL_RESULTS (RESULT_ID, TEST_CASE_ID, ACTUAL_RESULT) VALUES (2, 1, 'The login is successful.')",
      "INSERT INTO TEST_CASE_ACTUAL_RESULTS (RESULT_ID, TEST_CASE_ID, ACTUAL_RESULT) VALUES (3, 1, 'The navigation is successful.')",
      "INSERT INTO TEST_CASE_ACTUAL_RESULTS (RESULT_ID, TEST_CASE_ID, ACTUAL_RESULT) VALUES (4, 0, 'The logout is successful.')",
      "INSERT INTO TEST_CASE_ACTUAL_RESULTS (RESULT_ID, TEST_CASE_ID, ACTUAL_RESULT) VALUES (5, 0, 'The page load is successful.')",
      "INSERT INTO TEST_CASE_ACTUAL_RESULTS (RESULT_ID, TEST_CASE_ID, ACTUAL_RESULT) VALUES (6, 1, 'The data submission is successful.')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_INS_TEST_CASE_ACTUAL_RESULTS that fires AFTER INSERT on the TEST_CASE_ACTUAL_RESULTS table for each row, inserting a corresponding record into the TEST_RESULTS table. For each new row in TEST_CASE_ACTUAL_RESULTS, populate TEST_RESULTS with the RESULT_ID and TEST_CASE_ID from the new row, set the EXECUTION_DATE, CREATED_AT, and UPDATED_AT to the current timestamp in 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"' format, set OUTCOME to 'PENDING', set DURATION to 0, and set CREATED_BY and UPDATED_BY to the new RESULT_ID.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_INS_TEST_CASE_ACTUAL_RESULTS that, after each insert on the TEST_CASE_ACTUAL_RESULTS table, inserts a new record into the TEST_RESULTS table. For each new row, map the RESULT_ID and TEST_CASE_ID from the inserted row, set the EXECUTION_DATE, CREATED_AT, and UPDATED_AT to the current timestamp formatted as 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"', set the OUTCOME to 'PENDING' and DURATION to 0, and use the inserted RESULT_ID for both CREATED_BY and UPDATED_BY.",
    "id": 38,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_INS_TEST_CASE_ACTUAL_RESULTS` that is activated `AFTER` an `INSERT` operation occurs on the `TEST_CASE_ACTUAL_RESULTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `TEST_CASE_ACTUAL_RESULTS` table. Upon activation, the trigger performs a single `INSERT` operation into the `TEST_RESULTS` table. The `INSERT` operation populates the following columns in the `TEST_RESULTS` table:\n- `RESULT_ID`: This column is populated with the value from the `RESULT_ID` column of the newly inserted row in the `TEST_CASE_ACTUAL_RESULTS` table, referenced as `:NEW.RESULT_ID`.\n- `TEST_CASE_ID`: This column is populated with the value from the `TEST_CASE_ID` column of the newly inserted row in the `TEST_CASE_ACTUAL_RESULTS` table, referenced as `:NEW.TEST_CASE_ID`.\n- `EXECUTION_DATE`: This column is populated with a character string representing the current timestamp. The `CURRENT_TIMESTAMP` function retrieves the current date and time, including fractional seconds and time zone information. This timestamp is then formatted into a specific string representation using the `TO_CHAR` function with the format model `'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"'`. This format model specifies a four-digit year, two-digit month, two-digit day, followed by the literal character 'T', a two-digit hour in 24-hour format, two-digit minute, two-digit second, a period, three digits for fractional seconds, and finally the literal character 'Z'.\n- `OUTCOME`: This column is populated with the literal string value `'PENDING'`.\n- `DURATION`: This column is populated with the numeric literal value `0`.\n- `CREATED_AT`: This column is populated with a character string representing the current timestamp, formatted identically to the `EXECUTION_DATE` column using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')`.\n- `UPDATED_AT`: This column is populated with a character string representing the current timestamp, formatted identically to the `EXECUTION_DATE` and `CREATED_AT` columns using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')`.\n- `CREATED_BY`: This column is populated with the value from the `RESULT_ID` column of the newly inserted row in the `TEST_CASE_ACTUAL_RESULTS` table, referenced as `:NEW.RESULT_ID`.\n- `UPDATED_BY`: This column is populated with the value from the `RESULT_ID` column of the newly inserted row in the `TEST_CASE_ACTUAL_RESULTS` table, referenced as `:NEW.RESULT_ID`.",
    "original_summary": "Create a trigger named TRG_INS_TEST_CASE_ACTUAL_RESULTS that fires AFTER INSERT on TEST_CASE_ACTUAL_RESULTS for each row. For every inserted row, insert a corresponding record into the TEST_RESULTS table. Populate the TEST_RESULTS columns as follows: RESULT_ID, TEST_CASE_ID, CREATED_BY, and UPDATED_BY with values from :NEW.RESULT_ID and :NEW.TEST_CASE_ID. Set EXECUTION_DATE, CREATED_AT, and UPDATED_AT to the current timestamp formatted as 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"'. Set OUTCOME to 'PENDING' and DURATION to 0.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create trigger TRG_INS_TEST_CASE_ACTUAL_RESULTS after insert on TEST_CASE_ACTUAL_RESULTS. For each new row, insert into TEST_RESULTS. Map RESULT_ID, TEST_CASE_ID, CREATED_BY, UPDATED_BY from :NEW. Set EXECUTION_DATE, CREATED_AT, UPDATED_AT to current timestamp as 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"'. Set OUTCOME to 'PENDING', DURATION to 0."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_campaign_performance that is defined to execute before any delete operation on the CAMPAIGNS table for each individual row being deleted, and within its body performs a delete operation on the CAMPAIGN_PERFORMANCE table where the CAMPAIGN_ID column in CAMPAIGN_PERFORMANCE matches the value of the CAMPAIGN_ID column from the row currently being deleted from the CAMPAIGNS table, which is accessed using the :OLD.CAMPAIGN_ID pseudorecord qualifier.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_campaign_performance\nBEFORE DELETE ON CAMPAIGNS\nFOR EACH ROW\nBEGIN\n  DELETE FROM CAMPAIGN_PERFORMANCE WHERE CAMPAIGN_ID = :OLD.CAMPAIGN_ID;\nEND;",
    "database_name": "social_mimap_information",
    "tables": [
      "BRANDS",
      "CAMPAIGNS",
      "CAMPAIGN_PERFORMANCE",
      "ENGAGEMENT_METRICS",
      "INFLUENCERS",
      "INFLUENCER_CAMPAIGNS",
      "METRIC_TYPES",
      "USERS"
    ],
    "call_sqls": [
      "DELETE FROM CAMPAIGNS WHERE CAMPAIGN_ID = 0",
      "DELETE FROM CAMPAIGNS WHERE CAMPAIGN_ID = 1",
      "DELETE FROM CAMPAIGNS WHERE CAMPAIGN_ID = 2",
      "DELETE FROM CAMPAIGNS WHERE CAMPAIGN_ID = 3",
      "DELETE FROM CAMPAIGNS WHERE CAMPAIGN_ID = 4"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_delete_campaign_performance that fires before each row is deleted from the CAMPAIGNS table, and deletes all corresponding rows from the CAMPAIGN_PERFORMANCE table where the CAMPAIGN_ID matches the CAMPAIGN_ID of the campaign being deleted.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_delete_campaign_performance that fires before a row is deleted from the CAMPAIGNS table, and it must delete any rows in the CAMPAIGN_PERFORMANCE table where the CAMPAIGN_ID matches the deleted row's CAMPAIGN_ID.",
    "id": 39,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_delete_campaign_performance that is defined to execute before any delete operation on the CAMPAIGNS table for each individual row being deleted, and within its body performs a delete operation on the CAMPAIGN_PERFORMANCE table where the CAMPAIGN_ID column in CAMPAIGN_PERFORMANCE matches the value of the CAMPAIGN_ID column from the row currently being deleted from the CAMPAIGNS table, which is accessed using the :OLD.CAMPAIGN_ID pseudorecord qualifier.",
    "original_summary": "Create a BEFORE DELETE FOR EACH ROW trigger named trg_delete_campaign_performance on the CAMPAIGNS table. It deletes rows from the CAMPAIGN_PERFORMANCE table where CAMPAIGN_ID equals :OLD.CAMPAIGN_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, set up a trigger called trg_delete_campaign_performance on the CAMPAIGNS table that fires before a row gets deleted. It's gotta clean up by wiping out any matching rows in the CAMPAIGN_PERFORMANCE table where the CAMPAIGN_ID matches the old row's ID."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_maintain_employee_dependencies that is executed before a delete operation on the EMPLOYEES table for each row being deleted. The trigger performs several operations to maintain referential integrity across related tables. First, it deletes rows from the PERFORMANCE_REVIEWS table where the EMPLOYEE_ID or REVIEWER_ID matches the EMPLOYEE_ID of the row being deleted from the EMPLOYEES table. Next, it deletes rows from the EMPLOYMENT_HISTORY table where the EMPLOYEE_ID matches the EMPLOYEE_ID of the row being deleted, and updates the EMPLOYMENT_HISTORY table to set the APPROVED_BY column to NULL for any rows where APPROVED_BY matches the EMPLOYEE_ID of the row being deleted. The trigger then deletes rows from the SALARY_HISTORY table where the EMPLOYEE_ID matches the EMPLOYEE_ID of the row being deleted. It updates the DEPARTMENTS table to set the HEAD_ID column to NULL for any rows where HEAD_ID matches the EMPLOYEE_ID of the row being deleted. Similarly, it updates the TEAMS table to set the MANAGER_ID column to NULL for any rows where MANAGER_ID matches the EMPLOYEE_ID of the row being deleted. Finally, it deletes rows from the BENEFITS table where the EMPLOYEE_ID matches the EMPLOYEE_ID of the row being deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_employee_dependencies\nBEFORE DELETE ON EMPLOYEES\nFOR EACH ROW\nBEGIN\n  -- Handle PERFORMANCE_REVIEWS dependencies\n  DELETE FROM PERFORMANCE_REVIEWS WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID OR REVIEWER_ID = :OLD.EMPLOYEE_ID;\n\n  -- Handle EMPLOYMENT_HISTORY dependencies\n  DELETE FROM EMPLOYMENT_HISTORY WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID;\n  UPDATE EMPLOYMENT_HISTORY SET APPROVED_BY = NULL WHERE APPROVED_BY = :OLD.EMPLOYEE_ID;\n\n  -- Handle SALARY_HISTORY dependencies\n  DELETE FROM SALARY_HISTORY WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID;\n\n  -- Handle DEPARTMENTS HEAD_ID dependency\n  UPDATE DEPARTMENTS SET HEAD_ID = NULL WHERE HEAD_ID = :OLD.EMPLOYEE_ID;\n\n  -- Handle TEAMS MANAGER_ID dependency\n  UPDATE TEAMS SET MANAGER_ID = NULL WHERE MANAGER_ID = :OLD.EMPLOYEE_ID;\n\n  -- Handle BENEFITS or other related table dependencies\n  DELETE FROM BENEFITS WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID;\nEND;",
    "database_name": "employee_mac_tracking",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "TEAMS",
      "POSITIONS",
      "EMPLOYMENT_HISTORY",
      "SALARY_HISTORY",
      "PERFORMANCE_REVIEWS"
    ],
    "call_sqls": [
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 0",
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 1",
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 2",
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 3",
      "DELETE FROM EMPLOYEES WHERE EMPLOYEE_ID = 4"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_maintain_employee_dependencies that fires BEFORE DELETE on each row of the EMPLOYEES table to maintain data integrity by removing or updating related records. When an employee is deleted, delete all their records from the PERFORMANCE_REVIEWS, EMPLOYMENT_HISTORY, SALARY_HISTORY, and BENEFITS tables, and also delete any PERFORMANCE_REVIEWS where they were the REVIEWER_ID. In EMPLOYMENT_HISTORY, set APPROVED_BY to NULL for any records where it matches the deleted employee. Additionally, in DEPARTMENTS, set HEAD_ID to NULL if it matches the deleted employee, and in TEAMS, set MANAGER_ID to NULL if it matches the deleted employee.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_maintain_employee_dependencies that, before deleting each row from the EMPLOYEES table, deletes all related records from the PERFORMANCE_REVIEWS, EMPLOYMENT_HISTORY, SALARY_HISTORY, and BENEFITS tables where the EMPLOYEE_ID matches the deleted employee, and also deletes any PERFORMANCE_REVIEWS records where the REVIEWER_ID matches the deleted employee. Additionally, update the APPROVED_BY column to NULL in the EMPLOYMENT_HISTORY table for any entries where APPROVED_BY matches the deleted EMPLOYEE_ID, and set the HEAD_ID to NULL in the DEPARTMENTS table and the MANAGER_ID to NULL in the TEAMS table wherever they correspond to the deleted EMPLOYEE_ID.",
    "id": 40,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_maintain_employee_dependencies that is defined to execute automatically before any DELETE operation is performed on the EMPLOYEES table, and it is configured to fire once for each row being deleted. The trigger's primary purpose is to maintain referential integrity by performing cascading deletions and nullifying foreign key references associated with the employee being removed. Upon activation, the trigger performs a series of data manipulation operations across multiple related tables in the employee_mac_tracking database.\n\nFirst, the trigger executes a DELETE operation on the PERFORMANCE_REVIEWS table. This operation targets all records where the EMPLOYEE_ID column matches the EMPLOYEE_ID of the employee being deleted from the EMPLOYEES table. The value of the deleted employee's EMPLOYEE_ID is accessed via the :OLD.EMPLOYEE_ID pseudorecord.\n\nSecond, the trigger executes a DELETE operation on the EMPLOYMENT_HISTORY table, removing all records where the EMPLOYEE_ID column equals :OLD.EMPLOYEE_ID.\n\nThird, the trigger executes a DELETE operation on the SALARY_HISTORY table, removing all records where the EMPLOYEE_ID column equals :OLD.EMPLOYEE_ID.\n\nFourth, the trigger executes a DELETE operation on the BENEFITS table, removing all records where the EMPLOYEE_ID column equals :OLD.EMPLOYEE_ID.\n\nFifth, the trigger executes an additional DELETE operation on the PERFORMANCE_REVIEWS table. This operation targets all records where the REVIEWER_ID column matches the :OLD.EMPLOYEE_ID, thereby removing any performance reviews where the deleted employee was the reviewer.\n\nSixth, the trigger executes an UPDATE operation on the EMPLOYMENT_HISTORY table. This operation sets the APPROVED_BY column to NULL for any records where the APPROVED_BY column equals :OLD.EMPLOYEE_ID, effectively removing the deleted employee's approval association from historical entries.\n\nSeventh, the trigger executes an UPDATE operation on the DEPARTMENTS table. This operation sets the HEAD_ID column to NULL for any records where the HEAD_ID column equals :OLD.EMPLOYEE_ID, ensuring no department retains the deleted employee as its head.\n\nEighth and finally, the trigger executes an UPDATE operation on the TEAMS table. This operation sets the MANAGER_ID column to NULL for any records where the MANAGER_ID column equals :OLD.EMPLOYEE_ID, ensuring no team retains the deleted employee as its manager.\n\nAll these operations are executed sequentially within the trigger body, and each data manipulation statement uses the :OLD.EMPLOYEE_ID value to identify records related to the specific employee row being deleted from the EMPLOYEES table.",
    "original_summary": "Create a BEFORE DELETE FOR EACH ROW trigger named trg_maintain_employee_dependencies on the EMPLOYEES table. For each deleted row, delete related records from PERFORMANCE_REVIEWS, EMPLOYMENT_HISTORY, SALARY_HISTORY, and BENEFITS tables. Update EMPLOYMENT_HISTORY to set APPROVED_BY to NULL where it matches the deleted EMPLOYEE_ID. Update DEPARTMENTS and TEAMS to set HEAD_ID and MANAGER_ID to NULL respectively where they match the deleted EMPLOYEE_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE DELETE FOR EACH ROW trigger designated as trg_maintain_employee_dependencies on the EMPLOYEES table. For each row that is to be deleted, it is necessary to delete the corresponding records from the PERFORMANCE_REVIEWS, EMPLOYMENT_HISTORY, SALARY_HISTORY, and BENEFITS tables. Furthermore, within the EMPLOYMENT_HISTORY table, the APPROVED_BY column should be updated to a NULL value for any entries matching the deleted EMPLOYEE_ID. Additionally, in the DEPARTMENTS and TEAMS tables, the HEAD_ID and MANAGER_ID columns, respectively, must be set to NULL wherever they correspond to the deleted EMPLOYEE_ID."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_step_count that is executed before an insert operation on the TEST_CASE_STEPS table. This trigger operates for each row being inserted. It declares a local variable v_step_count of type NUMBER to store the count of existing steps for a specific test case. The trigger performs a SELECT COUNT(*) operation to determine the number of rows in the TEST_CASE_STEPS table where the TEST_CASE_ID column matches the TEST_CASE_ID value of the row being inserted, referenced as :NEW.TEST_CASE_ID. The result of this count is stored in the v_step_count variable. The trigger then evaluates a conditional statement: if the value of v_step_count is greater than or equal to 10, it raises an application error using the RAISE_APPLICATION_ERROR function with an error code of -20001 and an error message stating 'Maximum 10 steps allowed per test case'. This prevents the insertion of the new row if the test case already has 10 or more steps.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_step_count\nBEFORE INSERT ON TEST_CASE_STEPS\nFOR EACH ROW\nDECLARE\n  v_step_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_step_count FROM TEST_CASE_STEPS WHERE TEST_CASE_ID = :NEW.TEST_CASE_ID;\n  IF v_step_count >= 10 THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Maximum 10 steps allowed per test case');\n  END IF;\nEND;",
    "database_name": "software_taqam_71174",
    "tables": [
      "TEST_CASES",
      "DEFECTS",
      "TEST_CASE_ACTUAL_RESULTS",
      "TEST_CASE_STEPS"
    ],
    "call_sqls": [
      "INSERT INTO TEST_CASE_STEPS (STEP_ID, TEST_CASE_ID, STEP_NUMBER, STEP_DESCRIPTION) VALUES (1, 1, 1, 'Step 1 for test case 1')",
      "INSERT INTO TEST_CASE_STEPS (STEP_ID, TEST_CASE_ID, STEP_NUMBER, STEP_DESCRIPTION) VALUES (2, 1, 2, 'Step 2 for test case 1')",
      "INSERT INTO TEST_CASE_STEPS (STEP_ID, TEST_CASE_ID, STEP_NUMBER, STEP_DESCRIPTION) VALUES (3, 1, 3, 'Step 3 for test case 1')",
      "INSERT INTO TEST_CASE_STEPS (STEP_ID, TEST_CASE_ID, STEP_NUMBER, STEP_DESCRIPTION) VALUES (4, 1, 4, 'Step 4 for test case 1')",
      "INSERT INTO TEST_CASE_STEPS (STEP_ID, TEST_CASE_ID, STEP_NUMBER, STEP_DESCRIPTION) VALUES (5, 1, 5, 'Step 5 for test case 1')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_validate_step_count that fires BEFORE INSERT on each row of the TEST_CASE_STEPS table to ensure no more than 10 steps exist for a given TEST_CASE_ID, raising an error with the message 'Maximum 10 steps allowed per test case' if the limit is exceeded.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_validate_step_count that, before inserting each new row into the TEST_CASE_STEPS table, checks the current number of steps for the given TEST_CASE_ID. If the count is already 10 or more, prevent the insertion by raising an error with the message 'Maximum 10 steps allowed per test case'.",
    "id": 41,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_validate_step_count that is configured to execute automatically BEFORE an INSERT operation on the TEST_CASE_STEPS table, and for EACH ROW being inserted. This trigger declares a local numeric variable named v_step_count. The trigger then performs a SELECT operation to count the existing rows in the TEST_CASE_STEPS table. Specifically, it executes a SELECT COUNT(*) INTO v_step_count FROM TEST_CASE_STEPS WHERE the TEST_CASE_ID column in the table matches the value of the TEST_CASE_ID column from the new row being inserted, which is referenced as :NEW.TEST_CASE_ID. After retrieving the count, the trigger evaluates a conditional IF statement: IF v_step_count >= 10 THEN. If this condition is true, meaning that the current number of steps for the given TEST_CASE_ID is already 10 or more, the trigger prevents the insertion by raising an application error using the RAISE_APPLICATION_ERROR procedure with an error number of -20001 and the error message 'Maximum 10 steps allowed per test case'. If the condition is false, meaning the count is less than 10, the trigger does nothing and allows the INSERT operation to proceed normally.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_validate_step_count on the TEST_CASE_STEPS table. For each new row, count the existing steps for the same TEST_CASE_ID. If the count is 10 or more, raise an application error (-20001) with the message 'Maximum 10 steps allowed per test case' to prevent the insertion.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a BEFORE INSERT FOR EACH ROW trigger called trg_validate_step_count for the TEST_CASE_STEPS table. For each new row, count the current steps for that TEST_CASE_ID. If the count reaches 10 or more, prevent the insertion by raising an application error (-20001) with the message 'Maximum 10 steps allowed per test case'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_GAMES_BEFORE_INSERT_CALC that is defined to fire automatically before any row insertion operation is performed on the GAMES table, and for each individual row being inserted, the trigger executes a block of code that calculates a value for the POINT_DIFFERENCE column of the new row by taking the value from the TEAM_POINTS column of the new row and subtracting from it the value from the OPPONENT_POINTS column of the new row, and then assigns the result of this arithmetic subtraction operation back to the POINT_DIFFERENCE column of the new row.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_GAMES_BEFORE_INSERT_CALC\nBEFORE INSERT ON GAMES\nFOR EACH ROW\nBEGIN\n    :NEW.POINT_DIFFERENCE := :NEW.TEAM_POINTS - :NEW.OPPONENT_POINTS;\nEND;",
    "database_name": "sports_tpa_analytics",
    "tables": [
      "GAMES",
      "OPPONENTS"
    ],
    "call_sqls": [
      "INSERT INTO GAMES (GAME_ID, OPPONENT_RANK, OPPONENT_NAME, RESULT, EFFECT, STATUS, PCT_OF_RANKING, GAME_DATE, EVENT_NAME, WIN, TEAM_POINTS, OPPONENT_POINTS, GAME_SCORE, OPPONENT_RATING, TEAM_RATING_POSTGAME, GAME_VALUE, TEAM_RATING_PREGAME, GAME_VALUE_USED, RATINGS_IMPACT, TEAM_ID, GAME_NUMBER, LOCATION, WEATHER_CONDITIONS, ATTENDANCE, GAME_DURATION, REFEREE_NAME, QUARTER_SCORES, PLAYER_PERFORMANCE) \nVALUES (1, 5, 'Team A', 'Win', 10, 'Completed', 75, '2023-10-01', 'Championship', 1, 100, 90, 190, 85, 95, 50, 90, 45, 5, 101, 1, 'Stadium A', 'Sunny', 50000, 120, 'Referee A', '25-25-25-25', 'Excellent')",
      "INSERT INTO GAMES (GAME_ID, OPPONENT_RANK, OPPONENT_NAME, RESULT, EFFECT, STATUS, PCT_OF_RANKING, GAME_DATE, EVENT_NAME, WIN, TEAM_POINTS, OPPONENT_POINTS, GAME_SCORE, OPPONENT_RATING, TEAM_RATING_POSTGAME, GAME_VALUE, TEAM_RATING_PREGAME, GAME_VALUE_USED, RATINGS_IMPACT, TEAM_ID, GAME_NUMBER, LOCATION, WEATHER_CONDITIONS, ATTENDANCE, GAME_DURATION, REFEREE_NAME, QUARTER_SCORES, PLAYER_PERFORMANCE) \nVALUES (2, 10, 'Team B', 'Loss', -5, 'Completed', 60, '2023-10-02', 'League Match', 0, 85, 95, 180, 80, 90, 45, 85, 40, -5, 102, 2, 'Stadium B', 'Cloudy', 30000, 110, 'Referee B', '20-20-20-25', 'Good')",
      "INSERT INTO GAMES (GAME_ID, OPPONENT_RANK, OPPONENT_NAME, RESULT, EFFECT, STATUS, PCT_OF_RANKING, GAME_DATE, EVENT_NAME, WIN, TEAM_POINTS, OPPONENT_POINTS, GAME_SCORE, OPPONENT_RATING, TEAM_RATING_POSTGAME, GAME_VALUE, TEAM_RATING_PREGAME, GAME_VALUE_USED, RATINGS_IMPACT, TEAM_ID, GAME_NUMBER, LOCATION, WEATHER_CONDITIONS, ATTENDANCE, GAME_DURATION, REFEREE_NAME, QUARTER_SCORES, PLAYER_PERFORMANCE) \nVALUES (3, 3, 'Team C', 'Win', 15, 'Completed', 80, '2023-10-03', 'Friendly', 1, 110, 85, 195, 90, 100, 55, 95, 50, 10, 103, 3, 'Stadium C', 'Rainy', 20000, 130, 'Referee C', '30-30-30-20', 'Outstanding')",
      "INSERT INTO GAMES (GAME_ID, OPPONENT_RANK, OPPONENT_NAME, RESULT, EFFECT, STATUS, PCT_OF_RANKING, GAME_DATE, EVENT_NAME, WIN, TEAM_POINTS, OPPONENT_POINTS, GAME_SCORE, OPPONENT_RATING, TEAM_RATING_POSTGAME, GAME_VALUE, TEAM_RATING_PREGAME, GAME_VALUE_USED, RATINGS_IMPACT, TEAM_ID, GAME_NUMBER, LOCATION, WEATHER_CONDITIONS, ATTENDANCE, GAME_DURATION, REFEREE_NAME, QUARTER_SCORES, PLAYER_PERFORMANCE) \nVALUES (4, 8, 'Team D', 'Draw', 0, 'Completed', 70, '2023-10-04', 'Tournament', 0, 95, 95, 190, 85, 95, 50, 90, 45, 0, 104, 4, 'Stadium D', 'Windy', 40000, 125, 'Referee D', '25-25-25-25', 'Average')",
      "INSERT INTO GAMES (GAME_ID, OPPONENT_RANK, OPPONENT_NAME, RESULT, EFFECT, STATUS, PCT_OF_RANKING, GAME_DATE, EVENT_NAME, WIN, TEAM_POINTS, OPPONENT_POINTS, GAME_SCORE, OPPONENT_RATING, TEAM_RATING_POSTGAME, GAME_VALUE, TEAM_RATING_PREGAME, GAME_VALUE_USED, RATINGS_IMPACT, TEAM_ID, GAME_NUMBER, LOCATION, WEATHER_CONDITIONS, ATTENDANCE, GAME_DURATION, REFEREE_NAME, QUARTER_SCORES, PLAYER_PERFORMANCE) \nVALUES (5, 6, 'Team E', 'Win', 20, 'Completed', 85, '2023-10-05', 'Final', 1, 120, 100, 220, 95, 105, 60, 100, 55, 15, 105, 5, 'Stadium E', 'Clear', 60000, 140, 'Referee E', '35-35-35-15', 'Exceptional')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_GAMES_BEFORE_INSERT_CALC that, before inserting each new row into the GAMES table, calculates the POINT_DIFFERENCE by subtracting the OPPONENT_POINTS from the TEAM_POINTS for that row and sets the POINT_DIFFERENCE column to this computed value.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_GAMES_BEFORE_INSERT_CALC that runs before inserting new rows into the GAMES table, calculating the POINT_DIFFERENCE for each new row by subtracting OPPONENT_POINTS from TEAM_POINTS.",
    "id": 42,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_GAMES_BEFORE_INSERT_CALC that is defined to fire automatically before any row insertion operation is performed on the GAMES table, and for each individual row being inserted, the trigger executes a block of code that calculates a value for the POINT_DIFFERENCE column of the new row by taking the value from the TEAM_POINTS column of the new row and subtracting from it the value from the OPPONENT_POINTS column of the new row, and then assigns the result of this arithmetic subtraction operation back to the POINT_DIFFERENCE column of the new row.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named TRG_GAMES_BEFORE_INSERT_CALC on the GAMES table. For each new row, set the POINT_DIFFERENCE column to the value of the TEAM_POINTS column minus the value of the OPPONENT_POINTS column from the same new row.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the GAMES table that runs before any new entries are added. It should figure out the POINT_DIFFERENCE by taking the TEAM_POINTS and subtracting the OPPONENT_POINTS from that same new row. Make sure the trigger name is something like TRG_GAMES_BEFORE_INSERT_CALC."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_PARKS_SIZE_UPD that is executed before an update operation on the SIZE_ACRES column of the PARKS table. This trigger operates on each row that is being updated. Within the trigger, it evaluates the new value of the SIZE_ACRES column for the row being updated. If the new SIZE_ACRES value is greater than or equal to 1, the trigger sets the CATEGORY_ID column of the same row to 0. If the new SIZE_ACRES value is less than 1, the trigger sets the CATEGORY_ID column to 1. The trigger uses a CASE statement to determine the appropriate value for CATEGORY_ID based on the condition of the SIZE_ACRES column.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PARKS_SIZE_UPD\nBEFORE UPDATE OF SIZE_ACRES ON PARKS\nFOR EACH ROW\nBEGIN\n    :NEW.CATEGORY_ID := CASE WHEN :NEW.SIZE_ACRES >= 1 THEN 0 ELSE 1 END;\nEND;",
    "database_name": "urban_psacs_tracking",
    "tables": [
      "BOROUGHS",
      "CATEGORIES",
      "CRIME_CATEGORIES",
      "CRIME_STATISTICS",
      "CRIME_STATISTICS_BRIDGE",
      "PARKS"
    ],
    "call_sqls": [
      "UPDATE PARKS SET SIZE_ACRES = 2 WHERE PARK_ID = 0",
      "UPDATE PARKS SET SIZE_ACRES = 0.5 WHERE PARK_ID = 1",
      "UPDATE PARKS SET SIZE_ACRES = 1.5 WHERE PARK_ID = 0",
      "UPDATE PARKS SET SIZE_ACRES = 0.8 WHERE PARK_ID = 1",
      "UPDATE PARKS SET SIZE_ACRES = 3 WHERE PARK_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_PARKS_SIZE_UPD that fires before each row update on the PARKS table when the SIZE_ACRES column is modified, and for each updated row, sets the CATEGORY_ID to 0 if the new SIZE_ACRES value is 1 or more, otherwise sets CATEGORY_ID to 1.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_PARKS_SIZE_UPD that fires before each row update on the PARKS table when the SIZE_ACRES column is modified, and for each updated row, sets the CATEGORY_ID to 0 if the new SIZE_ACRES value is 1 or more, otherwise sets CATEGORY_ID to 1.",
    "id": 43,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_PARKS_SIZE_UPD that is executed before an update operation on the SIZE_ACRES column of the PARKS table. This trigger operates on each row that is being updated. Within the trigger, it evaluates the new value of the SIZE_ACRES column for the row being updated. If the new SIZE_ACRES value is greater than or equal to 1, the trigger sets the CATEGORY_ID column of the same row to 0. If the new SIZE_ACRES value is less than 1, the trigger sets the CATEGORY_ID column to 1. The trigger uses a CASE statement to determine the appropriate value for CATEGORY_ID based on the condition of the SIZE_ACRES column.",
    "original_summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named TRG_PARKS_SIZE_UPD on the PARKS table, firing when the SIZE_ACRES column is updated. For each updated row, set the CATEGORY_ID to 0 if :NEW.SIZE_ACRES >= 1, otherwise set it to 1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How do you create a BEFORE UPDATE FOR EACH ROW trigger named TRG_PARKS_SIZE_UPD on the PARKS table that fires when the SIZE_ACRES column is updated, and for each updated row, sets the CATEGORY_ID to 0 if :NEW.SIZE_ACRES is greater than or equal to 1, otherwise sets it to 1?"
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_loan_officer_assign that fires before each row is inserted into the LOANS table, declaring local variables v_officer_id of the same type as the OFFICER_ID column in the LOAN_OFFICERS table and v_officer_count as a NUMBER. The trigger first executes a SELECT statement to count all rows in the LOAN_OFFICERS table where the STATUS column equals the string 'active', storing the result in v_officer_count. It then evaluates a conditional IF statement: if v_officer_count equals zero OR if the new value for the BORROWER_ID column in the LOANS table (referenced as :NEW.BORROWER_ID) is NULL, the trigger sets the new value for the LOAN_OFFICER_ID column to NULL. If that condition is false, the trigger enters a nested BEGIN block where it executes a SELECT statement to retrieve an OFFICER_ID; this SELECT statement uses a subquery that selects the OFFICER_ID and a ROW_NUMBER computed by the ROW_NUMBER() analytic function over a window ordered by OFFICER_ID, from the LOAN_OFFICERS table filtered for rows where STATUS equals 'active'; the outer query filters this result set to where the computed row number (aliased as rn) equals the result of the MOD function applied to :NEW.BORROWER_ID and v_officer_count, with 1 added to that result. The retrieved OFFICER_ID is stored in v_officer_id and then assigned to :NEW.LOAN_OFFICER_ID. This nested block includes an EXCEPTION handler for the NO_DATA_FOUND exception, which sets :NEW.LOAN_OFFICER_ID to NULL if the SELECT INTO statement fails to return a row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_loan_officer_assign\nBEFORE INSERT ON LOANS\nFOR EACH ROW\nDECLARE\n  v_officer_id    LOAN_OFFICERS.OFFICER_ID%TYPE;\n  v_officer_count NUMBER;\nBEGIN\n  -- Get the count of active loan officers\n  SELECT COUNT(*) INTO v_officer_count FROM LOAN_OFFICERS WHERE STATUS = 'active';\n\n  -- Handle cases where there are no active officers or BORROWER_ID is NULL\n  IF v_officer_count = 0 OR :NEW.BORROWER_ID IS NULL THEN\n    :NEW.LOAN_OFFICER_ID := NULL; -- Assign NULL if no active officers or borrower ID is unknown\n  ELSE\n    -- Assign a loan officer based on a round-robin approach using BORROWER_ID\n    -- The +1 is because MOD returns 0 to (divisor-1), and ROW_NUMBER starts from 1.\n    -- ORDER BY OFFICER_ID ensures deterministic assignment for ROW_NUMBER.\n    BEGIN\n      SELECT OFFICER_ID INTO v_officer_id\n        FROM (SELECT OFFICER_ID, ROW_NUMBER() OVER (ORDER BY OFFICER_ID) AS rn\n                FROM LOAN_OFFICERS\n               WHERE STATUS = 'active')\n       WHERE rn = MOD(:NEW.BORROWER_ID, v_officer_count) + 1;\n\n      :NEW.LOAN_OFFICER_ID := v_officer_id;\n    EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n        -- This could happen if the MOD result + 1 somehow doesn't map to an existing rn,\n        -- which should ideally not happen if v_officer_count > 0 and BORROWER_ID is not NULL.\n        -- As a fallback, assign NULL.\n        :NEW.LOAN_OFFICER_ID := NULL;\n    END;\n  END IF;\nEND;",
    "database_name": "loan_maf_analytics",
    "tables": [
      "BORROWERS",
      "LOANS",
      "LOAN_OFFICERS",
      "PAYMENTS"
    ],
    "call_sqls": [
      "INSERT INTO LOANS (LOAN_ID, LOAN_AMNT, BORROWER_ID) VALUES (1000, 5000, 1)",
      "INSERT INTO LOANS (LOAN_ID, LOAN_AMNT, BORROWER_ID, LOAN_PURPOSE) VALUES (1001, 10000, 5, 'Home Improvement')",
      "INSERT INTO LOANS (LOAN_ID, LOAN_AMNT, BORROWER_ID, LOAN_STATUS) VALUES (1002, 7500, 3, 'Pending')",
      "INSERT INTO LOANS (LOAN_ID, LOAN_AMNT, BORROWER_ID, TERM) VALUES (1003, 3000, 7, '36 months')",
      "INSERT INTO LOANS (LOAN_ID, LOAN_AMNT) VALUES (1004, 2000)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_loan_officer_assign that fires BEFORE INSERT on each row of the LOANS table to assign a LOAN_OFFICER_ID. If there are no active loan officers in the LOAN_OFFICERS table (where STATUS is 'active') or if the new BORROWER_ID is NULL, set the new LOAN_OFFICER_ID to NULL. Otherwise, assign a LOAN_OFFICER_ID by selecting an active officer's OFFICER_ID using a round-robin method based on the new BORROWER_ID, ordering by OFFICER_ID to ensure deterministic assignment. If no officer is found during this assignment, set LOAN_OFFICER_ID to NULL as a fallback.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_loan_officer_assign that fires before inserting a new row into the LOANS table. If there are no active loan officers in the LOAN_OFFICERS table or if the new BORROWER_ID is empty, set the LOAN_OFFICER_ID to NULL. Otherwise, assign a loan officer to the new loan by using the BORROWER_ID to select an active officer in a round-robin manner from the LOAN_OFFICERS table; if no officer is found through this method, default the LOAN_OFFICER_ID to NULL.",
    "id": 44,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_loan_officer_assign that fires before each row is inserted into the LOANS table, declaring local variables v_officer_id of the same type as the OFFICER_ID column in the LOAN_OFFICERS table and v_officer_count as a NUMBER. The trigger first executes a SELECT statement to count all rows in the LOAN_OFFICERS table where the STATUS column equals the string 'active', storing the result in v_officer_count. It then evaluates a conditional IF statement: if v_officer_count equals zero OR if the new value for the BORROWER_ID column in the LOANS table (referenced as :NEW.BORROWER_ID) is NULL, the trigger sets the new value for the LOAN_OFFICER_ID column to NULL. If that condition is false, the trigger enters a nested BEGIN block where it executes a SELECT statement to retrieve an OFFICER_ID; this SELECT statement uses a subquery that selects the OFFICER_ID and a ROW_NUMBER computed by the ROW_NUMBER() analytic function over a window ordered by OFFICER_ID, from the LOAN_OFFICERS table filtered for rows where STATUS equals 'active'; the outer query filters this result set to where the computed row number (aliased as rn) equals the result of the MOD function applied to :NEW.BORROWER_ID and v_officer_count, with 1 added to that result. The retrieved OFFICER_ID is stored in v_officer_id and then assigned to :NEW.LOAN_OFFICER_ID. This nested block includes an EXCEPTION handler for the NO_DATA_FOUND exception, which sets :NEW.LOAN_OFFICER_ID to NULL if the SELECT INTO statement fails to return a row.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_loan_officer_assign on the LOANS table. If no active loan officers exist or the new BORROWER_ID is NULL, set the new LOAN_OFFICER_ID to NULL. Otherwise, assign a LOAN_OFFICER_ID by selecting an active officer's ID using a round-robin method based on the new BORROWER_ID. Handle NO_DATA_FOUND by setting LOAN_OFFICER_ID to NULL.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires before a new row goes into the LOANS table. Call it trg_loan_officer_assign. Here's the deal: if there aren't any active loan officers hanging around, or if the new borrower ID is just plain empty, then slap a NULL into the LOAN_OFFICER_ID field. Otherwise, you gotta pick an officer for this new loan. Use the new borrower's ID to do a round-robin pick from the pool of active officers. Oh, and if that round-robin search comes up totally empty, just default the LOAN_OFFICER_ID back to NULL. Keep it simple."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_prediction that is defined to fire automatically before any row insertion operation on the PREDICTIONS table, and for each individual row being inserted, it declares a local variable v_exists of type NUMBER, then executes a SELECT statement that counts the number of rows in the PROPERTIES table where the PROPERTY_ID column value equals the new PROPERTY_ID value from the :NEW pseudorecord of the triggering row, storing the result into v_exists, and then checks a condition where if v_exists equals zero, meaning no matching PROPERTY_ID exists in the PROPERTIES table, it performs an INSERT operation into the PROPERTIES table, specifying the PROPERTY_ID column to receive the value from the :NEW.PROPERTY_ID pseudorecord.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_prediction\nBEFORE INSERT ON PREDICTIONS\nFOR EACH ROW\nDECLARE\n  v_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_exists FROM PROPERTIES WHERE PROPERTY_ID = :NEW.PROPERTY_ID;\n  IF v_exists = 0 THEN\n    INSERT INTO PROPERTIES (PROPERTY_ID) VALUES (:NEW.PROPERTY_ID);\n  END IF;\nEND;",
    "database_name": "real_eauda_73520",
    "tables": [
      "PROPERTIES",
      "PROPERTY_VALUES",
      "PREDICTIONS"
    ],
    "call_sqls": [
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1001, 500, 350000, '2024-01-15', 'Linear_Regression_v1')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1002, 501, 275000, '2024-01-16', 'Random_Forest_v2')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1003, 500, 355000, '2024-01-17', 'Neural_Network_v3')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1004, 999, 420000, '2024-01-18', 'Gradient_Boosting_v1')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, PROPERTY_ID, PREDICTED_VALUE, PREDICTION_DATE, MODEL_USED) VALUES (1005, 502, 190000, '2024-01-19', 'Linear_Regression_v1')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_validate_prediction that fires BEFORE INSERT on each row of the PREDICTIONS table, and if the inserted PROPERTY_ID does not already exist in the PROPERTIES table, it automatically inserts that PROPERTY_ID into the PROPERTIES table.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_validate_prediction that, before each row is inserted into the PREDICTIONS table, checks if the inserted PROPERTY_ID already exists in the PROPERTIES table; if it does not exist, the trigger should insert that PROPERTY_ID into the PROPERTIES table.",
    "id": 45,
    "generated_ir": "Write an Oracle PL/SQL database trigger named trg_validate_prediction that is activated immediately before an INSERT operation is performed on each row of the PREDICTIONS table. This trigger is defined as a BEFORE INSERT FOR EACH ROW trigger, meaning its body executes once for each individual row that is about to be inserted into the PREDICTIONS table during the INSERT statement. Upon activation for each row, the trigger performs a validation check to ensure referential integrity. It executes a SELECT statement that queries the PROPERTIES table, specifically checking for the existence of a row where the PROPERTY_ID column matches the value of the PROPERTY_ID column from the row currently being inserted into the PREDICTIONS table. This value is accessed using the :NEW.PROPERTY_ID pseudorecord reference. The SELECT statement uses a COUNT(*) function to determine the number of matching rows. If the count returns zero, indicating that the PROPERTY_ID does not exist in the PROPERTIES table, the trigger then performs an INSERT operation into the PROPERTIES table. This INSERT operation populates the PROPERTY_ID column in the PROPERTIES table with the value from :NEW.PROPERTY_ID. If the count is greater than zero, indicating the PROPERTY_ID already exists, the trigger takes no further action for that specific row. The trigger's purpose is to automatically maintain referential integrity by ensuring any PROPERTY_ID referenced in a new PREDICTIONS record is first added to the PROPERTIES table if it is not already present.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_validate_prediction on the PREDICTIONS table. If the inserted PROPERTY_ID does not exist in the PROPERTIES table, insert it into PROPERTIES.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE INSERT FOR EACH ROW trigger designated as trg_validate_prediction for the PREDICTIONS table. The trigger's function is to verify the existence of the inserted PROPERTY_ID within the PROPERTIES table. Should the PROPERTY_ID not be present, the trigger must facilitate its insertion into the PROPERTIES table."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_agile_coaches_audit` that is configured to execute automatically `AFTER` any `INSERT` operation is successfully performed on the `AGILE_COACHES` table. Upon activation, this trigger performs a single `INSERT` operation into the `COLLABORATION` table. The `INSERT` statement populates five columns in the `COLLABORATION` table: `COLLABORATION_ID`, `DEPT_ID`, `COACH_ID`, `TOPIC`, and `CREATED_DATE`. The values for these columns are derived from a `SELECT` statement. For the `COLLABORATION_ID` column, the value is calculated by adding `1000` to the `ROWNUM` pseudocolumn, which assigns a sequential number to each row returned by the subquery. For the `DEPT_ID` column, the value is directly selected from the `DEPT_ID` column of the `AGILE_COACHES` table. Similarly, for the `COACH_ID` column, the value is directly selected from the `COACH_ID` column of the `AGILE_COACHES` table. The `TOPIC` column is assigned a static string literal value of `'New Coach Onboarding'`. The `CREATED_DATE` column is populated by converting the current system date and time, obtained using the `SYSDATE` function, into a character string formatted as 'YYYY-MM-DD' using the `TO_CHAR` function. The `SELECT` statement that provides these values includes a `WHERE` clause that filters the rows from the `AGILE_COACHES` table. This `WHERE` clause specifies that only the row(s) where the `COACH_ID` column matches the maximum `COACH_ID` currently present in the `AGILE_COACHES` table should be considered. This maximum `COACH_ID` is determined by a subquery `(SELECT MAX(COACH_ID) FROM AGILE_COACHES)`. Consequently, this trigger effectively inserts a new record into the `COLLABORATION` table for the most recently added coach (assuming `COACH_ID` is an auto-incrementing or sequentially increasing identifier) with a predefined topic and the current date.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_agile_coaches_audit\nAFTER INSERT ON AGILE_COACHES\nBEGIN\n  INSERT INTO COLLABORATION (COLLABORATION_ID, DEPT_ID, COACH_ID, TOPIC, CREATED_DATE)\n  SELECT 1000 + ROWNUM, DEPT_ID, COACH_ID, 'New Coach Onboarding', TO_CHAR(SYSDATE, 'YYYY-MM-DD')\n  FROM AGILE_COACHES\n  WHERE COACH_ID = (SELECT MAX(COACH_ID) FROM AGILE_COACHES);\nEND;",
    "database_name": "healthcare_dar_assessment",
    "tables": [
      "AGILE_COACHES",
      "COLLABORATION"
    ],
    "call_sqls": [
      "INSERT INTO AGILE_COACHES (COACH_ID, COACH_NAME, EMAIL, DEPT_ID, CONTACT_NUMBER, CREATED_DATE, UPDATED_DATE) VALUES (2, 'Michael Chen', 'michael.chen@agilecoach.org', 101, '555-9012', '2024-01-15', '2024-01-15')",
      "INSERT INTO AGILE_COACHES (COACH_ID, COACH_NAME, EMAIL, DEPT_ID, CONTACT_NUMBER, CREATED_DATE, UPDATED_DATE) VALUES (3, 'Priya Sharma', 'priya.sharma@agilecoach.org', 102, '555-3456', '2024-01-16', '2024-01-16')",
      "INSERT INTO AGILE_COACHES (COACH_ID, COACH_NAME, EMAIL, DEPT_ID, CONTACT_NUMBER, CREATED_DATE, UPDATED_DATE) VALUES (4, 'David Miller', 'david.miller@agilecoach.org', 103, '555-7890', '2024-01-17', '2024-01-17')",
      "INSERT INTO AGILE_COACHES (COACH_ID, COACH_NAME, EMAIL, DEPT_ID, CONTACT_NUMBER, CREATED_DATE, UPDATED_DATE) VALUES (5, 'Lisa Wang', 'lisa.wang@agilecoach.org', 101, '555-2468', '2024-01-18', '2024-01-18')",
      "INSERT INTO AGILE_COACHES (COACH_ID, COACH_NAME, EMAIL, DEPT_ID, CONTACT_NUMBER, CREATED_DATE, UPDATED_DATE) VALUES (6, 'James Wilson', 'james.wilson@agilecoach.org', 104, '555-1357', '2024-01-19', '2024-01-19')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_agile_coaches_audit that fires after an INSERT on the AGILE_COACHES table, and for each insert operation, it adds a record to the COLLABORATION table for the most recently added coach (identified by the highest COACH_ID). The new record should include a generated COLLABORATION_ID calculated as 1000 plus a sequential number, the coach's DEPT_ID and COACH_ID, the fixed topic 'New Coach Onboarding', and the current date.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_agile_coaches_audit on the AGILE_COACHES table that, after any insert, adds a record to the COLLABORATION table for the most recently added coach, generating a COLLABORATION_ID as 1000 plus ROWNUM, using the coach's DEPT_ID and COACH_ID, setting the topic to 'New Coach Onboarding', and using the current date.",
    "id": 46,
    "generated_ir": "Write an Oracle PL/SQL trigger named `trg_agile_coaches_audit` that is defined to execute `AFTER` any `INSERT` operation on the `AGILE_COACHES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every new row successfully inserted into the `AGILE_COACHES` table.\n\nUpon activation, the trigger performs an `INSERT` operation into the `COLLABORATION` table. The values for the new row in the `COLLABORATION` table are constructed as follows:\n\nThe `COLLABORATION_ID` column is populated by a calculation. The value is derived by adding the literal number `1000` to the value returned by the pseudo-column `ROWNUM`. `ROWNUM` is a pseudo-column that assigns a sequential number to each row returned by a query. In this context, it is used to generate a unique identifier.\n\nThe `DEPT_ID` column is populated directly with the value from the newly inserted row in the `AGILE_COACHES` table, referenced as `:NEW.DEPT_ID`.\n\nThe `COACH_ID` column is populated directly with the value from the newly inserted row in the `AGILE_COACHES` table, referenced as `:NEW.COACH_ID`.\n\nThe `TOPIC` column is set to the literal string `'New Coach Onboarding'`.\n\nThe `COLLABORATION_DATE` column (or a similarly named date column in the `COLLABORATION` table intended to record the date of the collaboration) is set to the current date. This is achieved by using the `SYSDATE` function, which returns the current date and time from the Oracle database server.\n\nThe trigger operates within the `healthcare_dar_assessment` database.",
    "original_summary": "Create an AFTER INSERT statement-level trigger named trg_agile_coaches_audit on the AGILE_COACHES table. After any insert, insert a single record into the COLLABORATION table for the most recently added coach (the one with the maximum COACH_ID). The new record should use a generated COLLABORATION_ID (1000 + ROWNUM), the coach's DEPT_ID and COACH_ID, the static topic 'New Coach Onboarding', and the current date.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER INSERT statement-level trigger named trg_agile_coaches_audit on the AGILE_COACHES table that, after any insert, adds a record to the COLLABORATION table for the most recently added coach? The new record should have a COLLABORATION_ID generated as 1000 plus ROWNUM, use the coach's DEPT_ID and COACH_ID, set the topic to 'New Coach Onboarding', and use the current date."
  },
  {
    "ir": "Write a PL/SQL database trigger named `trg_validate_student_course` that is activated `BEFORE` an `INSERT` operation occurs on the `STUDENT_COURSES` table. This trigger executes `FOR EACH ROW` being inserted.\n\nUpon activation, the trigger declares three local numeric variables: `v_student_exists`, `v_semester_exists`, and `v_course_count`, all initialized to `NUMBER` data type.\n\nThe trigger's execution block begins by performing a `SELECT COUNT(*)` operation on the `STUDENTS` table. This query counts the number of rows where the `STUDENT_ID` column matches the `STUDENT_ID` value of the new row being inserted into `STUDENT_COURSES` (referenced as `:NEW.STUDENT_ID`). The result of this count is stored in the `v_student_exists` variable.\n\nImmediately following this, a conditional `IF` statement checks if the value of `v_student_exists` is equal to `0`. If this condition is true, meaning no matching student was found in the `STUDENTS` table, the trigger raises an application error using `RAISE_APPLICATION_ERROR`. The error code provided is `-20001`, and the associated error message is 'Student does not exist.'. This action prevents the `INSERT` operation on `STUDENT_COURSES` from completing.\n\nNext, the trigger performs another `SELECT COUNT(*)` operation, this time on the `SEMESTERS` table. This query counts the number of rows where the `SEMESTER_ID` column matches the `SEMESTER_ID` value of the new row being inserted into `STUDENT_COURSES` (referenced as `:NEW.SEMESTER_ID`). The result of this count is stored in the `v_semester_exists` variable.\n\nFollowing this, a second conditional `IF` statement checks if the value of `v_semester_exists` is equal to `0`. If this condition is true, indicating that no matching semester was found in the `SEMESTERS` table, the trigger raises an application error using `RAISE_APPLICATION_ERROR`. The error code provided is `-20002`, and the associated error message is 'Semester does not exist.'. This action also prevents the `INSERT` operation on `STUDENT_COURSES` from completing.\n\nSubsequently, the trigger executes a third `SELECT COUNT(*)` operation on the `STUDENT_COURSES` table itself. This query counts the number of existing rows in `STUDENT_COURSES` where both the `STUDENT_ID` column matches the `STUDENT_ID` value of the new row being inserted (referenced as `:NEW.STUDENT_ID`) AND the `SEMESTER_ID` column matches the `SEMESTER_ID` value of the new row being inserted (referenced as `:NEW.SEMESTER_ID`). The result of this count is stored in the `v_course_count` variable.\n\nFinally, a third conditional `IF` statement checks if the value of `v_course_count` is greater than or equal to `5`. If this condition is true, meaning the student is already enrolled in 5 or more courses for the specified semester, the trigger raises an application error using `RAISE_APPLICATION_ERROR`. The error code provided is `-20003`, and the associated error message is 'Student cannot enroll in more than 5 courses per semester.'. This action prevents the `INSERT` operation on `STUDENT_COURSES` from completing.\n\nIf all these conditions are false, meaning the student and semester exist, and the student is not exceeding the course limit for the semester, the trigger completes without raising an error, allowing the `INSERT` operation on `STUDENT_COURSES` to proceed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_student_course\nBEFORE INSERT ON STUDENT_COURSES\nFOR EACH ROW\nDECLARE\n    v_student_exists NUMBER;\n    v_semester_exists NUMBER;\n    v_course_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_student_exists\n    FROM STUDENTS\n    WHERE STUDENT_ID = :NEW.STUDENT_ID;\n\n    IF v_student_exists = 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Student does not exist.');\n    END IF;\n\n    SELECT COUNT(*)\n    INTO v_semester_exists\n    FROM SEMESTERS\n    WHERE SEMESTER_ID = :NEW.SEMESTER_ID;\n\n    IF v_semester_exists = 0 THEN\n        RAISE_APPLICATION_ERROR(-20002, 'Semester does not exist.');\n    END IF;\n\n    SELECT COUNT(*)\n    INTO v_course_count\n    FROM STUDENT_COURSES\n    WHERE STUDENT_ID = :NEW.STUDENT_ID AND SEMESTER_ID = :NEW.SEMESTER_ID;\n\n    IF v_course_count >= 5 THEN\n        RAISE_APPLICATION_ERROR(-20003, 'Student cannot enroll in more than 5 courses per semester.');\n    END IF;\nEND;",
    "database_name": "student_ap_tracking",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSES",
      "SEMESTERS"
    ],
    "call_sqls": [
      "INSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('100', '0', '0', '0', NULL, 'Enrolled')",
      "INSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('101', '1', '0', '1', NULL, 'Enrolled')",
      "INSERT INTO STUDENTS (STUDENT_ID, FIRST_NAME, LAST_NAME, GENDER, EMAIL, DATE_OF_BIRTH, MAJOR, ENROLLMENT_DATE, GRADUATION_DATE, GPA, ADVISER_ID) VALUES ('999', 'Test', 'Student', 'Male', 'test.student@example.com', '2000-01-01', 'Computer Science', '2022-09-01', NULL, 3.0, '0');\nINSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('102', '999', '0', '0', NULL, 'Enrolled')",
      "INSERT INTO SEMESTERS (SEMESTER_ID, SEMESTER_NAME, START_DATE, END_DATE, ACADEMIC_YEAR) VALUES ('999', 'Summer 2025', '2025-06-01', '2025-08-15', '2024-2025');\nINSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('103', '0', '0', '999', NULL, 'Enrolled')",
      "INSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('104', '0', '1', '0', NULL, 'Enrolled');\nINSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('105', '0', '2', '0', NULL, 'Enrolled');\nINSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('106', '0', '3', '0', NULL, 'Enrolled');\nINSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('107', '0', '4', '0', NULL, 'Enrolled');\nINSERT INTO STUDENT_COURSES (ENROLLMENT_ID, STUDENT_ID, COURSE_ID, SEMESTER_ID, GRADE, STATUS) VALUES ('108', '0', '5', '0', NULL, 'Enrolled')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_validate_student_course that fires BEFORE INSERT on the STUDENT_COURSES table for each row, to validate the new enrollment by ensuring the referenced STUDENT_ID exists in the STUDENTS table, the referenced SEMESTER_ID exists in the SEMESTERS table, and that the student is not already enrolled in 5 or more courses for the given semester in the STUDENT_COURSES table, raising specific application errors for any validation failure to prevent the insert.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_validate_student_course that runs before each insert into the STUDENT_COURSES table to ensure the STUDENT_ID exists in the STUDENTS table, the SEMESTER_ID exists in the SEMESTERS table, and the student is not already enrolled in five or more courses for that semester, raising specific errors for any failed validation to block the insert.",
    "id": 47,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_validate_student_course that is executed before an insert operation on the STUDENT_COURSES table for each row being inserted. The trigger performs three distinct validations to ensure data integrity and business rules are met before allowing the insertion to proceed. First, it verifies that the STUDENT_ID value in the new row exists in the STUDENTS table by attempting to select the STUDENT_ID from the STUDENTS table where it matches the new row's STUDENT_ID. If no matching record is found, indicating the student does not exist, the trigger raises an application error with a specific message stating that the student ID is invalid. Second, it verifies that the SEMESTER_ID value in the new row exists in the SEMESTERS table by attempting to select the SEMESTER_ID from the SEMESTERS table where it matches the new row's SEMESTER_ID. If no matching record is found, indicating the semester does not exist, the trigger raises an application error with a specific message stating that the semester ID is invalid. Third, it checks whether the student is already enrolled in five or more courses for the specified semester by counting the number of existing records in the STUDENT_COURSES table where the STUDENT_ID matches the new row's STUDENT_ID and the SEMESTER_ID matches the new row's SEMESTER_ID. If the count is five or greater, indicating the student has reached the maximum allowed course enrollment for that semester, the trigger raises an application error with a specific message stating that the student cannot enroll in more than five courses per semester. Each validation is performed sequentially, and if any validation fails, the trigger raises the corresponding error, which blocks the insert operation. If all validations pass, the trigger allows the insert to proceed without modifying the row.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_validate_student_course on the STUDENT_COURSES table. Validate that the referenced STUDENT_ID exists in the STUDENTS table and that the referenced SEMESTER_ID exists in the SEMESTERS table. Also, ensure the student is not already enrolled in 5 or more courses for the given semester. Raise specific application errors for each validation failure to prevent the insert.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a BEFORE INSERT row-level trigger called trg_validate_student_course for the STUDENT_COURSES table. Check that the STUDENT_ID exists in the STUDENTS table and the SEMESTER_ID exists in the SEMESTERS table. Also, verify the student is not already enrolled in five or more courses for that semester. Raise specific application errors for any failed validation to block the insert."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_individuals_income that is executed before an insert or update operation on the INDIVIDUALS table. This trigger operates on each row affected by the insert or update operation. The trigger checks the value of the CAPITAL_GAIN column in the new row being inserted or updated. If the value of CAPITAL_GAIN is greater than 50,000, the trigger sets the INCOME_BRACKET column of the new row to the string 'High'. The trigger does not perform any other operations, such as inserts, deletes, or function calls, and it does not modify any other columns or tables. The logic flow consists of a single conditional statement that evaluates whether the CAPITAL_GAIN exceeds the specified threshold and, if so, assigns the corresponding income bracket.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_individuals_income\nBEFORE INSERT OR UPDATE ON INDIVIDUALS\nFOR EACH ROW\nBEGIN\n    IF :NEW.CAPITAL_GAIN > 50000 THEN\n        :NEW.INCOME_BRACKET := 'High';\n    END IF;\nEND;",
    "database_name": "demographic_aeda_61583",
    "tables": [
      "COUNTRIES",
      "INDIVIDUALS",
      "MARITAL_STATUSES",
      "OCCUPATIONS",
      "RACES",
      "WORK_CLASSES"
    ],
    "call_sqls": [
      "INSERT INTO INDIVIDUALS (INDIVIDUAL_ID, CAPITAL_GAIN, INCOME_BRACKET) VALUES (1, 60000, NULL)",
      "INSERT INTO INDIVIDUALS (INDIVIDUAL_ID, CAPITAL_GAIN, INCOME_BRACKET) VALUES (2, 40000, 'Low')",
      "UPDATE INDIVIDUALS SET CAPITAL_GAIN = 70000 WHERE INDIVIDUAL_ID = 2",
      "UPDATE INDIVIDUALS SET CAPITAL_GAIN = 50001 WHERE INDIVIDUAL_ID = 1",
      "INSERT INTO INDIVIDUALS (INDIVIDUAL_ID, CAPITAL_GAIN, INCOME_BRACKET) VALUES (3, 50000, 'Medium')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_individuals_income that fires before each row is inserted or updated on the INDIVIDUALS table, and if the new CAPITAL_GAIN value is greater than 50,000, sets the new INCOME_BRACKET to 'High'.",
    "natural_language": "Write a Oracle PL/SQL trigger called trg_update_individuals_income for the INDIVIDUALS table that fires before each new row is inserted or an existing row is updated, and if the new CAPITAL_GAIN value exceeds 50000, then automatically set the INCOME_BRACKET to 'High'.",
    "id": 48,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_individuals_income that is executed before an insert or update operation on the INDIVIDUALS table. This trigger operates on each row affected by the insert or update operation. The trigger checks the value of the CAPITAL_GAIN column in the new row being inserted or updated. If the value of CAPITAL_GAIN is greater than 50,000, the trigger sets the INCOME_BRACKET column of the new row to the string 'High'. The trigger does not perform any other operations, such as inserts, deletes, or function calls, and it does not modify any other columns or tables. The logic flow consists of a single conditional statement that evaluates whether the CAPITAL_GAIN exceeds the specified threshold and, if so, assigns the corresponding income bracket.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_update_individuals_income on the INDIVIDUALS table. For each row, if the new CAPITAL_GAIN value exceeds 50,000, set the new INCOME_BRACKET to 'High'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, set up a trigger called trg_update_individuals_income for the INDIVIDUALS table that fires before a new row is added or an existing one is updated. For each row, if the fresh CAPITAL_GAIN amount is over 50k, then automatically bump the INCOME_BRACKET to 'High'."
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `TRG_CALCULATE_SALARY_IN_USD` on the `JOB_MARKET_DATA` table. This trigger executes before a new row is inserted into the `JOB_MARKET_DATA` table. It declares four local variables: `v_conversion_rate` of type `NUMBER`, `v_region` of type `VARCHAR2(255)`, `v_size_category` of type `VARCHAR2(255)`, and `v_type_count` of type `NUMBER`. The trigger first performs a `SELECT` operation to retrieve the `REGION` from the `COMPANY_LOCATIONS` table and the `SIZE_CATEGORY` from the `COMPANY_SIZES` table. This `SELECT` statement uses `LEFT JOIN` operations from `DUAL` to `COMPANY_LOCATIONS` on `cl.LOCATION_NAME = :NEW.COMPANY_LOCATION` and to `COMPANY_SIZES` on `cs.SIZE_CATEGORY = :NEW.COMPANY_SIZE`. The `NVL` function is applied to `cl.REGION` and `cs.SIZE_CATEGORY` to default to 'Unknown' if the corresponding join condition does not find a match, preventing `NO_DATA_FOUND` errors. The retrieved `REGION` value (or 'Unknown') is stored into `v_region`, and the retrieved `SIZE_CATEGORY` value (or 'Unknown') is stored into `v_size_category`. Next, the trigger executes another `SELECT` statement to count the number of rows in the `EMPLOYMENT_TYPES` table where the `TYPE_NAME` column matches the `EMPLOYMENT_TYPE` value of the new row being inserted (`:NEW.EMPLOYMENT_TYPE`). The result of this `COUNT(*)` operation is stored into `v_type_count`. Following this, a series of conditional `IF-ELSIF-ELSE` statements determine the `v_conversion_rate`. If the `SALARY_CURRENCY` of the new row (`:NEW.SALARY_CURRENCY`) is 'EUR', `v_conversion_rate` is set to 1.07. If `SALARY_CURRENCY` is 'GBP', `v_conversion_rate` is set to 1.25. If `SALARY_CURRENCY` is 'USD', `v_conversion_rate` is set to 1.00. If none of the above currency conditions are met, it checks if `v_region` is 'Europe' AND `v_size_category` is 'L'; if both are true, `v_conversion_rate` is set to 1.05. If none of the preceding conditions are met, `v_conversion_rate` is set to 1.10 as a default. Finally, the trigger calculates the `SALARY_IN_USD` for the new row (`:NEW.SALARY_IN_USD`) by multiplying the `SALARY` of the new row (`:NEW.SALARY`) by the determined `v_conversion_rate` and then rounding the result to the nearest whole number using the `ROUND` function. This calculated value is assigned back to the `SALARY_IN_USD` column of the new row being inserted.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CALCULATE_SALARY_IN_USD\nBEFORE INSERT ON JOB_MARKET_DATA\nFOR EACH ROW\nDECLARE\n    v_conversion_rate NUMBER;\n    v_region VARCHAR2(255);\n    v_size_category VARCHAR2(255);\n    v_type_count NUMBER;\nBEGIN\n    -- Use LEFT JOIN to prevent NO_DATA_FOUND if company location or size doesn't exist\n    SELECT NVL(cl.REGION, 'Unknown'), NVL(cs.SIZE_CATEGORY, 'Unknown')\n    INTO v_region, v_size_category\n    FROM DUAL\n    LEFT JOIN COMPANY_LOCATIONS cl ON cl.LOCATION_NAME = :NEW.COMPANY_LOCATION\n    LEFT JOIN COMPANY_SIZES cs ON cs.SIZE_CATEGORY = :NEW.COMPANY_SIZE;\n\n    -- COUNT(*) will return 0 if no rows match, so NO_DATA_FOUND is not expected here.\n    -- However, for robustness, a block can be used if a single-row select was intended.\n    -- For COUNT(*), it's generally safe.\n    SELECT COUNT(*) INTO v_type_count FROM EMPLOYMENT_TYPES WHERE TYPE_NAME = :NEW.EMPLOYMENT_TYPE;\n\n    IF :NEW.SALARY_CURRENCY = 'EUR' THEN\n        v_conversion_rate := 1.07;\n    ELSIF :NEW.SALARY_CURRENCY = 'GBP' THEN\n        v_conversion_rate := 1.25;\n    ELSIF :NEW.SALARY_CURRENCY = 'USD' THEN\n        v_conversion_rate := 1.00;\n    ELSIF v_region = 'Europe' AND v_size_category = 'L' THEN\n        v_conversion_rate := 1.05;\n    ELSE\n        v_conversion_rate := 1.10;\n    END IF;\n\n    :NEW.SALARY_IN_USD := ROUND(:NEW.SALARY * v_conversion_rate);\nEND;",
    "database_name": "job_mdaae_trends",
    "tables": [
      "JOB_MARKET_DATA",
      "COMPANY_LOCATIONS",
      "COMPANY_SIZES",
      "EMPLOYMENT_TYPES",
      "EXPERIENCE_LEVELS"
    ],
    "call_sqls": [
      "INSERT INTO JOB_MARKET_DATA (DATA_ID, WORK_YEAR, EXPERIENCE_LEVEL, EMPLOYMENT_TYPE, JOB_TITLE, SALARY, SALARY_CURRENCY, EMPLOYEE_RESIDENCE, REMOTE_RATIO, COMPANY_LOCATION, COMPANY_SIZE) VALUES (1, '2023', 'SE', 'Full-time', 'Data Scientist', 50000, 'EUR', 'DE', 0, 'Berlin', 'L')",
      "INSERT INTO JOB_MARKET_DATA (DATA_ID, WORK_YEAR, EXPERIENCE_LEVEL, EMPLOYMENT_TYPE, JOB_TITLE, SALARY, SALARY_CURRENCY, EMPLOYEE_RESIDENCE, REMOTE_RATIO, COMPANY_LOCATION, COMPANY_SIZE) VALUES (2, '2023', 'MI', 'Contract', 'Software Engineer', 60000, 'GBP', 'UK', 100, 'London', 'M')",
      "INSERT INTO JOB_MARKET_DATA (DATA_ID, WORK_YEAR, EXPERIENCE_LEVEL, EMPLOYMENT_TYPE, JOB_TITLE, SALARY, SALARY_CURRENCY, EMPLOYEE_RESIDENCE, REMOTE_RATIO, COMPANY_LOCATION, COMPANY_SIZE) VALUES (3, '2023', 'EN', 'Full-time', 'Data Analyst', 70000, 'USD', 'US', 50, 'New York', 'S')",
      "INSERT INTO JOB_MARKET_DATA (DATA_ID, WORK_YEAR, EXPERIENCE_LEVEL, EMPLOYMENT_TYPE, JOB_TITLE, SALARY, SALARY_CURRENCY, EMPLOYEE_RESIDENCE, REMOTE_RATIO, COMPANY_LOCATION, COMPANY_SIZE) VALUES (4, '2023', 'EX', 'Part-time', 'ML Engineer', 80000, 'JPY', 'JP', 0, 'Tokyo', 'L')",
      "INSERT INTO JOB_MARKET_DATA (DATA_ID, WORK_YEAR, EXPERIENCE_LEVEL, EMPLOYMENT_TYPE, JOB_TITLE, SALARY, SALARY_CURRENCY, EMPLOYEE_RESIDENCE, REMOTE_RATIO, COMPANY_LOCATION, COMPANY_SIZE) VALUES (5, '2023', 'SE', 'Full-time', 'DevOps Engineer', 45000, 'CAD', 'CA', 100, 'Toronto', 'M')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_CALCULATE_SALARY_IN_USD that fires BEFORE INSERT on each row of the JOB_MARKET_DATA table to calculate and set the SALARY_IN_USD. It determines a conversion rate based on the SALARY_CURRENCY: use 1.07 for 'EUR', 1.25 for 'GBP', and 1.00 for 'USD'. If the currency is not one of these, check the company's region from COMPANY_LOCATIONS and size category from COMPANY_SIZES; if the region is 'Europe' and the size category is 'L', use 1.05; otherwise, default to 1.10. Multiply the SALARY by this rate, round the result to the nearest whole number, and assign it to the new row's SALARY_IN_USD.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_CALCULATE_SALARY_IN_USD that fires before inserting a row into the JOB_MARKET_DATA table to calculate the SALARY_IN_USD. For each new entry, determine the conversion rate based on the SALARY_CURRENCY: use 1.07 for 'EUR', 1.25 for 'GBP', and 1.00 for 'USD'. If the currency is not one of these, retrieve the company's region from COMPANY_LOCATIONS and its size from COMPANY_SIZES; if the region is 'Europe' and the size is 'L', set the rate to 1.05, otherwise default to 1.10. Then, multiply the SALARY by this rate, round the result to the nearest whole number, and store it in SALARY_IN_USD.",
    "id": 49,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `TRG_CALCULATE_SALARY_IN_USD` on the `JOB_MARKET_DATA` table. This trigger executes before a new row is inserted into the `JOB_MARKET_DATA` table. It declares four local variables: `v_conversion_rate` of type `NUMBER`, `v_region` of type `VARCHAR2(255)`, `v_size_category` of type `VARCHAR2(255)`, and `v_type_count` of type `NUMBER`. The trigger first performs a `SELECT` operation to retrieve the `REGION` from the `COMPANY_LOCATIONS` table and the `SIZE_CATEGORY` from the `COMPANY_SIZES` table. This `SELECT` statement uses `LEFT JOIN` operations from `DUAL` to `COMPANY_LOCATIONS` on `cl.LOCATION_NAME = :NEW.COMPANY_LOCATION` and to `COMPANY_SIZES` on `cs.SIZE_CATEGORY = :NEW.COMPANY_SIZE`. The `NVL` function is applied to `cl.REGION` and `cs.SIZE_CATEGORY` to default to 'Unknown' if the corresponding join condition does not find a match, preventing `NO_DATA_FOUND` errors. The retrieved `REGION` value (or 'Unknown') is stored into `v_region`, and the retrieved `SIZE_CATEGORY` value (or 'Unknown') is stored into `v_size_category`. Next, the trigger executes another `SELECT` statement to count the number of rows in the `EMPLOYMENT_TYPES` table where the `TYPE_NAME` column matches the `EMPLOYMENT_TYPE` value of the new row being inserted (`:NEW.EMPLOYMENT_TYPE`). The result of this `COUNT(*)` operation is stored into `v_type_count`. Following this, a series of conditional `IF-ELSIF-ELSE` statements determine the `v_conversion_rate`. If the `SALARY_CURRENCY` of the new row (`:NEW.SALARY_CURRENCY`) is 'EUR', `v_conversion_rate` is set to 1.07. If `SALARY_CURRENCY` is 'GBP', `v_conversion_rate` is set to 1.25. If `SALARY_CURRENCY` is 'USD', `v_conversion_rate` is set to 1.00. If none of the above currency conditions are met, it checks if `v_region` is 'Europe' AND `v_size_category` is 'L'; if both are true, `v_conversion_rate` is set to 1.05. If none of the preceding conditions are met, `v_conversion_rate` is set to 1.10 as a default. Finally, the trigger calculates the `SALARY_IN_USD` for the new row (`:NEW.SALARY_IN_USD`) by multiplying the `SALARY` of the new row (`:NEW.SALARY`) by the determined `v_conversion_rate` and then rounding the result to the nearest whole number using the `ROUND` function. This calculated value is assigned back to the `SALARY_IN_USD` column of the new row being inserted.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named TRG_CALCULATE_SALARY_IN_USD on the JOB_MARKET_DATA table. For each new row, calculate the SALARY_IN_USD by multiplying the SALARY by a conversion rate. Determine the rate as follows: 1.07 for 'EUR', 1.25 for 'GBP', 1.00 for 'USD'. If the currency is not one of these, use 1.05 if the company's region (from COMPANY_LOCATIONS) is 'Europe' and its size category (from COMPANY_SIZES) is 'L'. Otherwise, default to 1.10. Use LEFT JOINs and NVL to handle missing data. Finally, round the calculated salary to the nearest whole number and assign it to :NEW.SALARY_IN_USD.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires before a new row gets popped into the JOB_MARKET_DATA table. Call it TRG_CALCULATE_SALARY_IN_USD. For every fresh entry, we've gotta figure out the SALARY_IN_USD. Basically, take the SALARY and multiply it by a conversion rate. Here's the deal on the rates: if the currency's 'EUR', use 1.07; for 'GBP', it's 1.25; and if it's already 'USD', just keep it at 1.00. Now, if the currency isn't any of those, we need to check a couple other tables. Grab the company's region from COMPANY_LOCATIONS and its size from COMPANY_SIZES using LEFT JOINs (and NVL to cover our bases if that info's missing). If the region is 'Europe' and the size is 'L', then the rate is 1.05. If not, just default to 1.10. Finally, round that calculated salary to the nearest whole number and slap it into :NEW.SALARY_IN_USD."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_max_wind_speed that is defined to fire automatically after any update operation that modifies the WIND_SPEED column on the WEATHER_DATA table, executing once for each row affected by the update. Within the trigger body, a local variable v_max_speed of type NUMBER is declared. The trigger logic first performs a SELECT statement on the WEATHER_DATA table to retrieve the maximum WIND_SPEED value for all rows where the POINT_ID column matches the new POINT_ID value from the updated row, storing this result into the v_max_speed variable. Following this, the trigger executes an INSERT statement into the ACCESS_LOGS table, populating its columns with specific values: the LOG_ID column is set to a random integer between 30001 and 40000 generated by ROUND(DBMS_RANDOM.VALUE(30001, 40000)); the USER_ID column is hardcoded to 1; the POINT_ID column is set to the :NEW.POINT_ID from the updated WEATHER_DATA row; the ACCESS_TIME column is set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'); the ACCESS_TYPE column is set to the literal string 'MAX_WIND'; the IP_ADDRESS column is set to the literal string '192.168.1.4'; the USER_AGENT column is set to the literal string 'WIND_AGENT'; the SESSION_ID column is set to a random 14-character alphanumeric string generated by DBMS_RANDOM.STRING('X', 14); and the DATA_ACCESSED column is set to a concatenated string formed by the literal 'MAX_SPEED=' appended with the value of the v_max_speed variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_max_wind_speed\nAFTER UPDATE OF WIND_SPEED ON WEATHER_DATA\nFOR EACH ROW\nDECLARE\n  v_max_speed NUMBER;\nBEGIN\n  SELECT MAX(WIND_SPEED) INTO v_max_speed FROM WEATHER_DATA WHERE POINT_ID = :NEW.POINT_ID;\n  INSERT INTO ACCESS_LOGS (LOG_ID, USER_ID, POINT_ID, ACCESS_TIME, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, SESSION_ID, DATA_ACCESSED)\n  VALUES (ROUND(DBMS_RANDOM.VALUE(30001, 40000)), 1, :NEW.POINT_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 'MAX_WIND', '192.168.1.4', 'WIND_AGENT', DBMS_RANDOM.STRING('X', 14), 'MAX_SPEED=' || v_max_speed);\nEND;",
    "database_name": "meteorological_dcaa_82309",
    "tables": [
      "ACCESS_LOGS",
      "FORECASTING_MODELS",
      "MONITORING_POINTS",
      "USERS",
      "WEATHER_DATA"
    ],
    "call_sqls": [
      "UPDATE WEATHER_DATA SET WIND_SPEED = 4.0 WHERE POINT_ID = 0 AND AVAILABLE_DATE = '0'",
      "UPDATE WEATHER_DATA SET WIND_SPEED = 5.0 WHERE POINT_ID = 1 AND AVAILABLE_DATE = '1'",
      "UPDATE WEATHER_DATA SET WIND_SPEED = 6.0 WHERE POINT_ID = 0 AND AVAILABLE_DATE = '0'",
      "UPDATE WEATHER_DATA SET WIND_SPEED = 7.0 WHERE POINT_ID = 1 AND AVAILABLE_DATE = '1'",
      "UPDATE WEATHER_DATA SET WIND_SPEED = 8.0 WHERE POINT_ID = 0 AND AVAILABLE_DATE = '0'"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_max_wind_speed that fires after each row update to the WIND_SPEED column in the WEATHER_DATA table. For each updated row, it calculates the maximum WIND_SPEED for that POINT_ID from the WEATHER_DATA table, then inserts a log record into the ACCESS_LOGS table with a random LOG_ID between 30001 and 40000, USER_ID set to 1, the POINT_ID from the updated row, the current timestamp, ACCESS_TYPE as 'MAX_WIND', IP_ADDRESS as '192.168.1.4', USER_AGENT as 'WIND_AGENT', a random 14-character SESSION_ID, and DATA_ACCESSED as 'MAX_SPEED=' concatenated with the calculated maximum wind speed.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_max_wind_speed that runs AFTER UPDATE on the WIND_SPEED column of the WEATHER_DATA table for each updated row, calculates the maximum WIND_SPEED for that row's POINT_ID, and logs an entry into the ACCESS_LOGS table with a randomly generated LOG_ID between 30001 and 40000, USER_ID as 1, the POINT_ID, the current timestamp, ACCESS_TYPE as 'MAX_WIND', IP_ADDRESS as '192.168.1.4', USER_AGENT as 'WIND_AGENT', a random 14-character SESSION_ID, and DATA_ACCESSED as 'MAX_SPEED=' concatenated with the calculated maximum wind speed.",
    "id": 50,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_max_wind_speed that is defined to fire automatically after any update operation that modifies the WIND_SPEED column on the WEATHER_DATA table, executing once for each row affected by the update. Within the trigger body, a local variable v_max_speed of type NUMBER is declared. The trigger logic first performs a SELECT statement on the WEATHER_DATA table to retrieve the maximum WIND_SPEED value for all rows where the POINT_ID column matches the new POINT_ID value from the updated row, storing this result into the v_max_speed variable. Following this, the trigger executes an INSERT statement into the ACCESS_LOGS table, populating its columns with specific values: the LOG_ID column is set to a random integer between 30001 and 40000 generated by ROUND(DBMS_RANDOM.VALUE(30001, 40000)); the USER_ID column is hardcoded to 1; the POINT_ID column is set to the :NEW.POINT_ID from the updated WEATHER_DATA row; the ACCESS_TIME column is set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'); the ACCESS_TYPE column is set to the literal string 'MAX_WIND'; the IP_ADDRESS column is set to the literal string '192.168.1.4'; the USER_AGENT column is set to the literal string 'WIND_AGENT'; the SESSION_ID column is set to a random 14-character alphanumeric string generated by DBMS_RANDOM.STRING('X', 14); and the DATA_ACCESSED column is set to a concatenated string formed by the literal 'MAX_SPEED=' appended with the value of the v_max_speed variable.",
    "original_summary": "Create an AFTER UPDATE row-level trigger named trg_max_wind_speed on the WEATHER_DATA table for the WIND_SPEED column. For each updated row, calculate the maximum WIND_SPEED for that POINT_ID, then insert a log into ACCESS_LOGS with a random LOG_ID (30001-40000), USER_ID=1, the POINT_ID, current timestamp, ACCESS_TYPE='MAX_WIND', IP='192.168.1.4', USER_AGENT='WIND_AGENT', a random 14-character SESSION_ID, and DATA_ACCESSED='MAX_SPEED=' concatenated with the calculated maximum speed.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a row-level trigger designated as 'trg_max_wind_speed' to execute AFTER UPDATE operations on the WEATHER_DATA table, specifically for the WIND_SPEED column. For each row that is updated, it is required to compute the maximum WIND_SPEED value associated with that row's POINT_ID. Subsequently, an entry must be inserted into the ACCESS_LOGS table. This log entry should contain the following: a LOG_ID generated randomly within the range of 30001 to 40000, a USER_ID set to 1, the respective POINT_ID, the current timestamp, an ACCESS_TYPE of 'MAX_WIND', an IP address of '192.168.1.4', a USER_AGENT string of 'WIND_AGENT', a randomly generated 14-character SESSION_ID, and a DATA_ACCESSED field concatenated from the string 'MAX_SPEED=' and the previously calculated maximum wind speed."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_model_accuracy_check` that is activated `AFTER` a `DELETE` operation occurs on the `FORECASTING_MODELS` table. This trigger declares three local variables: `v_total_accuracy` of type `NUMBER`, `v_user_id` of type `NUMBER`, and `v_point_id` of type `NUMBER`. Upon activation, the trigger first executes a `SELECT` statement to calculate the `SUM` of all `ACCURACY_SCORE` values from the `FORECASTING_MODELS` table where the `IS_ACTIVE` column has a value of `1`. The result of this summation is then stored into the `v_total_accuracy` variable. Following this, the trigger executes another `SELECT` statement to retrieve the `MIN`imum `USER_ID` from the `USERS` table, storing this value into the `v_user_id` variable. Immediately after, it executes a third `SELECT` statement to retrieve the `MIN`imum `POINT_ID` from the `MONITORING_POINTS` table, storing this value into the `v_point_id` variable. Finally, the trigger performs an `INSERT` operation into the `ACCESS_LOGS` table. For the `LOG_ID` column, it inserts a randomly generated number obtained by calling `DBMS_RANDOM.VALUE` to produce a floating-point number between `40001` and `50000`, which is then rounded to the nearest whole number using `ROUND`. For the `USER_ID` column, it inserts the value stored in `v_user_id`. For the `POINT_ID` column, it inserts the value stored in `v_point_id`. For the `ACCESS_TIME` column, it inserts the current system date and time, formatted as a string 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`. For the `ACCESS_TYPE` column, it inserts the literal string `'MODEL_DELETE'`. For the `IP_ADDRESS` column, it inserts the literal string `'192.168.1.5'`. For the `USER_AGENT` column, it inserts the literal string `'MODEL_AGENT'`. For the `SESSION_ID` column, it inserts a randomly generated alphanumeric string of `16` characters by calling `DBMS_RANDOM.STRING('X', 16)`. For the `DATA_ACCESSED` column, it concatenates the literal string `'TOTAL_ACCURACY='` with the string representation of the `v_total_accuracy` variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_model_accuracy_check\nAFTER DELETE ON FORECASTING_MODELS\nDECLARE\n  v_total_accuracy NUMBER;\n  v_user_id        NUMBER;\n  v_point_id       NUMBER;\nBEGIN\n  SELECT SUM(ACCURACY_SCORE) INTO v_total_accuracy FROM FORECASTING_MODELS WHERE IS_ACTIVE = 1;\n\n  -- Fetch an existing USER_ID and POINT_ID to satisfy foreign key constraints\n  -- Assuming USERS and MONITORING_POINTS tables are not empty.\n  -- If they could be empty, more robust error handling (e.g., EXCEPTION WHEN NO_DATA_FOUND) would be needed.\n  SELECT MIN(USER_ID) INTO v_user_id FROM USERS;\n  SELECT MIN(POINT_ID) INTO v_point_id FROM MONITORING_POINTS;\n\n  INSERT INTO ACCESS_LOGS (LOG_ID, USER_ID, POINT_ID, ACCESS_TIME, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, SESSION_ID, DATA_ACCESSED)\n  VALUES (ROUND(DBMS_RANDOM.VALUE(40001, 50000)), v_user_id, v_point_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 'MODEL_DELETE', '192.168.1.5', 'MODEL_AGENT', DBMS_RANDOM.STRING('X', 16), 'TOTAL_ACCURACY=' || v_total_accuracy);\nEND;",
    "database_name": "meteorological_dcaa_82309",
    "tables": [
      "ACCESS_LOGS",
      "FORECASTING_MODELS",
      "MONITORING_POINTS",
      "USERS",
      "WEATHER_DATA"
    ],
    "call_sqls": [
      "DELETE FROM FORECASTING_MODELS WHERE MODEL_ID = 0",
      "DELETE FROM FORECASTING_MODELS WHERE MODEL_ID = 1",
      "DELETE FROM FORECASTING_MODELS WHERE MODEL_NAME = 'Model A'",
      "DELETE FROM FORECASTING_MODELS WHERE ACCURACY_SCORE < 0.9",
      "DELETE FROM FORECASTING_MODELS WHERE IS_ACTIVE = 0"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_model_accuracy_check that fires after a delete operation on the FORECASTING_MODELS table, calculates the total sum of ACCURACY_SCORE for records where IS_ACTIVE equals 1, retrieves the smallest USER_ID from the USERS table and the smallest POINT_ID from the MONITORING_POINTS table, and inserts a log entry into the ACCESS_LOGS table with a randomly generated LOG_ID between 40001 and 50000, the retrieved USER_ID and POINT_ID, the current timestamp, ACCESS_TYPE as 'MODEL_DELETE', IP_ADDRESS as '192.168.1.5', USER_AGENT as 'MODEL_AGENT', a random 16-character SESSION_ID, and DATA_ACCESSED as 'TOTAL_ACCURACY=' concatenated with the calculated total accuracy sum.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_model_accuracy_check that fires AFTER DELETE on the FORECASTING_MODELS table, summing the ACCURACY_SCORE for active models (where IS_ACTIVE = 1), retrieving the smallest USER_ID from USERS and the smallest POINT_ID from MONITORING_POINTS, and inserting a log into ACCESS_LOGS with a random LOG_ID between 40001 and 50000, those IDs, the current time, ACCESS_TYPE as 'MODEL_DELETE', IP as '192.168.1.5', USER_AGENT as 'MODEL_AGENT', a random 16-character SESSION_ID, and DATA_ACCESSED as 'TOTAL_ACCURACY=' plus the calculated sum.",
    "id": 51,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_model_accuracy_check that is defined to execute automatically after any delete operation on the FORECASTING_MODELS table. This is a statement-level trigger, meaning it executes once after the entire delete operation is completed, not for each individual deleted row. Upon activation, the trigger declares several local variables: v_total_accuracy of type NUMBER to store the sum of accuracy scores, v_min_user_id of type NUMBER to store the smallest user ID, v_min_point_id of type NUMBER to store the smallest point ID, v_log_id of type NUMBER to store a randomly generated log ID, v_session_id of type VARCHAR2(16) to store a randomly generated session ID, and v_current_time of type TIMESTAMP to store the current system timestamp.\n\nThe trigger first performs a SELECT SUM(ACCURACY_SCORE) query from the FORECASTING_MODELS table into the variable v_total_accuracy, specifically summing the ACCURACY_SCORE column only for rows where the IS_ACTIVE column equals 1, indicating active models. Next, it performs a SELECT MIN(USER_ID) query from the USERS table into the variable v_min_user_id to retrieve the smallest USER_ID value present in that table. Then, it performs a SELECT MIN(POINT_ID) query from the MONITORING_POINTS table into the variable v_min_point_id to retrieve the smallest POINT_ID value present in that table. It also assigns the current system timestamp to v_current_time using the SYSTIMESTAMP function.\n\nFor generating random values, the trigger uses the DBMS_RANDOM.VALUE function. It assigns to v_log_id a random integer between 40001 and 50000, inclusive, calculated as FLOOR(DBMS_RANDOM.VALUE(40001, 50001)). It assigns to v_session_id a random 16-character alphanumeric string generated by the DBMS_RANDOM.STRING function with the 'X' parameter, which produces uppercase alphanumeric characters.\n\nFinally, the trigger performs an INSERT operation into the ACCESS_LOGS table. The INSERT statement populates the following columns: LOG_ID with the value of v_log_id, USER_ID with the value of v_min_user_id, POINT_ID with the value of v_min_point_id, ACCESS_TIME with the value of v_current_time, ACCESS_TYPE with the literal string 'MODEL_DELETE', IP with the literal string '192.168.1.5', USER_AGENT with the literal string 'MODEL_AGENT', SESSION_ID with the value of v_session_id, and DATA_ACCESSED with a concatenated string formed by the literal 'TOTAL_ACCURACY=' appended with the calculated sum v_total_accuracy converted to a string. The trigger does not contain any conditional IF statements or loops; it executes these operations sequentially each time it fires.",
    "original_summary": "Create an AFTER DELETE statement-level trigger named trg_model_accuracy_check on the FORECASTING_MODELS table. Calculate the sum of ACCURACY_SCORE where IS_ACTIVE=1, find the minimum USER_ID from USERS and minimum POINT_ID from MONITORING_POINTS. Insert a log into ACCESS_LOGS with a random LOG_ID (40001-50000), the retrieved user and point IDs, current timestamp, ACCESS_TYPE='MODEL_DELETE', IP='192.168.1.5', USER_AGENT='MODEL_AGENT', a random 16-character SESSION_ID, and DATA_ACCESSED='TOTAL_ACCURACY=' concatenated with the calculated sum.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create an AFTER DELETE trigger named trg_model_accuracy_check on FORECASTING_MODELS. Sum ACCURACY_SCORE for active models. Get the smallest USER_ID and POINT_ID. Insert a log into ACCESS_LOGS with a random LOG_ID (40001-50000), those IDs, current time, ACCESS_TYPE='MODEL_DELETE', IP='192.168.1.5', USER_AGENT='MODEL_AGENT', a random 16-char SESSION_ID, and DATA_ACCESSED as 'TOTAL_ACCURACY=' plus the sum."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_vehicles_before_insert_type that is executed before a new row is inserted into the VEHICLES table. This trigger operates on each row being inserted and sets the EMISSION_RATING column of the new row to the string value 'STANDARD'. The trigger does not take any parameters, and its sole purpose is to ensure that every new vehicle record has a default emission rating of 'STANDARD' upon insertion, regardless of any other data provided during the insert operation. The trigger does not perform any conditional checks, function calls, or complex operations; it simply assigns a fixed value to the EMISSION_RATING column for each new row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_vehicles_before_insert_type\nBEFORE INSERT ON VEHICLES\nFOR EACH ROW\nBEGIN\n:NEW.EMISSION_RATING := 'STANDARD';\nEND;",
    "database_name": "automobile_pas_database",
    "tables": [
      "VEHICLES"
    ],
    "call_sqls": [
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, ENGINE_ID, TRANSMISSION_ID, PRODUCTION_START_YEAR, PRODUCTION_END_YEAR, VEHICLE_TYPE, FUEL_TYPE, DRIVE_TYPE, VEHICLE_WEIGHT, VEHICLE_LENGTH, VEHICLE_WIDTH, VEHICLE_HEIGHT, CARGO_CAPACITY, SEATING_CAPACITY, SAFETY_RATING, VEHICLE_CODE, VEHICLE_DESCRIPTION, VEHICLE_PRICE, VEHICLE_CURRENCY, VEHICLE_STATUS, VEHICLE_IMAGE_URL, VEHICLE_VIDEO_URL, VEHICLE_LAUNCH_DATE) \nVALUES (1, 101, 'Model X', 2023, 201, 301, 2022, 2025, 'SUV', 'Electric', 'AWD', 2000, 5000, 2000, 1500, 500, 5, 5, 'VX2023', 1001, '50000', 'USD', 'Available', 'http://example.com/image1.jpg', 'http://example.com/video1.mp4', '2023-01-01')",
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, ENGINE_ID, TRANSMISSION_ID, PRODUCTION_START_YEAR, PRODUCTION_END_YEAR, VEHICLE_TYPE, FUEL_TYPE, DRIVE_TYPE, VEHICLE_WEIGHT, VEHICLE_LENGTH, VEHICLE_WIDTH, VEHICLE_HEIGHT, CARGO_CAPACITY, SEATING_CAPACITY, SAFETY_RATING, VEHICLE_CODE, VEHICLE_DESCRIPTION, VEHICLE_PRICE, VEHICLE_CURRENCY, VEHICLE_STATUS, VEHICLE_IMAGE_URL, VEHICLE_VIDEO_URL, VEHICLE_LAUNCH_DATE) \nVALUES (2, 102, 'Model Y', 2024, 202, 302, 2023, 2026, 'Sedan', 'Hybrid', 'FWD', 1800, 4800, 1900, 1400, 450, 4, 4, 'VY2024', 1002, '45000', 'USD', 'Available', 'http://example.com/image2.jpg', 'http://example.com/video2.mp4', '2024-02-01')",
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, ENGINE_ID, TRANSMISSION_ID, PRODUCTION_START_YEAR, PRODUCTION_END_YEAR, VEHICLE_TYPE, FUEL_TYPE, DRIVE_TYPE, VEHICLE_WEIGHT, VEHICLE_LENGTH, VEHICLE_WIDTH, VEHICLE_HEIGHT, CARGO_CAPACITY, SEATING_CAPACITY, SAFETY_RATING, VEHICLE_CODE, VEHICLE_DESCRIPTION, VEHICLE_PRICE, VEHICLE_CURRENCY, VEHICLE_STATUS, VEHICLE_IMAGE_URL, VEHICLE_VIDEO_URL, VEHICLE_LAUNCH_DATE) \nVALUES (3, 103, 'Model Z', 2025, 203, 303, 2024, 2027, 'Truck', 'Diesel', 'RWD', 3000, 6000, 2200, 1600, 1000, 2, 3, 'VZ2025', 1003, '60000', 'USD', 'Available', 'http://example.com/image3.jpg', 'http://example.com/video3.mp4', '2025-03-01')",
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, ENGINE_ID, TRANSMISSION_ID, PRODUCTION_START_YEAR, PRODUCTION_END_YEAR, VEHICLE_TYPE, FUEL_TYPE, DRIVE_TYPE, VEHICLE_WEIGHT, VEHICLE_LENGTH, VEHICLE_WIDTH, VEHICLE_HEIGHT, CARGO_CAPACITY, SEATING_CAPACITY, SAFETY_RATING, VEHICLE_CODE, VEHICLE_DESCRIPTION, VEHICLE_PRICE, VEHICLE_CURRENCY, VEHICLE_STATUS, VEHICLE_IMAGE_URL, VEHICLE_VIDEO_URL, VEHICLE_LAUNCH_DATE) \nVALUES (4, 104, 'Model A', 2026, 204, 304, 2025, 2028, 'Coupe', 'Petrol', 'AWD', 1500, 4500, 1800, 1300, 400, 2, 4, 'VA2026', 1004, '55000', 'USD', 'Available', 'http://example.com/image4.jpg', 'http://example.com/video4.mp4', '2026-04-01')",
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, ENGINE_ID, TRANSMISSION_ID, PRODUCTION_START_YEAR, PRODUCTION_END_YEAR, VEHICLE_TYPE, FUEL_TYPE, DRIVE_TYPE, VEHICLE_WEIGHT, VEHICLE_LENGTH, VEHICLE_WIDTH, VEHICLE_HEIGHT, CARGO_CAPACITY, SEATING_CAPACITY, SAFETY_RATING, VEHICLE_CODE, VEHICLE_DESCRIPTION, VEHICLE_PRICE, VEHICLE_CURRENCY, VEHICLE_STATUS, VEHICLE_IMAGE_URL, VEHICLE_VIDEO_URL, VEHICLE_LAUNCH_DATE) \nVALUES (5, 105, 'Model B', 2027, 205, 305, 2026, 2029, 'Convertible', 'Electric', 'FWD', 1600, 4600, 1850, 1350, 420, 2, 5, 'VB2027', 1005, '70000', 'USD', 'Available', 'http://example.com/image5.jpg', 'http://example.com/video5.mp4', '2027-05-01')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_vehicles_before_insert_type that fires before each row is inserted into the VEHICLES table, automatically setting the EMISSION_RATING column to 'STANDARD' for every new record.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_vehicles_before_insert_type that, before inserting a new record into the VEHICLES table, automatically sets the EMISSION_RATING column to 'STANDARD'.",
    "id": 52,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_vehicles_before_insert_type that is executed before any insert operation on the VEHICLES table in the automobile_pas_database. This trigger operates at the row level, meaning it is triggered for each new row that is being inserted. The trigger modifies the EMISSION_RATING column of the row that is about to be inserted. Specifically, it sets the new value of the EMISSION_RATING column, referred to as :NEW.EMISSION_RATING, to the string literal 'STANDARD'. This assignment occurs unconditionally for every insert operation, ensuring that the EMISSION_RATING column is automatically populated with the value 'STANDARD' for all new records inserted into the VEHICLES table, thereby enforcing a default emission rating without requiring explicit input from the user.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_vehicles_before_insert_type on the VEHICLES table. For each new row, set the EMISSION_RATING column to 'STANDARD'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create trigger trg_vehicles_before_insert_type to set EMISSION_RATING to 'STANDARD' on VEHICLES insert."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_PARKS_BOROUGH_DEL that is executed before a delete operation on the BOROUGHS table. This trigger operates on each row that is about to be deleted. The trigger first performs a delete operation on the CRIME_STATISTICS table, removing all records where the PARK_ID is found in a subquery. This subquery selects PARK_IDs from the PARKS table where the BOROUGH_ID matches the BOROUGH_ID of the row being deleted from the BOROUGHS table, referenced as :OLD.BOROUGH_ID. After deleting the relevant records from CRIME_STATISTICS, the trigger proceeds to delete records from the PARKS table where the BOROUGH_ID matches the same :OLD.BOROUGH_ID. This ensures that all related records in the PARKS and CRIME_STATISTICS tables are removed before the deletion of a borough from the BOROUGHS table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PARKS_BOROUGH_DEL\nBEFORE DELETE ON BOROUGHS\nFOR EACH ROW\nBEGIN\n    -- First, delete child records in CRIME_STATISTICS that reference PARKS\n    DELETE FROM CRIME_STATISTICS\n    WHERE PARK_ID IN (SELECT PARK_ID FROM PARKS WHERE BOROUGH_ID = :OLD.BOROUGH_ID);\n\n    -- Then, delete records from PARKS\n    DELETE FROM PARKS WHERE BOROUGH_ID = :OLD.BOROUGH_ID;\nEND;",
    "database_name": "urban_psacs_tracking",
    "tables": [
      "BOROUGHS",
      "CATEGORIES",
      "CRIME_CATEGORIES",
      "CRIME_STATISTICS",
      "CRIME_STATISTICS_BRIDGE",
      "PARKS"
    ],
    "call_sqls": [
      "DELETE FROM BOROUGHS WHERE BOROUGH_ID = 0",
      "DELETE FROM BOROUGHS WHERE BOROUGH_ID = 1",
      "DELETE FROM BOROUGHS WHERE BOROUGH_ID = 2",
      "DELETE FROM BOROUGHS WHERE BOROUGH_ID = 3",
      "DELETE FROM BOROUGHS WHERE BOROUGH_ID = 4"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_PARKS_BOROUGH_DEL that fires BEFORE DELETE on each row of the BOROUGHS table. When a BOROUGHS row is deleted, first remove all records from the CRIME_STATISTICS table where the PARK_ID matches any PARK_ID from the PARKS table associated with the deleted BOROUGH_ID. Then, delete all records from the PARKS table that have the same BOROUGH_ID as the deleted row.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_PARKS_BOROUGH_DEL that, before deleting a row from the BOROUGHS table, first removes any records from the CRIME_STATISTICS table where the PARK_ID matches any PARK_ID in the PARKS table linked to the borough being deleted, and then deletes all records from the PARKS table that have the same BOROUGH_ID as the borough being deleted.",
    "id": 53,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_PARKS_BOROUGH_DEL that is executed before a delete operation on the BOROUGHS table. This trigger operates on each row that is about to be deleted. The trigger first performs a delete operation on the CRIME_STATISTICS table, removing all records where the PARK_ID is found in a subquery. This subquery selects PARK_IDs from the PARKS table where the BOROUGH_ID matches the BOROUGH_ID of the row being deleted from the BOROUGHS table, referenced as :OLD.BOROUGH_ID. After deleting the relevant records from CRIME_STATISTICS, the trigger proceeds to delete records from the PARKS table where the BOROUGH_ID matches the same :OLD.BOROUGH_ID. This ensures that all related records in the PARKS and CRIME_STATISTICS tables are removed before the deletion of a borough from the BOROUGHS table.",
    "original_summary": "Create a BEFORE DELETE FOR EACH ROW trigger named TRG_PARKS_BOROUGH_DEL on the BOROUGHS table. For each row being deleted, first delete from CRIME_STATISTICS where PARK_ID is in (select PARK_ID from PARKS where BOROUGH_ID = :OLD.BOROUGH_ID). Then delete from PARKS where BOROUGH_ID = :OLD.BOROUGH_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE DELETE FOR EACH ROW trigger designated as TRG_PARKS_BOROUGH_DEL on the BOROUGHS table. For each row slated for deletion, it is required to first execute a deletion from the CRIME_STATISTICS table where the PARK_ID corresponds to any PARK_ID found in the PARKS table associated with the :OLD.BOROUGH_ID. Subsequently, a deletion from the PARKS table where BOROUGH_ID matches the :OLD.BOROUGH_ID must be performed."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_SIZE_REPORTS_BI that executes before each row is inserted into the SIZE_REPORTS table, which declares local variables v_timestamp of type TIMESTAMP, v_new_trend_id of type NUMBER, and v_market_id of type NUMBER, then assigns to v_timestamp a fixed timestamp value of '2025-10-26 12:00:00' converted to a TIMESTAMP and then to a TIMESTAMP WITH TIME ZONE in the UTC time zone using the FROM_TZ and TO_TIMESTAMP functions, then retrieves the next sequential TREND_ID by selecting the maximum existing TREND_ID from the SIZE_TRENDS table, adding 1 to it, and storing the result in v_new_trend_id, using the NVL function to handle nulls by defaulting to 0, then attempts to safely retrieve a MARKET_ID from the MARKETS table by selecting the MARKET_ID where the MARKET_NAME column equals the new value of the MARKET column from the inserted SIZE_REPORTS row, referenced as :NEW.MARKET, and if no matching MARKET_NAME is found, the exception handler for NO_DATA_FOUND sets v_market_id to a default value of 0, and if multiple rows with the same MARKET_NAME are found, the exception handler for TOO_MANY_ROWS selects the minimum MARKET_ID from those matching rows and assigns it to v_market_id, then inserts a new record into the SIZE_TRENDS table with columns TREND_ID set to v_new_trend_id, SIZE_ID set to the new value of the SIZE_ID column from the inserted SIZE_REPORTS row referenced as :NEW.SIZE_ID, MARKET_ID set to the determined v_market_id value, TREND_DATE set to the date portion of the v_timestamp variable formatted as 'YYYY-MM-DD' using the TO_CHAR function, and TREND_VALUE set to the new value of the UNITS_SOLD column from the inserted SIZE_REPORTS row referenced as :NEW.UNITS_SOLD, and if any other exception occurs during this trigger's execution, the exception handler for WHEN OTHERS catches it and performs no action with a NULL statement to suppress the error and prevent the trigger from failing.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_SIZE_REPORTS_BI\nBEFORE INSERT ON SIZE_REPORTS\nFOR EACH ROW\nDECLARE\n   v_timestamp TIMESTAMP;\n   v_new_trend_id NUMBER;\n   v_market_id NUMBER;\nBEGIN\n   v_timestamp := FROM_TZ(TO_TIMESTAMP('2025-10-26 12:00:00','YYYY-MM-DD HH24:MI:SS'), 'UTC');\n   \n   -- Generate new TREND_ID\n   SELECT NVL(MAX(TREND_ID), 0) + 1 INTO v_new_trend_id FROM SIZE_TRENDS;\n   \n   -- Get MARKET_ID safely\n   BEGIN\n      SELECT MARKET_ID INTO v_market_id \n      FROM MARKETS \n      WHERE MARKET_NAME = :NEW.MARKET;\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         v_market_id := 0; -- Default market ID\n      WHEN TOO_MANY_ROWS THEN\n         SELECT MIN(MARKET_ID) INTO v_market_id \n         FROM MARKETS \n         WHERE MARKET_NAME = :NEW.MARKET;\n   END;\n   \n   INSERT INTO SIZE_TRENDS (TREND_ID, SIZE_ID, MARKET_ID, TREND_DATE, TREND_VALUE)\n   VALUES (v_new_trend_id, :NEW.SIZE_ID, v_market_id, TO_CHAR(v_timestamp, 'YYYY-MM-DD'), :NEW.UNITS_SOLD);\n   \nEXCEPTION\n   WHEN OTHERS THEN\n      NULL; -- Suppress errors to prevent trigger failure\nEND;",
    "database_name": "apparel_sams_543314",
    "tables": [
      "MARKETS",
      "MEASUREMENTS",
      "SIZES",
      "SIZE_MARKET",
      "SIZE_REPORTS",
      "SIZE_TRENDS",
      "SIZE_UPDATES"
    ],
    "call_sqls": [
      "INSERT INTO SIZE_REPORTS (REPORT_ID, SIZE_ID, MARKET, UNITS_SOLD, REPORT_DATE, REPORT_TYPE) VALUES (2, 0, 'North America', 7500, '2023-02-01', 'sales')",
      "INSERT INTO SIZE_REPORTS (REPORT_ID, SIZE_ID, MARKET, UNITS_SOLD, REPORT_DATE, REPORT_TYPE) VALUES (3, 1, 'Europe', 4000, '2023-02-01', 'sales')",
      "INSERT INTO SIZE_REPORTS (REPORT_ID, SIZE_ID, MARKET, UNITS_SOLD, REPORT_DATE, REPORT_TYPE) VALUES (4, 0, 'Asia', 2000, '2023-03-01', 'inventory')",
      "INSERT INTO SIZE_REPORTS (REPORT_ID, SIZE_ID, MARKET, UNITS_SOLD, REPORT_DATE, REPORT_TYPE) VALUES (5, 1, 'North America', 6000, '2023-03-01', 'sales')",
      "INSERT INTO SIZE_REPORTS (REPORT_ID, SIZE_ID, MARKET, UNITS_SOLD, REPORT_DATE, REPORT_TYPE) VALUES (6, 0, 'Europe', 3500, '2023-04-01', 'sales')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_SIZE_REPORTS_BI that fires BEFORE INSERT on each row of the SIZE_REPORTS table. For each new row, generate a new TREND_ID by incrementing the maximum existing TREND_ID from the SIZE_TRENDS table, look up a MARKET_ID from the MARKETS table based on the new MARKET value, and if the MARKET_NAME is missing or has duplicates, assign a default MARKET_ID of 0 or use the minimum MARKET_ID respectively. Then insert a record into the SIZE_TRENDS table with the generated TREND_ID, the new SIZE_ID, the determined MARKET_ID, a fixed timestamp converted to 'YYYY-MM-DD' format, and the new UNITS_SOLD value. Suppress any errors to prevent the trigger from failing.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_SIZE_REPORTS_BI that fires BEFORE INSERT on each row of the SIZE_REPORTS table to generate a new TREND_ID, safely look up a MARKET_ID from the MARKETS table using the new MARKET value, insert a record into the SIZE_TRENDS table with the generated TREND_ID, the new SIZE_ID, the found MARKET_ID, a fixed timestamp formatted as 'YYYY-MM-DD', and the new UNITS_SOLD as TREND_VALUE, handle cases where the MARKET_NAME is missing by defaulting MARKET_ID to 0 or is duplicate by using the minimum MARKET_ID, and suppress all other errors to prevent trigger failure.",
    "id": 54,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_SIZE_REPORTS_BI that is executed before an insert operation on the SIZE_REPORTS table for each row being inserted. The trigger is designed to automatically generate a new TREND_ID, retrieve a corresponding MARKET_ID from the MARKETS table based on the new MARKET value, and then insert a new record into the SIZE_TRENDS table with specific values, while handling potential errors gracefully.\n\nThe trigger declares several local variables: v_trend_id of type NUMBER to store the generated trend identifier, v_market_id of type NUMBER to store the retrieved market identifier, and v_formatted_timestamp of type VARCHAR2 with a maximum length of 10 characters to hold a fixed timestamp string.\n\nThe trigger begins by generating a new TREND_ID using a sequence. It calls NEXTVAL on a sequence named SEQ_SIZE_TRENDS to obtain a unique numeric value, which is stored in the v_trend_id variable.\n\nNext, the trigger attempts to look up a MARKET_ID from the MARKETS table. It executes a SELECT statement to retrieve the MARKET_ID from the MARKETS table where the MARKET_NAME column matches the :NEW.MARKET value from the row being inserted into SIZE_REPORTS. The SELECT statement uses an aggregate function to handle duplicates: it selects the minimum MARKET_ID if multiple rows have the same MARKET_NAME. If no matching MARKET_NAME is found, the trigger uses a default value of 0 for v_market_id. This is implemented within a BEGIN-EXCEPTION block to manage errors. Specifically, if the SELECT statement returns no rows, a NO_DATA_FOUND exception is caught, and v_market_id is set to 0. If any other exception occurs during the SELECT operation, it is also caught, and v_market_id is set to 0, effectively suppressing all lookup errors to prevent trigger failure.\n\nThe trigger then constructs a fixed timestamp string. It uses the TO_CHAR function with the SYSDATE function to format the current system date as 'YYYY-MM-DD', storing this string in the v_formatted_timestamp variable.\n\nFollowing this, the trigger performs an INSERT operation into the SIZE_TRENDS table. It inserts a new row with the following column values: TREND_ID is set to v_trend_id, SIZE_ID is set to :NEW.SIZE_ID from the row being inserted into SIZE_REPORTS, MARKET_ID is set to v_market_id (which is either the retrieved MARKET_ID or the default 0), TREND_DATE is set to v_formatted_timestamp (the fixed date string), and TREND_VALUE is set to :NEW.UNITS_SOLD from the row being inserted into SIZE_REPORTS.\n\nThe trigger operates within the apparel_sams_543314 database and is associated with the SIZE_REPORTS table. It ensures that each insert into SIZE_REPORTS results in a corresponding record in SIZE_TRENDS, with error handling to manage missing or duplicate MARKET_NAME entries and to suppress any other errors that might occur during the MARKET_ID lookup.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named TRG_SIZE_REPORTS_BI on the SIZE_REPORTS table. For each new row, generate a new TREND_ID, safely look up a MARKET_ID from the MARKETS table based on the new MARKET value, and insert a corresponding record into the SIZE_TRENDS table with the calculated values. Handle exceptions for missing or duplicate MARKET_NAME values, and suppress all other errors.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a BEFORE INSERT FOR EACH ROW trigger named TRG_SIZE_REPORTS_BI on the SIZE_REPORTS table that, for each new row, generates a new TREND_ID, safely looks up a MARKET_ID from the MARKETS table based on the new MARKET value, inserts a corresponding record into the SIZE_TRENDS table with the calculated values, handles exceptions for missing or duplicate MARKET_NAME values, and suppresses all other errors?"
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_access_logs_location_default` that is configured to execute automatically before an `INSERT` operation is performed on the `ACCESS_LOGS` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row being inserted into the `ACCESS_LOGS` table. The trigger's primary purpose is to ensure that the `ACCESS_LOCATION` column of a new record in the `ACCESS_LOGS` table always has a non-NULL value. Specifically, within the trigger's execution block, it evaluates a conditional statement: `IF :NEW.ACCESS_LOCATION IS NULL THEN`. This condition checks if the value proposed for the `ACCESS_LOCATION` column in the new row (represented by `:NEW.ACCESS_LOCATION`) is `NULL`. If this condition evaluates to `TRUE`, indicating that no specific access location was provided for the new record, then the trigger proceeds to execute the statement `:NEW.ACCESS_LOCATION := 'Unknown';`. This statement assigns the string literal `'Unknown'` to the `ACCESS_LOCATION` column of the new row, thereby providing a default value. If the initial condition `IF :NEW.ACCESS_LOCATION IS NULL` evaluates to `FALSE`, meaning a non-NULL value was already provided for `ACCESS_LOCATION` in the new row, then no action is taken by the trigger for that specific column, and the provided value is retained. The trigger concludes its execution after this conditional check and potential assignment.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_access_logs_location_default\nBEFORE INSERT ON ACCESS_LOGS\nFOR EACH ROW\nBEGIN\n    IF :NEW.ACCESS_LOCATION IS NULL THEN\n        :NEW.ACCESS_LOCATION := 'Unknown';\n    END IF;\nEND;",
    "database_name": "economic_daar_473112",
    "tables": [
      "ACCESS_LOGS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, ACCESS_LOCATION) VALUES (0, 1, 0, '2023-05-01', 'view', 'United States')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, ACCESS_LOCATION) VALUES (1, 1, 1, '2023-05-02', 'download', NULL)",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE) VALUES (2, 1, 0, '2023-05-03', 'view')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, ACCESS_LOCATION) VALUES (3, 1, 1, '2023-05-04', 'download', 'Canada')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, ACCESS_LOCATION) VALUES (4, 1, 0, '2023-05-05', 'view', NULL)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_access_logs_location_default that fires before each row is inserted into the ACCESS_LOGS table, and if the new row's ACCESS_LOCATION is NULL, sets it to 'Unknown'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_access_logs_location_default that, before inserting a row into the ACCESS_LOGS table, sets the ACCESS_LOCATION column to 'Unknown' if it is found to be NULL.",
    "id": 55,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_access_logs_location_default` that is configured to execute automatically before an `INSERT` operation is performed on the `ACCESS_LOGS` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row being inserted into the `ACCESS_LOGS` table. The trigger's primary purpose is to ensure that the `ACCESS_LOCATION` column of a new record in the `ACCESS_LOGS` table always has a non-NULL value. Specifically, within the trigger's execution block, it evaluates a conditional statement: `IF :NEW.ACCESS_LOCATION IS NULL THEN`. This condition checks if the value proposed for the `ACCESS_LOCATION` column in the new row (represented by `:NEW.ACCESS_LOCATION`) is `NULL`. If this condition evaluates to `TRUE`, indicating that no specific access location was provided for the new record, then the trigger proceeds to execute the statement `:NEW.ACCESS_LOCATION := 'Unknown';`. This statement assigns the string literal `'Unknown'` to the `ACCESS_LOCATION` column of the new row, thereby providing a default value. If the initial condition `IF :NEW.ACCESS_LOCATION IS NULL` evaluates to `FALSE`, meaning a non-NULL value was already provided for `ACCESS_LOCATION` in the new row, then no action is taken by the trigger for that specific column, and the provided value is retained. The trigger concludes its execution after this conditional check and potential assignment.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_access_logs_location_default on the ACCESS_LOGS table. If the new row's ACCESS_LOCATION is NULL, set it to 'Unknown'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE INSERT row-level trigger designated as trg_access_logs_location_default for the ACCESS_LOGS table. The trigger's function is to assign the value 'Unknown' to the ACCESS_LOCATION column in any new row for which this value is determined to be NULL."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_set_next_inspection that fires automatically before any new row is inserted into the PROPERTY_UNITS table, for each individual row being inserted, and within its execution block, it declares a local variable v_next_date of type VARCHAR2 with a maximum length of 255 characters, then calculates a value for this variable by first obtaining the last day of the current month from the system date using the LAST_DAY function on SYSDATE, adding 365 days to that date, and converting the resulting date to a string in the 'YYYY-MM-DD' format using the TO_CHAR function, and finally assigns the calculated string value from v_next_date to the NEXT_INSPECTION_DATE column of the new row being inserted, referenced via the :NEW pseudorecord.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_set_next_inspection\nBEFORE INSERT ON PROPERTY_UNITS\nFOR EACH ROW\nDECLARE\n  v_next_date VARCHAR2(255);\nBEGIN\n  v_next_date := TO_CHAR(LAST_DAY(SYSDATE) + 365, 'YYYY-MM-DD');\n  :NEW.NEXT_INSPECTION_DATE := v_next_date;\nEND;",
    "database_name": "real_eapm_58871",
    "tables": [
      "PROPERTIES",
      "PROPERTY_SALES",
      "BUYERS",
      "SELLERS",
      "PROPERTY_UNITS",
      "PROPERTY_AUDITS"
    ],
    "call_sqls": [
      "INSERT INTO PROPERTY_UNITS (UNIT_ID, PROPERTY_ID, UNIT_NUMBER, UNIT_TYPE, STABILIZED, SQUARE_FOOTAGE, BEDROOMS, BATHROOMS, LAST_INSPECTION_DATE, UNIT_CONDITION, RENT, TENANT_ID) VALUES (2, 0, '2A', 'Apartment', 1, 900, 3, 2, '2021-01-15', 'excellent', 1600, 203)",
      "INSERT INTO PROPERTY_UNITS (UNIT_ID, PROPERTY_ID, UNIT_NUMBER, UNIT_TYPE, STABILIZED, SQUARE_FOOTAGE, BEDROOMS, BATHROOMS, LAST_INSPECTION_DATE, UNIT_CONDITION, RENT, TENANT_ID) VALUES (3, 1, '2B', 'Apartment', 1, 950, 3, 2, '2021-01-15', 'good', 1650, 204)",
      "INSERT INTO PROPERTY_UNITS (UNIT_ID, PROPERTY_ID, UNIT_NUMBER, UNIT_TYPE, STABILIZED, SQUARE_FOOTAGE, BEDROOMS, BATHROOMS, LAST_INSPECTION_DATE, UNIT_CONDITION, RENT, TENANT_ID) VALUES (4, 0, '3A', 'Apartment', 1, 1000, 3, 2, '2021-01-15', 'fair', 1700, 205)",
      "INSERT INTO PROPERTY_UNITS (UNIT_ID, PROPERTY_ID, UNIT_NUMBER, UNIT_TYPE, STABILIZED, SQUARE_FOOTAGE, BEDROOMS, BATHROOMS, LAST_INSPECTION_DATE, UNIT_CONDITION, RENT, TENANT_ID) VALUES (5, 1, '3B', 'Apartment', 1, 1050, 3, 2, '2021-01-15', 'excellent', 1750, 206)",
      "INSERT INTO PROPERTY_UNITS (UNIT_ID, PROPERTY_ID, UNIT_NUMBER, UNIT_TYPE, STABILIZED, SQUARE_FOOTAGE, BEDROOMS, BATHROOMS, LAST_INSPECTION_DATE, UNIT_CONDITION, RENT, TENANT_ID) VALUES (6, 0, '4A', 'Apartment', 1, 1100, 3, 2, '2021-01-15', 'good', 1800, 207)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_set_next_inspection that fires BEFORE INSERT on each row of the PROPERTY_UNITS table, automatically setting the NEXT_INSPECTION_DATE for the new record to the last day of the current month plus one year, formatted as 'YYYY-MM-DD'.",
    "natural_language": "Hey, can you write a Oracle PL/SQL trigger named trg_set_next_inspection for the PROPERTY_UNITS table that fires before each new row is inserted? It should calculate the next inspection date by taking the last day of the current month, adding one year to it, formatting the result as 'YYYY-MM-DD', and then assign that value to the :NEW.NEXT_INSPECTION_DATE field.",
    "id": 56,
    "generated_ir": "Write an Oracle PL/SQL BEFORE INSERT trigger named trg_set_next_inspection that fires for each row being inserted into the PROPERTY_UNITS table. The trigger declares a local variable next_date of type DATE. It calculates the next inspection date by first determining the last day of the current month using the LAST_DAY function with the current date from SYSDATE, then adds exactly one year to that date using the ADD_MONTHS function with an increment of 12 months. The resulting date value is then formatted into a string with the pattern 'YYYY-MM-DD' using the TO_CHAR function. This formatted string is assigned to the :NEW.NEXT_INSPECTION_DATE field for the row being inserted. No explicit exception handling is defined.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_set_next_inspection on the PROPERTY_UNITS table. Declare a VARCHAR2(255) variable v_next_date. Set v_next_date to TO_CHAR(LAST_DAY(SYSDATE) + 365, 'YYYY-MM-DD'). Assign v_next_date to :NEW.NEXT_INSPECTION_DATE.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, can you set up a trigger called trg_set_next_inspection for the PROPERTY_UNITS table? It should fire before each new row is added. Inside, declare a variable v_next_date as a VARCHAR2 with 255 characters. For the logic, figure out the last day of this month, add a year to it, and format that result as 'YYYY-MM-DD' to get the next inspection date. Then, just pop that value into the :NEW.NEXT_INSPECTION_DATE field."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_definition_consistency` that is activated `BEFORE` any `UPDATE` operation is performed on the `DEFINITIONS` table, and executes `FOR EACH ROW` that is being updated. This trigger declares two local `VARCHAR2(255)` variables: `source_ref` and `label_type`. Upon activation for a specific row, the trigger first executes a `SELECT` statement to retrieve the `SOURCE_REFERENCE` column value from the `DEFINITIONS` table where the `DEFINITION_ID` column matches the `DEFINITION_ID` of the `OLD` (pre-update) row being processed, and stores this retrieved value into the `source_ref` variable. Subsequently, it executes another `SELECT` statement to retrieve the `LABEL_TYPE` column value from the `LABELS` table where the `DATA_ID` column matches the `DATA_ID` of the `OLD` (pre-update) row being processed, and stores this retrieved value into the `label_type` variable. Following these data retrievals, the trigger evaluates a conditional `IF` statement: if the value stored in the `source_ref` variable is `NOT EQUAL` to the `SOURCE_REFERENCE` column value of the `NEW` (post-update) row being processed, then the `DEFINITION_TEXT` column of the `NEW` row is modified by converting its current value to `UPPERCASE` using the `UPPER()` function. After this, another independent conditional `IF` statement is evaluated: if the value stored in the `label_type` variable is `EQUAL` to the string literal `'descriptive'`, then the `SOURCE_REFERENCE` column of the `NEW` row is modified by removing any leading or trailing whitespace characters from its current value using the `TRIM()` function.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_definition_consistency\nBEFORE UPDATE ON DEFINITIONS\nFOR EACH ROW\nDECLARE\n    source_ref VARCHAR2(255);\n    label_type VARCHAR2(255);\nBEGIN\n    SELECT SOURCE_REFERENCE INTO source_ref FROM DEFINITIONS WHERE DEFINITION_ID = :OLD.DEFINITION_ID;\n    SELECT LABEL_TYPE INTO label_type FROM LABELS WHERE DATA_ID = :OLD.DATA_ID;\n    IF source_ref != :NEW.SOURCE_REFERENCE THEN\n        :NEW.DEFINITION_TEXT := UPPER(:NEW.DEFINITION_TEXT);\n    END IF;\n    IF label_type = 'descriptive' THEN\n        :NEW.SOURCE_REFERENCE := TRIM(:NEW.SOURCE_REFERENCE);\n    END IF;\nEND;",
    "database_name": "demographic_dcaa_801780",
    "tables": [
      "ACCESS_LOGS",
      "CALCULATED_PERCENTAGES",
      "DATA_SOURCES",
      "DEFINITIONS",
      "ERROR_MARGINS",
      "LABELS",
      "UNITS_OF_MEASURE",
      "UNIT_LEVELS",
      "USERS"
    ],
    "call_sqls": [
      "UPDATE DEFINITIONS SET DEFINITION_TEXT = 'Updated text', SOURCE_REFERENCE = 'New Reference' WHERE DEFINITION_ID = 0",
      "UPDATE DEFINITIONS SET DEFINITION_TEXT = 'Another update', SOURCE_REFERENCE = 'Another Reference' WHERE DEFINITION_ID = 1",
      "UPDATE DEFINITIONS SET DEFINITION_TEXT = 'Text change', SOURCE_REFERENCE = 'Reference change' WHERE DEFINITION_ID = 2",
      "UPDATE DEFINITIONS SET DEFINITION_TEXT = 'Modify text', SOURCE_REFERENCE = 'Modify Reference' WHERE DEFINITION_ID = 3",
      "UPDATE DEFINITIONS SET DEFINITION_TEXT = 'Alter text', SOURCE_REFERENCE = 'Alter Reference' WHERE DEFINITION_ID = 4"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_definition_consistency that fires BEFORE UPDATE on each row of the DEFINITIONS table. When a row is updated, if the old SOURCE_REFERENCE differs from the new SOURCE_REFERENCE, convert the new DEFINITION_TEXT to uppercase. Additionally, retrieve the LABEL_TYPE from the LABELS table using the old DATA_ID, and if the LABEL_TYPE is 'descriptive', trim any leading or trailing spaces from the new SOURCE_REFERENCE.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_definition_consistency that fires before each row is updated on the DEFINITIONS table. It should retrieve the old SOURCE_REFERENCE from the DEFINITIONS table and the LABEL_TYPE from the LABELS table using the old DATA_ID. If the old and new SOURCE_REFERENCE values differ, convert the new DEFINITION_TEXT to uppercase. Additionally, if the retrieved LABEL_TYPE is 'descriptive', trim any leading or trailing spaces from the new SOURCE_REFERENCE.",
    "id": 57,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_definition_consistency` that is activated `BEFORE` any `UPDATE` operation is performed on the `DEFINITIONS` table, and executes `FOR EACH ROW` that is being updated. This trigger declares two local `VARCHAR2(255)` variables: `source_ref` and `label_type`. Upon activation for a specific row, the trigger first executes a `SELECT` statement to retrieve the `SOURCE_REFERENCE` column value from the `DEFINITIONS` table where the `DEFINITION_ID` column matches the `DEFINITION_ID` of the `OLD` (pre-update) row being processed, and stores this retrieved value into the `source_ref` variable. Subsequently, it executes another `SELECT` statement to retrieve the `LABEL_TYPE` column value from the `LABELS` table where the `DATA_ID` column matches the `DATA_ID` of the `OLD` (pre-update) row being processed, and stores this retrieved value into the `label_type` variable. Following these data retrievals, the trigger evaluates a conditional `IF` statement: if the value stored in the `source_ref` variable is `NOT EQUAL` to the `SOURCE_REFERENCE` column value of the `NEW` (post-update) row being processed, then the `DEFINITION_TEXT` column of the `NEW` row is modified by converting its current value to `UPPERCASE` using the `UPPER()` function. After this, another independent conditional `IF` statement is evaluated: if the value stored in the `label_type` variable is `EQUAL` to the string literal `'descriptive'`, then the `SOURCE_REFERENCE` column of the `NEW` row is modified by removing any leading or trailing whitespace characters from its current value using the `TRIM()` function.",
    "original_summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_definition_consistency on the DEFINITIONS table. For each updated row, retrieve the old SOURCE_REFERENCE into a variable and the LABEL_TYPE from the LABELS table based on the old DATA_ID. If the old and new SOURCE_REFERENCE values differ, set the new DEFINITION_TEXT to uppercase. If the retrieved LABEL_TYPE is 'descriptive', trim the new SOURCE_REFERENCE.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need to set up a trigger called trg_definition_consistency on the DEFINITIONS table that fires before each row gets updated. Here's what it should do: grab the old SOURCE_REFERENCE and stash it in a variable. Then, go fetch the LABEL_TYPE from the LABELS table using the old DATA_ID. Now, if the old and new SOURCE_REFERENCE aren't the same, we gotta change the new DEFINITION_TEXT to all caps. Oh, and one more thing—if that LABEL_TYPE we pulled is 'descriptive', then we need to trim any extra spaces off the new SOURCE_REFERENCE."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_data_sets that is executed after an update operation on the DATA_VERSIONS table for each row affected by the update. The trigger checks the value of the VERSION_NUMBER column in the updated row. If the VERSION_NUMBER is 'v1.0', it inserts a new row into the DATA_SETS table with the DATA_SET_ID from the updated row, a DATA_SET_NAME of 'Version 1 Dataset', and a DATA_TYPE of 'Demographic'. If the VERSION_NUMBER is 'v2.0', it inserts a new row into the DATA_SETS table with the DATA_SET_ID from the updated row, a DATA_SET_NAME of 'Version 2 Dataset', and a DATA_TYPE of 'Socioeconomic'. If the VERSION_NUMBER is neither 'v1.0' nor 'v2.0', it inserts a new row into the DATA_SETS table with the DATA_SET_ID from the updated row, a DATA_SET_NAME of 'Other Version Dataset', and a DATA_TYPE of 'Other'. The trigger uses conditional logic to determine which insert operation to perform based on the VERSION_NUMBER value, utilizing an IF-ELSIF-ELSE structure to handle the different cases.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_data_sets\nAFTER UPDATE ON DATA_VERSIONS\nFOR EACH ROW\nBEGIN\n  IF :NEW.VERSION_NUMBER = 'v1.0' THEN\n    INSERT INTO DATA_SETS (DATA_SET_ID, DATA_SET_NAME, DATA_TYPE)\n    VALUES (:NEW.DATA_SET_ID, 'Version 1 Dataset', 'Demographic');\n  ELSIF :NEW.VERSION_NUMBER = 'v2.0' THEN\n    INSERT INTO DATA_SETS (DATA_SET_ID, DATA_SET_NAME, DATA_TYPE)\n    VALUES (:NEW.DATA_SET_ID, 'Version 2 Dataset', 'Socioeconomic');\n  ELSE\n    INSERT INTO DATA_SETS (DATA_SET_ID, DATA_SET_NAME, DATA_TYPE)\n    VALUES (:NEW.DATA_SET_ID, 'Other Version Dataset', 'Other');\n  END IF;\nEND;",
    "database_name": "demographic_asda_428440",
    "tables": [
      "DATA_SETS",
      "DATA_SOURCES",
      "DATA_VERSIONS",
      "INDIVIDUALS",
      "RESEARCH_TEAMS"
    ],
    "call_sqls": [
      "UPDATE DATA_VERSIONS SET VERSION_NUMBER = 'v1.0', LAST_UPDATED = SYSDATE WHERE VERSION_ID = 1",
      "UPDATE DATA_VERSIONS SET VERSION_NUMBER = 'v2.0', LAST_UPDATED = SYSDATE WHERE VERSION_ID = 2",
      "UPDATE DATA_VERSIONS SET VERSION_NUMBER = 'v3.0', LAST_UPDATED = SYSDATE WHERE VERSION_ID = 3",
      "UPDATE DATA_VERSIONS SET VERSION_NUMBER = 'v1.0', LAST_UPDATED = SYSDATE WHERE DATA_SET_ID = 100",
      "UPDATE DATA_VERSIONS SET VERSION_NUMBER = 'v2.0', LAST_UPDATED = SYSDATE WHERE VERSION_NUMBER = 'v1.5'"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_data_sets that fires after each row is updated in the DATA_VERSIONS table, and for each updated row, inserts a new record into the DATA_SETS table using the updated row's DATA_SET_ID, setting the DATA_SET_NAME and DATA_TYPE based on the VERSION_NUMBER: if VERSION_NUMBER is 'v1.0', insert 'Version 1 Dataset' and 'Demographic'; if 'v2.0', insert 'Version 2 Dataset' and 'Socioeconomic'; for any other version, insert 'Other Version Dataset' and 'Other'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_data_sets that fires after each row is updated in the DATA_VERSIONS table, inserting a new record into the DATA_SETS table using the updated row's DATA_SET_ID, where the DATA_SET_NAME and DATA_TYPE are determined by the VERSION_NUMBER: if it is 'v1.0', set them to 'Version 1 Dataset' and 'Demographic'; if it is 'v2.0', set them to 'Version 2 Dataset' and 'Socioeconomic'; for any other version number, set them to 'Other Version Dataset' and 'Other'.",
    "id": 58,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_data_sets that is executed after an update operation on the DATA_VERSIONS table for each row affected by the update. The trigger checks the value of the VERSION_NUMBER column in the updated row. If the VERSION_NUMBER is 'v1.0', it inserts a new row into the DATA_SETS table with the DATA_SET_ID from the updated row, a DATA_SET_NAME of 'Version 1 Dataset', and a DATA_TYPE of 'Demographic'. If the VERSION_NUMBER is 'v2.0', it inserts a new row into the DATA_SETS table with the DATA_SET_ID from the updated row, a DATA_SET_NAME of 'Version 2 Dataset', and a DATA_TYPE of 'Socioeconomic'. If the VERSION_NUMBER is neither 'v1.0' nor 'v2.0', it inserts a new row into the DATA_SETS table with the DATA_SET_ID from the updated row, a DATA_SET_NAME of 'Other Version Dataset', and a DATA_TYPE of 'Other'. The trigger uses conditional logic to determine which insert operation to perform based on the VERSION_NUMBER value, utilizing an IF-ELSIF-ELSE structure to handle the different cases.",
    "original_summary": "Create an AFTER UPDATE row-level trigger named trg_update_data_sets on the DATA_VERSIONS table. For each updated row, insert a record into the DATA_SETS table. Use the updated row's DATA_SET_ID. Set DATA_SET_NAME and DATA_TYPE based on the VERSION_NUMBER: 'v1.0' inserts 'Version 1 Dataset' and 'Demographic'; 'v2.0' inserts 'Version 2 Dataset' and 'Socioeconomic'; any other version inserts 'Other Version Dataset' and 'Other'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires off after someone updates a row in the DATA_VERSIONS table. Call it trg_update_data_sets. Every time a row gets updated, we gotta pop a new record into the DATA_SETS table. Use that updated row's DATA_SET_ID. Now, for the DATA_SET_NAME and DATA_TYPE, we gotta figure that out from the VERSION_NUMBER. If it's 'v1.0', slap in 'Version 1 Dataset' and 'Demographic'. If it's 'v2.0', go with 'Version 2 Dataset' and 'Socioeconomic'. For any other version number, just use 'Other Version Dataset' and 'Other'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_after_team_invitation that is executed automatically after a new row is inserted into the TEAM_INVITATIONS table. This trigger operates on each row that is inserted. It checks if the STATUS column of the newly inserted row, referenced as :NEW.STATUS, is equal to the string 'accepted'. If this condition is true, the trigger performs an INSERT operation into the TEAM_MEMBERS table. The columns affected in the TEAM_MEMBERS table are TEAM_MEMBER_ID, TEAM_ID, USER_ID, IS_LEADER, JOINED_AT, and ROLE_IN_TEAM. The TEAM_MEMBER_ID is assigned a value that is one greater than the current maximum TEAM_MEMBER_ID found in the TEAM_MEMBERS table, using a subquery with the NVL function to handle cases where the table might be empty by defaulting to 0. The TEAM_ID and USER_ID columns are populated with the values from the :NEW.TEAM_ID and :NEW.USER_ID fields of the inserted row in the TEAM_INVITATIONS table, respectively. The IS_LEADER column is set to 0, indicating that the new team member is not a leader. The JOINED_AT column is set to the value of :NEW.INVITATION_TIME from the inserted row, recording the time the invitation was accepted. Finally, the ROLE_IN_TEAM column is set to the string 'member', designating the role of the new team member.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_team_invitation\nAFTER INSERT ON TEAM_INVITATIONS\nFOR EACH ROW\nBEGIN\n  IF :NEW.STATUS = 'accepted' THEN\n    INSERT INTO TEAM_MEMBERS (TEAM_MEMBER_ID, TEAM_ID, USER_ID, IS_LEADER, JOINED_AT, ROLE_IN_TEAM)\n    VALUES ((SELECT NVL(MAX(TEAM_MEMBER_ID), 0) + 1 FROM TEAM_MEMBERS), :NEW.TEAM_ID, :NEW.USER_ID, 0, :NEW.INVITATION_TIME, 'member');\n  END IF;\nEND;",
    "database_name": "user_maa_syste",
    "tables": [
      "USERS",
      "LOGIN_HISTORY",
      "USER_ACTIVITY",
      "PASSWORD_RESET",
      "NOTIFICATIONS",
      "TEAM_INVITATIONS",
      "TEAM_MEMBERS",
      "TEAMS"
    ],
    "call_sqls": [
      "INSERT INTO TEAM_INVITATIONS (INVITATION_ID, TEAM_ID, USER_ID, INVITATION_TIME, INVITED_BY, STATUS, MESSAGE) VALUES (100, 1, 10, SYSDATE, 5, 'accepted', 'Welcome to Team Alpha!')",
      "INSERT INTO TEAM_INVITATIONS (INVITATION_ID, TEAM_ID, USER_ID, INVITATION_TIME, INVITED_BY, STATUS, MESSAGE) VALUES (101, 2, 11, SYSDATE, 6, 'pending', 'Join Team Beta!')",
      "INSERT INTO TEAM_INVITATIONS (INVITATION_ID, TEAM_ID, USER_ID, INVITATION_TIME, INVITED_BY, STATUS, MESSAGE) VALUES (102, 3, 12, SYSDATE, 7, 'accepted', 'Team Gamma needs you!')",
      "INSERT INTO TEAM_INVITATIONS (INVITATION_ID, TEAM_ID, USER_ID, INVITATION_TIME, INVITED_BY, STATUS, MESSAGE) VALUES (103, 1, 13, SYSDATE, 5, 'declined', 'Sorry, not interested.')",
      "INSERT INTO TEAM_INVITATIONS (INVITATION_ID, TEAM_ID, USER_ID, INVITATION_TIME, INVITED_BY, STATUS, MESSAGE) VALUES (104, 4, 14, SYSDATE, 8, 'accepted', 'Join Team Delta!')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_after_team_invitation that fires after each row is inserted into the TEAM_INVITATIONS table. When a new invitation has a STATUS of 'accepted', insert a corresponding record into the TEAM_MEMBERS table. The new TEAM_MEMBER_ID should be set to the next sequential number (one greater than the maximum existing TEAM_MEMBER_ID, or starting at 1 if none exist). Populate TEAM_ID with the new invitation's TEAM_ID, USER_ID with the new invitation's USER_ID, set IS_LEADER to 0, set JOINED_AT to the invitation's INVITATION_TIME, and set ROLE_IN_TEAM to 'member'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_after_team_invitation that, after an insert into the TEAM_INVITATIONS table, checks if the new STATUS is 'accepted'; if so, it adds a new member to the TEAM_MEMBERS table with the next available TEAM_MEMBER_ID, using the inserted TEAM_ID, USER_ID, and INVITATION_TIME, setting IS_LEADER to 0 and ROLE_IN_TEAM to 'member'.",
    "id": 59,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_after_team_invitation. This trigger is configured to execute automatically AFTER any INSERT operation is performed on the TEAM_INVITATIONS table. It is a FOR EACH ROW trigger, meaning its logic will be executed once for every individual row that is inserted into the TEAM_INVITATIONS table. The trigger's primary purpose is to conditionally insert a corresponding record into the TEAM_MEMBERS table when a team invitation is accepted.\n\nWithin the trigger's execution block, a conditional IF statement is evaluated. The condition checks if the value of the STATUS column for the newly inserted row, referenced via the :NEW pseudorecord, is exactly equal to the string 'accepted'. If this condition evaluates to true, the trigger proceeds to perform an INSERT operation into the TEAM_MEMBERS table.\n\nFor this INSERT operation, the trigger must generate a value for the TEAM_MEMBER_ID column. It does this by executing a subquery to calculate the next available ID. This subquery performs a SELECT statement on the TEAM_MEMBERS table, using the NVL and MAX functions. Specifically, it selects NVL(MAX(TEAM_MEMBER_ID), 0) + 1. This logic finds the current maximum value in the TEAM_MEMBER_ID column across all existing rows in the TEAM_MEMBERS table. The NVL function handles the case where the table is empty by returning 0, to which 1 is then added, ensuring the first ID is 1. This calculated value becomes the new TEAM_MEMBER_ID.\n\nThe values for the other columns in the new TEAM_MEMBERS row are sourced directly from the newly inserted row in the TEAM_INVITATIONS table. The TEAM_ID and USER_ID values are taken from the :NEW.TEAM_ID and :NEW.USER_ID fields, respectively. The INVITATION_TIME from the :NEW pseudorecord is used as the timestamp for the new membership record. Two columns are set to constant, hard-coded values: the IS_LEADER column is set to the number 0, and the ROLE_IN_TEAM column is set to the string 'member'.\n\nIf the condition in the IF statement evaluates to false (i.e., the new STATUS is not 'accepted'), the trigger does nothing and allows the INSERT operation on TEAM_INVITATIONS to complete without any side effects on the TEAM_MEMBERS table.",
    "original_summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_after_team_invitation on the TEAM_INVITATIONS table. For each new row where :NEW.STATUS is 'accepted', insert a record into the TEAM_MEMBERS table. Set TEAM_MEMBER_ID to the next sequential value (max existing +1, default 0 if null). Set TEAM_ID to :NEW.TEAM_ID, USER_ID to :NEW.USER_ID, IS_LEADER to 0, JOINED_AT to :NEW.INVITATION_TIME, and ROLE_IN_TEAM to 'member'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create trigger trg_after_team_invitation on TEAM_INVITATIONS. On accepted insert, add member to TEAM_MEMBERS with next ID, matching team, user, time, and role."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_INS_TEST_RESULTS that is defined to fire automatically after a new row is successfully inserted into the TEST_RESULTS table, executing once for each individual row inserted. The trigger performs a single UPDATE operation on the TEST_CASES table, specifically setting the EXECUTION_DATE column in TEST_CASES to the value of the :NEW.EXECUTION_DATE value from the newly inserted TEST_RESULTS row, but only for the specific row in TEST_CASES where the TEST_CASE_ID column matches the value of the :NEW.TEST_CASE_ID from the triggering insert operation.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_INS_TEST_RESULTS\nAFTER INSERT ON TEST_RESULTS\nFOR EACH ROW\nBEGIN\n    UPDATE TEST_CASES SET EXECUTION_DATE = :NEW.EXECUTION_DATE WHERE TEST_CASE_ID = :NEW.TEST_CASE_ID;\nEND;",
    "database_name": "software_taqam_71174",
    "tables": [
      "TEST_CASES",
      "TEST_CASE_STEPS",
      "TEST_CASE_ACTUAL_RESULTS",
      "TEST_RESULTS"
    ],
    "call_sqls": [
      "INSERT INTO TEST_RESULTS (RESULT_ID, TEST_CASE_ID, EXECUTION_DATE, OUTCOME, DURATION, CREATED_AT, UPDATED_AT, CREATED_BY, UPDATED_BY) VALUES (100, 0, '2023-10-26T10:00:00Z', 'SUCCESS', 5.5, '2023-10-26T09:00:00Z', '2023-10-26T09:00:00Z', 1, 1)",
      "INSERT INTO TEST_RESULTS (RESULT_ID, TEST_CASE_ID, EXECUTION_DATE, OUTCOME, DURATION, CREATED_AT, UPDATED_AT, CREATED_BY, UPDATED_BY) VALUES (101, 1, '2023-10-26T10:05:00Z', 'FAILURE', 10.2, '2023-10-26T09:05:00Z', '2023-10-26T09:05:00Z', 1, 1)",
      "INSERT INTO TEST_RESULTS (RESULT_ID, TEST_CASE_ID, EXECUTION_DATE, OUTCOME, DURATION, CREATED_AT, UPDATED_AT, CREATED_BY, UPDATED_BY) VALUES (102, 0, '2023-10-26T10:10:00Z', 'SKIPPED', 1.1, '2023-10-26T09:10:00Z', '2023-10-26T09:10:00Z', 1, 1)",
      "INSERT INTO TEST_RESULTS (RESULT_ID, TEST_CASE_ID, EXECUTION_DATE, OUTCOME, DURATION, CREATED_AT, UPDATED_AT, CREATED_BY, UPDATED_BY) VALUES (103, 1, '2023-10-26T10:15:00Z', 'SUCCESS', 7.8, '2023-10-26T09:15:00Z', '2023-10-26T09:15:00Z', 1, 1)",
      "INSERT INTO TEST_RESULTS (RESULT_ID, TEST_CASE_ID, EXECUTION_DATE, OUTCOME, DURATION, CREATED_AT, UPDATED_AT, CREATED_BY, UPDATED_BY) VALUES (104, 0, '2023-10-26T10:20:00Z', 'FAILURE', 12.0, '2023-10-26T09:20:00Z', '2023-10-26T09:20:00Z', 1, 1)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_INS_TEST_RESULTS that fires after each row is inserted into the TEST_RESULTS table, and updates the EXECUTION_DATE column in the TEST_CASES table with the new EXECUTION_DATE value from the inserted row, matching records where the TEST_CASE_ID in TEST_CASES equals the TEST_CASE_ID from the inserted row.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_INS_TEST_RESULTS that, after inserting a new row into the TEST_RESULTS table, updates the EXECUTION_DATE in the TEST_CASES table for the matching TEST_CASE_ID.",
    "id": 60,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_INS_TEST_RESULTS that is defined to fire automatically after a new row is successfully inserted into the TEST_RESULTS table, executing once for each individual row inserted. The trigger performs a single UPDATE operation on the TEST_CASES table, specifically setting the EXECUTION_DATE column in TEST_CASES to the value of the :NEW.EXECUTION_DATE value from the newly inserted TEST_RESULTS row, but only for the specific row in TEST_CASES where the TEST_CASE_ID column matches the value of the :NEW.TEST_CASE_ID from the triggering insert operation.",
    "original_summary": "Create an AFTER INSERT row-level trigger named TRG_INS_TEST_RESULTS on the TEST_RESULTS table. For each inserted row, update the TEST_CASES table's EXECUTION_DATE column with the new row's EXECUTION_DATE value where TEST_CASE_ID matches.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How do I create an AFTER INSERT row-level trigger named TRG_INS_TEST_RESULTS on the TEST_RESULTS table that, for each new row, updates the EXECUTION_DATE in the TEST_CASES table when the TEST_CASE_ID matches?"
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_audit_prediction_insert` that is activated `AFTER` an `INSERT` operation occurs on the `PREDICTIONS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is inserted into the `PREDICTIONS` table.\n\nUpon activation for a new row, the trigger declares a local PL/SQL variable named `v_country_name` of data type `VARCHAR2` with a maximum length of 255 characters.\n\nThe trigger then attempts to retrieve the `COUNTRY_NAME` from the `COUNTRIES` table. This retrieval is performed by joining the `COUNTRIES` table (aliased as `c`) with the `HAPPINESS_SCORES` table (aliased as `hs`) on their common column `COUNTRY_ID`, specifically where `c.COUNTRY_ID` matches `hs.COUNTRY_ID`. The selection is further filtered by a `WHERE` clause, requiring that `hs.SCORE_ID` is equal to the `SCORE_ID` value of the newly inserted row in the `PREDICTIONS` table, which is referenced using the `:NEW.SCORE_ID` pseudorecord. The retrieved `COUNTRY_NAME` is then assigned to the `v_country_name` variable.\n\nThis `SELECT` operation is enclosed within an exception handling block. If the `SELECT` statement does not find any data matching the specified criteria (i.e., `NO_DATA_FOUND` exception occurs), the `v_country_name` variable is assigned the string literal `'Unknown'`. If the `SELECT` statement returns more than one row (i.e., `TOO_MANY_ROWS` exception occurs), the `v_country_name` variable is assigned the string literal `'Multiple'`.\n\nFollowing this data retrieval and exception handling, there is a commented-out section of code. This commented section indicates a potential `INSERT` operation into a hypothetical `PREDICTIONS_AUDIT` table. If this audit table were to exist and the code were uncommented, it would insert a new row into `PREDICTIONS_AUDIT`. The columns to be populated would be `PREDICTION_ID` (with the value from `:NEW.PREDICTION_ID`), `ACTION` (with the string literal `'INSERT'`), `ACTION_DATE` (with the current system date and time obtained from the `SYSDATE` function), `COUNTRY_NAME` (with the value stored in the `v_country_name` variable), and `PREDICTED_SCORE` (with the value from `:NEW.PREDICTED_HAPPINESS_SCORE`). However, this audit functionality is explicitly stated as removed because the `PREDICTIONS_AUDIT` table does not exist.\n\nFinally, the trigger contains a `NULL` statement, which serves as a placeholder to ensure the trigger's block is syntactically valid, as the preceding audit functionality is commented out. The trigger then concludes its execution.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_audit_prediction_insert\nAFTER INSERT ON PREDICTIONS\nFOR EACH ROW\nDECLARE\n  v_country_name VARCHAR2(255);\nBEGIN\n  BEGIN\n    SELECT c.COUNTRY_NAME INTO v_country_name\n    FROM COUNTRIES c\n    JOIN HAPPINESS_SCORES hs ON c.COUNTRY_ID = hs.COUNTRY_ID\n    WHERE hs.SCORE_ID = :NEW.SCORE_ID;\n  EXCEPTION\n    WHEN NO_DATA_FOUND THEN\n      v_country_name := 'Unknown';\n    WHEN TOO_MANY_ROWS THEN\n      v_country_name := 'Multiple';\n  END;\n  \n  -- Audit functionality removed since PREDICTIONS_AUDIT table does not exist\n  -- If audit table existed, would insert here:\n  -- INSERT INTO PREDICTIONS_AUDIT (PREDICTION_ID, ACTION, ACTION_DATE, COUNTRY_NAME, PREDICTED_SCORE)\n  -- VALUES (:NEW.PREDICTION_ID, 'INSERT', SYSDATE, v_country_name, :NEW.PREDICTED_HAPPINESS_SCORE);\n  \n  NULL; -- Placeholder to make trigger valid\nEND;",
    "database_name": "global_haqol_metrics",
    "tables": [
      "HAPPINESS_SCORES",
      "COUNTRIES",
      "PREDICTIONS"
    ],
    "call_sqls": [
      "INSERT INTO PREDICTIONS (PREDICTION_ID, SCORE_ID, PREDICTED_HAPPINESS_SCORE, PREDICTION_YEAR, MODEL_USED, CONFIDENCE_INTERVAL, EXTERNAL_FACTORS) VALUES (0, 0, 7.6, 2016, 'Linear Regression', 0.05, 'Economic growth, political sta...')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, SCORE_ID, PREDICTED_HAPPINESS_SCORE, PREDICTION_YEAR, MODEL_USED, CONFIDENCE_INTERVAL, EXTERNAL_FACTORS) VALUES (1, 1, 7.55, 2016, 'Random Forest', 0.06, 'Healthcare improvements, educa...')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, SCORE_ID, PREDICTED_HAPPINESS_SCORE, PREDICTION_YEAR, MODEL_USED, CONFIDENCE_INTERVAL, EXTERNAL_FACTORS) VALUES (2, 0, 7.7, 2017, 'Neural Network', 0.04, 'Technological advancements')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, SCORE_ID, PREDICTED_HAPPINESS_SCORE, PREDICTION_YEAR, MODEL_USED, CONFIDENCE_INTERVAL, EXTERNAL_FACTORS) VALUES (3, 1, 7.5, 2017, 'Support Vector Machine', 0.07, 'Social reforms')",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, SCORE_ID, PREDICTED_HAPPINESS_SCORE, PREDICTION_YEAR, MODEL_USED, CONFIDENCE_INTERVAL, EXTERNAL_FACTORS) VALUES (4, 0, 7.65, 2018, 'Decision Tree', 0.055, 'Environmental policies')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_audit_prediction_insert that fires after each row is inserted into the PREDICTIONS table. For each new row, it should retrieve the COUNTRY_NAME from the COUNTRIES table by matching the SCORE_ID from the new row with the HAPPINESS_SCORES table. If no matching country is found, set the country name to 'Unknown'; if multiple matches are found, set it to 'Multiple'. Note that the actual audit insertion into a PREDICTIONS_AUDIT table is commented out because that table does not exist.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_audit_prediction_insert that fires after each row is inserted into the PREDICTIONS table, retrieves the COUNTRY_NAME from COUNTRIES by matching SCORE_ID with HAPPINESS_SCORES, sets the country name to 'Unknown' if no matching data is found or to 'Multiple' if multiple rows are found, and leaves the audit insert logic commented out because the PREDICTIONS_AUDIT table does not exist.",
    "id": 61,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_audit_prediction_insert` that is activated `AFTER` an `INSERT` operation occurs on the `PREDICTIONS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is inserted into the `PREDICTIONS` table.\n\nUpon activation for a new row, the trigger declares a local PL/SQL variable named `v_country_name` of data type `VARCHAR2` with a maximum length of 255 characters.\n\nThe trigger then attempts to retrieve the `COUNTRY_NAME` from the `COUNTRIES` table. This retrieval is performed by joining the `COUNTRIES` table (aliased as `c`) with the `HAPPINESS_SCORES` table (aliased as `hs`) on their common column `COUNTRY_ID`, specifically where `c.COUNTRY_ID` matches `hs.COUNTRY_ID`. The selection is further filtered by a `WHERE` clause, requiring that `hs.SCORE_ID` is equal to the `SCORE_ID` value of the newly inserted row in the `PREDICTIONS` table, which is referenced using the `:NEW.SCORE_ID` pseudorecord. The retrieved `COUNTRY_NAME` is then assigned to the `v_country_name` variable.\n\nThis `SELECT` operation is enclosed within an exception handling block. If the `SELECT` statement does not find any data matching the specified criteria (i.e., `NO_DATA_FOUND` exception occurs), the `v_country_name` variable is assigned the string literal `'Unknown'`. If the `SELECT` statement returns more than one row (i.e., `TOO_MANY_ROWS` exception occurs), the `v_country_name` variable is assigned the string literal `'Multiple'`.\n\nFollowing this data retrieval and exception handling, there is a commented-out section of code. This commented section indicates a potential `INSERT` operation into a hypothetical `PREDICTIONS_AUDIT` table. If this audit table were to exist and the code were uncommented, it would insert a new row into `PREDICTIONS_AUDIT`. The columns to be populated would be `PREDICTION_ID` (with the value from `:NEW.PREDICTION_ID`), `ACTION` (with the string literal `'INSERT'`), `ACTION_DATE` (with the current system date and time obtained from the `SYSDATE` function), `COUNTRY_NAME` (with the value stored in the `v_country_name` variable), and `PREDICTED_SCORE` (with the value from `:NEW.PREDICTED_HAPPINESS_SCORE`). However, this audit functionality is explicitly stated as removed because the `PREDICTIONS_AUDIT` table does not exist.\n\nFinally, the trigger contains a `NULL` statement, which serves as a placeholder to ensure the trigger's block is syntactically valid, as the preceding audit functionality is commented out. The trigger then concludes its execution.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_audit_prediction_insert on the PREDICTIONS table. For each new row, retrieve the COUNTRY_NAME from COUNTRIES by joining with HAPPINESS_SCORES using SCORE_ID. If no data is found, set country name to 'Unknown'. If multiple rows are found, set it to 'Multiple'. The audit insert logic is commented out as the PREDICTIONS_AUDIT table does not exist.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER INSERT row-level trigger named trg_audit_prediction_insert on the PREDICTIONS table that, for each new row, retrieves the COUNTRY_NAME from COUNTRIES by joining with HAPPINESS_SCORES using SCORE_ID, sets the country name to 'Unknown' if no data is found, sets it to 'Multiple' if multiple rows are found, and has the audit insert logic commented out because the PREDICTIONS_AUDIT table does not exist?"
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_metric_values that is executed before an insert operation on the PERFORMANCE_METRICS table. This trigger operates on each row being inserted into the table. It checks the value of the AUC column in the new row, referenced as :NEW.AUC, to ensure it is within the range of 0 to 1, inclusive. If the AUC value is less than 0 or greater than 1, the trigger raises an application error with the error code -20002 and the message 'AUC must be between 0 and 1'. Similarly, the trigger checks the value of the ACCURACY column in the new row, referenced as :NEW.ACCURACY, to ensure it is also within the range of 0 to 1, inclusive. If the ACCURACY value is less than 0 or greater than 1, the trigger raises an application error with the error code -20003 and the message 'Accuracy must be between 0 and 1'. The trigger does not perform any updates, deletes, or selects, and it does not call any functions or perform any special operations beyond the conditional checks and error raising.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_metric_values\nBEFORE INSERT ON PERFORMANCE_METRICS\nFOR EACH ROW\nBEGIN\n  IF :NEW.AUC < 0 OR :NEW.AUC > 1 THEN\n    RAISE_APPLICATION_ERROR(-20002, 'AUC must be between 0 and 1');\n  END IF;\n  IF :NEW.ACCURACY < 0 OR :NEW.ACCURACY > 1 THEN\n    RAISE_APPLICATION_ERROR(-20003, 'Accuracy must be between 0 and 1');\n  END IF;\nEND;",
    "database_name": "machine_lmpm_310382",
    "tables": [
      "MODELS",
      "MODEL_VERSIONS",
      "EVALUATIONS",
      "PERFORMANCE_METRICS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO PERFORMANCE_METRICS (METRIC_ID, EVALUATION_ID, AUC, ACCURACY) VALUES (100, 1, 0.95, 0.92)",
      "INSERT INTO PERFORMANCE_METRICS (METRIC_ID, EVALUATION_ID, AUC, ACCURACY) VALUES (101, 1, 0.5, 0.5)",
      "INSERT INTO PERFORMANCE_METRICS (METRIC_ID, EVALUATION_ID, AUC, ACCURACY, TPR, FPR) VALUES (102, 2, 1.0, 1.0, 0.9, 0.1)",
      "INSERT INTO PERFORMANCE_METRICS (METRIC_ID, EVALUATION_ID, AUC, ACCURACY) VALUES (103, 2, -0.1, 0.8)",
      "INSERT INTO PERFORMANCE_METRICS (METRIC_ID, EVALUATION_ID, AUC, ACCURACY, F1_SCORE) VALUES (104, 3, 0.0, 1.1, 0.85)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_validate_metric_values that fires before each row is inserted into the PERFORMANCE_METRICS table, validating that the new AUC value is between 0 and 1 and raising an error if it is not, and also validating that the new ACCURACY value is between 0 and 1 and raising an error if it is not.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_validate_metric_values that runs before each row is inserted into the PERFORMANCE_METRICS table to validate that the AUC and ACCURACY values are within acceptable ranges, raising an error if AUC is not between 0 and 1 inclusive or if ACCURACY is not between 0 and 1 inclusive.",
    "id": 62,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_validate_metric_values that is defined to fire automatically before any row insertion operation is performed on the PERFORMANCE_METRICS table, and for each individual row being inserted, the trigger executes a block of code that validates the values of two specific columns in the new row image: AUC and ACCURACY. The validation logic consists of two conditional checks. First, it checks if the value of the :NEW.AUC pseudorecord field is not within the inclusive numeric range of 0 to 1. Second, it checks if the value of the :NEW.ACCURACY pseudorecord field is not within the inclusive numeric range of 0 to 1. If either of these conditions evaluates to true, the trigger raises a custom application error using the RAISE_APPLICATION_ERROR procedure. This procedure is called with an error number argument of -20001, which is a user-defined error number within the permissible range, and an error message argument that is a string literal describing the validation failure, specifically indicating that either the AUC or ACCURACY value is out of the acceptable range of 0 to 1. Raising this error immediately halts the execution of the triggering INSERT statement and causes the entire transaction to roll back, preventing the insertion of the invalid row into the PERFORMANCE_METRICS table. If both the :NEW.AUC and :NEW.ACCURACY values are within their respective valid ranges, the trigger completes without raising an error, allowing the INSERT operation to proceed normally.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_validate_metric_values on the PERFORMANCE_METRICS table. Raise application error -20002 if the new AUC is not between 0 and 1. Raise application error -20003 if the new ACCURACY is not between 0 and 1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE INSERT FOR EACH ROW trigger, designated as trg_validate_metric_values, for the PERFORMANCE_METRICS table. The trigger must enforce the following validation rules: it shall raise application error -20002 in the event that the newly inserted AUC value falls outside the inclusive range of 0 to 1. Furthermore, it shall raise application error -20003 if the newly inserted ACCURACY value is not within the inclusive bounds of 0 and 1."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_audit_sales_insert that is executed automatically after a new row is inserted into the SALES table. This trigger operates on each row that is inserted and performs an insert operation into the RETURNS table. The insert operation populates the RETURN_ID column with a constant value of 999, the SALE_ID column with the value from the SALE_ID column of the newly inserted row in the SALES table, the ITEM_ID column with the value from the ITEM_ID column of the new row, the SIZE_ID column with the value from the SIZE_ID column of the new row, the RETURN_REASON column with the string 'Audit Trail', the RETURN_DATE column with the current date obtained from the CURRENT_DATE function, the EMPLOYEE_ID column with the value from the EMPLOYEE_ID column of the new row, and the RETURN_STATUS column with the string 'Pending'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_audit_sales_insert\nAFTER INSERT ON SALES\nFOR EACH ROW\nBEGIN\n  INSERT INTO RETURNS (RETURN_ID, SALE_ID, ITEM_ID, SIZE_ID, RETURN_REASON, RETURN_DATE, EMPLOYEE_ID, RETURN_STATUS)\n  VALUES (999, :NEW.SALE_ID, :NEW.ITEM_ID, :NEW.SIZE_ID, 'Audit Trail', CURRENT_DATE, :NEW.EMPLOYEE_ID, 'Pending');\nEND;",
    "database_name": "clothing_ssar_management",
    "tables": [
      "CLOTHING_ITEMS",
      "CUSTOMERS",
      "INVENTORY",
      "RETURNS",
      "SALES",
      "SIZES"
    ],
    "call_sqls": [
      "INSERT INTO SALES (SALE_ID, CUSTOMER_ID, ITEM_ID, SIZE_ID, QUANTITY, SALE_DATE, STORE_ID, EMPLOYEE_ID, TOTAL_COST, PAYMENT_METHOD) VALUES (2, 0, 0, 0, 1, '2023-05-05', 1, 0, '29.99', 'Credit Card')",
      "INSERT INTO SALES (SALE_ID, CUSTOMER_ID, ITEM_ID, SIZE_ID, QUANTITY, SALE_DATE, STORE_ID, EMPLOYEE_ID, TOTAL_COST, PAYMENT_METHOD) VALUES (3, 1, 0, 1, 2, '2023-05-06', 1, 1, '99.98', 'Cash')",
      "INSERT INTO SALES (SALE_ID, CUSTOMER_ID, ITEM_ID, SIZE_ID, QUANTITY, SALE_DATE, STORE_ID, EMPLOYEE_ID, TOTAL_COST, PAYMENT_METHOD) VALUES (4, 0, 1, 0, 1, '2023-05-07', 0, 0, '49.99', 'Debit Card')",
      "INSERT INTO SALES (SALE_ID, CUSTOMER_ID, ITEM_ID, SIZE_ID, QUANTITY, SALE_DATE, STORE_ID, EMPLOYEE_ID, TOTAL_COST, PAYMENT_METHOD) VALUES (5, 1, 1, 1, 1, '2023-05-08', 0, 1, '49.99', 'Credit Card')",
      "INSERT INTO SALES (SALE_ID, CUSTOMER_ID, ITEM_ID, SIZE_ID, QUANTITY, SALE_DATE, STORE_ID, EMPLOYEE_ID, TOTAL_COST, PAYMENT_METHOD) VALUES (6, 0, 0, 0, 3, '2023-05-09', 1, 0, '89.97', 'Cash')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_audit_sales_insert that fires after each new row is inserted into the SALES table, creating an audit trail by inserting a corresponding record into the RETURNS table. For every new sale, the trigger inserts a row into RETURNS with a fixed RETURN_ID of 999, the new sale's SALE_ID, ITEM_ID, SIZE_ID, and EMPLOYEE_ID, sets the RETURN_REASON to 'Audit Trail', populates the RETURN_DATE with the current date, and sets the RETURN_STATUS to 'Pending'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_audit_sales_insert that, after each new row is inserted into the SALES table, creates an audit entry in the RETURNS table. For every new sale, the trigger should record a fixed RETURN_ID of 999, include the new sale's SALE_ID, ITEM_ID, SIZE_ID, and EMPLOYEE_ID, set the RETURN_REASON to 'Audit Trail', log the current date as the RETURN_DATE, and mark the RETURN_STATUS as 'Pending'.",
    "id": 63,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_audit_sales_insert that is executed automatically after a new row is inserted into the SALES table. This trigger operates on each row that is inserted and performs an insert operation into the RETURNS table. The insert operation populates the RETURN_ID column with a constant value of 999, the SALE_ID column with the value from the SALE_ID column of the newly inserted row in the SALES table, the ITEM_ID column with the value from the ITEM_ID column of the new row, the SIZE_ID column with the value from the SIZE_ID column of the new row, the RETURN_REASON column with the string 'Audit Trail', the RETURN_DATE column with the current date obtained from the CURRENT_DATE function, the EMPLOYEE_ID column with the value from the EMPLOYEE_ID column of the new row, and the RETURN_STATUS column with the string 'Pending'.",
    "original_summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_audit_sales_insert on the SALES table. For each new sale, insert a corresponding audit record into the RETURNS table with a fixed RETURN_ID of 999, the new sale's SALE_ID, ITEM_ID, SIZE_ID, and EMPLOYEE_ID, a RETURN_REASON of 'Audit Trail', the current date, and a RETURN_STATUS of 'Pending'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER INSERT FOR EACH ROW trigger, which should be named trg_audit_sales_insert, specifically for the SALES table. This detailed trigger will meticulously capture every newly inserted sale, subsequently creating a comprehensive audit entry within the RETURNS table. Each audit record will systematically populate the RETURN_ID with the predetermined, fixed value of 999, while also incorporating the new sale's essential identifiers: SALE_ID, ITEM_ID, SIZE_ID, and EMPLOYEE_ID. Furthermore, it will explicitly set the RETURN_REASON to the descriptive phrase 'Audit Trail', automatically log the precise current date, and definitively assign a RETURN_STATUS of 'Pending' to clearly indicate its initial state."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_confidence that fires automatically before each row is inserted into the PREDICTIONS table, and for each new row, it declares a local variable v_tanh_confidence of type NUMBER, then calculates the hyperbolic tangent of the incoming value from the :NEW.CONFIDENCE column using the TANH function and assigns the result to v_tanh_confidence, then evaluates this value with a conditional IF-ELSIF-ELSE block: if v_tanh_confidence is less than 0.5, it sets the :NEW.ALERT_STATUS column for the row being inserted to the string 'active'; else if v_tanh_confidence is greater than or equal to 0.5 and less than 0.8, it sets :NEW.ALERT_STATUS to 'review'; otherwise, for all cases where v_tanh_confidence is 0.8 or greater, it sets :NEW.ALERT_STATUS to 'inactive'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_confidence\nBEFORE INSERT ON PREDICTIONS\nFOR EACH ROW\nDECLARE\n  v_tanh_confidence NUMBER;\nBEGIN\n  v_tanh_confidence := TANH(:NEW.CONFIDENCE);\n\n  IF v_tanh_confidence < 0.5 THEN\n    :NEW.ALERT_STATUS := 'active';\n  ELSIF v_tanh_confidence >= 0.5 AND v_tanh_confidence < 0.8 THEN\n    :NEW.ALERT_STATUS := 'review';\n  ELSE\n    :NEW.ALERT_STATUS := 'inactive';\n  END IF;\nEND;",
    "database_name": "weather_oaf_92747",
    "tables": [
      "PREDICTIONS",
      "PREDICTION_MODELS"
    ],
    "call_sqls": [
      "INSERT INTO PREDICTIONS (PREDICTION_ID, MODEL_ID, STATION_ID, EST, PREDICTED_CONDITION_ID, CONFIDENCE, ACTUAL_CONDITION_ID, ERROR_MARGIN) VALUES (0, 0, 0, '1993-01-01', 1, 0.1, 1, 0.05)",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, MODEL_ID, STATION_ID, EST, PREDICTED_CONDITION_ID, CONFIDENCE, ACTUAL_CONDITION_ID, ERROR_MARGIN) VALUES (1, 1, 1, '1993-01-02', 0, 0.6, 0, 0.1)",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, MODEL_ID, STATION_ID, EST, PREDICTED_CONDITION_ID, CONFIDENCE, ACTUAL_CONDITION_ID, ERROR_MARGIN) VALUES (2, 0, 0, '1993-01-03', 1, 0.9, 1, 0.02)",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, MODEL_ID, STATION_ID, EST, PREDICTED_CONDITION_ID, CONFIDENCE, ACTUAL_CONDITION_ID, ERROR_MARGIN) VALUES (3, 1, 1, '1993-01-04', 0, 0.4, 0, 0.08)",
      "INSERT INTO PREDICTIONS (PREDICTION_ID, MODEL_ID, STATION_ID, EST, PREDICTED_CONDITION_ID, CONFIDENCE, ACTUAL_CONDITION_ID, ERROR_MARGIN) VALUES (4, 0, 0, '1993-01-05', 1, 0.75, 1, 0.03)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_check_confidence that fires before each row is inserted into the PREDICTIONS table. For each new row, calculate the hyperbolic tangent of the new CONFIDENCE value, then set the new ALERT_STATUS to 'active' if the result is less than 0.5, to 'review' if it is between 0.5 and 0.8, and to 'inactive' if it is 0.8 or greater.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_check_confidence that runs before inserting each new record into the PREDICTIONS table. For each new entry, calculate the hyperbolic tangent of its CONFIDENCE score, then set the ALERT_STATUS to 'active' if the result is low (below 0.5), to 'review' if it is in a middling range (0.5 to below 0.8), and to 'inactive' if it is high (0.8 or above).",
    "id": 64,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_check_confidence that is executed before an insert operation on the PREDICTIONS table for each row being inserted. The trigger does not declare any local variables. For each new row, the trigger calculates the hyperbolic tangent of the CONFIDENCE score from the :NEW pseudorecord using the TANH function. Based on the calculated value, the trigger sets the ALERT_STATUS column of the new row to a specific string. If the hyperbolic tangent result is less than 0.5, the ALERT_STATUS is set to 'active'. If the result is greater than or equal to 0.5 and less than 0.8, the ALERT_STATUS is set to 'review'. If the result is greater than or equal to 0.8, the ALERT_STATUS is set to 'inactive'. This trigger does not perform any conditional checks or additional logic beyond this calculation and assignment.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_check_confidence on the PREDICTIONS table. For each new row, calculate the hyperbolic tangent of :NEW.CONFIDENCE. Set :NEW.ALERT_STATUS to 'active' if the result is less than 0.5, to 'review' if it is between 0.5 and 0.8, and to 'inactive' if it is 0.8 or greater.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the PREDICTIONS table that runs before adding any new record. Call it something like trg_check_confidence. For each incoming entry, you need to work out the hyperbolic tangent based on its confidence score. Then, adjust the alert status: if that calculated figure is on the low side, mark it as 'active'; if it's in a middling range, set it for 'review'; and if it's pretty high, just make it 'inactive'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_country_race that is executed after a delete operation on the NATIVE_COUNTRIES table for each row affected by the delete. The trigger begins by declaring two local variables: v_race_exists of type NUMBER, which will store the count of records, and v_new_race_id of type NUMBER, which will store the new race identifier. The trigger then performs a SELECT statement to count the number of entries in the RACES table where the RACE_NAME column matches the value of the NATIVE_COUNTRY_NAME column from the deleted row, storing the result in v_race_exists. If v_race_exists is greater than zero, indicating that a race with the same name as the deleted country already exists, the trigger executes an UPDATE statement on the RACES table, setting the DESCRIPTION column to 'Former country: ' concatenated with the deleted country's name for the row where RACE_NAME matches the deleted country's name. If no such race exists, the trigger performs another SELECT statement using the NVL function to determine the maximum RACE_ID in the RACES table, defaulting to zero if no records exist, and adds one to this value to generate a new race identifier, storing it in v_new_race_id. Subsequently, the trigger executes an INSERT statement to add a new record to the RACES table with the generated race identifier, the deleted country's name as the RACE_NAME, and 'Migrated from countries' as the DESCRIPTION.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_country_race\nAFTER DELETE ON NATIVE_COUNTRIES\nFOR EACH ROW\nDECLARE\n    v_race_exists NUMBER;\n    v_new_race_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_race_exists FROM RACES WHERE RACE_NAME = :OLD.NATIVE_COUNTRY_NAME;\n    IF v_race_exists > 0 THEN\n        UPDATE RACES SET DESCRIPTION = 'Former country: ' || :OLD.NATIVE_COUNTRY_NAME WHERE RACE_NAME = :OLD.NATIVE_COUNTRY_NAME;\n    ELSE\n        SELECT NVL(MAX(RACE_ID), 0) + 1 INTO v_new_race_id FROM RACES;\n        INSERT INTO RACES (RACE_ID, RACE_NAME, DESCRIPTION) VALUES (v_new_race_id, :OLD.NATIVE_COUNTRY_NAME, 'Migrated from countries');\n    END IF;\nEND;",
    "database_name": "demographic_asda_40195",
    "tables": [
      "DATASETS",
      "DATA_COLLECTION_METHODS",
      "EDUCATION_LEVELS",
      "NATIVE_COUNTRIES",
      "RACES",
      "RELATIONSHIPS"
    ],
    "call_sqls": [
      "DELETE FROM NATIVE_COUNTRIES WHERE NATIVE_COUNTRY_ID = 0",
      "DELETE FROM NATIVE_COUNTRIES WHERE NATIVE_COUNTRY_ID = 1",
      "DELETE FROM NATIVE_COUNTRIES WHERE NATIVE_COUNTRY_NAME = 'United-States'",
      "DELETE FROM NATIVE_COUNTRIES WHERE NATIVE_COUNTRY_NAME = 'Cuba'",
      "DELETE FROM NATIVE_COUNTRIES WHERE NATIVE_COUNTRY_ID = 2"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_sync_country_race that fires AFTER DELETE on each row of the NATIVE_COUNTRIES table. For each deleted country, check if a race with the same name as the deleted NATIVE_COUNTRY_NAME already exists in the RACES table. If it exists, update that race's DESCRIPTION in RACES to 'Former country: ' followed by the country name. If it does not exist, generate a new RACE_ID by taking the maximum existing RACE_ID plus one (starting from 1 if none exist) and insert a new race into RACES with that RACE_ID, the country name as RACE_NAME, and the DESCRIPTION set to 'Migrated from countries'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_sync_country_race that fires after each row is deleted from the NATIVE_COUNTRIES table. For every deleted country, check if a race with the same name as the deleted NATIVE_COUNTRY_NAME already exists in the RACES table. If it exists, update the DESCRIPTION of that race to start with 'Former country: ' followed by the country name. If it does not exist, create a new RACE_ID by taking the maximum existing RACE_ID and adding one, then insert a new race record with that ID, the country name as RACE_NAME, and 'Migrated from countries' as DESCRIPTION.",
    "id": 65,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_sync_country_race that is executed after a delete operation on the NATIVE_COUNTRIES table for each row affected by the delete. The trigger begins by declaring two local variables: v_race_exists of type NUMBER, which will store the count of records, and v_new_race_id of type NUMBER, which will store the new race identifier. The trigger then performs a SELECT statement to count the number of entries in the RACES table where the RACE_NAME column matches the value of the NATIVE_COUNTRY_NAME column from the deleted row, storing the result in v_race_exists. If v_race_exists is greater than zero, indicating that a race with the same name as the deleted country already exists, the trigger executes an UPDATE statement on the RACES table, setting the DESCRIPTION column to 'Former country: ' concatenated with the deleted country's name for the row where RACE_NAME matches the deleted country's name. If no such race exists, the trigger performs another SELECT statement using the NVL function to determine the maximum RACE_ID in the RACES table, defaulting to zero if no records exist, and adds one to this value to generate a new race identifier, storing it in v_new_race_id. Subsequently, the trigger executes an INSERT statement to add a new record to the RACES table with the generated race identifier, the deleted country's name as the RACE_NAME, and 'Migrated from countries' as the DESCRIPTION.",
    "original_summary": "Create an AFTER DELETE row trigger named trg_sync_country_race on the NATIVE_COUNTRIES table. Declare NUMBER variables v_race_exists and v_new_race_id. For each deleted row, check if a race with the same name as the deleted country exists. If it exists, update that race's description to 'Former country: ' concatenated with the country name. If it does not exist, generate a new RACE_ID (max + 1) and insert a new race with the country name and description 'Migrated from countries'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER DELETE row trigger, which should be named trg_sync_country_race, to be placed on the NATIVE_COUNTRIES table. You must carefully declare two NUMBER variables, specifically v_race_exists and v_new_race_id. For every single row that is deleted, the trigger should meticulously check whether a race entry, sharing an identical name with the recently deleted country, already exists within the relevant table. Should such a race be found, its description must be thoughtfully updated to a string that begins with 'Former country: ' and is then seamlessly concatenated with the original name of the country. Conversely, if no matching race is discovered, the process must then generate a completely new RACE_ID by calculating the maximum existing value and adding one, followed by the insertion of a brand new race record that incorporates the deleted country's name and a descriptive note stating 'Migrated from countries'."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_station_capacity` that is automatically executed after an `INSERT` operation is performed on the `RENTALS` table. This trigger is a row-level trigger, meaning it fires once for each row that is inserted into the `RENTALS` table. For each newly inserted row, the trigger performs two distinct `UPDATE` operations on the `STATIONS` table. The first `UPDATE` operation modifies the `STATIONS` table by decrementing the value of the `CURRENT_CAPACITY` column by `1`. This update is applied to the specific row in the `STATIONS` table where the `STATION_ID` column matches the value of the `START_STATION_ID` column from the newly inserted row in the `RENTALS` table, which is referenced using the `:NEW.START_STATION_ID` pseudorecord. The second `UPDATE` operation also modifies the `STATIONS` table, but this time it increments the value of the `CURRENT_CAPACITY` column by `1`. This update is applied to the specific row in the `STATIONS` table where the `STATION_ID` column matches the value of the `END_STATION_ID` column from the newly inserted row in the `RENTALS` table, which is referenced using the `:NEW.END_STATION_ID` pseudorecord.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_station_capacity\nAFTER INSERT ON RENTALS\nFOR EACH ROW\nBEGIN\n  UPDATE STATIONS\n  SET CURRENT_CAPACITY = CURRENT_CAPACITY - 1\n  WHERE STATION_ID = :NEW.START_STATION_ID;\n  UPDATE STATIONS\n  SET CURRENT_CAPACITY = CURRENT_CAPACITY + 1\n  WHERE STATION_ID = :NEW.END_STATION_ID;\nEND;",
    "database_name": "bike_ssautd_management",
    "tables": [
      "BIKES",
      "RENTALS",
      "STATIONS",
      "TRIPS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO RENTALS (RENTAL_ID, BIKE_ID, USER_ID, RENTAL_DATE, RETURN_DATE, START_STATION_ID, END_STATION_ID, PAYMENT_AMOUNT, PAYMENT_METHOD) VALUES (1000, 1, 1, '2024-01-15 09:00:00', '2024-01-15 09:30:00', 0, 1, '5.0', 'Credit Card')",
      "INSERT INTO RENTALS (RENTAL_ID, BIKE_ID, USER_ID, RENTAL_DATE, RETURN_DATE, START_STATION_ID, END_STATION_ID, PAYMENT_AMOUNT, PAYMENT_METHOD) VALUES (1001, 0, 0, '2024-01-15 10:15:00', '2024-01-15 10:45:00', 1, 0, '4.5', 'PayPal')",
      "INSERT INTO RENTALS (RENTAL_ID, BIKE_ID, USER_ID, RENTAL_DATE, RETURN_DATE, START_STATION_ID, END_STATION_ID, PAYMENT_AMOUNT, PAYMENT_METHOD) VALUES (1002, 1, 0, '2024-01-15 11:30:00', '2024-01-15 12:00:00', 0, 1, '6.0', 'Credit Card')",
      "INSERT INTO RENTALS (RENTAL_ID, BIKE_ID, USER_ID, RENTAL_DATE, RETURN_DATE, START_STATION_ID, END_STATION_ID, PAYMENT_AMOUNT, PAYMENT_METHOD) VALUES (1003, 0, 1, '2024-01-15 13:45:00', '2024-01-15 14:15:00', 1, 0, '3.5', 'Cash')",
      "INSERT INTO RENTALS (RENTAL_ID, BIKE_ID, USER_ID, RENTAL_DATE, RETURN_DATE, START_STATION_ID, END_STATION_ID, PAYMENT_AMOUNT, PAYMENT_METHOD) VALUES (1004, 1, 1, '2024-01-15 15:00:00', '2024-01-15 15:20:00', 0, 1, '2.5', 'Credit Card')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_station_capacity that fires after each new row is inserted into the RENTALS table, adjusting the CURRENT_CAPACITY in the STATIONS table by decreasing it by 1 for the station matching the START_STATION_ID from the new rental and increasing it by 1 for the station matching the END_STATION_ID from the new rental.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_station_capacity that fires after each insert on the RENTALS table to adjust station capacities: for every new rental, decrease the CURRENT_CAPACITY by 1 in the STATIONS table for the station with STATION_ID matching the new START_STATION_ID, and increase the CURRENT_CAPACITY by 1 for the station with STATION_ID matching the new END_STATION_ID.",
    "id": 66,
    "generated_ir": "Write an Oracle PL/SQL database trigger named trg_update_station_capacity that is configured to execute AFTER an INSERT operation is performed on the RENTALS table. This trigger is defined as a FOR EACH ROW trigger, meaning its body will execute once for each new row inserted into the RENTALS table. When a row is inserted into the RENTALS table, the trigger's execution context provides access to the values of the newly inserted row through the :NEW correlation identifier. Inside the trigger body, the first operation performed is an UPDATE statement targeting the STATIONS table. This UPDATE statement decreases the CURRENT_CAPACITY column by 1 for the specific row in the STATIONS table where the STATION_ID column matches the value of the START_STATION_ID column from the newly inserted RENTALS row, which is accessed via :NEW.START_STATION_ID. Following this, the second operation performed is another UPDATE statement, also targeting the STATIONS table. This UPDATE statement increases the CURRENT_CAPACITY column by 1 for the specific row in the STATIONS table where the STATION_ID column matches the value of the END_STATION_ID column from the newly inserted RENTALS row, which is accessed via :NEW.END_STATION_ID.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_update_station_capacity on RENTALS. For each new row, perform two updates on STATIONS: 1) Decrement CURRENT_CAPACITY by 1 where STATION_ID = :NEW.START_STATION_ID. 2) Increment CURRENT_CAPACITY by 1 where STATION_ID = :NEW.END_STATION_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a row-level trigger called trg_update_station_capacity that fires after an insert on the RENTALS table. For each new record, update the STATIONS table: first, reduce the CURRENT_CAPACITY by 1 for the station matching the new START_STATION_ID; second, increase the CURRENT_CAPACITY by 1 for the station matching the new END_STATION_ID."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_coach_delete that is executed automatically after a delete operation is performed on the COACHES table. This trigger operates for each row that is deleted from the COACHES table. Within the trigger body, it performs a delete operation on the TEAMS table, specifically removing rows where the TEAM_ID column matches the TEAM_ID value of the row that was just deleted from the COACHES table. The trigger uses the :OLD pseudorecord to access the TEAM_ID value of the deleted row from the COACHES table, ensuring that the deletion in the TEAMS table is directly linked to the TEAM_ID of the coach that was removed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_coach_delete\nAFTER DELETE ON COACHES\nFOR EACH ROW\nBEGIN\n  DELETE FROM TEAMS WHERE TEAM_ID = :OLD.TEAM_ID;\nEND;",
    "database_name": "nba_tsap_trackin",
    "tables": [
      "TEAMS",
      "COACHES",
      "PLAYER_STATISTICS",
      "AWARDS",
      "CONTRACTS",
      "DRAFT_PICKS"
    ],
    "call_sqls": [
      "DELETE FROM COACHES WHERE COACH_ID = 0",
      "DELETE FROM COACHES WHERE COACH_ID = 1",
      "DELETE FROM COACHES WHERE TEAM_ID = 0",
      "DELETE FROM COACHES WHERE TEAM_ID = 1",
      "DELETE FROM COACHES WHERE EXPERIENCE = 25"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_coach_delete that fires after a row is deleted from the COACHES table, and for each deleted coach, removes any corresponding row from the TEAMS table where the TEAM_ID matches the deleted coach's TEAM_ID.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_coach_delete that fires after a row is deleted from the COACHES table, and for each deleted coach, it also deletes any team in the TEAMS table that has the same TEAM_ID as the removed coach.",
    "id": 67,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_coach_delete` that is activated automatically `AFTER` a `DELETE` operation is performed on the `COACHES` table. This trigger is defined to execute `FOR EACH ROW` that is deleted from the `COACHES` table. Upon activation for each deleted row, the trigger performs a single `DELETE` operation on the `TEAMS` table. The `DELETE` operation targets rows in the `TEAMS` table where the value in the `TEAM_ID` column matches the value that was in the `TEAM_ID` column of the row just deleted from the `COACHES` table. This value is referenced using the `:OLD.TEAM_ID` pseudorecord. The trigger's purpose is to maintain referential integrity by removing any team associated with a deleted coach, based on a shared `TEAM_ID` value.",
    "original_summary": "Create an AFTER DELETE row-level trigger named trg_coach_delete on the COACHES table. For each deleted row, delete from the TEAMS table where TEAM_ID matches the deleted coach's TEAM_ID (accessed via :OLD.TEAM_ID).",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, set up a trigger called trg_coach_delete that fires after a row gets deleted from the COACHES table. Every time a coach is removed, it should also wipe out any team in the TEAMS table that has the same TEAM_ID as the coach that just got axed (you can grab that old ID with :OLD.TEAM_ID)."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_measurement_validation that executes before any insert or update operation on the MEASUREMENTS table for each affected row, declaring three local NUMBER variables v_size_count, v_unit_count, and v_measurement_count, then performs three separate queries: first, it selects the count of records from the SIZES table where the SIZE_ID column equals the new SIZE_ID value from the triggering row, storing the result in v_size_count; second, it selects the count of records from the MEASUREMENT_UNITS table where the UNIT_ID column equals the constant value 1, storing the result in v_unit_count; third, it selects the count of records from the MEASUREMENTS table where the MEASUREMENT_ID column equals the new MEASUREMENT_ID value from the triggering row, storing the result in v_measurement_count, and then evaluates a conditional IF-ELSIF-ELSE block where if v_size_count equals 0, it inserts a new row into the SIZES table with columns SIZE_ID set to the new SIZE_ID, SIZE_NAME set to 'Auto-Generated', SIZE_CODE set to 'AUTO', DESCRIPTION set to 'Auto-generated size', CATEGORY_ID set to 1, TYPE_ID set to 1, IS_CUSTOM set to 1, and both CREATED_AT and UPDATED_AT set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function on CURRENT_TIMESTAMP, but if that condition is false and v_unit_count equals 0, it inserts a new row into the MEASUREMENT_UNITS table with columns UNIT_ID set to 1, UNIT_NAME set to 'Centimeter', and UNIT_SYMBOL set to 'cm', otherwise, if neither previous condition is true, it deletes all rows from the SIZE_CHARTS table where the MEASUREMENT_ID column equals the new MEASUREMENT_ID value from the triggering row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_measurement_validation\nBEFORE INSERT OR UPDATE ON MEASUREMENTS\nFOR EACH ROW\nDECLARE\n    v_size_count NUMBER;\n    v_unit_count NUMBER;\n    v_measurement_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_size_count FROM SIZES WHERE SIZE_ID = :NEW.SIZE_ID;\n    SELECT COUNT(*) INTO v_unit_count FROM MEASUREMENT_UNITS WHERE UNIT_ID = 1;\n    SELECT COUNT(*) INTO v_measurement_count FROM MEASUREMENTS WHERE MEASUREMENT_ID = :NEW.MEASUREMENT_ID;\n    \n    IF v_size_count = 0 THEN\n        INSERT INTO SIZES (SIZE_ID, SIZE_NAME, SIZE_CODE, DESCRIPTION, CATEGORY_ID, TYPE_ID, IS_CUSTOM, CREATED_AT, UPDATED_AT)\n        VALUES (:NEW.SIZE_ID, 'Auto-Generated', 'AUTO', 'Auto-generated size', 1, 1, 1, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'), TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'));\n    ELSIF v_unit_count = 0 THEN\n        INSERT INTO MEASUREMENT_UNITS (UNIT_ID, UNIT_NAME, UNIT_SYMBOL)\n        VALUES (1, 'Centimeter', 'cm');\n    ELSE\n        DELETE FROM SIZE_CHARTS WHERE MEASUREMENT_ID = :NEW.MEASUREMENT_ID;\n    END IF;\nEND;",
    "database_name": "clothing_scam_management",
    "tables": [
      "BRANDS",
      "CATEGORIES",
      "CLOTHING_LINES",
      "MEASUREMENTS",
      "SIZES",
      "SIZE_CHARTS",
      "TYPES",
      "MEASUREMENT_UNITS"
    ],
    "call_sqls": [
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, BUST_CM, WAIST_CM, HIPS_CM, CREATED_AT, UPDATED_AT) VALUES (100, 999, 90, 60, 95, '2024-01-01 12:00:00', '2024-01-01 12:00:00')",
      "UPDATE MEASUREMENTS SET BUST_CM = 92 WHERE MEASUREMENT_ID = 100",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, BUST_CM, WAIST_CM, HIPS_CM, CREATED_AT, UPDATED_AT) VALUES (101, 1, 85, 58, 90, '2024-01-01 12:00:00', '2024-01-01 12:00:00')",
      "UPDATE MEASUREMENTS SET SIZE_ID = 500 WHERE MEASUREMENT_ID = 101",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, BUST_CM, WAIST_CM, HIPS_CM, CREATED_AT, UPDATED_AT) VALUES (200, 200, 88, 62, 93, '2024-01-01 12:00:00', '2024-01-01 12:00:00')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_measurement_validation that fires BEFORE INSERT OR UPDATE on each row of the MEASUREMENTS table. The trigger should check if the new SIZE_ID exists in the SIZES table; if not, insert a new predefined row into SIZES with the new SIZE_ID and default values. If the SIZE_ID exists, check if a UNIT_ID of 1 exists in the MEASUREMENT_UNITS table; if not, insert a new predefined row into MEASUREMENT_UNITS with UNIT_ID 1 and default values. If both the SIZE_ID and UNIT_ID exist, delete any rows from the SIZE_CHARTS table where the MEASUREMENT_ID matches the new row's MEASUREMENT_ID.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_measurement_validation that runs before inserting or updating a row in the MEASUREMENTS table. It should check if the SIZE_ID from the new row exists in the SIZES table; if not, insert a standard auto-generated entry into SIZES with that SIZE_ID. Otherwise, check if a UNIT_ID of 1 exists in the MEASUREMENT_UNITS table; if not, insert a standard entry for centimeters into MEASUREMENT_UNITS. If both conditions are false, remove any entries from the SIZE_CHARTS table that match the new MEASUREMENT_ID.",
    "id": 68,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_measurement_validation that executes before any insert or update operation on the MEASUREMENTS table for each affected row, declaring three local NUMBER variables v_size_count, v_unit_count, and v_measurement_count, then performs three separate queries: first, it selects the count of records from the SIZES table where the SIZE_ID column equals the new SIZE_ID value from the triggering row, storing the result in v_size_count; second, it selects the count of records from the MEASUREMENT_UNITS table where the UNIT_ID column equals the constant value 1, storing the result in v_unit_count; third, it selects the count of records from the MEASUREMENTS table where the MEASUREMENT_ID column equals the new MEASUREMENT_ID value from the triggering row, storing the result in v_measurement_count, and then evaluates a conditional IF-ELSIF-ELSE block where if v_size_count equals 0, it inserts a new row into the SIZES table with columns SIZE_ID set to the new SIZE_ID, SIZE_NAME set to 'Auto-Generated', SIZE_CODE set to 'AUTO', DESCRIPTION set to 'Auto-generated size', CATEGORY_ID set to 1, TYPE_ID set to 1, IS_CUSTOM set to 1, and both CREATED_AT and UPDATED_AT set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function on CURRENT_TIMESTAMP, but if that condition is false and v_unit_count equals 0, it inserts a new row into the MEASUREMENT_UNITS table with columns UNIT_ID set to 1, UNIT_NAME set to 'Centimeter', and UNIT_SYMBOL set to 'cm', otherwise, if neither previous condition is true, it deletes all rows from the SIZE_CHARTS table where the MEASUREMENT_ID column equals the new MEASUREMENT_ID value from the triggering row.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_measurement_validation on the MEASUREMENTS table. For each row, declare NUMBER variables v_size_count, v_unit_count, and v_measurement_count. Query to count matching records in SIZES, MEASUREMENT_UNITS (where UNIT_ID=1), and MEASUREMENTS. If v_size_count is 0, insert a new predefined row into SIZES. Else, if v_unit_count is 0, insert a new predefined row into MEASUREMENT_UNITS. Otherwise, delete rows from SIZE_CHARTS where MEASUREMENT_ID matches the new row's MEASUREMENT_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the MEASUREMENTS table that runs before adding or changing a row. It should check some related tables. If there aren't any matching entries in the SIZES table, put a standard new entry there. If that's not the case, but there aren't any matching entries in the MEASUREMENT_UNITS table for a common unit, then put a standard new entry there instead. If neither of those conditions is true, then remove any related entries from the SIZE_CHARTS table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_cytoplasm_volume_check that is defined to fire automatically after each row is updated on the CYTOPLASM_METRICS table, and within its body, it checks a condition on the newly updated row's CYTOPLASM_VOLUME column value, specifically if this :NEW.CYTOPLASM_VOLUME value is greater than 1500, and if this condition evaluates to true, it performs an INSERT operation into the SAMPLES table, populating the SAMPLE_ID, NAME, SAMPLE_TYPE, and STAINING_PROTOCOL columns, where the value for the SAMPLE_ID column is derived from a scalar subquery that selects from the SAMPLES table the maximum existing SAMPLE_ID value, applies the NVL function to that result to convert a potential NULL to 0, and then adds 1 to this result, while the NAME column receives the literal string 'Large cytoplasm sample', the SAMPLE_TYPE column receives the literal string 'Tissue', and the STAINING_PROTOCOL column receives the literal string 'H&E'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_cytoplasm_volume_check\nAFTER UPDATE ON CYTOPLASM_METRICS\nFOR EACH ROW\nBEGIN\n    IF :NEW.CYTOPLASM_VOLUME > 1500 THEN\n        INSERT INTO SAMPLES (SAMPLE_ID, NAME, SAMPLE_TYPE, STAINING_PROTOCOL) VALUES ((SELECT NVL(MAX(SAMPLE_ID), 0) + 1 FROM SAMPLES), 'Large cytoplasm sample', 'Tissue', 'H&E');\n    END IF;\nEND;",
    "database_name": "biological_saa_metrics",
    "tables": [
      "SAMPLES",
      "CELL_METRICS",
      "CYTOPLASM_METRICS",
      "NUCLEUS_METRICS",
      "NUCLEUS_OD_METRICS"
    ],
    "call_sqls": [
      "UPDATE CYTOPLASM_METRICS SET CYTOPLASM_VOLUME = 1600 WHERE CYTOPLASM_ID = 1",
      "UPDATE CYTOPLASM_METRICS SET CYTOPLASM_VOLUME = 2000, CYTOPLASM_TEXTURE = 'Granular' WHERE CELL_ID = 1",
      "UPDATE CYTOPLASM_METRICS SET CYTOPLASM_VOLUME = CYTOPLASM_VOLUME + 600 WHERE CYTOPLASM_VOLUME > 1000",
      "UPDATE CYTOPLASM_METRICS SET CYTOPLASM_VOLUME = 1800 WHERE CYTOPLASM_ID = (SELECT MAX(CYTOPLASM_ID) FROM CYTOPLASM_METRICS)",
      "UPDATE CYTOPLASM_METRICS SET CYTOPLASM_VOLUME = 1550, CYTOPLASM_SHAPE = 'Irregular' WHERE CYTOPLASM_ID = 2"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_cytoplasm_volume_check that fires AFTER UPDATE on each row of the CYTOPLASM_METRICS table to insert a new row into the SAMPLES table whenever the updated CYTOPLASM_VOLUME exceeds 1500, setting the new SAMPLE_ID to the next available sequential number (starting at 1 if no records exist), NAME to 'Large cytoplasm sample', SAMPLE_TYPE to 'Tissue', and STAINING_PROTOCOL to 'H&E'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_cytoplasm_volume_check that activates AFTER each UPDATE on the CYTOPLASM_METRICS table, and if the updated CYTOPLASM_VOLUME exceeds 1500, it inserts a new record into the SAMPLES table with SAMPLE_ID set to the next available ID (starting at 1 if the table is empty), NAME as 'Large cytoplasm sample', SAMPLE_TYPE as 'Tissue', and STAINING_PROTOCOL as 'H&E'.",
    "id": 69,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_cytoplasm_volume_check that is defined to fire automatically after each row is updated on the CYTOPLASM_METRICS table, and within its body, it checks a condition on the newly updated row's CYTOPLASM_VOLUME column value, specifically if this :NEW.CYTOPLASM_VOLUME value is greater than 1500, and if this condition evaluates to true, it performs an INSERT operation into the SAMPLES table, populating the SAMPLE_ID, NAME, SAMPLE_TYPE, and STAINING_PROTOCOL columns, where the value for the SAMPLE_ID column is derived from a scalar subquery that selects from the SAMPLES table the maximum existing SAMPLE_ID value, applies the NVL function to that result to convert a potential NULL to 0, and then adds 1 to this result, while the NAME column receives the literal string 'Large cytoplasm sample', the SAMPLE_TYPE column receives the literal string 'Tissue', and the STAINING_PROTOCOL column receives the literal string 'H&E'.",
    "original_summary": "Create a trigger named `trg_cytoplasm_volume_check` that fires AFTER UPDATE on each row of the `CYTOPLASM_METRICS` table. If the new CYTOPLASM_VOLUME is greater than 1500, insert a new row into the SAMPLES table. The new SAMPLE_ID is the maximum existing ID plus one (or 1 if none exist). Set NAME to 'Large cytoplasm sample', SAMPLE_TYPE to 'Tissue', and STAINING_PROTOCOL to 'H&E'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a trigger, which should be named `trg_cytoplasm_volume_check`, that is designed to activate automatically AFTER an UPDATE operation is performed on any individual row within the `CYTOPLASM_METRICS` table. In the event that the newly updated CYTOPLASM_VOLUME value is found to exceed the substantial threshold of 1500, the trigger must then proceed to insert a fresh record into the SAMPLES table. For this new entry, the SAMPLE_ID must be carefully calculated by taking the maximum existing ID and incrementing it by one; however, if the table is currently empty, the ID should be simply set to 1. Furthermore, the NAME field should be populated with the descriptive label 'Large cytoplasm sample', the SAMPLE_TYPE should be explicitly designated as 'Tissue', and the STAINING_PROTOCOL must be definitively assigned the value 'H&E'."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_GAMES_BEFORE_INSERT_WIN` that is configured to execute automatically `BEFORE` an `INSERT` operation is performed on the `GAMES` table, and for `EACH ROW` being inserted. The trigger's logic begins by evaluating a conditional statement: it compares the value of the `TEAM_POINTS` column in the new row being inserted (referenced as `:NEW.TEAM_POINTS`, which is of a numeric data type) with the value of the `OPPONENT_POINTS` column in the same new row (referenced as `:NEW.OPPONENT_POINTS`, also of a numeric data type). If the value of `:NEW.TEAM_POINTS` is strictly greater than the value of `:NEW.OPPONENT_POINTS`, then the trigger proceeds to execute the statements within the `THEN` block. Inside this `THEN` block, it sets the value of the `WIN` column in the new row (referenced as `:NEW.WIN`, which is of a numeric data type, likely representing a boolean or flag) to the integer literal `1`. Concurrently, it sets the value of the `RESULT` column in the new row (referenced as `:NEW.RESULT`, which is of a character string data type) to the string literal `'WIN'`. If the initial condition (that `:NEW.TEAM_POINTS` is greater than `:NEW.OPPONENT_POINTS`) evaluates to `FALSE` or `NULL`, the trigger executes the statements within the `ELSE` block. Inside this `ELSE` block, it sets the value of the `WIN` column in the new row (`:NEW.WIN`) to the integer literal `0`. Simultaneously, it sets the value of the `RESULT` column in the new row (`:NEW.RESULT`) to the string literal `'LOSS'`. The trigger's execution concludes after one of these conditional branches has been processed, and these modified values for `WIN` and `RESULT` are then used for the actual `INSERT` operation into the `GAMES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_GAMES_BEFORE_INSERT_WIN\nBEFORE INSERT ON GAMES\nFOR EACH ROW\nBEGIN\n    IF :NEW.TEAM_POINTS > :NEW.OPPONENT_POINTS THEN\n        :NEW.WIN := 1;\n        :NEW.RESULT := 'WIN';\n    ELSE\n        :NEW.WIN := 0;\n        :NEW.RESULT := 'LOSS';\n    END IF;\nEND;",
    "database_name": "sports_tpa_analytics",
    "tables": [
      "GAMES",
      "OPPONENTS"
    ],
    "call_sqls": [
      "INSERT INTO GAMES (GAME_ID, TEAM_POINTS, OPPONENT_POINTS) VALUES (1, 100, 90)",
      "INSERT INTO GAMES (GAME_ID, TEAM_POINTS, OPPONENT_POINTS) VALUES (2, 85, 95)",
      "INSERT INTO GAMES (GAME_ID, TEAM_POINTS, OPPONENT_POINTS) VALUES (3, 110, 100)",
      "INSERT INTO GAMES (GAME_ID, TEAM_POINTS, OPPONENT_POINTS) VALUES (4, 70, 70)",
      "INSERT INTO GAMES (GAME_ID, TEAM_POINTS, OPPONENT_POINTS) VALUES (5, 120, 125)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_GAMES_BEFORE_INSERT_WIN that fires before inserting a row into the GAMES table, setting the WIN and RESULT columns based on the TEAM_POINTS and OPPONENT_POINTS values: if TEAM_POINTS is greater than OPPONENT_POINTS, assign WIN as 1 and RESULT as 'WIN'; otherwise, assign WIN as 0 and RESULT as 'LOSS'.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_GAMES_BEFORE_INSERT_WIN that runs before inserting new records into the GAMES table. For each new game entry, if the TEAM_POINTS are greater than the OPPONENT_POINTS, set WIN to 1 and RESULT to 'WIN'; otherwise, set WIN to 0 and RESULT to 'LOSS'.",
    "id": 70,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_GAMES_BEFORE_INSERT_WIN` that is configured to execute automatically `BEFORE` an `INSERT` operation is performed on the `GAMES` table, and for `EACH ROW` being inserted. The trigger's logic begins by evaluating a conditional statement: it compares the value of the `TEAM_POINTS` column in the new row being inserted (referenced as `:NEW.TEAM_POINTS`, which is of a numeric data type) with the value of the `OPPONENT_POINTS` column in the same new row (referenced as `:NEW.OPPONENT_POINTS`, also of a numeric data type). If the value of `:NEW.TEAM_POINTS` is strictly greater than the value of `:NEW.OPPONENT_POINTS`, then the trigger proceeds to execute the statements within the `THEN` block. Inside this `THEN` block, it sets the value of the `WIN` column in the new row (referenced as `:NEW.WIN`, which is of a numeric data type, likely representing a boolean or flag) to the integer literal `1`. Concurrently, it sets the value of the `RESULT` column in the new row (referenced as `:NEW.RESULT`, which is of a character string data type) to the string literal `'WIN'`. If the initial condition (that `:NEW.TEAM_POINTS` is greater than `:NEW.OPPONENT_POINTS`) evaluates to `FALSE` or `NULL`, the trigger executes the statements within the `ELSE` block. Inside this `ELSE` block, it sets the value of the `WIN` column in the new row (`:NEW.WIN`) to the integer literal `0`. Simultaneously, it sets the value of the `RESULT` column in the new row (`:NEW.RESULT`) to the string literal `'LOSS'`. The trigger's execution concludes after one of these conditional branches has been processed, and these modified values for `WIN` and `RESULT` are then used for the actual `INSERT` operation into the `GAMES` table.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named TRG_GAMES_BEFORE_INSERT_WIN on the GAMES table. For each new row, if TEAM_POINTS is greater than OPPONENT_POINTS, set WIN to 1 and RESULT to 'WIN'. Otherwise, set WIN to 0 and RESULT to 'LOSS'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the GAMES table that runs before adding new entries. When a new game record is inserted, if the team's score looks better than the opponent's, mark it as a win. Otherwise, just treat it as a loss. Name the trigger something like TRG_GAMES_BEFORE_INSERT_WIN."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_player_stats_validation that is executed before an insert operation on the PLAYER_STATS table for each row being inserted. The trigger declares a local variable v_player_count of type NUMBER to store the count of players. It performs a SELECT statement to count the number of rows in the PLAYERS table where the PLAYER_ID column matches the PLAYER_ID value of the new row being inserted into the PLAYER_STATS table, using the :NEW bind variable to reference the new row's PLAYER_ID. The result of this count is stored in the v_player_count variable. The trigger then evaluates a conditional statement: if the value of v_player_count is equal to zero, indicating that there is no existing player with the specified PLAYER_ID in the PLAYERS table, it sets the PLAYER_ID of the new row in the PLAYER_STATS table to NULL, effectively preventing the insertion of a row with a non-existent PLAYER_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_player_stats_validation\nBEFORE INSERT ON PLAYER_STATS\nFOR EACH ROW\nDECLARE\n    v_player_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_player_count FROM PLAYERS WHERE PLAYER_ID = :NEW.PLAYER_ID;\n    IF v_player_count = 0 THEN\n        :NEW.PLAYER_ID := NULL;\n    END IF;\nEND;",
    "database_name": "sports_daa_visualization",
    "tables": [
      "PLAYERS",
      "PLAYER_GAMES",
      "PLAYER_STATS"
    ],
    "call_sqls": [
      "INSERT INTO PLAYER_STATS (STAT_ID, GAME_ID, PLAYER_ID, MINUTES, POSITION, PASSES) VALUES (100, 0, 999, 90, 'CB', 50)",
      "INSERT INTO PLAYER_STATS (STAT_ID, GAME_ID, PLAYER_ID, MINUTES, POSITION, GOALS) VALUES (101, 1, 0, 85, 'ST', 2)",
      "INSERT INTO PLAYER_STATS (STAT_ID, GAME_ID, PLAYER_ID, MINUTES, ASSISTS, TACKLES) VALUES (102, 2, 1, 90, 1, 3)",
      "INSERT INTO PLAYER_STATS (STAT_ID, GAME_ID, PLAYER_ID, MINUTES, PERFORMANCE_RATING) VALUES (103, 3, 2, 45, 6.5)",
      "INSERT INTO PLAYER_STATS (STAT_ID, GAME_ID, PLAYER_ID, MINUTES, SHOTS, FOULS) VALUES (104, 4, 3, 67, 4, 1)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_player_stats_validation that fires BEFORE INSERT on each row of the PLAYER_STATS table, checks whether the new PLAYER_ID value exists in the PLAYERS table, and if it does not exist, sets the new PLAYER_ID to NULL.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_player_stats_validation that, before inserting a row into the PLAYER_STATS table, validates the new PLAYER_ID by ensuring it exists in the PLAYERS table and sets it to NULL if it does not.",
    "id": 71,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_player_stats_validation that fires before each insert operation on the PLAYER_STATS table, declaring a local variable v_exists of type NUMBER, then executes a SELECT COUNT(*) statement against the PLAYERS table to count rows where the PLAYER_ID column equals the new PLAYER_ID value (referenced as :NEW.PLAYER_ID), storing this count in v_exists, then conditionally updates the new PLAYER_ID column to NULL by setting :NEW.PLAYER_ID to NULL if v_exists equals 0, thereby validating the new PLAYER_ID by ensuring it exists in the PLAYERS table and setting it to NULL if it does not.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_player_stats_validation on the PLAYER_STATS table. It must check if the new PLAYER_ID exists in the PLAYERS table. If not, set the new PLAYER_ID to NULL.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a BEFORE INSERT row-level trigger called trg_player_stats_validation for the PLAYER_STATS table that validates the new PLAYER_ID by checking if it exists in the PLAYERS table and sets it to NULL if it does not?"
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_author_affiliation` that is designed to execute automatically before an `UPDATE` operation is performed on any row within the `AUTHORS` table. This trigger operates at the row level, meaning its logic is applied individually to each row that is being updated. The trigger's execution flow involves two distinct operations. First, it checks the value of the `AFFILIATION` column for the row currently being updated. Specifically, it evaluates if the new value proposed for the `AFFILIATION` column (referenced as `:NEW.AFFILIATION`) is `NULL`. If this condition is met, indicating that the `AFFILIATION` is not provided or is explicitly set to `NULL`, the trigger then assigns the string literal `'Unknown'` to the `AFFILIATION` column of the row being updated (`:NEW.AFFILIATION`), thereby ensuring that the `AFFILIATION` column always contains a non-`NULL` value. Second, regardless of the `AFFILIATION` column's value, the trigger updates the `UPDATED_AT` column for the row being updated. It assigns a formatted string representation of the current system date and time to the `UPDATED_AT` column (`:NEW.UPDATED_AT`). This formatting is achieved by calling the `TO_CHAR` function with `SYSDATE` as the input, and the format model `'YYYY-MM-DD HH24:MI:SS'`, which converts the `SYSDATE` (representing the current date and time) into a string in the format 'Year-Month-Day Hour:Minute:Second' (e.g., '2023-10-27 14:35:01').",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_author_affiliation\nBEFORE UPDATE ON AUTHORS\nFOR EACH ROW\nBEGIN\n    -- Ensure AFFILIATION is not NULL\n    IF :NEW.AFFILIATION IS NULL THEN\n        :NEW.AFFILIATION := 'Unknown';\n    END IF;\n    \n    -- Update the UPDATED_AT timestamp\n    :NEW.UPDATED_AT := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');\nEND;",
    "database_name": "academic_rpmac_tracking",
    "tables": [
      "AUTHORS",
      "CITATIONS",
      "CITATION_METRICS",
      "PUBLICATIONS"
    ],
    "call_sqls": [
      "UPDATE AUTHORS SET AFFILIATION = 'University of California, Berkeley' WHERE AUTHOR_ID = 0",
      "UPDATE AUTHORS SET EMAIL = 'new.email@example.com' WHERE AUTHOR_ID = 1",
      "UPDATE AUTHORS SET AFFILIATION = NULL WHERE AUTHOR_ID = 0",
      "UPDATE AUTHORS SET H_INDEX = 25 WHERE AUTHOR_ID = 1",
      "UPDATE AUTHORS SET RESEARCH_INTERESTS = 'Machine Learning, AI' WHERE AUTHOR_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_author_affiliation that fires before each row is updated in the AUTHORS table, ensuring that if the new AFFILIATION value is NULL, it is set to 'Unknown', and always updates the UPDATED_AT column to the current system timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_author_affiliation that fires before each row update on the AUTHORS table, ensuring that if the new AFFILIATION value is NULL, it is set to 'Unknown', and always updating the UPDATED_AT column to the current system timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "id": 72,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_update_author_affiliation` that is configured to execute `BEFORE` any `UPDATE` operation is performed on the `AUTHORS` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is being updated in the `AUTHORS` table. The trigger's primary purpose is to enforce data integrity and maintain an audit trail by modifying column values in the row before the update is finalized.\n\nInside the trigger's `BEGIN...END` block, the logic is executed unconditionally for every row update. The trigger performs two distinct operations sequentially.\n\nFirst, a conditional statement (`IF...THEN...END IF`) is used to evaluate the value of the `AFFILIATION` column in the new data for the row, referenced as `:NEW.AFFILIATION`. The condition checks if `:NEW.AFFILIATION` is `NULL`. If this condition evaluates to `TRUE`, meaning the new `AFFILIATION` value is null, then the trigger modifies the `:NEW.AFFILIATION` value by assigning it the string literal `'Unknown'`. This assignment ensures that a null affiliation is never persisted, replacing it with a default value. If the condition is `FALSE`, meaning `:NEW.AFFILIATION` already contains a non-null value, this assignment step is skipped, and the original value remains unchanged.\n\nSecond, regardless of the outcome of the first conditional check, the trigger proceeds to update the `UPDATED_AT` column for the row. It modifies the `:NEW.UPDATED_AT` value by assigning it the current system timestamp. This timestamp is obtained using the `SYSTIMESTAMP` function and is immediately formatted into a specific string representation. The formatting is done using the `TO_CHAR` function with the format model `'YYYY-MM-DD HH24:MI:SS'`, which produces a timestamp string showing the year, month, day, hour (in 24-hour format), minute, and second. This action ensures the `UPDATED_AT` column always reflects the exact moment the row was last updated.\n\nThe trigger operates on the `AUTHORS` table within the `academic_rpmac_tracking` database. No other tables are referenced, and no SQL `SELECT`, `INSERT`, or `DELETE` operations are performed. The trigger's logic consists solely of in-row value assignments based on conditions and system functions, and it does not return a value but directly modifies the `:NEW` record values for the `AFFILIATION` and `UPDATED_AT` columns before the database commits the update.",
    "original_summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_update_author_affiliation on the AUTHORS table. For each row being updated, if the new AFFILIATION value is NULL, set it to 'Unknown'. Then, always update the UPDATED_AT column to the current system timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a BEFORE UPDATE FOR EACH ROW trigger, which you should name trg_update_author_affiliation, to be placed on the AUTHORS table. For every individual row that is undergoing an update, you must first check if the new value for the AFFILIATION column is NULL; if this condition is met, you should thoughtfully assign it the default value of 'Unknown'. Subsequently, without fail, you must also ensure the UPDATED_AT column is meticulously updated to reflect the precise current system timestamp, carefully formatted in the classic 'YYYY-MM-DD HH24:MI:SS' pattern."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named calculate_fantasy_points that is defined to fire automatically before any row is inserted into the PLAYER_STATISTICS table, and for each new row being inserted, it calculates a value for the FANTASY_POINTS column by performing a specific arithmetic operation: it takes the value from the new row's PTS column, adds to it the product of the new row's ASSISTS column value multiplied by 1.5, and further adds the product of the new row's FIELD_GOAL_PERCENTAGE column value multiplied by 100, then assigns the final result of this calculation directly into the :NEW.FANTASY_POINTS pseudo-record column for the row being inserted.",
    "plsql": "CREATE OR REPLACE TRIGGER calculate_fantasy_points\nBEFORE INSERT ON PLAYER_STATISTICS\nFOR EACH ROW\nBEGIN\n    -- Assuming a more standard linear calculation for fantasy points\n    -- Removed DEGREES function as it's not appropriate for fantasy point calculation\n    -- FIELD_GOAL_PERCENTAGE is typically a decimal, multiplying by 100 to give it a reasonable weight\n    :NEW.FANTASY_POINTS := :NEW.PTS + (:NEW.ASSISTS * 1.5) + (:NEW.FIELD_GOAL_PERCENTAGE * 100);\nEND;",
    "database_name": "basketball_gsap_tracking",
    "tables": [
      "GAMES",
      "PLAYERS",
      "PLAYER_STATISTICS"
    ],
    "call_sqls": [
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, ASSISTS, FIELD_GOAL_PERCENTAGE) VALUES (1000, 0, 1, 25, 8, 0.550)",
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, ASSISTS, FIELD_GOAL_PERCENTAGE) VALUES (1001, 1, 0, 18, 12, 0.480)",
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, ASSISTS, FIELD_GOAL_PERCENTAGE) VALUES (1002, 0, 0, 32, 5, 0.620)",
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, ASSISTS, FIELD_GOAL_PERCENTAGE) VALUES (1003, 1, 1, 12, 15, 0.390)",
      "INSERT INTO PLAYER_STATISTICS (STAT_ID, GAME_ID, PLAYER_ID, PTS, ASSISTS, FIELD_GOAL_PERCENTAGE, DRB, ORB) VALUES (1004, 0, 2, 22, 7, 0.510, 5, 3)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named calculate_fantasy_points that fires BEFORE INSERT on the PLAYER_STATISTICS table, and for each new row, calculates the FANTASY_POINTS column by adding the PTS value, 1.5 times the ASSISTS value, and 100 times the FIELD_GOAL_PERCENTAGE value, then assigns the result to the new row's FANTASY_POINTS.",
    "natural_language": "Write a Oracle PL/SQL trigger called calculate_fantasy_points that, before inserting a new row into the PLAYER_STATISTICS table, calculates the FANTASY_POINTS value for that row by adding the PTS value, plus the ASSISTS value multiplied by 1.5, plus the FIELD_GOAL_PERCENTAGE value multiplied by 100, and then assigns the result to the FANTASY_POINTS column for the new row.",
    "id": 73,
    "generated_ir": "Write an Oracle PL/SQL trigger named calculate_fantasy_points that is defined to fire automatically before any row is inserted into the PLAYER_STATISTICS table, and for each new row being inserted, it calculates a value for the FANTASY_POINTS column by performing a specific arithmetic operation: it takes the value from the new row's PTS column, adds to it the product of the new row's ASSISTS column value multiplied by 1.5, and further adds the product of the new row's FIELD_GOAL_PERCENTAGE column value multiplied by 100, then assigns the final result of this calculation directly into the :NEW.FANTASY_POINTS pseudo-record column for the row being inserted.",
    "original_summary": "Create a BEFORE INSERT trigger named calculate_fantasy_points on the PLAYER_STATISTICS table. For each new row, calculate the FANTASY_POINTS column as: PTS + (ASSISTS * 1.5) + (FIELD_GOAL_PERCENTAGE * 100). Assign the result to :NEW.FANTASY_POINTS.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a BEFORE INSERT trigger called calculate_fantasy_points for the PLAYER_STATISTICS table that computes the FANTASY_POINTS column for each new row using the formula PTS plus (ASSISTS multiplied by 1.5) plus (FIELD_GOAL_PERCENTAGE multiplied by 100), and then assigns the result to :NEW.FANTASY_POINTS?"
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_before_health_data_insert` on the `HEALTH_DATA` table. This trigger executes automatically for each row *before* an `INSERT` operation is performed on the `HEALTH_DATA` table. The trigger first declares two local PL/SQL variables: `v_state_population` of type `NUMBER` and `v_avg_confirmed` of type `NUMBER`. Upon execution, the trigger performs the following sequence of operations:\n\n1.  It executes a `SELECT` statement to retrieve the `POPULATION` value from the `STATES` table. This retrieved value is then stored into the local variable `v_state_population`. The selection is conditioned by matching the `STATE_ID` column in the `STATES` table with the `STATE_ID` value of the row currently being inserted into `HEALTH_DATA` (referenced as `:NEW.STATE_ID`).\n\n2.  Subsequently, it executes another `SELECT` statement to calculate the average of the `TOTAL_CONFIRMED` column from the `HEALTH_DATA` table. This calculated average is then stored into the local variable `v_avg_confirmed`. The average is computed only for rows in `HEALTH_DATA` where the `STATE_ID` column matches the `STATE_ID` value of the row currently being inserted (referenced as `:NEW.STATE_ID`).\n\n3.  It then modifies the `VACCINATION_RATE` column of the new row being inserted (`:NEW.VACCINATION_RATE`). The existing string value of `:NEW.VACCINATION_RATE` is first converted to a number using `TO_NUMBER()`, then multiplied by `1.1`, and finally converted back to a character string using `TO_CHAR()`.\n\n4.  Following this, it modifies the `TEST_POSITIVITY_RATE` column of the new row being inserted (`:NEW.TEST_POSITIVITY_RATE`). The existing string value of `:NEW.TEST_POSITIVITY_RATE` is first converted to a number using `TO_NUMBER()`, then multiplied by the result of dividing `v_state_population` by `1000000`, and finally converted back to a character string using `TO_CHAR()`.\n\n5.  Next, it modifies the `SOURCE` column of the new row being inserted (`:NEW.SOURCE`). The operation involves taking a substring of the existing `SOURCE` value, specifically from the first character up to two characters before its end (`SUBSTR(:NEW.SOURCE, 1, LENGTH(:NEW.SOURCE) - 2)`), and then concatenating this substring with the literal string `'_VAL'`.\n\n6.  Finally, it updates the `LAST_UPDATED` column of the new row being inserted (`:NEW.LAST_UPDATED`). The current system date and time are retrieved using `SYSDATE` and then formatted into a character string in `YYYY-MM-DD HH24:MI:SS` format using `TO_CHAR()`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_before_health_data_insert\nBEFORE INSERT ON HEALTH_DATA\nFOR EACH ROW\nDECLARE\n    v_state_population NUMBER;\n    v_avg_confirmed NUMBER;\nBEGIN\n    SELECT POPULATION INTO v_state_population\n    FROM STATES\n    WHERE STATE_ID = :NEW.STATE_ID;\n\n    SELECT AVG(TOTAL_CONFIRMED) INTO v_avg_confirmed\n    FROM HEALTH_DATA\n    WHERE STATE_ID = :NEW.STATE_ID;\n\n    :NEW.VACCINATION_RATE := TO_CHAR(TO_NUMBER(:NEW.VACCINATION_RATE) * 1.1);\n    :NEW.TEST_POSITIVITY_RATE := TO_CHAR(TO_NUMBER(:NEW.TEST_POSITIVITY_RATE) * (v_state_population / 1000000));\n    :NEW.SOURCE := SUBSTR(:NEW.SOURCE, 1, LENGTH(:NEW.SOURCE) - 2) || '_VAL';\n    :NEW.LAST_UPDATED := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');\nEND;",
    "database_name": "public_hdma_tracking",
    "tables": [
      "ACCESS_LOGS",
      "HEALTH_DATA",
      "REPORTING",
      "ROLES",
      "STATES",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO HEALTH_DATA (DATA_ID, DATE_RECORDED, STATE_ID, TOTAL_CONFIRMED, CURED_DISCHARGED, DEATHS, VACCINATION_RATE, TEST_POSITIVITY_RATE, ACTIVE_CASES, HOSPITALIZATIONS, ICU_BEDS_OCCUPIED, VENTILATORS_OCCUPIED, SOURCE, LAST_UPDATED) VALUES (100, '2023-10-26', 0, 500, 450, 10, '0.7', '0.08', 40, 15, 3, 1, 'Hospital A_OLD', '2023-10-25 10:00:00')",
      "INSERT INTO HEALTH_DATA (DATA_ID, DATE_RECORDED, STATE_ID, TOTAL_CONFIRMED, CURED_DISCHARGED, DEATHS, VACCINATION_RATE, TEST_POSITIVITY_RATE, ACTIVE_CASES, HOSPITALIZATIONS, ICU_BEDS_OCCUPIED, VENTILATORS_OCCUPIED, SOURCE, LAST_UPDATED) VALUES (101, '2023-10-26', 1, 1500, 1300, 50, '0.65', '0.12', 150, 30, 8, 2, 'Testing Center B_OLD', '2023-10-25 11:00:00')",
      "INSERT INTO HEALTH_DATA (DATA_ID, DATE_RECORDED, STATE_ID, TOTAL_CONFIRMED, CURED_DISCHARGED, DEATHS, VACCINATION_RATE, TEST_POSITIVITY_RATE, ACTIVE_CASES, HOSPITALIZATIONS, ICU_BEDS_OCCUPIED, VENTILATORS_OCCUPIED, SOURCE, LAST_UPDATED) VALUES (102, '2023-10-27', 0, 550, 480, 11, '0.72', '0.09', 59, 18, 4, 1, 'Clinic C_OLD', '2023-10-26 09:00:00')",
      "INSERT INTO HEALTH_DATA (DATA_ID, DATE_RECORDED, STATE_ID, TOTAL_CONFIRMED, CURED_DISCHARGED, DEATHS, VACCINATION_RATE, TEST_POSITIVITY_RATE, ACTIVE_CASES, HOSPITALIZATIONS, ICU_BEDS_OCCUPIED, VENTILATORS_OCCUPIED, SOURCE, LAST_UPDATED) VALUES (103, '2023-10-27', 1, 1600, 1350, 55, '0.68', '0.11', 195, 35, 9, 3, 'Health Dept D_OLD', '2023-10-26 10:00:00')",
      "INSERT INTO HEALTH_DATA (DATA_ID, DATE_RECORDED, STATE_ID, TOTAL_CONFIRMED, CURED_DISCHARGED, DEATHS, VACCINATION_RATE, TEST_POSITIVITY_RATE, ACTIVE_CASES, HOSPITALIZATIONS, ICU_BEDS_OCCUPIED, VENTILATORS_OCCUPIED, SOURCE, LAST_UPDATED) VALUES (104, '2023-10-28', 0, 600, 500, 12, '0.75', '0.10', 88, 20, 5, 2, 'Private Lab E_OLD', '2023-10-27 08:00:00')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_before_health_data_insert that fires BEFORE INSERT on each row of the HEALTH_DATA table. For each new row, retrieve the population from the STATES table based on the new STATE_ID and calculate the average TOTAL_CONFIRMED from existing HEALTH_DATA rows for that STATE_ID. Then adjust the new row's values: increase VACCINATION_RATE by 10%, adjust TEST_POSITIVITY_RATE by multiplying it by the state population divided by 1,000,000, append '_VAL' to the end of SOURCE, and set LAST_UPDATED to the current timestamp.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_before_health_data_insert that fires before inserting a new row into the HEALTH_DATA table, and for each new row, it should retrieve the population from the STATES table for the same STATE_ID and calculate the average TOTAL_CONFIRMED from existing HEALTH_DATA rows for that STATE_ID, then adjust the new row by increasing the VACCINATION_RATE by 10%, modifying the TEST_POSITIVITY_RATE based on the population, appending '_VAL' to the SOURCE, and setting the LAST_UPDATED to the current timestamp.",
    "id": 74,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_before_health_data_insert` that is configured to execute automatically `BEFORE` any `INSERT` operation is performed on any row within the database table named `HEALTH_DATA`. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual new row that is about to be inserted into the `HEALTH_DATA` table.\n\nThe trigger performs a series of operations to compute and set values for specific columns of the new row, which is referenced using the `:NEW` pseudorecord. The operations are as follows:\n\nFirst, it retrieves the `POPULATION` value from the `STATES` table. It executes a `SELECT` statement that queries the `STATES` table for the `POPULATION` column where the `STATE_ID` in the `STATES` table matches the `STATE_ID` value from the `:NEW` pseudorecord of the row being inserted into `HEALTH_DATA`. The retrieved `POPULATION` value is stored into a local PL/SQL variable.\n\nSecond, it calculates the average `TOTAL_CONFIRMED` value from existing rows in the `HEALTH_DATA` table. It executes a `SELECT` statement with the `AVG` aggregate function on the `TOTAL_CONFIRMED` column, selecting from the `HEALTH_DATA` table where the `STATE_ID` matches the `STATE_ID` value from the `:NEW` pseudorecord. The result of this average calculation is stored into another local PL/SQL variable.\n\nThird, it adjusts the new row's `VACCINATION_RATE` column by increasing its existing value by 10%. This is done by taking the `:NEW.VACCINATION_RATE` value, multiplying it by 1.10, and assigning the result back to `:NEW.VACCINATION_RATE`.\n\nFourth, it modifies the new row's `TEST_POSITIVITY_RATE` column based on the retrieved `POPULATION` value. The exact calculation is not specified in the natural language, but the operation involves using the `POPULATION` variable to compute a new value, which is then assigned to `:NEW.TEST_POSITIVITY_RATE`.\n\nFifth, it appends the string literal '_VAL' to the end of the new row's `SOURCE` column value. This is done by taking the existing `:NEW.SOURCE` string and concatenating '_VAL' to it, then assigning the concatenated result back to `:NEW.SOURCE`.\n\nFinally, it sets the new row's `LAST_UPDATED` column to the current system date and time by assigning the `SYSDATE` function's return value to `:NEW.LAST_UPDATED`.\n\nAll these operations are performed sequentially within the trigger's execution block, ensuring that the new row's data is adjusted before it is physically inserted into the `HEALTH_DATA` table.",
    "original_summary": "Create a BEFORE INSERT row-level trigger on the HEALTH_DATA table. Before inserting a row, retrieve the state's population and the average confirmed cases for that state. Modify the new row's VACCINATION_RATE (increase by 10%), TEST_POSITIVITY_RATE (adjust by population), SOURCE (append '_VAL'), and LAST_UPDATED (set to current timestamp).",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need to set up a trigger that fires off before any new row gets slotted into the HEALTH_DATA table. When it's about to insert, the trigger should grab the state's population and the average confirmed cases for that same state. Then, it's gotta tweak the new row: bump up the VACCINATION_RATE by like 10%, adjust the TEST_POSITIVITY_RATE based on the population, tack on '_VAL' to the end of the SOURCE, and set the LAST_UPDATED to right now's timestamp."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_calc_avg_reaction_time that is defined to fire automatically after each new row is inserted into the REACTION_TIMES table, and within its execution block, it first declares a local variable v_avg_time of type NUMBER, then performs a SELECT statement to calculate the average value of the REACTION_TIME column from all rows in the REACTION_TIMES table and stores that result into the v_avg_time variable, and subsequently executes an INSERT statement into the EXPERIMENT_OUTCOMES table, where the values for the columns OUTCOME_ID, EXPERIMENT_ID, PARTICIPANT_ID, OUTCOME, OUTCOME_DATE, OUTCOME_NOTES, and OUTCOME_SCORE are populated by a subquery that selects from the EXPERIMENTS table, specifically generating the OUTCOME_ID by using a scalar subquery on the EXPERIMENT_OUTCOMES table to find the current maximum OUTCOME_ID value, applying the NVL function to handle nulls by returning 0 if the maximum is null, and then adding 1 to that result, taking the EXPERIMENT_ID directly from the EXPERIMENTS table alias e, setting PARTICIPANT_ID to NULL, setting the OUTCOME to the literal string 'Avg Reaction Time Calculated', setting OUTCOME_DATE to the current date using the CURRENT_DATE function, setting OUTCOME_NOTES to a concatenated string starting with 'Average reaction time: ' and appended with the value of the v_avg_time variable using the concatenation operator ||, and setting OUTCOME_SCORE to the value of the v_avg_time variable, and this insert operation is performed for every row from the EXPERIMENTS table where the STATUS column has the exact string value 'In Progress'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_calc_avg_reaction_time\nAFTER INSERT ON REACTION_TIMES\nDECLARE\n    v_avg_time NUMBER;\nBEGIN\n    SELECT AVG(REACTION_TIME) INTO v_avg_time FROM REACTION_TIMES;\n    INSERT INTO EXPERIMENT_OUTCOMES (OUTCOME_ID, EXPERIMENT_ID, PARTICIPANT_ID, OUTCOME, OUTCOME_DATE, OUTCOME_NOTES, OUTCOME_SCORE)\n    SELECT (SELECT NVL(MAX(OUTCOME_ID), 0) + 1 FROM EXPERIMENT_OUTCOMES),\n           e.EXPERIMENT_ID,\n           NULL,\n           'Avg Reaction Time Calculated',\n           CURRENT_DATE,\n           'Average reaction time: ' || v_avg_time,\n           v_avg_time\n    FROM EXPERIMENTS e\n    WHERE e.STATUS = 'In Progress';\nEND;",
    "database_name": "cognitive_paned_247164",
    "tables": [
      "EXPERIMENTS",
      "PARTICIPANTS",
      "BRAIN_ACTIVITY",
      "EXPERIMENT_OUTCOMES",
      "REACTION_TIMES",
      "STIMULI"
    ],
    "call_sqls": [
      "INSERT INTO REACTION_TIMES (REACTION_TIME_ID, EXPERIMENT_ID, PARTICIPANT_ID, REACTION_TIME, TRIAL_NUMBER, CONDITION, SESSION_ID) VALUES (2, 1, 1, 1200, 2, 'Condition A', 'Session2')",
      "INSERT INTO REACTION_TIMES (REACTION_TIME_ID, EXPERIMENT_ID, PARTICIPANT_ID, REACTION_TIME, TRIAL_NUMBER, CONDITION, SESSION_ID) VALUES (3, 1, 2, 800, 3, 'Condition B', 'Session3')",
      "INSERT INTO REACTION_TIMES (REACTION_TIME_ID, EXPERIMENT_ID, PARTICIPANT_ID, REACTION_TIME, TRIAL_NUMBER, CONDITION, SESSION_ID) VALUES (4, 0, 1, 950, 4, 'Condition A', 'Session4')",
      "INSERT INTO REACTION_TIMES (REACTION_TIME_ID, EXPERIMENT_ID, PARTICIPANT_ID, REACTION_TIME, TRIAL_NUMBER, CONDITION, SESSION_ID) VALUES (5, 0, 2, 1100, 5, 'Condition B', 'Session5')",
      "INSERT INTO REACTION_TIMES (REACTION_TIME_ID, EXPERIMENT_ID, PARTICIPANT_ID, REACTION_TIME, TRIAL_NUMBER, CONDITION, SESSION_ID) VALUES (6, 1, 1, 1050, 6, 'Condition A', 'Session6')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_calc_avg_reaction_time that fires AFTER INSERT on the REACTION_TIMES table to calculate the average REACTION_TIME from the REACTION_TIMES table, then for each experiment in the EXPERIMENTS table with STATUS 'In Progress', insert a record into EXPERIMENT_OUTCOMES with OUTCOME_ID set to the maximum existing OUTCOME_ID plus one (starting from 0 if none exist), EXPERIMENT_ID from the experiment, PARTICIPANT_ID as NULL, OUTCOME as 'Avg Reaction Time Calculated', OUTCOME_DATE as the current date, OUTCOME_NOTES as 'Average reaction time: ' followed by the calculated average, and OUTCOME_SCORE as the average value.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_calc_avg_reaction_time that fires after new entries are inserted into the REACTION_TIMES table. It should compute the average REACTION_TIME from the REACTION_TIMES table, then for all experiments in the EXPERIMENTS table with STATUS 'In Progress', insert a new record into the EXPERIMENT_OUTCOMES table. The new record's OUTCOME_ID should be the next sequential number (starting from 1 if none exist), include the EXPERIMENT_ID, leave PARTICIPANT_ID blank, set OUTCOME to 'Avg Reaction Time Calculated', use today's date for OUTCOME_DATE, add a note in OUTCOME_NOTES stating the average reaction time, and place the average value in OUTCOME_SCORE.",
    "id": 75,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_calc_avg_reaction_time that is defined to fire automatically after each new row is inserted into the REACTION_TIMES table, and within its execution block, it first declares a local variable v_avg_time of type NUMBER, then performs a SELECT statement to calculate the average value of the REACTION_TIME column from all rows in the REACTION_TIMES table and stores that result into the v_avg_time variable, and subsequently executes an INSERT statement into the EXPERIMENT_OUTCOMES table, where the values for the columns OUTCOME_ID, EXPERIMENT_ID, PARTICIPANT_ID, OUTCOME, OUTCOME_DATE, OUTCOME_NOTES, and OUTCOME_SCORE are populated by a subquery that selects from the EXPERIMENTS table, specifically generating the OUTCOME_ID by using a scalar subquery on the EXPERIMENT_OUTCOMES table to find the current maximum OUTCOME_ID value, applying the NVL function to handle nulls by returning 0 if the maximum is null, and then adding 1 to that result, taking the EXPERIMENT_ID directly from the EXPERIMENTS table alias e, setting PARTICIPANT_ID to NULL, setting the OUTCOME to the literal string 'Avg Reaction Time Calculated', setting OUTCOME_DATE to the current date using the CURRENT_DATE function, setting OUTCOME_NOTES to a concatenated string starting with 'Average reaction time: ' and appended with the value of the v_avg_time variable using the concatenation operator ||, and setting OUTCOME_SCORE to the value of the v_avg_time variable, and this insert operation is performed for every row from the EXPERIMENTS table where the STATUS column has the exact string value 'In Progress'.",
    "original_summary": "Create an AFTER INSERT statement-level trigger named trg_calc_avg_reaction_time on the REACTION_TIMES table. It must calculate the average REACTION_TIME from the REACTION_TIMES table. Then, for each 'In Progress' experiment in the EXPERIMENTS table, insert a row into EXPERIMENT_OUTCOMES. The OUTCOME_ID is the maximum existing OUTCOME_ID plus 1 (defaulting to 0 if null). Set EXPERIMENT_ID from the experiment, PARTICIPANT_ID to NULL, OUTCOME to 'Avg Reaction Time Calculated', OUTCOME_DATE to CURRENT_DATE, OUTCOME_NOTES to 'Average reaction time: ' concatenated with the average value, and OUTCOME_SCORE to the average value.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the REACTION_TIMES table for after new entries are added. It should figure out a typical or average reaction time from the data. Then, for experiments that are currently active or in a running state, add a new record to the experiment results. The new record's ID should be one more than the last one used, or start from scratch if there aren't any. Fill in the experiment's ID, leave the participant blank, mark the outcome as something about the average time being done, use today's date, add a note that mentions the general average time figure, and put that average figure in the score field."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_health_data that is defined to fire automatically after any row in the HEALTH_DATA table is updated, and for each individual row that is updated, the trigger executes a single UPDATE statement targeting the STATES table, specifically modifying the POPULATION column by adding the difference between the new ACTIVE_CASES value from the updated HEALTH_DATA row (referenced as :NEW.ACTIVE_CASES) and the old ACTIVE_CASES value from before the update (referenced as :OLD.ACTIVE_CASES) to the existing POPULATION value, and this update is applied only to the row in the STATES table where the STATE_ID column matches the new STATE_ID value (referenced as :NEW.STATE_ID) from the updated HEALTH_DATA row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_health_data\nAFTER UPDATE ON HEALTH_DATA\nFOR EACH ROW\nBEGIN\n    UPDATE STATES SET POPULATION = POPULATION + :NEW.ACTIVE_CASES - :OLD.ACTIVE_CASES WHERE STATE_ID = :NEW.STATE_ID;\nEND;",
    "database_name": "public_hdma_tracking",
    "tables": [
      "ACCESS_LOGS",
      "HEALTH_DATA",
      "STATES",
      "USERS",
      "REPORTING"
    ],
    "call_sqls": [
      "UPDATE HEALTH_DATA SET ACTIVE_CASES = 25 WHERE DATA_ID = 0",
      "UPDATE HEALTH_DATA SET ACTIVE_CASES = 130 WHERE DATA_ID = 1",
      "UPDATE HEALTH_DATA SET ACTIVE_CASES = 40 WHERE DATA_ID = 0",
      "UPDATE HEALTH_DATA SET ACTIVE_CASES = 110 WHERE DATA_ID = 1",
      "UPDATE HEALTH_DATA SET ACTIVE_CASES = 50 WHERE DATA_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_health_data that fires after each row is updated in the HEALTH_DATA table, and for each updated row, updates the POPULATION column in the STATES table by adding the difference between the new and old ACTIVE_CASES values from HEALTH_DATA, but only for the state where the STATES.STATE_ID matches the :NEW.STATE_ID from the updated HEALTH_DATA row.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_health_data that, after each row is updated in the HEALTH_DATA table, updates the POPULATION column in the STATES table by adding the difference between the new and old ACTIVE_CASES values, but only for the state where the STATE_ID matches the new STATE_ID from the updated HEALTH_DATA row.",
    "id": 76,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_health_data that is defined to fire automatically after any row in the HEALTH_DATA table is updated, and for each individual row that is updated, the trigger executes a single UPDATE statement targeting the STATES table, specifically modifying the POPULATION column by adding the difference between the new ACTIVE_CASES value from the updated HEALTH_DATA row (referenced as :NEW.ACTIVE_CASES) and the old ACTIVE_CASES value from before the update (referenced as :OLD.ACTIVE_CASES) to the existing POPULATION value, and this update is applied only to the row in the STATES table where the STATE_ID column matches the new STATE_ID value (referenced as :NEW.STATE_ID) from the updated HEALTH_DATA row.",
    "original_summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_health_data on the HEALTH_DATA table. For each updated row, update the POPULATION column in the STATES table by adding the difference (:NEW.ACTIVE_CASES - :OLD.ACTIVE_CASES). Apply this update only where the STATES.STATE_ID matches :NEW.STATE_ID from the updated HEALTH_DATA row.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER UPDATE FOR EACH ROW trigger, which should be named trg_update_health_data, on the HEALTH_DATA table. For every single row that is updated, you must subsequently update the POPULATION column within the STATES table by carefully adding the precise numerical difference, which is calculated by subtracting the old ACTIVE_CASES value from the new ACTIVE_CASES value. Importantly, this specific update operation should only be applied in those cases where the STATE_ID from the STATES table exactly matches the new STATE_ID value originating from the recently updated row in the HEALTH_DATA table."
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_access_logs_insert` that automatically executes before a new row is inserted into the `ACCESS_LOGS` table. This trigger declares a local variable `v_region` of data type `VARCHAR2` with a maximum length of 255 characters. Upon activation for each row being inserted, the trigger performs a `SELECT` operation to retrieve the `REGION` column value from the `STATES` table. The specific row in the `STATES` table is identified by matching its `STATE_ID` column with a `STATE_ID` value obtained from a subquery. This subquery selects the `STATE_ID` from the `HEALTH_DATA` table where the `DATA_ID` column matches the `DATA_ID` value of the new row being inserted into `ACCESS_LOGS` (referenced as `:NEW.DATA_ID`). The retrieved `REGION` value is then stored in the `v_region` variable. Following this, the trigger evaluates the value of `v_region` using a conditional `IF-ELSIF-ELSE` statement. If `v_region` is exactly equal to the string literal 'South', then the `ACCESS_TYPE` column of the new row being inserted into `ACCESS_LOGS` (referenced as `:NEW.ACCESS_TYPE`) is set to the string literal 'priority'. If `v_region` is not 'South' but is exactly equal to the string literal 'West', then `:NEW.ACCESS_TYPE` is set to the string literal 'standard'. For all other cases where `v_region` is neither 'South' nor 'West', `:NEW.ACCESS_TYPE` is set to the string literal 'restricted'. The trigger then completes its execution, allowing the `INSERT` operation to proceed with the potentially modified `ACCESS_TYPE` value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_access_logs_insert\nBEFORE INSERT ON ACCESS_LOGS\nFOR EACH ROW\nDECLARE\n   v_region VARCHAR2(255);\nBEGIN\n   SELECT REGION INTO v_region\n   FROM STATES\n   WHERE STATE_ID = (SELECT STATE_ID FROM HEALTH_DATA WHERE DATA_ID = :NEW.DATA_ID);\n   IF v_region = 'South' THEN\n      :NEW.ACCESS_TYPE := 'priority';\n   ELSIF v_region = 'West' THEN\n      :NEW.ACCESS_TYPE := 'standard';\n   ELSE\n      :NEW.ACCESS_TYPE := 'restricted';\n   END IF;\nEND;",
    "database_name": "public_hdtaa_595280",
    "tables": [
      "HEALTH_DATA",
      "STATES",
      "VACCINATION_PROGRAMS",
      "ACCESS_LOGS"
    ],
    "call_sqls": [
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, IP_ADDRESS, ACCESS_DURATION, ACCESS_DEVICE) VALUES (0, 0, 0, '2023-05-01', '192.168.1.1', 60, 'desktop')",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, IP_ADDRESS, ACCESS_DURATION, ACCESS_DEVICE) VALUES (1, 1, 0, '2023-05-02', '192.168.1.2', 120, 'mobile')",
      "INSERT INTO HEALTH_DATA (DATA_ID, STATE_ID, FLU_CASES, FLU_DEATHS, FLU_PERCENT, HOSPI_RATE, TESTING_RATE, TEST_RESULTS, POSITIVE_TESTS, VAC_PERCENT, VACCINATIONS, VACCINATION_COVERAGE, VACCINATION_TYPE, WEEK, YEAR, DATA_SOURCE) VALUES (2, 0, 100, 5, 0.1, 0.05, 0.2, 1000, 100, 0.5, 50000, 'high', 'flu shot', 1, 2023, 'CDC');\nINSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, IP_ADDRESS, ACCESS_DURATION, ACCESS_DEVICE) VALUES (2, 2, 1, '2023-05-03', '192.168.1.3', 90, 'tablet')",
      "INSERT INTO HEALTH_DATA (DATA_ID, STATE_ID, FLU_CASES, FLU_DEATHS, FLU_PERCENT, HOSPI_RATE, TESTING_RATE, TEST_RESULTS, POSITIVE_TESTS, VAC_PERCENT, VACCINATIONS, VACCINATION_COVERAGE, VACCINATION_TYPE, WEEK, YEAR, DATA_SOURCE) VALUES (3, 1, 200, 10, 0.2, 0.1, 0.3, 2000, 200, 0.6, 60000, 'medium', 'nasal spray', 2, 2023, 'state health department');\nINSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, IP_ADDRESS, ACCESS_DURATION, ACCESS_DEVICE) VALUES (3, 3, 2, '2023-05-04', '192.168.1.4', 150, 'desktop')",
      "INSERT INTO HEALTH_DATA (DATA_ID, STATE_ID, FLU_CASES, FLU_DEATHS, FLU_PERCENT, HOSPI_RATE, TESTING_RATE, TEST_RESULTS, POSITIVE_TESTS, VAC_PERCENT, VACCINATIONS, VACCINATION_COVERAGE, VACCINATION_TYPE, WEEK, YEAR, DATA_SOURCE) VALUES (4, 0, 50, 2, 0.05, 0.02, 0.1, 500, 50, 0.4, 40000, 'low', 'flu shot', 3, 2023, 'CDC');\nINSERT INTO ACCESS_LOGS (ACCESS_ID, DATA_ID, USER_ID, ACCESS_DATE, IP_ADDRESS, ACCESS_DURATION, ACCESS_DEVICE) VALUES (4, 4, 3, '2023-05-05', '192.168.1.5', 75, 'mobile')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_access_logs_insert that fires BEFORE INSERT on each row of the ACCESS_LOGS table. For each new row, determine the ACCESS_TYPE based on the REGION associated with the record. Retrieve the REGION from the STATES table by finding the STATE_ID from the HEALTH_DATA table where DATA_ID matches the new DATA_ID. If the region is 'South', set the new ACCESS_TYPE to 'priority'; if it is 'West', set it to 'standard'; for any other region, set it to 'restricted'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_access_logs_insert that fires BEFORE INSERT on each row of the ACCESS_LOGS table to set the :NEW.ACCESS_TYPE based on the REGION from the STATES table: when a new row is inserted, find the REGION by looking up the STATE_ID from the HEALTH_DATA table where its DATA_ID matches the new row's DATA_ID, then set ACCESS_TYPE to 'priority' if the region is 'South', 'standard' if it is 'West', and 'restricted' for any other region.",
    "id": 77,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_access_logs_insert` that automatically executes before a new row is inserted into the `ACCESS_LOGS` table. This trigger declares a local variable `v_region` of data type `VARCHAR2` with a maximum length of 255 characters. Upon activation for each row being inserted, the trigger performs a `SELECT` operation to retrieve the `REGION` column value from the `STATES` table. The specific row in the `STATES` table is identified by matching its `STATE_ID` column with a `STATE_ID` value obtained from a subquery. This subquery selects the `STATE_ID` from the `HEALTH_DATA` table where the `DATA_ID` column matches the `DATA_ID` value of the new row being inserted into `ACCESS_LOGS` (referenced as `:NEW.DATA_ID`). The retrieved `REGION` value is then stored in the `v_region` variable. Following this, the trigger evaluates the value of `v_region` using a conditional `IF-ELSIF-ELSE` statement. If `v_region` is exactly equal to the string literal 'South', then the `ACCESS_TYPE` column of the new row being inserted into `ACCESS_LOGS` (referenced as `:NEW.ACCESS_TYPE`) is set to the string literal 'priority'. If `v_region` is not 'South' but is exactly equal to the string literal 'West', then `:NEW.ACCESS_TYPE` is set to the string literal 'standard'. For all other cases where `v_region` is neither 'South' nor 'West', `:NEW.ACCESS_TYPE` is set to the string literal 'restricted'. The trigger then completes its execution, allowing the `INSERT` operation to proceed with the potentially modified `ACCESS_TYPE` value.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named trg_access_logs_insert on the ACCESS_LOGS table. For each new row, retrieve the REGION from the STATES table by matching STATE_ID with the STATE_ID from the HEALTH_DATA table where DATA_ID equals :NEW.DATA_ID. Based on the retrieved region, set :NEW.ACCESS_TYPE to 'priority' for 'South', 'standard' for 'West', and 'restricted' for all other regions.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a BEFORE INSERT row-level trigger, which should be named trg_access_logs_insert, to be placed on the ACCESS_LOGS table. For every single new row that is inserted, you must carefully retrieve the corresponding REGION value from the STATES table. This is done by first matching the STATE_ID from the HEALTH_DATA table, specifically where its DATA_ID matches the new :NEW.DATA_ID value, and then using that matched STATE_ID to find the REGION. Subsequently, based on the specific region that was retrieved, you should meticulously set the :NEW.ACCESS_TYPE column: assign it the value 'priority' if the region is precisely 'South', assign 'standard' if the region is identically 'West', and for all other possible region values, without exception, set the access type to 'restricted'."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_loyalty_program` that is activated `AFTER` an `INSERT` operation occurs on the `LOCATIONS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is inserted into the `LOCATIONS` table. Upon activation, the trigger performs a single `INSERT` operation into the `LOYALTY_PROGRAMS` table. The `INSERT` statement populates the following columns in the `LOYALTY_PROGRAMS` table: the `LOYALTY_PROGRAM_ID` column is assigned the value from the `LOCATION_ID` column of the newly inserted row in the `LOCATIONS` table, referenced as `:NEW.LOCATION_ID`; the `PROGRAM_NAME` column is assigned the literal string value `'New Location Program'`; the `DESCRIPTION` column is assigned the literal string value `'Benefits for new location'`; and the `BENEFITS` column is assigned the literal string value `'5% discount for new location'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_loyalty_program\nAFTER INSERT ON LOCATIONS\nFOR EACH ROW\nBEGIN\n  INSERT INTO LOYALTY_PROGRAMS (LOYALTY_PROGRAM_ID, PROGRAM_NAME, DESCRIPTION, BENEFITS)\n  VALUES (:NEW.LOCATION_ID, 'New Location Program', 'Benefits for new location', '5% discount for new location');\nEND;",
    "database_name": "automobile_saim_70043",
    "tables": [
      "LOCATIONS",
      "LOYALTY_PROGRAMS",
      "USER_ROLES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO LOCATIONS (LOCATION_ID, LOCATION_NAME, ADDRESS) VALUES (0, 'Ahmedabad Branch', '123 Main St, Ahmedabad')",
      "INSERT INTO LOCATIONS (LOCATION_ID, LOCATION_NAME, ADDRESS) VALUES (1, 'Surat Branch', '456 Elm St, Surat')",
      "INSERT INTO LOCATIONS (LOCATION_ID, LOCATION_NAME, ADDRESS) VALUES (2, 'Mumbai Branch', '789 Oak Ave, Mumbai')",
      "INSERT INTO LOCATIONS (LOCATION_ID, LOCATION_NAME, ADDRESS) VALUES (3, 'Delhi Branch', '101 Pine Rd, Delhi')",
      "INSERT INTO LOCATIONS (LOCATION_ID, LOCATION_NAME, ADDRESS) VALUES (4, 'Bangalore Branch', '202 Maple Ln, Bangalore')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_insert_loyalty_program that fires AFTER INSERT on the LOCATIONS table for each new row, and for every new location inserted, it automatically creates a corresponding loyalty program in the LOYALTY_PROGRAMS table, setting the LOYALTY_PROGRAM_ID to match the new LOCATION_ID, with PROGRAM_NAME as 'New Location Program', DESCRIPTION as 'Benefits for new location', and BENEFITS as '5% discount for new location'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_insert_loyalty_program that, after each insert into the LOCATIONS table, automatically adds a corresponding row to the LOYALTY_PROGRAMS table, setting LOYALTY_PROGRAM_ID to the new LOCATION_ID, PROGRAM_NAME to 'New Location Program', DESCRIPTION to 'Benefits for new location', and BENEFITS to '5% discount for new location'.",
    "id": 78,
    "generated_ir": "Write an Oracle PL/SQL `AFTER INSERT` row-level trigger named `trg_insert_loyalty_program` that automatically executes after an `INSERT` operation is performed on any row in the `LOCATIONS` table of the `automobile_saim_70043` database. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every new row inserted into the `LOCATIONS` table. The trigger does not declare any local variables. Upon activation, the trigger performs a single `INSERT` operation into the `LOYALTY_PROGRAMS` table. The values for the columns in this new row are derived as follows: The `LOYALTY_PROGRAM_ID` column is populated with the value of the `LOCATION_ID` from the newly inserted row in the `LOCATIONS` table, which is referenced using the `:NEW.LOCATION_ID` pseudorecord variable. The `PROGRAM_NAME` column is set to the literal string value `'New Location Program'`. The `DESCRIPTION` column is set to the literal string value `'Benefits for new location'`. The `BENEFITS` column is set to the literal string value `'5% discount for new location'`. No other columns in the `LOYALTY_PROGRAMS` table are populated by this trigger; any other columns in that table will receive their default values or remain `NULL` if no default is defined. The trigger does not contain any conditional logic, calculations, or control flow statements.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_insert_loyalty_program on the LOCATIONS table. For each new location inserted, insert a corresponding row into the LOYALTY_PROGRAMS table. Set LOYALTY_PROGRAM_ID to the new LOCATION_ID. Set PROGRAM_NAME to 'New Location Program', DESCRIPTION to 'Benefits for new location', and BENEFITS to '5% discount for new location'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create trigger trg_insert_loyalty_program on LOCATIONS. After each insert, add a row to LOYALTY_PROGRAMS. Set LOYALTY_PROGRAM_ID to the new LOCATION_ID, PROGRAM_NAME to 'New Location Program', DESCRIPTION to 'Benefits for new location', and BENEFITS to '5% discount for new location'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_metrics_upper_unit that is defined to fire automatically before any INSERT operation or any UPDATE operation is performed on the METRICS table, and for each individual row being inserted or updated, the trigger executes a block of code that assigns a new value to the UNIT column of the currently processing row, specifically by taking the incoming or existing value from the :NEW.UNIT bind variable, which represents the UNIT column value for the new row version, and applying the UPPER() built-in SQL function to it, which converts all alphabetical characters within the string to their uppercase equivalents, and then assigns this uppercase result back to the :NEW.UNIT bind variable, thereby ensuring that the UNIT column value is always stored in uppercase letters regardless of the original case provided in the INSERT or UPDATE statement.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_metrics_upper_unit\nBEFORE INSERT OR UPDATE ON METRICS\nFOR EACH ROW\nBEGIN\n    :NEW.UNIT := UPPER(:NEW.UNIT);\nEND;",
    "database_name": "meteorological_dcaa_67637",
    "tables": [
      "REPORTS",
      "REPORT_CONFIGS",
      "METRICS"
    ],
    "call_sqls": [
      "INSERT INTO METRICS (METRIC_ID, METRIC_NAME, UNIT) VALUES (1, 'Temperature', 'celsius')",
      "INSERT INTO METRICS (METRIC_ID, METRIC_NAME, UNIT) VALUES (2, 'Pressure', 'psi')",
      "UPDATE METRICS SET UNIT = 'kilogram' WHERE METRIC_ID = 1",
      "INSERT INTO METRICS (METRIC_ID, METRIC_NAME, UNIT) VALUES (3, 'Speed', 'km/h')",
      "UPDATE METRICS SET UNIT = 'meter per second', METRIC_NAME = 'Velocity' WHERE METRIC_ID = 3"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_metrics_upper_unit that fires before each INSERT or UPDATE operation on the METRICS table, ensuring the UNIT column value is converted to uppercase before being saved.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_metrics_upper_unit that, before inserting or updating each row in the METRICS table, ensures the UNIT value is stored in uppercase.",
    "id": 79,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_metrics_upper_unit that is defined to fire automatically before any INSERT operation or any UPDATE operation is performed on the METRICS table, and for each individual row being inserted or updated, the trigger executes a block of code that assigns a new value to the UNIT column of the currently processing row, specifically by taking the incoming or existing value from the :NEW.UNIT bind variable, which represents the UNIT column value for the new row version, and applying the UPPER() built-in SQL function to it, which converts all alphabetical characters within the string to their uppercase equivalents, and then assigns this uppercase result back to the :NEW.UNIT bind variable, thereby ensuring that the UNIT column value is always stored in uppercase letters regardless of the original case provided in the INSERT or UPDATE statement.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE trigger named `trg_metrics_upper_unit` on the `METRICS` table. For each affected row, convert the value of the `UNIT` column to uppercase before it is saved.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please implement a BEFORE INSERT OR UPDATE trigger designated as `trg_metrics_upper_unit` for the `METRICS` table. This trigger must execute for each row prior to its insertion or update, ensuring the value within the `UNIT` column is transformed to uppercase prior to its persistence in the database."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_coordinate_treatment_data that fires before each row is deleted from the TREATMENTS table, and within its execution block, it first declares variables v_active_conditions, v_patient_age, and v_medication_total as NUMBER, and declares a cursor c_patient_meds that selects the MEDICATION_NAME and DOSAGE columns from the MEDICATIONS table for rows where the PATIENT_ID equals the OLD.PATIENT_ID value from the row being deleted, and a record variable r_med based on that cursor's row type, then begins by deleting all rows from the MEDICAL_HISTORY table where the TREATMENT_ID column matches the OLD.TREATMENT_ID value from the row being deleted, then selects a count of rows from the MEDICAL_HISTORY table where PATIENT_ID equals OLD.PATIENT_ID and the STATUS column equals the string 'active', storing the result in v_active_conditions, then calculates the patient's age by subtracting the year extracted from the patient's DOB column, after converting it from a string using the format 'YYYY-MM-DD', from the current year extracted from SYSDATE, for the row in the PATIENTS table where PATIENT_ID equals OLD.PATIENT_ID, storing the result in v_patient_age, then selects the sum of the REFILLS_REMAINING column from the MEDICATIONS table for rows where PATIENT_ID equals OLD.PATIENT_ID, storing the result in v_medication_total, then evaluates a conditional IF statement where if v_active_conditions is greater than 0 and v_patient_age is greater than 60, it opens a FOR loop over the cursor c_patient_meds, and for each fetched record r_med, it inserts a new row into the MEDICAL_HISTORY table, populating the HISTORY_ID column with the absolute value of the modulus of a random number generated by DBMS_RANDOM.VALUE multiplied by 1000 and then taken modulo 10000, the PATIENT_ID column with OLD.PATIENT_ID, the CONDITION column with the string 'Medication Review', the DIAGNOSIS_DATE column with the current date converted to a string in 'YYYY-MM-DD' format using TO_CHAR and SYSDATE, the STATUS column with the string 'active', the DOCTOR_ID column with OLD.DOCTOR_ID, the TREATMENT_ID column with NULL, and the NOTES column with the concatenated string 'Reviewing ' followed by r_med.MEDICATION_NAME, a space, and r_med.DOSAGE; if the first condition is not met, it checks an ELSIF condition where if v_medication_total is greater than 5, it deletes rows from the MEDICATIONS table where PATIENT_ID equals OLD.PATIENT_ID and the REFILLS_REMAINING column equals 0; if that condition is also not met, it checks another ELSIF condition where if v_active_conditions equals 0, it updates the PATIENTS table by setting the PRIMARY_CARE_PHYSICIAN_ID column to NULL for the row where PATIENT_ID equals OLD.PATIENT_ID; if none of the previous conditions are true, it executes an ELSE block that inserts a new row into the TREATMENTS table, populating the TREATMENT_ID column with the absolute value of the modulus of a random number generated by DBMS_RANDOM.VALUE multiplied by 1000 and then taken modulo 10000, the PATIENT_ID column with OLD.PATIENT_ID, the TREATMENT_NAME column with the string 'Replacement Therapy', the START_DATE column with the current date converted to a string in 'YYYY-MM-DD' format using TO_CHAR and SYSDATE, the END_DATE column with NULL, the STATUS column with the string 'ongoing', the DOCTOR_ID column with OLD.DOCTOR_ID, and the NOTES column with the concatenated string 'Replacing deleted treatment ID ' followed by the OLD.TREATMENT_ID value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_coordinate_treatment_data\nBEFORE DELETE ON TREATMENTS\nFOR EACH ROW\nDECLARE\n    v_active_conditions NUMBER;\n    v_patient_age NUMBER;\n    v_medication_total NUMBER;\n    CURSOR c_patient_meds IS SELECT MEDICATION_NAME, DOSAGE FROM MEDICATIONS WHERE PATIENT_ID = :OLD.PATIENT_ID;\n    r_med c_patient_meds%ROWTYPE;\nBEGIN\n    -- First, delete dependent records in MEDICAL_HISTORY to avoid foreign key constraint violation\n    DELETE FROM MEDICAL_HISTORY WHERE TREATMENT_ID = :OLD.TREATMENT_ID;\n\n    SELECT COUNT(*) INTO v_active_conditions FROM MEDICAL_HISTORY WHERE PATIENT_ID = :OLD.PATIENT_ID AND STATUS = 'active';\n    SELECT (EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM TO_DATE(DOB, 'YYYY-MM-DD'))) INTO v_patient_age FROM PATIENTS WHERE PATIENT_ID = :OLD.PATIENT_ID;\n    SELECT SUM(REFILLS_REMAINING) INTO v_medication_total FROM MEDICATIONS WHERE PATIENT_ID = :OLD.PATIENT_ID;\n    \n    IF v_active_conditions > 0 AND v_patient_age > 60 THEN\n        FOR r_med IN c_patient_meds LOOP\n            INSERT INTO MEDICAL_HISTORY (HISTORY_ID, PATIENT_ID, CONDITION, DIAGNOSIS_DATE, STATUS, DOCTOR_ID, TREATMENT_ID, NOTES)\n            VALUES (ABS(MOD(DBMS_RANDOM.VALUE * 1000, 10000)), :OLD.PATIENT_ID, 'Medication Review', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'active', :OLD.DOCTOR_ID, NULL, 'Reviewing ' || r_med.MEDICATION_NAME || ' ' || r_med.DOSAGE);\n        END LOOP;\n    ELSIF v_medication_total > 5 THEN\n        DELETE FROM MEDICATIONS WHERE PATIENT_ID = :OLD.PATIENT_ID AND REFILLS_REMAINING = 0;\n    ELSIF v_active_conditions = 0 THEN\n        UPDATE PATIENTS SET PRIMARY_CARE_PHYSICIAN_ID = NULL WHERE PATIENT_ID = :OLD.PATIENT_ID;\n    ELSE\n        INSERT INTO TREATMENTS (TREATMENT_ID, PATIENT_ID, TREATMENT_NAME, START_DATE, END_DATE, STATUS, DOCTOR_ID, NOTES)\n        VALUES (ABS(MOD(DBMS_RANDOM.VALUE * 1000, 10000)), :OLD.PATIENT_ID, 'Replacement Therapy', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), NULL, 'ongoing', :OLD.DOCTOR_ID, 'Replacing deleted treatment ID ' || :OLD.TREATMENT_ID);\n    END IF;\nEND;",
    "database_name": "healthcare_daap_outcomes",
    "tables": [
      "PATIENTS",
      "MEDICAL_HISTORY",
      "TREATMENTS",
      "MEDICATIONS"
    ],
    "call_sqls": [
      "DELETE FROM TREATMENTS WHERE TREATMENT_ID = 1",
      "DELETE FROM TREATMENTS WHERE PATIENT_ID = 0",
      "DELETE FROM TREATMENTS WHERE PATIENT_ID = 1 AND STATUS = 'completed'",
      "DELETE FROM TREATMENTS WHERE DOCTOR_ID = 0",
      "DELETE FROM TREATMENTS WHERE TREATMENT_NAME = 'Diabetes Management'"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_coordinate_treatment_data that executes BEFORE DELETE on each row of the TREATMENTS table. For each deleted treatment, first delete any related records in the MEDICAL_HISTORY table for that TREATMENT_ID. Then, based on the patient's data: if the patient has any active conditions in MEDICAL_HISTORY and is over 60 years old (calculated from PATIENTS.DOB), create a 'Medication Review' entry in MEDICAL_HISTORY for each of the patient's medications from the MEDICATIONS table, including the MEDICATION_NAME and DOSAGE in the notes. If the total sum of REFILLS_REMAINING for the patient's medications exceeds 5, delete any of their medications with zero REFILLS_REMAINING. If the patient has no active conditions, set their PRIMARY_CARE_PHYSICIAN_ID to NULL in the PATIENTS table. Otherwise, insert a new 'Replacement Therapy' treatment into the TREATMENTS table for the patient.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_coordinate_treatment_data that fires BEFORE DELETE on each row of the TREATMENTS table. For every deleted treatment, first remove any related records from the MEDICAL_HISTORY table where the TREATMENT_ID matches the deleted one. Then, based on the patient's data: if the patient has more than zero active conditions in MEDICAL_HISTORY and is older than 60 years, insert a new 'Medication Review' record into MEDICAL_HISTORY for each of the patient's medications from the MEDICATIONS table, including the MEDICATION_NAME and DOSAGE in the notes; if the total REFILLS_REMAINING from MEDICATIONS for the patient exceeds 5, delete any medication records for that patient with zero refills remaining; if the patient has no active conditions, update the PATIENTS table to set the PRIMARY_CARE_PHYSICIAN_ID to null for that patient; otherwise, insert a new 'Replacement Therapy' record into the TREATMENTS table for the patient with notes indicating it replaces the deleted treatment.",
    "id": 80,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_coordinate_treatment_data that is executed before a row is deleted from the TREATMENTS table for each row affected by the delete operation. The trigger operates within the healthcare_daap_outcomes database.\n\nThe trigger begins by declaring several local variables: v_patient_id of type NUMBER, which stores the patient identifier from the deleted treatment; v_patient_age of type NUMBER, which stores the age of the patient; v_active_conditions_count of type NUMBER, which stores the count of active conditions for the patient; v_total_refills of type NUMBER, which stores the total number of refills remaining for the patient's medications; and v_medication_name and v_dosage of type VARCHAR2, which temporarily store medication details during cursor iteration.\n\nFirst, the trigger performs a delete operation on the MEDICAL_HISTORY table, removing all rows where the TREATMENT_ID column matches the :OLD.TREATMENT_ID from the row being deleted from the TREATMENTS table.\n\nNext, the trigger retrieves the patient's data. It executes a SELECT statement to fetch the PATIENT_ID from the :OLD pseudorecord of the TREATMENTS table and stores it in v_patient_id. Using this v_patient_id, the trigger performs another SELECT statement to calculate the patient's age from the PATIENTS table, typically by subtracting the birth date from the current date, and stores the result in v_patient_age.\n\nThen, the trigger determines the number of active conditions for the patient. It executes a SELECT COUNT(*) operation on the MEDICAL_HISTORY table, counting rows where the PATIENT_ID equals v_patient_id and the CONDITION_STATUS is 'Active', storing the result in v_active_conditions_count.\n\nThe trigger proceeds with conditional logic based on the patient's data. If v_active_conditions_count is greater than zero and v_patient_age is greater than 60, the trigger inserts new records into the MEDICAL_HISTORY table. It uses a cursor to iterate over all medications for the patient from the MEDICATIONS table, selecting MEDICATION_NAME and DOSAGE for rows where PATIENT_ID equals v_patient_id. For each medication fetched, the trigger inserts a row into MEDICAL_HISTORY with the following values: PATIENT_ID set to v_patient_id, TREATMENT_ID set to a new unique identifier (e.g., from a sequence), HISTORY_TYPE set to 'Medication Review', NOTES set to a concatenated string of the medication name and dosage (e.g., 'Medication: ' || v_medication_name || ', Dosage: ' || v_dosage), and other columns set to default or null values as per the table schema.\n\nAfter handling the medication review insertion, the trigger calculates the total refills remaining for the patient. It executes a SELECT SUM(REFILLS_REMAINING) operation on the MEDICATIONS table for rows where PATIENT_ID equals v_patient_id, storing the result in v_total_refills. If v_total_refills exceeds 5, the trigger performs a delete operation on the MEDICATIONS table, removing all rows where PATIENT_ID equals v_patient_id and REFILLS_REMAINING equals 0.\n\nIf v_active_conditions_count equals zero, indicating the patient has no active conditions, the trigger updates the PATIENTS table. It sets the PRIMARY_CARE_PHYSICIAN_ID column to null for the row where PATIENT_ID equals v_patient_id.\n\nOtherwise, if v_active_conditions_count is greater than zero (and the patient is not necessarily older than 60, as that condition was already handled separately), the trigger inserts a new record into the TREATMENTS table. This insertion creates a replacement therapy record with the following values: TREATMENT_ID set to a new unique identifier (e.g., from a sequence), PATIENT_ID set to v_patient_id, TREATMENT_TYPE set to 'Replacement Therapy', NOTES set to a string indicating it replaces the deleted treatment (e.g., 'Replaces treatment ID: ' || :OLD.TREATMENT_ID), and other columns set to default or null values as per the table schema.\n\nThe trigger ensures data coordination by cleaning up related medical history, managing medication records based on patient conditions and age, updating patient information if no active conditions exist, and providing replacement therapy when active conditions are present, all before the original treatment record is deleted from the TREATMENTS table.",
    "original_summary": "Create a BEFORE DELETE row-level trigger named trg_coordinate_treatment_data on the TREATMENTS table. Declare variables v_active_conditions, v_patient_age, v_medication_total as NUMBER. Declare a cursor c_patient_meds to select MEDICATION_NAME and DOSAGE from MEDICATIONS where PATIENT_ID = :OLD.PATIENT_ID, and a record variable r_med. For each deleted row: 1) DELETE from MEDICAL_HISTORY where TREATMENT_ID = :OLD.TREATMENT_ID. 2) Count active conditions in MEDICAL_HISTORY for :OLD.PATIENT_ID into v_active_conditions. 3) Calculate patient age from PATIENTS.DOB for :OLD.PATIENT_ID into v_patient_age. 4) Sum REFILLS_REMAINING from MEDICATIONS for :OLD.PATIENT_ID into v_medication_total. Then, execute conditional logic: IF (v_active_conditions > 0 AND v_patient_age > 60) THEN FOR r_med IN c_patient_meds LOOP INSERT into MEDICAL_HISTORY (HISTORY_ID, PATIENT_ID, CONDITION, DIAGNOSIS_DATE, STATUS, DOCTOR_ID, TREATMENT_ID, NOTES) VALUES (ABS(MOD(DBMS_RANDOM.VALUE * 1000, 10000)), :OLD.PATIENT_ID, 'Medication Review', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'active', :OLD.DOCTOR_ID, NULL, 'Reviewing ' || r_med.MEDICATION_NAME || ' ' || r_med.DOSAGE). END LOOP. ELSIF v_medication_total > 5 THEN DELETE from MEDICATIONS where PATIENT_ID = :OLD.PATIENT_ID AND REFILLS_REMAINING = 0. ELSIF v_active_conditions = 0 THEN UPDATE PATIENTS SET PRIMARY_CARE_PHYSICIAN_ID = NULL where PATIENT_ID = :OLD.PATIENT_ID. ELSE INSERT into TREATMENTS (TREATMENT_ID, PATIENT_ID, TREATMENT_NAME, START_DATE, END_DATE, STATUS, DOCTOR_ID, NOTES) VALUES (ABS(MOD(DBMS_RANDOM.VALUE * 1000, 10000)), :OLD.PATIENT_ID, 'Replacement Therapy', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), NULL, 'ongoing', :OLD.DOCTOR_ID, 'Replacing deleted treatment ID ' || :OLD.TREATMENT_ID). END IF.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a BEFORE DELETE row-level trigger, which should be named trg_coordinate_treatment_data, specifically for the TREATMENTS table. You must begin by carefully declaring several numeric variables: v_active_conditions, v_patient_age, and v_medication_total. Additionally, you need to declare a cursor, called c_patient_meds, that will meticulously select both the MEDICATION_NAME and DOSAGE from the MEDICATIONS table, but only for records where the PATIENT_ID matches the :OLD.PATIENT_ID of the row being deleted; also, declare a record variable named r_med to hold each cursor fetch. For every row that is deleted, the trigger must perform the following sequence of detailed actions: Firstly, it should delete any corresponding entries from the MEDICAL_HISTORY table where the TREATMENT_ID equals the :OLD.TREATMENT_ID. Secondly, it must count the number of currently active conditions for that patient in the MEDICAL_HISTORY table, storing the result into the v_active_conditions variable. Thirdly, it needs to calculate the patient's age by deriving it from their date of birth in the PATIENTS table, placing the calculated value into v_patient_age. Fourthly, it should sum up all the REFILLS_REMAINING values from the MEDICATIONS table for the patient, saving the total into v_medication_total. Following these preparatory steps, the trigger must then execute a comprehensive conditional logic block: IF the patient has more than zero active conditions AND is older than 60 years, THEN, for each medication record fetched by the cursor, the trigger must insert a new, detailed record into the MEDICAL_HISTORY table. This new record should include a randomly generated HISTORY_ID, the patient's ID, a condition labeled 'Medication Review', the current date as the diagnosis date, a status of 'active', the original doctor's ID, a null TREATMENT_ID, and notes that concatenate 'Reviewing ' with the specific medication name and its dosage. END LOOP. ELSIF, however, the total medication refills exceed 5, THEN the trigger should proceed to delete from the MEDICATIONS table any records for that patient where there are zero refills remaining. ELSIF the patient has absolutely no active conditions, THEN the trigger must update the PATIENTS table to set the PRIMARY_CARE_PHYSICIAN_ID to null for that specific patient. ELSE, in all other scenarios, the trigger is required to insert a new treatment record into the TREATMENTS table. This new treatment should have a randomly generated TREATMENT_ID, the patient's ID, a treatment name of 'Replacement Therapy', the current start date, a null end date, a status of 'ongoing', the original doctor's ID, and descriptive notes that indicate it is replacing the deleted treatment by appending its ID."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_alert_on_pm25 that fires after each row is inserted into the SAMPLES table, declaring local variables v_safe_limit of type NUMBER, v_alert_id of type NUMBER, v_alert_message of type VARCHAR2 with a length of 255, v_agency_contact of the same type as the CONTACT_PERSON column in the AGENCIES table, and v_agency_id of type NUMBER, then performs a SELECT query on the POLLUTANTS table to retrieve the SAFE_LIMIT value for the row where the POLLUTANT_NAME column equals the string 'PM2.5' and stores it into v_safe_limit, then checks a conditional IF statement where the new row's PM25 column value is not null and is greater than the retrieved v_safe_limit, and if true, executes a SELECT query on the ALERTS table to find the maximum existing ALERT_ID value, uses the NVL function to treat a null result as 0, adds 1 to it, and stores the result into v_alert_id, then begins a nested block that first queries the STATIONS table to select the AGENCY column value for the row where the STATION_ID matches the new row's STATION_ID, converts that value to a number using the TO_NUMBER function, and stores it into v_agency_id, then uses that v_agency_id to query the AGENCIES table, selecting the CONTACT_PERSON column value for the matching AGENCY_ID and storing it into v_agency_contact, with an EXCEPTION handler that sets v_agency_contact to the string 'Unknown Contact' if the NO_DATA_FOUND exception is raised from either SELECT, or sets it to 'Error Retrieving Contact' for any other exception, after which it constructs the v_alert_message string by concatenating the literal 'PM2.5 levels are above the safe limit at station ' with the new row's STATION_ID value, and finally performs an INSERT into the ALERTS table, specifying columns ALERT_ID, SAMPLE_ID, ALERT_TYPE, ALERT_MESSAGE, ALERT_DATE, SEVERITY, ACTION_TAKEN, and SENT_TO, with corresponding values v_alert_id, the new row's SAMPLE_ID, the string 'critical', v_alert_message, the current system date formatted to a 'YYYY-MM-DD' string using TO_CHAR(SYSDATE, 'YYYY-MM-DD'), the string 'high', the string 'Notified the relevant agency', and the v_agency_contact value, with an outer EXCEPTION handler that does nothing (NULL) if a NO_DATA_FOUND exception is raised from the initial pollutant query or if any other exception is raised.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_alert_on_pm25\nAFTER INSERT ON SAMPLES\nFOR EACH ROW\nDECLARE\n   v_safe_limit NUMBER;\n   v_alert_id NUMBER;\n   v_alert_message VARCHAR2(255);\n   v_agency_contact AGENCIES.CONTACT_PERSON%TYPE;\n   v_agency_id NUMBER;\nBEGIN\n   -- Get safe limit for PM2.5\n   SELECT SAFE_LIMIT INTO v_safe_limit FROM POLLUTANTS WHERE POLLUTANT_NAME = 'PM2.5';\n   \n   -- Check if PM25 exceeds safe limit and is not null\n   IF :NEW.PM25 IS NOT NULL AND :NEW.PM25 > v_safe_limit THEN\n      -- Get next alert ID\n      SELECT NVL(MAX(ALERT_ID), 0) + 1 INTO v_alert_id FROM ALERTS;\n      \n      -- Get agency contact with exception handling\n   BEGIN\n      SELECT TO_NUMBER(AGENCY) INTO v_agency_id \n      FROM STATIONS \n      WHERE STATION_ID = :NEW.STATION_ID;\n      \n      SELECT CONTACT_PERSON INTO v_agency_contact \n      FROM AGENCIES \n      WHERE AGENCY_ID = v_agency_id;\n   EXCEPTION\n      WHEN NO_DATA_FOUND THEN\n         v_agency_contact := 'Unknown Contact';\n      WHEN OTHERS THEN\n         v_agency_contact := 'Error Retrieving Contact';\n   END;\n      \n      v_alert_message := 'PM2.5 levels are above the safe limit at station ' || :NEW.STATION_ID;\n      \n      INSERT INTO ALERTS (ALERT_ID, SAMPLE_ID, ALERT_TYPE, ALERT_MESSAGE, ALERT_DATE, SEVERITY, ACTION_TAKEN, SENT_TO)\n      VALUES (v_alert_id, :NEW.SAMPLE_ID, 'critical', v_alert_message, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'high', 'Notified the relevant agency', v_agency_contact);\n   END IF;\nEXCEPTION\n   WHEN NO_DATA_FOUND THEN\n      -- Handle case where pollutant data is not found\n      NULL;\n   WHEN OTHERS THEN\n      -- Log or handle other errors appropriately\n      NULL;\nEND;",
    "database_name": "air_qmaa_918261",
    "tables": [
      "STATIONS",
      "SAMPLES",
      "SAMPLE_DETAILS",
      "POLLUTANTS",
      "ALERTS",
      "AGENCIES"
    ],
    "call_sqls": [
      "INSERT INTO POLLUTANTS (POLLUTANT_ID, POLLUTANT_NAME, SAFE_LIMIT) VALUES (1, 'PM2.5', 25);\nINSERT INTO AGENCIES (AGENCY_ID, CONTACT_PERSON) VALUES (101, 'John Doe');\nINSERT INTO STATIONS (STATION_ID, AGENCY) VALUES (1, '101');\nINSERT INTO SAMPLES (SAMPLE_ID, STATION_ID, PM25) VALUES (1, 1, 30)",
      "INSERT INTO POLLUTANTS (POLLUTANT_ID, POLLUTANT_NAME, SAFE_LIMIT) VALUES (2, 'PM2.5', 20);\nINSERT INTO AGENCIES (AGENCY_ID, CONTACT_PERSON) VALUES (102, 'Jane Smith');\nINSERT INTO STATIONS (STATION_ID, AGENCY) VALUES (2, '102');\nINSERT INTO SAMPLES (SAMPLE_ID, STATION_ID, PM25) VALUES (2, 2, 21)",
      "INSERT INTO POLLUTANTS (POLLUTANT_ID, POLLUTANT_NAME, SAFE_LIMIT) VALUES (3, 'PM2.5', 30);\nINSERT INTO AGENCIES (AGENCY_ID, CONTACT_PERSON) VALUES (103, 'Peter Jones');\nINSERT INTO STATIONS (STATION_ID, AGENCY) VALUES (3, '103');\nINSERT INTO SAMPLES (SAMPLE_ID, STATION_ID, PM25) VALUES (3, 3, 35)",
      "INSERT INTO POLLUTANTS (POLLUTANT_ID, POLLUTANT_NAME, SAFE_LIMIT) VALUES (4, 'PM2.5', 15);\nINSERT INTO AGENCIES (AGENCY_ID, CONTACT_PERSON) VALUES (104, 'Alice Brown');\nINSERT INTO STATIONS (STATION_ID, AGENCY) VALUES (4, '104');\nINSERT INTO SAMPLES (SAMPLE_ID, STATION_ID, PM25) VALUES (4, 4, 14)",
      "INSERT INTO POLLUTANTS (POLLUTANT_ID, POLLUTANT_NAME, SAFE_LIMIT) VALUES (5, 'PM2.5', 22);\nINSERT INTO AGENCIES (AGENCY_ID, CONTACT_PERSON) VALUES (105, 'Bob White');\nINSERT INTO STATIONS (STATION_ID, AGENCY) VALUES (5, '105');\nINSERT INTO SAMPLES (SAMPLE_ID, STATION_ID, PM25) VALUES (5, 5, 28)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_alert_on_pm25 that fires after each row is inserted into the SAMPLES table. It checks if the new row's PM25 value is not null and exceeds the SAFE_LIMIT for 'PM2.5' from the POLLUTANTS table. If so, it generates a new ALERT_ID, determines the responsible agency's contact person from the STATION_ID via the STATIONS and AGENCIES tables (defaulting to 'Unknown Contact' or 'Error Retrieving Contact' if not found), constructs an alert message, and inserts a critical alert into the ALERTS table with details including the contact, severity 'high', and a formatted alert date.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_alert_on_pm25 that fires after each row is inserted into the SAMPLES table. It should check if the new PM25 value is not null and exceeds the SAFE_LIMIT for pollutant type 'PM2.5' from the POLLUTANTS table. If so, generate a new ALERT_ID, determine the responsible agency's contact person from the AGENCIES table via the new row's STATION_ID, defaulting to 'Unknown Contact' if not found, create an alert message, and insert a record into the ALERTS table with the alert details, including setting the severity to 'high' and using the current date. Handle any errors silently without disruption.",
    "id": 81,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_alert_on_pm25 that executes automatically after each new row is inserted into the SAMPLES table, for each individual row inserted. The trigger first checks if the PM25 column value from the new row data is not null. If it is not null, it then retrieves the SAFE_LIMIT value from the POLLUTANTS table where the POLLUTANT_TYPE column equals the string literal 'PM2.5'. It compares the new PM25 value against this retrieved SAFE_LIMIT. If the PM25 value exceeds the SAFE_LIMIT, the trigger proceeds to generate a new ALERT_ID by selecting the next value from a sequence named ALERTS_SEQ. Next, it determines the responsible agency's contact person by querying the AGENCIES table: it performs a SELECT operation on the CONTACT_PERSON column from the AGENCIES table where the STATION_ID column matches the STATION_ID value from the new row inserted into SAMPLES. If no matching row is found, it defaults the contact person to the string literal 'Unknown Contact'. The trigger then constructs an alert message as a string concatenating the literal 'High PM2.5 alert at station ', the STATION_ID from the new row, and the literal ' with value ' followed by the PM25 value from the new row. It inserts a new record into the ALERTS table with the following column values: ALERT_ID set to the generated sequence value, STATION_ID set to the STATION_ID from the new row, POLLUTANT_TYPE set to the string literal 'PM2.5', MEASURED_VALUE set to the PM25 value from the new row, SAFE_LIMIT set to the retrieved SAFE_LIMIT from the POLLUTANTS table, SEVERITY set to the string literal 'high', ALERT_DATE set to the current system date (using SYSDATE), CONTACT_PERSON set to the determined contact person value, and ALERT_MESSAGE set to the constructed alert message string. The trigger includes an exception handling section that catches any exceptions (using WHEN OTHERS) and performs no action, thereby silently handling any errors without disrupting the insert operation on the SAMPLES table.",
    "original_summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_alert_on_pm25 on the SAMPLES table. Retrieve the SAFE_LIMIT for 'PM2.5' from the POLLUTANTS table. If the new row's PM25 value is not null and exceeds this limit, generate a new ALERT_ID, determine the responsible agency's contact person via the STATION_ID and AGENCIES table (defaulting to 'Unknown Contact' on error), construct an alert message, and insert a critical alert into the ALERTS table with details including the contact, severity 'high', and a formatted alert date. Handle exceptions from the initial pollutant query or other errors silently.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER INSERT FOR EACH ROW trigger, which should be named trg_alert_on_pm25, specifically for the SAMPLES table. First, you must carefully retrieve the precise SAFE_LIMIT value corresponding to the pollutant type 'PM2.5' from the detailed POLLUTANTS table. Subsequently, if the newly inserted row's PM25 value is definitively not null and, importantly, exceeds this pre-defined safety limit, you should proceed to generate a completely new and unique ALERT_ID. Following that, you must diligently determine the responsible agency's designated contact person by meticulously linking through the new row's STATION_ID to the comprehensive AGENCIES table, gracefully defaulting to a placeholder of 'Unknown Contact' should any error occur during this lookup. Then, you are to construct a detailed and informative alert message. Finally, insert a critical alert record, with all pertinent details including the identified contact, a severity level explicitly set to 'high', and a properly formatted alert date, directly into the ALERTS table. Throughout this entire process, any and all exceptions arising from the initial pollutant query or any other subsequent errors must be handled silently and without any visible disruption."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_after_origin_update that is executed after an update operation on the PAYMENT_ORIGINS table for each row affected by the update. The trigger declares three local variables: v_total_payments of type NUMBER to store the total count of payments associated with the updated origin, v_sample_payment_id of type NUMBER to store a sample payment ID for the updated origin, and v_next_plan_id of type NUMBER to store the next available plan ID for insertion into the INSTALLMENT_PLANS table. The trigger begins by selecting the count of rows from the PAYMENTS table where the PAYMENT_ORIGIN column matches the ORIGIN_ID of the updated row, storing this count in v_total_payments. It then attempts to select the minimum PAYMENT_ID from the PAYMENTS table where the PAYMENT_ORIGIN matches the updated ORIGIN_ID, storing the result in v_sample_payment_id. If no data is found, the exception handler sets v_sample_payment_id to NULL. The trigger then checks if v_sample_payment_id is not NULL, indicating that there is at least one payment associated with the updated origin. If this condition is true, the trigger selects the maximum PLAN_ID from the INSTALLMENT_PLANS table, adds one to it, and stores the result in v_next_plan_id, using the NVL function to default to 0 if no rows exist. The trigger then inserts a new row into the INSTALLMENT_PLANS table with the following values: v_next_plan_id for PLAN_ID, v_sample_payment_id for PAYMENT_ID, v_total_payments for INSTALLMENT_COUNT, the current date plus 30 days formatted as 'YYYY-MM-DD' for DUE_DATES, the string 'summary' for STATUS, v_total_payments multiplied by 1000 for both TOTAL_INSTALLMENT_AMOUNT_CENTS and OUTSTANDING_BALANCE_CENTS, the string 'system' for both CREATED_BY and UPDATED_BY, and the current date and time formatted as 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"' for both CREATED_DATE and UPDATED_DATE.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_origin_update\nAFTER UPDATE ON PAYMENT_ORIGINS\nFOR EACH ROW\nDECLARE\n    v_total_payments NUMBER;\n    v_sample_payment_id NUMBER;\n    v_next_plan_id NUMBER;\nBEGIN\n    -- Get total payments for this origin\n    SELECT COUNT(*) INTO v_total_payments \n    FROM PAYMENTS \n    WHERE PAYMENT_ORIGIN = :NEW.ORIGIN_ID;\n    \n    -- Get a sample payment ID for this origin (if any exist)\n    BEGIN\n        SELECT MIN(PAYMENT_ID) INTO v_sample_payment_id\n        FROM PAYMENTS \n        WHERE PAYMENT_ORIGIN = :NEW.ORIGIN_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_sample_payment_id := NULL;\n    END;\n    \n    -- Only insert if we have a valid payment ID\n    IF v_sample_payment_id IS NOT NULL THEN\n        -- Get next plan ID\n        SELECT NVL(MAX(PLAN_ID), 0) + 1 INTO v_next_plan_id FROM INSTALLMENT_PLANS;\n        \n        INSERT INTO INSTALLMENT_PLANS (\n            PLAN_ID, \n            PAYMENT_ID, \n            INSTALLMENT_COUNT, \n            DUE_DATES, \n            STATUS, \n            TOTAL_INSTALLMENT_AMOUNT_CENTS, \n            OUTSTANDING_BALANCE_CENTS, \n            CREATED_BY, \n            CREATED_DATE, \n            UPDATED_BY, \n            UPDATED_DATE\n        ) VALUES (\n            v_next_plan_id,\n            v_sample_payment_id,\n            v_total_payments,\n            TO_CHAR(SYSDATE + 30, 'YYYY-MM-DD'),\n            'summary',\n            v_total_payments * 1000,\n            v_total_payments * 1000,\n            'system',\n            TO_CHAR(SYSDATE, 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'),\n            'system',\n            TO_CHAR(SYSDATE, 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"')\n        );\n    END IF;\nEND;",
    "database_name": "e_cppaf_detection",
    "tables": [
      "PAYMENTS",
      "FRAUD_DETECTION",
      "INSTALLMENT_PLANS",
      "TRANSACTION_FEES",
      "PAYMENT_ORIGINS"
    ],
    "call_sqls": [
      "UPDATE PAYMENT_ORIGINS SET DESCRIPTION = 'Updated description for web payments' WHERE ORIGIN_ID = 0",
      "UPDATE PAYMENT_ORIGINS SET IS_ACTIVE = 0 WHERE ORIGIN_ID = 1",
      "UPDATE PAYMENT_ORIGINS SET UPDATED_BY = 'system_admin', UPDATED_DATE = TO_CHAR(SYSDATE, 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"') WHERE ORIGIN_ID = 0",
      "UPDATE PAYMENT_ORIGINS SET ORIGIN_NAME = 'NEW_WEB_PAYMENT_NAME' WHERE ORIGIN_ID = 0",
      "UPDATE PAYMENT_ORIGINS SET DESCRIPTION = 'Another update for mobile app payments' WHERE ORIGIN_ID = 1"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_after_origin_update that fires after each row is updated in the PAYMENT_ORIGINS table. For each updated origin, count the total number of payments linked to that origin in the PAYMENTS table and retrieve the minimum PAYMENT_ID from those payments. If a payment exists, calculate the next PLAN_ID from the INSTALLMENT_PLANS table, then insert a new row into INSTALLMENT_PLANS with that PLAN_ID, the minimum PAYMENT_ID, the total payments count as INSTALLMENT_COUNT, a DUE_DATES set to 30 days from the current date, a STATUS of 'summary', TOTAL_INSTALLMENT_AMOUNT_CENTS and OUTSTANDING_BALANCE_CENTS each set to the total payments multiplied by 1000, audit columns CREATED_BY and UPDATED_BY set to 'system', and date columns CREATED_DATE and UPDATED_DATE set to the current timestamp.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_after_origin_update that fires AFTER UPDATE on each row of the PAYMENT_ORIGINS table. For each updated row, count the total payments for that origin in the PAYMENTS table and find its minimum PAYMENT_ID. If a payment exists, calculate the next PLAN_ID from the INSTALLMENT_PLANS table, then insert a new row into INSTALLMENT_PLANS with the PLAN_ID as the calculated next ID, PAYMENT_ID as the minimum found, INSTALLMENT_COUNT as the total payments, DUE_DATES as the current date plus 30 days, STATUS as 'summary', TOTAL_INSTALLMENT_AMOUNT_CENTS and OUTSTANDING_BALANCE_CENTS as the total payments times 1000, CREATED_BY and UPDATED_BY as 'system', and CREATED_DATE and UPDATED_DATE as the current timestamp.",
    "id": 82,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_after_origin_update that is executed after an update operation on the PAYMENT_ORIGINS table for each row affected by the update. The trigger declares three local variables: v_total_payments of type NUMBER to store the total count of payments associated with the updated origin, v_sample_payment_id of type NUMBER to store a sample payment ID for the updated origin, and v_next_plan_id of type NUMBER to store the next available plan ID for insertion into the INSTALLMENT_PLANS table. The trigger begins by selecting the count of rows from the PAYMENTS table where the PAYMENT_ORIGIN column matches the ORIGIN_ID of the updated row, storing this count in v_total_payments. It then attempts to select the minimum PAYMENT_ID from the PAYMENTS table where the PAYMENT_ORIGIN matches the updated ORIGIN_ID, storing the result in v_sample_payment_id. If no data is found, the exception handler sets v_sample_payment_id to NULL. The trigger then checks if v_sample_payment_id is not NULL, indicating that there is at least one payment associated with the updated origin. If this condition is true, the trigger selects the maximum PLAN_ID from the INSTALLMENT_PLANS table, adds one to it, and stores the result in v_next_plan_id, using the NVL function to default to 0 if no rows exist. The trigger then inserts a new row into the INSTALLMENT_PLANS table with the following values: v_next_plan_id for PLAN_ID, v_sample_payment_id for PAYMENT_ID, v_total_payments for INSTALLMENT_COUNT, the current date plus 30 days formatted as 'YYYY-MM-DD' for DUE_DATES, the string 'summary' for STATUS, v_total_payments multiplied by 1000 for both TOTAL_INSTALLMENT_AMOUNT_CENTS and OUTSTANDING_BALANCE_CENTS, the string 'system' for both CREATED_BY and UPDATED_BY, and the current date and time formatted as 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"' for both CREATED_DATE and UPDATED_DATE.",
    "original_summary": "Create an AFTER UPDATE row-level trigger named trg_after_origin_update on the PAYMENT_ORIGINS table. For each updated row, count the total payments for that origin and get its minimum PAYMENT_ID. If a payment exists, calculate the next PLAN_ID, then insert a new row into INSTALLMENT_PLANS using these values, the current date plus 30 days for DUE_DATES, 'summary' for STATUS, the total payments times 1000 for amount columns, 'system' for audit columns, and the current timestamp for date columns.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a row-level trigger named trg_after_origin_update that fires AFTER UPDATE on the PAYMENT_ORIGINS table. For each updated row, count the total payments for that origin and find its minimum PAYMENT_ID. If a payment exists, calculate the next PLAN_ID, then insert a new row into INSTALLMENT_PLANS. Use these values, set DUE_DATES to the current date plus 30 days, STATUS to 'summary', the amount columns to the total payments times 1000, the audit columns to 'system', and the date columns to the current timestamp."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_warehouse_capacity` that is activated `BEFORE` an `INSERT` operation is performed on the `WAREHOUSES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row being inserted into the `WAREHOUSES` table. Upon activation, for each new row being inserted, the trigger modifies the value of the `CAPACITY` column within that new row. Specifically, it takes the value that was originally provided for the `CAPACITY` column in the new row (`:NEW.CAPACITY`) and adds a fixed numerical value of `50` to it. The result of this addition then replaces the original value of the `CAPACITY` column for that new row (`:NEW.CAPACITY := :NEW.CAPACITY + 50;`). This modification occurs before the row is actually committed to the `WAREHOUSES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_warehouse_capacity\nBEFORE INSERT ON WAREHOUSES\nFOR EACH ROW\nBEGIN\n  :NEW.CAPACITY := :NEW.CAPACITY + 50;\nEND;",
    "database_name": "automobile_saim_70043",
    "tables": [
      "LOCATIONS",
      "LOYALTY_PROGRAMS",
      "USER_ROLES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO WAREHOUSES (WAREHOUSE_ID, WAREHOUSE_NAME, ADDRESS, CAPACITY) VALUES (2, 'Rajkot Warehouse', '234 Industrial Zone, Rajkot', 200)",
      "INSERT INTO WAREHOUSES (WAREHOUSE_ID, WAREHOUSE_NAME, ADDRESS, CAPACITY) VALUES (3, 'Vadodara Warehouse', '567 Business Park, Vadodara', 75)",
      "INSERT INTO WAREHOUSES (WAREHOUSE_ID, WAREHOUSE_NAME, ADDRESS, CAPACITY) VALUES (4, 'Mumbai Warehouse', '890 Port Area, Mumbai', 300)",
      "INSERT INTO WAREHOUSES (WAREHOUSE_ID, WAREHOUSE_NAME, ADDRESS, CAPACITY) VALUES (5, 'Delhi Warehouse', '111 Logistics Hub, Delhi', 0)",
      "INSERT INTO WAREHOUSES (WAREHOUSE_ID, WAREHOUSE_NAME, ADDRESS, CAPACITY) VALUES (6, 'Chennai Warehouse', '222 Coastal Road, Chennai', 125)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_warehouse_capacity on the WAREHOUSES table that fires before each new row is inserted, increasing the CAPACITY column value by 50 before the insertion occurs.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_warehouse_capacity that, before inserting each new row into the WAREHOUSES table, increases the CAPACITY column value by 50 units.",
    "id": 83,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_update_warehouse_capacity` that is activated `BEFORE` an `INSERT` operation is performed on the `WAREHOUSES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row being inserted into the `WAREHOUSES` table. Upon activation, for each new row being inserted, the trigger modifies the value of the `CAPACITY` column within that new row. Specifically, it takes the value that was originally provided for the `CAPACITY` column in the new row (`:NEW.CAPACITY`) and adds a fixed numerical value of `50` to it. The result of this addition then replaces the original value of the `CAPACITY` column for that new row (`:NEW.CAPACITY := :NEW.CAPACITY + 50;`). This modification occurs before the row is actually committed to the `WAREHOUSES` table.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_update_warehouse_capacity on the WAREHOUSES table. For each new row, increase the CAPACITY column value by 50 before insertion.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE INSERT FOR EACH ROW trigger designated as trg_update_warehouse_capacity for the WAREHOUSES table. The trigger's function is to increment the value in the CAPACITY column by 50 units prior to the insertion of each new record."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_check_assessment_date` that is activated `BEFORE` an `INSERT` operation is performed on the `ASSESSMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row being inserted into the `ASSESSMENTS` table. Upon activation, the trigger accesses the value of the `DATE_CONDUCTED` column for the `NEW` row being inserted. It then converts this `DATE_CONDUCTED` column value, which is expected to be a string, into a `DATE` data type using the `TO_DATE` function. The `TO_DATE` function uses the format mask `'YYYY-MM-DD'` to interpret the input string, meaning it expects the year to be represented by four digits, the month by two digits, and the day by two digits, separated by hyphens. The trigger then performs a conditional check: `IF` the converted `DATE_CONDUCTED` value is `LESS THAN` the current system date and time, obtained using the `SYSDATE` function, `THEN` it executes a specific action. This action involves raising an application error using the `RAISE_APPLICATION_ERROR` procedure. The error is assigned an error number of `-20001` and a descriptive error message string: `'Assessment date cannot be in the past.'`. This error prevents the `INSERT` operation from completing for the current row, effectively rejecting any attempt to insert an assessment record where the `DATE_CONDUCTED` is a past date.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_assessment_date\nBEFORE INSERT ON ASSESSMENTS\nFOR EACH ROW\nBEGIN\n  IF TO_DATE(:NEW.DATE_CONDUCTED, 'YYYY-MM-DD') < SYSDATE THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Assessment date cannot be in the past.');\n  END IF;\nEND;",
    "database_name": "educational_aaspt_766875",
    "tables": [
      "ASSESSMENTS",
      "ASSESSMENT_FORMS",
      "ASSESSMENT_QUESTIONS",
      "CLASSES",
      "STUDENTS",
      "TEACHERS"
    ],
    "call_sqls": [
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (100, 'History Final', 'C', 60, '2025-12-15', 1, 'Final', 120)",
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (101, 'Physics Quiz', 'A', 20, '2025-06-01', 0, 'Quiz', 30)",
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (102, 'English Midterm', 'B', 50, '2025-10-20', 1, 'Midterm', 90)",
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (103, 'Chemistry Lab', 'D', 15, '2025-11-11', 0, 'Practical', 60)",
      "INSERT INTO ASSESSMENTS (ASSESSMENT_ID, ASSESSMENT_NAME, FORM, TOTAL_QUESTIONS, DATE_CONDUCTED, CLASS_ID, ASSESSMENT_TYPE, DURATION) VALUES (104, 'Algebra Test', 'A', 40, '2025-09-30', 1, 'Test', 80)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_check_assessment_date on the ASSESSMENTS table that fires BEFORE INSERT for each new row. It ensures that the DATE_CONDUCTED value, interpreted in the format 'YYYY-MM-DD', is not earlier than the current date; if it is, it prevents the insertion by raising an error with the message 'Assessment date cannot be in the past.'.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_check_assessment_date that runs before inserting any new record into the ASSESSMENTS table. For each new entry, check the DATE_CONDUCTED field, which is stored as text in a year-month-day format, and convert it to a date. If the converted date is earlier than the current date, prevent the insertion and raise an error with the message 'Assessment date cannot be in the past.'",
    "id": 84,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_check_assessment_date that is defined to execute automatically before any row insertion operation on the ASSESSMENTS table, firing once for each individual row being inserted, which declares a local variable v_converted_date of type DATE, then performs a conversion operation on the DATE_CONDUCTED field of the new incoming row (referenced as :NEW.DATE_CONDUCTED) from its text format (stored as a string in year-month-day format) into a DATE data type using the TO_DATE function with the appropriate format mask, storing the result into v_converted_date, and after this conversion, it checks a conditional IF statement: if the v_converted_date is less than the current system date (obtained via SYSDATE), it raises a custom application error with the message 'Assessment date cannot be in the past.', thereby preventing the insertion of the row, and if the condition is false, it executes a NULL statement to allow the insertion to proceed normally.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_check_assessment_date on the ASSESSMENTS table. For each new row, convert the DATE_CONDUCTED string to a date using format 'YYYY-MM-DD'. If this date is earlier than SYSDATE, raise application error -20001 with message 'Assessment date cannot be in the past.'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the ASSESSMENTS table that runs before adding any new record. Name it something like trg_check_assessment_date. For each entry, you need to handle the DATE_CONDUCTED field, which is text, and turn it into an actual date, assuming it's in a standard year-month-day layout. If, after converting, that date seems to be from before right now, you should block the insert and throw an error with a suitable message saying the date can't be old."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_draft_pick_delete that is executed automatically after a row is deleted from the DRAFT_PICKS table. This trigger operates for each row that is deleted. It declares a local variable v_next_coach_id of type NUMBER to store the next available coach ID. The trigger begins by executing a SELECT statement to retrieve the maximum value of the COACH_ID column from the COACHES table, using the NVL function to handle null values by defaulting to 0 if no rows exist, and then adds 1 to this maximum value to determine the next available coach ID, storing the result in the v_next_coach_id variable. Following this, the trigger performs an INSERT operation into the COACHES table, specifying the columns COACH_ID, COACH_NAME, TEAM_ID, EXPERIENCE, DATE_OF_BIRTH, and WIN_LOSS_RECORD. The values inserted are the calculated v_next_coach_id, a string literal 'Default Coach' for COACH_NAME, the TEAM_ID from the deleted row in the DRAFT_PICKS table accessed via the :OLD pseudorecord, a numeric literal 0 for EXPERIENCE, a date literal '1900-01-01' for DATE_OF_BIRTH, and a string literal '0-0' for WIN_LOSS_RECORD. The trigger includes an exception handling block that captures any exceptions using the OTHERS handler, but it does not perform any specific error handling actions, effectively ignoring any errors that occur during the execution of the trigger.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_draft_pick_delete\nAFTER DELETE ON DRAFT_PICKS\nFOR EACH ROW\nDECLARE\n  v_next_coach_id NUMBER;\nBEGIN\n  -- Get the next available COACH_ID\n  SELECT NVL(MAX(COACH_ID), 0) + 1 INTO v_next_coach_id FROM COACHES;\n  \n  INSERT INTO COACHES (COACH_ID, COACH_NAME, TEAM_ID, EXPERIENCE, DATE_OF_BIRTH, WIN_LOSS_RECORD)\n  VALUES (v_next_coach_id, 'Default Coach', :OLD.TEAM_ID, 0, '1900-01-01', '0-0');\n  \nEXCEPTION\n  WHEN OTHERS THEN\n    -- Log error or handle as needed\n    NULL;\nEND;",
    "database_name": "nba_tsap_trackin",
    "tables": [
      "TEAMS",
      "COACHES",
      "PLAYER_STATISTICS",
      "AWARDS",
      "CONTRACTS",
      "DRAFT_PICKS"
    ],
    "call_sqls": [
      "DELETE FROM DRAFT_PICKS WHERE PICK_ID = 0",
      "DELETE FROM DRAFT_PICKS WHERE PICK_ID = 1",
      "DELETE FROM DRAFT_PICKS WHERE TEAM_ID = 0 AND ROUND = 1 AND PICK = 5",
      "DELETE FROM DRAFT_PICKS WHERE TEAM_ID = 1 AND ROUND = 1 AND PICK = 10",
      "DELETE FROM DRAFT_PICKS WHERE PICK_ID = (SELECT MIN(PICK_ID) FROM DRAFT_PICKS)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_draft_pick_delete that fires after each row is deleted from the DRAFT_PICKS table, and for each deleted row, it inserts a new default coach record into the COACHES table. The new coach should have a COACH_ID calculated as one more than the highest existing COACH_ID in COACHES (or starting at 1 if none exist), with the COACH_NAME set to 'Default Coach', the TEAM_ID set to the deleted row's TEAM_ID, EXPERIENCE set to 0, DATE_OF_BIRTH set to '1900-01-01', and WIN_LOSS_RECORD set to '0-0'. Any errors encountered during this process should be silently ignored.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_draft_pick_delete that fires after each row is deleted from the DRAFT_PICKS table, and for each deletion, it inserts a new coach into the COACHES table with the next available COACH_ID (calculated as the maximum existing COACH_ID plus one, or starting at 0 if none exist), sets the COACH_NAME to 'Default Coach', uses the deleted row's TEAM_ID, assigns 0 for EXPERIENCE, sets DATE_OF_BIRTH to '1900-01-01', and sets WIN_LOSS_RECORD to '0-0', while ignoring any errors that occur during this process.",
    "id": 85,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_draft_pick_delete that executes automatically after each row is deleted from the DRAFT_PICKS table. For each deleted row, the trigger performs an insert operation into the COACHES table. To determine the next available COACH_ID, the trigger first executes a SELECT MAX(COACH_ID) operation on the COACHES table, storing the result into a local variable v_max_coach_id. If the result of this query is null, indicating no existing rows, the trigger sets the COACH_ID for the new coach to 0; otherwise, it calculates the new COACH_ID as v_max_coach_id plus one. The trigger then constructs a new row for insertion into the COACHES table with the following column values: the calculated COACH_ID, the COACH_NAME set to the string literal 'Default Coach', the TEAM_ID set to the TEAM_ID value from the deleted row (accessed via the :OLD pseudorecord), the EXPERIENCE set to the numeric literal 0, the DATE_OF_BIRTH set to the date literal '1900-01-01', and the WIN_LOSS_RECORD set to the string literal '0-0'. The trigger executes this INSERT operation within a BEGIN...EXCEPTION...END block to handle any exceptions that may occur during the insertion; if any error is raised, the exception handler catches it and performs no action, effectively ignoring the error and allowing the trigger to complete without propagating the exception.",
    "original_summary": "Create an AFTER DELETE row-level trigger named trg_draft_pick_delete on the DRAFT_PICKS table. For each deleted row, calculate the next COACH_ID as MAX(COACH_ID)+1 from COACHES (defaulting to 0 if null), then insert a default coach into COACHES using this ID, 'Default Coach' as name, the deleted row's TEAM_ID, 0 experience, '1900-01-01' birth date, and '0-0' win-loss record. Include an exception handler that ignores any errors.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create an AFTER DELETE trigger named trg_draft_pick_delete on DRAFT_PICKS. For each deleted row, insert a default coach into COACHES using the next COACH_ID (MAX+1 from COACHES or 0), 'Default Coach', the deleted TEAM_ID, 0 experience, '1900-01-01' birth date, and '0-0' record. Ignore all errors."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_measurements_avg_bust that is defined to execute automatically after every successful insertion of a new row into the MEASUREMENTS table, where the trigger body first declares a local variable v_avg_bust of type NUMBER, then performs a SELECT statement that calculates the count of distinct, non-null values found in the BUST column of the MEASUREMENTS table and stores this result into the v_avg_bust variable, and subsequently executes an INSERT statement into the SIZE_UPDATES table, populating its columns with specific values: the UPDATE_ID column is set to the current total row count of the SIZE_UPDATES table plus one, obtained via a scalar subquery (SELECT COUNT(*) FROM SIZE_UPDATES) + 1; the MEASUREMENT_ID column is explicitly set to NULL; the UPDATE_DATE column is set to the current system date converted to a string in the 'YYYY-MM-DD' format using the TO_CHAR function with the SYSDATE parameter; the UPDATED_BY column is set to the numeric literal 0; the UPDATE_REASON column is set to the string literal 'STATS'; and the UPDATE_DESCRIPTION column is set to the concatenated string 'Distinct bust values: ' appended with the numeric value stored in the v_avg_bust variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_measurements_avg_bust\nAFTER INSERT ON MEASUREMENTS\nDECLARE\n    v_avg_bust NUMBER;\nBEGIN\n    SELECT COUNT(DISTINCT BUST) INTO v_avg_bust FROM MEASUREMENTS WHERE BUST IS NOT NULL;\n    INSERT INTO SIZE_UPDATES (UPDATE_ID, MEASUREMENT_ID, UPDATE_DATE, UPDATED_BY, UPDATE_REASON, UPDATE_DESCRIPTION) VALUES ((SELECT COUNT(*) FROM SIZE_UPDATES) + 1, NULL, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 0, 'STATS', 'Distinct bust values: ' || v_avg_bust);\nEND;",
    "database_name": "apparel_sams_543314",
    "tables": [
      "SIZES",
      "MEASUREMENTS",
      "SIZE_UPDATES"
    ],
    "call_sqls": [
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (0, 0, 36.8, 96.5, 96.5, 116.8, 106.7, 91.4, 76.2, 60.3)",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (1, 1, 38.1, 101.6, 101.6, 116.8, 111.8, 96.5, 78.7, 62.2)",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (2, 0, 37.0, 96.5, 97.0, 117.0, 107.0, 92.0, 76.5, 60.5)",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (3, 1, 38.5, 102.0, 102.0, 117.5, 112.0, 97.0, 79.0, 62.5)",
      "INSERT INTO MEASUREMENTS (MEASUREMENT_ID, SIZE_ID, ACROSS_SHOULDER, BUST, CHEST, FRONT_LENGTH, HIPS, WAIST, INSEAM, SLEEVE_LENGTH) VALUES (4, 0, 36.9, 97.0, 96.8, 116.9, 106.9, 91.8, 76.3, 60.4)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named `trg_measurements_avg_bust` that fires after each insert on the MEASUREMENTS table, calculates the count of distinct non-null BUST values from the MEASUREMENTS table, and inserts a new record into the SIZE_UPDATES table with an UPDATE_ID set to the total number of rows in SIZE_UPDATES plus one, a NULL MEASUREMENT_ID, the current date in 'YYYY-MM-DD' format, UPDATED_BY as 0, UPDATE_REASON as 'STATS', and an UPDATE_DESCRIPTION that concatenates 'Distinct bust values: ' with the distinct count.",
    "natural_language": "Write a Oracle PL/SQL trigger named `trg_measurements_avg_bust` that, after each row is inserted into the MEASUREMENTS table, calculates the distinct count of all non-null BUST values and inserts a new record into the SIZE_UPDATES table with the following values: UPDATE_ID as the current row count of SIZE_UPDATES plus one, MEASUREMENT_ID as NULL, UPDATE_DATE as the current system date formatted as 'YYYY-MM-DD', UPDATED_BY as 0, UPDATE_REASON as 'STATS', and UPDATE_DESCRIPTION as the text 'Distinct bust values: ' followed by the calculated distinct count.",
    "id": 86,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_measurements_avg_bust that is defined to execute automatically after every successful insertion of a new row into the MEASUREMENTS table, where the trigger body first declares a local variable v_avg_bust of type NUMBER, then performs a SELECT statement that calculates the count of distinct, non-null values found in the BUST column of the MEASUREMENTS table and stores this result into the v_avg_bust variable, and subsequently executes an INSERT statement into the SIZE_UPDATES table, populating its columns with specific values: the UPDATE_ID column is set to the current total row count of the SIZE_UPDATES table plus one, obtained via a scalar subquery (SELECT COUNT(*) FROM SIZE_UPDATES) + 1; the MEASUREMENT_ID column is explicitly set to NULL; the UPDATE_DATE column is set to the current system date converted to a string in the 'YYYY-MM-DD' format using the TO_CHAR function with the SYSDATE parameter; the UPDATED_BY column is set to the numeric literal 0; the UPDATE_REASON column is set to the string literal 'STATS'; and the UPDATE_DESCRIPTION column is set to the concatenated string 'Distinct bust values: ' appended with the numeric value stored in the v_avg_bust variable.",
    "original_summary": "Create an AFTER INSERT row-level trigger named `trg_measurements_avg_bust` on the MEASUREMENTS table. It calculates the count of distinct non-null BUST values and inserts a record into SIZE_UPDATES. The inserted values are: UPDATE_ID as the total row count of SIZE_UPDATES plus one, NULL MEASUREMENT_ID, current date as 'YYYY-MM-DD', UPDATED_BY as 0, UPDATE_REASON as 'STATS', and UPDATE_DESCRIPTION as 'Distinct bust values: ' concatenated with the distinct count.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER INSERT row-level trigger, which should be named `trg_measurements_avg_bust`, specifically for the MEASUREMENTS table. This detailed trigger will meticulously compute the distinct count of all non-null BUST values and then, using that calculated figure, will proceed to insert a new and complete record directly into the SIZE_UPDATES table. The values to be carefully inserted are as follows: the UPDATE_ID should be derived by taking the total number of rows currently in the SIZE_UPDATES table and then adding one to that total; the MEASUREMENT_ID should be explicitly set to NULL; the current system date should be formatted precisely as 'YYYY-MM-DD'; the UPDATED_BY field should be populated with the constant value 0; the UPDATE_REASON should be clearly labeled as 'STATS'; and finally, the UPDATE_DESCRIPTION should be a concatenated string that begins with the literal text 'Distinct bust values: ' and is then seamlessly appended with the previously calculated distinct count."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_documentation that is defined to execute before any row is deleted from the DOCUMENTATION table, and for each row being deleted, the trigger declares a user-defined exception named child_rows_found and associates it with the Oracle error code -02292, then attempts to perform two delete operations: first, it deletes all rows from the COMPONENT_DOCUMENTATION_HISTORY table where the DOCUMENTATION_ID column matches the value of the DOCUMENTATION_ID column from the row currently being deleted from the DOCUMENTATION table, which is referenced as :OLD.DOCUMENTATION_ID, and second, it deletes all rows from the VERSIONS table where the DOCUMENTATION_ID column also matches the :OLD.DOCUMENTATION_ID value; if during the execution of these deletions the Oracle database raises the foreign key constraint violation error ORA-02292, which is trapped by the child_rows_found exception handler, the trigger then raises an application error with code -20001 and a message constructed by concatenating the string 'Cannot delete documentation record with ID ' with the value of :OLD.DOCUMENTATION_ID and the string '. Child records exist in other tables. Delete child records first.', thereby preventing the original delete operation on the DOCUMENTATION table from proceeding.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_documentation\nBEFORE DELETE ON DOCUMENTATION\nFOR EACH ROW\nDECLARE\n  child_rows_found EXCEPTION;\n  PRAGMA EXCEPTION_INIT(child_rows_found, -02292);\nBEGIN\n  -- Delete from known child tables based on schema\n  DELETE FROM COMPONENT_DOCUMENTATION_HISTORY WHERE DOCUMENTATION_ID = :OLD.DOCUMENTATION_ID;\n  \n  -- Delete from VERSIONS table based on the constraint name in the error\n  DELETE FROM VERSIONS WHERE DOCUMENTATION_ID = :OLD.DOCUMENTATION_ID;\n  \nEXCEPTION\n  WHEN child_rows_found THEN\n    RAISE_APPLICATION_ERROR(-20001, \n      'Cannot delete documentation record with ID ' || :OLD.DOCUMENTATION_ID || \n      '. Child records exist in other tables. Delete child records first.');\nEND;",
    "database_name": "electronic_csa_documentat",
    "tables": [
      "COMPONENTS",
      "DOCUMENTATION",
      "SPECIFICATIONS",
      "COMPONENT_DOCUMENTATION_HISTORY",
      "COMPONENT_SPECIFICATIONS_HISTORY"
    ],
    "call_sqls": [
      "DELETE FROM DOCUMENTATION WHERE DOCUMENTATION_ID = 0",
      "DELETE FROM DOCUMENTATION WHERE DOCUMENTATION_ID = 1",
      "INSERT INTO DOCUMENTATION (DOCUMENTATION_ID, COMPONENT_ID, DOCUMENT_TYPE, FILE_PATH, UPLOAD_DATE, VERSION, AUTHOR, LAST_UPDATED) VALUES (2, 0, 'datasheet', 'docs/1002_datasheet.pdf', '2023-01-01', '1.0', 'John Doe', '2023-05-01');\nDELETE FROM DOCUMENTATION WHERE DOCUMENTATION_ID = 2",
      "INSERT INTO DOCUMENTATION (DOCUMENTATION_ID, COMPONENT_ID, DOCUMENT_TYPE, FILE_PATH, UPLOAD_DATE, VERSION, AUTHOR, LAST_UPDATED) VALUES (3, 1, 'user manual', 'docs/1003_manual.pdf', '2023-02-01', '1.1', 'Jane Smith', '2023-05-01');\nDELETE FROM DOCUMENTATION WHERE DOCUMENTATION_ID = 3",
      "INSERT INTO DOCUMENTATION (DOCUMENTATION_ID, COMPONENT_ID, DOCUMENT_TYPE, FILE_PATH, UPLOAD_DATE, VERSION, AUTHOR, LAST_UPDATED) VALUES (4, 0, 'application note', 'docs/1004_appnote.pdf', '2023-03-01', '1.0', 'Alice Brown', '2023-05-01');\nDELETE FROM DOCUMENTATION WHERE DOCUMENTATION_ID = 4"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_delete_documentation that executes BEFORE DELETE on each row of the DOCUMENTATION table, which attempts to delete related records from the COMPONENT_DOCUMENTATION_HISTORY and VERSIONS tables using the DOCUMENTATION_ID of the row being deleted, and if any foreign key constraint violation occurs, raises an application error with a message indicating child records exist and prevents the deletion.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_delete_documentation that runs before each row is deleted from the DOCUMENTATION table, using the DOCUMENTATION_ID from the row being deleted to first remove any related records from the COMPONENT_DOCUMENTATION_HISTORY and VERSIONS tables, and if any child records still exist causing a foreign key constraint error, it should prevent the deletion by raising an application error with the message that child records are present.",
    "id": 87,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_delete_documentation`. This trigger is configured to execute `BEFORE` a `DELETE` operation is performed on the `DOCUMENTATION` table. It is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row being deleted from the `DOCUMENTATION` table.\n\nThe trigger's execution begins by performing two `DELETE` operations on related child tables. The first operation is `DELETE FROM COMPONENT_DOCUMENTATION_HISTORY WHERE DOCUMENTATION_ID = :OLD.DOCUMENTATION_ID;`. This statement deletes all rows from the `COMPONENT_DOCUMENTATION_HISTORY` table where the `DOCUMENTATION_ID` column matches the value of the `DOCUMENTATION_ID` column from the row currently being deleted from the `DOCUMENTATION` table (referenced as `:OLD.DOCUMENTATION_ID`). The second operation is `DELETE FROM VERSIONS WHERE DOCUMENTATION_ID = :OLD.DOCUMENTATION_ID;`. This statement deletes all rows from the `VERSIONS` table where the `DOCUMENTATION_ID` column matches the `:OLD.DOCUMENTATION_ID` value.\n\nFollowing these deletions, the trigger includes an `EXCEPTION` block to handle a specific error condition: `WHEN OTHERS THEN`. This block catches any exception that occurs during the execution of the preceding `DELETE` statements. Within this block, a conditional check is performed: `IF SQLCODE = -2292 THEN`. This condition checks if the Oracle error code of the caught exception is `-2292`, which corresponds to the error \"integrity constraint violated - child record found\". This error is raised when a foreign key constraint prevents the deletion of a parent record because child records still exist in a related table.\n\nIf the condition `SQLCODE = -2292` evaluates to `TRUE`, the trigger executes the `RAISE_APPLICATION_ERROR` procedure. This procedure is called with two parameters: the error number `-20001` and the error message string `'Cannot delete documentation record because child records are present in related tables.'`. This action prevents the original `DELETE` operation on the `DOCUMENTATION` table from completing and signals an application-level error to the calling environment, effectively enforcing referential integrity by ensuring that a documentation record cannot be deleted if related child records in other tables (beyond those explicitly deleted by the trigger) still exist and would cause a constraint violation.\n\nIf any other exception occurs (i.e., `SQLCODE` is not `-2292`), the `RAISE` statement is executed: `RAISE;`. This re-raises the original exception, allowing it to propagate to the calling environment for standard error handling.\n\nThe trigger concludes after this exception handling logic.",
    "original_summary": "Create a BEFORE DELETE row-level trigger named trg_delete_documentation on the DOCUMENTATION table. Before deleting each row, attempt to delete related records from COMPONENT_DOCUMENTATION_HISTORY and VERSIONS tables using :OLD.DOCUMENTATION_ID. If a foreign key constraint violation (ORA-02292) occurs, raise application error -20001 with a message indicating child records exist and prevent the deletion.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE DELETE row-level trigger designated as trg_delete_documentation for the DOCUMENTATION table. Prior to the deletion of each individual row, one must endeavor to delete associated records from the COMPONENT_DOCUMENTATION_HISTORY and VERSIONS tables by utilizing the :OLD.DOCUMENTATION_ID value. Should this action result in a foreign key constraint violation, specifically error ORA-02292, it is required to raise an application error numbered -20001. The accompanying message must state that child records are present, thereby precluding the deletion."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_department_budget that is automatically executed after any update operation on the SALARY column of the EMPLOYEES table for each individual row that is modified, and within its execution block, it performs an update on the DEPARTMENTS table, specifically setting the BUDGET column to a new calculated value by taking the existing BUDGET value, converting it from a string to a number using the TO_NUMBER function, then adding the numerical difference between the new SALARY value from the updated employee row (accessed via the :NEW.SALARY pseudorecord variable and converted to a number with TO_NUMBER) and the old SALARY value from the employee row before the update (accessed via the :OLD.SALARY pseudorecord variable and also converted to a number with TO_NUMBER), and finally converting the resulting sum back to a string using the TO_CHAR function, and this update is applied only to the department record in the DEPARTMENTS table where the DEPARTMENT_ID column matches the new DEPARTMENT_ID value from the updated employee row (accessed via the :NEW.DEPARTMENT_ID pseudorecord variable).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_department_budget\nAFTER UPDATE OF SALARY ON EMPLOYEES\nFOR EACH ROW\nBEGIN\n    UPDATE DEPARTMENTS\n    SET BUDGET = TO_CHAR(TO_NUMBER(BUDGET) + (TO_NUMBER(:NEW.SALARY) - TO_NUMBER(:OLD.SALARY)))\n    WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;\nEND;",
    "database_name": "human_rmaei_system",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOB_TITLES",
      "LOCATIONS",
      "USERS"
    ],
    "call_sqls": [
      "UPDATE EMPLOYEES SET SALARY = '55000.0' WHERE EMPLOYEE_ID = 0",
      "UPDATE EMPLOYEES SET SALARY = '65000.0' WHERE EMPLOYEE_ID = 1",
      "UPDATE EMPLOYEES SET SALARY = '52000.0' WHERE EMPLOYEE_ID = 0",
      "UPDATE EMPLOYEES SET SALARY = '70000.0' WHERE EMPLOYEE_ID = 1",
      "UPDATE EMPLOYEES SET SALARY = '60000.0' WHERE EMPLOYEE_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_department_budget that fires after an update to the SALARY column on the EMPLOYEES table, and for each updated row, updates the BUDGET in the DEPARTMENTS table by adding the difference between the new and old SALARY values to the existing BUDGET, converting BUDGET and salary values to numbers for the calculation and then converting the result back to a string, and only updates the department that matches the new DEPARTMENT_ID.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_department_budget that runs after any update to the SALARY column in the EMPLOYEES table. For each updated row, adjust the BUDGET in the DEPARTMENTS table by adding the difference between the new and old salary values, ensuring both BUDGET and salary are handled as numbers for the calculation before converting the result back to text. Only update the budget for the department matching the new DEPARTMENT_ID from the updated employee.",
    "id": 88,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_department_budget that is automatically executed after any update operation on the SALARY column of the EMPLOYEES table for each individual row that is modified, and within its execution block, it performs an update on the DEPARTMENTS table, specifically setting the BUDGET column to a new calculated value by taking the existing BUDGET value, converting it from a string to a number using the TO_NUMBER function, then adding the numerical difference between the new SALARY value from the updated employee row (accessed via the :NEW.SALARY pseudorecord variable and converted to a number with TO_NUMBER) and the old SALARY value from the employee row before the update (accessed via the :OLD.SALARY pseudorecord variable and also converted to a number with TO_NUMBER), and finally converting the resulting sum back to a string using the TO_CHAR function, and this update is applied only to the department record in the DEPARTMENTS table where the DEPARTMENT_ID column matches the new DEPARTMENT_ID value from the updated employee row (accessed via the :NEW.DEPARTMENT_ID pseudorecord variable).",
    "original_summary": "Create a trigger named trg_update_department_budget that fires after update of the SALARY column on the EMPLOYEES table. For each updated row, update the BUDGET in the DEPARTMENTS table by adding the difference between the new and old SALARY values. Convert BUDGET and salary values to numbers for the calculation, then convert the result back to a string. Update only the department matching the new DEPARTMENT_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, set up a trigger called trg_update_department_budget that kicks in after someone updates the SALARY field in the EMPLOYEES table. For every row that gets changed, you gotta adjust the BUDGET over in the DEPARTMENTS table. Just add the difference between the new salary and the old one. Make sure to treat both the BUDGET and salary as numbers when you do the math, then turn the final result back into text. Only update the budget for the department that matches the new DEPARTMENT_ID from the updated employee."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_log_user_access that activates after an insert operation on the USERS table, executing for each row inserted. The trigger begins by declaring several local variables: v_game_count and v_team_count of type NUMBER to store counts of games and teams, v_access_type of type VARCHAR2(255) to store the type of user access, and v_next_access_id of type NUMBER to store the next available access ID. The trigger first retrieves the next available ACCESS_ID by selecting the maximum ACCESS_ID from the ACCESS_LOGS table, using NVL to handle null values, and increments it by one, storing the result in v_next_access_id. It then counts the number of games associated with teams coached by the new user by selecting the count of rows from the GAMES table where TEAM_ID matches any TEAM_ID from the TEAMS table with COACH_NAME equal to the new user's USER_NAME, storing the result in v_game_count. Next, it counts the number of teams coached by the new user by selecting the count of rows from the TEAMS table where COACH_NAME matches the new user's USER_NAME, storing the result in v_team_count. The trigger then determines the access type based on the counts: if v_game_count is greater than 10, it sets v_access_type to 'High Activity Coach' and inserts a new row into the ACCESS_LOGS table with the calculated ACCESS_ID, the new user's USER_ID, the current date formatted as 'YYYY-MM-DD', the access type, a fixed IP address '192.168.1.1', a fixed user agent 'Browser', a fixed access duration of 300 seconds, and a fixed data size of 1024 bytes. If v_game_count is not greater than 10 but v_team_count is greater than 0, it sets v_access_type to 'Regular Coach' and inserts a new row into the ACCESS_LOGS table with similar values but with a different IP address '192.168.1.2', a different access duration of 180 seconds, and a different data size of 512 bytes. If neither condition is met, it sets v_access_type to 'New User' and inserts a new row into the ACCESS_LOGS table with yet another IP address '192.168.1.3', an access duration of 60 seconds, and a data size of 256 bytes. The trigger includes an exception handler that silently handles any errors to prevent the trigger from failing.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_log_user_access\nAFTER INSERT ON USERS\nFOR EACH ROW\nDECLARE\n  v_game_count NUMBER;\n  v_team_count NUMBER;\n  v_access_type VARCHAR2(255);\n  v_next_access_id NUMBER;\nBEGIN\n  -- Get next available ACCESS_ID\n  SELECT NVL(MAX(ACCESS_ID), 0) + 1 INTO v_next_access_id FROM ACCESS_LOGS;\n  \n  -- Count games for teams coached by this user\n  SELECT COUNT(*) INTO v_game_count \n  FROM GAMES \n  WHERE TEAM_ID IN (SELECT TEAM_ID FROM TEAMS WHERE COACH_NAME = :NEW.USER_NAME);\n  \n  -- Count teams coached by this user\n  SELECT COUNT(*) INTO v_team_count \n  FROM TEAMS \n  WHERE COACH_NAME = :NEW.USER_NAME;\n  \n  -- Determine access type and insert log entry\n  IF v_game_count > 10 THEN\n    v_access_type := 'High Activity Coach';\n    INSERT INTO ACCESS_LOGS (ACCESS_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, ACCESS_DURATION, DATA_SIZE) \n    VALUES (v_next_access_id, :NEW.USER_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), v_access_type, '192.168.1.1', 'Browser', 300, 1024);\n  ELSIF v_team_count > 0 THEN\n    v_access_type := 'Regular Coach';\n    INSERT INTO ACCESS_LOGS (ACCESS_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, ACCESS_DURATION, DATA_SIZE) \n    VALUES (v_next_access_id, :NEW.USER_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), v_access_type, '192.168.1.2', 'Browser', 180, 512);\n  ELSE\n    v_access_type := 'New User';\n    INSERT INTO ACCESS_LOGS (ACCESS_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, ACCESS_DURATION, DATA_SIZE) \n    VALUES (v_next_access_id, :NEW.USER_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), v_access_type, '192.168.1.3', 'Browser', 60, 256);\n  END IF;\nEXCEPTION\n  WHEN OTHERS THEN\n    NULL; -- Silently handle any errors to prevent trigger failure\nEND;",
    "database_name": "sports_tpa_analytics",
    "tables": [
      "ACCESS_LOGS",
      "EVENTS",
      "GAMES",
      "OPPONENTS",
      "RATINGS",
      "TEAMS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, PHONE_NUMBER, ADDRESS, DATE_JOINED, LAST_LOGIN, STATUS) VALUES (0, 'John Doe', 'john.doe@iupui.edu', 'coach', '123-456-7890', '123 Main St, Indianapolis, IN', '2022-01-01', '2023-05-01 10:00:00', 'active')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, PHONE_NUMBER, ADDRESS, DATE_JOINED, LAST_LOGIN, STATUS) VALUES (1, 'Jane Smith', 'jane.smith@iupui.edu', 'analyst', '098-765-4321', '456 Elm St, Indianapolis, IN', '2022-02-01', '2023-05-02 11:00:00', 'active')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, PHONE_NUMBER, ADDRESS, DATE_JOINED, LAST_LOGIN, STATUS) VALUES (2, 'Alice Johnson', 'alice.johnson@iupui.edu', 'coach', '111-222-3333', '789 Oak St, Indianapolis, IN', '2023-01-01', '2023-06-01 09:00:00', 'active')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, PHONE_NUMBER, ADDRESS, DATE_JOINED, LAST_LOGIN, STATUS) VALUES (3, 'Bob Brown', 'bob.brown@iupui.edu', 'analyst', '444-555-6666', '321 Pine St, Indianapolis, IN', '2023-02-01', '2023-06-02 10:00:00', 'active')",
      "INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, PHONE_NUMBER, ADDRESS, DATE_JOINED, LAST_LOGIN, STATUS) VALUES (4, 'Charlie Green', 'charlie.green@iupui.edu', 'coach', '777-888-9999', '654 Maple St, Indianapolis, IN', '2023-03-01', '2023-06-03 11:00:00', 'active')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_log_user_access that fires after each new row is inserted into the USERS table. For each new user, it should calculate the number of games in the GAMES table for teams they coach (based on matching COACH_NAME in TEAMS to the new USER_NAME) and the number of teams they coach from the TEAMS table. Based on these counts: if the game count exceeds 10, assign an access type of 'High Activity Coach'; if the team count is greater than 0, assign 'Regular Coach'; otherwise, assign 'New User'. Then, insert a record into the ACCESS_LOGS table with a generated ACCESS_ID (the next sequential ID from existing ACCESS_LOGS), the new USER_ID, the current date, the determined access type, and predefined values for IP_ADDRESS, USER_AGENT, ACCESS_DURATION, and DATA_SIZE (specific values vary by access type). Handle any errors silently to prevent trigger failure.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_log_user_access that fires AFTER INSERT on the USERS table for each new row. For every inserted user, determine their access type by counting the number of games in the GAMES table for teams they coach (where COACH_NAME in TEAMS matches the new USER_NAME) and the number of teams they coach in the TEAMS table. If the game count exceeds 10, assign 'High Activity Coach'; if the team count is greater than 0, assign 'Regular Coach'; otherwise, assign 'New User'. Then, insert a record into the ACCESS_LOGS table with a generated ACCESS_ID (based on the maximum existing ACCESS_ID plus one), the new USER_ID, today's date, the assigned access type, and predefined values for IP_ADDRESS, USER_AGENT, ACCESS_DURATION, and DATA_SIZE. Include an exception handler to silently ignore any errors.",
    "id": 89,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_log_user_access` that is designed to execute automatically after an `INSERT` operation is performed on the `USERS` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its body will be executed once for every individual row that is successfully inserted into the `USERS` table. The trigger's primary purpose is to analyze the newly inserted user's profile, determine an access type classification, and log this information into an `ACCESS_LOGS` table.\n\nThe trigger begins by declaring several local variables. It declares a variable to store the count of games associated with teams the new user coaches, a variable to store the count of teams the new user coaches, a variable to hold the calculated maximum `ACCESS_ID` from the `ACCESS_LOGS` table, a variable to store the determined access type classification as a string, and a variable to hold today's date.\n\nFor each newly inserted row in the `USERS` table, the trigger performs two distinct `SELECT` queries using the `INTO` clause to populate the count variables. First, it executes a `SELECT COUNT(*)` query on the `GAMES` table. This query joins the `GAMES` table with the `TEAMS` table on the condition that `GAMES.TEAM_ID` equals `TEAMS.TEAM_ID`. It includes a `WHERE` clause that filters the results to only count games where the `TEAMS.COACH_NAME` column matches the `USER_NAME` value of the newly inserted user row, referenced as `:NEW.USER_NAME`. The result of this count is stored in the game count variable.\n\nSecond, it executes another `SELECT COUNT(*)` query, this time directly on the `TEAMS` table. The `WHERE` clause filters for rows where the `TEAMS.COACH_NAME` column matches the `:NEW.USER_NAME`. The result is stored in the team count variable.\n\nFollowing the data retrieval, the trigger implements a conditional logic block using `IF / ELSIF / ELSE` statements to determine the user's access type based on the calculated counts. The logic is evaluated in sequence: if the game count variable is greater than 10, the access type variable is assigned the string literal `'High Activity Coach'`. If the first condition is false but the team count variable is greater than 0, the access type variable is assigned `'Regular Coach'`. If neither of the previous conditions are met, the access type variable is assigned `'New User'`.\n\nNext, the trigger prepares to insert a record into the `ACCESS_LOGS` table. It first executes a `SELECT NVL(MAX(ACCESS_ID), 0) + 1` query on the `ACCESS_LOGS` table to generate a new primary key value. This query finds the maximum existing `ACCESS_ID`, uses the `NVL` function to convert a potential `NULL` result (if the table is empty) to 0, and then adds 1 to this value. The result is stored in the variable for the new access ID.\n\nThe trigger then performs an `INSERT` operation into the `ACCESS_LOGS` table. The values for the insert are constructed as follows: the new access ID variable is used for the `ACCESS_ID` column; the `USER_ID` from the newly inserted user row (`:NEW.USER_ID`) is used for the `USER_ID` column; today's date variable (populated by calling the `TRUNC(SYSDATE)` function to get the date without a time component) is used for the `ACCESS_DATE` column; the calculated access type variable is used for the `ACCESS_TYPE` column. For the remaining columns—`IP_ADDRESS`, `USER_AGENT`, `ACCESS_DURATION`, and `DATA_SIZE`—the trigger inserts predefined, hard-coded literal values as specified in the requirement.\n\nThe entire block of code is wrapped within a `BEGIN ... EXCEPTION ... END` structure to implement an exception handler. The `EXCEPTION` section is configured with a `WHEN OTHERS THEN` clause, which is designed to catch any and all exceptions that occur during the execution of the trigger's main logic block. The handler contains a `NULL` statement, meaning that if any error (such as a `NO_DATA_FOUND` exception from the `SELECT ... INTO` statements, a `DUP_VAL_ON_INDEX` exception from the insert, or any other) is raised, the trigger will take no action and silently proceed, effectively ignoring the error without logging it or raising it to the calling context.",
    "original_summary": "Create an AFTER INSERT row-level trigger named trg_log_user_access on the USERS table. For each new user, calculate the count of games for teams they coach and the count of teams they coach. Determine an access type based on these counts ('High Activity Coach', 'Regular Coach', or 'New User'). Insert a corresponding record into the ACCESS_LOGS table with a generated ACCESS_ID, the user's ID, current date, the determined access type, and predefined values for IP, user agent, duration, and data size. Include an exception handler to silently handle any errors.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a row-level trigger called trg_log_user_access that fires AFTER INSERT on the USERS table. For every new user inserted, compute the number of games for the teams they coach and the number of teams they coach. Based on these counts, assign an access type of 'High Activity Coach', 'Regular Coach', or 'New User'. Then, insert a new row into the ACCESS_LOGS table. Populate the row with a generated ACCESS_ID, the new user's ID, today's date, the assigned access type, and these predefined values: IP, user agent, duration, and data size. Also, include an exception handler to catch and ignore any errors silently."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_nucleus_intensity_ratio` that is activated `AFTER` any `INSERT` or `UPDATE` operation on the `NUCLEUS_METRICS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row affected by the `INSERT` or `UPDATE` statement. Upon activation for a specific row, the trigger first declares a local variable `v_cell_intensity` of data type `NUMBER` to temporarily store a numeric value. It then performs a `SELECT` operation to retrieve the `CELL_INTENSITY` column value from the `CELL_METRICS` table. This `SELECT` statement includes a `WHERE` clause that filters the `CELL_METRICS` table to find the row where the `SAMPLE_ID` column matches the `SAMPLE_ID` value of the row currently being processed in the `NUCLEUS_METRICS` table (referenced as `:NEW.SAMPLE_ID`). The retrieved `CELL_INTENSITY` value is then stored into the `v_cell_intensity` variable. Following this, the trigger evaluates a conditional `IF` statement: it checks if the `v_cell_intensity` variable `IS NOT NULL`. If `v_cell_intensity` contains a non-null value, the trigger proceeds to execute an `UPDATE` operation on the `NUCLEUS_CELL_RATIO` table. This `UPDATE` statement sets the `NUCLEUS_INTENSITY_RATIO` column to the result of a division operation: the `NUCLEUS_INTENSITY` value of the newly inserted or updated row in `NUCLEUS_METRICS` (referenced as `:NEW.NUCLEUS_INTENSITY`) divided by the `v_cell_intensity` value previously retrieved. The `UPDATE` operation on `NUCLEUS_CELL_RATIO` is constrained by a `WHERE` clause, ensuring that only the row where the `SAMPLE_ID` column matches the `SAMPLE_ID` value of the current `NUCLEUS_METRICS` row (referenced as `:NEW.SAMPLE_ID`) is modified. If the `v_cell_intensity` variable is `NULL`, the `IF` condition evaluates to false, and the `UPDATE` operation on `NUCLEUS_CELL_RATIO` is skipped for that particular row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_nucleus_intensity_ratio\nAFTER INSERT OR UPDATE ON NUCLEUS_METRICS\nFOR EACH ROW\nDECLARE\n    v_cell_intensity NUMBER;\nBEGIN\n    SELECT CELL_INTENSITY INTO v_cell_intensity FROM CELL_METRICS WHERE SAMPLE_ID = :NEW.SAMPLE_ID;\n    IF v_cell_intensity IS NOT NULL THEN\n        UPDATE NUCLEUS_CELL_RATIO\n        SET NUCLEUS_INTENSITY_RATIO = :NEW.NUCLEUS_INTENSITY / v_cell_intensity\n        WHERE SAMPLE_ID = :NEW.SAMPLE_ID;\n    END IF;\nEND;",
    "database_name": "biological_saa_metrics",
    "tables": [
      "CELL_METRICS",
      "CYTOPLASM_METRICS",
      "NUCLEUS_CELL_RATIO",
      "NUCLEUS_METRICS",
      "NUCLEUS_OD_METRICS",
      "SAMPLES"
    ],
    "call_sqls": [
      "INSERT INTO NUCLEUS_METRICS (NUCLEUS_ID, SAMPLE_ID, AREA, PERIMETER, CIRCULARITY, MAX_CALIPER, MIN_CALIPER, ECCENTRICITY, NUCLEUS_VOLUME, NUCLEUS_SHAPE, NUCLEUS_TEXTURE, NUCLEUS_INTENSITY, NUCLEUS_AREA_STD_DEV) \nVALUES (2, 1, 23.5, 20.5, 0.71, 8.5, 4.3, 0.89, 160, 'Spherical', 'Smooth', 0.78, 2.1)",
      "INSERT INTO NUCLEUS_METRICS (NUCLEUS_ID, SAMPLE_ID, AREA, PERIMETER, CIRCULARITY, MAX_CALIPER, MIN_CALIPER, ECCENTRICITY, NUCLEUS_VOLUME, NUCLEUS_SHAPE, NUCLEUS_TEXTURE, NUCLEUS_INTENSITY, NUCLEUS_AREA_STD_DEV) \nVALUES (3, 0, 27.0, 22.0, 0.73, 8.0, 5.0, 0.80, 170, 'Ellipsoidal', 'Granular', 0.76, 2.3)",
      "UPDATE NUCLEUS_METRICS \nSET NUCLEUS_INTENSITY = 0.82 \nWHERE NUCLEUS_ID = 0",
      "UPDATE NUCLEUS_METRICS \nSET NUCLEUS_INTENSITY = 0.77 \nWHERE NUCLEUS_ID = 1",
      "INSERT INTO NUCLEUS_METRICS (NUCLEUS_ID, SAMPLE_ID, AREA, PERIMETER, CIRCULARITY, MAX_CALIPER, MIN_CALIPER, ECCENTRICITY, NUCLEUS_VOLUME, NUCLEUS_SHAPE, NUCLEUS_TEXTURE, NUCLEUS_INTENSITY, NUCLEUS_AREA_STD_DEV) \nVALUES (4, 1, 24.0, 21.0, 0.72, 8.2, 4.5, 0.85, 165, 'Spherical', 'Smooth', 0.79, 2.2)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_nucleus_intensity_ratio that fires after each insert or update on the NUCLEUS_METRICS table, and for each affected row, retrieves the CELL_INTENSITY from the CELL_METRICS table where the SAMPLE_ID matches the new SAMPLE_ID; if a CELL_INTENSITY value is found, it updates the NUCLEUS_CELL_RATIO table by setting the NUCLEUS_INTENSITY_RATIO to the new NUCLEUS_INTENSITY divided by that retrieved value for the matching SAMPLE_ID.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_nucleus_intensity_ratio that, after each new or updated row in the NUCLEUS_METRICS table, retrieves the matching CELL_INTENSITY from CELL_METRICS for the same SAMPLE_ID. If a value is found, update the NUCLEUS_CELL_RATIO table by setting the NUCLEUS_INTENSITY_RATIO to the new nucleus intensity divided by that retrieved cell intensity for the same sample.",
    "id": 90,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_update_nucleus_intensity_ratio` that is activated `AFTER` any `INSERT` or `UPDATE` operation on the `NUCLEUS_METRICS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row affected by the `INSERT` or `UPDATE` statement. Upon activation for a specific row, the trigger first declares a local variable `v_cell_intensity` of data type `NUMBER` to temporarily store a numeric value. It then performs a `SELECT` operation to retrieve the `CELL_INTENSITY` column value from the `CELL_METRICS` table. This `SELECT` statement includes a `WHERE` clause that filters the `CELL_METRICS` table to find the row where the `SAMPLE_ID` column matches the `SAMPLE_ID` value of the row currently being processed in the `NUCLEUS_METRICS` table (referenced as `:NEW.SAMPLE_ID`). The retrieved `CELL_INTENSITY` value is then stored into the `v_cell_intensity` variable. Following this, the trigger evaluates a conditional `IF` statement: it checks if the `v_cell_intensity` variable `IS NOT NULL`. If `v_cell_intensity` contains a non-null value, the trigger proceeds to execute an `UPDATE` operation on the `NUCLEUS_CELL_RATIO` table. This `UPDATE` statement sets the `NUCLEUS_INTENSITY_RATIO` column to the result of a division operation: the `NUCLEUS_INTENSITY` value of the newly inserted or updated row in `NUCLEUS_METRICS` (referenced as `:NEW.NUCLEUS_INTENSITY`) divided by the `v_cell_intensity` value previously retrieved. The `UPDATE` operation on `NUCLEUS_CELL_RATIO` is constrained by a `WHERE` clause, ensuring that only the row where the `SAMPLE_ID` column matches the `SAMPLE_ID` value of the current `NUCLEUS_METRICS` row (referenced as `:NEW.SAMPLE_ID`) is modified. If the `v_cell_intensity` variable is `NULL`, the `IF` condition evaluates to false, and the `UPDATE` operation on `NUCLEUS_CELL_RATIO` is skipped for that particular row.",
    "original_summary": "Create an AFTER INSERT OR UPDATE row-level trigger named trg_update_nucleus_intensity_ratio on the NUCLEUS_METRICS table. For each row, retrieve the CELL_INTENSITY from CELL_METRICS where SAMPLE_ID matches :NEW.SAMPLE_ID. If the retrieved value is not null, update the NUCLEUS_CELL_RATIO table, setting NUCLEUS_INTENSITY_RATIO to :NEW.NUCLEUS_INTENSITY divided by the retrieved value, for the row with the matching SAMPLE_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "For each new or updated row in the NUCLEUS_METRICS table, retrieve the matching CELL_INTENSITY from CELL_METRICS. If a value is found, update the NUCLEUS_CELL_RATIO table by setting the NUCLEUS_INTENSITY_RATIO to the new nucleus intensity divided by that retrieved value for the same sample. Implement this logic in an AFTER INSERT OR UPDATE row-level trigger named trg_update_nucleus_intensity_ratio."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_ADJUST_REMOTE_RATIO that is executed before an insert or update operation on the JOB_MARKET_DATA table for each row. The trigger begins by declaring three local variables: v_flexibility of type VARCHAR2(255) initialized to 'Medium', v_min_years and v_max_years of type NUMBER both initialized to 0, and v_avg_salary of type NUMBER initialized to 0. The trigger then performs a series of operations to retrieve and assign values to these variables. First, it attempts to select the FLEXIBILITY column from the EMPLOYMENT_TYPES table where the TYPE_NAME matches the :NEW.EMPLOYMENT_TYPE value, storing the result in v_flexibility. If no data is found, it defaults v_flexibility to 'Medium'. Next, it selects MIN_YEARS_EXPERIENCE and MAX_YEARS_EXPERIENCE from the EXPERIENCE_LEVELS table where LEVEL_NAME matches :NEW.EXPERIENCE_LEVEL, storing the results in v_min_years and v_max_years respectively, defaulting both to 0 if no data is found. Then, it calculates the average salary by selecting the average of the SALARY_IN_USD column from the JOB_MARKET_DATA table where JOB_TITLE matches :NEW.JOB_TITLE, storing the result in v_avg_salary, defaulting to 0 if no data is found. The trigger then applies business logic using conditional statements to set the :NEW.REMOTE_RATIO value based on the retrieved data: if v_flexibility is 'High' and v_min_years is less than 2, it sets :NEW.REMOTE_RATIO to 100; if v_flexibility is 'Medium' and v_max_years is greater than 5, it sets :NEW.REMOTE_RATIO to 50; if v_avg_salary is greater than 100000 and v_min_years is between 3 and 5, it sets :NEW.REMOTE_RATIO to 75; if v_flexibility is 'Low' or v_max_years is less than 1, it sets :NEW.REMOTE_RATIO to 0; otherwise, it sets :NEW.REMOTE_RATIO to 25.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_ADJUST_REMOTE_RATIO\nBEFORE INSERT OR UPDATE ON JOB_MARKET_DATA\nFOR EACH ROW\nDECLARE\n    v_flexibility VARCHAR2(255) := 'Medium';\n    v_min_years NUMBER := 0;\n    v_max_years NUMBER := 0;\n    v_avg_salary NUMBER := 0;\nBEGIN\n    -- Get flexibility with exception handling\n    BEGIN\n        SELECT FLEXIBILITY INTO v_flexibility \n        FROM EMPLOYMENT_TYPES \n        WHERE TYPE_NAME = :NEW.EMPLOYMENT_TYPE;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_flexibility := 'Medium';\n    END;\n    \n    -- Get experience levels with exception handling\n    BEGIN\n        SELECT MIN_YEARS_EXPERIENCE, MAX_YEARS_EXPERIENCE \n        INTO v_min_years, v_max_years \n        FROM EXPERIENCE_LEVELS \n        WHERE LEVEL_NAME = :NEW.EXPERIENCE_LEVEL;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_min_years := 0;\n            v_max_years := 0;\n    END;\n    \n    -- Get average salary with exception handling\n    BEGIN\n        SELECT NVL(AVG(SALARY_IN_USD), 0) INTO v_avg_salary \n        FROM JOB_MARKET_DATA \n        WHERE JOB_TITLE = :NEW.JOB_TITLE;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_avg_salary := 0;\n    END;\n    \n    -- Apply business logic\n    IF v_flexibility = 'High' AND v_min_years < 2 THEN\n        :NEW.REMOTE_RATIO := 100;\n    ELSIF v_flexibility = 'Medium' AND v_max_years > 5 THEN\n        :NEW.REMOTE_RATIO := 50;\n    ELSIF v_avg_salary > 100000 AND v_min_years BETWEEN 3 AND 5 THEN\n        :NEW.REMOTE_RATIO := 75;\n    ELSIF v_flexibility = 'Low' OR v_max_years < 1 THEN\n        :NEW.REMOTE_RATIO := 0;\n    ELSE\n        :NEW.REMOTE_RATIO := 25;\n    END IF;\nEND;",
    "database_name": "job_mdaae_trends",
    "tables": [
      "JOB_MARKET_DATA",
      "COMPANY_LOCATIONS",
      "COMPANY_SIZES",
      "EMPLOYMENT_TYPES",
      "EXPERIENCE_LEVELS"
    ],
    "call_sqls": [
      "INSERT INTO JOB_MARKET_DATA (DATA_ID, WORK_YEAR, EXPERIENCE_LEVEL, EMPLOYMENT_TYPE, JOB_TITLE, SALARY_IN_USD) VALUES (1001, '2024', 'EN', 'Full-time', 'Data Analyst', 85000)",
      "INSERT INTO JOB_MARKET_DATA (DATA_ID, WORK_YEAR, EXPERIENCE_LEVEL, EMPLOYMENT_TYPE, JOB_TITLE, SALARY_IN_USD) VALUES (1002, '2024', 'SE', 'Contract', 'Senior Software Engineer', 120000)",
      "UPDATE JOB_MARKET_DATA SET EXPERIENCE_LEVEL = 'MI', EMPLOYMENT_TYPE = 'Part-time' WHERE DATA_ID = 1001",
      "INSERT INTO JOB_MARKET_DATA (DATA_ID, WORK_YEAR, EXPERIENCE_LEVEL, EMPLOYMENT_TYPE, JOB_TITLE, SALARY_IN_USD) VALUES (1003, '2024', 'EX', 'Freelance', 'Machine Learning Engineer', 150000)",
      "UPDATE JOB_MARKET_DATA SET JOB_TITLE = 'Lead Data Scientist', SALARY_IN_USD = 180000 WHERE DATA_ID = 1002"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_ADJUST_REMOTE_RATIO that fires BEFORE INSERT OR UPDATE on each row of the JOB_MARKET_DATA table to set the new REMOTE_RATIO value based on business rules. The trigger determines the value by checking the employment type's flexibility from the EMPLOYMENT_TYPES table (defaulting to 'Medium' if not found), the experience level's minimum and maximum years from the EXPERIENCE_LEVELS table (defaulting to 0 if not found), and the average salary for the job title from JOB_MARKET_DATA (defaulting to 0 if not found). It sets REMOTE_RATIO to 100 if flexibility is 'High' and minimum years is less than 2; to 50 if flexibility is 'Medium' and maximum years is greater than 5; to 75 if the average salary is over 100000 and minimum years is between 3 and 5; to 0 if flexibility is 'Low' or maximum years is less than 1; otherwise, it sets it to 25.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_ADJUST_REMOTE_RATIO that fires BEFORE INSERT OR UPDATE on each row of the JOB_MARKET_DATA table to set the new REMOTE_RATIO based on business rules, using default values if related data is not found. The trigger should retrieve the flexibility from the EMPLOYMENT_TYPES table for the new EMPLOYMENT_TYPE (defaulting to 'Medium' if not found), the minimum and maximum years from the EXPERIENCE_LEVELS table for the new EXPERIENCE_LEVEL (defaulting both to 0 if not found), and the average salary from JOB_MARKET_DATA for the new JOB_TITLE (defaulting to 0 if not found). Then, apply these rules: if flexibility is 'High' and minimum years is less than 2, set REMOTE_RATIO to 100; else if flexibility is 'Medium' and maximum years is greater than 5, set it to 50; else if average salary is over 100000 and minimum years is between 3 and 5, set it to 75; else if flexibility is 'Low' or maximum years is less than 1, set it to 0; otherwise, set it to 25.",
    "id": 91,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_ADJUST_REMOTE_RATIO that is executed before an insert or update operation on the JOB_MARKET_DATA table for each row. The trigger begins by declaring three local variables: v_flexibility of type VARCHAR2(255) initialized to 'Medium', v_min_years and v_max_years of type NUMBER both initialized to 0, and v_avg_salary of type NUMBER initialized to 0. The trigger then performs a series of operations to retrieve and assign values to these variables. First, it attempts to select the FLEXIBILITY column from the EMPLOYMENT_TYPES table where the TYPE_NAME matches the :NEW.EMPLOYMENT_TYPE value, storing the result in v_flexibility. If no data is found, it defaults v_flexibility to 'Medium'. Next, it selects MIN_YEARS_EXPERIENCE and MAX_YEARS_EXPERIENCE from the EXPERIENCE_LEVELS table where LEVEL_NAME matches :NEW.EXPERIENCE_LEVEL, storing the results in v_min_years and v_max_years respectively, defaulting both to 0 if no data is found. Then, it calculates the average salary by selecting the average of the SALARY_IN_USD column from the JOB_MARKET_DATA table where JOB_TITLE matches :NEW.JOB_TITLE, storing the result in v_avg_salary, defaulting to 0 if no data is found. The trigger then applies business logic using conditional statements to set the :NEW.REMOTE_RATIO value based on the retrieved data: if v_flexibility is 'High' and v_min_years is less than 2, it sets :NEW.REMOTE_RATIO to 100; if v_flexibility is 'Medium' and v_max_years is greater than 5, it sets :NEW.REMOTE_RATIO to 50; if v_avg_salary is greater than 100000 and v_min_years is between 3 and 5, it sets :NEW.REMOTE_RATIO to 75; if v_flexibility is 'Low' or v_max_years is less than 1, it sets :NEW.REMOTE_RATIO to 0; otherwise, it sets :NEW.REMOTE_RATIO to 25.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_ADJUST_REMOTE_RATIO on the JOB_MARKET_DATA table. For each row, set the new REMOTE_RATIO based on the following logic: If the employment type's flexibility is 'High' and the experience level's minimum years is less than 2, set it to 100. Else if flexibility is 'Medium' and maximum years is greater than 5, set it to 50. Else if the average salary for the job title is over 100000 and minimum years is between 3 and 5, set it to 75. Else if flexibility is 'Low' or maximum years is less than 1, set it to 0. Otherwise, set it to 25. Retrieve flexibility from EMPLOYMENT_TYPES, experience years from EXPERIENCE_LEVELS, and average salary from JOB_MARKET_DATA, using default values if data is not found.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How should the BEFORE INSERT OR UPDATE row-level trigger named TRG_ADJUST_REMOTE_RATIO be created on the JOB_MARKET_DATA table to set the new REMOTE_RATIO for each row? The logic is: if the employment type's flexibility from the EMPLOYMENT_TYPES table is 'High' and the experience level's minimum years from the EXPERIENCE_LEVELS table is less than 2, set it to 100. Otherwise, if flexibility is 'Medium' and maximum years is greater than 5, set it to 50. Otherwise, if the average salary for the job title from JOB_MARKET_DATA is over 100000 and minimum years is between 3 and 5, set it to 75. Otherwise, if flexibility is 'Low' or maximum years is less than 1, set it to 0. In all other cases, set it to 25. What default values should be used if the data is not found?"
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_access_logs_validation that is executed before an insert operation on the ACCESS_LOGS table for each row. The trigger declares four local variables: v_user_exists, v_record_exists, v_region_id, and v_temp_report_id, all of type NUMBER. It first checks if the USER_ID from the new row being inserted exists in the USERS table by counting the number of rows with a matching USER_ID and storing the result in v_user_exists. Similarly, it checks if the RECORD_ID from the new row exists in the CLIMATE_DATA table, storing the count in v_record_exists. If v_user_exists is zero, indicating the USER_ID does not exist, the trigger sets the USER_ID of the new row to 0 and inserts a new row into the REPORTS table with a generated REPORT_ID, a REPORT_NAME of 'Invalid User Access', the current date as GENERATED_DATE, a USER_ID of 0, a CONTENT message indicating an access attempt with an invalid user, and a STATUS of 'error'. If v_record_exists is zero, indicating the RECORD_ID does not exist, the trigger sets the RECORD_ID of the new row to NULL, retrieves a REGION_ID from the REGIONS table (taking the first row), and inserts a new row into the CLIMATE_DATA table with a generated RECORD_ID, default values for various columns, the current date's day, month, and year, and the retrieved REGION_ID. If the STATUS_CODE of the new row is 400 or greater, the trigger generates a new REPORT_ID, inserts a new row into the REPORTS table with this REPORT_ID, a REPORT_NAME of 'Error Access Log', the current date as GENERATED_DATE, the USER_ID from the new row, a CONTENT message indicating an error status code was detected, and a STATUS of 'warning', shared with users '1,2'. If none of these conditions are met, the trigger updates the LAST_LOGIN column in the USERS table for the matching USER_ID with the current timestamp and inserts a new row into the MODEL_PARAMETERS table with a generated PARAMETER_ID, specified values for various model parameters, a MODEL_NAME of 'AccessLogModel', a MODEL_VERSION of 'v1.0', the current timestamp as CREATED_AT, and the USER_ID from the new row as CREATED_BY.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_access_logs_validation\nBEFORE INSERT ON ACCESS_LOGS\nFOR EACH ROW\nDECLARE\n    v_user_exists NUMBER;\n    v_record_exists NUMBER;\n    v_region_id NUMBER;\n    v_temp_report_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_user_exists FROM USERS WHERE USER_ID = :NEW.USER_ID;\n    SELECT COUNT(*) INTO v_record_exists FROM CLIMATE_DATA WHERE RECORD_ID = :NEW.RECORD_ID;\n    IF v_user_exists = 0 THEN\n        :NEW.USER_ID := 0;\n        INSERT INTO REPORTS (REPORT_ID, REPORT_NAME, GENERATED_DATE, USER_ID, CONTENT, DATASET_ID, REGION_ID, STATUS, SHARED_WITH)\n        VALUES ((SELECT NVL(MAX(REPORT_ID), 0) + 1 FROM REPORTS), 'Invalid User Access', TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), 0, 'Access attempted with invalid user', NULL, NULL, 'error', NULL);\n    ELSIF v_record_exists = 0 THEN\n        :NEW.RECORD_ID := NULL;\n        SELECT REGION_ID INTO v_region_id FROM REGIONS WHERE ROWNUM = 1;\n        INSERT INTO CLIMATE_DATA (RECORD_ID, ANOMALY_RAINFALL, AREA, DAY, FCG, FATALITIES, LATITUDE, LONGITUDE, MONTH, NDVI, POPULATION, CEREAL_PRICE, RAINFALL_MM, RAMADAN, WATERWAYS, YEAR, TEMPERATURE, HUMIDITY, WIND_SPEED, PRECIPITATION_TYPE, SOIL_MOISTURE, CROP_TYPE, REGION_ID)\n        VALUES ((SELECT NVL(MAX(RECORD_ID), 0) + 1 FROM CLIMATE_DATA), 0, 100, EXTRACT(DAY FROM CURRENT_DATE), 1, 0, 40.0, -100.0, EXTRACT(MONTH FROM CURRENT_DATE), 0.5, 1000, 2.5, 100, 0, 1, EXTRACT(YEAR FROM CURRENT_DATE), 20, 70, 5, 'rain', 0.4, 'wheat', v_region_id);\n    ELSIF :NEW.STATUS_CODE >= 400 THEN\n        SELECT NVL(MAX(REPORT_ID), 0) + 1 INTO v_temp_report_id FROM REPORTS;\n        INSERT INTO REPORTS (REPORT_ID, REPORT_NAME, GENERATED_DATE, USER_ID, CONTENT, DATASET_ID, REGION_ID, STATUS, SHARED_WITH)\n        VALUES (v_temp_report_id, 'Error Access Log', TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), :NEW.USER_ID, 'Error status code detected', NULL, NULL, 'warning', '1,2');\n    ELSE\n        UPDATE USERS SET LAST_LOGIN = TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') WHERE USER_ID = :NEW.USER_ID;\n        INSERT INTO MODEL_PARAMETERS (PARAMETER_ID, LEARNING_RATE, MAX_DEPTH, MIN_CHILD_WEIGHT, N_ESTIMATORS, GAMMA, COLSAMPLE_BYTREE, SUBSAMPLE, MODEL_NAME, MODEL_VERSION, CREATED_AT, CREATED_BY)\n        VALUES ((SELECT NVL(MAX(PARAMETER_ID), 0) + 1 FROM MODEL_PARAMETERS), 0.01, 5, 1, 100, 0, 1, 1, 'AccessLogModel', 'v1.0', TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'), :NEW.USER_ID);\n    END IF;\nEND;",
    "database_name": "climate_daa_prediction",
    "tables": [
      "ACCESS_LOGS",
      "CLIMATE_DATA",
      "DATASETS",
      "MODEL_PARAMETERS",
      "MODEL_PERFORMANCE",
      "REGIONS",
      "REPORTS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, RECORD_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, STATUS_CODE) VALUES (1, 999, 999, '2024-05-01', 'READ', '192.168.1.1', 'Mozilla', 200)",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, RECORD_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, STATUS_CODE) VALUES (2, 1, 999, '2024-05-01', 'READ', '192.168.1.1', 'Mozilla', 200)",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, RECORD_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, STATUS_CODE) VALUES (3, 1, 1, '2024-05-01', 'READ', '192.168.1.1', 'Mozilla', 404)",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, RECORD_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, STATUS_CODE) VALUES (4, 1, 1, '2024-05-01', 'READ', '192.168.1.1', 'Mozilla', 200)",
      "INSERT INTO ACCESS_LOGS (ACCESS_ID, RECORD_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, IP_ADDRESS, USER_AGENT, STATUS_CODE) VALUES (5, 1, 1, '2024-05-01', 'READ', '192.168.1.1', 'Mozilla', 500)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_ACCESS_LOGS_VALIDATION that fires BEFORE INSERT on each row of the ACCESS_LOGS table to validate new entries. If the USER_ID does not exist in the USERS table, set it to 0 and insert an error report into REPORTS. If the RECORD_ID does not exist in CLIMATE_DATA, set it to NULL and insert a default record into CLIMATE_DATA using the first REGION_ID from REGIONS. If the STATUS_CODE is 400 or higher, insert a warning report into REPORTS. Otherwise, update the user's LAST_LOGIN in USERS and insert a new model parameter record into MODEL_PARAMETERS.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_ACCESS_LOGS_VALIDATION that runs BEFORE INSERT on each row of the ACCESS_LOGS table. For each new row, if the USER_ID does not exist in the USERS table, set it to 0 and insert an error report into REPORTS; if the RECORD_ID does not exist in CLIMATE_DATA, set it to NULL and insert a default record into CLIMATE_DATA; if the STATUS_CODE is 400 or higher, insert a warning report into REPORTS; otherwise, update the user's LAST_LOGIN in USERS and insert a model parameter record into MODEL_PARAMETERS.",
    "id": 92,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_ACCESS_LOGS_VALIDATION`. This trigger is configured to execute `BEFORE` any `INSERT` operation is performed on the `ACCESS_LOGS` table. It is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row that is being inserted into the `ACCESS_LOGS` table. The trigger performs a series of conditional validations and actions based on the values in the new row.\n\nFirst, the trigger checks if the `USER_ID` from the new row (`:NEW.USER_ID`) exists in the `USERS` table. It performs a `SELECT COUNT(*)` query into a variable, counting rows in the `USERS` table where the `USER_ID` column matches `:NEW.USER_ID`. If the count is zero, indicating the user does not exist, the trigger sets the `:NEW.USER_ID` value to `0`. It then performs an `INSERT` operation into the `REPORTS` table. This insert includes values such as a report type indicating an error, the current timestamp, and a message referencing the invalid user ID.\n\nSecond, the trigger checks if the `RECORD_ID` from the new row (`:NEW.RECORD_ID`) exists in the `CLIMATE_DATA` table. It performs another `SELECT COUNT(*)` query into a variable, counting rows in the `CLIMATE_DATA` table where the `RECORD_ID` column matches `:NEW.RECORD_ID`. If the count is zero, indicating the record does not exist, the trigger sets the `:NEW.RECORD_ID` value to `NULL`. It then performs an `INSERT` operation into the `CLIMATE_DATA` table to create a default record. This insert likely populates the `RECORD_ID` with a sequence-generated value or a default, along with other default column values like a timestamp and placeholder data.\n\nThird, the trigger checks the `STATUS_CODE` from the new row (`:NEW.STATUS_CODE`). If the `STATUS_CODE` is greater than or equal to `400`, it performs an `INSERT` operation into the `REPORTS` table. This insert includes values such as a report type indicating a warning, the current timestamp, and a message referencing the high status code.\n\nIf none of the above conditions are met (i.e., the `USER_ID` exists in `USERS`, the `RECORD_ID` exists in `CLIMATE_DATA`, and the `STATUS_CODE` is less than `400`), the trigger executes two final operations. It performs an `UPDATE` operation on the `USERS` table, setting the `LAST_LOGIN` column to the current timestamp for the row where the `USER_ID` matches `:NEW.USER_ID`. It then performs an `INSERT` operation into the `MODEL_PARAMETERS` table. This insert includes values such as the `USER_ID`, the `RECORD_ID`, the current timestamp, and potentially default or derived parameter values.\n\nThe trigger uses explicit variable declarations to store the results of the `COUNT(*)` queries. All database operations (`SELECT`, `INSERT`, `UPDATE`) are performed within the trigger's `BEGIN` and `END` block, with conditional logic (`IF-THEN-ELSIF-ELSE`) controlling the flow based on the validation checks. The trigger modifies the incoming row's data using the `:NEW` pseudo-record before it is inserted into the `ACCESS_LOGS` table.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named TRG_ACCESS_LOGS_VALIDATION on the ACCESS_LOGS table. The trigger must: 1) If the USER_ID is invalid, set it to 0 and log an error report. 2) If the RECORD_ID is invalid, set it to NULL and insert a default CLIMATE_DATA record. 3) If STATUS_CODE >= 400, insert a warning report. 4) Otherwise, update the user's LAST_LOGIN and insert a model parameter record.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a BEFORE INSERT FOR EACH ROW trigger called TRG_ACCESS_LOGS_VALIDATION on the ACCESS_LOGS table. For each new row, do the following: if the USER_ID is invalid, set it to 0 and log an error report; if the RECORD_ID is invalid, set it to NULL and insert a default CLIMATE_DATA record; if the STATUS_CODE is 400 or higher, insert a warning report; otherwise, update the user's LAST_LOGIN and insert a model parameter record."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_PREVENT_FUTURE_DATE that is executed before an insert operation on the WEATHER_STATIONS table. This trigger operates on each row being inserted into the table. It checks the value of the INSTALLATION_DATE column in the new row, which is expected to be in the format 'YYYY-MM-DD'. The trigger uses the TO_DATE function to convert the INSTALLATION_DATE from a string to a date data type. It then compares this date to the current system date, SYSDATE, which represents the current date and time on the database server. If the INSTALLATION_DATE is found to be greater than SYSDATE, indicating that the date is in the future, the trigger modifies the INSTALLATION_DATE value in the new row. It sets INSTALLATION_DATE to the current system date, formatted as a string in 'YYYY-MM-DD' format using the TO_CHAR function. This ensures that no future dates are inserted into the INSTALLATION_DATE column of the WEATHER_STATIONS table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PREVENT_FUTURE_DATE\nBEFORE INSERT ON WEATHER_STATIONS\nFOR EACH ROW\nBEGIN\n    IF TO_DATE(:NEW.INSTALLATION_DATE, 'YYYY-MM-DD') > SYSDATE THEN\n        :NEW.INSTALLATION_DATE := TO_CHAR(SYSDATE, 'YYYY-MM-DD');\n    END IF;\nEND;",
    "database_name": "meteorological_dcaa_72951",
    "tables": [
      "METEOROLOGICAL_DATA",
      "METEOROLOGICAL_PARAMETERS",
      "WEATHER_STATIONS"
    ],
    "call_sqls": [
      "INSERT INTO WEATHER_STATIONS (STATION_ID, STATION_NAME, LOCATION, LATITUDE, LONGITUDE, ELEVATION, STATION_TYPE, INSTALLATION_DATE, DECOMMISSION_DATE) VALUES (1, 'Station Alpha', 'City A', 34.05, -118.25, 100, 'Automatic', '2023-01-15', NULL)",
      "INSERT INTO WEATHER_STATIONS (STATION_ID, STATION_NAME, LOCATION, LATITUDE, LONGITUDE, ELEVATION, STATION_TYPE, INSTALLATION_DATE, DECOMMISSION_DATE) VALUES (2, 'Station Beta', 'City B', 34.06, -118.26, 110, 'Manual', TO_CHAR(SYSDATE + 10, 'YYYY-MM-DD'), NULL)",
      "INSERT INTO WEATHER_STATIONS (STATION_ID, STATION_NAME, LOCATION, LATITUDE, LONGITUDE, ELEVATION, STATION_TYPE, INSTALLATION_DATE, DECOMMISSION_DATE) VALUES (3, 'Station Gamma', 'City C', 34.07, -118.27, 120, 'Automatic', TO_CHAR(SYSDATE - 5, 'YYYY-MM-DD'), NULL)",
      "INSERT INTO WEATHER_STATIONS (STATION_ID, STATION_NAME, LOCATION, LATITUDE, LONGITUDE, ELEVATION, STATION_TYPE, INSTALLATION_DATE, DECOMMISSION_DATE) VALUES (4, 'Station Delta', 'City D', 34.08, -118.28, 130, 'Manual', TO_CHAR(SYSDATE + 30, 'YYYY-MM-DD'), NULL)",
      "INSERT INTO WEATHER_STATIONS (STATION_ID, STATION_NAME, LOCATION, LATITUDE, LONGITUDE, ELEVATION, STATION_TYPE, INSTALLATION_DATE, DECOMMISSION_DATE) VALUES (5, 'Station Epsilon', 'City E', 34.09, -118.29, 140, 'Automatic', '2024-03-01', NULL)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_PREVENT_FUTURE_DATE that fires BEFORE INSERT on each row of the WEATHER_STATIONS table, ensuring that if the new INSTALLATION_DATE (provided in 'YYYY-MM-DD' format) is later than the current date, it is automatically set to the current date in the same 'YYYY-MM-DD' format.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_PREVENT_FUTURE_DATE that runs before inserting any new record into the WEATHER_STATIONS table. It should check the INSTALLATION_DATE of the incoming data, and if that date is set to a future date, automatically change it to today's date, ensuring all dates are handled in the 'YYYY-MM-DD' format.",
    "id": 93,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_PREVENT_FUTURE_DATE that is executed before an insert operation on the WEATHER_STATIONS table. This trigger operates on each row being inserted into the table. It checks the value of the INSTALLATION_DATE column in the new row, which is expected to be in the format 'YYYY-MM-DD'. The trigger uses the TO_DATE function to convert the INSTALLATION_DATE from a string to a date data type. It then compares this date to the current system date, SYSDATE, which represents the current date and time on the database server. If the INSTALLATION_DATE is found to be greater than SYSDATE, indicating that the date is in the future, the trigger modifies the INSTALLATION_DATE value in the new row. It sets INSTALLATION_DATE to the current system date, formatted as a string in 'YYYY-MM-DD' format using the TO_CHAR function. This ensures that no future dates are inserted into the INSTALLATION_DATE column of the WEATHER_STATIONS table.",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named TRG_PREVENT_FUTURE_DATE on the WEATHER_STATIONS table. If the new row's INSTALLATION_DATE (in 'YYYY-MM-DD' format) is greater than the current date (SYSDATE), set it to the current date formatted as 'YYYY-MM-DD'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the WEATHER_STATIONS table that runs before adding any new record. The trigger should be called something like TRG_PREVENT_FUTURE_DATE. Its job is to check the INSTALLATION_DATE for the incoming data. If that date looks like it's set for some time ahead of now, then just change it to today's date. Make sure the dates are handled in the usual 'YYYY-MM-DD' format."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_old_climate_data` that is configured to execute automatically `BEFORE` any `DELETE` operation is performed on the `CLIMATE_DATA` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning it will execute once for every individual row that is being deleted from the `CLIMATE_DATA` table. Upon activation, for each row being deleted from `CLIMATE_DATA`, the trigger performs a `DELETE` operation on the `MODEL_PERFORMANCE` table. The `DELETE` operation on `MODEL_PERFORMANCE` is conditional, targeting only those rows where the value in the `RECORD_ID` column of `MODEL_PERFORMANCE` is equal to the value of the `RECORD_ID` column from the row currently being deleted from the `CLIMATE_DATA` table. The `:OLD.RECORD_ID` pseudo-record refers to the value of the `RECORD_ID` column in the row of the `CLIMATE_DATA` table that is in the process of being deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_old_climate_data\nBEFORE DELETE ON CLIMATE_DATA\nFOR EACH ROW\nBEGIN\n    DELETE FROM MODEL_PERFORMANCE WHERE RECORD_ID = :OLD.RECORD_ID;\nEND;",
    "database_name": "climate_daa_prediction",
    "tables": [
      "CLIMATE_DATA",
      "DATASETS",
      "MODEL_PERFORMANCE",
      "MODEL_PARAMETERS",
      "REGIONS"
    ],
    "call_sqls": [
      "DELETE FROM CLIMATE_DATA WHERE RECORD_ID = 0",
      "DELETE FROM CLIMATE_DATA WHERE RECORD_ID = 1",
      "DELETE FROM CLIMATE_DATA WHERE RECORD_ID = 2",
      "DELETE FROM CLIMATE_DATA WHERE RECORD_ID = 3",
      "DELETE FROM CLIMATE_DATA WHERE RECORD_ID = 4"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_delete_old_climate_data that fires BEFORE DELETE on the CLIMATE_DATA table for each row, and deletes any rows from the MODEL_PERFORMANCE table where the RECORD_ID matches the RECORD_ID of the CLIMATE_DATA row being deleted.",
    "natural_language": "Write a Oracle PL/SQL trigger called trg_delete_old_climate_data that, before deleting any row from the CLIMATE_DATA table, removes the corresponding rows from the MODEL_PERFORMANCE table where MODEL_PERFORMANCE.RECORD_ID matches the RECORD_ID of the row being deleted.",
    "id": 94,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_delete_old_climate_data` that is configured to execute automatically `BEFORE` any `DELETE` operation is performed on the `CLIMATE_DATA` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning it will execute once for every individual row that is being deleted from the `CLIMATE_DATA` table. Upon activation, for each row being deleted from `CLIMATE_DATA`, the trigger performs a `DELETE` operation on the `MODEL_PERFORMANCE` table. The `DELETE` operation on `MODEL_PERFORMANCE` is conditional, targeting only those rows where the value in the `RECORD_ID` column of `MODEL_PERFORMANCE` is equal to the value of the `RECORD_ID` column from the row currently being deleted from the `CLIMATE_DATA` table. The `:OLD.RECORD_ID` pseudo-record refers to the value of the `RECORD_ID` column in the row of the `CLIMATE_DATA` table that is in the process of being deleted.",
    "original_summary": "Create a trigger named `trg_delete_old_climate_data` that fires BEFORE DELETE on the CLIMATE_DATA table for each row. It deletes rows from the MODEL_PERFORMANCE table where MODEL_PERFORMANCE.RECORD_ID equals the :OLD.RECORD_ID from the deleted CLIMATE_DATA row.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Create a trigger called `trg_delete_old_climate_data` that, before deleting any row from the CLIMATE_DATA table, removes the corresponding rows from the MODEL_PERFORMANCE table where MODEL_PERFORMANCE.RECORD_ID matches the :OLD.RECORD_ID of the row being deleted."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_shipment_items that is defined to execute automatically after a delete operation is performed on the SHIPMENTS table, and it is configured to fire once for each row that is deleted from that table; the trigger's body contains a single DELETE statement that targets the SHIPMENT_ITEMS table, specifying a condition in the WHERE clause that the SHIPMENT_ID column in the SHIPMENT_ITEMS table must be equal to the value of the SHIPMENT_ID column from the deleted row, which is referenced using the :OLD.SHIPMENT_ID correlation identifier.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_shipment_items\nAFTER DELETE ON SHIPMENTS\nFOR EACH ROW\nBEGIN\n  DELETE FROM SHIPMENT_ITEMS WHERE SHIPMENT_ID = :OLD.SHIPMENT_ID;\nEND;",
    "database_name": "clothing_ssaim_39101",
    "tables": [
      "SHIPMENTS",
      "SHIPMENT_ITEMS",
      "SUPPLIERS",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "DELETE FROM SHIPMENTS WHERE SHIPMENT_ID = 0",
      "DELETE FROM SHIPMENTS WHERE SHIPMENT_ID = 1",
      "DELETE FROM SHIPMENTS WHERE SUPPLIER_ID = 1 AND WAREHOUSE_ID = 1",
      "DELETE FROM SHIPMENTS WHERE SHIPMENT_DATE = '2023-05-01'",
      "DELETE FROM SHIPMENTS WHERE EXPECTED_DELIVERY_DATE = '2023-05-06'"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_shipment_items that executes after each row is deleted from the SHIPMENTS table, and for each deleted shipment, removes all corresponding rows from the SHIPMENT_ITEMS table where the SHIPMENT_ID matches the deleted shipment's SHIPMENT_ID.",
    "natural_language": "Hey, write a Oracle PL/SQL trigger called trg_update_shipment_items on the SHIPMENTS table that fires after a row is deleted. Whenever a shipment is removed, it should also delete all corresponding rows in the SHIPMENT_ITEMS table where the SHIPMENT_ID matches the deleted shipment's SHIPMENT_ID.",
    "id": 95,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_shipment_items that is defined to execute automatically after a delete operation is performed on the SHIPMENTS table, and it is configured to fire once for each row that is deleted from that table; the trigger's body contains a single DELETE statement that targets the SHIPMENT_ITEMS table, specifying a condition in the WHERE clause that the SHIPMENT_ID column in the SHIPMENT_ITEMS table must be equal to the value of the SHIPMENT_ID column from the deleted row, which is referenced using the :OLD.SHIPMENT_ID correlation identifier.",
    "original_summary": "Create an AFTER DELETE row trigger named trg_update_shipment_items on the SHIPMENTS table. For each deleted row, delete all rows from the SHIPMENT_ITEMS table where SHIPMENT_ID equals the :OLD.SHIPMENT_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, set up a trigger called trg_update_shipment_items on the SHIPMENTS table that fires after a row gets deleted. Every time you zap a shipment, it should also clean out all the matching rows in the SHIPMENT_ITEMS table where the SHIPMENT_ID matches the old, deleted one."
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER INSERT` row-level trigger named `TRG_INDIVIDUALS_INSERT` that is automatically executed whenever a new row is successfully inserted into the `INDIVIDUALS` table. For each individual row inserted into the `INDIVIDUALS` table, this trigger performs a single `INSERT` operation into the `DEMOGRAPHICS` table. The `INSERT` statement populates the columns of the `DEMOGRAPHICS` table with values derived directly from the newly inserted row in the `INDIVIDUALS` table. Specifically, the `ID` column in `DEMOGRAPHICS` is populated with the value from the `ID` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.ID`). The `FEMALE` column in `DEMOGRAPHICS` is populated with the value from the `FEMALE` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.FEMALE`). The `BLACK` column in `DEMOGRAPHICS` is populated with the value from the `BLACK` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.BLACK`). The `LATIN` column in `DEMOGRAPHICS` is populated with the value from the `LATIN` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.LATIN`). The `WHITE` column in `DEMOGRAPHICS` is populated with the value from the `WHITE` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.WHITE`). The `AGE` column in `DEMOGRAPHICS` is populated with the value from the `AGE` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.AGE`). The `PARENT_COLLEGE` column in `DEMOGRAPHICS` is populated with the value from the `PARENT_COLLEGE` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.PARENT_COLLEGE`). The `NUMKIDS` column in `DEMOGRAPHICS` is populated with the value from the `NUMKIDS` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.NUMKIDS`). The `ADDRESS` column in `DEMOGRAPHICS` is populated with the value from the `ADDRESS` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.ADDRESS`). The `MARITAL_STATUS` column in `DEMOGRAPHICS` is populated with the value from the `MARITAL_STATUS` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.MARITAL_STATUS`). The `DATE_OF_BIRTH` column in `DEMOGRAPHICS` is populated with the value from the `DATE_OF_BIRTH` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.DATE_OF_BIRTH`). The `ETHNICITY` column in `DEMOGRAPHICS` is populated with the value from the `ETHNICITY` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.ETHNICITY`). The `DISABILITY_STATUS` column in `DEMOGRAPHICS` is populated with the value from the `DISABILITY_STATUS` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.DISABILITY_STATUS`). Finally, the `MILITARY_SERVICE` column in `DEMOGRAPHICS` is populated with the value from the `MILITARY_SERVICE` column of the newly inserted `INDIVIDUALS` row (referenced as `:NEW.MILITARY_SERVICE`). This trigger does not contain any conditional logic or function calls; it performs a direct one-to-one mapping and insertion of column values from the `INDIVIDUALS` table to the `DEMOGRAPHICS` table for every new row.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_INDIVIDUALS_INSERT\nAFTER INSERT ON INDIVIDUALS\nFOR EACH ROW\nBEGIN\n   INSERT INTO DEMOGRAPHICS (ID, FEMALE, BLACK, LATIN, WHITE, AGE, PARENT_COLLEGE, NUMKIDS, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, MILITARY_SERVICE) VALUES (:NEW.ID, :NEW.FEMALE, :NEW.BLACK, :NEW.LATIN, :NEW.WHITE, :NEW.AGE, :NEW.PARENT_COLLEGE, :NEW.NUMKIDS, :NEW.ADDRESS, :NEW.MARITAL_STATUS, :NEW.DATE_OF_BIRTH, :NEW.ETHNICITY, :NEW.DISABILITY_STATUS, :NEW.MILITARY_SERVICE);\nEND;",
    "database_name": "demographic_aeda_192071",
    "tables": [
      "ACCESS_LOGS",
      "DEMOGRAPHICS",
      "EDUCATION",
      "EMPLOYMENT",
      "FINANCIAL_AID",
      "HOUSEHOLD",
      "INDIVIDUALS",
      "STATISTICS",
      "USERS"
    ],
    "call_sqls": [
      "INSERT INTO INDIVIDUALS (ID, FEMALE, BLACK, LATIN, WHITE, EMPLOYED, WAGE, COLLGRAD, AGE, PARENT_COLLEGE, NUMKIDS, EFC, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, MILITARY_SERVICE, EMPLOYMENT_SECTOR, EMPLOYMENT_START_DATE, EMPLOYMENT_END_DATE, EDUCATION_LEVEL, INCOME_SOURCE, HEALTH_INSURANCE) VALUES (2, 0, 1, 0, 1, 1, 15.50, 1, 28, 1, 2, 500, '789 Pine St', 'Married', '1995-08-20', 'African American', 1, 1, 'Healthcare', '2021-01-01', NULL, 'Bachelor', 'Salary', 1)",
      "INSERT INTO INDIVIDUALS (ID, FEMALE, BLACK, LATIN, WHITE, EMPLOYED, WAGE, COLLGRAD, AGE, PARENT_COLLEGE, NUMKIDS, EFC, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, MILITARY_SERVICE, EMPLOYMENT_SECTOR, EMPLOYMENT_START_DATE, EMPLOYMENT_END_DATE, EDUCATION_LEVEL, INCOME_SOURCE, HEALTH_INSURANCE) VALUES (3, 1, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, '1010 Maple St', 'Single', '1983-03-10', 'Caucasian', 0, 0, 'Education', '2015-09-01', '2020-06-01', 'Master', 'None', 0)",
      "INSERT INTO INDIVIDUALS (ID, FEMALE, BLACK, LATIN, WHITE, EMPLOYED, WAGE, COLLGRAD, AGE, PARENT_COLLEGE, NUMKIDS, EFC, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, MILITARY_SERVICE, EMPLOYMENT_SECTOR, EMPLOYMENT_START_DATE, EMPLOYMENT_END_DATE, EDUCATION_LEVEL, INCOME_SOURCE, HEALTH_INSURANCE) VALUES (4, 0, 0, 1, 0, 1, 18.75, 0, 30, 1, 1, 1000, '202 Birch St', 'Divorced', '1993-11-05', 'Hispanic', 0, 0, 'Finance', '2019-03-15', NULL, 'Associate', 'Wage', 1)",
      "INSERT INTO INDIVIDUALS (ID, FEMALE, BLACK, LATIN, WHITE, EMPLOYED, WAGE, COLLGRAD, AGE, PARENT_COLLEGE, NUMKIDS, EFC, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, MILITARY_SERVICE, EMPLOYMENT_SECTOR, EMPLOYMENT_START_DATE, EMPLOYMENT_END_DATE, EDUCATION_LEVEL, INCOME_SOURCE, HEALTH_INSURANCE) VALUES (5, 1, 1, 0, 0, 0, 0, 1, 45, 0, 3, 2000, '303 Cedar St', 'Widowed', '1978-02-25', 'African American', 1, 1, 'Government', '2010-05-01', '2018-12-31', 'Doctorate', 'Pension', 0)",
      "INSERT INTO INDIVIDUALS (ID, FEMALE, BLACK, LATIN, WHITE, EMPLOYED, WAGE, COLLGRAD, AGE, PARENT_COLLEGE, NUMKIDS, EFC, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, MILITARY_SERVICE, EMPLOYMENT_SECTOR, EMPLOYMENT_START_DATE, EMPLOYMENT_END_DATE, EDUCATION_LEVEL, INCOME_SOURCE, HEALTH_INSURANCE) VALUES (6, 0, 0, 0, 1, 1, 22.00, 1, 32, 1, 1, 3000, '404 Oak St', 'Married', '1991-07-15', 'Caucasian', 0, 0, 'Technology', '2017-08-01', NULL, 'Bachelor', 'Salary', 1)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named TRG_INDIVIDUALS_INSERT that fires after each new row is inserted into the INDIVIDUALS table, and for each insertion, it automatically adds a corresponding record to the DEMOGRAPHICS table by copying all the individual's data—including ID, FEMALE, BLACK, LATIN, WHITE, AGE, PARENT_COLLEGE, NUMKIDS, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, and MILITARY_SERVICE—from the newly inserted INDIVIDUALS row into the matching columns in DEMOGRAPHICS.",
    "natural_language": "Write a Oracle PL/SQL trigger named TRG_INDIVIDUALS_INSERT that, after each new row is inserted into the INDIVIDUALS table, copies all column values from that new row—including ID, FEMALE, BLACK, LATIN, WHITE, AGE, PARENT_COLLEGE, NUMKIDS, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, and MILITARY_SERVICE—into the corresponding columns of the DEMOGRAPHICS table.",
    "id": 96,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_INDIVIDUALS_INSERT that is configured to execute AFTER each row INSERT operation on the INDIVIDUALS table. This trigger is defined as a FOR EACH ROW trigger, meaning its logic will be executed once for every new row inserted into the INDIVIDUALS table. The trigger's primary purpose is to automatically replicate the inserted individual's data into the DEMOGRAPHICS table. Inside the trigger's BEGIN...END block, a single INSERT operation is performed on the DEMOGRAPHICS table. The INSERT statement specifies the target columns in the DEMOGRAPHICS table: ID, FEMALE, BLACK, LATIN, WHITE, AGE, PARENT_COLLEGE, NUMKIDS, ADDRESS, MARITAL_STATUS, DATE_OF_BIRTH, ETHNICITY, DISABILITY_STATUS, and MILITARY_SERVICE. The VALUES clause of the INSERT statement uses the corresponding column values from the newly inserted row in the INDIVIDUALS table, which are accessed via the :NEW pseudorecord. Specifically, the values inserted are :NEW.ID, :NEW.FEMALE, :NEW.BLACK, :NEW.LATIN, :NEW.WHITE, :NEW.AGE, :NEW.PARENT_COLLEGE, :NEW.NUMKIDS, :NEW.ADDRESS, :NEW.MARITAL_STATUS, :NEW.DATE_OF_BIRTH, :NEW.ETHNICITY, :NEW.DISABILITY_STATUS, and :NEW.MILITARY_SERVICE. This operation ensures that a new record is created in the DEMOGRAPHICS table containing an exact copy of all the specified column data from the newly inserted INDIVIDUALS row, effectively maintaining a synchronized demographic record for each individual.",
    "original_summary": "Create an AFTER INSERT row-level trigger named TRG_INDIVIDUALS_INSERT on the INDIVIDUALS table. For each inserted row, perform a direct INSERT into the DEMOGRAPHICS table, mapping all column values (:NEW.ID, :NEW.FEMALE, :NEW.BLACK, :NEW.LATIN, :NEW.WHITE, :NEW.AGE, :NEW.PARENT_COLLEGE, :NEW.NUMKIDS, :NEW.ADDRESS, :NEW.MARITAL_STATUS, :NEW.DATE_OF_BIRTH, :NEW.ETHNICITY, :NEW.DISABILITY_STATUS, :NEW.MILITARY_SERVICE) from the new INDIVIDUALS row to the corresponding columns in DEMOGRAPHICS.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER INSERT row-level trigger named TRG_INDIVIDUALS_INSERT on the INDIVIDUALS table that, for each new row, directly inserts all column values from that row into the corresponding columns of the DEMOGRAPHICS table?"
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_vehicles_before_insert_price that executes automatically before any new row is inserted into the VEHICLES table, for each individual row being inserted, and performs a single assignment operation that sets the value of the :NEW pseudorecord's VEHICLE_CURRENCY column to the literal string 'USD' for that incoming row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_vehicles_before_insert_price\nBEFORE INSERT ON VEHICLES\nFOR EACH ROW\nBEGIN\n:NEW.VEHICLE_CURRENCY := 'USD';\nEND;",
    "database_name": "automobile_pas_database",
    "tables": [
      "VEHICLES"
    ],
    "call_sqls": [
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, VEHICLE_PRICE) VALUES (1, 101, 'Civic', 2023, '25000')",
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, VEHICLE_PRICE) VALUES (2, 102, 'Corolla', 2024, '27000')",
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, VEHICLE_PRICE) VALUES (3, 103, 'F-150', 2022, '45000')",
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, VEHICLE_PRICE) VALUES (4, 104, 'Model 3', 2023, '40000')",
      "INSERT INTO VEHICLES (VEHICLE_ID, MANUFACTURER_ID, MODEL_NAME, MODEL_YEAR, VEHICLE_PRICE) VALUES (5, 105, 'CR-V', 2024, '30000')"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_vehicles_before_insert_price that, before inserting a new row into the VEHICLES table, sets the VEHICLE_CURRENCY column for that row to 'USD'.",
    "natural_language": "Write a Oracle PL/SQL trigger named `trg_vehicles_before_insert_price` that, before inserting a new row into the VEHICLES table, sets the VEHICLE_CURRENCY column to 'USD' for that row.",
    "id": 97,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_vehicles_before_insert_price that is executed automatically before a new row is inserted into the VEHICLES table. This trigger operates for each row inserted and performs a column value assignment on the new row. Specifically, it sets the VEHICLE_CURRENCY column of the new row to the string literal 'USD' by modifying the :NEW pseudorecord. The trigger uses the BEFORE INSERT timing to ensure the VEHICLE_CURRENCY column is populated with 'USD' prior to the actual insertion of the row into the VEHICLES table. No additional SQL operations such as SELECT, UPDATE, or DELETE are performed; the trigger solely modifies the incoming row data. The trigger does not include any conditional logic, exception handling, or variable declarations, and it does not return a value.",
    "original_summary": "Create a BEFORE INSERT row-level trigger named `trg_vehicles_before_insert_price` on the VEHICLES table. It sets the :NEW.VEHICLE_CURRENCY column for the incoming row to the string 'USD'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "How do you create a BEFORE INSERT row-level trigger named `trg_vehicles_before_insert_price` on the VEHICLES table to set the :NEW.VEHICLE_CURRENCY column to 'USD'?"
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_adjust_confidence that is executed before an update operation on the PREDICTIONS table, specifically for each row being updated. The trigger declares a local variable v_adjusted_confidence of type NUMBER, which is used to store the result of applying the TANH mathematical function to the value in the CONFIDENCE column of the row being updated, referred to as :NEW.CONFIDENCE. The TANH function computes the hyperbolic tangent of the given confidence value, which is a mathematical operation that transforms the input into a value between -1 and 1. The trigger then evaluates the adjusted confidence value using conditional logic. If v_adjusted_confidence is less than 0.4, the trigger increases the original confidence value by multiplying it by 1.1, effectively boosting the confidence by 10%. If v_adjusted_confidence is greater than or equal to 0.4 but less than 0.7, the trigger increases the original confidence value by multiplying it by 1.05, providing a 5% increase. If v_adjusted_confidence is 0.7 or higher, the trigger decreases the original confidence value by multiplying it by 0.95, resulting in a 5% reduction. The trigger modifies the :NEW.CONFIDENCE value directly, which represents the new value that will be stored in the CONFIDENCE column of the PREDICTIONS table for the row being updated.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_adjust_confidence\nBEFORE UPDATE ON PREDICTIONS\nFOR EACH ROW\nDECLARE\n  v_adjusted_confidence NUMBER;\nBEGIN\n  v_adjusted_confidence := TANH(:NEW.CONFIDENCE);\n\n  IF v_adjusted_confidence < 0.4 THEN\n    :NEW.CONFIDENCE := :NEW.CONFIDENCE * 1.1;\n  ELSIF v_adjusted_confidence >= 0.4 AND v_adjusted_confidence < 0.7 THEN\n    :NEW.CONFIDENCE := :NEW.CONFIDENCE * 1.05;\n  ELSE\n    :NEW.CONFIDENCE := :NEW.CONFIDENCE * 0.95;\n  END IF;\nEND;",
    "database_name": "weather_oaf_92747",
    "tables": [
      "PREDICTIONS",
      "PREDICTION_MODELS"
    ],
    "call_sqls": [
      "UPDATE PREDICTIONS SET CONFIDENCE = 0.75 WHERE PREDICTION_ID = 0",
      "UPDATE PREDICTIONS SET CONFIDENCE = 0.65 WHERE PREDICTION_ID = 1",
      "UPDATE PREDICTIONS SET CONFIDENCE = 0.85 WHERE PREDICTION_ID = 0",
      "UPDATE PREDICTIONS SET CONFIDENCE = 0.55 WHERE PREDICTION_ID = 1",
      "UPDATE PREDICTIONS SET CONFIDENCE = 0.95 WHERE PREDICTION_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_adjust_confidence that fires BEFORE UPDATE on each row of the PREDICTIONS table, adjusting the new CONFIDENCE value based on its hyperbolic tangent: if the tangent is below 0.4, increase CONFIDENCE by 10%; if it is between 0.4 and 0.7, increase CONFIDENCE by 5%; otherwise, decrease CONFIDENCE by 5%.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_adjust_confidence that fires BEFORE UPDATE on the PREDICTIONS table for each row, adjusting the CONFIDENCE value based on its hyperbolic tangent: if the result is less than 0.4, multiply CONFIDENCE by 1.1; if it is at least 0.4 but less than 0.7, multiply by 1.05; otherwise, multiply by 0.95.",
    "id": 98,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_adjust_confidence` that is activated `BEFORE` any `UPDATE` operation on the `PREDICTIONS` table. This trigger is configured to execute `FOR EACH ROW` that is being updated. Upon activation, for each row being updated, the trigger performs a single conditional operation to adjust the value of the `CONFIDENCE` column in the row currently being updated (`:NEW.CONFIDENCE`). This adjustment is based on the hyperbolic tangent of the current `CONFIDENCE` value from the row being updated (`:NEW.CONFIDENCE`). The trigger first calculates the hyperbolic tangent of `:NEW.CONFIDENCE` using the `TANH` function. It then evaluates this calculated value using a conditional logic structure. If the calculated hyperbolic tangent value is strictly less than 0.4, the trigger multiplies the original `:NEW.CONFIDENCE` value by 1.1 and assigns the result back to `:NEW.CONFIDENCE`. If the calculated hyperbolic tangent value is greater than or equal to 0.4 but strictly less than 0.7, the trigger multiplies the original `:NEW.CONFIDENCE` value by 1.05 and assigns the result back to `:NEW.CONFIDENCE`. If the calculated hyperbolic tangent value is 0.7 or greater, the trigger multiplies the original `:NEW.CONFIDENCE` value by 0.95 and assigns the result back to `:NEW.CONFIDENCE`. The trigger does not declare any local variables and performs no separate SQL operations such as SELECT, INSERT, or DELETE; it only modifies the `:NEW.CONFIDENCE` value in place based on the described calculation and conditional logic.",
    "original_summary": "Create a BEFORE UPDATE row-level trigger named trg_adjust_confidence on the PREDICTIONS table. For each row, calculate v_adjusted_confidence = TANH(:NEW.CONFIDENCE). If v_adjusted_confidence < 0.4, set :NEW.CONFIDENCE = :NEW.CONFIDENCE * 1.1. Else if v_adjusted_confidence < 0.7, set :NEW.CONFIDENCE = :NEW.CONFIDENCE * 1.05. Otherwise, set :NEW.CONFIDENCE = :NEW.CONFIDENCE * 0.95.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Make a BEFORE UPDATE trigger trg_adjust_confidence for PREDICTIONS. For each row, compute TANH(:NEW.CONFIDENCE). If result < 0.4, multiply confidence by 1.1. If < 0.7, multiply by 1.05. Else, multiply by 0.95."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named `trg_update_student_gpa` that is activated after an `UPDATE` operation on the `GRADE` column of the `STUDENT_COURSES` table. This trigger executes for `EACH ROW` affected by the `UPDATE` statement. It declares three local variables: `v_total_gpa` of type `NUMBER` to store the sum of grades, `v_course_count` of type `NUMBER` to store the number of courses, and `v_new_gpa` of type `NUMBER` to store the newly calculated GPA. The trigger's execution begins by checking a conditional statement: `IF :NEW.GRADE <> :OLD.GRADE THEN`. This condition evaluates whether the new value of the `GRADE` column (`:NEW.GRADE`) is different from the old value of the `GRADE` column (`:OLD.GRADE`) for the current row being processed. If this condition is true, indicating that the grade has actually changed, the trigger proceeds to execute a `SELECT` statement. This `SELECT` statement calculates the `SUM` of the `GRADE` column, explicitly converting each `GRADE` value to a `NUMBER` using `TO_NUMBER(GRADE)`, and counts the total number of rows using `COUNT(*)`. The results of these aggregations are then stored into the `v_total_gpa` and `v_course_count` variables, respectively. This `SELECT` operation is performed on the `STUDENT_COURSES` table, specifically for rows where the `STUDENT_ID` column matches the `STUDENT_ID` of the current row being updated (`:NEW.STUDENT_ID`). Following this, another conditional statement is evaluated: `IF v_course_count > 0 THEN`. If the `v_course_count` variable is greater than 0, meaning the student has at least one course, the `v_new_gpa` variable is calculated by dividing `v_total_gpa` by `v_course_count`. Otherwise, if `v_course_count` is not greater than 0 (i.e., it is 0), `v_new_gpa` is set to `NULL`. Subsequently, a further conditional statement is checked: `IF v_new_gpa IS NOT NULL THEN`. If `v_new_gpa` is not `NULL`, an `UPDATE` statement is executed. This `UPDATE` statement modifies the `STUDENTS` table, setting the `GPA` column to the value stored in `v_new_gpa`. This update is applied to the row in the `STUDENTS` table where the `STUDENT_ID` column matches the `STUDENT_ID` of the current row being updated in `STUDENT_COURSES` (`:NEW.STUDENT_ID`). The trigger concludes its execution after these conditional checks and operations.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_student_gpa\nAFTER UPDATE OF GRADE ON STUDENT_COURSES\nFOR EACH ROW\nDECLARE\n    v_total_gpa NUMBER;\n    v_course_count NUMBER;\n    v_new_gpa NUMBER;\nBEGIN\n    IF :NEW.GRADE <> :OLD.GRADE THEN\n        SELECT SUM(TO_NUMBER(GRADE)), COUNT(*)\n        INTO v_total_gpa, v_course_count\n        FROM STUDENT_COURSES\n        WHERE STUDENT_ID = :NEW.STUDENT_ID;\n\n        IF v_course_count > 0 THEN\n            v_new_gpa := v_total_gpa / v_course_count;\n        ELSE\n            v_new_gpa := NULL;\n        END IF;\n\n        IF v_new_gpa IS NOT NULL THEN\n            UPDATE STUDENTS\n            SET GPA = v_new_gpa\n            WHERE STUDENT_ID = :NEW.STUDENT_ID;\n        END IF;\n    END IF;\nEND;",
    "database_name": "student_ap_tracking",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSES",
      "SEMESTERS"
    ],
    "call_sqls": [
      "UPDATE STUDENT_COURSES SET GRADE = 'A' WHERE ENROLLMENT_ID = '0'",
      "UPDATE STUDENT_COURSES SET GRADE = 'B' WHERE ENROLLMENT_ID = '1'",
      "UPDATE STUDENT_COURSES SET GRADE = 'C' WHERE ENROLLMENT_ID = '0'",
      "UPDATE STUDENT_COURSES SET GRADE = 'D' WHERE ENROLLMENT_ID = '1'",
      "UPDATE STUDENT_COURSES SET GRADE = 'F' WHERE ENROLLMENT_ID = '0'"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_update_student_gpa that fires after an update to the GRADE column in the STUDENT_COURSES table for each affected row. When the GRADE changes, calculate the student's new GPA by summing all their course grades from the STUDENT_COURSES table and dividing by the total number of courses for that student, then update the GPA column in the STUDENTS table with this calculated value for the corresponding student.",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_update_student_gpa that runs AFTER an UPDATE on the STUDENT_COURSES table, specifically when the GRADE column changes. For the student whose GRADE was updated, calculate their new GPA by summing all their grades from the STUDENT_COURSES table and dividing by the total number of their courses, then update the GPA in the STUDENTS table for that student with this calculated value.",
    "id": 99,
    "generated_ir": "Write an Oracle PL/SQL `AFTER UPDATE` row-level trigger named `trg_update_student_gpa` that activates on the `STUDENT_COURSES` table. This trigger operates for each row affected by the `UPDATE` statement. The core logic of the trigger executes only if the `GRADE` column of the updated row has changed, which is determined by comparing the new value (`:NEW.GRADE`) with the old value (`:OLD.GRADE`).\n\nInside this conditional block, the trigger declares two local numeric variables: `v_total_grade` to store the sum of all grades for the student and `v_course_count` to store the total number of courses for the student.\n\nThe trigger then performs a single `SELECT` operation that queries the `STUDENT_COURSES` table. This query calculates two aggregate values for the student whose `STUDENT_ID` matches the `STUDENT_ID` of the newly updated row (`:NEW.STUDENT_ID`): the sum of all `GRADE` values and the count of all records. These calculated values are stored into the `v_total_grade` and `v_course_count` variables, respectively.\n\nFollowing this `SELECT` statement, the trigger calculates the new GPA by dividing the `v_total_grade` by `v_course_count`. This calculation assumes that both variables contain numeric data and that `v_course_count` is greater than zero to avoid a division-by-zero error.\n\nFinally, the trigger performs an `UPDATE` operation on the `STUDENTS` table. It sets the `GPA` column to the newly calculated value for the record where the `STUDENT_ID` column matches the `STUDENT_ID` of the newly updated row (`:NEW.STUDENT_ID`).",
    "original_summary": "Create an AFTER UPDATE row-level trigger named trg_update_student_gpa on the STUDENT_COURSES table, firing only when the GRADE column changes. For the updated student, calculate their new GPA by summing all their course grades and dividing by the number of courses. Update the student's GPA in the STUDENTS table with this newly calculated value.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a row-level trigger called trg_update_student_gpa, which is specifically designed to execute AFTER an UPDATE operation on the STUDENT_COURSES table. This trigger should be activated exclusively when there is a modification to the GRADE column's value. For the particular student whose record has been altered, meticulously compute their fresh Grade Point Average by aggregating the grades from all their enrolled courses and then dividing that total sum by the complete count of their courses. Finally, ensure that the STUDENTS table is updated precisely with this newly calculated GPA value for the corresponding student."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_validate_post_author that is executed before an insert operation on the POSTS table. This trigger operates for each row being inserted and begins by declaring two local variables: v_author_exists and v_platform_exists, both of type NUMBER. The trigger first checks if the PLATFORM_ID column of the new row (:NEW.PLATFORM_ID) is not null. If PLATFORM_ID is not null, it enters a nested block to determine if a foreign key constraint exists for PLATFORM_ID in the POSTS table. It does this by selecting a count of rows from the DUAL table where there exists a record in the USER_CONSTRAINTS and USER_CONS_COLUMNS views that matches the criteria: the constraint type is 'R' (indicating a foreign key), the table name is 'POSTS', and the column name is 'PLATFORM_ID'. The result of this query is stored in the v_platform_exists variable. If v_platform_exists is greater than zero, indicating that a foreign key constraint exists, the trigger sets :NEW.PLATFORM_ID to null to prevent a constraint violation due to the absence of a parent table. If any exception occurs during this process, the trigger also sets :NEW.PLATFORM_ID to null. Next, the trigger assigns the value 1 to v_author_exists, representing a placeholder validation for the post author, as there is no POST_AUTHORS table to check against. If v_author_exists equals zero, the trigger raises an application error with the code -20003 and the message 'Post author does not exist.'",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_post_author\nBEFORE INSERT ON POSTS\nFOR EACH ROW\nDECLARE\n    v_author_exists NUMBER;\n    v_platform_exists NUMBER;\nBEGIN\n    -- Check if PLATFORM_ID exists to avoid FK constraint violation\n    IF :NEW.PLATFORM_ID IS NOT NULL THEN\n        BEGIN\n            SELECT COUNT(*)\n            INTO v_platform_exists\n            FROM DUAL\n            WHERE EXISTS (\n                SELECT 1 FROM USER_CONSTRAINTS uc\n                JOIN USER_CONS_COLUMNS ucc ON uc.CONSTRAINT_NAME = ucc.CONSTRAINT_NAME\n                WHERE uc.CONSTRAINT_TYPE = 'R'\n                AND uc.TABLE_NAME = 'POSTS'\n                AND ucc.COLUMN_NAME = 'PLATFORM_ID'\n            );\n            \n            -- If foreign key constraint exists but no parent table accessible,\n            -- set PLATFORM_ID to NULL to avoid constraint violation\n            IF v_platform_exists > 0 THEN\n                :NEW.PLATFORM_ID := NULL;\n            END IF;\n        EXCEPTION\n            WHEN OTHERS THEN\n                :NEW.PLATFORM_ID := NULL;\n        END;\n    END IF;\n    \n    -- Original author validation (kept as no-op since no POST_AUTHORS table exists)\n    v_author_exists := 1;\n    \n    IF v_author_exists = 0 THEN\n        RAISE_APPLICATION_ERROR(-20003, 'Post author does not exist.');\n    END IF;\nEND;",
    "database_name": "social_mpaae_metrics",
    "tables": [
      "COMMENTS",
      "COMMENT_AUTHORS",
      "POSTS"
    ],
    "call_sqls": [
      "INSERT INTO POSTS (POST_ID, PLATFORM_ID, POST_URL, POST_CONTENT, POST_TIME, POST_AUTHOR_ID, POST_TYPE, POST_TAGS, POST_ENGAGEMENT) VALUES ('post1', 1, 'http://example.com/post1', 'Content 1', '2023-01-01', 101, 'Article', 'tag1,tag2', 100)",
      "INSERT INTO POSTS (POST_ID, PLATFORM_ID, POST_URL, POST_CONTENT, POST_TIME, POST_AUTHOR_ID, POST_TYPE, POST_TAGS, POST_ENGAGEMENT) VALUES ('post2', 2, 'http://example.com/post2', 'Content 2', '2023-01-02', 102, 'Blog', 'tag3', 200)",
      "INSERT INTO POSTS (POST_ID, PLATFORM_ID, POST_URL, POST_CONTENT, POST_TIME, POST_AUTHOR_ID, POST_TYPE, POST_TAGS, POST_ENGAGEMENT) VALUES ('post3', NULL, 'http://example.com/post3', 'Content 3', '2023-01-03', 103, 'News', 'tag4,tag5', 150)",
      "INSERT INTO POSTS (POST_ID, PLATFORM_ID, POST_URL, POST_CONTENT, POST_TIME, POST_AUTHOR_ID, POST_TYPE, POST_TAGS, POST_ENGAGEMENT) VALUES ('post4', 1, 'http://example.com/post4', 'Content 4', '2023-01-04', 104, 'Article', 'tag6', 50)",
      "INSERT INTO POSTS (POST_ID, PLATFORM_ID, POST_URL, POST_CONTENT, POST_TIME, POST_AUTHOR_ID, POST_TYPE, POST_TAGS, POST_ENGAGEMENT) VALUES ('post5', 2, 'http://example.com/post5', 'Content 5', '2023-01-05', 105, 'Blog', 'tag7,tag8', 300)"
    ],
    "summary": "Write a Oracle PL/SQL trigger named trg_validate_post_author that fires BEFORE INSERT on each row of the POSTS table. If a new row has a non-null PLATFORM_ID and a foreign key constraint exists on the PLATFORM_ID column in the POSTS table, set the PLATFORM_ID to null to avoid constraint violations. Then, if the author validation fails (simulated by checking if the author exists), raise an application error with the message 'Post author does not exist.'",
    "natural_language": "Write a Oracle PL/SQL trigger named trg_validate_post_author that runs before each row is inserted into the POSTS table. If PLATFORM_ID is not null and there is a foreign key constraint on the PLATFORM_ID column in the POSTS table, set the new PLATFORM_ID value to null. Then, simulate checking if the author exists; if the author does not exist, raise an error with the message 'Post author does not exist.'",
    "id": 100,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_validate_post_author that is executed before an insert operation on the POSTS table. This trigger operates for each row being inserted and begins by declaring two local variables: v_author_exists and v_platform_exists, both of type NUMBER. The trigger first checks if the PLATFORM_ID column of the new row (:NEW.PLATFORM_ID) is not null. If PLATFORM_ID is not null, it enters a nested block to determine if a foreign key constraint exists for PLATFORM_ID in the POSTS table. It does this by selecting a count of rows from the DUAL table where there exists a record in the USER_CONSTRAINTS and USER_CONS_COLUMNS views that matches the criteria: the constraint type is 'R' (indicating a foreign key), the table name is 'POSTS', and the column name is 'PLATFORM_ID'. The result of this query is stored in the v_platform_exists variable. If v_platform_exists is greater than zero, indicating that a foreign key constraint exists, the trigger sets :NEW.PLATFORM_ID to null to prevent a constraint violation due to the absence of a parent table. If any exception occurs during this process, the trigger also sets :NEW.PLATFORM_ID to null. Next, the trigger assigns the value 1 to v_author_exists, representing a placeholder validation for the post author, as there is no POST_AUTHORS table to check against. If v_author_exists equals zero, the trigger raises an application error with the code -20003 and the message 'Post author does not exist.'",
    "original_summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_validate_post_author on the POSTS table. If PLATFORM_ID is not null and a foreign key constraint exists for it, set :NEW.PLATFORM_ID to null. Then, if a placeholder author validation fails (simulated by checking if v_author_exists equals zero), raise an application error 'Post author does not exist.'",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "trigger",
    "original_natural_language": "Define a BEFORE INSERT FOR EACH ROW trigger, designated as trg_validate_post_author, for the POSTS table. The trigger's logic shall proceed as follows: first, if the PLATFORM_ID is not null and a corresponding foreign key constraint is present, the value for :NEW.PLATFORM_ID shall be set to null. Subsequently, a validation for the placeholder author is to be simulated by verifying if the variable v_author_exists equals zero. Should this validation fail, an application error with the message 'Post author does not exist.' must be raised."
  }
]