[
  {
    "ir": "Write a PL/pgSQL stored procedure named `remove_low_value_boxes` that accepts three input parameters: `p_warehouse_code` of type `bigint`, `p_value_threshold` of type `real`, and `p_contents_pattern` of type `text`. The purpose of this procedure is to remove specific records from the table named `\"Boxes\"`. The procedure performs a single `DELETE` operation. This `DELETE` operation targets rows in the `\"Boxes\"` table that satisfy three simultaneous conditions. The first condition requires that the value in the `\"Warehouse\"` column of a given row must be equal to the value provided by the `p_warehouse_code` input parameter. The second condition specifies that the value in the `\"Value\"` column of the same row must be strictly less than the value provided by the `p_value_threshold` input parameter. The third condition involves a pattern matching comparison on the `\"Contents\"` column. Specifically, it requires that the uppercase version of the string in the `\"Contents\"` column must match a pattern. This pattern is constructed by taking the `p_contents_pattern` input parameter, converting it to uppercase using the `UPPER()` function, and then enclosing it with wildcard characters (`%`) on both sides. The `LIKE` operator is used for this case-insensitive pattern matching. Only rows that meet all three of these criteria will be permanently removed from the `\"Boxes\"` table.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_low_value_boxes(p_warehouse_code bigint, p_value_threshold real, p_contents_pattern text)\nAS $$\nBEGIN\n    DELETE FROM \"Boxes\"\n    WHERE \"Warehouse\" = p_warehouse_code\n    AND \"Value\" < p_value_threshold\n    AND UPPER(\"Contents\") LIKE UPPER('%' || p_contents_pattern || '%');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL remove_low_value_boxes(1, 100.0, 'rock');",
      "CALL remove_low_value_boxes(3, 200.0, 'scissors');",
      "CALL remove_low_value_boxes(4, 50.0, 'paper');",
      "CALL remove_low_value_boxes(2, 150.0, 'tool');",
      "CALL remove_low_value_boxes(1, 75.5, '');"
    ],
    "summary": "Create a stored procedure named remove_low_value_boxes that takes parameters for warehouse_code (bigint), value_threshold (real), and contents_pattern (text). Delete boxes from the specified warehouse where the value is below the threshold and the contents (case-insensitive) match the pattern with wildcards.",
    "natural_language": "Create a comprehensive stored procedure, which should be named `remove_low_value_boxes`, designed to accept three distinct input parameters: a `warehouse_code` of type bigint, a `value_threshold` of type real, and a `contents_pattern` of type text. This procedure must meticulously delete all boxes located within the precisely specified warehouse, but only under the strict condition that each box's monetary value is demonstrably and significantly below the provided financial threshold, while also ensuring that the textual description of the box's contents, when evaluated in a completely case-insensitive manner, successfully matches the given pattern, which may intelligently incorporate wildcard characters for flexible matching.",
    "id": 1,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named remove_low_value_boxes that accepts three input parameters: warehouse_code of type bigint, value_threshold of type real, and contents_pattern of type text. The procedure is designed to delete records from the Boxes table based on specific conditions. The procedure does not declare any local variables. It performs a DELETE operation on the Boxes table. The deletion targets rows where the Warehouse column exactly matches the warehouse_code parameter. Additionally, the Value column must be strictly less than the value_threshold parameter. Furthermore, the Contents column must match the contents_pattern parameter in a case-insensitive manner, where the pattern can include wildcard characters such as percent signs for flexible string matching; this is achieved using the ILIKE operator. The procedure executes a single DELETE statement that applies all these conditions simultaneously, removing all Boxes records that satisfy the combined criteria of belonging to the specified warehouse, having a value below the given threshold, and having contents that case-insensitively match the provided pattern. The procedure does not return any value; it performs the deletion and completes."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named bulk_insert_countries that accepts three input parameters: p_base_name of type text, which serves as a base string for generating country names; p_count of type integer, which specifies the total number of new country records to create; and p_base_score of type real, which provides a base numerical score. The procedure begins by declaring local variables i, v_country_name, v_score, and v_max_id. It first executes a SELECT query on the countries table to retrieve the current maximum value from the id column, storing the result in v_max_id; if the id column contains no values, the COALESCE function returns 0. The procedure then enters a FOR loop that iterates from 1 to the value of p_count. In each iteration, it constructs v_country_name by concatenating the p_base_name parameter, an underscore character, and the string representation of the current loop index i. It calculates v_score by adding the p_base_score parameter to the remainder of dividing the current index i by 10, using the MOD function. Finally, for each iteration, it performs an INSERT operation into the countries table, specifying values for the id, name, and overall_score columns: the id is set to the sum of v_max_id and the current index i, the name is set to v_country_name, and the overall_score is set to v_score.",
    "plsql": "CREATE OR REPLACE PROCEDURE bulk_insert_countries(p_base_name text, p_count integer, p_base_score real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    i integer;\n    v_country_name text;\n    v_score real;\n    v_max_id bigint;\nBEGIN\n    -- Get the current maximum ID to ensure unique IDs\n    SELECT COALESCE(MAX(id), 0) INTO v_max_id FROM countries;\n    \n    FOR i IN 1..p_count LOOP\n        v_country_name := p_base_name || '_' || i::text;\n        v_score := p_base_score + MOD(i, 10);\n        INSERT INTO countries (id, name, overall_score) \n        VALUES (v_max_id + i, v_country_name, v_score);\n    END LOOP;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "CALL bulk_insert_countries('TestCountryA', 5, 85.5);",
      "CALL bulk_insert_countries('NewRegion', 10, 70.0);",
      "CALL bulk_insert_countries('ContinentX', 3, 92.1);",
      "CALL bulk_insert_countries('IslandNation', 1, 99.9);",
      "CALL bulk_insert_countries('Developing', 7, 60.0);"
    ],
    "summary": "Create a stored procedure named bulk_insert_countries that takes a base name, a count, and a base score. Generate and insert the specified number of country records with sequential IDs (starting after the current maximum), names formed by appending \"_index\" to the base name, and scores calculated as base score plus (index modulo 10).",
    "natural_language": "Develop a stored procedure, which should be named bulk_insert_countries, designed to accept three distinct input parameters: a foundational name string, a numerical count, and a base score value. This procedure must meticulously generate and then insert a precise quantity of country records, as specified by the count parameter. Each new record should receive a sequentially assigned ID, beginning immediately after the currently highest existing ID in the table. The country names are to be constructed by systematically appending an underscore followed by the sequential index number to the provided base name. Furthermore, the score for each entry must be dynamically calculated by taking the supplied base score and adding to it the result of the current index number modulo ten.",
    "id": 2,
    "generated_ir": "Write a PLpgSQL stored procedure named bulk_insert_countries that accepts three input parameters: p_base_name of type text, which serves as a base string for generating country names; p_count of type integer, which specifies the total number of new country records to create; and p_base_score of type real, which provides a base numerical score. The procedure begins by declaring local variables i, v_country_name, v_score, and v_max_id. It first executes a SELECT query on the countries table to retrieve the current maximum value from the id column, storing the result in v_max_id; if the id column contains no values, the COALESCE function returns 0. The procedure then enters a FOR loop that iterates from 1 to the value of p_count. In each iteration, it constructs v_country_name by concatenating the p_base_name parameter, an underscore character, and the string representation of the current loop index i. It calculates v_score by adding the p_base_score parameter to the remainder of dividing the current index i by 10, using the MOD function. Finally, for each iteration, it performs an INSERT operation into the countries table, specifying values for the id, name, and overall_score columns: the id is set to the sum of v_max_id and the current index i, the name is set to v_country_name, and the overall_score is set to v_score."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_architect_projects` that accepts a single input parameter, `p_architect_id`, of type `INTEGER`. This procedure is designed to perform various operations on architect-related data based on the provided architect's ID.\n\nUpon execution, the procedure first declares several local variables: `v_architect_name` of type `TEXT` to store the architect's name, `v_bridge_count` of type `INTEGER` to store the count of bridges, `v_mill_count` of type `INTEGER` to store the count of mills, `v_total_length` of type `REAL` to store the sum of bridge lengths, `v_avg_year` of type `INTEGER` to store the average built year of mills, and `v_action_code` of type `INTEGER` to store a numerical code representing the action taken.\n\nThe procedure then attempts to retrieve the `name` from the `architect` table into the `v_architect_name` variable, specifically for the row where the `id` column, explicitly cast to an `INTEGER`, matches the input parameter `p_architect_id`.\n\nFollowing this initial data retrieval, the procedure enters a conditional block to determine the subsequent actions:\n\n1.  **If `v_architect_name` is `NULL`**: This condition implies that no architect with the given `p_architect_id` was found in the `architect` table. In this scenario, the procedure inserts a new record into the `bridge` table. The `id` for this new bridge is determined by selecting the maximum existing `id` from the `bridge` table, using `COALESCE` to default to `0` if no `id` exists, and then adding `1` to it. The `architect_id` for this new bridge is set to the input `p_architect_id`. The `name` is set to the literal string 'Default Bridge', the `location` to 'Unknown', the `length_meters` to `50.0`, and the `length_feet` to `164.0`.\n\n2.  **Else if `p_architect_id` is less than `10`**: If an architect was found and their `id` is less than `10`, the procedure proceeds to count the number of bridges and mills associated with this architect. It selects the count of all rows from the `bridge` table where the `architect_id` matches `p_architect_id` and stores this count in `v_bridge_count`. Concurrently, it selects the count of all rows from the `mill` table where the `architect_id` matches `p_architect_id` and stores this count in `v_mill_count`. Finally, it calculates `v_action_code` by summing `v_bridge_count` and `v_mill_count`.\n\n3.  **Else if `p_architect_id` is between `10` and `20` (inclusive)**: If the architect's `id` falls within this range, the procedure calculates the total length of bridges and the average built year of mills for this architect. It selects the sum of the `length_meters` column from the `bridge` table where the `architect_id` matches `p_architect_id` and stores this sum in `v_total_length`. Simultaneously, it selects the average of the `built_year` column from the `mill` table where the `architect_id` matches `p_architect_id` and stores this average in `v_avg_year`. The `v_action_code` is then calculated by summing the `v_total_length` (coalesced to `0` if `NULL` and then cast to `INTEGER`) and `v_avg_year` (coalesced to `0` if `NULL`).\n\n4.  **Else if `p_architect_id` is greater than `20` AND `p_architect_id` is less than `50`**: For architects whose `id` is in this specific range, the procedure performs deletion operations. It deletes rows from the `bridge` table where the `architect_id` matches `p_architect_id` AND the `length_meters` is less than `100`. Concurrently, it deletes rows from the `mill` table where the `architect_id` matches `p_architect_id` AND the `built_year` is less than `1900`. After these deletions, `v_action_code` is set to `1`.\n\n5.  **Else (for any other `p_architect_id` value)**: If none of the above conditions are met, the procedure updates the `architect` table. It sets the `name` column to the ASCII representation of its current value (using the `to_ascii` function) for the row where the `id` column, explicitly cast to an `INTEGER`, matches `p_architect_id`. After this update, `v_action_code` is set to `2`.\n\nFinally, regardless of the conditional path taken, the procedure raises a notice message using `RAISE NOTICE`. This message displays the text 'Processed architect % with code %', substituting the first `%` with the value of `v_architect_name` and the second `%` with the value of `v_action_code`.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_architect_projects(p_architect_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_architect_name TEXT;\n    v_bridge_count INTEGER;\n    v_mill_count INTEGER;\n    v_total_length REAL;\n    v_avg_year INTEGER;\n    v_action_code INTEGER;\nBEGIN\n    SELECT \"name\" INTO v_architect_name FROM \"architect\" WHERE \"id\"::INTEGER = p_architect_id;\n    \n    IF v_architect_name IS NULL THEN\n        INSERT INTO \"bridge\" (\"id\", \"architect_id\", \"name\", \"location\", \"length_meters\", \"length_feet\")\n        VALUES ((SELECT COALESCE(MAX(\"id\"), 0) + 1 FROM \"bridge\"), p_architect_id, 'Default Bridge', 'Unknown', 50.0, 164.0);\n    ELSIF p_architect_id < 10 THEN\n        SELECT COUNT(*) INTO v_bridge_count FROM \"bridge\" WHERE \"architect_id\" = p_architect_id;\n        SELECT COUNT(*) INTO v_mill_count FROM \"mill\" WHERE \"architect_id\" = p_architect_id;\n        v_action_code := v_bridge_count + v_mill_count;\n    ELSIF p_architect_id BETWEEN 10 AND 20 THEN\n        SELECT SUM(\"length_meters\") INTO v_total_length FROM \"bridge\" WHERE \"architect_id\" = p_architect_id;\n        SELECT AVG(\"built_year\") INTO v_avg_year FROM \"mill\" WHERE \"architect_id\" = p_architect_id;\n        v_action_code := COALESCE(v_total_length, 0)::INTEGER + COALESCE(v_avg_year, 0);\n    ELSIF p_architect_id > 20 AND p_architect_id < 50 THEN\n        DELETE FROM \"bridge\" WHERE \"architect_id\" = p_architect_id AND \"length_meters\" < 100;\n        DELETE FROM \"mill\" WHERE \"architect_id\" = p_architect_id AND \"built_year\" < 1900;\n        v_action_code := 1;\n    ELSE\n        UPDATE \"architect\" SET \"name\" = to_ascii(\"name\") WHERE \"id\"::INTEGER = p_architect_id;\n        v_action_code := 2;\n    END IF;\n    \n    RAISE NOTICE 'Processed architect % with code %', v_architect_name, v_action_code;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL process_architect_projects(1);",
      "CALL process_architect_projects(5);",
      "CALL process_architect_projects(15);",
      "CALL process_architect_projects(30);",
      "CALL process_architect_projects(60);"
    ],
    "summary": "Create a stored procedure named process_architect_projects that takes an architect ID as input. It retrieves the architect's name. Based on the ID value, it performs different actions: if the architect is not found, it inserts a default bridge; if ID < 10, it counts the architect's bridges and mills; if ID is between 10 and 20 inclusive, it calculates total bridge length and average mill built year; if ID is between 21 and 49, it deletes short bridges and old mills for that architect; otherwise, it updates the architect's name to its ASCII representation. Finally, it outputs a notice with the architect name and an action code.",
    "natural_language": "Hey, can you whip up a stored procedure called process_architect_projects that needs an architect's ID? First, grab the architect's name. Then, depending on the ID, do this stuff: if you can't find the architect at all, just plop in a default bridge. If the ID's less than 10, count up how many bridges and mills they've got. If the ID's from 10 to 20 (including those), figure out the total length of all their bridges and the average year their mills were built. If it's between 21 and 49, get rid of any short bridges and old mills belonging to that architect. For any other ID, just update the architect's name to its ASCII code version. At the end, shoot out a notice with the architect's name and a code saying what you did.",
    "id": 3,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_architect_projects that accepts a single input parameter, p_architect_id, of type INTEGER, representing the architect's ID. The procedure begins by declaring variables: v_architect_name of type TEXT to store the architect's name, v_bridge_count of type INTEGER to count bridges, v_mill_count of type INTEGER to count mills, v_total_length of type REAL to sum bridge lengths, v_avg_year of type REAL to calculate the average built year of mills, v_action_code of type TEXT to indicate the action performed, and v_notice_message of type TEXT to construct the output notice. The procedure first executes a SELECT query to retrieve the name column from the architect table where the id column equals the p_architect_id parameter, storing the result into v_architect_name. If no architect is found (i.e., v_architect_name is NULL), it performs an INSERT into the bridge table, generating a random id using floor(random() * 1000)::integer, setting architect_id to p_architect_id, name to 'Default Bridge', location to 'Unknown', length_meters to 0.0, and length_feet to 0.0, then sets v_action_code to 'INSERT_DEFAULT_BRIDGE'. If an architect is found, it evaluates the p_architect_id value. If p_architect_id is less than 10, it executes two SELECT COUNT(*) queries: one into v_bridge_count from the bridge table where architect_id equals p_architect_id, and one into v_mill_count from the mill table where architect_id equals p_architect_id, then sets v_action_code to 'COUNT_PROJECTS'. If p_architect_id is between 10 and 20 inclusive, it executes two aggregate queries: a SELECT SUM(length_meters) into v_total_length from the bridge table where architect_id equals p_architect_id, and a SELECT AVG(built_year) into v_avg_year from the mill table where architect_id equals p_architect_id, then sets v_action_code to 'CALCULATE_METRICS'. If p_architect_id is between 21 and 49 inclusive, it performs two DELETE operations: one on the bridge table where architect_id equals p_architect_id and length_meters is less than 50.0, and one on the mill table where architect_id equals p_architect_id and built_year is less than 1850, then sets v_action_code to 'DELETE_SHORT_AND_OLD'. For any other p_architect_id value (i.e., 50 or greater), it executes an UPDATE on the architect table, setting the name column to a string of ASCII codes by converting each character of the current name to its ASCII code using the chr and ascii functions, specifically by applying string_agg(ascii(ch)::text, ' ') over the characters of v_architect_name, where the id equals p_architect_id, then sets v_action_code to 'UPDATE_NAME_TO_ASCII'. After the conditional block, the procedure constructs v_notice_message by concatenating the architect's name (or 'Unknown' if NULL) with the action code, formatted as 'Architect: [name] - Action: [code]'. Finally, it outputs a NOTICE with the message v_notice_message."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_city_institutions that accepts a single input parameter p_city of type text, representing a city name, and performs a series of operations on the institution and Championship tables based on the count of institutions and championships associated with that city. The procedure first declares two local integer variables, v_institution_count and v_championship_count. It then calculates v_institution_count by performing a SELECT COUNT(*) query from the institution table where the City column exactly matches the provided p_city parameter. Next, it calculates v_championship_count by performing a SELECT COUNT(*) query from the Championship table (aliased as c) joined with the institution table (aliased as i) on the condition that c.Institution_ID equals i.Institution_ID, where the i.City column matches the p_city parameter. Following these counts, the procedure executes a conditional IF-ELSIF-ELSE block. If v_institution_count equals zero, indicating no institutions exist for the city, it performs an INSERT into the institution table, specifying values for the columns Institution_ID, Name, Team, City, Province, Founded, Affiliation, Enrollment, Endowment, Stadium, and Capacity. The Institution_ID value is derived from a subquery that selects the COALESCE(MAX(Institution_ID), 0) + 1 from the institution table. The Name is set to 'New University', Team to 'New Team', City to the p_city parameter, Province to 'Unknown', Founded to the current year extracted via EXTRACT(YEAR FROM CURRENT_DATE), Affiliation to 'Public', Enrollment to 1000, Endowment to '$0', Stadium to 'Temporary', and Capacity to 1000. If the first condition is false and v_championship_count equals zero, indicating institutions exist but no championships are associated with them for the city, it performs an INSERT into the Championship table, specifying columns Institution_ID, Nickname, Joined, and Number_of_Championships. The values are selected from a query on the institution table (aliased as i) where i.City equals p_city and where a NOT EXISTS subquery ensures the record does not already exist in the Championship table (aliased as c) for the same Institution_ID. The selected values are i.Institution_ID, a concatenated string using CONCAT(i.Team, '-Champs') for Nickname, the current year extracted via EXTRACT(YEAR FROM CURRENT_DATE) for Joined, and 0 for Number_of_Championships. If neither of the previous conditions is true, meaning both institution and championship counts are greater than zero, it executes a DELETE operation on the Championship table where the Institution_ID is in a subquery result. The subquery selects i.Institution_ID from the institution table (aliased as i) where i.City equals p_city and the i.Enrollment column is less than 10000, and the deletion only occurs for those records where the Championship table's Number_of_Championships column equals 0.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_city_institutions(p_city text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_institution_count integer;\n    v_championship_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_institution_count\n    FROM \"institution\"\n    WHERE \"City\" = p_city;\n\n    SELECT COUNT(*) INTO v_championship_count\n    FROM \"Championship\" c\n    JOIN \"institution\" i ON c.\"Institution_ID\" = i.\"Institution_ID\"\n    WHERE i.\"City\" = p_city;\n\n    IF v_institution_count = 0 THEN\n        INSERT INTO \"institution\" (\"Institution_ID\", \"Name\", \"Team\", \"City\", \"Province\", \"Founded\", \"Affiliation\", \"Enrollment\", \"Endowment\", \"Stadium\", \"Capacity\")\n        VALUES ((SELECT COALESCE(MAX(\"Institution_ID\"), 0) + 1 FROM \"institution\"), 'New University', 'New Team', p_city, 'Unknown', EXTRACT(YEAR FROM CURRENT_DATE), 'Public', 1000, '$0', 'Temporary', 1000);\n    ELSIF v_championship_count = 0 THEN\n        INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n        SELECT i.\"Institution_ID\", CONCAT(i.\"Team\", '-Champs'), EXTRACT(YEAR FROM CURRENT_DATE), 0\n        FROM \"institution\" i\n        WHERE i.\"City\" = p_city\n        AND NOT EXISTS (SELECT 1 FROM \"Championship\" c WHERE c.\"Institution_ID\" = i.\"Institution_ID\");\n    ELSE\n        DELETE FROM \"Championship\"\n        WHERE \"Institution_ID\" IN (\n            SELECT i.\"Institution_ID\"\n            FROM \"institution\" i\n            WHERE i.\"City\" = p_city\n            AND i.\"Enrollment\" < 10000\n        )\n        AND \"Number_of_Championships\" = 0;\n    END IF;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL process_city_institutions('Vancouver');",
      "CALL process_city_institutions('Calgary');",
      "CALL process_city_institutions('Edmonton');",
      "CALL process_city_institutions('Toronto');",
      "CALL process_city_institutions('Montreal');"
    ],
    "summary": "Create a stored procedure named process_city_institutions that accepts a city name (text). Count institutions in the city and championships for those institutions. If no institutions exist, insert a new institution with default values. If institutions exist but no championships, insert a new championship for each institution. If both exist, delete championships for institutions in the city with enrollment < 10000 and number_of_championships = 0.",
    "natural_language": "Make a stored procedure called process_city_institutions that takes a city name. Figure out roughly how many institutions are in that general area and also get a sense of their championship counts. If there don't seem to be any institutions at all, put in a new institution with some basic default details. If there are institutions but they don't appear to have any championships, add a new championship for each of those places. If both are present, remove championships for institutions in that city that have kind of low enrollment and no championships to speak of.",
    "id": 4,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_city_institutions that accepts one input parameter: a city name of type TEXT. This procedure operates on the institution_sports database and interacts with two tables: institution and Championship. The procedure first determines the number of institutions located in the specified city and assesses their championship counts. Based on this assessment, it performs one of three conditional operations: inserting a new institution if none exist, inserting new championship records for existing institutions without championships, or deleting championship records for institutions with low enrollment and no championships.\n\nFirst, the procedure declares two local variables: institution_count of type INTEGER to store the number of institutions in the given city, and championship_count of type INTEGER to store the total number of championships across those institutions.\n\nThe procedure begins by assigning a value to institution_count using a SELECT statement with a COUNT aggregation. This SELECT statement counts the number of rows in the institution table where the City column matches the input city name parameter.\n\nNext, the procedure assigns a value to championship_count using a SELECT statement with a SUM aggregation and a LEFT JOIN. This SELECT statement sums the Number_of_Championships column from the Championship table for all institutions in the specified city. It performs a LEFT JOIN between the institution table and the Championship table on the Institution_ID column, filtering the results to rows where the institution.City column matches the input city name parameter. The COALESCE function is used to convert a NULL sum result to 0.\n\nFollowing this, the procedure evaluates the counts using a conditional IF-ELSIF-ELSE block:\n\n1. **IF institution_count is equal to 0** (indicating no institutions exist in the city):\n   The procedure executes an INSERT statement into the institution table. This INSERT statement populates the columns with default values: Institution_ID is set to a value calculated by adding 1 to the maximum Institution_ID currently in the institution table (using a subquery with MAX and COALESCE to handle an empty table), Name is set to the string literal 'New Institution', Team is set to the string literal 'New Team', City is set to the input city name parameter, Province is set to an empty string, Founded is set to 2023.0, Affiliation is set to the string literal 'Unknown', Enrollment is set to 1000.0, Endowment is set to the string literal '$0', Stadium is set to the string literal 'TBD', and Capacity is set to 1000.0.\n\n2. **ELSE IF championship_count is equal to 0** (indicating institutions exist but have no championships):\n   The procedure executes an INSERT statement for each institution in the city that lacks a championship record. This is done using a loop or a subquery that identifies institutions by performing a LEFT JOIN between the institution table and the Championship table on Institution_ID, selecting Institution_ID from institution where City matches the input parameter and the corresponding Championship.Institution_ID is NULL. For each such institution, the INSERT into the Championship table populates: Institution_ID with the institution's ID, Nickname with the string literal 'New Entry', Joined with the current year extracted using the EXTRACT(YEAR FROM CURRENT_DATE) function, and Number_of_Championships with 0.0.\n\n3. **ELSE** (if both institutions and championships exist):\n   The procedure executes a DELETE statement on the Championship table. This DELETE removes records for institutions in the specified city that have low enrollment (defined as an Enrollment value less than 5000.0 in the institution table) and no championships (defined as a Number_of_Championships value equal to 0.0 in the Championship table). The deletion is performed using a subquery that joins the institution and Championship tables on Institution_ID, filtering for rows where institution.City matches the input city name parameter, institution.Enrollment is less than 5000.0, and Championship.Number_of_Championships is 0.0.\n\nThe procedure does not return a value; it is a void procedure that performs data manipulation based on the conditions."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named handle_empty_range_artist that accepts a single input parameter called artist_name of type text, which is used to identify an artist by their last name. The procedure begins by declaring two local variables, artist_birth and artist_death, both of type bigint, and a third variable named test_range of type numrange. It then executes a SELECT query on the \"Artists\" table to retrieve the \"birthYear\" and \"deathYear\" columns for the specific row where the \"lname\" column matches the provided artist_name parameter, storing the retrieved values into the artist_birth and artist_death variables. If both retrieved values are not null, the procedure constructs a numeric range named test_range by casting artist_birth and artist_death to numeric and passing them to the numrange constructor. It then checks if this constructed range is empty using the isempty function. If the range is empty, the procedure performs two DELETE operations: first, it deletes rows from the \"Paintings\" table where the \"painterID\" column equals the \"artistID\" value from the \"Artists\" table for the specified artist_name; second, it deletes rows from the \"Sculptures\" table where the \"sculptorID\" column equals that same \"artistID\". If the constructed range is not empty, the procedure executes an INSERT operation into the \"Paintings\" table, adding a new row with the \"title\" column set to the string 'Valid Range Painting', the \"year\" column set to the current year extracted from the system date using EXTRACT(YEAR FROM CURRENT_DATE), and the \"painterID\" column set to the \"artistID\" value from the \"Artists\" table for the specified artist_name. The procedure performs no action if either the artist_birth or artist_death value retrieved from the initial SELECT is null.",
    "plsql": "CREATE OR REPLACE PROCEDURE handle_empty_range_artist(artist_name text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    artist_birth bigint;\n    artist_death bigint;\n    test_range numrange;\nBEGIN\n    SELECT \"birthYear\", \"deathYear\" INTO artist_birth, artist_death \n    FROM \"Artists\" WHERE \"lname\" = artist_name;\n    \n    IF artist_birth IS NOT NULL AND artist_death IS NOT NULL THEN\n        test_range := numrange(artist_birth::numeric, artist_death::numeric);\n        \n        IF isempty(test_range) THEN\n            DELETE FROM \"Paintings\" WHERE \"painterID\" = (SELECT \"artistID\" FROM \"Artists\" WHERE \"lname\" = artist_name);\n            DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = (SELECT \"artistID\" FROM \"Artists\" WHERE \"lname\" = artist_name);\n        ELSE\n            INSERT INTO \"Paintings\" (\"title\", \"year\", \"painterID\") \n            VALUES ('Valid Range Painting', EXTRACT(YEAR FROM CURRENT_DATE), \n                   (SELECT \"artistID\" FROM \"Artists\" WHERE \"lname\" = artist_name));\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL handle_empty_range_artist('Seurat');",
      "CALL handle_empty_range_artist('Picasso');",
      "CALL handle_empty_range_artist('van Gogh');",
      "CALL handle_empty_range_artist('Monet');",
      "CALL handle_empty_range_artist('Dali');"
    ],
    "summary": "Create a stored procedure named handle_empty_range_artist that takes an artist's last name as input. Retrieve the artist's birth and death years. If both are present, create a numeric range. If the range is empty, delete all paintings and sculptures by that artist. If the range is valid, insert a new painting titled 'Valid Range Painting' for the artist.",
    "natural_language": "Develop a stored procedure, which should be named handle_empty_range_artist, designed to accept the last name of a specific artist as its input parameter. The procedure must first retrieve the detailed birth year and death year for that particular artist. Subsequently, if both of these crucial dates are definitively present, a numeric range should be constructed from them. In the event that this calculated range is found to be completely empty, the procedure must then proceed to meticulously delete every single painting and sculpture associated with that artist. Conversely, if the range is confirmed to be valid and non-empty, the procedure should insert a brand new painting, explicitly titled 'Valid Range Painting', and correctly assign it to the artist in question.",
    "id": 5,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named handle_empty_range_artist that accepts a single input parameter, artist_last_name, of type TEXT. The procedure operates on the art_1 database. It begins by declaring two local variables: artist_birth_year and artist_death_year, both of type BIGINT, and a third variable, artist_id, also of type BIGINT.\n\nFirst, the procedure retrieves the artistID, birthYear, and deathYear for the specified artist by executing a SELECT statement on the Artists table, filtering by the lname column to match the artist_last_name parameter. It stores the retrieved artistID into the artist_id variable, birthYear into artist_birth_year, and deathYear into artist_death_year.\n\nNext, the procedure checks if both artist_birth_year and artist_death_year are not null. If either is null, the procedure does nothing further and exits. If both are present, it calculates a numeric range by subtracting the birth year from the death year (i.e., deathYear - birthYear) to determine the range length.\n\nThe procedure then evaluates if this calculated range is empty. An empty range is defined as being less than or equal to zero (i.e., deathYear - birthYear <= 0). If the range is empty, the procedure performs two deletion operations: it deletes all rows from the Paintings table where the painterID column matches the artist_id variable, and it deletes all rows from the Sculptures table where the sculptorID column matches the artist_id variable.\n\nConversely, if the range is valid and non-empty (i.e., deathYear - birthYear > 0), the procedure inserts a new row into the Paintings table. This new painting has a paintingID generated by selecting the maximum paintingID from the Paintings table, using COALESCE to handle cases where no paintings exist (defaulting to 0), and incrementing this value by 1. The title is set to 'Valid Range Painting', the year is set to the current year (extracted using EXTRACT(YEAR FROM CURRENT_DATE)), height_mm and width_mm are set to 1000, medium is set to 'oil', mediumOn is set to 'canvas', location is set to NULL, and painterID is set to the artist_id variable.\n\nThe procedure does not return any value; it performs the operations based on the conditions described."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named add_mill_structure that accepts two input parameters: an integer parameter named arch_id and a text parameter named mill_name, and performs a single INSERT operation into a database table named mill, specifically populating the architect_id column with the value from the arch_id parameter, the name column with the value from the mill_name parameter, the location column with the hardcoded string literal 'Default Location', the type column with the hardcoded string literal 'Standard', and the built_year column with the current calendar year derived by applying the EXTRACT function to the CURRENT_DATE function to obtain its YEAR component.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_mill_structure(arch_id INTEGER, mill_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO mill (architect_id, name, location, type, built_year)\n    VALUES (arch_id, mill_name, 'Default Location', 'Standard', EXTRACT(YEAR FROM CURRENT_DATE));\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL add_mill_structure(1, 'New Mill One');",
      "CALL add_mill_structure(2, 'Modern Mill Design');",
      "CALL add_mill_structure(3, 'Hadid Mill Project');",
      "CALL add_mill_structure(1, 'Second Wright Mill');",
      "CALL add_mill_structure(2, 'Gehry Experimental Mill');"
    ],
    "summary": "Create a stored procedure named add_mill_structure that inserts a new mill record. It takes an architect ID and a mill name as inputs. The procedure sets the location to 'Default Location', the type to 'Standard', and the built year to the current year.",
    "natural_language": "Create a comprehensive stored procedure, which should be named 'add_mill_structure', that is specifically designed to insert a brand new record into the mill table. This procedure must accept two distinct input parameters: the unique identifier for the architect and the full, official name of the mill. Within its detailed logic, it will meticulously assign the location to the predefined string 'Default Location', explicitly set the structural type to 'Standard', and carefully populate the built year with the exact current year from the system.",
    "id": 6,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named add_mill_structure that accepts two input parameters: p_architect_id of type integer and p_name of type text. The procedure is designed to insert a new record into the mill table. It begins by declaring a local variable v_id of type integer to hold the new mill's unique identifier. It also declares a local variable v_current_year of type integer to store the current year extracted from the system.\n\nThe procedure executes a SELECT statement to retrieve the maximum value of the id column from the mill table. It uses the COALESCE function to handle cases where the table is empty, defaulting to 0. It then increments this maximum value by 1 to generate a new unique id, storing the result in the v_id variable.\n\nNext, the procedure obtains the current system year by using the EXTRACT function on the CURRENT_DATE, specifically extracting the year component, and stores this value in the v_current_year variable.\n\nSubsequently, the procedure performs an INSERT operation into the mill table. The columns populated are id, architect_id, name, location, type, built_year, and notes. The values inserted are: v_id for the id column, p_architect_id for the architect_id column, p_name for the name column, the constant string 'Default Location' for the location column, the constant string 'Standard' for the type column, v_current_year for the built_year column, and NULL for the notes column, as no value is provided for it.\n\nThe procedure does not include any conditional logic, loops, or explicit error handling. Its sole purpose is to generate a new id, capture the current year, and insert a new row into the mill table using the provided parameters and the predefined constant values for location and type."
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `update_management_status` that accepts two input parameters: `p_dept_id`, an integer representing a department identifier, and `p_head_id`, an integer representing a head identifier. The procedure's primary function is to manage the presence of a specific department-head association within the `management` table. It begins by executing a `SELECT` statement to check for the existence of a record in the `management` table. This `SELECT` statement attempts to retrieve `1` (a constant value, indicating existence rather than actual data) from the `management` table where the column `\"department_ID\"` is equal to the value provided by the `p_dept_id` parameter AND the column `\"head_ID\"` is equal to the value provided by the `p_head_id` parameter. Based on the outcome of this existence check, a conditional logic path is followed. If the `SELECT` statement finds at least one matching record (i.e., `IF EXISTS` evaluates to TRUE), the procedure then executes a `DELETE` operation. This `DELETE` statement removes all rows from the `management` table where the `\"department_ID\"` column matches the `p_dept_id` parameter AND the `\"head_ID\"` column matches the `p_head_id` parameter. Conversely, if the `SELECT` statement does not find any matching records (i.e., `IF EXISTS` evaluates to FALSE), the procedure executes an `INSERT` operation. This `INSERT` statement adds a new row into the `management` table. The values inserted are: the `p_dept_id` parameter into the `\"department_ID\"` column, the `p_head_id` parameter into the `\"head_ID\"` column, and the literal string value `'Yes'` into the `\"temporary_acting\"` column.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_management_status(p_dept_id integer, p_head_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM management WHERE \"department_ID\" = p_dept_id AND \"head_ID\" = p_head_id) THEN\n        DELETE FROM management WHERE \"department_ID\" = p_dept_id AND \"head_ID\" = p_head_id;\n    ELSE\n        INSERT INTO management(\"department_ID\", \"head_ID\", \"temporary_acting\")\n        VALUES (p_dept_id, p_head_id, 'Yes');\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL update_management_status(1, 1);",
      "CALL update_management_status(2, 3);",
      "CALL update_management_status(3, 2);",
      "CALL update_management_status(15, 5);",
      "CALL update_management_status(2, 5);"
    ],
    "summary": "Create a stored procedure named update_management_status that takes a department ID and a head ID. Check if this department-head combination exists in the management table. If it exists, delete the record. If it doesn't exist, insert a new record with 'Yes' in the temporary_acting column.",
    "natural_language": "Hey, can you whip up a stored procedure called update_management_status? It needs a department ID and a head ID. Basically, check if that department and head are already paired up in the management table. If they are, just get rid of that entry. If they're not, go ahead and add a new one, and make sure to put 'Yes' in the temporary_acting column.",
    "id": 7,
    "generated_ir": "Write a PL/pgSQL stored procedure named `update_management_status` that accepts two input parameters: `p_dept_id`, an integer representing a department identifier, and `p_head_id`, an integer representing a head identifier. The procedure's primary function is to manage the presence of a specific department-head association within the `management` table. It begins by executing a `SELECT` statement to check for the existence of a record in the `management` table. This `SELECT` statement attempts to retrieve `1` (a constant value, indicating existence rather than actual data) from the `management` table where the column `\"department_ID\"` is equal to the value provided by the `p_dept_id` parameter AND the column `\"head_ID\"` is equal to the value provided by the `p_head_id` parameter. Based on the outcome of this existence check, a conditional logic path is followed. If the `SELECT` statement finds at least one matching record (i.e., `IF EXISTS` evaluates to TRUE), the procedure then executes a `DELETE` operation. This `DELETE` statement removes all rows from the `management` table where the `\"department_ID\"` column matches the `p_dept_id` parameter AND the `\"head_ID\"` column matches the `p_head_id` parameter. Conversely, if the `SELECT` statement does not find any matching records (i.e., `IF EXISTS` evaluates to FALSE), the procedure executes an `INSERT` operation. This `INSERT` statement adds a new row into the `management` table. The values inserted are: the `p_dept_id` parameter into the `\"department_ID\"` column, the `p_head_id` parameter into the `\"head_ID\"` column, and the literal string value `'Yes'` into the `\"temporary_acting\"` column."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `adjust_account_balances` that accepts four input parameters: `p_customer_id` of type `bigint`, `p_adjustment_factor` of type `numeric`, `p_min_balance` of type `numeric`, and `p_max_balance` of type `numeric`. The purpose of this procedure is to modify existing records within the `Accounts` table. Specifically, it performs an `UPDATE` operation on the `Accounts` table. For each row that satisfies the specified conditions, the `account_name` column is updated. The new value for `account_name` is derived by first casting the current `account_name` value, which is stored as `text`, to a `numeric` data type. This numeric representation of `account_name` is then multiplied by the `p_adjustment_factor` parameter. The result of this multiplication, which is a `numeric` value, is then cast back to a `text` data type before being assigned as the new value for the `account_name` column. The `UPDATE` operation is conditionally applied only to those rows where two conditions are met simultaneously: first, the `customer_id` column in the `Accounts` table must exactly match the value provided by the `p_customer_id` input parameter; and second, the `account_name` column, after being cast to a `numeric` data type, must fall within the inclusive range defined by the `p_min_balance` and `p_max_balance` input parameters. That is, the numeric representation of `account_name` must be greater than or equal to `p_min_balance` AND less than or equal to `p_max_balance`.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_account_balances(\n    p_customer_id bigint,\n    p_adjustment_factor numeric,\n    p_min_balance numeric,\n    p_max_balance numeric\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE \"Accounts\"\n    SET account_name = (account_name::numeric * p_adjustment_factor)::text\n    WHERE customer_id = p_customer_id\n    AND account_name::numeric BETWEEN p_min_balance AND p_max_balance;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoice_Line_Items",
      "Invoices",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "CALL adjust_account_balances(8, 1.10, 100, 1000);",
      "CALL adjust_account_balances(3, 0.95, 200, 800);",
      "CALL adjust_account_balances(1, 1.05, 50, 500);",
      "CALL adjust_account_balances(12, 1.15, 0, 10000);",
      "CALL adjust_account_balances(5, 0.90, 10, 2000);"
    ],
    "summary": "Create a stored procedure named `adjust_account_balances` that takes a customer ID, adjustment factor, minimum balance, and maximum balance. Update the `Accounts` table for the specified customer. For each account where the `account_name` (when cast to numeric) is between the minimum and maximum balance (inclusive), set the new `account_name` to the result of multiplying its numeric value by the adjustment factor and casting back to text.",
    "natural_language": "Please construct a stored procedure designated as `adjust_account_balances`. This procedure shall accept the following parameters: a customer identifier, an adjustment factor, a minimum balance threshold, and a maximum balance threshold. The procedure is to execute an update on the `Accounts` table, specifically for records associated with the provided customer. For each qualifying account, where the numeric interpretation of the `account_name` field falls within the inclusive range defined by the minimum and maximum balance parameters, the `account_name` value must be recalculated. The new value shall be derived by multiplying the numeric interpretation of the original `account_name` by the supplied adjustment factor, subsequently casting the resultant product back to a textual data type.",
    "id": 8,
    "generated_ir": "Write a PLpgSQL stored procedure named `adjust_account_balances` that accepts four input parameters: `p_customer_id` of type `bigint`, `p_adjustment_factor` of type `numeric`, `p_min_balance` of type `numeric`, and `p_max_balance` of type `numeric`. The purpose of this procedure is to modify existing records within the `Accounts` table. Specifically, it performs an `UPDATE` operation on the `Accounts` table. For each row that satisfies the specified conditions, the `account_name` column is updated. The new value for `account_name` is derived by first casting the current `account_name` value, which is stored as `text`, to a `numeric` data type. This numeric representation of `account_name` is then multiplied by the `p_adjustment_factor` parameter. The result of this multiplication, which is a `numeric` value, is then cast back to a `text` data type before being assigned as the new value for the `account_name` column. The `UPDATE` operation is conditionally applied only to those rows where two conditions are met simultaneously: first, the `customer_id` column in the `Accounts` table must exactly match the value provided by the `p_customer_id` input parameter; and second, the `account_name` column, after being cast to a `numeric` data type, must fall within the inclusive range defined by the `p_min_balance` and `p_max_balance` input parameters. That is, the numeric representation of `account_name` must be greater than or equal to `p_min_balance` AND less than or equal to `p_max_balance`."
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `update_department_ranking` that accepts three input parameters: `p_department_id` of type `integer`, `new_ranking` of type `integer`, and `min_employees` of type `real`. The purpose of this procedure is to conditionally update the ranking of a specific department and ensure that all relevant heads are associated with that department in the `management` table. The procedure begins by evaluating a conditional statement. This condition checks for the existence of at least one record in the `department` table where the `Department_ID` column matches the value provided in the `p_department_id` input parameter AND the `Num_Employees` column has a value strictly greater than the `min_employees` input parameter. If this condition evaluates to true (i.e., such a department exists and meets the employee count criterion), then the following two operations are executed sequentially. First, an `UPDATE` statement is performed on the `department` table. This `UPDATE` statement sets the value of the `Ranking` column to the value provided in the `new_ranking` input parameter. This update is applied only to the rows in the `department` table where the `Department_ID` column matches the value of the `p_department_id` input parameter. Second, an `INSERT` statement is executed to add new records into the `management` table. The columns being populated in the `management` table are `\"department_ID\"`, `\"head_ID\"`, and `\"temporary_acting\"`. The values for these columns are derived from a `SELECT` subquery. For the `\"department_ID\"` column, the value is directly taken from the `p_department_id` input parameter. For the `\"head_ID\"` column, the values are selected from the `\"head_ID\"` column of the `head` table, aliased as `h`. For the `\"temporary_acting\"` column, a static string literal 'No' is used. The `SELECT` subquery includes a `WHERE` clause that filters the records from the `head` table. This `WHERE` clause ensures that only those `head_ID` values from the `head` table are considered that are NOT present in a nested subquery. The nested subquery selects the `\"head_ID\"` column from the `management` table, aliased as `m`, where the `\"department_ID\"` column in the `management` table matches the `p_department_id` input parameter. This effectively inserts only those heads into the `management` table for the specified department that are not already associated with it. If the initial `IF EXISTS` condition evaluates to false, no operations are performed, and the procedure concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_department_ranking(IN p_department_id integer, IN new_ranking integer, IN min_employees real)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM department d WHERE d.\"Department_ID\" = p_department_id AND d.\"Num_Employees\" > min_employees) THEN\n        UPDATE department \n        SET \"Ranking\" = new_ranking \n        WHERE \"Department_ID\" = p_department_id;\n        \n        INSERT INTO management (\"department_ID\", \"head_ID\", \"temporary_acting\")\n        SELECT p_department_id, h.\"head_ID\", 'No'\n        FROM head h\n        WHERE h.\"head_ID\" NOT IN (SELECT m.\"head_ID\" FROM management m WHERE m.\"department_ID\" = p_department_id);\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL update_department_ranking(1, 5, 10000.0);",
      "CALL update_department_ranking(2, 10, 50000.0);",
      "CALL update_department_ranking(3, 1, 1000000.0);",
      "CALL update_department_ranking(1, 2, 5000.0);",
      "CALL update_department_ranking(2, 7, 20000.0);"
    ],
    "summary": "Create a stored procedure named `update_department_ranking` that takes a department ID, a new ranking, and a minimum employee count as parameters. If a department with the given ID exists and has more employees than the minimum, update its ranking to the new value. Then, insert into the `management` table for that department all heads from the `head` table that are not already assigned to it, using 'No' for the `temporary_acting` column.",
    "natural_language": "Create procedure `update_department_ranking`. If department exists and meets employee minimum, update its rank. Then add unassigned heads to its management with 'No' for temporary_acting.",
    "id": 9,
    "generated_ir": "Write a PL/pgSQL stored procedure named `update_department_ranking` that accepts three input parameters: `p_department_id` of type `integer`, `new_ranking` of type `integer`, and `min_employees` of type `real`. The purpose of this procedure is to conditionally update the ranking of a specific department and ensure that all relevant heads are associated with that department in the `management` table. The procedure begins by evaluating a conditional statement. This condition checks for the existence of at least one record in the `department` table where the `Department_ID` column matches the value provided in the `p_department_id` input parameter AND the `Num_Employees` column has a value strictly greater than the `min_employees` input parameter. If this condition evaluates to true (i.e., such a department exists and meets the employee count criterion), then the following two operations are executed sequentially. First, an `UPDATE` statement is performed on the `department` table. This `UPDATE` statement sets the value of the `Ranking` column to the value provided in the `new_ranking` input parameter. This update is applied only to the rows in the `department` table where the `Department_ID` column matches the value of the `p_department_id` input parameter. Second, an `INSERT` statement is executed to add new records into the `management` table. The columns being populated in the `management` table are `\"department_ID\"`, `\"head_ID\"`, and `\"temporary_acting\"`. The values for these columns are derived from a `SELECT` subquery. For the `\"department_ID\"` column, the value is directly taken from the `p_department_id` input parameter. For the `\"head_ID\"` column, the values are selected from the `\"head_ID\"` column of the `head` table, aliased as `h`. For the `\"temporary_acting\"` column, a static string literal 'No' is used. The `SELECT` subquery includes a `WHERE` clause that filters the records from the `head` table. This `WHERE` clause ensures that only those `head_ID` values from the `head` table are considered that are NOT present in a nested subquery. The nested subquery selects the `\"head_ID\"` column from the `management` table, aliased as `m`, where the `\"department_ID\"` column in the `management` table matches the `p_department_id` input parameter. This effectively inserts only those heads into the `management` table for the specified department that are not already associated with it. If the initial `IF EXISTS` condition evaluates to false, no operations are performed, and the procedure concludes."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `delete_low_sales_songs` that accepts two input parameters: `threshold`, which is of type `REAL`, representing a sales value used as a comparison point, and `singer_id`, which is of type `INTEGER`, representing the unique identifier of a singer. The procedure's sole operation is to perform a `DELETE` statement on the `song` table. This `DELETE` operation targets and removes rows from the `song` table where two conditions are simultaneously met: first, the value in the `\"Sales\"` column is strictly less than the value provided in the `threshold` input parameter, and second, the value in the `\"Singer_ID\"` column is exactly equal to the value provided in the `singer_id` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_low_sales_songs(IN threshold REAL, IN singer_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM song\n    WHERE \"Sales\" < threshold AND \"Singer_ID\" = singer_id;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL delete_low_sales_songs(100000.0, 1);",
      "CALL delete_low_sales_songs(500000.0, 2);",
      "CALL delete_low_sales_songs(200000.0, 1);",
      "CALL delete_low_sales_songs(700000.0, 2);",
      "CALL delete_low_sales_songs(300000.0, 1);"
    ],
    "summary": "Create a stored procedure named delete_low_sales_songs with parameters threshold (REAL) and singer_id (INTEGER). Delete rows from the song table where Sales is less than the threshold and Singer_ID equals the provided singer_id.",
    "natural_language": "Develop a stored procedure called delete_low_sales_songs, which must be configured to accept two distinct input parameters: a threshold value of type REAL and a singer identifier of type INTEGER. This procedure should meticulously remove all records from the song table where the Sales figure is definitively lower than the specified threshold value and, concurrently, where the Singer_ID column matches exactly the provided singer_id parameter.",
    "id": 10,
    "generated_ir": "Write a PLpgSQL stored procedure named `delete_low_sales_songs` that accepts two input parameters: `threshold`, which is of type `REAL`, representing a sales value used as a comparison point, and `singer_id`, which is of type `INTEGER`, representing the unique identifier of a singer. The procedure's sole operation is to perform a `DELETE` statement on the `song` table. This `DELETE` operation targets and removes rows from the `song` table where two conditions are simultaneously met: first, the value in the `\"Sales\"` column is strictly less than the value provided in the `threshold` input parameter, and second, the value in the `\"Singer_ID\"` column is exactly equal to the value provided in the `singer_id` input parameter."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_club_leadership that accepts five parameters: p_source_club of type INTEGER representing the ID of the source club, p_target_club of type INTEGER representing the ID of the target club, p_member_age_min of type INTEGER specifying the minimum age of eligible members, p_new_club_name of type TEXT for the new name of the target club, and p_transfer_year of type TEXT indicating the year of transfer. The procedure begins by declaring two local variables: v_eligible_member of type INTEGER to store the ID of an eligible member, and v_club_performance of type NUMERIC to store the performance ranking of the target club. It first executes a SELECT statement to find a member from the member table who is also a leader in the club_leader table, belongs to the source club specified by p_source_club, and meets the minimum age requirement specified by p_member_age_min. The result is stored in v_eligible_member, and only one member is selected due to the LIMIT 1 clause. Next, it calculates the cumulative distribution of the target club's overall ranking using the cume_dist() window function, ordering by Overall_Ranking in descending order, and stores this value in v_club_performance. If an eligible member is found (v_eligible_member is not null), the procedure inserts a new record into the club_leader table with the target club ID, the eligible member's ID, and the transfer year. It then updates the club table to change the name of the target club to the new name specified by p_new_club_name. If no eligible member is found, the procedure deletes the target club from the club table if its Overall_Ranking is greater than 50. Additionally, it updates the member table to increment the age of all members who are leaders in the source club by 1 year.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_club_leadership(\n    p_source_club INTEGER,\n    p_target_club INTEGER,\n    p_member_age_min INTEGER,\n    p_new_club_name TEXT,\n    p_transfer_year TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_eligible_member INTEGER;\n    v_club_performance NUMERIC;\nBEGIN\n    SELECT m.\"Member_ID\" INTO v_eligible_member\n    FROM \"member\" m\n    JOIN \"club_leader\" cl ON m.\"Member_ID\" = cl.\"Member_ID\"\n    WHERE cl.\"Club_ID\" = p_source_club AND m.\"Age\" >= p_member_age_min\n    LIMIT 1;\n    \n    SELECT cume_dist() OVER (ORDER BY \"Overall_Ranking\" DESC) INTO v_club_performance\n    FROM \"club\"\n    WHERE \"Club_ID\" = p_target_club;\n    \n    IF v_eligible_member IS NOT NULL THEN\n        INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\")\n        VALUES (p_target_club, v_eligible_member, p_transfer_year);\n        \n        UPDATE \"club\"\n        SET \"Club_Name\" = p_new_club_name\n        WHERE \"Club_ID\" = p_target_club;\n    ELSE\n        DELETE FROM \"club\"\n        WHERE \"Club_ID\" = p_target_club AND \"Overall_Ranking\" > 50;\n        \n        UPDATE \"member\"\n        SET \"Age\" = \"Age\" + 1\n        WHERE \"Member_ID\" IN (SELECT \"Member_ID\" FROM \"club_leader\" WHERE \"Club_ID\" = p_source_club);\n    END IF;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL manage_club_leadership(1, 3, 25, 'Texas Elite', '2024');",
      "CALL manage_club_leadership(4, 8, 30, 'New Champions', '2023');",
      "CALL manage_club_leadership(3, 6, 20, 'Renamed Club', '2025');",
      "CALL manage_club_leadership(1, 4, 35, 'Top Performers', '2024');",
      "CALL manage_club_leadership(6, 1, 22, 'Future Stars', '2023');"
    ],
    "summary": "Create a PLpgSQL stored procedure named `manage_club_leadership` with parameters `p_source_club` (INTEGER), `p_target_club` (INTEGER), `p_member_age_min` (INTEGER), `p_new_club_name` (TEXT), and `p_transfer_year` (TEXT). First, select an eligible member leader from the source club meeting the age minimum. Second, calculate the performance rank of the target club. If a member is found, insert them as a leader for the target club and update the target club's name. If no member is found, delete the target club if its ranking is over 50. Finally, increment the age of all members who are leaders in the source club.",
    "natural_language": "Alright, so we need a PLpgSQL procedure called `manage_club_leadership`. It's gotta take in a few things: `p_source_club` (an integer), `p_target_club` (also an integer), `p_member_age_min` (another integer), `p_new_club_name` (some text), and `p_transfer_year` (text too). Here's the deal: first, pick out a member from the source club who's old enough to be a leader. Then, figure out how the target club's been performing, like its rank. If you find a suitable member, make 'em a leader for the target club and give that club its new name. If you can't find anyone, just axe the target club if its ranking's worse than 50. Oh, and before you finish, bump up the age for everyone who's leading in the source club.",
    "id": 11,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named manage_club_leadership that performs a series of operations to manage club leadership based on specified conditions. The procedure takes five input parameters: p_source_club of type integer, representing the source club's ID; p_target_club of type integer, representing the target club's ID; p_member_age_min of type integer, representing the minimum age threshold for selecting a member; p_new_club_name of type text, representing the new name to assign to the target club; and p_transfer_year of type text, representing the year to record for the leadership transfer.\n\nThe procedure begins by selecting a suitable member from the source club to become a leader. It queries the member table to find a member who is associated with the source club via the club_leader table, specifically where the club_leader.Club_ID equals p_source_club and member.Member_ID equals club_leader.Member_ID, and where the member's Age is greater than or equal to p_member_age_min. It selects the first such member based on some ordering (e.g., by Member_ID or Age) and stores the Member_ID in a variable.\n\nNext, the procedure checks the performance of the target club by retrieving its Overall_Ranking from the club table where Club_ID equals p_target_club, storing the ranking in a variable.\n\nIf a suitable member is found (i.e., the Member_ID variable is not null), the procedure proceeds to make this member a leader for the target club. It inserts a new record into the club_leader table with Club_ID set to p_target_club, Member_ID set to the selected member's ID, and Year_Join set to p_transfer_year. Then, it updates the club table for the target club by setting Club_Name to p_new_club_name where Club_ID equals p_target_club.\n\nIf no suitable member is found (i.e., the Member_ID variable is null), the procedure checks the target club's ranking. If the stored Overall_Ranking is less than 50 (indicating worse performance, assuming lower numbers are worse), it deletes the target club from the club table where Club_ID equals p_target_club. If the ranking is 50 or higher, no deletion occurs.\n\nRegardless of the outcome, before finishing, the procedure updates the age of all members who are leaders in the source club. It increments the Age by 1 in the member table for all members whose Member_ID exists in the club_leader table with Club_ID equal to p_source_club.\n\nThe procedure does not return a value; it performs data manipulation operations as described."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"InsertNewCourse\" that accepts a single input parameter called course_name of type TEXT, which represents the name of a new course to be inserted into the database, and within the procedure's logic, first checks if the provided course_name parameter is not NULL, and if this condition is true, performs an INSERT operation into a table named \"course\", specifically targeting the columns \"Course_ID\", \"Staring_Date\", and \"Course\", where for the \"Course_ID\" column value, it executes a subquery to calculate the new identifier by selecting the current maximum numeric value from the \"Course_ID\" column in the \"course\" table and then adding 1 to that maximum, for the \"Staring_Date\" column value, it calls the TO_CHAR function to format the current date and time obtained from the CURRENT_TIMESTAMP function into a string using the 'DD Mon' format mask which results in a day of the month and abbreviated month name like '01 Jan', and for the \"Course\" column value, it directly uses the input parameter course_name.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"InsertNewCourse\"(course_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF course_name IS NOT NULL THEN\n        INSERT INTO \"course\" (\"Course_ID\", \"Staring_Date\", \"Course\")\n        VALUES ((SELECT MAX(\"Course_ID\") + 1 FROM \"course\"), TO_CHAR(CURRENT_TIMESTAMP, 'DD Mon'), course_name);\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL \"InsertNewCourse\"('History');",
      "CALL \"InsertNewCourse\"('Art');",
      "CALL \"InsertNewCourse\"('Music');",
      "CALL \"InsertNewCourse\"('Physical Education');",
      "CALL \"InsertNewCourse\"('Computer Science');"
    ],
    "summary": "Create a stored procedure named InsertNewCourse that inserts a new course record. It generates a new ID by incrementing the current maximum ID, sets the starting date to today's date in 'DD Mon' format, and uses the provided course name, but only if the name is not null.",
    "natural_language": "Create a stored procedure called InsertNewCourse to add a new course. It should figure out a new ID by taking the highest existing one and adding a bit to it, set the start date to roughly around now formatted in a short date style, and use the given course name, but only if that name is provided and isn't empty.",
    "id": 12,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"InsertNewCourse\" that accepts a single input parameter called course_name of type TEXT, which represents the name of a new course to be inserted into the database, and within the procedure's logic, first checks if the provided course_name parameter is not NULL, and if this condition is true, performs an INSERT operation into a table named \"course\", specifically targeting the columns \"Course_ID\", \"Staring_Date\", and \"Course\", where for the \"Course_ID\" column value, it executes a subquery to calculate the new identifier by selecting the current maximum numeric value from the \"Course_ID\" column in the \"course\" table and then adding 1 to that maximum, for the \"Staring_Date\" column value, it calls the TO_CHAR function to format the current date and time obtained from the CURRENT_TIMESTAMP function into a string using the 'DD Mon' format mask which results in a day of the month and abbreviated month name like '01 Jan', and for the \"Course\" column value, it directly uses the input parameter course_name."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `delete_old_players` that accepts two input parameters: `cutoff_age`, which is an `INTEGER` representing the age threshold, and `target_school_id`, which is also an `INTEGER` representing the identifier of a specific school. The procedure's sole operation is to perform a `DELETE` statement on the `player` table. This `DELETE` operation targets and removes all rows from the `player` table where two conditions are simultaneously met: first, the value in the `\"Age\"` column is strictly greater than the value provided by the `cutoff_age` parameter, and second, the value in the `\"School_ID\"` column is exactly equal to the value provided by the `target_school_id` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_players(IN cutoff_age INTEGER, IN target_school_id INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM player \n    WHERE \"Age\" > cutoff_age AND \"School_ID\" = target_school_id;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "CALL delete_old_players(15, 1);",
      "CALL delete_old_players(14, 2);",
      "CALL delete_old_players(16, 1);",
      "CALL delete_old_players(13, 2);",
      "CALL delete_old_players(17, 1);"
    ],
    "summary": "Create a stored procedure named delete_old_players that deletes all rows from the player table where the Age column is greater than the provided cutoff_age parameter and the School_ID column equals the provided target_school_id parameter.",
    "natural_language": "Make a stored procedure called delete_old_players that removes players who are kind of older than a certain age you provide and who are from a specific school you also specify.",
    "id": 13,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `delete_old_players` that accepts two input parameters: `p_age_threshold` of type `integer` to specify the age above which players are considered old, and `p_school_id` of type `integer` to identify the specific school from which players should be removed. The procedure's purpose is to delete records from the `player` table where the player's age is greater than the provided age threshold and the player is associated with the specified school.\n\nThe procedure will perform a `DELETE` operation on the `player` table. The deletion will target rows where the `Age` column value is strictly greater than the value provided by the `p_age_threshold` parameter. Additionally, the deletion will only apply to players whose `School_ID` column value exactly matches the value provided by the `p_school_id` parameter. This ensures that only players who are both older than the specified age and belong to the given school are removed from the database. The procedure does not return any value; it executes the deletion as a standalone operation."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that inserts a new record into the artist table by taking two input parameters: artist_name of type text and artist_age of type integer. The procedure performs an insert operation on the artist table, specifically targeting the columns named Artist and Age. It assigns the value of the artist_name parameter to the Artist column and the value of the artist_age parameter to the Age column, thereby adding a new artist entry with the specified name and age into the table.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_artist(IN artist_name text, IN artist_age integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"artist\" (\"Artist\", \"Age\") VALUES (artist_name, artist_age);\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL insert_new_artist('New Artist 1', 30);",
      "CALL insert_new_artist('New Artist 2', 25);",
      "CALL insert_new_artist('New Artist 3', 40);",
      "CALL insert_new_artist('New Artist 4', 35);",
      "CALL insert_new_artist('New Artist 5', 28);"
    ],
    "summary": "Create a stored procedure that takes a text artist_name and an integer artist_age. Insert a new record into the artist table, setting the Artist column to artist_name and the Age column to artist_age.",
    "natural_language": "Make a stored procedure that accepts an artist's name as text and an age number. Use it to add a new entry to the artist table, putting the given name in the Artist field and the provided number in the Age column.",
    "id": 14,
    "generated_ir": "Write a PLpgSQL stored procedure that inserts a new record into the artist table by taking two input parameters: artist_name of type text and artist_age of type integer. The procedure performs an insert operation on the artist table, specifically targeting the columns named Artist and Age. It assigns the value of the artist_name parameter to the Artist column and the value of the artist_age parameter to the Age column, thereby adding a new artist entry with the specified name and age into the table."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named transfer_conference_participation that accepts three input parameters: an integer parameter p_old_conference_id representing the source conference identifier, an integer parameter p_new_conference_id representing the target conference identifier, and a text parameter p_role representing the new role to be assigned. The procedure performs two sequential data manipulation operations on the conference_participation table. First, it executes an INSERT statement that selects all staff_ID values from the conference_participation table where the Conference_ID column matches the provided p_old_conference_id parameter; for each selected staff_ID, it inserts a new row into the conference_participation table with the Conference_ID column set to the p_new_conference_id parameter, the staff_ID column set to the selected staff_ID value, and the role column set to the provided p_role parameter value. Second, it executes a DELETE statement that removes all rows from the conference_participation table where the Conference_ID column equals the provided p_old_conference_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_conference_participation(\n    p_old_conference_id INTEGER,\n    p_new_conference_id INTEGER,\n    p_role TEXT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO conference_participation (\"Conference_ID\", \"staff_ID\", \"role\")\n    SELECT p_new_conference_id, \"staff_ID\", p_role\n    FROM conference_participation\n    WHERE \"Conference_ID\" = p_old_conference_id;\n    \n    DELETE FROM conference_participation\n    WHERE \"Conference_ID\" = p_old_conference_id;\nEND;\n$$;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "CALL transfer_conference_participation(1, 3, 'Attendee');",
      "CALL transfer_conference_participation(2, 1, 'Speaker');",
      "CALL transfer_conference_participation(1, 2, 'Sponsor');",
      "CALL transfer_conference_participation(3, 2, 'Organizer');",
      "CALL transfer_conference_participation(2, 3, 'Presenter');"
    ],
    "summary": "Create a stored procedure named transfer_conference_participation that copies all staff participants from an old conference to a new one, assigning them a specified new role, and then deletes their participation records from the old conference.",
    "natural_language": "Create procedure transfer_conference_participation to copy staff from old to new conference with a new role, then delete old records.",
    "id": 15,
    "generated_ir": "Write a PLpgSQL stored procedure named transfer_conference_participation that accepts three input parameters: an integer parameter p_old_conference_id representing the source conference identifier, an integer parameter p_new_conference_id representing the target conference identifier, and a text parameter p_role representing the new role to be assigned. The procedure performs two sequential data manipulation operations on the conference_participation table. First, it executes an INSERT statement that selects all staff_ID values from the conference_participation table where the Conference_ID column matches the provided p_old_conference_id parameter; for each selected staff_ID, it inserts a new row into the conference_participation table with the Conference_ID column set to the p_new_conference_id parameter, the staff_ID column set to the selected staff_ID value, and the role column set to the provided p_role parameter value. Second, it executes a DELETE statement that removes all rows from the conference_participation table where the Conference_ID column equals the provided p_old_conference_id parameter."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that deletes rows from the \"Boxes\" table where the \"Value\" column is less than a specified threshold. The procedure is named DeleteLowValueBoxes and accepts a single parameter, p_value_threshold, of type real, which represents the threshold value. The procedure performs a DELETE operation on the \"Boxes\" table, targeting rows where the \"Value\" column is less than the provided p_value_threshold parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteLowValueBoxes(p_value_threshold real)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Boxes\"\n    WHERE \"Value\" < p_value_threshold;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL DeleteLowValueBoxes(100.0);",
      "CALL DeleteLowValueBoxes(200.0);",
      "CALL DeleteLowValueBoxes(50.0);",
      "CALL DeleteLowValueBoxes(300.0);",
      "CALL DeleteLowValueBoxes(150.0);"
    ],
    "summary": "Create a stored procedure named DeleteLowValueBoxes that deletes rows from the Boxes table where the Value column is less than the provided real parameter p_value_threshold.",
    "natural_language": "Please construct a stored procedure designated as 'DeleteLowValueBoxes' to remove records from the Boxes table for which the Value column is inferior to the supplied real parameter, p_value_threshold.",
    "id": 16,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named DeleteLowValueBoxes that accepts one input parameter: p_value_threshold of type real, which specifies the minimum value threshold for boxes to be retained; boxes with a Value less than this threshold will be deleted. The procedure does not declare any local variables. It performs a single DELETE operation on the Boxes table, targeting all rows where the Value column is strictly less than the p_value_threshold parameter. The procedure does not return any value; it is a void procedure that executes the deletion and then completes."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named delete_actors_by_criteria that accepts three input parameters: an integer parameter p_min_age specifying the lower bound of an age range, an integer parameter p_max_age specifying the upper bound of an age range, and an integer parameter p_musical_id specifying a musical identifier; the procedure executes a DELETE operation on the actor table, targeting rows where the age column value falls inclusively between the p_min_age and p_max_age parameter values and where the value in the column named \"Musical_ID\" (case-sensitive) is exactly equal to the p_musical_id parameter value.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_actors_by_criteria(IN p_min_age integer, IN p_max_age integer, IN p_musical_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM actor \n    WHERE age BETWEEN p_min_age AND p_max_age \n    AND \"Musical_ID\" = p_musical_id;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL delete_actors_by_criteria(20, 25, 1);",
      "CALL delete_actors_by_criteria(18, 30, 2);",
      "CALL delete_actors_by_criteria(25, 35, 1);",
      "CALL delete_actors_by_criteria(40, 50, 3);",
      "CALL delete_actors_by_criteria(21, 26, 2);"
    ],
    "summary": "Create a stored procedure named delete_actors_by_criteria that deletes actors from the actor table where their age is between two given inclusive values and their Musical_ID matches a specified musical ID.",
    "natural_language": "How can I create a stored procedure called delete_actors_by_criteria to remove actors from the actor table when their age falls within a specified inclusive range and their Musical_ID equals a given musical ID?",
    "id": 17,
    "generated_ir": "Write a PostgreSQL PLpgSQL stored procedure named delete_actors_by_criteria that accepts three input parameters: an integer parameter p_min_age specifying the lower bound of an age range, an integer parameter p_max_age specifying the upper bound of an age range, and an integer parameter p_musical_id specifying a musical identifier; the procedure executes a DELETE operation on the actor table, targeting rows where the age column value falls inclusively between the p_min_age and p_max_age parameter values and where the value in the column named \"Musical_ID\" (case-sensitive) is exactly equal to the p_musical_id parameter value."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named cleanup_expired_policies that accepts four parameters: p_cutoff_date of type date, p_policy_type of type text, p_customer_pattern of type text, and p_days_buffer of type integer. The procedure begins by declaring two integer variables, v_policy_count and v_affected_customers, to store the count of distinct policies and customers affected by the cleanup operation. It then performs a SELECT query on the Customer_Policies table, joining it with the Customers table using the Customer_ID column to count distinct Policy_IDs and Customer_IDs where the End_Date of the policy is earlier than the date calculated by subtracting p_days_buffer from p_cutoff_date, the Policy_Type_Code matches p_policy_type, and the Customer_Details column in the Customers table matches the pattern specified by p_customer_pattern using the LIKE operator. The results of this query are stored in v_policy_count and v_affected_customers. Next, the procedure deletes records from the Claims table where the Policy_ID matches any Policy_ID from the previously described SELECT query. Following this, it deletes records from the Customer_Policies table where the Policy_ID matches any Policy_ID from the same SELECT query. Finally, the procedure raises a notice displaying the number of policies cleaned up and the number of customers affected, using the values stored in v_policy_count and v_affected_customers.",
    "plsql": "CREATE OR REPLACE PROCEDURE cleanup_expired_policies(p_cutoff_date date, p_policy_type text, p_customer_pattern text, p_days_buffer integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_policy_count integer;\n    v_affected_customers integer;\nBEGIN\n    SELECT COUNT(DISTINCT cp.\"Policy_ID\"), COUNT(DISTINCT cp.\"Customer_ID\")\n    INTO v_policy_count, v_affected_customers\n    FROM \"Customer_Policies\" cp\n    JOIN \"Customers\" c ON cp.\"Customer_ID\" = c.\"Customer_ID\"\n    WHERE cp.\"End_Date\" < p_cutoff_date - p_days_buffer\n    AND cp.\"Policy_Type_Code\" = p_policy_type\n    AND c.\"Customer_Details\" LIKE p_customer_pattern;\n    \n    DELETE FROM \"Claims\"\n    WHERE \"Policy_ID\" IN (\n        SELECT cp.\"Policy_ID\"\n        FROM \"Customer_Policies\" cp\n        JOIN \"Customers\" c ON cp.\"Customer_ID\" = c.\"Customer_ID\"\n        WHERE cp.\"End_Date\" < p_cutoff_date - p_days_buffer\n        AND cp.\"Policy_Type_Code\" = p_policy_type\n        AND c.\"Customer_Details\" LIKE p_customer_pattern\n    );\n    \n    DELETE FROM \"Customer_Policies\"\n    WHERE \"Policy_ID\" IN (\n        SELECT cp.\"Policy_ID\"\n        FROM \"Customer_Policies\" cp\n        JOIN \"Customers\" c ON cp.\"Customer_ID\" = c.\"Customer_ID\"\n        WHERE cp.\"End_Date\" < p_cutoff_date - p_days_buffer\n        AND cp.\"Policy_Type_Code\" = p_policy_type\n        AND c.\"Customer_Details\" LIKE p_customer_pattern\n    );\n    \n    RAISE NOTICE 'Cleaned up % policies affecting % customers', v_policy_count, v_affected_customers;\nEND;\n$$;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "CALL cleanup_expired_policies('2024-01-01', 'Car', '%America%', 30);",
      "CALL cleanup_expired_policies('2023-12-31', 'Life', '%Willms%', 60);",
      "CALL cleanup_expired_policies('2024-03-15', 'Car', '%Jaskolski%', 0);",
      "CALL cleanup_expired_policies('2022-06-30', 'Life', '%Paucek%', 90);",
      "CALL cleanup_expired_policies('2024-02-01', 'Car', '%%', 7);"
    ],
    "summary": "Create a stored procedure named cleanup_expired_policies that deletes expired policies and their associated claims. It identifies policies ending before a cutoff date (minus a buffer), matching a specific type and customer name pattern. It counts the distinct policies and customers affected, deletes the related claims, then deletes the policies, and finally outputs a notice with the cleanup counts.",
    "natural_language": "Construct a stored procedure, to be named cleanup_expired_policies, which meticulously performs the deletion of all insurance policies that have expired, along with any and all associated claim records. This procedure must first intelligently identify those policies whose termination date occurs prior to a specified cutoff date, which itself is adjusted by subtracting a predefined buffer period for added flexibility. The selection criteria must further ensure that each policy matches a designated type and that the related customer's name aligns with a particular textual pattern. It should then proceed to calculate and record the distinct number of policies and unique customers impacted by this operation. Following this, it must systematically delete all claims linked to these identified policies, and subsequently remove the policies themselves. Finally, the procedure must generate and output a comprehensive notification message that clearly details the counts from the cleanup process.",
    "id": 18,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named cleanup_expired_policies that operates on the insurance_policies database. The procedure does not take any input parameters and does not return a value directly, but it will output a notification message. The procedure begins by declaring several local variables: a date variable v_cutoff_date to store the calculated cutoff date, a bigint variable v_policy_count to hold the number of distinct policies to be deleted, a bigint variable v_customer_count to hold the number of unique customers affected, and a text variable v_notification_message to construct the final output message.\n\nThe procedure first calculates the cutoff date by taking the current date (using the CURRENT_DATE function) and subtracting a predefined buffer period of 30 days, storing the result in v_cutoff_date. It then identifies the set of policies to be deleted by performing a SELECT query on the Customer_Policies table, joining it with the Customers table on the Customer_ID column. The selection criteria are: the policy's End_Date must be less than the calculated v_cutoff_date, the Policy_Type_Code must exactly match the string 'Life', and the customer's Customer_Details must contain the substring 'Mrs.' (using the LIKE operator with pattern matching). This query selects the Policy_ID from Customer_Policies that satisfy all these conditions.\n\nUsing the result set of identified Policy_ID values, the procedure then calculates two aggregate counts: it counts the distinct number of Policy_ID values from the identified set and stores it in v_policy_count, and it counts the distinct number of Customer_ID values associated with those policies (by joining Customer_Policies again) and stores it in v_customer_count.\n\nNext, the procedure performs a deletion operation on the Claims table, deleting all rows where the Policy_ID column matches any of the Policy_ID values from the identified set of policies to be deleted. This removes all claim records associated with those policies.\n\nFollowing the deletion of claims, the procedure performs a deletion operation on the Customer_Policies table, deleting all rows where the Policy_ID column matches any of the Policy_ID values from the identified set. This removes the expired policies themselves.\n\nFinally, the procedure constructs a notification message by concatenating literal strings with the values of v_policy_count and v_customer_count. The message format is: 'Cleanup completed. Deleted ' || v_policy_count || ' policies affecting ' || v_customer_count || ' unique customers.' It then outputs this message using the RAISE NOTICE statement to log the notification."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named sync_department_heads that accepts five input parameters: a text parameter p_creation_year to filter departments by their creation year, a real parameter p_min_budget to specify a minimum budget threshold, a text parameter p_state_required to filter heads by their birth state, a real parameter p_age_minimum to set a minimum age for heads, and a text parameter p_acting_indicator to flag management records as temporary or acting. The procedure begins by declaring a cursor named v_dept_cursor that selects the Department_ID, Name, and Ranking columns from the department table for rows where the Creation column equals p_creation_year and the Budget_in_Billions column is greater than or equal to p_min_budget. It then initializes two variables: an integer v_head_count and a real v_avg_age. The procedure first calculates v_head_count by counting all rows in the head table where the born_state column matches p_state_required. Next, it calculates v_avg_age by computing the average of the age column from the head table for rows where age is greater than or equal to p_age_minimum. The procedure then enters a loop that iterates through each record fetched by the v_dept_cursor, referred to as dept_rec. For each department record, it evaluates a conditional block: if v_head_count is greater than the department's Ranking value from dept_rec, it performs an INSERT into the management table, selecting the department's Department_ID from dept_rec, the head_ID from the head table, and the p_acting_indicator parameter for the temporary_acting column; this INSERT is limited to one row from the head table where the head's born_state equals p_state_required and the head's age is at least p_age_minimum. Alternatively, if the first condition is false and v_avg_age is greater than 65, it executes a DELETE operation on the management table, removing rows where the department_ID column matches dept_rec's Department_ID and the temporary_acting column equals p_acting_indicator. If neither of the previous conditions is true, it performs a third INSERT into the management table, directly inserting dept_rec's Department_ID, a hardcoded head_ID value of 1, and a literal string 'Yes' for the temporary_acting column. The loop continues until all records from the cursor are processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_department_heads(\n    p_creation_year text,\n    p_min_budget real,\n    p_state_required text,\n    p_age_minimum real,\n    p_acting_indicator text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_dept_cursor CURSOR FOR\n        SELECT d.\"Department_ID\", d.\"Name\", d.\"Ranking\"\n        FROM department d\n        WHERE d.\"Creation\" = p_creation_year\n        AND d.\"Budget_in_Billions\" >= p_min_budget;\n    \n    v_head_count integer;\n    v_avg_age real;\nBEGIN\n    SELECT COUNT(*) INTO v_head_count\n    FROM head\n    WHERE born_state = p_state_required;\n    \n    SELECT AVG(age) INTO v_avg_age\n    FROM head\n    WHERE age >= p_age_minimum;\n    \n    FOR dept_rec IN v_dept_cursor LOOP\n        IF v_head_count > dept_rec.\"Ranking\" THEN\n            INSERT INTO management (\"department_ID\", \"head_ID\", \"temporary_acting\")\n            SELECT dept_rec.\"Department_ID\", h.\"head_ID\", p_acting_indicator\n            FROM head h\n            WHERE h.born_state = p_state_required\n            AND h.age >= p_age_minimum\n            LIMIT 1;\n        ELSIF v_avg_age > 65 THEN\n            DELETE FROM management\n            WHERE \"department_ID\" = dept_rec.\"Department_ID\"\n            AND \"temporary_acting\" = p_acting_indicator;\n        ELSE\n            INSERT INTO management (\"department_ID\", \"head_ID\", \"temporary_acting\")\n            VALUES (dept_rec.\"Department_ID\", 1, 'Yes');\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL sync_department_heads('1789', 10.0, 'Alabama', 65.0, 'Yes');",
      "CALL sync_department_heads('1947', 50.0, 'California', 70.0, 'No');",
      "CALL sync_department_heads('1789', 5.0, 'Alabama', 60.0, 'Maybe');",
      "CALL sync_department_heads('1947', 100.0, 'California', 75.0, 'Yes');",
      "CALL sync_department_heads('1789', 20.0, 'Alabama', 68.0, 'No');"
    ],
    "summary": "Create a stored procedure named sync_department_heads that filters departments by creation year and minimum budget, then loops through them. For each department, if the count of heads from a specified state exceeds the department's ranking, insert a management record with a matching head. If not, but the average head age is over 65, delete management records for that department with a specific acting indicator. Otherwise, insert a default management record with head_ID 1 and 'Yes' for acting.",
    "natural_language": "How can I create a stored procedure named sync_department_heads that will filter departments by their creation year and a minimum budget, then loop through them? For each department, if the number of heads from a given state is greater than the department's ranking, it should insert a management record with a matching head. If that condition is not met, but the average age of the heads is over 65, should it delete management records for that department where a specific acting indicator is set? Otherwise, should it insert a default management record using head_ID 1 and 'Yes' for acting?",
    "id": 19,
    "generated_ir": "Write a PostgreSQL PLpgSQL stored procedure named sync_department_heads that accepts five input parameters: a text parameter p_creation_year to filter departments by their creation year, a real parameter p_min_budget to specify a minimum budget threshold, a text parameter p_state_required to filter heads by their birth state, a real parameter p_age_minimum to set a minimum age for heads, and a text parameter p_acting_indicator to flag management records as temporary or acting. The procedure begins by declaring a cursor named v_dept_cursor that selects the Department_ID, Name, and Ranking columns from the department table for rows where the Creation column equals p_creation_year and the Budget_in_Billions column is greater than or equal to p_min_budget. It then initializes two variables: an integer v_head_count and a real v_avg_age. The procedure first calculates v_head_count by counting all rows in the head table where the born_state column matches p_state_required. Next, it calculates v_avg_age by computing the average of the age column from the head table for rows where age is greater than or equal to p_age_minimum. The procedure then enters a loop that iterates through each record fetched by the v_dept_cursor, referred to as dept_rec. For each department record, it evaluates a conditional block: if v_head_count is greater than the department's Ranking value from dept_rec, it performs an INSERT into the management table, selecting the department's Department_ID from dept_rec, the head_ID from the head table, and the p_acting_indicator parameter for the temporary_acting column; this INSERT is limited to one row from the head table where the head's born_state equals p_state_required and the head's age is at least p_age_minimum. Alternatively, if the first condition is false and v_avg_age is greater than 65, it executes a DELETE operation on the management table, removing rows where the department_ID column matches dept_rec's Department_ID and the temporary_acting column equals p_acting_indicator. If neither of the previous conditions is true, it performs a third INSERT into the management table, directly inserting dept_rec's Department_ID, a hardcoded head_ID value of 1, and a literal string 'Yes' for the temporary_acting column. The loop continues until all records from the cursor are processed."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `calculate_student_distances` that accepts two input parameters: `p_student_id` of type `bigint`, representing the unique identifier of a student, and `p_target_city` of type `text`, representing the code of a target city. The procedure declares two local variables: `v_student_city` of type `text` to store the city code of the student, and `v_distance` of type `bigint` to store a calculated or retrieved distance. The procedure begins by executing a `SELECT` statement to retrieve the `city_code` from the `public.\"Student\"` table where the `\"StuID\"` column matches the value provided in the `p_student_id` parameter. The retrieved `city_code` is then assigned to the `v_student_city` variable. Following this, another `SELECT` statement is executed to retrieve the `\"distance\"` from the `public.\"Direct_distance\"` table. This selection is based on a compound `WHERE` clause that checks for two conditions: either `city1_code` in the table matches the `v_student_city` and `city2_code` matches the `p_target_city`, OR `city1_code` matches the `p_target_city` and `city2_code` matches the `v_student_city`. This ensures that the distance is found regardless of the order in which the cities are stored in the `Direct_distance` table. The retrieved `\"distance\"` is then assigned to the `v_distance` variable. Finally, an `INSERT` statement is executed to add a new row into the `public.\"Direct_distance\"` table. This `INSERT` statement specifies the values for the `\"city1_code\"`, `\"city2_code\"`, and `\"distance\"` columns as `v_student_city`, `p_target_city`, and `0` respectively. This `INSERT` operation is conditional, only proceeding if two conditions are met: `v_distance` is `NULL` (meaning no existing direct distance was found between the student's city and the target city) AND `v_student_city` is not `NULL` (ensuring that a valid student city was successfully retrieved).",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_student_distances(p_student_id bigint, p_target_city text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_city text;\n    v_distance bigint;\nBEGIN\n    SELECT city_code INTO v_student_city FROM public.\"Student\" WHERE \"StuID\" = p_student_id;\n    \n    SELECT \"distance\" INTO v_distance \n    FROM public.\"Direct_distance\" \n    WHERE (\"city1_code\" = v_student_city AND \"city2_code\" = p_target_city) \n       OR (\"city1_code\" = p_target_city AND \"city2_code\" = v_student_city);\n    \n    INSERT INTO public.\"Direct_distance\" (\"city1_code\", \"city2_code\", \"distance\") \n    SELECT v_student_city, p_target_city, 0 \n    WHERE v_distance IS NULL AND v_student_city IS NOT NULL;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL calculate_student_distances(1001, 'PIT');",
      "CALL calculate_student_distances(1002, 'PHL');",
      "CALL calculate_student_distances(1003, 'BAL');",
      "CALL calculate_student_distances(1001, 'PHL');",
      "CALL calculate_student_distances(1002, 'BAL');"
    ],
    "summary": "Create a stored procedure named calculate_student_distances that accepts a student ID and a target city code. It retrieves the student's city code. Then it attempts to find the distance between the two cities in the Direct_distance table, checking both column orders. If no distance is found and the student's city code is valid, it inserts a new record into the Direct_distance table with the two city codes and a distance of zero.",
    "natural_language": "Create procedure calculate_student_distances. Input: student ID and target city. Get student's city. Check Direct_distance table for a matching distance in either column order. If no match and student's city is valid, insert a zero-distance record for the two cities.",
    "id": 20,
    "generated_ir": "Write a PostgreSQL PL/pgSQL procedure named calculate_student_distances that accepts two input parameters: a BIGINT parameter p_stu_id to identify the student, and a TEXT parameter p_target_city_code to specify the target city code. The procedure first declares a local TEXT variable v_student_city_code to store the student's city code. It begins execution by retrieving the student's city code from the Student table using a SELECT query that selects the city_code column from the Student table where the StuID column equals the input parameter p_stu_id, storing the result into the v_student_city_code variable. Next, the procedure checks if a distance record exists in the Direct_distance table for the pair of cities represented by the student's city code and the target city code, regardless of column order. This is done using a SELECT EXISTS query that looks for a row in the Direct_distance table where either (city1_code equals v_student_city_code and city2_code equals p_target_city_code) OR (city1_code equals p_target_city_code and city2_code equals v_student_city_code), storing the boolean result into a local BOOLEAN variable v_distance_exists. If v_distance_exists is FALSE, the procedure then validates whether the student's city code exists in the City table by performing another SELECT EXISTS query that checks for a row in the City table where the city_code column equals v_student_city_code, storing the result into a local BOOLEAN variable v_student_city_valid. If v_student_city_valid is TRUE, the procedure performs an INSERT operation into the Direct_distance table, specifying values for the columns city1_code, city2_code, and distance; the city1_code is set to v_student_city_code, the city2_code is set to p_target_city_code, and the distance is set to 0. The procedure does not return any value; it is a void procedure that performs conditional data insertion based on the existence of distance records and city validity."
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `reorganize_photo_data` that accepts three input parameters: `p_old_color` of type `text`, representing the color to be replaced; `p_new_color` of type `text`, representing the new color to be assigned; and `p_range_filter` of type `text`, representing a specific mountain range to filter by. The procedure begins by declaring a local variable `v_mountain_ids` as an array of integers, which will store unique mountain identifiers, and another local variable `v_processed_count` as an integer, initialized to 0, to track the number of mountains processed. A third local variable `v_current_mountain` is declared as an integer to hold the mountain ID during iteration. The procedure then executes a `SELECT` statement to populate the `v_mountain_ids` array. This `SELECT` statement aggregates distinct `mountain_id` values from the `photos` table, aliased as `p`, by joining it with the `mountain` table, aliased as `m`, on the condition `p.mountain_id = m.id`. The selection is further filtered by two conditions: `p.color` must be equal to the `p_old_color` parameter, and the `Range` column in the `mountain` table (accessed as `m.\"Range\"`) must be equal to the `p_range_filter` parameter. After attempting to populate `v_mountain_ids`, the procedure checks if `v_mountain_ids` is not `NULL`. If it is not `NULL`, indicating that at least one mountain ID was found matching the criteria, the procedure enters a `FOREACH` loop. This loop iterates through each `v_current_mountain` integer value present in the `v_mountain_ids` array. Inside the loop, for each `v_current_mountain`, a `DELETE` statement is executed on the `photos` table. This `DELETE` statement removes all rows where `mountain_id` matches the `v_current_mountain` and `color` is equal to `p_old_color`. Immediately following the `DELETE`, an `INSERT` statement is executed to add new rows into the `photos` table. This `INSERT` statement populates the `camera_lens_id`, `mountain_id`, `color`, and `name` columns. The values for these columns are selected from the `photos` table itself. Specifically, `camera_lens_id` is selected directly, `mountain_id` is set to the `v_current_mountain`, `color` is set to `p_new_color`, and `name` is constructed by concatenating the string 'Migrated_' with the original `name` column value. The `SELECT` statement for the `INSERT` is filtered by `mountain_id` being equal to `v_current_mountain` and `color` being equal to `p_old_color`. A `LIMIT 1` clause is applied to this `SELECT` statement, meaning only one row matching these criteria will be selected and inserted for each `v_current_mountain`. After the `INSERT` operation, the `v_processed_count` variable is incremented by 1. Once the `FOREACH` loop completes, the procedure checks if `v_processed_count` is greater than 0. If it is, indicating that at least one mountain's photos were processed, a final `DELETE` statement is executed. This `DELETE` statement targets the `photos` table, aliased as `p`, and uses the `mountain` table, aliased as `m`, in a `USING` clause for joining. The join condition is `p.mountain_id = m.id`. The `DELETE` operation is further constrained by three `AND` conditions: `m.\"Range\"` must be equal to `p_range_filter`, `p.color` must not be equal to `p_old_color` AND `p.color` must not be equal to `p_new_color`, and `p.mountain_id` must not be present in the result of a subquery. This subquery selects `mountain_id` from the `photos` table where `color` is equal to `p_new_color`. This final `DELETE` effectively removes photos associated with the specified range that have colors other than the old or new color, and for which no photo with the `p_new_color` exists for that mountain.",
    "plsql": "CREATE OR REPLACE PROCEDURE reorganize_photo_data(p_old_color text, p_new_color text, p_range_filter text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_mountain_ids integer[];\n    v_processed_count integer := 0;\n    v_current_mountain integer;\nBEGIN\n    SELECT ARRAY_AGG(DISTINCT mountain_id) INTO v_mountain_ids\n    FROM photos p\n    JOIN mountain m ON p.mountain_id = m.id\n    WHERE p.color = p_old_color AND m.\"Range\" = p_range_filter;\n    \n    IF v_mountain_ids IS NOT NULL THEN\n        FOREACH v_current_mountain IN ARRAY v_mountain_ids\n        LOOP\n            DELETE FROM photos\n            WHERE mountain_id = v_current_mountain AND color = p_old_color;\n            \n            INSERT INTO photos (camera_lens_id, mountain_id, color, name)\n            SELECT camera_lens_id, v_current_mountain, p_new_color, CONCAT('Migrated_', name)\n            FROM photos\n            WHERE mountain_id = v_current_mountain AND color = p_old_color\n            LIMIT 1;\n            \n            v_processed_count := v_processed_count + 1;\n        END LOOP;\n        \n        IF v_processed_count > 0 THEN\n            DELETE FROM photos p\n            USING mountain m\n            WHERE p.mountain_id = m.id\n            AND m.\"Range\" = p_range_filter\n            AND p.color NOT IN (p_old_color, p_new_color)\n            AND p.mountain_id NOT IN (SELECT mountain_id FROM photos WHERE color = p_new_color);\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL reorganize_photo_data('RBG', 'Color', 'Lasta Massif');",
      "CALL reorganize_photo_data('Black/White', 'Monochrome', 'Arsi Mountains');",
      "CALL reorganize_photo_data('RBG', 'RGB', 'Kollo Massif');",
      "CALL reorganize_photo_data('Black/White', 'Grayscale', 'Lasta Massif');",
      "CALL reorganize_photo_data('RBG', 'Full Color', 'Arsi Mountains');"
    ],
    "summary": "Create a stored procedure named reorganize_photo_data that accepts an old color, a new color, and a mountain range. It gets an array of mountain IDs from the specified range that have photos of the old color. For each mountain ID, it deletes all photos of the old color for that mountain and then inserts one new photo (based on the first deleted record) with the new color and a 'Migrated_' prefix on the name. After processing all mountains, if any were processed, it deletes all photos in the specified range that have a color other than the old or new color, but only for mountains that do not have any photo with the new color.",
    "natural_language": "Can you create a stored procedure called reorganize_photo_data that takes an old color, a new color, and a mountain range as inputs? For the specified range, it should obtain an array of mountain IDs with photos of the old color. For each of these mountain IDs, could it delete all old-color photos for that mountain and then insert a single new photo? This new photo should be based on the first deleted record, use the new color, and have a 'Migrated_' prefix added to its name. After processing all mountains, if any mountains were processed, should it then delete all photos in the specified range that have a color other than the old or new color, but only for those mountains that do not have any photo with the new color?",
    "id": 21,
    "generated_ir": "Write a PL/pgSQL stored procedure named `reorganize_photo_data` that accepts three input parameters: `p_old_color` of type `text`, representing the color to be replaced; `p_new_color` of type `text`, representing the new color to be assigned; and `p_range_filter` of type `text`, representing a specific mountain range to filter by. The procedure begins by declaring a local variable `v_mountain_ids` as an array of integers, which will store unique mountain identifiers, and another local variable `v_processed_count` as an integer, initialized to 0, to track the number of mountains processed. A third local variable `v_current_mountain` is declared as an integer to hold the mountain ID during iteration. The procedure then executes a `SELECT` statement to populate the `v_mountain_ids` array. This `SELECT` statement aggregates distinct `mountain_id` values from the `photos` table, aliased as `p`, by joining it with the `mountain` table, aliased as `m`, on the condition `p.mountain_id = m.id`. The selection is further filtered by two conditions: `p.color` must be equal to the `p_old_color` parameter, and the `Range` column in the `mountain` table (accessed as `m.\"Range\"`) must be equal to the `p_range_filter` parameter. After attempting to populate `v_mountain_ids`, the procedure checks if `v_mountain_ids` is not `NULL`. If it is not `NULL`, indicating that at least one mountain ID was found matching the criteria, the procedure enters a `FOREACH` loop. This loop iterates through each `v_current_mountain` integer value present in the `v_mountain_ids` array. Inside the loop, for each `v_current_mountain`, a `DELETE` statement is executed on the `photos` table. This `DELETE` statement removes all rows where `mountain_id` matches the `v_current_mountain` and `color` is equal to `p_old_color`. Immediately following the `DELETE`, an `INSERT` statement is executed to add new rows into the `photos` table. This `INSERT` statement populates the `camera_lens_id`, `mountain_id`, `color`, and `name` columns. The values for these columns are selected from the `photos` table itself. Specifically, `camera_lens_id` is selected directly, `mountain_id` is set to the `v_current_mountain`, `color` is set to `p_new_color`, and `name` is constructed by concatenating the string 'Migrated_' with the original `name` column value. The `SELECT` statement for the `INSERT` is filtered by `mountain_id` being equal to `v_current_mountain` and `color` being equal to `p_old_color`. A `LIMIT 1` clause is applied to this `SELECT` statement, meaning only one row matching these criteria will be selected and inserted for each `v_current_mountain`. After the `INSERT` operation, the `v_processed_count` variable is incremented by 1. Once the `FOREACH` loop completes, the procedure checks if `v_processed_count` is greater than 0. If it is, indicating that at least one mountain's photos were processed, a final `DELETE` statement is executed. This `DELETE` statement targets the `photos` table, aliased as `p`, and uses the `mountain` table, aliased as `m`, in a `USING` clause for joining. The join condition is `p.mountain_id = m.id`. The `DELETE` operation is further constrained by three `AND` conditions: `m.\"Range\"` must be equal to `p_range_filter`, `p.color` must not be equal to `p_old_color` AND `p.color` must not be equal to `p_new_color`, and `p.mountain_id` must not be present in the result of a subquery. This subquery selects `mountain_id` from the `photos` table where `color` is equal to `p_new_color`. This final `DELETE` effectively removes photos associated with the specified range that have colors other than the old or new color, and for which no photo with the `p_new_color` exists for that mountain."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `create_order_with_items` that accepts two input parameters: `p_customer_id`, which is of type `bigint` and represents the unique identifier of the customer for whom the order is being created, and `p_product_id`, which is also of type `bigint` and represents the unique identifier of the product to be included in the order. The procedure begins by declaring two local variables: `v_new_order_id` of type `bigint` to store the newly generated order identifier, and `v_new_item_id` of type `bigint` to store the newly generated order item identifier. The execution flow then proceeds as follows: First, it calculates the next available `order_id` by querying the `\"Customer_Orders\"` table. Specifically, it selects the maximum value of the `\"order_id\"` column from `\"Customer_Orders\"`, uses the `COALESCE` function to treat a `NULL` result (which would occur if the table is empty) as `0`, and then adds `1` to this result. This calculated value is then stored into the `v_new_order_id` variable. Second, it inserts a new record into the `\"Customer_Orders\"` table. The `\"order_id\"` column is populated with the value from `v_new_order_id`, the `\"customer_id\"` column is populated with the value from the input parameter `p_customer_id`, the `\"order_date\"` column is populated with the current timestamp obtained by calling the `NOW()` function, and the `\"order_status_code\"` column is set to the literal string value `'New'`. Third, it calculates the next available `order_item_id` by querying the `\"Order_Items\"` table. Specifically, it selects the maximum value of the `\"order_item_id\"` column from `\"Order_Items\"`, uses the `COALESCE` function to treat a `NULL` result (if the table is empty) as `0`, and then adds `1` to this result. This calculated value is then stored into the `v_new_item_id` variable. Fourth, it inserts a new record into the `\"Order_Items\"` table. The `\"order_item_id\"` column is populated with the value from `v_new_item_id`, the `\"order_id\"` column is populated with the value from `v_new_order_id` (which was generated in the first step), the `\"product_id\"` column is populated with the value from the input parameter `p_product_id`, and the `\"order_quantity\"` column is set to the literal string value `'1'`.",
    "plsql": "CREATE OR REPLACE PROCEDURE create_order_with_items(\n    p_customer_id bigint,\n    p_product_id bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_new_order_id bigint;\n    v_new_item_id bigint;\nBEGIN\n    SELECT COALESCE(MAX(\"order_id\"), 0) + 1\n    INTO v_new_order_id\n    FROM \"Customer_Orders\";\n    \n    INSERT INTO \"Customer_Orders\" (\"order_id\", \"customer_id\", \"order_date\", \"order_status_code\")\n    VALUES (v_new_order_id, p_customer_id, NOW(), 'New');\n    \n    SELECT COALESCE(MAX(\"order_item_id\"), 0) + 1\n    INTO v_new_item_id\n    FROM \"Order_Items\";\n    \n    INSERT INTO \"Order_Items\" (\"order_item_id\", \"order_id\", \"product_id\", \"order_quantity\")\n    VALUES (v_new_item_id, v_new_order_id, p_product_id, '1');\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL create_order_with_items(12, 13);",
      "CALL create_order_with_items(3, 10);",
      "CALL create_order_with_items(1, 1);",
      "CALL create_order_with_items(2, 2);",
      "CALL create_order_with_items(12, 3);"
    ],
    "summary": "Create a stored procedure named `create_order_with_items` that takes a customer ID and a product ID. It generates a new order ID and inserts a new order for the customer with a 'New' status. It then generates a new order item ID and inserts an order item for the generated order, linking the product with a quantity of 1.",
    "natural_language": "How can I create a stored procedure called `create_order_with_items` that accepts a customer ID and a product ID, generates a new order ID to insert an order with a 'New' status for that customer, and then generates a new order item ID to insert an order item for that order, linking the specified product with a quantity of 1?",
    "id": 22,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `create_order_with_items` that accepts two input parameters: `p_customer_id`, which is of type `bigint` and represents the unique identifier of the customer for whom the order is being created, and `p_product_id`, which is also of type `bigint` and represents the unique identifier of the product to be included in the order. The procedure begins by declaring two local variables: `v_new_order_id` of type `bigint` to store the newly generated order identifier, and `v_new_item_id` of type `bigint` to store the newly generated order item identifier. The execution flow then proceeds as follows: First, it calculates the next available `order_id` by querying the `\"Customer_Orders\"` table. Specifically, it selects the maximum value of the `\"order_id\"` column from `\"Customer_Orders\"`, uses the `COALESCE` function to treat a `NULL` result (which would occur if the table is empty) as `0`, and then adds `1` to this result. This calculated value is then stored into the `v_new_order_id` variable. Second, it inserts a new record into the `\"Customer_Orders\"` table. The `\"order_id\"` column is populated with the value from `v_new_order_id`, the `\"customer_id\"` column is populated with the value from the input parameter `p_customer_id`, the `\"order_date\"` column is populated with the current timestamp obtained by calling the `NOW()` function, and the `\"order_status_code\"` column is set to the literal string value `'New'`. Third, it calculates the next available `order_item_id` by querying the `\"Order_Items\"` table. Specifically, it selects the maximum value of the `\"order_item_id\"` column from `\"Order_Items\"`, uses the `COALESCE` function to treat a `NULL` result (if the table is empty) as `0`, and then adds `1` to this result. This calculated value is then stored into the `v_new_item_id` variable. Fourth, it inserts a new record into the `\"Order_Items\"` table. The `\"order_item_id\"` column is populated with the value from `v_new_item_id`, the `\"order_id\"` column is populated with the value from `v_new_order_id` (which was generated in the first step), the `\"product_id\"` column is populated with the value from the input parameter `p_product_id`, and the `\"order_quantity\"` column is set to the literal string value `'1'`."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_building_info` that accepts six input parameters: `p_building_id` of type `text`, `p_name` of type `text`, `p_street_address` of type `text`, `p_years_as_tallest` of type `text`, `p_height_feet` of type `integer`, and `p_floors` of type `integer`. The purpose of this procedure is to either update an existing building record or insert a new building record into the `building` table based on the provided `p_building_id`.\n\nThe procedure begins by executing a conditional check. It first attempts to select a single row (specifically, the literal value `1`) from the `building` table. This selection is performed to determine if a record with a matching `building_id` already exists. The condition for this selection is that the value in the `building_id` column of the `building` table must be equal to the value provided in the `p_building_id` input parameter.\n\nIf the `SELECT` statement finds at least one row that satisfies this condition (meaning a building with the specified `p_building_id` already exists), the procedure proceeds to execute an `UPDATE` operation. This `UPDATE` targets the `building` table. It sets the value of the `Name` column to the value provided in the `p_name` parameter, the `Street_address` column to the value from the `p_street_address` parameter, the `Years_as_tallest` column to the value from the `p_years_as_tallest` parameter, the `Height_feet` column to the value from the `p_height_feet` parameter, and the `Floors` column to the value from the `p_floors` parameter. This `UPDATE` operation is specifically applied to the row(s) where the `building_id` column in the `building` table matches the value of the `p_building_id` input parameter.\n\nIf the `SELECT` statement does not find any rows that satisfy the condition (meaning a building with the specified `p_building_id` does not exist), the procedure proceeds to execute an `INSERT` operation. This `INSERT` targets the `building` table. It inserts a new row into the `building` table, populating the `building_id` column with the value from the `p_building_id` parameter, the `Name` column with the value from the `p_name` parameter, the `Street_address` column with the value from the `p_street_address` parameter, the `Years_as_tallest` column with the value from the `p_years_as_tallest` parameter, the `Height_feet` column with the value from the `p_height_feet` parameter, and the `Floors` column with the value from the `p_floors` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_building_info(p_building_id text, p_name text, p_street_address text, p_years_as_tallest text, p_height_feet integer, p_floors integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (\n        SELECT 1 FROM building\n        WHERE \"building_id\" = p_building_id\n    ) THEN\n        -- If the building exists, update its information\n        UPDATE building\n        SET\n            \"Name\" = p_name,\n            \"Street_address\" = p_street_address,\n            \"Years_as_tallest\" = p_years_as_tallest,\n            \"Height_feet\" = p_height_feet,\n            \"Floors\" = p_floors\n        WHERE \"building_id\" = p_building_id;\n    ELSE\n        -- If the building does not exist, insert a new record\n        INSERT INTO building (\"building_id\", \"Name\", \"Street_address\", \"Years_as_tallest\", \"Height_feet\", \"Floors\")\n        VALUES (p_building_id, p_name, p_street_address, p_years_as_tallest, p_height_feet, p_floors);\n    END IF;\nEND;\n$$;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building"
    ],
    "call_sqls": [
      "CALL update_building_info('0', 'Citizens Bank Building', '701 North Franklin Street', '19131915', 145, 12);",
      "CALL update_building_info('1', 'Tampa City Hall', '315 John F. Kennedy Boulevard', '19151926', 160, 10);",
      "CALL update_building_info('2', 'Floridan Hotel', '905 Franklin Street', '19261966', 204, 17);",
      "CALL update_building_info('3', 'New Building', '123 Main Street', '2023-present', 500, 50);",
      "CALL update_building_info('0', 'Updated Citizens Bank Building', '701 North Franklin Street', '19131915', 150, 13);"
    ],
    "summary": "Create a stored procedure named `update_building_info` that takes building ID, name, address, years as tallest, height, and floors. If a building with the given ID exists, update its information with the provided values. If it does not exist, insert a new building record with the provided values.",
    "natural_language": "Update or insert building information. For building ID, name, address, years as tallest, height, and floors, if a building with the given ID exists, update its record with the new values. If it does not exist, insert a new building record with these values. Name this stored procedure `update_building_info`.",
    "id": 23,
    "generated_ir": "Write a PostgreSQL PL/pgSQL procedure named update_building_info that updates or inserts building information in the building table of the protein_institute database. The procedure accepts six parameters: p_building_id of type text representing the building identifier, p_name of type text for the building name, p_street_address of type text for the street address, p_years_as_tallest of type text for the years the building was the tallest, p_height_feet of type integer for the height in feet, and p_floors of type integer for the number of floors. The procedure begins by checking if a building record exists in the building table where the building_id column matches the provided p_building_id. If such a record exists, it performs an UPDATE operation on the building table, setting the Name column to p_name, the Street_address column to p_street_address, the Years_as_tallest column to p_years_as_tallest, the Height_feet column to p_height_feet, and the Floors column to p_floors, specifically for the row where building_id equals p_building_id. If no matching record is found, it performs an INSERT operation into the building table, creating a new row with building_id set to p_building_id, Name set to p_name, Street_address set to p_street_address, Years_as_tallest set to p_years_as_tallest, Height_feet set to p_height_feet, and Floors set to p_floors. The procedure uses conditional logic with an IF statement to determine whether to update or insert, based on the existence check. No return value is specified, indicating it is a void procedure."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named calculate_average_age_by_country that accepts two parameters: p_country_filter of type TEXT, which specifies the country to filter the records by, and p_min_age of type INTEGER, which sets the minimum age threshold for the records to be considered. The procedure begins by declaring two local variables: v_avg_age of type NUMERIC to store the calculated average age, and v_country_name of type TEXT to store the name of the country. It then performs a SELECT operation on the people table, retrieving the Country and the average Age of individuals whose Country matches the value of p_country_filter and whose Age is greater than or equal to p_min_age. The results of this query are stored into the v_country_name and v_avg_age variables. The query groups the results by the Country column to ensure the average is calculated per country. Following the SELECT operation, the procedure checks if v_avg_age is not NULL, indicating that there are records meeting the criteria. If this condition is true, it executes an INSERT operation into the people table, adding a new row with the Name column set to 'Average Age Record', the Country column set to the value of v_country_name, the Is_Male column set to 'T', and the Age column set to the integer value of v_avg_age. This operation effectively records the calculated average age as a new entry in the people table.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_age_by_country(p_country_filter TEXT, p_min_age INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_age NUMERIC;\n    v_country_name TEXT;\nBEGIN\n    SELECT \"Country\", AVG(\"Age\") INTO v_country_name, v_avg_age\n    FROM \"people\"\n    WHERE \"Country\" = p_country_filter AND \"Age\" >= p_min_age\n    GROUP BY \"Country\";\n    \n    IF v_avg_age IS NOT NULL THEN\n        INSERT INTO \"people\" (\"Name\", \"Country\", \"Is_Male\", \"Age\")\n        VALUES ('Average Age Record', v_country_name, 'T', v_avg_age::INTEGER);\n    END IF;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL calculate_average_age_by_country('Canada', 25);",
      "CALL calculate_average_age_by_country('United States', 30);",
      "CALL calculate_average_age_by_country('Sweden', 20);",
      "CALL calculate_average_age_by_country('Canada', 35);",
      "CALL calculate_average_age_by_country('United States', 18);"
    ],
    "summary": "Create a stored procedure named calculate_average_age_by_country that accepts a country filter (TEXT) and a minimum age (INTEGER). Calculate the average age from the people table for the specified country where age meets the minimum threshold. If an average is found, insert a new record into the people table with Name 'Average Age Record', the country, Is_Male 'T', and the calculated average age as an integer.",
    "natural_language": "How can I create a stored procedure called calculate_average_age_by_country that takes a country filter as TEXT and a minimum age as INTEGER, calculates the average age from the people table for that country where age is at least the given minimum, and if an average is found, inserts a new record into the people table with the Name 'Average Age Record', the specified country, Is_Male set to 'T', and the calculated average age as an integer?",
    "id": 24,
    "generated_ir": "Write a PLpgSQL stored procedure named calculate_average_age_by_country that accepts two parameters: p_country_filter of type TEXT, which specifies the country to filter the records by, and p_min_age of type INTEGER, which sets the minimum age threshold for the records to be considered. The procedure begins by declaring two local variables: v_avg_age of type NUMERIC to store the calculated average age, and v_country_name of type TEXT to store the name of the country. It then performs a SELECT operation on the people table, retrieving the Country and the average Age of individuals whose Country matches the value of p_country_filter and whose Age is greater than or equal to p_min_age. The results of this query are stored into the v_country_name and v_avg_age variables. The query groups the results by the Country column to ensure the average is calculated per country. Following the SELECT operation, the procedure checks if v_avg_age is not NULL, indicating that there are records meeting the criteria. If this condition is true, it executes an INSERT operation into the people table, adding a new row with the Name column set to 'Average Age Record', the Country column set to the value of v_country_name, the Is_Male column set to 'T', and the Age column set to the integer value of v_avg_age. This operation effectively records the calculated average age as a new entry in the people table."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_camera_lens_id of type integer, p_mountain_id of type integer, and p_color_factor of type real. The procedure begins by declaring a local variable v_color of type text. It then evaluates the value of p_color_factor using a conditional statement: if p_color_factor is greater than 0.5, it assigns the string 'RBG' to v_color; otherwise, it assigns the string 'Black/White' to v_color. Following this conditional logic, the procedure performs an insert operation into the photos table, specifically targeting the columns camera_lens_id, mountain_id, color, and name. The values inserted are p_camera_lens_id for the camera_lens_id column, p_mountain_id for the mountain_id column, the value of v_color for the color column, and the string 'New Photo' for the name column.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_photo_with_calculated_color(p_camera_lens_id integer, p_mountain_id integer, p_color_factor real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_color text;\nBEGIN\n    IF p_color_factor > 0.5 THEN\n        v_color := 'RBG';\n    ELSE\n        v_color := 'Black/White';\n    END IF;\n    \n    INSERT INTO photos (camera_lens_id, mountain_id, color, name)\n    VALUES (p_camera_lens_id, p_mountain_id, v_color, 'New Photo');\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "CALL insert_photo_with_calculated_color(1, 1, 0.7);",
      "CALL insert_photo_with_calculated_color(2, 2, 0.3);",
      "CALL insert_photo_with_calculated_color(3, 3, 0.9);",
      "CALL insert_photo_with_calculated_color(1, 2, 0.1);",
      "CALL insert_photo_with_calculated_color(2, 1, 0.6);"
    ],
    "summary": "Create a stored procedure that takes a camera_lens_id (integer), a mountain_id (integer), and a color_factor (real). Determine the color as 'RGB' if color_factor > 0.5, otherwise 'Black/White'. Insert a new photo with these IDs, the determined color, and the name 'New Photo'.",
    "natural_language": "Please construct a stored procedure that accepts three input parameters: an integer designated as camera_lens_id, an integer designated as mountain_id, and a real number designated as color_factor. The procedure shall evaluate the color_factor; if its value exceeds 0.5, the color shall be determined as 'RGB'. Otherwise, the color shall be determined as 'Black/White'. Subsequently, the procedure must execute an insertion into the photo table, incorporating the provided identifiers, the determined color value, and a static name of 'New Photo'.",
    "id": 25,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `insert_photo_with_calculated_color` that accepts three input parameters: `camera_lens_id` of type `integer`, `mountain_id` of type `integer`, and `color_factor` of type `real`. The procedure operates within the `mountain_photos` database.\n\nThe procedure begins by declaring a local variable `v_color` of type `text` to store the determined color value based on the `color_factor`.\n\nThe procedure then evaluates the `color_factor` parameter using an `IF` statement:\n- If `color_factor` is greater than `0.5`, the procedure sets `v_color` to the string `'RGB'`.\n- Otherwise (if `color_factor` is less than or equal to `0.5`), the procedure sets `v_color` to the string `'Black/White'`.\n\nFollowing the color determination, the procedure executes an `INSERT` operation into the `photos` table. The `INSERT` statement includes the following column values:\n- `camera_lens_id` is set to the input parameter `camera_lens_id`.\n- `mountain_id` is set to the input parameter `mountain_id`.\n- `color` is set to the variable `v_color`.\n- `name` is set to the static string `'New Photo'`.\n\nThe `id` column in the `photos` table is not explicitly provided in the `INSERT` statement, implying it is an auto-generated column (likely a `SERIAL` or identity column) that will be assigned automatically by the database.\n\nThe procedure does not return any value; it is a `void` procedure that performs the insertion and then completes execution."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_school_colors` that accepts two input parameters: `school_id_input`, which is an integer representing the unique identifier of a school, and `new_colors`, which is a text string representing the new color information to be assigned to the school. The procedure's sole operation is to perform an `UPDATE` statement on the `school_details` table. This `UPDATE` statement modifies the value in the column named `\"Colors\"` within the `school_details` table, setting it to the value provided by the `new_colors` input parameter. The `UPDATE` operation is conditionally applied, affecting only those rows in the `school_details` table where the value in the column named `\"School_ID\"` precisely matches the integer value provided by the `school_id_input` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_school_colors(school_id_input INTEGER, new_colors TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE school_details\n    SET \"Colors\" = new_colors\n    WHERE \"School_ID\" = school_id_input;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "school",
      "school_details"
    ],
    "call_sqls": [
      "CALL update_school_colors(1, 'Scarlet and Gray');",
      "CALL update_school_colors(2, 'Navy and White');",
      "CALL update_school_colors(3, 'Green and Gold');",
      "CALL update_school_colors(1, 'Blue and Silver');",
      "CALL update_school_colors(2, 'Maroon and Gold');"
    ],
    "summary": "Create a stored procedure named update_school_colors that updates the Colors column in the school_details table for a row where the School_ID matches a given integer, setting it to a given text value.",
    "natural_language": "Please construct a stored procedure designated as 'update_school_colors'. This procedure shall modify the 'Colors' column within the 'school_details' table. The update operation is to be performed on the row where the 'School_ID' corresponds to a specified integer parameter, assigning the column's value to a provided text parameter.",
    "id": 26,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_school_colors` that accepts two input parameters: `p_school_id` of type `integer`, representing the unique identifier for a school, and `p_colors` of type `text`, representing the new colors value to be assigned. The procedure's primary purpose is to update the `Colors` column in the `school_details` table for a specific school record. The update operation targets the row in the `school_details` table where the `School_ID` column matches the value provided by the `p_school_id` input parameter. The procedure sets the `Colors` column of that row to the value provided by the `p_colors` input parameter. No local variables are declared, as the operation directly uses the input parameters. The procedure does not return any value; it is a void procedure that performs an in-place update. The database context is `school_player`."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_country_name of type text, p_new_status of type text, and p_population_threshold of type integer. The procedure first declares a local variable v_country_id of type integer. It then performs a SELECT query on the country table to retrieve the Country_ID where the Name column matches the value of p_country_name, storing the result in the v_country_id variable. If v_country_id is not NULL, indicating that a matching country was found, the procedure proceeds to update the roller_coaster table. It sets the Status column to the value of p_new_status for all rows where the Country_ID matches v_country_id and where there exists at least one row in the country table with the same Country_ID and a Population greater than p_population_threshold.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_coaster_status_by_population(p_country_name text, p_new_status text, p_population_threshold integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_country_id integer;\nBEGIN\n    SELECT \"Country_ID\" INTO v_country_id FROM country WHERE \"Name\" = p_country_name;\n    \n    IF v_country_id IS NOT NULL THEN\n        UPDATE roller_coaster\n        SET \"Status\" = p_new_status\n        WHERE \"Country_ID\" = v_country_id\n        AND EXISTS (\n            SELECT 1 FROM country c \n            WHERE c.\"Country_ID\" = roller_coaster.\"Country_ID\" \n            AND c.\"Population\" > p_population_threshold\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "CALL update_coaster_status_by_population('Austria', 'Closed for Maintenance', 8000000);",
      "CALL update_coaster_status_by_population('Finland', 'Under Renovation', 5000000);",
      "CALL update_coaster_status_by_population('Sweden', 'Operating', 9000000);",
      "CALL update_coaster_status_by_population('Austria', 'Operating', 9000000);",
      "CALL update_coaster_status_by_population('Finland', 'Closed', 6000000);"
    ],
    "summary": "Create a stored procedure that updates roller coaster statuses for a specified country. It finds the country's ID, then updates the status for all roller coasters in that country, but only if the country's population exceeds a given threshold.",
    "natural_language": "Make a stored procedure that adjusts the status for roller coasters in a certain country. It should look up the country's identifier and then update the status for all coasters there, but only do this if the country has a pretty large population.",
    "id": 27,
    "generated_ir": "Write a PLpgSQL stored procedure that takes three parameters: p_country_name of type text, p_new_status of type text, and p_population_threshold of type integer. The procedure first declares a local variable v_country_id of type integer. It then performs a SELECT query on the country table to retrieve the Country_ID where the Name column matches the value of p_country_name, storing the result in the v_country_id variable. If v_country_id is not NULL, indicating that a matching country was found, the procedure proceeds to update the roller_coaster table. It sets the Status column to the value of p_new_status for all rows where the Country_ID matches v_country_id and where there exists at least one row in the country table with the same Country_ID and a Population greater than p_population_threshold."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes an integer parameter p_artist_id and retrieves the Age of the artist from the artist table where the Artist_ID matches the provided p_artist_id. It stores this Age value in a local variable v_age. The procedure then evaluates the value of v_age using conditional logic: if v_age is less than 25, it assigns the text 'Young' to another local variable v_category; if v_age is between 25 and 35 inclusive, it assigns 'Mid' to v_category; otherwise, it assigns 'Veteran' to v_category. Finally, the procedure updates the artist table by setting the Famous_Title column to the value of v_category for the row where the Artist_ID matches the provided p_artist_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_artist_age_category(p_artist_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_age integer;\n    v_category text;\nBEGIN\n    SELECT \"Age\" INTO v_age\n    FROM artist\n    WHERE \"Artist_ID\" = p_artist_id;\n\n    IF v_age < 25 THEN\n        v_category := 'Young';\n    ELSIF v_age BETWEEN 25 AND 35 THEN\n        v_category := 'Mid';\n    ELSE\n        v_category := 'Veteran';\n    END IF;\n\n    UPDATE artist\n    SET \"Famous_Title\" = v_category\n    WHERE \"Artist_ID\" = p_artist_id;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL update_artist_age_category(1);",
      "CALL update_artist_age_category(2);",
      "CALL update_artist_age_category(3);",
      "CALL update_artist_age_category(10);",
      "CALL update_artist_age_category(15);"
    ],
    "summary": "Create a stored procedure that accepts an artist ID. Retrieve the artist's age and categorize them as 'Young' (age < 25), 'Mid' (age between 25 and 35), or 'Veteran' (age > 35). Update the artist's Famous_Title column with this category.",
    "natural_language": "Hey, can you whip up a stored procedure that takes an artist's ID? It should figure out how old the artist is and slap a label on 'em: 'Young' if they're under 25, 'Mid' if they're 25 to 35, or 'Veteran' if they're over 35. Then, just update that artist's Famous_Title column with whatever category you got.",
    "id": 28,
    "generated_ir": "Write a PLpgSQL stored procedure that takes an integer parameter p_artist_id and retrieves the Age of the artist from the artist table where the Artist_ID matches the provided p_artist_id. It stores this Age value in a local variable v_age. The procedure then evaluates the value of v_age using conditional logic: if v_age is less than 25, it assigns the text 'Young' to another local variable v_category; if v_age is between 25 and 35 inclusive, it assigns 'Mid' to v_category; otherwise, it assigns 'Veteran' to v_category. Finally, the procedure updates the artist table by setting the Famous_Title column to the value of v_category for the row where the Artist_ID matches the provided p_artist_id."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_course_id of type bigint, p_new_subject_id of type bigint, and p_operation_mode of type text. The procedure performs a series of operations to synchronize course data based on the provided parameters. First, it calculates the number of students enrolled in the course identified by p_course_id by counting rows in the \"Student_Course_Enrolment\" table where the course_id matches p_course_id, storing the result in the variable v_student_count. Next, it calculates the number of test results associated with the course by joining the \"Student_Tests_Taken\" table with the \"Student_Course_Enrolment\" table on the registration_id column and filtering rows where the course_id matches p_course_id, storing the result in the variable v_test_results_count. It then checks if there is an author associated with the course by verifying the existence of a row in the \"Course_Authors_and_Tutors\" table joined with the \"Courses\" table on the author_id column, where the course_id matches p_course_id, storing the result in the boolean variable v_author_exists. Additionally, it checks if a subject with the ID p_new_subject_id exists in the \"Subjects\" table, storing the result in the boolean variable v_subject_exists. If no such subject exists, it inserts a new row into the \"Subjects\" table with the subject_id set to p_new_subject_id and the subject_name set to a concatenated string 'Sync_' followed by the p_course_id and p_operation_mode values. If the p_operation_mode is 'MIGRATE' and the number of students enrolled in the course (v_student_count) is greater than zero, it calculates a new course ID by finding the maximum course_id in the \"Courses\" table, adding one to it, and storing the result in the variable v_new_course_id. It then inserts a new row into the \"Courses\" table with the new course_id, the author_id and course details copied from the course identified by p_course_id, the subject_id set to p_new_subject_id, and the course_name appended with '_migrated'. Afterward, it deletes all rows from the \"Student_Tests_Taken\" table where the registration_id matches any registration_id in the \"Student_Course_Enrolment\" table for the course identified by p_course_id. If the p_operation_mode is 'CLEANUP' and the number of test results associated with the course (v_test_results_count) is zero, it deletes all rows from the \"Student_Course_Enrolment\" table where the course_id matches p_course_id and then deletes the corresponding row from the \"Courses\" table. If neither of these conditions is met, it checks if there is no author associated with the course (v_author_exists is false) and, if so, inserts a new row into the \"Course_Authors_and_Tutors\" table with an author_id set to p_course_id plus 500, default values for other columns, and an auto-generated login_name, password, and address.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_course_data(\n    p_course_id bigint,\n    p_new_subject_id bigint,\n    p_operation_mode text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_count integer;\n    v_test_results_count integer;\n    v_author_exists boolean;\n    v_new_course_id bigint;\n    v_subject_exists boolean;\nBEGIN\n    SELECT COUNT(*) INTO v_student_count\n    FROM \"Student_Course_Enrolment\"\n    WHERE course_id = p_course_id;\n    \n    SELECT COUNT(*) INTO v_test_results_count\n    FROM \"Student_Tests_Taken\" stt\n    INNER JOIN \"Student_Course_Enrolment\" sce ON stt.registration_id = sce.registration_id\n    WHERE sce.course_id = p_course_id;\n    \n    SELECT EXISTS(SELECT 1 FROM \"Course_Authors_and_Tutors\" cat\n                 INNER JOIN \"Courses\" c ON cat.author_id = c.author_id\n                 WHERE c.course_id = p_course_id) INTO v_author_exists;\n    \n    SELECT EXISTS(SELECT 1 FROM \"Subjects\" WHERE subject_id = p_new_subject_id) INTO v_subject_exists;\n    \n    IF NOT v_subject_exists THEN\n        INSERT INTO \"Subjects\" (subject_id, subject_name)\n        VALUES (p_new_subject_id, 'Sync_' || CAST(p_course_id AS text) || '_' || p_operation_mode);\n    END IF;\n    \n    IF p_operation_mode = 'MIGRATE' AND v_student_count > 0 THEN\n        SELECT COALESCE(MAX(course_id), 0) + 1 INTO v_new_course_id FROM \"Courses\";\n        \n        INSERT INTO \"Courses\" (course_id, author_id, subject_id, course_name, course_description)\n        SELECT v_new_course_id, author_id, p_new_subject_id, course_name || '_migrated', course_description\n        FROM \"Courses\"\n        WHERE course_id = p_course_id;\n        \n        DELETE FROM \"Student_Tests_Taken\"\n        WHERE registration_id IN (\n            SELECT registration_id FROM \"Student_Course_Enrolment\"\n            WHERE course_id = p_course_id\n        );\n    ELSIF p_operation_mode = 'CLEANUP' AND v_test_results_count = 0 THEN\n        DELETE FROM \"Student_Course_Enrolment\"\n        WHERE course_id = p_course_id;\n        \n        DELETE FROM \"Courses\"\n        WHERE course_id = p_course_id;\n    ELSE\n        IF NOT v_author_exists THEN\n            INSERT INTO \"Course_Authors_and_Tutors\" (author_id, author_tutor_ATB, login_name, password, personal_name, middle_name, family_name, gender_mf, address_line_1)\n            VALUES (p_course_id + 500, '777', 'auto_' || CAST(p_course_id AS text), 'auto_pass', 'Auto', 'Generated', 'Author', '0', 'Auto-generated address');\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "CALL synchronize_course_data(1, 101, 'MIGRATE');",
      "CALL synchronize_course_data(2, 102, 'CLEANUP');",
      "CALL synchronize_course_data(3, 103, 'UPDATE');",
      "CALL synchronize_course_data(4, 104, 'MIGRATE');",
      "CALL synchronize_course_data(5, 105, 'CLEANUP');"
    ],
    "summary": "Create a stored procedure that takes a course ID, a new subject ID, and an operation mode ('MIGRATE' or 'CLEANUP'). Count the students enrolled and test results for the course, and check if an author and the new subject exist. If the subject does not exist, create it. If the mode is 'MIGRATE' and there are enrolled students, create a new migrated course with the new subject ID, copy details from the old course, and delete its test records. If the mode is 'CLEANUP' and there are no test results, delete the course's enrolments and the course itself. Otherwise, if no author exists for the course, create a new author record with a derived ID.",
    "natural_language": "Write a stored procedure that accepts a course ID, a new subject ID, and an operation mode ('MIGRATE' or 'CLEANUP'). Count the enrolled students and test results for the course, and verify the existence of an author and the new subject. If the subject does not exist, create it. For 'MIGRATE' mode with enrolled students, create a new migrated course under the new subject ID, copy the old course's details, and remove its test records. For 'CLEANUP' mode with no test results, delete the course's enrolments and then the course itself. Otherwise, if the course lacks an author, create a new author record using a derived ID.",
    "id": 29,
    "generated_ir": "Write a PLpgSQL stored procedure that takes three parameters: p_course_id of type bigint, p_new_subject_id of type bigint, and p_operation_mode of type text. The procedure performs a series of operations to synchronize course data based on the provided parameters. First, it calculates the number of students enrolled in the course identified by p_course_id by counting rows in the \"Student_Course_Enrolment\" table where the course_id matches p_course_id, storing the result in the variable v_student_count. Next, it calculates the number of test results associated with the course by joining the \"Student_Tests_Taken\" table with the \"Student_Course_Enrolment\" table on the registration_id column and filtering rows where the course_id matches p_course_id, storing the result in the variable v_test_results_count. It then checks if there is an author associated with the course by verifying the existence of a row in the \"Course_Authors_and_Tutors\" table joined with the \"Courses\" table on the author_id column, where the course_id matches p_course_id, storing the result in the boolean variable v_author_exists. Additionally, it checks if a subject with the ID p_new_subject_id exists in the \"Subjects\" table, storing the result in the boolean variable v_subject_exists. If no such subject exists, it inserts a new row into the \"Subjects\" table with the subject_id set to p_new_subject_id and the subject_name set to a concatenated string 'Sync_' followed by the p_course_id and p_operation_mode values. If the p_operation_mode is 'MIGRATE' and the number of students enrolled in the course (v_student_count) is greater than zero, it calculates a new course ID by finding the maximum course_id in the \"Courses\" table, adding one to it, and storing the result in the variable v_new_course_id. It then inserts a new row into the \"Courses\" table with the new course_id, the author_id and course details copied from the course identified by p_course_id, the subject_id set to p_new_subject_id, and the course_name appended with '_migrated'. Afterward, it deletes all rows from the \"Student_Tests_Taken\" table where the registration_id matches any registration_id in the \"Student_Course_Enrolment\" table for the course identified by p_course_id. If the p_operation_mode is 'CLEANUP' and the number of test results associated with the course (v_test_results_count) is zero, it deletes all rows from the \"Student_Course_Enrolment\" table where the course_id matches p_course_id and then deletes the corresponding row from the \"Courses\" table. If neither of these conditions is met, it checks if there is no author associated with the course (v_author_exists is false) and, if so, inserts a new row into the \"Course_Authors_and_Tutors\" table with an author_id set to p_course_id plus 500, default values for other columns, and an auto-generated login_name, password, and address."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes two input parameters, p_source_city and p_target_city, both of type text, and performs the following operations: First, it declares two local variables, v_lat and v_lon, both of type double precision, to temporarily store the latitude and longitude values. Then, it retrieves the latitude and longitude values from the \"City\" table for the row where the city_code column matches the value of the p_source_city parameter and assigns these values to the v_lat and v_lon variables. Next, it updates the \"City\" table by setting the latitude and longitude columns to the values stored in v_lat and v_lon for the row where the city_code column matches the value of the p_target_city parameter, but only if the value of v_lat is not NULL.",
    "plsql": "CREATE OR REPLACE PROCEDURE sync_city_coordinates(p_source_city text, p_target_city text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lat double precision;\n    v_lon double precision;\nBEGIN\n    SELECT latitude, longitude INTO v_lat, v_lon \n    FROM \"City\" \n    WHERE city_code = p_source_city;\n    \n    UPDATE \"City\" \n    SET latitude = v_lat, longitude = v_lon \n    WHERE city_code = p_target_city AND v_lat IS NOT NULL;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL sync_city_coordinates('BAL', 'PIT');",
      "CALL sync_city_coordinates('PHL', 'BAL');",
      "CALL sync_city_coordinates('PIT', 'PHL');",
      "CALL sync_city_coordinates('BAL', 'BAL');",
      "CALL sync_city_coordinates('PHL', 'PIT');"
    ],
    "summary": "Create a stored procedure that copies the latitude and longitude from a source city to a target city in the City table, using city codes as identifiers. The update should only occur if the source city's latitude is not null.",
    "natural_language": "Develop a comprehensive stored procedure that meticulously transfers the precise latitude and longitudinal coordinates from a carefully specified source city over to a distinctly identified target city, both of which are located within the extensive City table, by utilizing their unique city codes as the primary identifiers for matching. This crucial update operation must be executed exclusively under the strict condition that the source city's latitude value is definitively populated and not null.",
    "id": 30,
    "generated_ir": "Write a PLpgSQL stored procedure that takes two input parameters, p_source_city and p_target_city, both of type text, and performs the following operations: First, it declares two local variables, v_lat and v_lon, both of type double precision, to temporarily store the latitude and longitude values. Then, it retrieves the latitude and longitude values from the \"City\" table for the row where the city_code column matches the value of the p_source_city parameter and assigns these values to the v_lat and v_lon variables. Next, it updates the \"City\" table by setting the latitude and longitude columns to the values stored in v_lat and v_lon for the row where the city_code column matches the value of the p_target_city parameter, but only if the value of v_lat is not NULL."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named \"UpdateCourseName\" that accepts a single input parameter called new_name of type TEXT, which is intended to be the new name value, and within its body, first checks if the provided new_name parameter is not NULL, and if this condition is true, performs an UPDATE operation on the table named \"course\", specifically setting the value of the column \"Course\" to the value of the input parameter new_name, but only for the single row where the value in the \"Course_ID\" column matches the result of a subquery that selects the maximum numerical value from the \"Course_ID\" column within the entire \"course\" table, thereby updating the course name for the record with the highest course identifier.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"UpdateCourseName\"(new_name TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF new_name IS NOT NULL THEN\n        UPDATE \"course\"\n        SET \"Course\" = new_name\n        WHERE \"Course_ID\" = (SELECT MAX(\"Course_ID\") FROM \"course\");\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL \"UpdateCourseName\"('History');",
      "CALL \"UpdateCourseName\"('Geography');",
      "CALL \"UpdateCourseName\"('Art');",
      "CALL \"UpdateCourseName\"('Music');",
      "CALL \"UpdateCourseName\"('Physical Education');"
    ],
    "summary": "Create a stored procedure named UpdateCourseName that accepts a TEXT parameter new_name. If new_name is not null, update the course table by setting the Course column to new_name for the row where Course_ID equals the maximum Course_ID in the table.",
    "natural_language": "Update course name to provided text for the highest ID.",
    "id": 31,
    "generated_ir": "Write a PostgreSQL PLpgSQL stored procedure named \"UpdateCourseName\" that accepts a single input parameter called new_name of type TEXT, which is intended to be the new name value, and within its body, first checks if the provided new_name parameter is not NULL, and if this condition is true, performs an UPDATE operation on the table named \"course\", specifically setting the value of the column \"Course\" to the value of the input parameter new_name, but only for the single row where the value in the \"Course_ID\" column matches the result of a subquery that selects the maximum numerical value from the \"Course_ID\" column within the entire \"course\" table, thereby updating the course name for the record with the highest course identifier."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `analyze_rating_patterns` that accepts one input parameter, `p_min_stars`, which is an integer representing a minimum star rating threshold. The procedure begins by declaring three local variables: `v_reviewer_count` of type integer, `v_avg_year` of type numeric, and `v_radians_result` of type numeric. It then executes a `SELECT` statement to calculate two aggregate values: the count of distinct `rID` values from the `\"Reviewer\"` table and the average of the `\"year\"` column from the `\"Movie\"` table. These calculated values are stored into the `v_reviewer_count` and `v_avg_year` variables, respectively. This `SELECT` statement joins three tables: `\"Rating\"` (aliased as `rt`), `\"Reviewer\"` (aliased as `r`), and `\"Movie\"` (aliased as `m`). The join conditions are `rt.\"rID\" = r.\"rID\"` to link ratings to reviewers, and `rt.\"mID\" = m.\"mID\"` to link ratings to movies. The selection is filtered by a `WHERE` clause, including only those records from the `\"Rating\"` table where the `\"stars\"` column is greater than or equal to the input parameter `p_min_stars`.\n\nFollowing this initial data retrieval, the procedure enters a conditional block (`IF`) that checks two conditions: if `v_reviewer_count` is greater than 0 AND `v_avg_year` is not NULL. If both conditions are true, the procedure proceeds with further operations. Inside this conditional block, the `v_radians_result` variable is assigned the result of applying the `radians()` function to the `v_avg_year` value. The `radians()` function converts a degree value (in this case, the average year is treated as a degree value for this mathematical operation) into its equivalent in radians. Subsequently, a `DELETE` statement is executed on the `\"Rating\"` table. This `DELETE` operation removes rows where the `\"ratingDate\"` column is NULL AND the `\"stars\"` column is less than the input parameter `p_min_stars`. After the deletion, an `INSERT` statement is executed to add a new row into the `\"Movie\"` table. The new row's values are: `mID` is calculated as `3000 + p_min_stars`, `title` is set to the string literal 'Analysis Result', `year` is set to the rounded value of `v_avg_year` using the `ROUND()` function, and `director` is set to the string literal 'Pattern Detector'. The procedure concludes after this conditional block.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_rating_patterns(p_min_stars integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_reviewer_count integer;\n    v_avg_year numeric;\n    v_radians_result numeric;\nBEGIN\n    SELECT COUNT(DISTINCT r.\"rID\"), AVG(m.\"year\")\n    INTO v_reviewer_count, v_avg_year\n    FROM \"Rating\" rt\n    JOIN \"Reviewer\" r ON rt.\"rID\" = r.\"rID\"\n    JOIN \"Movie\" m ON rt.\"mID\" = m.\"mID\"\n    WHERE rt.\"stars\" >= p_min_stars;\n    \n    IF v_reviewer_count > 0 AND v_avg_year IS NOT NULL THEN\n        v_radians_result := radians(v_avg_year);\n        \n        DELETE FROM \"Rating\"\n        WHERE \"ratingDate\" IS NULL AND \"stars\" < p_min_stars;\n        \n        INSERT INTO \"Movie\" (\"mID\", \"title\", \"year\", \"director\")\n        VALUES (3000 + p_min_stars, 'Analysis Result', ROUND(v_avg_year), 'Pattern Detector');\n    END IF;\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL analyze_rating_patterns(1);",
      "CALL analyze_rating_patterns(2);",
      "CALL analyze_rating_patterns(3);",
      "CALL analyze_rating_patterns(4);",
      "CALL analyze_rating_patterns(5);"
    ],
    "summary": "Create a stored procedure named `analyze_rating_patterns` that takes an integer parameter `p_min_stars`. It calculates the count of distinct reviewers and the average movie year from a join of the Rating, Reviewer, and Movie tables, filtered by ratings with stars >= `p_min_stars`. If the reviewer count > 0 and the average year is not null, it converts the average year to radians, deletes Rating rows where ratingDate is null and stars < `p_min_stars`, and inserts a new Movie row with a calculated ID, title 'Analysis Result', the rounded average year, and director 'Pattern Detector'.",
    "natural_language": "Develop a comprehensive stored procedure, to be named `analyze_rating_patterns`, which accepts a single integer input parameter designated as `p_min_stars`. This procedure meticulously performs a calculation to determine both the total number of unique reviewers and the mean production year of movies, derived from an intricate join operation involving the Rating, Reviewer, and Movie tables, specifically filtering for those rating entries where the number of stars meets or exceeds the provided `p_min_stars` threshold. Subsequently, if the computed count of distinct reviewers is definitively greater than zero and the resulting average movie year is a non-null value, the procedure executes a series of precise operations: it first transforms the average year into its radian equivalent, then proceeds to permanently delete all rows from the Rating table where the ratingDate field is empty and the stars are strictly less than the `p_min_stars` parameter. Finally, it inserts a brand new record into the Movie table, featuring a dynamically calculated identifier, a formal title explicitly set to 'Analysis Result', the average year rounded to the nearest whole number, and a director name officially listed as 'Pattern Detector'.",
    "id": 32,
    "generated_ir": "Write a PLpgSQL stored procedure named `analyze_rating_patterns` that accepts one input parameter, `p_min_stars`, which is an integer representing a minimum star rating threshold. The procedure begins by declaring three local variables: `v_reviewer_count` of type integer, `v_avg_year` of type numeric, and `v_radians_result` of type numeric. It then executes a `SELECT` statement to calculate two aggregate values: the count of distinct `rID` values from the `\"Reviewer\"` table and the average of the `\"year\"` column from the `\"Movie\"` table. These calculated values are stored into the `v_reviewer_count` and `v_avg_year` variables, respectively. This `SELECT` statement joins three tables: `\"Rating\"` (aliased as `rt`), `\"Reviewer\"` (aliased as `r`), and `\"Movie\"` (aliased as `m`). The join conditions are `rt.\"rID\" = r.\"rID\"` to link ratings to reviewers, and `rt.\"mID\" = m.\"mID\"` to link ratings to movies. The selection is filtered by a `WHERE` clause, including only those records from the `\"Rating\"` table where the `\"stars\"` column is greater than or equal to the input parameter `p_min_stars`.\n\nFollowing this initial data retrieval, the procedure enters a conditional block (`IF`) that checks two conditions: if `v_reviewer_count` is greater than 0 AND `v_avg_year` is not NULL. If both conditions are true, the procedure proceeds with further operations. Inside this conditional block, the `v_radians_result` variable is assigned the result of applying the `radians()` function to the `v_avg_year` value. The `radians()` function converts a degree value (in this case, the average year is treated as a degree value for this mathematical operation) into its equivalent in radians. Subsequently, a `DELETE` statement is executed on the `\"Rating\"` table. This `DELETE` operation removes rows where the `\"ratingDate\"` column is NULL AND the `\"stars\"` column is less than the input parameter `p_min_stars`. After the deletion, an `INSERT` statement is executed to add a new row into the `\"Movie\"` table. The new row's values are: `mID` is calculated as `3000 + p_min_stars`, `title` is set to the string literal 'Analysis Result', `year` is set to the rounded value of `v_avg_year` using the `ROUND()` function, and `director` is set to the string literal 'Pattern Detector'. The procedure concludes after this conditional block."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_customer_account_type` that accepts four input parameters: `p_customer_name` of type `text`, representing the full name of a customer; `p_new_account_type` of type `text`, representing the new account type to be assigned; `p_state_filter` of type `text`, representing the state, county, or province to filter customers by; and `p_min_accounts` of type `integer`, representing the minimum number of accounts a customer must have for their accounts to be updated. The procedure declares two local variables: `v_customer_id` of type `bigint` to store the identified customer's ID, and `v_account_count` of type `integer` to store the number of accounts associated with the identified customer.\n\nThe procedure begins by attempting to retrieve the `customer_id` from the `\"Customers\"` table. It selects the `customer_id` from the alias `c` of the `\"Customers\"` table and stores it into the `v_customer_id` variable. This selection is performed based on two conditions: first, the concatenation of the `customer_first_name` and `customer_last_name` columns from the `\"Customers\"` table, converted to lowercase using the `lower()` function, must exactly match the `p_customer_name` parameter, also converted to lowercase using the `lower()` function; second, the `state_county_province` column from the `\"Customers\"` table must exactly match the `p_state_filter` parameter.\n\nFollowing this initial selection, the procedure checks if a `v_customer_id` was successfully found (i.e., `v_customer_id` is not `NULL`). If a customer ID was found, the procedure proceeds to count the number of accounts associated with this customer. It selects the count of all rows from the `\"Accounts\"` table, aliased as `a`, and stores this count into the `v_account_count` variable. This count is filtered by ensuring that the `customer_id` column in the `\"Accounts\"` table matches the `v_customer_id` that was previously identified.\n\nAfter determining the account count, the procedure then evaluates a conditional statement: if the `v_account_count` is greater than or equal to the `p_min_accounts` parameter, it proceeds to update the customer's accounts. In this case, it performs an `UPDATE` operation on the `\"Accounts\"` table. For all rows in the `\"Accounts\"` table where the `customer_id` column matches the `v_customer_id`, the `other_account_details` column is set to the value provided by the `p_new_account_type` parameter. If `v_customer_id` is `NULL` or `v_account_count` is less than `p_min_accounts`, no update operation is performed.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_customer_account_type(\n    p_customer_name text,\n    p_new_account_type text,\n    p_state_filter text,\n    p_min_accounts integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_customer_id bigint;\n    v_account_count integer;\nBEGIN\n    SELECT c.customer_id INTO v_customer_id\n    FROM \"Customers\" c\n    WHERE lower(c.customer_first_name || ' ' || c.customer_last_name) = lower(p_customer_name)\n    AND c.state_county_province = p_state_filter;\n\n    IF v_customer_id IS NOT NULL THEN\n        SELECT COUNT(*) INTO v_account_count\n        FROM \"Accounts\" a\n        WHERE a.customer_id = v_customer_id;\n\n        IF v_account_count >= p_min_accounts THEN\n            UPDATE \"Accounts\"\n            SET other_account_details = p_new_account_type\n            WHERE customer_id = v_customer_id;\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoice_Line_Items",
      "Invoices",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "CALL update_customer_account_type('Dee Larkin', 'Premium', 'WestVirginia', 1);",
      "CALL update_customer_account_type('Brennon Weimann', 'Gold', 'Oklahoma', 2);",
      "CALL update_customer_account_type('Joesph Schaefer', 'Silver', 'Arkansas', 1);",
      "CALL update_customer_account_type('Dee Larkin', 'VIP', 'WestVirginia', 3);",
      "CALL update_customer_account_type('Brennon Weimann', 'Regular', 'Oklahoma', 1);"
    ],
    "summary": "Create a stored procedure named `update_customer_account_type` that takes a customer name, new account type, state filter, and minimum account count. Find the customer ID by matching the full name (case-insensitive) and state. If found, count the customer's accounts. If the account count meets or exceeds the minimum, update the `other_account_details` for all of that customer's accounts to the new account type.",
    "natural_language": "Hey, can you whip up a stored procedure called `update_customer_account_type`? It needs to take a customer's name, a new type of account, a state to filter by, and a minimum number of accounts. First, look up the customer's ID by matching their full name (don't worry about capitalization) and their state. If you find 'em, count up how many accounts they have. If that count is at least the minimum you got, then go ahead and update the `other_account_details` for every single one of that customer's accounts to the new account type.",
    "id": 33,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_customer_account_type` that accepts four input parameters: `p_customer_name` of type `text`, representing the full name of a customer; `p_new_account_type` of type `text`, representing the new account type to be assigned; `p_state_filter` of type `text`, representing the state, county, or province to filter customers by; and `p_min_accounts` of type `integer`, representing the minimum number of accounts a customer must have for their accounts to be updated. The procedure declares two local variables: `v_customer_id` of type `bigint` to store the identified customer's ID, and `v_account_count` of type `integer` to store the number of accounts associated with the identified customer.\n\nThe procedure begins by attempting to retrieve the `customer_id` from the `\"Customers\"` table. It selects the `customer_id` from the alias `c` of the `\"Customers\"` table and stores it into the `v_customer_id` variable. This selection is performed based on two conditions: first, the concatenation of the `customer_first_name` and `customer_last_name` columns from the `\"Customers\"` table, converted to lowercase using the `lower()` function, must exactly match the `p_customer_name` parameter, also converted to lowercase using the `lower()` function; second, the `state_county_province` column from the `\"Customers\"` table must exactly match the `p_state_filter` parameter.\n\nFollowing this initial selection, the procedure checks if a `v_customer_id` was successfully found (i.e., `v_customer_id` is not `NULL`). If a customer ID was found, the procedure proceeds to count the number of accounts associated with this customer. It selects the count of all rows from the `\"Accounts\"` table, aliased as `a`, and stores this count into the `v_account_count` variable. This count is filtered by ensuring that the `customer_id` column in the `\"Accounts\"` table matches the `v_customer_id` that was previously identified.\n\nAfter determining the account count, the procedure then evaluates a conditional statement: if the `v_account_count` is greater than or equal to the `p_min_accounts` parameter, it proceeds to update the customer's accounts. In this case, it performs an `UPDATE` operation on the `\"Accounts\"` table. For all rows in the `\"Accounts\"` table where the `customer_id` column matches the `v_customer_id`, the `other_account_details` column is set to the value provided by the `p_new_account_type` parameter. If `v_customer_id` is `NULL` or `v_account_count` is less than `p_min_accounts`, no update operation is performed."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named transform_mission_records that accepts four input parameters: p_nationality_source of type text to identify the source nationality for filtering, p_nationality_target of type text to specify the target nationality for new records, p_speed_adjustment of type integer to modify speed values, and p_year_offset of type integer to adjust launch years. The procedure begins by declaring two local variables: v_temp_ship_id as an integer to store a newly generated ship identifier, and v_mission_codes as a text array. It initializes v_mission_codes by populating it with an array of all mission \"Code\" values from the mission table, specifically those records where the associated ship (via a join on the \"Ship_ID\" column) has a \"Nationality\" equal to the p_nationality_source parameter and where the mission's \"Speed_knots\" column value is greater than 20. Next, the procedure inserts a new row into the ship table, generating a new \"Ship_ID\" by taking the current maximum value from the \"Ship_ID\" column and adding 1, setting the \"Name\" column to the literal string 'Transformed_Vessel', the \"Type\" column to 'Conversion', the \"Nationality\" column to the p_nationality_target parameter value, and the \"Tonnage\" column to the integer-cast average of the \"Tonnage\" column from all ship records where the \"Nationality\" matches p_nationality_source; the newly generated \"Ship_ID\" value is captured into the v_temp_ship_id variable using a RETURNING clause. Following this, the procedure performs an INSERT into the mission table, selecting data from existing mission records where the mission's \"Ship_ID\" corresponds to any ship whose \"Nationality\" equals p_nationality_source, and limiting the selection to only 3 rows. For each selected row, it constructs new values: a new \"Mission_ID\" calculated by adding a row number sequence to the current maximum \"Mission_ID\" (or 0 if the table is empty, using COALESCE), the \"Ship_ID\" set to the v_temp_ship_id, the \"Code\" prefixed with 'TRN-', the \"Launched_Year\" incremented by the p_year_offset parameter, the \"Location\" set to the p_nationality_target parameter value, the \"Speed_knots\" increased by the p_speed_adjustment parameter, and the \"Fate\" column appended with the string 'Transformed from '. Finally, the procedure executes a DELETE operation on the ship table, removing any ship records where the \"Ship_ID\" does not appear in the distinct set of \"Ship_ID\" values present in the mission table (i.e., ships with no associated missions) and where the ship's \"Nationality\" is exactly equal to the p_nationality_source parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_mission_records(\n    p_nationality_source text,\n    p_nationality_target text,\n    p_speed_adjustment integer,\n    p_year_offset integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_temp_ship_id integer;\n    v_mission_codes text[];\nBEGIN\n    v_mission_codes := ARRAY(\n        SELECT m.\"Code\" \n        FROM mission m\n        JOIN ship s ON m.\"Ship_ID\" = s.\"Ship_ID\"\n        WHERE s.\"Nationality\" = p_nationality_source\n        AND m.\"Speed_knots\" > 20\n    );\n\n    INSERT INTO ship (\"Ship_ID\", \"Name\", \"Type\", \"Nationality\", \"Tonnage\")\n    VALUES (\n        (SELECT MAX(\"Ship_ID\") + 1 FROM ship),\n        'Transformed_Vessel',\n        'Conversion',\n        p_nationality_target,\n        (SELECT AVG(\"Tonnage\") FROM ship WHERE \"Nationality\" = p_nationality_source)::integer\n    )\n    RETURNING \"Ship_ID\" INTO v_temp_ship_id;\n\n    INSERT INTO mission (\"Mission_ID\", \"Ship_ID\", \"Code\", \"Launched_Year\", \"Location\", \"Speed_knots\", \"Fate\")\n    SELECT \n        (SELECT COALESCE(MAX(\"Mission_ID\"), 0) FROM mission) + ROW_NUMBER() OVER (),\n        v_temp_ship_id,\n        'TRN-' || \"Code\",\n        \"Launched_Year\" + p_year_offset,\n        p_nationality_target,\n        \"Speed_knots\" + p_speed_adjustment,\n        'Transformed from ' || \"Fate\"\n    FROM mission\n    WHERE \"Ship_ID\" IN (\n        SELECT \"Ship_ID\" FROM ship \n        WHERE \"Nationality\" = p_nationality_source\n    )\n    LIMIT 3;\n\n    DELETE FROM ship\n    WHERE \"Ship_ID\" NOT IN (\n        SELECT DISTINCT \"Ship_ID\" FROM mission\n    )\n    AND \"Nationality\" = p_nationality_source;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL transform_mission_records('United Kingdom', 'United States', 5, 2);",
      "CALL transform_mission_records('United States', 'Germany', -3, -1);",
      "CALL transform_mission_records('Germany', 'France', 10, 5);",
      "CALL transform_mission_records('France', 'Italy', 0, 0);",
      "CALL transform_mission_records('Italy', 'Japan', 7, 3);"
    ],
    "summary": "Create a stored procedure named transform_mission_records with parameters p_nationality_source (text), p_nationality_target (text), p_speed_adjustment (integer), and p_year_offset (integer). The procedure should: 1) Store mission codes from missions where the associated ship's nationality matches p_nationality_source and mission speed exceeds 20. 2) Insert a new ship with name 'Transformed_Vessel', type 'Conversion', nationality p_nationality_target, and tonnage set to the average tonnage of ships with nationality p_nationality_source; capture the new ship's ID. 3) Insert up to 3 new missions based on missions from ships with nationality p_nationality_source, transforming the data: prefix code with 'TRN-', adjust launch year by p_year_offset, set location to p_nationality_target, adjust speed by p_speed_adjustment, and append 'Transformed from ' to fate. 4) Delete ships with nationality p_nationality_source that have no associated missions.",
    "natural_language": "Create a stored procedure called transform_mission_records. It must take the parameters p_nationality_source (text), p_nationality_target (text), p_speed_adjustment (integer), and p_year_offset (integer). First, store the mission codes from missions where the linked ship's nationality is p_nationality_source and the mission speed is over 20. Next, insert a new ship. Name it 'Transformed_Vessel', set its type to 'Conversion', its nationality to p_nationality_target, and its tonnage to the average tonnage of ships with nationality p_nationality_source; also capture this new ship's ID. Then, insert up to 3 new missions based on missions from ships with nationality p_nationality_source. Transform the data by prefixing the mission code with 'TRN-', adjusting the launch year by p_year_offset, setting the location to p_nationality_target, adjusting the speed by p_speed_adjustment, and appending 'Transformed from ' to the fate. Finally, delete any ships with nationality p_nationality_source that have no associated missions.",
    "id": 34,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named transform_mission_records that accepts four input parameters: p_nationality_source of type text, p_nationality_target of type text, p_speed_adjustment of type integer, and p_year_offset of type integer. The procedure operates on the ship_mission database and involves multiple steps to transform mission records and manage ship data.\n\nFirst, the procedure declares a variable v_mission_codes of type text array to store mission codes, a variable v_avg_tonnage of type integer to hold the average tonnage, and a variable v_new_ship_id of type integer to capture the ID of a newly inserted ship.\n\nThe procedure begins by selecting mission codes from the mission table where the linked ship's nationality matches p_nationality_source and the mission speed exceeds 20. This is achieved by joining the mission table with the ship table on Ship_ID, filtering for ship.nationality equal to p_nationality_source and mission.speed_knots greater than 20. The selected mission codes are stored in the v_mission_codes array.\n\nNext, the procedure calculates the average tonnage from the ship table for ships with nationality equal to p_nationality_source, storing the result in v_avg_tonnage. It then inserts a new row into the ship table with the following values: Name set to 'Transformed_Vessel', Type set to 'Conversion', Nationality set to p_nationality_target, and Tonnage set to v_avg_tonnage. The RETURNING clause is used to capture the generated Ship_ID into v_new_ship_id.\n\nFollowing this, the procedure inserts up to three new missions into the mission table. It selects from the mission table where the linked ship's nationality is p_nationality_source, joining on Ship_ID, and limits the result to three rows. For each selected mission, the data is transformed: the mission code is prefixed with 'TRN-', the launched year is adjusted by adding p_year_offset, the location is set to p_nationality_target, the speed is adjusted by adding p_speed_adjustment, and the fate is modified by appending 'Transformed from ' to its original value. The new missions are linked to the newly inserted ship by setting Ship_ID to v_new_ship_id.\n\nFinally, the procedure deletes any ships from the ship table where the nationality matches p_nationality_source and there are no associated missions in the mission table. This is done using a subquery to check for the absence of matching Mission_IDs in the mission table for each ship."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_book_audio_length that accepts three input parameters: an integer parameter named book_id to identify a specific book record, a text parameter named new_audio_length to provide the new audio duration value, and an integer parameter named max_pages to serve as a maximum page count threshold. The procedure begins by checking for the existence of a row in the book table where the Book_ID column matches the provided book_id parameter and simultaneously the Pages column value is less than or equal to the max_pages parameter. If such a row exists, the procedure executes an update operation on the book table, setting the Audio column to the value of the new_audio_length parameter specifically for the row where the Book_ID column equals the input book_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_book_audio_length(book_id INTEGER, new_audio_length TEXT, max_pages INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"book\" WHERE \"Book_ID\" = book_id AND \"Pages\" <= max_pages) THEN\n        UPDATE \"book\"\n        SET \"Audio\" = new_audio_length\n        WHERE \"Book_ID\" = book_id;\n    END IF;\nEND;\n$$;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "CALL update_book_audio_length(1, '34h 15m', 800);",
      "CALL update_book_audio_length(2, '38h 05m', 1000);",
      "CALL update_book_audio_length(3, '48h 20m', 1200);",
      "CALL update_book_audio_length(1, '35h 00m', 500);",
      "CALL update_book_audio_length(2, '37h 30m', 770);"
    ],
    "summary": "Create a stored procedure named update_book_audio_length that updates the Audio column in the book table for a specific book_id, but only if that book's Pages are less than or equal to a given maximum page threshold.",
    "natural_language": "Please construct a stored procedure designated as 'update_book_audio_length'. Its function is to modify the value within the Audio column of the book table for a specified book identifier. This modification shall be executed conditionally, proceeding only if the number of Pages for the identified book does not exceed a provided maximum page threshold.",
    "id": 35,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `update_book_audio_length` that accepts two input parameters: `p_book_id` of type `integer` representing the unique identifier of the book to update, and `p_max_pages` of type `integer` representing the maximum page threshold.\n\nThe procedure begins by declaring a local variable `v_current_pages` of type `integer` to store the current number of pages for the specified book.\n\nThe procedure then retrieves the `Pages` value from the `book` table for the row where the `Book_ID` column equals the input parameter `p_book_id`. This value is stored into the `v_current_pages` variable.\n\nNext, the procedure checks a condition: if `v_current_pages` is less than or equal to `p_max_pages`, then it proceeds to update the `book` table. The update operation sets the `Audio` column to a new calculated value. The new value is constructed by concatenating the string representation of `v_current_pages` (converted to text) with the literal string ' pages' to form a descriptive audio length.\n\nIf the condition is not met (i.e., if `v_current_pages` is greater than `p_max_pages`), the update operation is not performed, and the procedure ends without making any changes to the database.\n\nThe procedure does not return a value; it is a void procedure that performs a conditional update."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named consolidate_device_stock that accepts two integer input parameters, p_source_shop and p_target_shop, and performs a consolidation of stock records from a source shop to a target shop by first reading all stock entries from the source shop, then attempting to insert those entries into the target shop, and finally deleting the original source shop entries. The procedure begins by declaring a variable named rec of type RECORD to hold rows from a query. It then executes a FOR loop that iterates over each row returned by a SELECT query on the stock table; this query selects the Device_ID column and the Quantity column for every row where the Shop_ID column equals the provided p_source_shop parameter. For each record fetched in the loop, the procedure executes an INSERT statement on the stock table, specifying values for the Shop_ID column (using the p_target_shop parameter), the Device_ID column (using the rec.Device_ID value from the current loop record), and the Quantity column (using the rec.Quantity value from the current loop record). This INSERT statement includes an ON CONFLICT clause that targets the unique constraint or index on the combination of the Shop_ID and Device_ID columns; if a row with the same target shop and device ID already exists, the DO NOTHING action is taken, meaning the insert is silently skipped without error and no update occurs. After the loop completes all iterations, the procedure executes a DELETE statement on the stock table that removes every row where the Shop_ID column equals the p_source_shop parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_device_stock(p_source_shop integer, p_target_shop integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    rec RECORD;\nBEGIN\n    FOR rec IN \n        SELECT \"Device_ID\", \"Quantity\" \n        FROM stock \n        WHERE \"Shop_ID\" = p_source_shop\n    LOOP\n        INSERT INTO stock (\"Shop_ID\", \"Device_ID\", \"Quantity\")\n        VALUES (p_target_shop, rec.\"Device_ID\", rec.\"Quantity\")\n        ON CONFLICT (\"Shop_ID\", \"Device_ID\") \n        DO NOTHING;\n    END LOOP;\n    \n    DELETE FROM stock WHERE \"Shop_ID\" = p_source_shop;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL consolidate_device_stock(1, 2);",
      "CALL consolidate_device_stock(3, 1);",
      "CALL consolidate_device_stock(2, 3);",
      "CALL consolidate_device_stock(5, 10);",
      "CALL consolidate_device_stock(8, 4);"
    ],
    "summary": "Create a stored procedure named consolidate_device_stock that accepts source and target shop IDs. It reads all stock entries from the source shop and inserts them into the target shop. If a device already exists at the target shop, the insert is skipped. Finally, it deletes all stock entries from the source shop.",
    "natural_language": "How can I create a stored procedure named consolidate_device_stock that takes source and target shop IDs, reads all stock entries from the source shop to insert them into the target shop while skipping inserts for devices that already exist there, and then deletes all stock entries from the source shop?",
    "id": 36,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named consolidate_device_stock that accepts two integer input parameters, p_source_shop and p_target_shop, and performs a consolidation of stock records from a source shop to a target shop by first reading all stock entries from the source shop, then attempting to insert those entries into the target shop, and finally deleting the original source shop entries. The procedure begins by declaring a variable named rec of type RECORD to hold rows from a query. It then executes a FOR loop that iterates over each row returned by a SELECT query on the stock table; this query selects the Device_ID column and the Quantity column for every row where the Shop_ID column equals the provided p_source_shop parameter. For each record fetched in the loop, the procedure executes an INSERT statement on the stock table, specifying values for the Shop_ID column (using the p_target_shop parameter), the Device_ID column (using the rec.Device_ID value from the current loop record), and the Quantity column (using the rec.Quantity value from the current loop record). This INSERT statement includes an ON CONFLICT clause that targets the unique constraint or index on the combination of the Shop_ID and Device_ID columns; if a row with the same target shop and device ID already exists, the DO NOTHING action is taken, meaning the insert is silently skipped without error and no update occurs. After the loop completes all iterations, the procedure executes a DELETE statement on the stock table that removes every row where the Shop_ID column equals the p_source_shop parameter."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named calculate_company_stats that accepts three input parameters: an integer p_year, an integer p_min_rank, and a real number p_max_assets. The procedure first calculates two statistics: it computes the average Sales_billion from the company table for companies whose Rank is between the parameter p_min_rank and 10 inclusive and whose Assets_billion is less than or equal to p_max_assets, storing the result in a local variable v_avg_sales; it also calculates the total count of distinct Station_ID values from the station_company table, joined with the gas_station table on Station_ID, for gas stations opened in the specified p_year and where the associated Company_ID belongs to a company with a Rank less than or equal to p_min_rank, storing this count in a local variable v_total_stations. Based on these computed values, the procedure executes one of three conditional branches: if v_avg_sales is greater than 300, it deletes rows from the station_company table where the Rank_of_the_Year column is greater than 5 and the Company_ID belongs to any company in the company table with a Sales_billion value less than the calculated v_avg_sales; else, if v_total_stations is greater than 10, it inserts up to three new rows into the station_company table, specifically into the Station_ID, Company_ID, and Rank_of_the_Year columns, by performing a cross join between the gas_station table (filtered for stations opened in p_year) and the company table (filtered for companies with a Rank equal to p_min_rank), generating a random integer between 1 and 5 (inclusive) using the expression FLOOR(RANDOM() * 5 + 1) for the Rank_of_the_Year, and only for station-company pairs that do not already exist in the station_company table, as enforced by a NOT EXISTS subquery; otherwise, if neither previous condition is met, it deletes rows from the station_company table where the Company_ID belongs to any company in the company table with an Assets_billion value greater than the input parameter p_max_assets.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_company_stats(p_year INTEGER, p_min_rank INTEGER, p_max_assets REAL)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_sales REAL;\n    v_total_stations INTEGER;\nBEGIN\n    SELECT AVG(\"Sales_billion\") INTO v_avg_sales\n    FROM company\n    WHERE \"Rank\" BETWEEN p_min_rank AND 10\n    AND \"Assets_billion\" <= p_max_assets;\n    \n    SELECT COUNT(DISTINCT sc.\"Station_ID\") INTO v_total_stations\n    FROM station_company sc\n    JOIN gas_station gs ON sc.\"Station_ID\" = gs.\"Station_ID\"\n    WHERE gs.\"Open_Year\" = p_year\n    AND sc.\"Company_ID\" IN (SELECT \"Company_ID\" FROM company WHERE \"Rank\" <= p_min_rank);\n    \n    IF v_avg_sales > 300 THEN\n        DELETE FROM station_company\n        WHERE \"Rank_of_the_Year\" > 5\n        AND \"Company_ID\" IN (SELECT \"Company_ID\" FROM company WHERE \"Sales_billion\" < v_avg_sales);\n    ELSIF v_total_stations > 10 THEN\n        INSERT INTO station_company (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\")\n        SELECT gs.\"Station_ID\", c.\"Company_ID\", FLOOR(RANDOM() * 5 + 1)\n        FROM gas_station gs\n        CROSS JOIN company c\n        WHERE gs.\"Open_Year\" = p_year\n        AND c.\"Rank\" = p_min_rank\n        AND NOT EXISTS (\n            SELECT 1 FROM station_company sc \n            WHERE sc.\"Station_ID\" = gs.\"Station_ID\" \n            AND sc.\"Company_ID\" = c.\"Company_ID\"\n        )\n        LIMIT 3;\n    ELSE\n        DELETE FROM station_company\n        WHERE \"Company_ID\" IN (\n            SELECT \"Company_ID\" FROM company \n            WHERE \"Assets_billion\" > p_max_assets\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "CALL calculate_company_stats(2020, 5, 500.0);",
      "CALL calculate_company_stats(2019, 3, 1000.0);",
      "CALL calculate_company_stats(2021, 8, 300.0);",
      "CALL calculate_company_stats(2018, 1, 200.0);",
      "CALL calculate_company_stats(2022, 6, 750.0);"
    ],
    "summary": "Create a stored procedure named calculate_company_stats with parameters p_year (INTEGER), p_min_rank (INTEGER), and p_max_assets (REAL). Calculate the average Sales_billion for companies with Rank between p_min_rank and 10 and Assets_billion <= p_max_assets, storing it in v_avg_sales. Count distinct Station_ID from station_company joined with gas_station for stations opened in p_year where the associated Company_ID belongs to a company with Rank <= p_min_rank, storing it in v_total_stations. If v_avg_sales > 300, delete from station_company where Rank_of_the_Year > 5 and Company_ID belongs to a company with Sales_billion < v_avg_sales. Else if v_total_stations > 10, insert up to three new rows into station_company (Station_ID, Company_ID, Rank_of_the_Year) from a cross join of gas_station (opened in p_year) and company (Rank = p_min_rank), with Rank_of_the_Year as a random integer 1-5, only for non-existing pairs. Else, delete from station_company where Company_ID belongs to a company with Assets_billion > p_max_assets.",
    "natural_language": "Create a stored procedure called calculate_company_stats that takes p_year (INTEGER), p_min_rank (INTEGER), and p_max_assets (REAL) as parameters. First, compute the average Sales_billion for companies whose Rank is between p_min_rank and 10 and whose Assets_billion is less than or equal to p_max_assets, and store this result in v_avg_sales. Next, count the distinct Station_ID from the join of station_company and gas_station for stations opened in the year p_year, but only where the associated Company_ID belongs to a company with a Rank less than or equal to p_min_rank, and store this count in v_total_stations. Then, check the following conditions: if v_avg_sales is greater than 300, delete records from station_company where the Rank_of_the_Year is greater than 5 and the Company_ID belongs to a company with Sales_billion less than v_avg_sales. Otherwise, if v_total_stations is greater than 10, insert up to three new rows into station_company for columns Station_ID, Company_ID, and Rank_of_the_Year. These rows should come from a cross join of gas_station (filtered for stations opened in p_year) and company (filtered for Rank equal to p_min_rank), assigning a random integer between 1 and 5 as Rank_of_the_Year, but only insert pairs that do not already exist. If neither condition is met, delete from station_company where the Company_ID belongs to a company with Assets_billion greater than p_max_assets.",
    "id": 37,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named calculate_company_stats that accepts three input parameters: an integer p_year, an integer p_min_rank, and a real number p_max_assets. The procedure first calculates two statistics: it computes the average Sales_billion from the company table for companies whose Rank is between the parameter p_min_rank and 10 inclusive and whose Assets_billion is less than or equal to p_max_assets, storing the result in a local variable v_avg_sales; it also calculates the total count of distinct Station_ID values from the station_company table, joined with the gas_station table on Station_ID, for gas stations opened in the specified p_year and where the associated Company_ID belongs to a company with a Rank less than or equal to p_min_rank, storing this count in a local variable v_total_stations. Based on these computed values, the procedure executes one of three conditional branches: if v_avg_sales is greater than 300, it deletes rows from the station_company table where the Rank_of_the_Year column is greater than 5 and the Company_ID belongs to any company in the company table with a Sales_billion value less than the calculated v_avg_sales; else, if v_total_stations is greater than 10, it inserts up to three new rows into the station_company table, specifically into the Station_ID, Company_ID, and Rank_of_the_Year columns, by performing a cross join between the gas_station table (filtered for stations opened in p_year) and the company table (filtered for companies with a Rank equal to p_min_rank), generating a random integer between 1 and 5 (inclusive) using the expression FLOOR(RANDOM() * 5 + 1) for the Rank_of_the_Year, and only for station-company pairs that do not already exist in the station_company table, as enforced by a NOT EXISTS subquery; otherwise, if neither previous condition is met, it deletes rows from the station_company table where the Company_ID belongs to any company in the company table with an Assets_billion value greater than the input parameter p_max_assets."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `validate_warehouse_capacity_limits` that accepts three input parameters: `p_capacity_threshold` of type `bigint`, `p_value_limit` of type `real`, and `p_location_substring` of type `text`. The procedure declares three local variables: `v_warehouse_code` of type `bigint`, `v_current_box_count` of type `integer`, and `v_high_value_boxes` of type `integer`. The procedure then initiates a loop that iterates over a specific set of warehouse codes. This set is determined by selecting the \"Code\" column from the \"Warehouses\" table where the \"Capacity\" column is strictly greater than the input parameter `p_capacity_threshold` AND the \"Location\" column contains the `p_location_substring` as a case-sensitive substring (achieved by concatenating '%' before and after `p_location_substring`). For each `v_warehouse_code` obtained from this selection, the procedure performs the following operations: First, it calculates the total number of boxes currently stored in the warehouse identified by `v_warehouse_code` by selecting the count of all rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code`, and stores this count in the `v_current_box_count` variable. Second, it calculates the number of \"high-value\" boxes in the same warehouse by selecting the count of rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code` AND the \"Value\" column is strictly greater than the input parameter `p_value_limit`, and stores this count in the `v_high_value_boxes` variable. Third, it evaluates a conditional statement: if the `v_current_box_count` is strictly greater than the \"Capacity\" value for the current `v_warehouse_code` (which is retrieved by selecting the \"Capacity\" column from the \"Warehouses\" table where the \"Code\" column matches `v_warehouse_code`), then it proceeds to delete a specific box. The deletion targets rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code` AND the \"Value\" column is equal to the minimum \"Value\" found among all boxes in that same warehouse (this minimum value is determined by a subquery that selects the minimum \"Value\" from the \"Boxes\" table where the \"Warehouse\" column matches `v_warehouse_code`). This loop continues until all relevant warehouse codes have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_warehouse_capacity_limits(p_capacity_threshold bigint, p_value_limit real, p_location_substring text)\nAS $$\nDECLARE\n    v_warehouse_code bigint;\n    v_current_box_count integer;\n    v_high_value_boxes integer;\nBEGIN\n    FOR v_warehouse_code IN\n        SELECT \"Code\"\n        FROM \"Warehouses\"\n        WHERE \"Capacity\" > p_capacity_threshold\n        AND \"Location\" LIKE '%' || p_location_substring || '%'\n    LOOP\n        SELECT COUNT(*) INTO v_current_box_count\n        FROM \"Boxes\"\n        WHERE \"Warehouse\" = v_warehouse_code;\n        \n        SELECT COUNT(*) INTO v_high_value_boxes\n        FROM \"Boxes\"\n        WHERE \"Warehouse\" = v_warehouse_code\n        AND \"Value\" > p_value_limit;\n        \n        IF v_current_box_count > (SELECT \"Capacity\" FROM \"Warehouses\" WHERE \"Code\" = v_warehouse_code) THEN\n            DELETE FROM \"Boxes\"\n            WHERE \"Warehouse\" = v_warehouse_code\n            AND \"Value\" = (SELECT MIN(\"Value\") FROM \"Boxes\" WHERE \"Warehouse\" = v_warehouse_code);\n        END IF;\n    END LOOP;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL validate_warehouse_capacity_limits(2, 200.0, 'Chicago');",
      "CALL validate_warehouse_capacity_limits(3, 150.0, 'New York');",
      "CALL validate_warehouse_capacity_limits(1, 180.0, 'York');",
      "CALL validate_warehouse_capacity_limits(4, 250.0, 'Chic');",
      "CALL validate_warehouse_capacity_limits(5, 100.0, 'New');"
    ],
    "summary": "Create a stored procedure named validate_warehouse_capacity_limits that takes parameters for capacity_threshold (bigint), value_limit (real), and location_substring (text). Loop through warehouses with capacity exceeding the threshold and location containing the substring. For each, count its total boxes and high-value boxes (value above limit). If the box count exceeds the warehouse's capacity, delete the box with the minimum value in that warehouse.",
    "natural_language": "Make a stored procedure called validate_warehouse_capacity_limits that uses inputs for a capacity threshold (bigint), a value cutoff (real), and a bit of text for location. Go through warehouses that have a capacity over that rough threshold and where the location kind of matches that text snippet. For each one, figure out roughly how many boxes it has in total and how many are the more valuable ones (above that limit). If the number of boxes seems to be more than what the warehouse should hold, get rid of the least valuable box found there.",
    "id": 38,
    "generated_ir": "Write a PLpgSQL stored procedure named `validate_warehouse_capacity_limits` that accepts three input parameters: `p_capacity_threshold` of type `bigint`, `p_value_limit` of type `real`, and `p_location_substring` of type `text`. The procedure declares three local variables: `v_warehouse_code` of type `bigint`, `v_current_box_count` of type `integer`, and `v_high_value_boxes` of type `integer`. The procedure then initiates a loop that iterates over a specific set of warehouse codes. This set is determined by selecting the \"Code\" column from the \"Warehouses\" table where the \"Capacity\" column is strictly greater than the input parameter `p_capacity_threshold` AND the \"Location\" column contains the `p_location_substring` as a case-sensitive substring (achieved by concatenating '%' before and after `p_location_substring`). For each `v_warehouse_code` obtained from this selection, the procedure performs the following operations: First, it calculates the total number of boxes currently stored in the warehouse identified by `v_warehouse_code` by selecting the count of all rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code`, and stores this count in the `v_current_box_count` variable. Second, it calculates the number of \"high-value\" boxes in the same warehouse by selecting the count of rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code` AND the \"Value\" column is strictly greater than the input parameter `p_value_limit`, and stores this count in the `v_high_value_boxes` variable. Third, it evaluates a conditional statement: if the `v_current_box_count` is strictly greater than the \"Capacity\" value for the current `v_warehouse_code` (which is retrieved by selecting the \"Capacity\" column from the \"Warehouses\" table where the \"Code\" column matches `v_warehouse_code`), then it proceeds to delete a specific box. The deletion targets rows from the \"Boxes\" table where the \"Warehouse\" column matches the current `v_warehouse_code` AND the \"Value\" column is equal to the minimum \"Value\" found among all boxes in that same warehouse (this minimum value is determined by a subquery that selects the minimum \"Value\" from the \"Boxes\" table where the \"Warehouse\" column matches `v_warehouse_code`). This loop continues until all relevant warehouse codes have been processed."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named aggregate_focal_length_metrics that accepts four input parameters: a real number parameter p_focal_group1, a real number parameter p_focal_group2, an integer parameter p_mountain_threshold, and a text parameter p_brand_input. The procedure first calculates the average mountain_id from the photos table for two distinct groups of photos, where the grouping is based on the focal length of the camera lens used. For the first group, it joins the photos table with the camera_lens table on the camera_lens_id foreign key and filters for rows where the camera_lens brand equals p_brand_input and the camera_lens focal_length_mm is less than or equal to p_focal_group1, then computes the average mountain_id for these rows and stores it in a local variable v_group1_avg. For the second group, it performs a similar join and filter operation, but selects rows where the camera_lens focal_length_mm is greater than p_focal_group1 and less than or equal to p_focal_group2, and the brand matches p_brand_input, computing the average mountain_id into a second local variable v_group2_avg. The procedure then computes the absolute difference between these two average values, using COALESCE to treat NULL averages as 0, and stores this result in variable v_total_diff. Next, a conditional block executes one of three possible actions based on the computed values: if v_total_diff is greater than the input parameter p_mountain_threshold, it inserts new rows into the photos table, generating a new id by adding a random integer between 1 and 999,999 to the camera_lens id, using the camera_lens id itself, setting the mountain_id to the integer average of the two group averages (again using COALESCE with a default of 10 for NULLs), setting the color column to the literal string 'Balanced', and setting the name column to the string 'Diff: ' concatenated with the integer floor of v_total_diff, where the source for this insert is a select from the camera_lens table filtered for the specified p_brand_input and where focal_length_mm is between p_focal_group1 and p_focal_group2, ordered by camera_lens id and limited to 4 rows. If the first condition is not met, the procedure checks if the first group's average (or 0 if NULL) is greater than the second group's average (or 0 if NULL); if true, it deletes rows from the photos table where the photo id is in a subquery that selects the id of photos whose mountain_id is greater than v_group1_avg and whose camera_lens_id corresponds to a lens from the camera_lens table with a brand matching p_brand_input and a focal_length_mm less than or equal to p_focal_group1, ordering the subquery by photo id and limiting the result to 2 rows. If neither of the previous conditions is true, the procedure executes an alternative delete operation, removing rows from the photos table where the photo id is in a subquery that selects the id of photos whose mountain_id is less than the COALESCE value of v_group2_avg or p_mountain_threshold if v_group2_avg is NULL, whose camera_lens_id corresponds to a lens with a brand matching p_brand_input and a focal_length_mm greater than p_focal_group2, and whose color column value is either 'RBG' or 'Black/White', ordering the subquery by photo id and limiting the result to 3 rows.",
    "plsql": "CREATE OR REPLACE PROCEDURE aggregate_focal_length_metrics(p_focal_group1 real, p_focal_group2 real, p_mountain_threshold integer, p_brand_input text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_group1_avg real;\n    v_group2_avg real;\n    v_total_diff real;\nBEGIN\n    SELECT AVG(p.\"mountain_id\") INTO v_group1_avg\n    FROM \"photos\" p\n    INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n    WHERE cl.\"focal_length_mm\" <= p_focal_group1\n    AND cl.\"brand\" = p_brand_input;\n    \n    SELECT AVG(p.\"mountain_id\") INTO v_group2_avg\n    FROM \"photos\" p\n    INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n    WHERE cl.\"focal_length_mm\" > p_focal_group1 AND cl.\"focal_length_mm\" <= p_focal_group2\n    AND cl.\"brand\" = p_brand_input;\n    \n    v_total_diff := ABS(COALESCE(v_group1_avg, 0) - COALESCE(v_group2_avg, 0));\n    \n    IF v_total_diff > p_mountain_threshold THEN\n        INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n        SELECT \n            FLOOR(RANDOM() * 1000000) + cl.\"id\",\n            cl.\"id\",\n            FLOOR(COALESCE(v_group1_avg, 10) + COALESCE(v_group2_avg, 10)) / 2,\n            'Balanced',\n            'Diff: ' || FLOOR(v_total_diff)\n        FROM \"camera_lens\" cl\n        WHERE cl.\"brand\" = p_brand_input\n        AND cl.\"focal_length_mm\" BETWEEN p_focal_group1 AND p_focal_group2\n        ORDER BY cl.\"id\" -- Added ORDER BY for deterministic LIMIT\n        LIMIT 4;\n    ELSIF COALESCE(v_group1_avg, 0) > COALESCE(v_group2_avg, 0) THEN\n        DELETE FROM \"photos\"\n        WHERE \"id\" IN (\n            SELECT p_inner.\"id\"\n            FROM \"photos\" p_inner\n            WHERE p_inner.\"mountain_id\" > v_group1_avg\n            AND p_inner.\"camera_lens_id\" IN (\n                SELECT \"id\" FROM \"camera_lens\"\n                WHERE \"focal_length_mm\" <= p_focal_group1\n                AND \"brand\" = p_brand_input\n            )\n            ORDER BY p_inner.\"id\" -- Added ORDER BY for deterministic LIMIT\n            LIMIT 2\n        );\n    ELSE\n        DELETE FROM \"photos\"\n        WHERE \"id\" IN (\n            SELECT p_inner.\"id\"\n            FROM \"photos\" p_inner\n            WHERE p_inner.\"mountain_id\" < COALESCE(v_group2_avg, p_mountain_threshold)\n            AND p_inner.\"camera_lens_id\" IN (\n                SELECT \"id\" FROM \"camera_lens\"\n                WHERE \"focal_length_mm\" > p_focal_group2\n                AND \"brand\" = p_brand_input\n            )\n            AND p_inner.\"color\" IN ('RBG', 'Black/White')\n            ORDER BY p_inner.\"id\" -- Added ORDER BY for deterministic LIMIT\n            LIMIT 3\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "photos"
    ],
    "call_sqls": [
      "CALL aggregate_focal_length_metrics(35.0, 85.0, 15, 'Olympus');",
      "CALL aggregate_focal_length_metrics(24.0, 70.0, 10, 'Canon');",
      "CALL aggregate_focal_length_metrics(50.0, 135.0, 20, 'Nikon');",
      "CALL aggregate_focal_length_metrics(16.0, 35.0, 5, 'Sony');",
      "CALL aggregate_focal_length_metrics(70.0, 200.0, 25, 'Sigma');"
    ],
    "summary": "Create a stored procedure named aggregate_focal_length_metrics with parameters p_focal_group1 (real), p_focal_group2 (real), p_mountain_threshold (integer), and p_brand_input (text). Calculate the average mountain_id for photos using lenses with brand p_brand_input in two focal length groups: <= p_focal_group1 and between p_focal_group1 and p_focal_group2. Compute the absolute difference between these averages. If the difference > p_mountain_threshold, insert up to 4 new 'Balanced' photos for lenses in the focal range, using the integer average of the group averages for mountain_id. If the first group's average > second group's average, delete up to 2 photos from the first group where mountain_id > its average. Otherwise, delete up to 3 photos from lenses with focal_length > p_focal_group2 where color is 'RBG' or 'Black/White' and mountain_id is less than the second group's average or the threshold.",
    "natural_language": "Please construct a stored procedure entitled 'aggregate_focal_length_metrics'. This procedure shall accept the following parameters: 'p_focal_group1' of type REAL, 'p_focal_group2' of type REAL, 'p_mountain_threshold' of type INTEGER, and 'p_brand_input' of type TEXT. The procedure is to compute the average 'mountain_id' for photographs that utilize lenses from the brand specified by 'p_brand_input', segmented into two focal length categories: those less than or equal to 'p_focal_group1', and those greater than 'p_focal_group1' but less than or equal to 'p_focal_group2'. Subsequently, determine the absolute difference between these two computed averages.\n\nShould this absolute difference exceed the value of 'p_mountain_threshold', insert a maximum of four new photographic records with the designation 'Balanced'. These records are to be associated with lenses within the specified focal range, employing the integer average of the two group averages for the 'mountain_id' value.\n\nAlternatively, if the first group's average exceeds that of the second group, delete up to two photographic records from the first group where the 'mountain_id' is greater than its group average. If the contrary is true, delete up to three photographic records from lenses with a 'focal_length' exceeding 'p_focal_group2', provided the 'color' attribute is either 'RBG' or 'Black/White' and the 'mountain_id' is less than either the second group's average or the provided threshold value.",
    "id": 39,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named aggregate_focal_length_metrics in the mountain_photos database. The procedure accepts four input parameters: p_focal_group1 of type REAL, p_focal_group2 of type REAL, p_mountain_threshold of type INTEGER, and p_brand_input of type TEXT. The procedure returns no value (void). It declares several local variables: v_avg_group1 of type REAL to store the average mountain_id for the first focal length group, v_avg_group2 of type REAL for the second group, v_abs_diff of type REAL to hold the absolute difference between the two averages, v_combined_avg of type INTEGER to store the integer average of the two group averages, and a loop counter variable if needed for iterative operations.\n\nFirst, the procedure computes v_avg_group1 by executing a SELECT statement that calculates the AVG of the mountain_id column from the photos table, joining with the camera_lens table on photos.camera_lens_id = camera_lens.id. This query filters rows where camera_lens.brand equals p_brand_input and camera_lens.focal_length_mm is less than or equal to p_focal_group1. The result is stored into v_avg_group1, defaulting to 0 if no rows match.\n\nSecond, it computes v_avg_group2 similarly, but with a filter where camera_lens.focal_length_mm is greater than p_focal_group1 and less than or equal to p_focal_group2. The result is stored into v_avg_group2, defaulting to 0 if no rows match.\n\nThird, it calculates v_abs_diff as the absolute value of the difference between v_avg_group1 and v_avg_group2.\n\nThe procedure then checks if v_abs_diff is greater than p_mountain_threshold. If true, it computes v_combined_avg as the integer average of v_avg_group1 and v_avg_group2, using rounding or truncation as needed. It then performs an INSERT operation into the photos table, adding up to four new records. For each insertion, it selects camera_lens.id from the camera_lens table where brand equals p_brand_input and focal_length_mm is between p_focal_group1 and p_focal_group2 (inclusive of p_focal_group2), limiting to four distinct lens IDs. For each selected lens, it inserts a row with camera_lens_id set to that lens ID, mountain_id set to v_combined_avg, color set to a default value like 'Balanced', and name set to 'Balanced'. The insertion stops after four records are inserted or if no more matching lenses exist.\n\nIf the condition v_abs_diff > p_mountain_threshold is false, the procedure evaluates another condition: whether v_avg_group1 is greater than v_avg_group2. If true, it performs a DELETE operation on the photos table, removing up to two records. The deletion targets rows where photos.camera_lens_id corresponds to lenses from camera_lens with brand equal to p_brand_input and focal_length_mm less than or equal to p_focal_group1, and where photos.mountain_id is greater than v_avg_group1. The DELETE uses a subquery with LIMIT 2 to restrict the number of deletions.\n\nIf v_avg_group1 is not greater than v_avg_group2 (i.e., v_avg_group2 is greater than or equal to v_avg_group1), the procedure performs a different DELETE operation. This deletion removes up to three records from the photos table where photos.camera_lens_id corresponds to lenses from camera_lens with brand equal to p_brand_input and focal_length_mm greater than p_focal_group2, and where photos.color is either 'RBG' or 'Black/White', and photos.mountain_id is less than either v_avg_group2 or p_mountain_threshold (whichever is smaller, using a LEAST function). The DELETE uses a subquery with LIMIT 3 to restrict the number of deletions.\n\nThe procedure includes error handling for cases like division by zero or null values, but these are not explicitly required in the description. It does not return any value; all operations are performed as side effects on the database tables."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_lens_focal_ranges` that accepts four input parameters: `p_threshold1` of type `real`, `p_threshold2` of type `real`, `p_brand_pattern` of type `text`, and `p_mountain_limit` of type `integer`. The procedure first declares two local variables: `v_lens_count` of type `integer` and `v_total_photos` of type `integer`. It then executes a `SELECT` statement to calculate two values: the total count of distinct `camera_lens` records that match a specified brand pattern, and the sum of photo counts associated with those lenses. This `SELECT` statement involves a subquery named `lens_stats`. The subquery selects the `id` from the `\"camera_lens\"` table and counts the number of associated photos from the `\"photos\"` table for each lens. It performs a `LEFT JOIN` between `\"camera_lens\"` (aliased as `cl`) and `\"photos\"` (aliased as `p`) on the condition `cl.\"id\" = p.\"camera_lens_id\"`. The subquery filters `camera_lens` records where the `brand` column matches the `p_brand_pattern` using the `LIKE` operator. The results of the subquery are grouped by `cl.\"id\"`. The outer `SELECT` statement then counts the number of rows returned by the `lens_stats` subquery, storing this count into `v_lens_count`. It also calculates the sum of the `photo_count` column from the `lens_stats` subquery, using `COALESCE` to default to `0` if the sum is `NULL`, and stores this sum into `v_total_photos`.\n\nFollowing this initial data retrieval, the procedure enters a conditional block.\n\nIf `v_lens_count` is greater than `p_mountain_limit`, the procedure executes a `DELETE` statement. This `DELETE` statement removes records from the `\"photos\"` table where the `mountain_id` column is greater than `p_mountain_limit` AND the `camera_lens_id` is present in a subquery's result set. The subquery selects the `id` from the `\"camera_lens\"` table where the `focal_length_mm` column is less than `p_threshold1`.\n\nOtherwise, if the previous condition is false and `v_total_photos` is less than `100`, the procedure executes an `INSERT` statement. This `INSERT` statement adds up to 5 new records into the `\"photos\"` table, populating the `id`, `camera_lens_id`, `mountain_id`, `color`, and `name` columns. The values for these columns are derived from a `SELECT` statement that retrieves data from the `\"camera_lens\"` table (aliased as `cl`) where `cl.\"focal_length_mm\"` is between `p_threshold1` and `p_threshold2` (inclusive).\n    - For the `id` column, a random integer is generated by `FLOOR(RANDOM() * 1000000)` and cast to `integer`, then `row_number() OVER ()` is added to it, and the final result is cast to `integer`.\n    - For the `camera_lens_id` column, `cl.\"id\"` is used.\n    - For the `mountain_id` column, a subquery is used to select a random `mountain_id` from existing photos. This subquery first selects a `mountain_id` from the `\"photos\"` table where `mountain_id` is not `NULL`, then uses `LIMIT 1` and `OFFSET` with a randomly generated offset. The offset is calculated by `FLOOR(RANDOM() * (SELECT COUNT(*) FROM (SELECT DISTINCT \"mountain_id\" FROM \"photos\" WHERE \"mountain_id\" IS NOT NULL) AS valid_mountains))`, ensuring a valid random offset within the distinct non-null `mountain_id` count.\n    - For the `color` column, a `CASE` statement is used: if `cl.\"id\"` is even (i.e., `MOD(cl.\"id\", 2) = 0`), the value is 'RGB'; otherwise, it's 'Black/White'.\n    - For the `name` column, a concatenated string 'Auto-generated ' followed by `cl.\"brand\"` is used.\nThe `SELECT` statement is limited to `5` rows.\n\nOtherwise (if neither of the previous conditions is met), the procedure executes a `DELETE` statement. This `DELETE` statement removes records from the `\"photos\"` table where the `id` is present in a subquery's result set. The subquery selects the `id` from the `\"photos\"` table (aliased as `p`) by performing an `INNER JOIN` with the `\"camera_lens\"` table (aliased as `cl`) on the condition `p.\"camera_lens_id\" = cl.\"id\"`. This subquery filters records where `cl.\"focal_length_mm\"` is greater than `p_threshold2` AND `p.\"mountain_id\"` is less than `p_mountain_limit`. The results are ordered by `p.\"id\"` and limited to `10` records.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_lens_focal_ranges(p_threshold1 real, p_threshold2 real, p_brand_pattern text, p_mountain_limit integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lens_count integer;\n    v_total_photos integer;\nBEGIN\n    SELECT COUNT(*), COALESCE(SUM(photo_count), 0)\n    INTO v_lens_count, v_total_photos\n    FROM (\n        SELECT cl.\"id\", COUNT(p.\"id\") as photo_count\n        FROM \"camera_lens\" cl\n        LEFT JOIN \"photos\" p ON cl.\"id\" = p.\"camera_lens_id\"\n        WHERE cl.\"brand\" LIKE p_brand_pattern\n        GROUP BY cl.\"id\"\n    ) lens_stats;\n    \n    IF v_lens_count > p_mountain_limit THEN\n        DELETE FROM \"photos\"\n        WHERE \"mountain_id\" > p_mountain_limit\n        AND \"camera_lens_id\" IN (\n            SELECT \"id\" FROM \"camera_lens\" \n            WHERE \"focal_length_mm\" < p_threshold1\n        );\n    ELSIF v_total_photos < 100 THEN\n        INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n        SELECT \n            (FLOOR(RANDOM() * 1000000)::integer + row_number() OVER ())::integer,\n            cl.\"id\",\n            (SELECT \"mountain_id\" FROM \"photos\" WHERE \"mountain_id\" IS NOT NULL LIMIT 1 OFFSET FLOOR(RANDOM() * (SELECT COUNT(*) FROM (SELECT DISTINCT \"mountain_id\" FROM \"photos\" WHERE \"mountain_id\" IS NOT NULL) AS valid_mountains))),\n            CASE WHEN MOD(cl.\"id\", 2) = 0 THEN 'RGB' ELSE 'Black/White' END,\n            'Auto-generated ' || cl.\"brand\"\n        FROM \"camera_lens\" cl\n        WHERE cl.\"focal_length_mm\" BETWEEN p_threshold1 AND p_threshold2\n        LIMIT 5;\n    ELSE\n        DELETE FROM \"photos\"\n        WHERE \"id\" IN (\n            SELECT p.\"id\"\n            FROM \"photos\" p\n            INNER JOIN \"camera_lens\" cl ON p.\"camera_lens_id\" = cl.\"id\"\n            WHERE cl.\"focal_length_mm\" > p_threshold2\n            AND p.\"mountain_id\" < p_mountain_limit\n            ORDER BY p.\"id\"\n            LIMIT 10\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "photos"
    ],
    "call_sqls": [
      "CALL process_lens_focal_ranges(35.0, 200.0, 'Olympus%', 50);",
      "CALL process_lens_focal_ranges(20.0, 100.0, 'Nikon%', 30);",
      "CALL process_lens_focal_ranges(10.0, 300.0, 'Canon%', 100);",
      "CALL process_lens_focal_ranges(50.0, 150.0, 'Sony%', 25);",
      "CALL process_lens_focal_ranges(24.0, 70.0, 'Sigma%', 75);"
    ],
    "summary": "Create a stored procedure named process_lens_focal_ranges that accepts four parameters: p_threshold1 (real), p_threshold2 (real), p_brand_pattern (text), and p_mountain_limit (integer). Count the distinct lenses matching the brand pattern and sum their associated photo counts. If the lens count exceeds the mountain limit, delete photos where mountain_id is greater than the limit and the lens's focal length is below threshold1. Else, if the total photo count is below 100, insert up to 5 new photo records for lenses with focal lengths between the two thresholds, generating random IDs, random existing mountain_ids, and color based on lens ID parity. Otherwise, delete the first 10 photos where the lens's focal length exceeds threshold2 and the mountain_id is below the mountain limit.",
    "natural_language": "Alright, so we need a stored procedure called process_lens_focal_ranges. It's gotta take four inputs: p_threshold1 (a real number), p_threshold2 (another real number), p_brand_pattern (some text), and p_mountain_limit (an integer). Here's the deal: first, count how many different lenses fit that brand pattern and add up all their photo counts. If that lens count is bigger than the mountain limit, then get rid of any photos where the mountain_id is over the limit and the lens's focal length is less than threshold1. If that's not the case, but the total photo count is under 100, then we need to add up to 5 new photo entries for lenses whose focal lengths are between those two thresholds. For these new ones, just make up random IDs, pick random mountain_ids that already exist, and set the color based on whether the lens ID is even or odd. Otherwise, if none of the above fits, just delete the first 10 photos where the lens's focal length is above threshold2 and the mountain_id is below the mountain limit.",
    "id": 40,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_lens_focal_ranges` that accepts four input parameters: `p_threshold1` of type `real`, `p_threshold2` of type `real`, `p_brand_pattern` of type `text`, and `p_mountain_limit` of type `integer`. The procedure first declares two local variables: `v_lens_count` of type `integer` and `v_total_photos` of type `integer`. It then executes a `SELECT` statement to calculate two values: the total count of distinct `camera_lens` records that match a specified brand pattern, and the sum of photo counts associated with those lenses. This `SELECT` statement involves a subquery named `lens_stats`. The subquery selects the `id` from the `\"camera_lens\"` table and counts the number of associated photos from the `\"photos\"` table for each lens. It performs a `LEFT JOIN` between `\"camera_lens\"` (aliased as `cl`) and `\"photos\"` (aliased as `p`) on the condition `cl.\"id\" = p.\"camera_lens_id\"`. The subquery filters `camera_lens` records where the `brand` column matches the `p_brand_pattern` using the `LIKE` operator. The results of the subquery are grouped by `cl.\"id\"`. The outer `SELECT` statement then counts the number of rows returned by the `lens_stats` subquery, storing this count into `v_lens_count`. It also calculates the sum of the `photo_count` column from the `lens_stats` subquery, using `COALESCE` to default to `0` if the sum is `NULL`, and stores this sum into `v_total_photos`.\n\nFollowing this initial data retrieval, the procedure enters a conditional block.\n\nIf `v_lens_count` is greater than `p_mountain_limit`, the procedure executes a `DELETE` statement. This `DELETE` statement removes records from the `\"photos\"` table where the `mountain_id` column is greater than `p_mountain_limit` AND the `camera_lens_id` is present in a subquery's result set. The subquery selects the `id` from the `\"camera_lens\"` table where the `focal_length_mm` column is less than `p_threshold1`.\n\nOtherwise, if the previous condition is false and `v_total_photos` is less than `100`, the procedure executes an `INSERT` statement. This `INSERT` statement adds up to 5 new records into the `\"photos\"` table, populating the `id`, `camera_lens_id`, `mountain_id`, `color`, and `name` columns. The values for these columns are derived from a `SELECT` statement that retrieves data from the `\"camera_lens\"` table (aliased as `cl`) where `cl.\"focal_length_mm\"` is between `p_threshold1` and `p_threshold2` (inclusive).\n    - For the `id` column, a random integer is generated by `FLOOR(RANDOM() * 1000000)` and cast to `integer`, then `row_number() OVER ()` is added to it, and the final result is cast to `integer`.\n    - For the `camera_lens_id` column, `cl.\"id\"` is used.\n    - For the `mountain_id` column, a subquery is used to select a random `mountain_id` from existing photos. This subquery first selects a `mountain_id` from the `\"photos\"` table where `mountain_id` is not `NULL`, then uses `LIMIT 1` and `OFFSET` with a randomly generated offset. The offset is calculated by `FLOOR(RANDOM() * (SELECT COUNT(*) FROM (SELECT DISTINCT \"mountain_id\" FROM \"photos\" WHERE \"mountain_id\" IS NOT NULL) AS valid_mountains))`, ensuring a valid random offset within the distinct non-null `mountain_id` count.\n    - For the `color` column, a `CASE` statement is used: if `cl.\"id\"` is even (i.e., `MOD(cl.\"id\", 2) = 0`), the value is 'RGB'; otherwise, it's 'Black/White'.\n    - For the `name` column, a concatenated string 'Auto-generated ' followed by `cl.\"brand\"` is used.\nThe `SELECT` statement is limited to `5` rows.\n\nOtherwise (if neither of the previous conditions is met), the procedure executes a `DELETE` statement. This `DELETE` statement removes records from the `\"photos\"` table where the `id` is present in a subquery's result set. The subquery selects the `id` from the `\"photos\"` table (aliased as `p`) by performing an `INNER JOIN` with the `\"camera_lens\"` table (aliased as `cl`) on the condition `p.\"camera_lens_id\" = cl.\"id\"`. This subquery filters records where `cl.\"focal_length_mm\"` is greater than `p_threshold2` AND `p.\"mountain_id\"` is less than `p_mountain_limit`. The results are ordered by `p.\"id\"` and limited to `10` records."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named analyze_market_segments that accepts three input parameters: a text parameter p_wealth_tier to specify a wealth classification, a text parameter p_market_action to specify a market operation, and a real number parameter p_adjustment_rate to specify a rate for financial adjustments. The procedure first declares local variables v_tier_boundary of type REAL, v_singer_id of type INTEGER, v_net_worth of type REAL, and v_total_song_sales of type REAL. If the p_wealth_tier parameter is equal to the string 'premium', the procedure sets v_tier_boundary to 25.0, then enters a loop that iterates over each row from the singer table where the Net_Worth_Millions column is greater than or equal to v_tier_boundary, fetching the Singer_ID and Net_Worth_Millions values into the v_singer_id and v_net_worth variables. For each singer in this loop, it calculates the total song sales by selecting the sum of the Sales column from the song table for rows where the Singer_ID matches the current v_singer_id, storing the result in v_total_song_sales and using the COALESCE function to return 0 if the sum is null. If v_total_song_sales is greater than 1,500,000, it updates the singer table by multiplying the Net_Worth_Millions column by (1 + p_adjustment_rate) for the current v_singer_id. If v_total_song_sales is greater than 800,000 but not greater than 1,500,000, it updates the Net_Worth_Millions column by multiplying it by (1 + p_adjustment_rate * 0.7). If v_total_song_sales is 800,000 or less, it updates the Net_Worth_Millions column by multiplying it by (1 + p_adjustment_rate * 0.4). If the p_wealth_tier parameter is equal to the string 'standard', the procedure sets v_tier_boundary to 25.0, then enters a loop that iterates over each row from the singer table where the Net_Worth_Millions column is less than v_tier_boundary, fetching the Singer_ID and Net_Worth_Millions values. For each singer in this loop, if the p_market_action parameter is equal to the string 'expand', it inserts a new row into the song table with Song_ID set to v_singer_id + 3000, Title set to 'Market Expansion Hit', Singer_ID set to v_singer_id, Sales set to 500000, and Highest_Position set to 5. If p_market_action is not 'expand', it updates the song table by multiplying the Sales column by (1 - p_adjustment_rate * 0.2) for all rows where the Singer_ID matches the current v_singer_id. If the p_wealth_tier parameter is neither 'premium' nor 'standard', the procedure deletes rows from the song table where the Singer_ID is found in the result of a subquery that selects the Singer_ID from the singer table where the Net_Worth_Millions column is less than 20.0.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_market_segments(\n    p_wealth_tier TEXT,\n    p_market_action TEXT,\n    p_adjustment_rate REAL\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_tier_boundary REAL;\n    v_singer_id INTEGER;\n    v_net_worth REAL;\n    v_total_song_sales REAL;\nBEGIN\n    IF p_wealth_tier = 'premium' THEN\n        v_tier_boundary := 25.0;\n        \n        FOR v_singer_id, v_net_worth IN \n            SELECT \"Singer_ID\", \"Net_Worth_Millions\" \n            FROM singer \n            WHERE \"Net_Worth_Millions\" >= v_tier_boundary\n        LOOP\n            SELECT COALESCE(SUM(\"Sales\"), 0) INTO v_total_song_sales\n            FROM song WHERE \"Singer_ID\" = v_singer_id;\n            \n            IF v_total_song_sales > 1500000 THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * (1 + p_adjustment_rate)\n                WHERE \"Singer_ID\" = v_singer_id;\n            ELSIF v_total_song_sales > 800000 THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * (1 + p_adjustment_rate * 0.7)\n                WHERE \"Singer_ID\" = v_singer_id;\n            ELSE\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" * (1 + p_adjustment_rate * 0.4)\n                WHERE \"Singer_ID\" = v_singer_id;\n            END IF;\n        END LOOP;\n    ELSIF p_wealth_tier = 'standard' THEN\n        v_tier_boundary := 25.0;\n        \n        FOR v_singer_id, v_net_worth IN \n            SELECT \"Singer_ID\", \"Net_Worth_Millions\" \n            FROM singer \n            WHERE \"Net_Worth_Millions\" < v_tier_boundary\n        LOOP\n            IF p_market_action = 'expand' THEN\n                INSERT INTO song (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n                VALUES (v_singer_id + 3000, 'Market Expansion Hit', v_singer_id, 500000, 5);\n            ELSE\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * (1 - p_adjustment_rate * 0.2)\n                WHERE \"Singer_ID\" = v_singer_id;\n            END IF;\n        END LOOP;\n    ELSE\n        DELETE FROM song \n        WHERE \"Singer_ID\" IN (\n            SELECT \"Singer_ID\" \n            FROM singer \n            WHERE \"Net_Worth_Millions\" < 20.0\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL analyze_market_segments('premium', 'adjust', 0.05);",
      "CALL analyze_market_segments('standard', 'expand', 0.02);",
      "CALL analyze_market_segments('premium', 'rebalance', -0.03);",
      "CALL analyze_market_segments('standard', 'contract', 0.01);",
      "CALL analyze_market_segments('unknown', 'cleanup', 0.0);"
    ],
    "summary": "Create a stored procedure named analyze_market_segments with parameters p_wealth_tier (TEXT), p_market_action (TEXT), and p_adjustment_rate (REAL). For 'premium' tier singers (net worth >= 25.0), adjust their net worth based on their total song sales using the adjustment rate. For 'standard' tier singers (net worth < 25.0), if the action is 'expand', insert a new market expansion song; otherwise, decrease their song sales. For any other tier, delete songs for singers with net worth below 20.0.",
    "natural_language": "Alright, so we need a stored procedure called analyze_market_segments. It's gonna take three things: p_wealth_tier (that's TEXT), p_market_action (also TEXT), and p_adjustment_rate (a REAL number). Here's the deal: for the big-shot 'premium' tier singersyou know, the ones rolling in dough with a net worth of 25.0 or morewe're gonna tweak their net worth. How? We'll use that adjustment rate on their total song sales. Now, for the 'standard' tier folks (net worth under 25.0), if the action is 'expand', we gotta add a brand new market expansion song for them. If it's not 'expand', then we're cutting their song sales down a bit. And for any other tier that doesn't fit those two? Well, if a singer's net worth is below 20.0, we're just gonna delete their songs.",
    "id": 41,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named analyze_market_segments that accepts three input parameters: a text parameter p_wealth_tier to specify a wealth classification, a text parameter p_market_action to specify a market operation, and a real number parameter p_adjustment_rate to specify a rate for financial adjustments. The procedure first declares local variables v_tier_boundary of type REAL, v_singer_id of type INTEGER, v_net_worth of type REAL, and v_total_song_sales of type REAL. If the p_wealth_tier parameter is equal to the string 'premium', the procedure sets v_tier_boundary to 25.0, then enters a loop that iterates over each row from the singer table where the Net_Worth_Millions column is greater than or equal to v_tier_boundary, fetching the Singer_ID and Net_Worth_Millions values into the v_singer_id and v_net_worth variables. For each singer in this loop, it calculates the total song sales by selecting the sum of the Sales column from the song table for rows where the Singer_ID matches the current v_singer_id, storing the result in v_total_song_sales and using the COALESCE function to return 0 if the sum is null. If v_total_song_sales is greater than 1,500,000, it updates the singer table by multiplying the Net_Worth_Millions column by (1 + p_adjustment_rate) for the current v_singer_id. If v_total_song_sales is greater than 800,000 but not greater than 1,500,000, it updates the Net_Worth_Millions column by multiplying it by (1 + p_adjustment_rate * 0.7). If v_total_song_sales is 800,000 or less, it updates the Net_Worth_Millions column by multiplying it by (1 + p_adjustment_rate * 0.4). If the p_wealth_tier parameter is equal to the string 'standard', the procedure sets v_tier_boundary to 25.0, then enters a loop that iterates over each row from the singer table where the Net_Worth_Millions column is less than v_tier_boundary, fetching the Singer_ID and Net_Worth_Millions values. For each singer in this loop, if the p_market_action parameter is equal to the string 'expand', it inserts a new row into the song table with Song_ID set to v_singer_id + 3000, Title set to 'Market Expansion Hit', Singer_ID set to v_singer_id, Sales set to 500000, and Highest_Position set to 5. If p_market_action is not 'expand', it updates the song table by multiplying the Sales column by (1 - p_adjustment_rate * 0.2) for all rows where the Singer_ID matches the current v_singer_id. If the p_wealth_tier parameter is neither 'premium' nor 'standard', the procedure deletes rows from the song table where the Singer_ID is found in the result of a subquery that selects the Singer_ID from the singer table where the Net_Worth_Millions column is less than 20.0."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three parameters: p_singer_id of type integer, p_multiplier of type real, and p_citizenship of type text. The procedure begins by declaring a variable v_total_sales of type real. It then performs a SELECT operation to calculate the sum of the \"Sales\" column from the \"song\" table, filtering rows where the \"Singer_ID\" column matches the value of p_singer_id, and stores the result into the v_total_sales variable. If v_total_sales is not NULL, the procedure proceeds to execute an UPDATE operation on the \"singer\" table. This update sets the \"Net_Worth_Millions\" column to the product of v_total_sales and p_multiplier for rows where the \"Singer_ID\" column equals p_singer_id and the \"Citizenship\" column matches the value of p_citizenship. The procedure does not perform any operations if v_total_sales is NULL.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_net_worth_based_on_sales(p_singer_id integer, p_multiplier real, p_citizenship text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_sales real;\nBEGIN\n    SELECT SUM(\"Sales\") INTO v_total_sales FROM \"song\" WHERE \"Singer_ID\" = p_singer_id;\n    IF v_total_sales IS NOT NULL THEN\n        UPDATE \"singer\" \n        SET \"Net_Worth_Millions\" = v_total_sales * p_multiplier \n        WHERE \"Singer_ID\" = p_singer_id \n        AND \"Citizenship\" = p_citizenship;\n    END IF;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL update_net_worth_based_on_sales(1, 0.001, 'France');",
      "CALL update_net_worth_based_on_sales(2, 0.002, 'United States');",
      "CALL update_net_worth_based_on_sales(3, 0.0015, 'United States');",
      "CALL update_net_worth_based_on_sales(1, 0.0005, 'France');",
      "CALL update_net_worth_based_on_sales(2, 0.003, 'United States');"
    ],
    "summary": "Create a stored procedure that calculates the total sales for a given singer_id. If the total is not null, update the singer's Net_Worth_Millions by multiplying the total sales with a provided multiplier, but only for singers with a matching citizenship.",
    "natural_language": "Please construct a stored procedure to compute the aggregate sales figure for a specified singer identifier. Should the computed total be non-null, proceed to update the singer's Net_Worth_Millions by applying the supplied multiplier to the total sales value, contingent upon the singer possessing the corresponding citizenship.",
    "id": 42,
    "generated_ir": "Write a PLpgSQL stored procedure that takes three parameters: p_singer_id of type integer, p_multiplier of type real, and p_citizenship of type text. The procedure begins by declaring a variable v_total_sales of type real. It then performs a SELECT operation to calculate the sum of the \"Sales\" column from the \"song\" table, filtering rows where the \"Singer_ID\" column matches the value of p_singer_id, and stores the result into the v_total_sales variable. If v_total_sales is not NULL, the procedure proceeds to execute an UPDATE operation on the \"singer\" table. This update sets the \"Net_Worth_Millions\" column to the product of v_total_sales and p_multiplier for rows where the \"Singer_ID\" column equals p_singer_id and the \"Citizenship\" column matches the value of p_citizenship. The procedure does not perform any operations if v_total_sales is NULL."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `delete_songs_by_sales` that accepts three input parameters: `p_singer_id` of type `integer`, `p_sales_threshold` of type `real`, and `p_citizenship` of type `text`. This procedure performs a `DELETE` operation on the `song` table. The deletion targets rows in the `song` table where the value in the `Singer_ID` column exactly matches the value provided in the `p_singer_id` parameter, AND the value in the `Sales` column is strictly less than the value provided in the `p_sales_threshold` parameter, AND there exists at least one corresponding row in the `singer` table. The existence check for the `singer` table is performed by a subquery that verifies two conditions simultaneously: the `Singer_ID` column in the `singer` table must exactly match the value provided in the `p_singer_id` parameter, AND the `Citizenship` column in the `singer` table must exactly match the value provided in the `p_citizenship` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_songs_by_sales(p_singer_id integer, p_sales_threshold real, p_citizenship text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"song\" \n    WHERE \"Singer_ID\" = p_singer_id \n    AND \"Sales\" < p_sales_threshold \n    AND EXISTS (SELECT 1 FROM \"singer\" WHERE \"Singer_ID\" = p_singer_id AND \"Citizenship\" = p_citizenship);\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL delete_songs_by_sales(1, 500000.0, 'France');",
      "CALL delete_songs_by_sales(2, 1000000.0, 'United States');",
      "CALL delete_songs_by_sales(1, 100000.0, 'France');",
      "CALL delete_songs_by_sales(3, 200000.0, 'United States');",
      "CALL delete_songs_by_sales(2, 700000.0, 'United States');"
    ],
    "summary": "Create a stored procedure named delete_songs_by_sales that deletes songs from the song table for a specified singer_id where sales are below a threshold, only if a singer with that ID and a matching citizenship exists.",
    "natural_language": "Please construct a stored procedure designated as 'delete_songs_by_sales'. This procedure shall remove records from the song table for a provided singer identifier, contingent upon the condition that the associated sales figures are beneath a specified threshold. The deletion operation must be executed only if a singer possessing the given identifier and a corresponding citizenship entry exists within the relevant table.",
    "id": 43,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `delete_songs_by_sales` that accepts three input parameters: `p_singer_id` of type `integer`, `p_sales_threshold` of type `real`, and `p_citizenship` of type `text`. This procedure performs a `DELETE` operation on the `song` table. The deletion targets rows in the `song` table where the value in the `Singer_ID` column exactly matches the value provided in the `p_singer_id` parameter, AND the value in the `Sales` column is strictly less than the value provided in the `p_sales_threshold` parameter, AND there exists at least one corresponding row in the `singer` table. The existence check for the `singer` table is performed by a subquery that verifies two conditions simultaneously: the `Singer_ID` column in the `singer` table must exactly match the value provided in the `p_singer_id` parameter, AND the `Citizenship` column in the `singer` table must exactly match the value provided in the `p_citizenship` parameter."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `adjust_writer_episodes` that accepts two input parameters: `p_wid`, an integer representing a writer's unique identifier, and `p_adjustment`, an integer representing an adjustment value for the number of episodes. The procedure begins by declaring two local variables: `v_current_episodes`, an integer to store the current number of episodes for a writer, and `v_mod_check`, an integer to store the result of a modulo operation. It then retrieves the value from the `num_of_episodes` column for the row in the `writer` table where the `wid` column matches the input parameter `p_wid`, and stores this retrieved value into the `v_current_episodes` variable. Subsequently, it calculates the remainder of `p_wid` divided by 3 using the `mod` function and assigns this result to the `v_mod_check` variable. Following this, the procedure executes a conditional block based on the value of `v_mod_check`. If `v_mod_check` is equal to 0, it attempts to insert a new row into the `writer` table with the following values: `p_wid` for the `wid` column, the string literal 'adjusted' for the `gender` column, the integer 0 for the `name` column, the integer 0 for the `nationality` column, `p_adjustment` for the `num_of_episodes` column, an empty string '' for the `birth_city` column, and the integer 0 for the `birth_year` column. If a row with the same `wid` already exists (due to a unique constraint on the `wid` column), it instead updates the existing row by adding the value of `p_adjustment` to the current value of the `num_of_episodes` column in that row. If `v_mod_check` is equal to 1, it deletes all rows from the `written_by` table where the `wid` column matches the input parameter `p_wid`. If `v_mod_check` is neither 0 nor 1 (i.e., it is 2), it inserts a new row into the `genre` table with the value of `p_wid` for the `gid` column and the string literal 'auto-generated' for the `genre` column.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_writer_episodes(p_wid integer, p_adjustment integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_episodes integer;\n    v_mod_check integer;\nBEGIN\n    SELECT \"num_of_episodes\" INTO v_current_episodes FROM writer WHERE \"wid\" = p_wid;\n    v_mod_check := mod(p_wid, 3);\n    \n    IF v_mod_check = 0 THEN\n        INSERT INTO writer (\"wid\", \"gender\", \"name\", \"nationality\", \"num_of_episodes\", \"birth_city\", \"birth_year\")\n        VALUES (p_wid, 'adjusted', 0, 0, p_adjustment, '', 0)\n        ON CONFLICT (\"wid\") DO UPDATE SET \"num_of_episodes\" = writer.\"num_of_episodes\" + p_adjustment;\n    ELSIF v_mod_check = 1 THEN\n        DELETE FROM written_by WHERE \"wid\" = p_wid;\n    ELSE\n        INSERT INTO genre (\"gid\", \"genre\") VALUES (p_wid, 'auto-generated');\n    END IF;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "CALL adjust_writer_episodes(3, 10);",
      "CALL adjust_writer_episodes(1, 5);",
      "CALL adjust_writer_episodes(2, 20);",
      "CALL adjust_writer_episodes(6, -5);",
      "CALL adjust_writer_episodes(4, 15);"
    ],
    "summary": "Create a stored procedure named adjust_writer_episodes that accepts a writer ID and an episode adjustment value. Get the writer's current episode count. Calculate the writer ID modulo 3. If the result is 0, insert a new writer record with the given ID and adjustment value, or update the existing writer's episode count by adding the adjustment if the ID already exists. If the result is 1, delete all records for that writer from the written_by table. If the result is 2, insert a new genre record with the writer ID and 'auto-generated' as the genre name.",
    "natural_language": "Make a stored procedure called adjust_writer_episodes that takes a writer ID and a number to adjust episodes by. First, find out how many episodes the writer currently has. Then, do a calculation with the writer ID and the number 3. If that calculation gives a certain result, just add the new adjustment to the writer's total if they're already there, or put them in if they're not. If the calculation gives a different result, clean out any mentions of that writer from the written_by list. For another possible result of the calculation, add a new genre entry for that writer with a standard made-up name.",
    "id": 44,
    "generated_ir": "Write a PLpgSQL stored procedure named `adjust_writer_episodes` that accepts two input parameters: `p_wid`, an integer representing a writer's unique identifier, and `p_adjustment`, an integer representing an adjustment value for the number of episodes. The procedure begins by declaring two local variables: `v_current_episodes`, an integer to store the current number of episodes for a writer, and `v_mod_check`, an integer to store the result of a modulo operation. It then retrieves the value from the `num_of_episodes` column for the row in the `writer` table where the `wid` column matches the input parameter `p_wid`, and stores this retrieved value into the `v_current_episodes` variable. Subsequently, it calculates the remainder of `p_wid` divided by 3 using the `mod` function and assigns this result to the `v_mod_check` variable. Following this, the procedure executes a conditional block based on the value of `v_mod_check`. If `v_mod_check` is equal to 0, it attempts to insert a new row into the `writer` table with the following values: `p_wid` for the `wid` column, the string literal 'adjusted' for the `gender` column, the integer 0 for the `name` column, the integer 0 for the `nationality` column, `p_adjustment` for the `num_of_episodes` column, an empty string '' for the `birth_city` column, and the integer 0 for the `birth_year` column. If a row with the same `wid` already exists (due to a unique constraint on the `wid` column), it instead updates the existing row by adding the value of `p_adjustment` to the current value of the `num_of_episodes` column in that row. If `v_mod_check` is equal to 1, it deletes all rows from the `written_by` table where the `wid` column matches the input parameter `p_wid`. If `v_mod_check` is neither 0 nor 1 (i.e., it is 2), it inserts a new row into the `genre` table with the value of `p_wid` for the `gid` column and the string literal 'auto-generated' for the `genre` column."
  },
  {
    "ir": "Write a PostgreSQL stored procedure named `delete_old_service_records` that accepts five input parameters: `p_cutoff_date` of type `TIMESTAMP WITH TIME ZONE`, `p_min_property_id` of type `BIGINT`, `p_max_property_id` of type `BIGINT`, `p_resident_threshold` of type `BIGINT`, and `p_service_pattern` of type `TEXT`. The purpose of this procedure is to remove records from the `\"Residents_Services\"` table. The deletion operation targets rows where the value in the `\"date_provided\"` column is strictly earlier than the `p_cutoff_date` parameter. Additionally, the deletion is constrained by the `\"property_id\"` column, which must have a value inclusively between `p_min_property_id` and `p_max_property_id`. A further condition for deletion is that the `\"resident_id\"` column must contain a value strictly greater than `p_resident_threshold`. Finally, the deletion applies only to rows where the `\"other_details\"` column contains the `p_service_pattern` string as a substring, with the search being case-insensitive due to the use of the `ILIKE` operator, which is constructed by concatenating a '%' wildcard character before and after the `p_service_pattern` to match any occurrence of the pattern within the column's text.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_service_records(\n    IN p_cutoff_date TIMESTAMP WITH TIME ZONE,\n    IN p_min_property_id BIGINT,\n    IN p_max_property_id BIGINT,\n    IN p_resident_threshold BIGINT,\n    IN p_service_pattern TEXT\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Residents_Services\"\n    WHERE \"date_provided\" < p_cutoff_date\n    AND \"property_id\" BETWEEN p_min_property_id AND p_max_property_id\n    AND \"resident_id\" > p_resident_threshold\n    AND \"other_details\" ILIKE '%' || p_service_pattern || '%';\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Residents_Services"
    ],
    "call_sqls": [
      "CALL delete_old_service_records('2017-01-01 00:00:00+08:00', 1, 1000, 0, 'Satisfied');",
      "CALL delete_old_service_records('2018-01-01 00:00:00+08:00', 500, 900, 10, 'Unsatisfied');",
      "CALL delete_old_service_records('2017-06-01 00:00:00+08:00', 600, 700, 20, 'repair');",
      "CALL delete_old_service_records('2016-01-01 00:00:00+08:00', 100, 500, 5, 'cleaning');",
      "CALL delete_old_service_records('2019-01-01 00:00:00+08:00', 800, 999, 30, 'maintenance');"
    ],
    "summary": "Create a stored procedure named delete_old_service_records with parameters p_cutoff_date (TIMESTAMPTZ), p_min_property_id (BIGINT), p_max_property_id (BIGINT), p_resident_threshold (BIGINT), and p_service_pattern (TEXT). Delete records from the Residents_Services table where the service date is before the cutoff, the property ID is within the specified range, the resident ID is above the threshold, and the other details contain the given pattern (case-insensitive).",
    "natural_language": "Create procedure delete_old_service_records with parameters p_cutoff_date TIMESTAMPTZ, p_min_property_id BIGINT, p_max_property_id BIGINT, p_resident_threshold BIGINT, p_service_pattern TEXT. Delete from Residents_Services where service date < cutoff, property ID between min and max, resident ID > threshold, and other details contain pattern case-insensitively.",
    "id": 45,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named delete_old_service_records that accepts five input parameters: p_cutoff_date of type TIMESTAMPTZ to specify a cutoff date, p_min_property_id of type BIGINT to set the lower bound for property IDs, p_max_property_id of type BIGINT to set the upper bound for property IDs, p_resident_threshold of type BIGINT to set a minimum resident ID threshold, and p_service_pattern of type TEXT to provide a pattern for matching other details. The procedure does not declare any local variables. It performs a single DELETE operation on the Residents_Services table. The deletion condition includes multiple criteria combined with AND logic: first, the date_provided column must be less than the input p_cutoff_date; second, the property_id column must be greater than or equal to p_min_property_id and less than or equal to p_max_property_id; third, the resident_id column must be greater than p_resident_threshold; fourth, the other_details column must contain the substring specified by p_service_pattern in a case-insensitive manner, which is implemented using the ILIKE operator with the pattern '%' concatenated with p_service_pattern concatenated with '%'. The procedure does not return a value; it simply executes the deletion."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `establish_new_church` that accepts three input parameters: `p_name` of type `text`, representing the name of the new church; `p_organizer` of type `text`, representing the entity or individual who organized the church; and `p_open_year` of type `integer`, representing the year the church was opened. The procedure first declares a local variable `v_church_id` of type `integer`. It then calculates the value for `v_church_id` by executing a `SELECT` statement on the `church` table. This `SELECT` statement retrieves the maximum value from the `\"Church_ID\"` column. The `COALESCE` function is applied to this maximum value, ensuring that if no rows exist in the `church` table or if `\"Church_ID\"` is `NULL` for all rows, `0` is used instead of `NULL`. This result is then incremented by `1` to generate a new, unique identifier for the church. Following this, the procedure performs an `INSERT` operation into the `church` table. The `INSERT` statement populates the columns `\"Church_ID\"`, `\"Name\"`, `\"Organized_by\"`, and `\"Open_Date\"`. The value for `\"Church_ID\"` is taken from the previously calculated `v_church_id`. The value for `\"Name\"` is taken from the input parameter `p_name`. The value for `\"Organized_by\"` is taken from the input parameter `p_organizer`. The value for `\"Open_Date\"` is taken from the input parameter `p_open_year`.",
    "plsql": "CREATE OR REPLACE PROCEDURE establish_new_church(p_name text, p_organizer text, p_open_year integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_church_id integer;\nBEGIN\n    v_church_id := (SELECT COALESCE(MAX(\"Church_ID\"), 0) + 1 FROM church);\n    \n    INSERT INTO church (\"Church_ID\", \"Name\", \"Organized_by\", \"Open_Date\")\n    VALUES (v_church_id, p_name, p_organizer, p_open_year);\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL establish_new_church('New Hope Church', 'John Doe', 2023);",
      "CALL establish_new_church('Unity Church', 'Jane Smith', 2024);",
      "CALL establish_new_church('Grace Church', 'Emily Johnson', 2025);",
      "CALL establish_new_church('Faith Church', 'Michael Brown', 2026);",
      "CALL establish_new_church('Peace Church', 'Sarah Davis', 2027);"
    ],
    "summary": "Create a stored procedure named establish_new_church that inserts a new church. It takes parameters for name, organizer, and opening year. The procedure generates a new unique Church_ID by finding the maximum existing ID, defaulting to 0 if none exist, and adding 1.",
    "natural_language": "Write a stored procedure called establish_new_church to insert a new church. The procedure must accept the church's name, organizer, and opening year as parameters. It should generate a unique Church_ID by calculating the maximum existing ID (starting from 0 if no records exist) and then incrementing it by one.",
    "id": 46,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named establish_new_church that inserts a new record into the church table. The procedure accepts three input parameters: p_name of type text representing the church's name, p_organizer of type text representing the organizer's name, and p_opening_year of type integer representing the opening year. The procedure first declares a local variable v_new_church_id of type integer to hold the generated unique Church_ID. To generate this ID, the procedure queries the church table to find the maximum existing value in the Church_ID column using the MAX aggregate function. If the table is empty, the MAX function returns NULL, so the procedure uses the COALESCE function to substitute 0 as the starting value. The procedure then increments this maximum value by 1 to produce the new Church_ID and stores it in v_new_church_id. After generating the ID, the procedure performs an INSERT operation into the church table, specifying the columns Church_ID, Name, Organized_by, and Open_Date. The values inserted are v_new_church_id for Church_ID, p_name for Name, p_organizer for Organized_by, and p_opening_year for Open_Date. The Continuation_of column is not included in the INSERT statement, so it will be set to NULL by default. The procedure does not return any value; it is a void procedure that executes the insertion."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `remove_manufacturer_data` that accepts three input parameters: `p_manufacturer_code` of type `bigint`, `p_revenue_threshold` of type `real`, and `p_min_product_price` of type `numeric`. The procedure first performs a `DELETE` operation on the `\"Products\"` table. This deletion targets rows where the value in the `\"Manufacturer\"` column exactly matches the value provided in the `p_manufacturer_code` parameter AND the value in the `\"Price\"` column is greater than or equal to the value provided in the `p_min_product_price` parameter. Following this, the procedure performs a second `DELETE` operation, this time on the `\"Manufacturers\"` table. This subsequent deletion targets rows where the value in the `\"Code\"` column exactly matches the value provided in the `p_manufacturer_code` parameter AND the value in the `\"Revenue\"` column is less than or equal to the value provided in the `p_revenue_threshold` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_manufacturer_data(\n    p_manufacturer_code bigint,\n    p_revenue_threshold real,\n    p_min_product_price numeric\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Products\" WHERE \"Manufacturer\" = p_manufacturer_code AND \"Price\" >= p_min_product_price;\n    DELETE FROM \"Manufacturers\" WHERE \"Code\" = p_manufacturer_code AND \"Revenue\" <= p_revenue_threshold;\nEND;\n$$;",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "CALL remove_manufacturer_data(1, 100.0, 200);",
      "CALL remove_manufacturer_data(2, 120.0, 100);",
      "CALL remove_manufacturer_data(3, 50.0, 150);",
      "CALL remove_manufacturer_data(1, 120.0, 240);",
      "CALL remove_manufacturer_data(2, 100.0, 120);"
    ],
    "summary": "Create a stored procedure named `remove_manufacturer_data` that takes a manufacturer code (bigint), a revenue threshold (real), and a minimum product price (numeric). First, delete from the \"Products\" table where the manufacturer matches the code and the price is at least the minimum. Then, delete from the \"Manufacturers\" table where the code matches and the revenue is at most the threshold.",
    "natural_language": "Alright, so I need you to whip up a stored procedure called `remove_manufacturer_data`. It's gotta take three things: a manufacturer code (that's a bigint), a revenue cap (that's a real number), and a minimum price for products (a numeric). Here's the deal: first, go ahead and wipe out any entries in the \"Products\" table where the manufacturer code matches the one given and the product's price is at least that minimum price. After that's done, clean up the \"Manufacturers\" table by deleting any manufacturer whose code matches and whose revenue is at or below that threshold.",
    "id": 47,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named remove_manufacturer_data that accepts three input parameters: p_manufacturer_code of type BIGINT, p_revenue_cap of type REAL, and p_min_price of type NUMERIC. The procedure is designed to delete data from two tables, Products and Manufacturers, based on the provided criteria. It does not declare any local variables. The procedure executes two DELETE operations sequentially.\n\nFirst, it performs a DELETE operation on the Products table. The deletion targets rows where the Manufacturer column equals the input parameter p_manufacturer_code and the Price column is greater than or equal to the input parameter p_min_price. This operation removes all product records associated with the specified manufacturer that have a price meeting or exceeding the minimum price threshold.\n\nSecond, it performs a DELETE operation on the Manufacturers table. The deletion targets rows where the Code column equals the input parameter p_manufacturer_code and the Revenue column is less than or equal to the input parameter p_revenue_cap. This operation removes the manufacturer record itself, but only if its revenue is at or below the specified revenue cap.\n\nThe procedure executes these two DELETE statements in the order specified: first deleting qualifying products, then deleting the qualifying manufacturer. There is no explicit return value; the procedure completes after performing the deletions."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that deletes rows from the \"Boxes\" table based on specific criteria provided through its parameters. The procedure is named delete_boxes_by_criteria and accepts three parameters: p_warehouse_code of type bigint, p_min_value of type real, and p_contents_filter of type text. The procedure performs a DELETE operation on the \"Boxes\" table, targeting rows where the \"Warehouse\" column matches the value of p_warehouse_code, the \"Value\" column is greater than or equal to p_min_value, and the \"Contents\" column, when converted to lowercase using the LOWER() function, matches the lowercase version of p_contents_filter. The LOWER() function is used to ensure case-insensitive comparison of the \"Contents\" column with the p_contents_filter parameter. The procedure does not include any conditional branching or iteration, and its sole operation is the deletion of rows that meet all specified conditions.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_boxes_by_criteria(p_warehouse_code bigint, p_min_value real, p_contents_filter text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Boxes\" \n    WHERE \"Warehouse\" = p_warehouse_code \n    AND \"Value\" >= p_min_value \n    AND LOWER(\"Contents\") = LOWER(p_contents_filter);\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL delete_boxes_by_criteria(1, 200.0, 'Rocks');",
      "CALL delete_boxes_by_criteria(3, 180.0, 'Scissors');",
      "CALL delete_boxes_by_criteria(4, 190.0, 'Rocks');",
      "CALL delete_boxes_by_criteria(1, 250.0, 'Scissors');",
      "CALL delete_boxes_by_criteria(3, 180.0, 'Rocks');"
    ],
    "summary": "Create a stored procedure named `delete_boxes_by_criteria` that deletes boxes from a specified warehouse where the box value meets a minimum and its contents match a given filter (case-insensitive).",
    "natural_language": "Write a stored procedure called `delete_boxes_by_criteria` to remove boxes from a given warehouse if the box value is at least a specified minimum and its contents match a provided filter, ignoring case.",
    "id": 48,
    "generated_ir": "Write a PLpgSQL stored procedure that deletes rows from the \"Boxes\" table based on specific criteria provided through its parameters. The procedure is named delete_boxes_by_criteria and accepts three parameters: p_warehouse_code of type bigint, p_min_value of type real, and p_contents_filter of type text. The procedure performs a DELETE operation on the \"Boxes\" table, targeting rows where the \"Warehouse\" column matches the value of p_warehouse_code, the \"Value\" column is greater than or equal to p_min_value, and the \"Contents\" column, when converted to lowercase using the LOWER() function, matches the lowercase version of p_contents_filter. The LOWER() function is used to ensure case-insensitive comparison of the \"Contents\" column with the p_contents_filter parameter. The procedure does not include any conditional branching or iteration, and its sole operation is the deletion of rows that meet all specified conditions."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_country_scores that accepts six input parameters: a bigint parameter p_country_id to identify a specific country record, and five real number parameters p_justice_adjustment, p_health_adjustment, p_education_adjustment, p_economics_adjustment, and p_politics_adjustment, each representing a proposed change to a corresponding score category for that country. The procedure begins by declaring seven local real variables: v_current_overall, v_new_justice, v_new_health, v_new_education, v_new_economics, v_new_politics, and v_new_overall. It first executes a SELECT statement to retrieve the current overall_score from the countries table for the row where the id column matches the provided p_country_id, storing this value into the v_current_overall variable. Based on the value of v_current_overall, the procedure applies a different multiplicative factor to each of the input adjustment parameters before calculating new category scores. If v_current_overall is greater than 95.0, each adjustment is multiplied by 0.5. If it is greater than 90.0 but less than or equal to 95.0, adjustments are multiplied by 0.75. If it is greater than 80.0 but less than or equal to 90.0, adjustments are used directly (multiplied by 1.0). If it is greater than 70.0 but less than or equal to 80.0, adjustments are multiplied by 1.25. For all other cases (v_current_overall less than or equal to 70.0), adjustments are multiplied by 1.5. For each of the five score categoriesjustice_score, health_score, education_score, economics_score, and politics_scorethe procedure calculates a new value by selecting the current score from the countries table for the specified p_country_id, adding the corresponding adjusted parameter (original adjustment multiplied by the determined factor), and then constraining the result to a range between 0 and 100 inclusive using the expression GREATEST(0, LEAST(100, calculated_value)). The calculated values are stored in the variables v_new_justice, v_new_health, v_new_education, v_new_economics, and v_new_politics, respectively. After computing all five new category scores, the procedure calculates a new overall score v_new_overall by taking the arithmetic mean (sum divided by 5.0) of these five new category scores. Finally, the procedure executes a single UPDATE statement on the countries table, setting the justice_score column to v_new_justice, health_score to v_new_health, education_score to v_new_education, economics_score to v_new_economics, politics_score to v_new_politics, and overall_score to v_new_overall, specifically for the row where the id column equals the input p_country_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_country_scores(\n    p_country_id bigint,\n    p_justice_adjustment real,\n    p_health_adjustment real,\n    p_education_adjustment real,\n    p_economics_adjustment real,\n    p_politics_adjustment real\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_overall real;\n    v_new_justice real;\n    v_new_health real;\n    v_new_education real;\n    v_new_economics real;\n    v_new_politics real;\n    v_new_overall real;\nBEGIN\n    SELECT overall_score INTO v_current_overall FROM countries WHERE id = p_country_id;\n    \n    IF v_current_overall > 95.0 THEN\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment * 0.5));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment * 0.5));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment * 0.5));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment * 0.5));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment * 0.5));\n    ELSIF v_current_overall > 90.0 THEN\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment * 0.75));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment * 0.75));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment * 0.75));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment * 0.75));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment * 0.75));\n    ELSIF v_current_overall > 80.0 THEN\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment));\n    ELSIF v_current_overall > 70.0 THEN\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment * 1.25));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment * 1.25));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment * 1.25));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment * 1.25));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment * 1.25));\n    ELSE\n        v_new_justice := GREATEST(0, LEAST(100, (SELECT justice_score FROM countries WHERE id = p_country_id) + p_justice_adjustment * 1.5));\n        v_new_health := GREATEST(0, LEAST(100, (SELECT health_score FROM countries WHERE id = p_country_id) + p_health_adjustment * 1.5));\n        v_new_education := GREATEST(0, LEAST(100, (SELECT education_score FROM countries WHERE id = p_country_id) + p_education_adjustment * 1.5));\n        v_new_economics := GREATEST(0, LEAST(100, (SELECT economics_score FROM countries WHERE id = p_country_id) + p_economics_adjustment * 1.5));\n        v_new_politics := GREATEST(0, LEAST(100, (SELECT politics_score FROM countries WHERE id = p_country_id) + p_politics_adjustment * 1.5));\n    END IF;\n    \n    v_new_overall := (v_new_justice + v_new_health + v_new_education + v_new_economics + v_new_politics) / 5.0;\n    \n    UPDATE countries \n    SET justice_score = v_new_justice,\n        health_score = v_new_health,\n        education_score = v_new_education,\n        economics_score = v_new_economics,\n        politics_score = v_new_politics,\n        overall_score = v_new_overall\n    WHERE id = p_country_id;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "CALL update_country_scores(1, 2.5, -1.0, 0.5, 3.0, -2.0);",
      "CALL update_country_scores(2, -1.5, 2.0, 1.5, 0.0, 1.0);",
      "CALL update_country_scores(3, 5.0, 3.0, -2.0, 4.0, 0.5);",
      "CALL update_country_scores(1, 0.0, 0.0, 0.0, 0.0, 0.0);",
      "CALL update_country_scores(2, -10.0, 15.0, -8.0, 20.0, -5.0);"
    ],
    "summary": "Create a stored procedure named `update_country_scores` that takes a country ID and five adjustment values (justice, health, education, economics, politics). Retrieve the country's current overall score. Apply a multiplier to each adjustment based on the overall score (e.g., 0.5 if >95, 1.5 if <=70). Calculate each new category score by adding the adjusted value to the current score, then clamping the result between 0 and 100. Compute a new overall score as the average of the five new scores. Update the country record with all new scores.",
    "natural_language": "Create procedure `update_country_scores` with country ID and five adjustment values. Get current overall score. Use it to scale each adjustment. Add scaled adjustments to current category scores, limit results to 0-100. Average new scores for new overall. Update country record.",
    "id": 49,
    "generated_ir": "Write a PostgreSQL PL/pgSQL procedure named `update_country_scores` that operates on the `country_language` database. The procedure accepts six input parameters: `p_country_id` of type `BIGINT` representing the unique identifier of a country, and five adjustment parameters of type `REAL` named `p_justice_adj`, `p_health_adj`, `p_education_adj`, `p_economics_adj`, and `p_politics_adj`. These adjustment values are intended to modify the respective category scores for the specified country.\n\nThe procedure begins by declaring several local variables to store intermediate calculation results. These variables include `v_current_overall_score` of type `REAL` to hold the existing overall score of the country, `v_scaled_justice_adj`, `v_scaled_health_adj`, `v_scaled_education_adj`, `v_scaled_economics_adj`, and `v_scaled_politics_adj` all of type `REAL` to store the scaled adjustment values, `v_new_justice_score`, `v_new_health_score`, `v_new_education_score`, `v_new_economics_score`, and `v_new_politics_score` all of type `REAL` to hold the updated category scores after applying the scaled adjustments, and `v_new_overall_score` of type `REAL` to store the newly calculated overall average.\n\nThe procedure's logic is executed as follows. First, it performs a `SELECT` statement to retrieve the current `overall_score`, `justice_score`, `health_score`, `education_score`, `economics_score`, and `politics_score` from the `countries` table for the row where the `id` column matches the input parameter `p_country_id`. These values are fetched into the corresponding local variables.\n\nNext, the procedure calculates the scaled adjustment for each category. Each input adjustment parameter (`p_justice_adj`, `p_health_adj`, etc.) is multiplied by the `v_current_overall_score` variable, and the result is divided by 100.0. This scaling operation uses the current overall score as a weighting factor. The results of these calculations are stored in the respective scaled adjustment variables (`v_scaled_justice_adj`, etc.).\n\nThen, the procedure computes the new score for each of the five categories. For each category, it takes the current score (retrieved from the database) and adds the corresponding scaled adjustment value. After this addition, the result is constrained to a valid range using a bounding operation: if the sum is less than 0.0, it is set to 0.0; if it is greater than 100.0, it is set to 100.0. These bounded results become the new category scores and are stored in the variables `v_new_justice_score`, `v_new_health_score`, `v_new_education_score`, `v_new_economics_score`, and `v_new_politics_score`.\n\nFollowing the calculation of all five new category scores, the procedure computes the new overall score. This is done by calculating the arithmetic mean (average) of the five new category scores (`v_new_justice_score`, `v_new_health_score`, `v_new_education_score`, `v_new_economics_score`, and `v_new_politics_score`). The result is stored in the `v_new_overall_score` variable.\n\nFinally, the procedure executes an `UPDATE` statement on the `countries` table. It updates the row where the `id` column equals `p_country_id`. The update sets the following columns to their newly calculated values: `overall_score` is set to `v_new_overall_score`, `justice_score` is set to `v_new_justice_score`, `health_score` is set to `v_new_health_score`, `education_score` is set to `v_new_education_score`, `economics_score` is set to `v_new_economics_score`, and `politics_score` is set to `v_new_politics_score`. This completes the procedure, which does not return a value."
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `create_character_summary` that accepts three input parameters: `p_character_name` of type `text`, `p_year_threshold` of type `integer`, and `p_result_status` of type `text`. The purpose of this procedure is to analyze character data from the `actor` table and then insert a summary record into the `musical` table.\n\nUpon execution, the procedure first declares three local variables: `v_total_actors` of type `integer`, `v_min_age` of type `integer`, and `v_max_musical_id` of type `integer`.\n\nThe procedure then performs its first operation, which is a `SELECT` statement. This statement queries the `actor` table to calculate two aggregate values: the total count of rows and the minimum value of the `age` column. These calculated values are then assigned to the `v_total_actors` and `v_min_age` variables, respectively. The selection is filtered by a `WHERE` clause that compares the lowercase version of the `Character` column in the `actor` table with the lowercase version of the input parameter `p_character_name`. This ensures a case-insensitive comparison for character names.\n\nNext, the procedure executes a second `SELECT` statement. This statement queries the `musical` table to find the maximum value of the `Musical_ID` column. The `COALESCE` function is used to handle cases where `MAX(\"Musical_ID\")` might return `NULL` (e.g., if the `musical` table is empty), in which case it defaults to `0`. One is then added to this result, and the final value is assigned to the `v_max_musical_id` variable. This effectively generates a new, unique `Musical_ID` for the upcoming insertion.\n\nFinally, the procedure performs an `INSERT` operation into the `musical` table. A new row is inserted with values for the following columns:\n- `Musical_ID`: The value from the `v_max_musical_id` variable.\n- `Name`: A concatenated string formed by 'Character Analysis: ' followed by the value of the `p_character_name` input parameter.\n- `Year`: The value of the `p_year_threshold` input parameter.\n- `Award`: The literal string 'Character Study'.\n- `Category`: The literal string 'Performance Analysis'.\n- `Nominee`: A concatenated string formed by 'Min Age: ' followed by the value of the `v_min_age` variable.\n- `Result`: The value of the `p_result_status` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE create_character_summary(p_character_name text, p_year_threshold integer, p_result_status text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_actors integer;\n    v_min_age integer;\n    v_max_musical_id integer;\nBEGIN\n    SELECT COUNT(*), MIN(age) INTO v_total_actors, v_min_age \n    FROM actor \n    WHERE LOWER(actor.\"Character\") = LOWER(p_character_name);\n    \n    SELECT COALESCE(MAX(\"Musical_ID\"), 0) + 1 INTO v_max_musical_id FROM musical;\n    \n    INSERT INTO musical (\"Musical_ID\", \"Name\", \"Year\", \"Award\", \"Category\", \"Nominee\", \"Result\")\n    VALUES (v_max_musical_id, 'Character Analysis: ' || p_character_name, p_year_threshold, 'Character Study', 'Performance Analysis', 'Min Age: ' || v_min_age, p_result_status);\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL create_character_summary('Alf Stewart', 2000, 'Analyzed');",
      "CALL create_character_summary('Lou Carpenter', 1995, 'Completed');",
      "CALL create_character_summary('Irene Roberts', 2010, 'Pending');",
      "CALL create_character_summary('Harold Bishop', 1985, 'Nominated');",
      "CALL create_character_summary('Susan Kennedy', 2005, 'Won');"
    ],
    "summary": "Create a stored procedure named create_character_summary with parameters p_character_name (text), p_year_threshold (integer), and p_result_status (text). Count the total actors and find the minimum age for the specified character (case-insensitive). Determine the next available Musical_ID. Insert a summary record into the musical table with the calculated ID, a name prefixed 'Character Analysis: ', the provided year threshold, fixed awards/category, a nominee field showing the minimum age, and the provided result status.",
    "natural_language": "Develop a stored procedure, to be named create_character_summary, which must accept three distinct parameters: a text parameter for the character's name, an integer parameter to serve as a year threshold, and a final text parameter for the result status. This procedure should comprehensively calculate the total number of actors and meticulously identify the very minimum age associated with the specified character, ensuring the character name matching is handled in a case-insensitive manner. Furthermore, it must intelligently determine the next sequentially available Musical_ID. Finally, it is to insert a detailed summary record into the musical table, utilizing the newly calculated ID, a descriptive name that is prefixed with 'Character Analysis: ', the provided year threshold, a fixed and predetermined set of awards and category details, a nominee field that explicitly displays the discovered minimum age, and the result status that was originally supplied.",
    "id": 50,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `create_character_summary` that accepts three input parameters: `p_character_name` of type `text`, representing the character name to search for; `p_year_threshold` of type `integer`, serving as the year threshold; and `p_result_status` of type `text`, representing the result status. The procedure begins by declaring three local variables: `v_total_actors` of type `integer` to store the total number of actors associated with the specified character; `v_min_age` of type `integer` to store the minimum age among those actors; and `v_next_musical_id` of type `integer` to store the next sequentially available Musical_ID.\n\nInside the procedure's execution block, it first performs a `SELECT` operation on the `actor` table to calculate the total number of actors and the minimum age for the specified character. This is achieved by using the `COUNT` aggregate function on the `Actor_ID` column and the `MIN` aggregate function on the `age` column. The `WHERE` clause filters rows where the `Character` column matches the `p_character_name` parameter in a case-insensitive manner, using the `LOWER` function to convert both the column value and the parameter to lowercase for comparison. The results of these aggregations are stored into the `v_total_actors` and `v_min_age` variables, respectively.\n\nNext, the procedure determines the next available `Musical_ID` by performing another `SELECT` operation on the `musical` table. It selects the maximum value from the `Musical_ID` column. The `COALESCE` function is used to handle cases where the `musical` table might be empty, substituting `0` for `NULL`. The result of `COALESCE(MAX(Musical_ID), 0)` is then incremented by `1` to generate a new, unique `Musical_ID`, which is stored in the `v_next_musical_id` variable.\n\nFinally, an `INSERT` operation is executed to add a new record into the `musical` table. The values inserted into the respective columns are: `v_next_musical_id` for the `Musical_ID` column; a concatenated string formed by prefixing the literal `'Character Analysis: '` to the `p_character_name` parameter for the `Name` column; `p_year_threshold` for the `Year` column; the literal string `'Tony Award'` for the `Award` column; the literal string `'Best Performance by a Leading Actor in a Musical'` for the `Category` column; a concatenated string formed by the literal `'Min Age: '` followed by the `v_min_age` variable cast to text for the `Nominee` column; and `p_result_status` for the `Result` column."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three input parameters: school_name of type TEXT, min_age of type INTEGER, and new_team of type TEXT. The procedure updates the \"Team\" column in the player table to the value of new_team for all rows where the \"School_ID\" column matches any \"School_ID\" from the school table that corresponds to the school_name parameter, and where the \"Age\" column in the player table is greater than or equal to the min_age parameter. Specifically, the procedure first identifies the relevant \"School_ID\" values by performing a SELECT operation on the school table, filtering rows where the \"School\" column matches the school_name parameter. Then, it uses these \"School_ID\" values in a WHERE condition to update the \"Team\" column in the player table for rows that also satisfy the condition of having an \"Age\" value greater than or equal to the min_age parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_team_based_on_school_and_age(IN school_name TEXT, IN min_age INTEGER, IN new_team TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE player\n    SET \"Team\" = new_team\n    WHERE \"School_ID\" IN (\n        SELECT \"School_ID\"\n        FROM school\n        WHERE \"School\" = school_name\n    ) AND \"Age\" >= min_age;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school"
    ],
    "call_sqls": [
      "CALL assign_team_based_on_school_and_age('St Aloysius'' College', 15, 'New Team A');",
      "CALL assign_team_based_on_school_and_age('Barker College', 14, 'New Team B');",
      "CALL assign_team_based_on_school_and_age('Cranbrook School', 16, 'New Team C');",
      "CALL assign_team_based_on_school_and_age('St Aloysius'' College', 10, 'Junior Team');",
      "CALL assign_team_based_on_school_and_age('Barker College', 20, 'Senior Team');"
    ],
    "summary": "Create a stored procedure that accepts `school_name` (TEXT), `min_age` (INTEGER), and `new_team` (TEXT) parameters. Update the `player` table, setting the \"Team\" column to `new_team` for all players whose \"School_ID\" matches the school with the given `school_name` and whose \"Age\" is greater than or equal to `min_age`.",
    "natural_language": "Update player team to new_team where school matches school_name and age >= min_age.",
    "id": 51,
    "generated_ir": "Write a PLpgSQL stored procedure that takes three input parameters: school_name of type TEXT, min_age of type INTEGER, and new_team of type TEXT. The procedure updates the \"Team\" column in the player table to the value of new_team for all rows where the \"School_ID\" column matches any \"School_ID\" from the school table that corresponds to the school_name parameter, and where the \"Age\" column in the player table is greater than or equal to the min_age parameter. Specifically, the procedure first identifies the relevant \"School_ID\" values by performing a SELECT operation on the school table, filtering rows where the \"School\" column matches the school_name parameter. Then, it uses these \"School_ID\" values in a WHERE condition to update the \"Team\" column in the player table for rows that also satisfy the condition of having an \"Age\" value greater than or equal to the min_age parameter."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_customer_resident_data` that accepts two input parameters: `p_customer_id` of type `bigint` and `p_property_id` of type `bigint`. The procedure begins by declaring two local integer variables: `v_resident_count` and `v_thing_count`. It then proceeds to calculate the count of residents for a specific property within the current year. This is achieved by executing a `SELECT COUNT(*)` statement on the `\"Residents\"` table, filtering rows where the `\"property_id\"` column matches the input parameter `p_property_id` and the year extracted from the `\"date_moved_in\"` column is equal to the year extracted from the current timestamp (`CURRENT_TIMESTAMP`). The resulting count is stored in the `v_resident_count` variable. Subsequently, the procedure calculates the count of \"things\" associated with a specific customer. This is done by executing another `SELECT COUNT(*)` statement on the `\"Things\"` table, filtering rows where the `\"thing_id\"` column is present in a subquery. The subquery selects `\"thing_id\"` from the `\"Customer_Events\"` table where the `\"customer_id\"` column matches the input parameter `p_customer_id`. The count obtained from this operation is stored in the `v_thing_count` variable. Following these calculations, the procedure evaluates conditional logic based on the values of `v_resident_count` and `v_thing_count`. If both `v_resident_count` is greater than 0 AND `v_thing_count` is greater than 0, the procedure executes an `INSERT` statement. This statement inserts a new row into the `\"Customer_Events\"` table, setting the `\"customer_id\"` column to `p_customer_id`, the `\"property_id\"` column to `p_property_id`, and the `\"date_moved_in\"` column to the current timestamp (`CURRENT_TIMESTAMP`). Alternatively, if `v_resident_count` is equal to 0 AND `v_thing_count` is greater than 0, the procedure executes a `DELETE` statement. This statement removes rows from the `\"Customer_Events\"` table where the `\"customer_id\"` column matches `p_customer_id` AND the `\"property_id\"` column matches `p_property_id`. In all other cases (i.e., if neither of the above conditions is met), the procedure executes an `UPDATE` statement. This statement modifies the `\"Customers\"` table by setting the `\"customer_details\"` column to an uppercase substring of its current value. Specifically, it takes the first 10 characters of the existing `\"customer_details\"` value using `SUBSTR(\"customer_details\", 1, 10)` and then converts this substring to uppercase using the `UPPER()` function. This update is applied only to the row where the `\"customer_id\"` column matches the input parameter `p_customer_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_customer_resident_data(IN p_customer_id bigint, IN p_property_id bigint)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_resident_count integer;\n    v_thing_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_resident_count\n    FROM \"Residents\"\n    WHERE \"property_id\" = p_property_id\n    AND EXTRACT(YEAR FROM \"date_moved_in\") = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);\n    \n    SELECT COUNT(*) INTO v_thing_count\n    FROM \"Things\"\n    WHERE \"thing_id\" IN (\n        SELECT \"thing_id\" FROM \"Customer_Events\" \n        WHERE \"customer_id\" = p_customer_id\n    );\n    \n    IF v_resident_count > 0 AND v_thing_count > 0 THEN\n        INSERT INTO \"Customer_Events\" (\"customer_id\", \"property_id\", \"date_moved_in\")\n        VALUES (p_customer_id, p_property_id, CURRENT_TIMESTAMP);\n    ELSIF v_resident_count = 0 AND v_thing_count > 0 THEN\n        DELETE FROM \"Customer_Events\"\n        WHERE \"customer_id\" = p_customer_id\n        AND \"property_id\" = p_property_id;\n    ELSE\n        UPDATE \"Customers\"\n        SET \"customer_details\" = UPPER(SUBSTR(\"customer_details\", 1, 10))\n        WHERE \"customer_id\" = p_customer_id;\n    END IF;\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Customers",
      "Residents",
      "Things"
    ],
    "call_sqls": [
      "CALL process_customer_resident_data(19, 605);",
      "CALL process_customer_resident_data(5, 879);",
      "CALL process_customer_resident_data(16, 629);",
      "CALL process_customer_resident_data(4, 954);",
      "CALL process_customer_resident_data(10, 500);"
    ],
    "summary": "Create a stored procedure named process_customer_resident_data that processes data based on resident and thing counts. It counts current-year residents for a property and counts things associated with a customer's events. If both counts are positive, it inserts a new customer event. If there are zero residents but positive things, it deletes matching customer events. Otherwise, it updates the customer's details to an uppercase substring.",
    "natural_language": "Create a stored procedure called process_customer_resident_data that handles data depending on some resident numbers and thing totals. It should figure out roughly how many residents for a property there are from this year and get a count of things linked to a customer's various events. If both these amounts are decently high, it adds a new customer event. If there are basically no residents but a fair number of things, it removes any matching customer events. Otherwise, it just adjusts the customer's information to a shorter, uppercase version.",
    "id": 52,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `process_customer_resident_data` that accepts two input parameters: `p_customer_id` of type `bigint` and `p_property_id` of type `bigint`. The procedure begins by declaring two local integer variables: `v_resident_count` and `v_thing_count`. It then proceeds to calculate the count of residents for a specific property within the current year. This is achieved by executing a `SELECT COUNT(*)` statement on the `\"Residents\"` table, filtering rows where the `\"property_id\"` column matches the input parameter `p_property_id` and the year extracted from the `\"date_moved_in\"` column is equal to the year extracted from the current timestamp (`CURRENT_TIMESTAMP`). The resulting count is stored in the `v_resident_count` variable. Subsequently, the procedure calculates the count of \"things\" associated with a specific customer. This is done by executing another `SELECT COUNT(*)` statement on the `\"Things\"` table, filtering rows where the `\"thing_id\"` column is present in a subquery. The subquery selects `\"thing_id\"` from the `\"Customer_Events\"` table where the `\"customer_id\"` column matches the input parameter `p_customer_id`. The count obtained from this operation is stored in the `v_thing_count` variable. Following these calculations, the procedure evaluates conditional logic based on the values of `v_resident_count` and `v_thing_count`. If both `v_resident_count` is greater than 0 AND `v_thing_count` is greater than 0, the procedure executes an `INSERT` statement. This statement inserts a new row into the `\"Customer_Events\"` table, setting the `\"customer_id\"` column to `p_customer_id`, the `\"property_id\"` column to `p_property_id`, and the `\"date_moved_in\"` column to the current timestamp (`CURRENT_TIMESTAMP`). Alternatively, if `v_resident_count` is equal to 0 AND `v_thing_count` is greater than 0, the procedure executes a `DELETE` statement. This statement removes rows from the `\"Customer_Events\"` table where the `\"customer_id\"` column matches `p_customer_id` AND the `\"property_id\"` column matches `p_property_id`. In all other cases (i.e., if neither of the above conditions is met), the procedure executes an `UPDATE` statement. This statement modifies the `\"Customers\"` table by setting the `\"customer_details\"` column to an uppercase substring of its current value. Specifically, it takes the first 10 characters of the existing `\"customer_details\"` value using `SUBSTR(\"customer_details\", 1, 10)` and then converts this substring to uppercase using the `UPPER()` function. This update is applied only to the row where the `\"customer_id\"` column matches the input parameter `p_customer_id`."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named register_party_service that accepts four input parameters: a parameter named customer_party_id of type BIGINT which represents the unique identifier for the customer party, a parameter named target_service_id of type BIGINT which represents the unique identifier for the service to be booked, a parameter named booking_date of type DATE which signifies the date when the booking is being made, and a parameter named service_schedule_date of type DATE which indicates the scheduled date for the service to be performed. The procedure executes a single SQL INSERT operation into a table named \"Party_Services\". The insertion populates four columns in the \"Party_Services\" table: the customer_id column is set to the value of the customer_party_id input parameter, the service_id column is set to the value of the target_service_id input parameter, the booking_made_date column is set to the booking_date input parameter after explicitly casting it to a TIMESTAMP WITH TIME ZONE data type, and the service_datetime column is set to the service_schedule_date input parameter after explicitly casting it to a TIMESTAMP WITH TIME ZONE data type.",
    "plsql": "CREATE OR REPLACE PROCEDURE register_party_service(customer_party_id BIGINT, target_service_id BIGINT, booking_date DATE, service_schedule_date DATE)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"Party_Services\" (customer_id, service_id, booking_made_date, service_datetime)\n    VALUES (\n        customer_party_id,\n        target_service_id,\n        booking_date::timestamp with time zone,\n        service_schedule_date::timestamp with time zone\n    );\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Addresses",
      "Party_Addresses",
      "Forms",
      "Services",
      "Party_Forms",
      "Party_Services",
      "Individuals"
    ],
    "call_sqls": [
      "CALL register_party_service(10, 12, '2023-10-15', '2023-11-20');",
      "CALL register_party_service(14, 11, '2023-10-16', '2023-11-25');",
      "CALL register_party_service(4, 7, '2023-10-17', '2023-11-30');",
      "CALL register_party_service(1, 1, '2023-10-18', '2023-12-01');",
      "CALL register_party_service(2, 3, '2023-10-19', '2023-12-05');"
    ],
    "summary": "Create a stored procedure named register_party_service with input parameters: customer_party_id (BIGINT), target_service_id (BIGINT), booking_date (DATE), service_schedule_date (DATE). Insert a row into the Party_Services table. Set customer_id to customer_party_id, service_id to target_service_id, booking_made_date to booking_date cast as TIMESTAMP WITH TIME ZONE, and service_datetime to service_schedule_date cast as TIMESTAMP WITH TIME ZONE.",
    "natural_language": "Create procedure register_party_service with inputs customer_party_id BIGINT, target_service_id BIGINT, booking_date DATE, service_schedule_date DATE. Insert into Party_Services setting customer_id to customer_party_id, service_id to target_service_id, booking_made_date to booking_date::TIMESTAMPTZ, service_datetime to service_schedule_date::TIMESTAMPTZ.",
    "id": 53,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named register_party_service that accepts four input parameters: a parameter named customer_party_id of type BIGINT which represents the unique identifier for the customer party, a parameter named target_service_id of type BIGINT which represents the unique identifier for the service to be booked, a parameter named booking_date of type DATE which signifies the date when the booking is being made, and a parameter named service_schedule_date of type DATE which indicates the scheduled date for the service to be performed. The procedure executes a single SQL INSERT operation into a table named \"Party_Services\". The insertion populates four columns in the \"Party_Services\" table: the customer_id column is set to the value of the customer_party_id input parameter, the service_id column is set to the value of the target_service_id input parameter, the booking_made_date column is set to the booking_date input parameter after explicitly casting it to a TIMESTAMP WITH TIME ZONE data type, and the service_datetime column is set to the service_schedule_date input parameter after explicitly casting it to a TIMESTAMP WITH TIME ZONE data type."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `archive_old_claims` that accepts three input parameters: `p_cutoff_date` of type `date`, `p_policy_id_filter` of type `bigint`, and `p_status_flag` of type `boolean`. The purpose of this procedure is to conditionally delete records from the table named `\"Claims\"`. The procedure's logic is controlled by the `p_status_flag` parameter. If `p_status_flag` evaluates to `TRUE`, the procedure executes a `DELETE` operation on the `\"Claims\"` table. This deletion targets rows where the value in the `\"Date_Claim_Made\"` column is strictly less than the value provided in the `p_cutoff_date` parameter, AND the value in the `\"Policy_ID\"` column is exactly equal to the value provided in the `p_policy_id_filter` parameter, AND the value in the `\"Date_Claim_Settled\"` column is explicitly `NOT NULL`. If `p_status_flag` evaluates to `FALSE`, the procedure executes an alternative `DELETE` operation on the `\"Claims\"` table. This deletion targets rows where the value in the `\"Date_Claim_Made\"` column is strictly less than the value provided in the `p_cutoff_date` parameter, AND the value in the `\"Policy_ID\"` column is exactly equal to the value provided in the `p_policy_id_filter` parameter, AND the value in the `\"Date_Claim_Settled\"` column is explicitly `NULL`.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_old_claims(p_cutoff_date date, p_policy_id_filter bigint, p_status_flag boolean)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF p_status_flag THEN\n        DELETE FROM \"Claims\" \n        WHERE \"Date_Claim_Made\" < p_cutoff_date \n        AND \"Policy_ID\" = p_policy_id_filter\n        AND \"Date_Claim_Settled\" IS NOT NULL;\n    ELSE\n        DELETE FROM \"Claims\" \n        WHERE \"Date_Claim_Made\" < p_cutoff_date \n        AND \"Policy_ID\" = p_policy_id_filter\n        AND \"Date_Claim_Settled\" IS NULL;\n    END IF;\nEND;\n$$;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "CALL archive_old_claims('2017-01-01', 744, TRUE);",
      "CALL archive_old_claims('2018-03-15', 552, FALSE);",
      "CALL archive_old_claims('2016-06-30', 473, TRUE);",
      "CALL archive_old_claims('2017-12-31', 744, FALSE);",
      "CALL archive_old_claims('2015-01-01', 552, TRUE);"
    ],
    "summary": "Create a stored procedure named archive_old_claims that deletes claims older than a cutoff date for a specific policy. If a status flag is true, delete settled claims. If false, delete unsettled claims.",
    "natural_language": "Hey, can you whip up a stored procedure called archive_old_claims? It needs to get rid of claims for a particular policy that are older than a certain date. Oh, and here's the kicker: if a status flag is set to true, only ditch the settled ones. If it's false, then only boot out the unsettled claims.",
    "id": 54,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `archive_old_claims` that accepts three input parameters: `p_cutoff_date` of type `date`, `p_policy_id_filter` of type `bigint`, and `p_status_flag` of type `boolean`. The purpose of this procedure is to conditionally delete records from the table named `\"Claims\"`. The procedure's logic is controlled by the `p_status_flag` parameter. If `p_status_flag` evaluates to `TRUE`, the procedure executes a `DELETE` operation on the `\"Claims\"` table. This deletion targets rows where the value in the `\"Date_Claim_Made\"` column is strictly less than the value provided in the `p_cutoff_date` parameter, AND the value in the `\"Policy_ID\"` column is exactly equal to the value provided in the `p_policy_id_filter` parameter, AND the value in the `\"Date_Claim_Settled\"` column is explicitly `NOT NULL`. If `p_status_flag` evaluates to `FALSE`, the procedure executes an alternative `DELETE` operation on the `\"Claims\"` table. This deletion targets rows where the value in the `\"Date_Claim_Made\"` column is strictly less than the value provided in the `p_cutoff_date` parameter, AND the value in the `\"Policy_ID\"` column is exactly equal to the value provided in the `p_policy_id_filter` parameter, AND the value in the `\"Date_Claim_Settled\"` column is explicitly `NULL`."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named insert_individual_from_party that accepts two parameters: party_id_input of type BIGINT, which represents the unique identifier of a party, and last_name_input of type TEXT, which represents the last name of an individual. The procedure begins by declaring two local variables, party_email_val and party_phone_val, both of type TEXT, to store the email and phone number associated with the specified party. It then performs a SELECT operation on the Parties table to retrieve the party_email and party_phone columns for the row where the party_id matches the provided party_id_input, storing these values into the declared variables. Next, the procedure attempts to INSERT a new row into the Individuals table with the following values: individual_id set to party_id_input, individual_last_name set to the uppercase version of last_name_input using the UPPER() function, individual_email set to the lowercase version of party_email_val using the LOWER() function, and inidividual_phone set to party_phone_val. If a conflict occurs on the individual_id column, indicating that a row with the same individual_id already exists, the procedure performs an UPDATE operation on the conflicting row, setting individual_last_name, individual_email, and inidividual_phone to the values from the EXCLUDED pseudo-table, which represents the values that would have been inserted.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_individual_from_party(party_id_input BIGINT, last_name_input TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    party_email_val TEXT;\n    party_phone_val TEXT;\nBEGIN\n    SELECT \"party_email\", \"party_phone\" INTO party_email_val, party_phone_val\n    FROM \"Parties\"\n    WHERE \"party_id\" = party_id_input;\n    \n    INSERT INTO \"Individuals\" (\"individual_id\", \"individual_last_name\", \"individual_email\", \"inidividual_phone\")\n    VALUES (party_id_input, UPPER(last_name_input), LOWER(party_email_val), party_phone_val)\n    ON CONFLICT (individual_id) DO UPDATE\n    SET\n        \"individual_last_name\" = EXCLUDED.\"individual_last_name\",\n        \"individual_email\" = EXCLUDED.\"individual_email\",\n        \"inidividual_phone\" = EXCLUDED.\"inidividual_phone\";\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Addresses",
      "Forms",
      "Individuals",
      "Organizations",
      "Parties",
      "Party_Addresses",
      "Party_Forms",
      "Party_Services",
      "Services"
    ],
    "call_sqls": [
      "CALL insert_individual_from_party(1, 'Smith');",
      "CALL insert_individual_from_party(2, 'Johnson');",
      "CALL insert_individual_from_party(3, 'Williams');",
      "CALL insert_individual_from_party(1, 'Brown');",
      "CALL insert_individual_from_party(2, 'Jones');"
    ],
    "summary": "Create a stored procedure named insert_individual_from_party that accepts a party_id (BIGINT) and a last_name (TEXT). Retrieve the party's email and phone from the Parties table. Insert a new individual using the party_id, the uppercase last_name, the lowercase email, and the phone. If the individual_id already exists, update the existing record with the new values instead.",
    "natural_language": "Construct a stored procedure, which we shall name 'insert_individual_from_party', that is designed to receive two distinct input parameters: a party identifier of type BIGINT and a last name provided as TEXT. The procedure must first perform a lookup in the comprehensive Parties table to meticulously retrieve the associated email address and contact phone number for the specified party. Subsequently, it should proceed to insert a brand new individual record, utilizing the supplied party_id, transforming the last_name to its uppercase representation, converting the email to a consistent lowercase format, and incorporating the phone number as retrieved. Importantly, if an individual record with that specific individual_id is already present within the system, the procedure must gracefully handle this by updating the pre-existing record with all the newly provided and transformed values, thereby ensuring data integrity and avoiding duplication.",
    "id": 55,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named insert_individual_from_party for the e_government database that accepts two input parameters: p_party_id of type BIGINT and p_last_name of type TEXT. The procedure first declares a variable v_party_email of type TEXT and a variable v_party_phone of type TEXT to store retrieved data. It then executes a SELECT query on the Parties table to fetch the party_email and party_phone columns for the given p_party_id, storing the results into the declared variables. If no matching party is found, the procedure does nothing further. Using the retrieved and input values, it attempts to insert a new record into the Individuals table with the following column assignments: individual_id is set to the p_party_id value, individual_last_name is set to the uppercase version of p_last_name using the UPPER function, individual_email is set to the lowercase version of v_party_email using the LOWER function, and inidividual_phone is set directly to v_party_phone. The other columns (individual_first_name, individual_middle_name, individual_address) are left as NULL. If an individual record with the same individual_id (i.e., the same p_party_id) already exists in the Individuals table, the procedure instead performs an UPDATE on that existing record, setting individual_last_name to UPPER(p_last_name), individual_email to LOWER(v_party_email), and inidividual_phone to v_party_phone, leaving the other columns unchanged. This upsert behavior is implemented using an INSERT with an ON CONFLICT clause on the individual_id primary key, specifying a DO UPDATE action that updates the three columns with the new values. The procedure does not return a value."
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `remove_expired_addresses` that accepts four input parameters: `target_party_id` of type `BIGINT`, `expiry_date` of type `DATE`, `address_type` of type `TEXT`, and `state_filter` of type `TEXT`. The purpose of this procedure is to remove specific address records from the `\"Party_Addresses\"` table based on a combination of criteria. The `target_party_id` parameter is used to identify the specific party whose addresses are being considered for removal. The `expiry_date` parameter defines the cutoff date for address expiration; addresses with a `date_address_to` on or before this date are candidates for removal. The `address_type` parameter specifies the type of address to be removed, matching against the `address_type_code` column. The `state_filter` parameter is used to narrow down the addresses to those located in a particular state, province, or county.\n\nThe procedure performs a single `DELETE` operation on the `\"Party_Addresses\"` table. This `DELETE` statement targets rows where the `party_id` column exactly matches the `target_party_id` input parameter. Additionally, it requires that the `DATE` part of the `date_address_to` column in `\"Party_Addresses\"` is less than or equal to the `expiry_date` input parameter. Furthermore, the `address_type_code` column in `\"Party_Addresses\"` must exactly match the `address_type` input parameter. Finally, to be deleted, the `address_id` from the `\"Party_Addresses\"` table must be present in the result set of a subquery. This subquery selects `address_id` values from the `\"Addresses\"` table where the `state_province_county` column exactly matches the `state_filter` input parameter. In essence, the procedure deletes party address records that belong to a specific party, have an expiration date on or before the provided `expiry_date`, are of a particular `address_type`, and are associated with an address located in the specified state, province, or county.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_expired_addresses(target_party_id BIGINT, expiry_date DATE, address_type TEXT, state_filter TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Party_Addresses\"\n    WHERE party_id = target_party_id\n    AND DATE(date_address_to) <= expiry_date\n    AND address_type_code = address_type\n    AND address_id IN (\n        SELECT address_id\n        FROM \"Addresses\"\n        WHERE state_province_county = state_filter\n    );\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Addresses",
      "Party_Addresses",
      "Forms",
      "Services",
      "Party_Forms",
      "Party_Services",
      "Individuals"
    ],
    "call_sqls": [
      "CALL remove_expired_addresses(10, '2023-12-31', 'Residence', 'NorthCarolina');",
      "CALL remove_expired_addresses(15, '2022-06-15', 'Billing', 'Colorado');",
      "CALL remove_expired_addresses(4, '2024-01-01', 'Delivery', 'NewHampshire');",
      "CALL remove_expired_addresses(2, '2021-03-20', 'Residence', 'California');",
      "CALL remove_expired_addresses(8, '2023-10-10', 'Billing', 'Texas');"
    ],
    "summary": "Create a stored procedure named remove_expired_addresses with input parameters: target_party_id (BIGINT), expiry_date (DATE), address_type (TEXT), state_filter (TEXT). Delete rows from the Party_Addresses table where party_id equals target_party_id, the DATE part of date_address_to is <= expiry_date, and address_type_code equals address_type. Also, the address_id must be in the result of a subquery that selects address_id from the Addresses table where state_province_county equals state_filter.",
    "natural_language": "Create a stored procedure called remove_expired_addresses that takes in a target_party_id (BIGINT), an expiry_date (DATE), an address_type (TEXT), and a state_filter (TEXT). The procedure should get rid of some old entries from the Party_Addresses table for the given party. It should remove records where the address type matches the provided one, and where the end date is on or before the specified expiry date. Also, only delete addresses that are located in the general area or state indicated by the state_filter.",
    "id": 56,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named remove_expired_addresses that accepts four input parameters: target_party_id of type BIGINT, expiry_date of type DATE, address_type of type TEXT, and state_filter of type TEXT. This procedure is designed to delete expired address records from the Party_Addresses table for a specific party, based on address type, expiry date, and state location criteria.\n\nThe procedure operates within the e_government database and involves the following tables and columns:\n- Party_Addresses table with columns: party_id, address_id, date_address_from, address_type_code, date_address_to.\n- Addresses table with columns: address_id, line_1_number_building, town_city, zip_postcode, state_province_county, country.\n\nThe core logic of the procedure is to perform a DELETE operation on the Party_Addresses table. The deletion targets rows that meet all of the following conditions:\n1. The party_id column in Party_Addresses must match the input parameter target_party_id.\n2. The address_type_code column in Party_Addresses must match the input parameter address_type.\n3. The date_address_to column in Party_Addresses must be less than or equal to the input parameter expiry_date. This condition ensures that only addresses whose end date is on or before the specified expiry date are removed.\n4. The address must be located in the state specified by state_filter. This is enforced by joining the Party_Addresses table with the Addresses table on the address_id column, and checking that the state_province_county column in the Addresses table matches the input parameter state_filter.\n\nThe DELETE operation uses a FROM clause with an INNER JOIN between Party_Addresses and Addresses on the condition Party_Addresses.address_id = Addresses.address_id. The WHERE clause combines all the above conditions using the AND logical operator.\n\nNo local variables are declared, as the procedure directly executes the DELETE statement based on the input parameters. The procedure does not return a value; it performs a data modification operation and completes."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named insert_party_address that accepts two mandatory input parameters: party_id_input of type BIGINT, which represents the unique identifier for a party, and address_id_input of type BIGINT, which represents the unique identifier for an address. The procedure begins by declaring a local variable address_type_val of type TEXT. It then calculates the value for this variable using a conditional CASE expression: it checks if the input party_id_input is an even number by evaluating the modulo operation MOD(party_id_input, 2) = 0; if this condition is true, the variable is assigned the string literal 'Billing', otherwise it is assigned the string literal 'Residence'. Following this logic, the procedure performs a single INSERT operation into the table named \"Party_Addresses\". It inserts a new row with values for four columns: the \"party_id\" column is set to the input parameter party_id_input, the \"address_id\" column is set to the input parameter address_id_input, the \"date_address_from\" column is populated with the current date and time using the function call CURRENT_TIMESTAMP, and the \"address_type_code\" column is set to the derived value stored in the local variable address_type_val.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_party_address(party_id_input BIGINT, address_id_input BIGINT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    address_type_val TEXT;\nBEGIN\n    address_type_val := CASE WHEN MOD(party_id_input, 2) = 0 THEN 'Billing' ELSE 'Residence' END;\n    INSERT INTO \"Party_Addresses\" (\"party_id\", \"address_id\", \"date_address_from\", \"address_type_code\")\n    VALUES (party_id_input, address_id_input, CURRENT_TIMESTAMP, address_type_val);\nEND;\n$$;",
    "database_name": "e_government",
    "tables": [
      "Addresses",
      "Forms",
      "Individuals",
      "Organizations",
      "Parties",
      "Party_Addresses",
      "Party_Forms",
      "Party_Services",
      "Services"
    ],
    "call_sqls": [
      "CALL insert_party_address(1, 1);",
      "CALL insert_party_address(2, 2);",
      "CALL insert_party_address(3, 3);",
      "CALL insert_party_address(4, 1);",
      "CALL insert_party_address(5, 2);"
    ],
    "summary": "Create a stored procedure named insert_party_address that takes a party ID and an address ID. Determine the address type as 'Billing' if the party ID is even, otherwise 'Residence'. Insert a new record into Party_Addresses with these IDs, the current timestamp, and the determined address type.",
    "natural_language": "How can I create a stored procedure called 'insert_party_address' that accepts a party ID and an address ID, determines the address type as 'Billing' for even party IDs and 'Residence' for odd ones, and then inserts a new record into the Party_Addresses table with these values and the current timestamp?",
    "id": 57,
    "generated_ir": "Write a PostgreSQL PL/pgSQL procedure named insert_party_address in the e_government database. The procedure accepts two input parameters: a party_id of type bigint and an address_id of type bigint. It declares a local variable v_address_type of type text to store the determined address type. The procedure determines the address type based on the parity of the input party_id: if the party_id is even (i.e., party_id % 2 = 0), it sets v_address_type to the string 'Billing'; if the party_id is odd (i.e., party_id % 2 != 0), it sets v_address_type to the string 'Residence'. It then inserts a new row into the Party_Addresses table with the following column values: the party_id column is set to the input party_id parameter, the address_id column is set to the input address_id parameter, the date_address_from column is set to the current timestamp using the PostgreSQL function CURRENT_TIMESTAMP, the address_type_code column is set to the determined v_address_type, and the date_address_to column is left as NULL. The procedure does not return a value; it performs the insertion and then completes."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes five parameters: p_cutoff_date of type timestamp with time zone, p_min_amount of type numeric, p_archive_prefix of type text, p_batch_size of type bigint, and p_retention_days of type integer. The procedure begins by declaring two local variables, v_count of type integer and v_archive_id of type bigint. It then performs a SELECT COUNT(*) operation to determine the number of rows in the \"Invoices\" table joined with the \"Invoice_Line_Items\" table where the invoice_date is earlier than p_cutoff_date and the derived_total_cost in \"Invoice_Line_Items\" exceeds p_min_amount, storing the result in v_count. If v_count is greater than zero, the procedure assigns v_archive_id the current timestamp in seconds since the epoch, cast to bigint. It then inserts new rows into the \"Invoices\" table, selecting invoice_number as v_archive_id plus a row number ordered by invoice_number, order_id, and the current timestamp as invoice_date from the \"Invoices\" table where invoice_date is less than p_cutoff_date, limiting the number of rows inserted to p_batch_size. Finally, it deletes rows from the \"Invoice_Line_Items\" table where the invoice_number exists in the \"Invoices\" table with an invoice_date older than the current timestamp minus the number of days specified by p_retention_days.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_invoice_data(\n    p_cutoff_date timestamp with time zone,\n    p_min_amount numeric,\n    p_archive_prefix text,\n    p_batch_size bigint,\n    p_retention_days integer\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_count integer;\n    v_archive_id bigint;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM \"Invoices\" i\n    JOIN \"Invoice_Line_Items\" ili ON i.invoice_number = ili.invoice_number\n    WHERE i.invoice_date < p_cutoff_date\n    AND ili.derived_total_cost > p_min_amount;\n    \n    IF v_count > 0 THEN\n        v_archive_id := EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::bigint;\n        \n        INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date)\n        SELECT \n            v_archive_id + ROW_NUMBER() OVER (ORDER BY invoice_number),\n            order_id,\n            CURRENT_TIMESTAMP\n        FROM \"Invoices\"\n        WHERE invoice_date < p_cutoff_date\n        LIMIT p_batch_size;\n        \n        DELETE FROM \"Invoice_Line_Items\"\n        WHERE invoice_number IN (\n            SELECT invoice_number\n            FROM \"Invoices\"\n            WHERE invoice_date < (CURRENT_TIMESTAMP - INTERVAL '1 day' * p_retention_days)\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Invoices",
      "Invoice_Line_Items"
    ],
    "call_sqls": [
      "CALL archive_invoice_data('2023-01-01 00:00:00+00', 60.00, 'arch_', 100, 30);",
      "CALL archive_invoice_data('2023-06-01 00:00:00+00', 70.00, 'archive_', 50, 60);",
      "CALL archive_invoice_data('2023-03-01 00:00:00+00', 80.00, 'backup_', 200, 90);",
      "CALL archive_invoice_data('2023-09-01 00:00:00+00', 50.00, 'old_', 150, 120);",
      "CALL archive_invoice_data('2023-12-01 00:00:00+00', 65.00, 'save_', 75, 45);"
    ],
    "summary": "Create a stored procedure with parameters p_cutoff_date (TIMESTAMPTZ), p_min_amount (NUMERIC), p_archive_prefix (TEXT), p_batch_size (BIGINT), and p_retention_days (INTEGER). Count rows from Invoices joined with Invoice_Line_Items where invoice_date < p_cutoff_date and derived_total_cost > p_min_amount. If count > 0, generate an archive ID from the epoch timestamp. Insert up to p_batch_size rows into Invoices, creating new invoice numbers. Finally, delete rows from Invoice_Line_Items where the invoice_number exists in Invoices with an invoice_date older than current date minus p_retention_days.",
    "natural_language": "Make a stored procedure that takes a sort of recent date, a not-too-small money amount, a text prefix for archives, a decent batch size, and a number of days to keep stuff. Figure out roughly how many invoice and line item records there are from a while back that had pretty high totals. If you find a bunch, come up with a new archive ID based on the current time. Then, copy a good chunk of those old invoices over with new invoice numbers. Lastly, clean out any really old line items for invoices that are past their keep-around time.",
    "id": 58,
    "generated_ir": "Write a PLpgSQL stored procedure that takes five parameters: p_cutoff_date of type timestamp with time zone, p_min_amount of type numeric, p_archive_prefix of type text, p_batch_size of type bigint, and p_retention_days of type integer. The procedure begins by declaring two local variables, v_count of type integer and v_archive_id of type bigint. It then performs a SELECT COUNT(*) operation to determine the number of rows in the \"Invoices\" table joined with the \"Invoice_Line_Items\" table where the invoice_date is earlier than p_cutoff_date and the derived_total_cost in \"Invoice_Line_Items\" exceeds p_min_amount, storing the result in v_count. If v_count is greater than zero, the procedure assigns v_archive_id the current timestamp in seconds since the epoch, cast to bigint. It then inserts new rows into the \"Invoices\" table, selecting invoice_number as v_archive_id plus a row number ordered by invoice_number, order_id, and the current timestamp as invoice_date from the \"Invoices\" table where invoice_date is less than p_cutoff_date, limiting the number of rows inserted to p_batch_size. Finally, it deletes rows from the \"Invoice_Line_Items\" table where the invoice_number exists in the \"Invoices\" table with an invoice_date older than the current timestamp minus the number of days specified by p_retention_days."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named optimize_member_assignments that accepts five input parameters: an integer p_min_club_ranking, an integer p_max_member_age, a text p_target_nationality, a text p_assignment_year, and an integer p_leader_threshold. The procedure first declares two local variables: an integer v_optimal_club and a numeric v_performance_score. It begins execution by selecting a single Club_ID from the club table, assigning it to v_optimal_club, where the Overall_Ranking column value falls between the p_min_club_ranking parameter and the p_leader_threshold parameter, ordering the results by Overall_Ranking in ascending order and limiting the result to the first row. Next, using a common table expression named performance_analysis, it calculates a cumulative distribution percentile (perf_score) for each club by applying the cume_dist() window function over all clubs ordered by their Overall_Ranking; it then selects the perf_score value from this CTE where the Club_ID matches the previously identified v_optimal_club and stores this value into the v_performance_score variable. The procedure then performs an update on the member table, setting the Age column to the value of p_max_member_age and the Nationality column to the value of p_target_nationality for all members whose Member_ID is found in a subquery; this subquery selects Member_ID from the member table (aliased as m), performing a left join with the club_leader table (aliased as cl) on m.Member_ID = cl.Member_ID, and includes only those members where no matching record exists in club_leader (cl.Member_ID IS NULL) and where the member's current Age is less than the p_max_member_age parameter. Finally, the procedure updates the club_leader table, setting the Year_Join column to the value of the p_assignment_year parameter for all rows where the Club_ID equals the selected v_optimal_club.",
    "plsql": "CREATE OR REPLACE PROCEDURE optimize_member_assignments(\n    p_min_club_ranking INTEGER,\n    p_max_member_age INTEGER,\n    p_target_nationality TEXT,\n    p_assignment_year TEXT,\n    p_leader_threshold INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_optimal_club INTEGER;\n    v_performance_score NUMERIC;\nBEGIN\n    SELECT \"Club_ID\" INTO v_optimal_club\n    FROM \"club\"\n    WHERE \"Overall_Ranking\" BETWEEN p_min_club_ranking AND p_leader_threshold\n    ORDER BY \"Overall_Ranking\"\n    LIMIT 1;\n    \n    WITH performance_analysis AS (\n        SELECT \"Club_ID\", \"Overall_Ranking\",\n               cume_dist() OVER (ORDER BY \"Overall_Ranking\") as perf_score\n        FROM \"club\"\n    )\n    SELECT perf_score INTO v_performance_score\n    FROM performance_analysis\n    WHERE \"Club_ID\" = v_optimal_club;\n    \n    UPDATE \"member\"\n    SET \"Age\" = p_max_member_age,\n        \"Nationality\" = p_target_nationality\n    WHERE \"Member_ID\" IN (\n        SELECT m.\"Member_ID\"\n        FROM \"member\" m\n        LEFT JOIN \"club_leader\" cl ON m.\"Member_ID\" = cl.\"Member_ID\"\n        WHERE cl.\"Member_ID\" IS NULL AND m.\"Age\" < p_max_member_age\n    );\n    \n    UPDATE \"club_leader\"\n    SET \"Year_Join\" = p_assignment_year\n    WHERE \"Club_ID\" = v_optimal_club;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL optimize_member_assignments(10, 25, 'Australia', '2024', 50);",
      "CALL optimize_member_assignments(1, 30, 'USA', '2023', 100);",
      "CALL optimize_member_assignments(20, 35, 'Canada', '2025', 75);",
      "CALL optimize_member_assignments(5, 28, 'UK', '2024', 60);",
      "CALL optimize_member_assignments(15, 40, 'Germany', '2023', 80);"
    ],
    "summary": "Create a stored procedure named optimize_member_assignments with parameters p_min_club_ranking (INTEGER), p_max_member_age (INTEGER), p_target_nationality (TEXT), p_assignment_year (TEXT), and p_leader_threshold (INTEGER). Select the optimal club based on ranking range. Calculate its performance percentile. Update the age and nationality for members not assigned as leaders and below the age threshold. Update the join year for leaders in the optimal club.",
    "natural_language": "Please construct a stored procedure designated as 'optimize_member_assignments'. This procedure shall accept the following parameters: p_min_club_ranking of type INTEGER, p_max_member_age of type INTEGER, p_target_nationality of type TEXT, p_assignment_year of type TEXT, and p_leader_threshold of type INTEGER. The procedure's logic must first identify the optimal club according to the specified ranking range. Subsequently, it is required to compute the performance percentile for said club. Following this, for members who are not designated as leaders and whose age is below the provided threshold, their age and nationality fields should be updated. Finally, for those members who hold leadership positions within the optimal club, their join year must be updated accordingly.",
    "id": 59,
    "generated_ir": "Write a PostgreSQL PLpgSQL stored procedure named optimize_member_assignments that accepts five input parameters: an integer p_min_club_ranking, an integer p_max_member_age, a text p_target_nationality, a text p_assignment_year, and an integer p_leader_threshold. The procedure first declares two local variables: an integer v_optimal_club and a numeric v_performance_score. It begins execution by selecting a single Club_ID from the club table, assigning it to v_optimal_club, where the Overall_Ranking column value falls between the p_min_club_ranking parameter and the p_leader_threshold parameter, ordering the results by Overall_Ranking in ascending order and limiting the result to the first row. Next, using a common table expression named performance_analysis, it calculates a cumulative distribution percentile (perf_score) for each club by applying the cume_dist() window function over all clubs ordered by their Overall_Ranking; it then selects the perf_score value from this CTE where the Club_ID matches the previously identified v_optimal_club and stores this value into the v_performance_score variable. The procedure then performs an update on the member table, setting the Age column to the value of p_max_member_age and the Nationality column to the value of p_target_nationality for all members whose Member_ID is found in a subquery; this subquery selects Member_ID from the member table (aliased as m), performing a left join with the club_leader table (aliased as cl) on m.Member_ID = cl.Member_ID, and includes only those members where no matching record exists in club_leader (cl.Member_ID IS NULL) and where the member's current Age is less than the p_max_member_age parameter. Finally, the procedure updates the club_leader table, setting the Year_Join column to the value of the p_assignment_year parameter for all rows where the Club_ID equals the selected v_optimal_club."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `count_heads_in_department` that accepts three input parameters: `p_department_id` of type `integer`, `min_age` of type `real`, and `max_age` of type `real`. The purpose of this procedure is to insert new records into the `management` table. Specifically, it inserts the value of the `p_department_id` parameter into the `\"department_ID\"` column, the `\"head_ID\"` from the `head` table into the `\"head_ID\"` column, and the literal string `'No'` into the `\"temporary_acting\"` column. The selection of `head_ID` values from the `head` table is based on two conditions: first, the `\"age\"` column of the `head` table must be inclusively between the `min_age` and `max_age` parameters; and second, the `\"head_ID\"` from the `head` table must not already exist in the `management` table for the specific `department_ID` provided by the `p_department_id` parameter. This second condition is checked by a subquery that selects `\"head_ID\"` from the `management` table where the `\"department_ID\"` column matches the `p_department_id` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE count_heads_in_department(IN p_department_id integer, IN min_age real, IN max_age real)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO management (\"department_ID\", \"head_ID\", \"temporary_acting\")\n    SELECT p_department_id, h.\"head_ID\", 'No'\n    FROM head h\n    WHERE h.\"age\" BETWEEN min_age AND max_age\n    AND h.\"head_ID\" NOT IN (\n        SELECT m.\"head_ID\" \n        FROM management m \n        WHERE m.\"department_ID\" = p_department_id\n    );\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL count_heads_in_department(1, 65.0, 70.0);",
      "CALL count_heads_in_department(2, 60.0, 75.0);",
      "CALL count_heads_in_department(3, 68.0, 69.0);",
      "CALL count_heads_in_department(1, 67.0, 68.0);",
      "CALL count_heads_in_department(2, 66.0, 70.0);"
    ],
    "summary": "Create a stored procedure named `count_heads_in_department` that takes a department ID, a minimum age, and a maximum age as parameters. Insert records into the `management` table for the given department ID, using 'No' for the `temporary_acting` column. The `head_ID` values are selected from the `head` table where the head's age is between the provided min and max age, and the head is not already associated with the given department in the `management` table.",
    "natural_language": "Construct a stored procedure designated as `count_heads_in_department`. This procedure shall accept three input parameters: a department identifier, a minimum age threshold, and a maximum age threshold. Its function is to insert records into the `management` table corresponding to the specified department. The `temporary_acting` column for these new entries must be populated with the value 'No'. The `head_ID` values for insertion are to be derived from the `head` table, selecting those heads whose age falls within the stipulated minimum and maximum range. Furthermore, a head is only eligible if a pre-existing association between that head and the given department does not already reside within the `management` table.",
    "id": 60,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `count_heads_in_department` that accepts three input parameters: `p_department_id` of type `integer`, `min_age` of type `real`, and `max_age` of type `real`. The purpose of this procedure is to insert new records into the `management` table. Specifically, it inserts the value of the `p_department_id` parameter into the `\"department_ID\"` column, the `\"head_ID\"` from the `head` table into the `\"head_ID\"` column, and the literal string `'No'` into the `\"temporary_acting\"` column. The selection of `head_ID` values from the `head` table is based on two conditions: first, the `\"age\"` column of the `head` table must be inclusively between the `min_age` and `max_age` parameters; and second, the `\"head_ID\"` from the `head` table must not already exist in the `management` table for the specific `department_ID` provided by the `p_department_id` parameter. This second condition is checked by a subquery that selects `\"head_ID\"` from the `management` table where the `\"department_ID\"` column matches the `p_department_id` parameter."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named update_festival_result that accepts two input parameters: festival_id of type integer and new_result of type text. The procedure performs an update operation on the music_festival table, specifically targeting the Result column. It sets the Result column to the value provided by the new_result parameter for the row where the ID column matches the value of the festival_id parameter. The procedure does not include any conditional logic beyond the WHERE clause used to identify the specific row to update based on the festival_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_festival_result(IN festival_id integer, IN new_result text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    UPDATE \"music_festival\"\n    SET \"Result\" = new_result\n    WHERE \"ID\" = festival_id;\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL update_festival_result(1, 'Winner');",
      "CALL update_festival_result(2, 'Runner-up');",
      "CALL update_festival_result(3, 'Disqualified');",
      "CALL update_festival_result(1, 'Cancelled');",
      "CALL update_festival_result(2, 'Postponed');"
    ],
    "summary": "Create a stored procedure named update_festival_result that takes an integer festival_id and a text new_result. Update the music_festival table, setting the Result column to new_result where the ID matches festival_id.",
    "natural_language": "Create a stored procedure, which should be named update_festival_result, that accepts two distinct input parameters: an integer specifically designated as festival_id and a text string referred to as new_result. This procedure must perform an update operation on the music_festival table, meticulously setting the value within the Result column to the provided new_result string, but only for those precise rows where the existing ID column value perfectly corresponds to the supplied festival_id parameter.",
    "id": 61,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named update_festival_result that accepts two input parameters: festival_id of type INTEGER and new_result of type TEXT. The procedure performs an UPDATE operation on the music_festival table. It sets the Result column to the value provided in the new_result parameter, but only for the row where the ID column exactly matches the value provided in the festival_id parameter. The procedure does not declare any local variables, does not contain any complex control flow or business logic beyond the conditional update, and does not return a value. Its sole purpose is to modify a single record in the music_festival table based on the provided identifiers."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named migrate_students_by_distance that accepts two text parameters, p_from_city and p_to_city, representing source and destination city codes, declares a local variable v_distance of type bigint, and begins by querying the Direct_distance table to retrieve a single distance value where the city1_code and city2_code columns match the two input parameters in either order, storing the result in v_distance; if v_distance is not null, the procedure then executes an update on the Student table, setting the city_code column to the value of p_to_city for every row where the city_code column currently equals p_from_city, but only if the retrieved v_distance is less than 1000.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_students_by_distance(p_from_city text, p_to_city text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_distance bigint;\nBEGIN\n    SELECT distance INTO v_distance \n    FROM \"Direct_distance\" \n    WHERE (city1_code = p_from_city AND city2_code = p_to_city) \n       OR (city1_code = p_to_city AND city2_code = p_from_city);\n    \n    IF v_distance IS NOT NULL THEN\n        UPDATE \"Student\" \n        SET city_code = p_to_city \n        WHERE city_code = p_from_city AND v_distance < 1000;\n    END IF;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL migrate_students_by_distance('BAL', 'PIT');",
      "CALL migrate_students_by_distance('PHL', 'BAL');",
      "CALL migrate_students_by_distance('PIT', 'PHL');",
      "CALL migrate_students_by_distance('BAL', 'ATL');",
      "CALL migrate_students_by_distance('PHL', 'ATL');"
    ],
    "summary": "Create a stored procedure named migrate_students_by_distance that moves students from a source city to a target city, but only if the distance between the two cities (retrieved from the Direct_distance table) is less than 1000.",
    "natural_language": "What stored procedure can be created to migrate students from a source city to a target city, but only when the distance between them, as found in the Direct_distance table, is under 1000?",
    "id": 62,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `migrate_students_by_distance` that accepts two input parameters: `p_source_city_code` of data type `text` representing the city code of the source city from which students are to be migrated, and `p_target_city_code` of data type `text` representing the city code of the target city to which students are to be migrated. The procedure operates within the `address_1` database. The purpose of this procedure is to update the `city_code` column for specific student records in the `Student` table, effectively migrating them from the source city to the target city, but only if a specific condition regarding geographical distance is met.\n\nThe procedure first declares a variable named `v_distance` of data type `bigint` to temporarily store the distance value retrieved from the database.\n\nThe core logic begins with a `SELECT` query that retrieves the `distance` column from the `Direct_distance` table. This query specifically looks for a single record where the `city1_code` column is equal to the `p_source_city_code` input parameter AND the `city2_code` column is equal to the `p_target_city_code` input parameter. The result of this query is stored into the `v_distance` variable. If no such record is found, the `v_distance` variable will be `NULL`.\n\nFollowing this retrieval, the procedure executes a conditional check using an `IF` statement. The condition checks if the `v_distance` variable is not `NULL` AND if the value of `v_distance` is strictly less than 1000.\n\nIf and only if this condition evaluates to `TRUE`, the procedure proceeds to execute an `UPDATE` statement on the `Student` table. This `UPDATE` statement sets the `city_code` column to the value of the `p_target_city_code` input parameter. The update is applied only to rows in the `Student` table where the current value of the `city_code` column is exactly equal to the `p_source_city_code` input parameter. This action migrates all students associated with the source city code to the target city code.\n\nIf the condition evaluates to `FALSE` (i.e., if `v_distance` is `NULL` or if `v_distance` is greater than or equal to 1000), the `UPDATE` statement is not executed, and no changes are made to the `Student` table. The procedure then completes its execution."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named restructure_club_data that takes five parameters: p_club_threshold of type INTEGER, p_member_nationality of type TEXT, p_leader_name of type TEXT, p_new_ranking of type INTEGER, and p_year_update of type TEXT. The procedure begins by declaring two local variables: v_max_club_id of type INTEGER to store the maximum Club_ID from the club table, and v_member_stats of type INTEGER to store the count of distinct Club_IDs from the club_leader table joined with the member table where the member's Nationality matches the p_member_nationality parameter. The procedure first executes a SELECT statement to find the maximum Club_ID from the club table and stores it in v_max_club_id. It then performs another SELECT statement to count the distinct Club_IDs from the club_leader table joined with the member table on Member_ID, where the member's Nationality matches the p_member_nationality parameter, storing the result in v_member_stats. Next, the procedure deletes rows from the club_leader table where the Club_ID is in a subquery that selects Club_IDs from the club table with an Overall_Ranking greater than the p_club_threshold parameter. Following the deletion, the procedure attempts to insert a new row into the club table with the following values: Club_ID as the maximum Club_ID found plus one (or 1 if no maximum exists), Overall_Ranking as p_new_ranking, Team_Leader as p_leader_name, and Club_Name as 'New Club ' concatenated with p_year_update. This insertion only occurs if there is no existing row in the club table with a Team_Leader equal to p_leader_name, and if a conflict on Club_ID occurs, the insertion does nothing.",
    "plsql": "CREATE OR REPLACE PROCEDURE restructure_club_data(\n    p_club_threshold INTEGER,\n    p_member_nationality TEXT,\n    p_leader_name TEXT,\n    p_new_ranking INTEGER,\n    p_year_update TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_max_club_id INTEGER;\n    v_member_stats INTEGER;\nBEGIN\n    SELECT MAX(\"Club_ID\") INTO v_max_club_id\n    FROM \"club\";\n    \n    SELECT COUNT(DISTINCT cl.\"Club_ID\") INTO v_member_stats\n    FROM \"club_leader\" cl\n    JOIN \"member\" m ON cl.\"Member_ID\" = m.\"Member_ID\"\n    WHERE m.\"Nationality\" = p_member_nationality;\n    \n    DELETE FROM \"club_leader\"\n    WHERE \"Club_ID\" IN (\n        SELECT c.\"Club_ID\"\n        FROM \"club\" c\n        WHERE c.\"Overall_Ranking\" > p_club_threshold\n    );\n    \n    INSERT INTO \"club\" (\"Club_ID\", \"Overall_Ranking\", \"Team_Leader\", \"Club_Name\")\n    SELECT \n        COALESCE(v_max_club_id, 0) + 1,\n        p_new_ranking,\n        p_leader_name,\n        'New Club ' || p_year_update\n    WHERE NOT EXISTS (\n        SELECT 1 FROM \"club\" WHERE \"Team_Leader\" = p_leader_name\n    )\n    ON CONFLICT (\"Club_ID\") DO NOTHING;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL restructure_club_data(50, 'Australia', 'John Doe', 10, '2023');",
      "CALL restructure_club_data(70, 'USA', 'Jane Smith', 20, '2024');",
      "CALL restructure_club_data(10, 'Australia', 'Mack Mitchell', 5, '2022');",
      "CALL restructure_club_data(90, 'Canada', 'Oscar Roan', 30, '2025');",
      "CALL restructure_club_data(60, 'UK', 'Tony Peters', 15, '2023');"
    ],
    "summary": "Create a stored procedure named restructure_club_data with parameters p_club_threshold (INTEGER), p_member_nationality (TEXT), p_leader_name (TEXT), p_new_ranking (INTEGER), and p_year_update (TEXT). Find the maximum Club_ID and count distinct clubs for a given nationality. Delete club leaders for clubs with a ranking above the threshold. Insert a new club with an incremented ID, the new ranking, the leader name, and a name containing the year, only if no club with that leader exists. On ID conflict, do nothing.",
    "natural_language": "Create procedure restructure_club_data with params p_club_threshold, p_member_nationality, p_leader_name, p_new_ranking, p_year_update. Get max Club_ID and count distinct clubs for given nationality. Delete leaders from clubs ranked above threshold. Insert new club with incremented ID, new ranking, leader name, and year-inclusive name if leader not present. On conflict, skip.",
    "id": 63,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `restructure_club_data` that accepts five input parameters: `p_club_threshold` of type `integer`, `p_member_nationality` of type `text`, `p_leader_name` of type `text`, `p_new_ranking` of type `integer`, and `p_year_update` of type `text`. The procedure begins by declaring local variables `v_max_club_id` of type `integer`, `v_club_count` of type `integer`, and `v_leader_exists` of type `boolean`. It first queries the `club` table to find the maximum value in the `Club_ID` column, storing the result into `v_max_club_id`. Next, it queries the `member` table, aliased as `m`, performing an inner join with the `club_leader` table, aliased as `cl`, on the condition that `m.Member_ID` equals `cl.Member_ID`. It counts the distinct `cl.Club_ID` values from this join where the `m.Nationality` column equals the `p_member_nationality` parameter, storing the result into `v_club_count`. The procedure then performs a `DELETE` operation on the `club_leader` table, targeting rows where the `Club_ID` exists in a subquery. This subquery selects the `Club_ID` from the `club` table where the `Overall_Ranking` column is greater than the `p_club_threshold` parameter. Following the deletion, the procedure checks for the existence of a leader by querying the `club` table. It sets `v_leader_exists` to `true` if there is at least one row where the `Team_Leader` column equals the `p_leader_name` parameter; otherwise, it sets `v_leader_exists` to `false`. If `v_leader_exists` is `false`, the procedure attempts to insert a new row into the `club` table. The `Club_ID` column for the new row is set to `v_max_club_id + 1`. The `Overall_Ranking` column is set to the `p_new_ranking` parameter. The `Team_Leader` column is set to the `p_leader_name` parameter. The `Club_Name` column is constructed by concatenating the `p_leader_name` parameter, the literal string `' ('`, the `p_year_update` parameter, and the literal string `')'`. This `INSERT` operation includes an `ON CONFLICT` clause that specifies to do nothing (i.e., skip the insertion) if a conflict arises on the `Club_ID` column."
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `insert_new_genre` that accepts a single input parameter. This parameter, named `new_genre`, is of type `TEXT` and represents the name of the new genre to be added to the database. The procedure begins by declaring a local variable named `max_gid` of type `INTEGER`. It then executes a `SELECT` statement to retrieve the maximum value currently present in the `gid` column of the `genre` table. The result of this `SELECT` statement is stored in the `max_gid` variable. Following this, the procedure performs an `INSERT` operation into the `genre` table. For the `gid` column, it calculates the value by taking the `max_gid` variable, applying the `COALESCE` function to it (which returns `max_gid` if it's not `NULL`, otherwise it returns `0`), and then adding `1` to the result. For the `genre` column, it uses the value provided by the `new_genre` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_genre(IN new_genre TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    max_gid INTEGER;\nBEGIN\n    SELECT MAX(\"gid\") INTO max_gid FROM \"genre\";\n    INSERT INTO \"genre\" (\"gid\", \"genre\") VALUES (COALESCE(max_gid, 0) + 1, new_genre);\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "classification",
      "directed_by",
      "director",
      "genre",
      "made_by",
      "producer"
    ],
    "call_sqls": [
      "CALL insert_new_genre('Action');",
      "CALL insert_new_genre('Comedy');",
      "CALL insert_new_genre('Drama');",
      "CALL insert_new_genre('Science Fiction');",
      "CALL insert_new_genre('Horror');"
    ],
    "summary": "Create a stored procedure named insert_new_genre that takes a new genre name. Find the maximum existing genre ID. Insert a new genre record with an ID calculated by incrementing the maximum ID (or starting at 1 if none exist) and the provided genre name.",
    "natural_language": "Create procedure insert_new_genre to add a new genre. It finds the max current genre ID, increments it (or uses 1 if none), and inserts the new record.",
    "id": 64,
    "generated_ir": "Write a PL/pgSQL stored procedure named `insert_new_genre` that accepts a single input parameter. This parameter, named `new_genre`, is of type `TEXT` and represents the name of the new genre to be added to the database. The procedure begins by declaring a local variable named `max_gid` of type `INTEGER`. It then executes a `SELECT` statement to retrieve the maximum value currently present in the `gid` column of the `genre` table. The result of this `SELECT` statement is stored in the `max_gid` variable. Following this, the procedure performs an `INSERT` operation into the `genre` table. For the `gid` column, it calculates the value by taking the `max_gid` variable, applying the `COALESCE` function to it (which returns `max_gid` if it's not `NULL`, otherwise it returns `0`), and then adding `1` to the result. For the `genre` column, it uses the value provided by the `new_genre` input parameter."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named adjust_championship_data that accepts a single input parameter p_threshold of type real, which serves as a control value to determine one of three distinct data modification paths. The procedure first declares a local variable v_current_year of type real and initializes it by extracting the four-digit year component from the system's current date using the EXTRACT(YEAR FROM CURRENT_DATE) function. The core logic is a conditional block that branches based on the value of p_threshold. If p_threshold is greater than zero, the procedure executes a DELETE operation on the \"Championship\" table, removing rows where the absolute value of the \"Number_of_Championships\" column, obtained via the abs() function, is less than the provided p_threshold AND where the \"Joined\" column value is less than the result of the expression v_current_year - 10 (i.e., the year joined is more than ten years before the current year). If p_threshold is exactly equal to zero, the procedure performs an INSERT operation into the \"Championship\" table, specifying the columns \"Institution_ID\", \"Nickname\", \"Joined\", and \"Number_of_Championships\". The data to insert is selected from the \"institution\" table (aliased as i), where the institution's \"Enrollment\" column is greater than 30000 AND where a correlated subquery using NOT EXISTS confirms that no corresponding record already exists in the \"Championship\" table (aliased as c) with a matching \"Institution_ID\". For each qualifying institution row, the inserted values are: the i.\"Institution_ID\", a constructed nickname using the CONCAT function to combine the literal string 'Zero-' with a substring of the i.\"Team\" column starting at the first character and taking the next seven characters (via SUBSTRING(i.\"Team\" FROM 1 FOR 7)), the v_current_year for the \"Joined\" value, and the literal number 0 for \"Number_of_Championships\". For any other case where p_threshold is not greater than and not equal to zero (i.e., it is a negative number), the procedure executes a different DELETE operation on the \"Championship\" table, removing rows where either the \"Number_of_Championships\" column is less than zero OR where the \"Joined\" column value is greater than the v_current_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_championship_data(p_threshold real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_year real;\nBEGIN\n    v_current_year := EXTRACT(YEAR FROM CURRENT_DATE);\n\n    IF p_threshold > 0 THEN\n        DELETE FROM \"Championship\"\n        WHERE abs(\"Number_of_Championships\") < p_threshold\n        AND \"Joined\" < v_current_year - 10;\n    ELSIF p_threshold = 0 THEN\n        INSERT INTO \"Championship\" (\"Institution_ID\", \"Nickname\", \"Joined\", \"Number_of_Championships\")\n        SELECT i.\"Institution_ID\", CONCAT('Zero-', SUBSTRING(i.\"Team\" FROM 1 FOR 7)), v_current_year, 0\n        FROM \"institution\" i\n        WHERE i.\"Enrollment\" > 30000\n        AND NOT EXISTS (SELECT 1 FROM \"Championship\" c WHERE c.\"Institution_ID\" = i.\"Institution_ID\");\n    ELSE\n        DELETE FROM \"Championship\"\n        WHERE \"Number_of_Championships\" < 0\n        OR \"Joined\" > v_current_year;\n    END IF;\nEND;\n$$;",
    "database_name": "institution_sports",
    "tables": [
      "Championship",
      "institution"
    ],
    "call_sqls": [
      "CALL adjust_championship_data(1.5);",
      "CALL adjust_championship_data(0);",
      "CALL adjust_championship_data(-1.0);",
      "CALL adjust_championship_data(0.5);",
      "CALL adjust_championship_data(2.0);"
    ],
    "summary": "Create a stored procedure named adjust_championship_data that accepts a threshold (real). Get the current year. If threshold > 0, delete rows where absolute(number_of_championships) < threshold and joined < (current_year - 10). If threshold = 0, insert rows for institutions with enrollment > 30000 not already in Championship, with nickname 'Zero-' + team substring, joined=current_year, number_of_championships=0. If threshold < 0, delete rows where number_of_championships < 0 or joined > current_year.",
    "natural_language": "Write a stored procedure called adjust_championship_data that takes a real number threshold. First, determine the current year. If the threshold is greater than zero, remove all records where the absolute value of number_of_championships is below the threshold and the joined year is more than ten years before the current year. If the threshold equals zero, add new records for any institution with an enrollment over 30000 that isn't already in the Championship table; set their nickname to 'Zero-' plus a substring of the team name, their joined year to the current year, and their number_of_championships to zero. If the threshold is less than zero, delete any rows where number_of_championships is negative or the joined year is in the future relative to the current year.",
    "id": 65,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named adjust_championship_data that accepts one input parameter: threshold of type REAL. The procedure declares a local variable current_year of type INTEGER, initialized by extracting the year component from the current system date using the EXTRACT(YEAR FROM CURRENT_DATE) function.\n\nThe procedure performs conditional operations based on the value of the threshold parameter.\n\nIf the threshold is greater than zero, the procedure executes a DELETE operation on the Championship table. It deletes all rows where the absolute value of the Number_of_Championships column is less than the threshold parameter and where the Joined column (representing the year the institution joined) is more than ten years before the current_year variable, specifically where current_year - Joined > 10.\n\nIf the threshold is equal to zero, the procedure executes an INSERT operation into the Championship table. It inserts new records for institutions that meet the following criteria: the institution must exist in the institution table with an Enrollment value greater than 30000, and the institution must not already have a corresponding record in the Championship table, determined by a non-matching Institution_ID. For each qualifying institution, the procedure inserts a row with the following values: the Institution_ID from the institution table; the Nickname set to the string 'Zero-' concatenated with a substring of the Team name from the institution table, taking the first three characters; the Joined year set to the current_year variable; and the Number_of_Championships set to 0.0.\n\nIf the threshold is less than zero, the procedure executes a DELETE operation on the Championship table. It deletes all rows where the Number_of_Championships column is less than zero or where the Joined column is greater than the current_year variable, indicating a future year."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_song_catalog that accepts three input parameters: a real number parameter p_min_sales representing a minimum sales threshold, a real number parameter p_max_position representing a maximum chart position threshold, and a text parameter p_operation specifying the action to perform. The procedure begins by declaring a local integer variable v_current_year and a record variable v_song_rec, then extracts the current year from the system date and assigns it to v_current_year. It then enters a loop that iterates over each row returned by a SELECT query on the song table, fetching the Song_ID, Title, Singer_ID, Sales, and Highest_Position columns for every song where the Sales column value is strictly greater than the p_min_sales parameter. For each fetched song record, the procedure first checks if the song's Highest_Position is less than or equal to the p_max_position parameter. If true, it evaluates the p_operation parameter: if p_operation is exactly the string 'boost', it executes an UPDATE on the song table, multiplying the Sales value by 1.2 for the specific row matching the current song's Song_ID; if p_operation is exactly 'archive', it performs an INSERT into the song table, creating a new record with a Song_ID equal to the current song's Song_ID plus 1000, a Title formed by trimming whitespace from the current song's Title and appending the string ' Archive', the same Singer_ID, a Sales value equal to half (0.5 times) the current song's Sales, and a Highest_Position value equal to the current song's Highest_Position plus 10; if p_operation is exactly 'premium', it executes an UPDATE on the song table, multiplying the Sales value by 1.5 for the row matching the current song's Song_ID; for any other value of p_operation, it executes a DELETE operation on the song table, removing the row where Song_ID matches the current song's Song_ID. If the initial condition on Highest_Position is false, the procedure then checks if the current song's Sales value is greater than twice (2 times) the p_min_sales parameter; if true, it executes an UPDATE on the song table, multiplying the Sales value by 1.1 for the row matching the current song's Song_ID. If neither of the previous conditions is met, it executes an UPDATE on the song table, incrementing the Highest_Position value by 1 for the row matching the current song's Song_ID. The loop continues until all songs meeting the initial Sales > p_min_sales condition have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_song_catalog(\n    p_min_sales REAL,\n    p_max_position REAL,\n    p_operation TEXT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_current_year INTEGER;\n    v_song_rec RECORD;\nBEGIN\n    v_current_year := EXTRACT(YEAR FROM CURRENT_DATE);\n    \n    FOR v_song_rec IN \n        SELECT \"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\"\n        FROM song\n        WHERE \"Sales\" > p_min_sales\n    LOOP\n        IF v_song_rec.\"Highest_Position\" <= p_max_position THEN\n            IF p_operation = 'boost' THEN\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * 1.2 \n                WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n            ELSIF p_operation = 'archive' THEN\n                INSERT INTO song (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n                VALUES (v_song_rec.\"Song_ID\" + 1000, TRIM(v_song_rec.\"Title\") || ' Archive', \n                       v_song_rec.\"Singer_ID\", v_song_rec.\"Sales\" * 0.5, v_song_rec.\"Highest_Position\" + 10);\n            ELSIF p_operation = 'premium' THEN\n                UPDATE song \n                SET \"Sales\" = \"Sales\" * 1.5 \n                WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n            ELSE\n                DELETE FROM song WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n            END IF;\n        ELSIF v_song_rec.\"Sales\" > p_min_sales * 2 THEN\n            UPDATE song \n            SET \"Sales\" = \"Sales\" * 1.1 \n            WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n        ELSE\n            UPDATE song \n            SET \"Highest_Position\" = \"Highest_Position\" + 1 \n            WHERE \"Song_ID\" = v_song_rec.\"Song_ID\";\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL process_song_catalog(500000.0, 5.0, 'boost');",
      "CALL process_song_catalog(300000.0, 10.0, 'archive');",
      "CALL process_song_catalog(1000000.0, 3.0, 'premium');",
      "CALL process_song_catalog(200000.0, 15.0, 'delete');",
      "CALL process_song_catalog(750000.0, 8.0, 'boost');"
    ],
    "summary": "Create a stored procedure named process_song_catalog with parameters p_min_sales (REAL), p_max_position (REAL), and p_operation (TEXT). Loop through songs where Sales > p_min_sales. For each song, if Highest_Position <= p_max_position: if p_operation is 'boost', update Sales by multiplying by 1.2; if 'archive', insert a new song with ID+1000, title + ' Archive', same singer, Sales halved, and Highest_Position+10; if 'premium', update Sales by multiplying by 1.5; else delete the song. Else if Sales > 2 * p_min_sales, update Sales by multiplying by 1.1. Else, increment Highest_Position by 1.",
    "natural_language": "Write a stored procedure called process_song_catalog that takes p_min_sales (REAL), p_max_position (REAL), and p_operation (TEXT) as parameters. Iterate through all songs where Sales exceed p_min_sales. For each song, check if its Highest_Position is less than or equal to p_max_position. If true, then: when p_operation is 'boost', increase Sales by 20%; when it's 'archive', insert a new archived record with the original ID plus 1000, append ' Archive' to the title, keep the singer, halve the Sales, and add 10 to the Highest_Position; when it's 'premium', increase Sales by 50%; for any other operation value, delete the song. If the first condition is false but Sales are greater than twice p_min_sales, then increase Sales by 10%. If neither condition is met, add 1 to the song's Highest_Position.",
    "id": 66,
    "generated_ir": "Write a PL/pgSQL stored procedure named process_song_catalog that accepts three parameters: p_min_sales of type REAL, p_max_position of type REAL, and p_operation of type TEXT. The procedure does not return a value. It begins by declaring a cursor named song_cursor that selects all columns from the song table where the Sales column is greater than the input parameter p_min_sales. It then declares local variables to hold each column from the song table for the current row: v_song_id of type INTEGER, v_title of type TEXT, v_singer_id of type INTEGER, v_sales of type REAL, and v_highest_position of type REAL. The procedure opens the cursor and enters a loop that fetches each row from the cursor into the corresponding local variables. The loop continues until no more rows are found. For each fetched row, the procedure checks if the v_highest_position is less than or equal to the input parameter p_max_position. If this condition is true, it evaluates the p_operation parameter. If p_operation is exactly the string 'boost', it updates the current song's Sales in the song table by setting Sales to v_sales multiplied by 1.20 (a 20% increase) where the Song_ID equals v_song_id. If p_operation is exactly the string 'archive', it performs an INSERT into the song table with the following values: Song_ID set to v_song_id plus 1000, Title set to v_title concatenated with the string ' Archive', Singer_ID set to v_singer_id, Sales set to v_sales divided by 2.0 (halved), and Highest_Position set to v_highest_position plus 10.0. If p_operation is exactly the string 'premium', it updates the current song's Sales in the song table by setting Sales to v_sales multiplied by 1.50 (a 50% increase) where the Song_ID equals v_song_id. For any other value of p_operation, it deletes the current song from the song table where the Song_ID equals v_song_id. If the first condition (v_highest_position <= p_max_position) is false, the procedure then checks if v_sales is greater than twice the p_min_sales (i.e., v_sales > 2 * p_min_sales). If this second condition is true, it updates the current song's Sales in the song table by setting Sales to v_sales multiplied by 1.10 (a 10% increase) where the Song_ID equals v_song_id. If neither the first nor the second condition is met, it updates the current song's Highest_Position in the song table by setting Highest_Position to v_highest_position plus 1.0 where the Song_ID equals v_song_id. After processing all rows from the cursor, the procedure closes the cursor."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named process_country_rankings that accepts three parameters: p_min_score and p_max_score of type real, and p_score_type of type text. This procedure processes country rankings based on scores stored in the countries table. It begins by declaring several variables: v_country_record to hold each row from the countries table, v_score_value to store the score of the current country based on the specified score type, v_rank_position to track the rank of each country, v_total_countries to store the total number of countries, and v_percentile to calculate the percentile rank of each country. The procedure first counts the total number of countries and stores this count in v_total_countries. It initializes v_rank_position to zero. It then iterates over each country record, selecting columns id, name, overall_score, justice_score, health_score, education_score, economics_score, and politics_score from the countries table, ordered by the score type specified in p_score_type in descending order. The score type can be 'OVERALL', 'JUSTICE', 'HEALTH', 'EDUCATION', 'ECONOMICS', or 'POLITICS', defaulting to overall_score if an unrecognized type is provided. For each country, the procedure increments v_rank_position by one and assigns the appropriate score to v_score_value based on p_score_type. It calculates v_percentile as the percentile rank of the country using the formula (v_total_countries - v_rank_position + 1) * 100.0 / v_total_countries. If v_score_value is between p_min_score and p_max_score, the procedure updates the overall_score of the country based on its percentile: increasing it by 2.0 if the percentile is 90 or above, by 1.5 if between 75 and 90, by 1.0 if between 50 and 75, decreasing it by 0.5 if between 25 and 50, and decreasing it by 1.0 if below 25. The overall_score is constrained to a maximum of 100 and a minimum of 0 using the LEAST and GREATEST functions, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_country_rankings(\n    p_min_score real,\n    p_max_score real,\n    p_score_type text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_country_record RECORD;\n    v_score_value real;\n    v_rank_position integer;\n    v_total_countries integer;\n    v_percentile real;\nBEGIN\n    SELECT COUNT(*) INTO v_total_countries FROM countries;\n    v_rank_position := 0;\n    \n    FOR v_country_record IN \n        SELECT id, name, overall_score, justice_score, health_score, education_score, economics_score, politics_score\n        FROM countries \n        ORDER BY \n            CASE \n                WHEN p_score_type = 'OVERALL' THEN overall_score\n                WHEN p_score_type = 'JUSTICE' THEN justice_score\n                WHEN p_score_type = 'HEALTH' THEN health_score\n                WHEN p_score_type = 'EDUCATION' THEN education_score\n                WHEN p_score_type = 'ECONOMICS' THEN economics_score\n                WHEN p_score_type = 'POLITICS' THEN politics_score\n                ELSE overall_score\n            END DESC\n    LOOP\n        v_rank_position := v_rank_position + 1;\n        \n        v_score_value := CASE \n            WHEN p_score_type = 'OVERALL' THEN v_country_record.overall_score\n            WHEN p_score_type = 'JUSTICE' THEN v_country_record.justice_score\n            WHEN p_score_type = 'HEALTH' THEN v_country_record.health_score\n            WHEN p_score_type = 'EDUCATION' THEN v_country_record.education_score\n            WHEN p_score_type = 'ECONOMICS' THEN v_country_record.economics_score\n            WHEN p_score_type = 'POLITICS' THEN v_country_record.politics_score\n            ELSE v_country_record.overall_score\n        END;\n        \n        v_percentile := (v_total_countries - v_rank_position + 1) * 100.0 / v_total_countries;\n        \n        IF v_score_value >= p_min_score AND v_score_value <= p_max_score THEN\n            IF v_percentile >= 90.0 THEN\n                UPDATE countries \n                SET overall_score = LEAST(100, overall_score + 2.0)\n                WHERE id = v_country_record.id;\n            ELSIF v_percentile >= 75.0 THEN\n                UPDATE countries \n                SET overall_score = LEAST(100, overall_score + 1.5)\n                WHERE id = v_country_record.id;\n            ELSIF v_percentile >= 50.0 THEN\n                UPDATE countries \n                SET overall_score = LEAST(100, overall_score + 1.0)\n                WHERE id = v_country_record.id;\n            ELSIF v_percentile >= 25.0 THEN\n                UPDATE countries \n                SET overall_score = GREATEST(0, overall_score - 0.5)\n                WHERE id = v_country_record.id;\n            ELSE\n                UPDATE countries \n                SET overall_score = GREATEST(0, overall_score - 1.0)\n                WHERE id = v_country_record.id;\n            END IF;\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "CALL process_country_rankings(80.0, 100.0, 'OVERALL');",
      "CALL process_country_rankings(70.0, 95.0, 'HEALTH');",
      "CALL process_country_rankings(85.0, 100.0, 'EDUCATION');",
      "CALL process_country_rankings(60.0, 90.0, 'JUSTICE');",
      "CALL process_country_rankings(75.0, 100.0, 'ECONOMICS');"
    ],
    "summary": "Create a stored procedure named process_country_rankings that updates country overall scores based on their percentile rank for a specified score type (e.g., JUSTICE, HEALTH). It ranks countries by the chosen score, calculates their percentile, and adjusts the overall score up or down based on the percentile bracket, clamping the final score between 0 and 100. Only countries with scores within a provided minimum and maximum range are updated.",
    "natural_language": "Create a stored procedure, which should be named process_country_rankings, that meticulously updates the overall scores for countries by first carefully ranking them according to a user-specified score type, such as JUSTICE or HEALTH. Subsequently, it must calculate the precise percentile rank for each country based on this ordering. Following this, the procedure will thoughtfully adjust each country's overall score either upward or downward, depending on which specific percentile bracket it falls into, while also ensuring that the final computed score is always securely clamped within the acceptable range of 0 to 100. Importantly, this comprehensive update process should only be applied to those countries whose scores for the chosen metric fall gracefully within a provided minimum and maximum threshold.",
    "id": 67,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named process_country_rankings that accepts four input parameters: p_score_type of type text, p_min_score of type real, p_max_score of type real, and p_adjustment_factor of type real. The procedure meticulously updates the overall_score column in the countries table based on a user-specified score type, such as JUSTICE or HEALTH, and a provided score range.\n\nThe procedure begins by declaring a temporary table named ranked_countries with columns: country_id of type bigint, country_name of type text, selected_score of type real, and percentile_rank of type real. It also declares a variable v_total_count of type integer.\n\nFirst, the procedure validates the p_score_type parameter to ensure it matches one of the valid score columns: justice_score, health_score, education_score, economics_score, or politics_score. If the parameter does not match any of these, the procedure raises an exception.\n\nNext, the procedure populates the ranked_countries temporary table by selecting from the countries table. It selects the id, name, and the score column corresponding to p_score_type (using dynamic SQL to reference the correct column). It filters rows where the selected score is between p_min_score and p_max_score (inclusive). The results are ordered by the selected score in ascending order.\n\nThen, the procedure calculates the total number of rows in ranked_countries and stores it in v_total_count. It updates the percentile_rank column in ranked_countries for each row using the formula: (row_number - 1) * 100.0 / (v_total_count - 1), where row_number is the order of the row in the sorted result (with the lowest score having row_number 1). This computes the percentile rank from 0 to 100.\n\nAfter computing percentile ranks, the procedure updates the overall_score in the countries table for each country in ranked_countries. The new overall_score is calculated as: current overall_score + (p_adjustment_factor * (percentile_rank - 50) / 50). This adjustment increases the score if the percentile rank is above 50 and decreases it if below 50, scaled by p_adjustment_factor. The result is then clamped to the range 0 to 100 using a CASE statement: if the calculated value is less than 0, set to 0; if greater than 100, set to 100; otherwise, keep the calculated value.\n\nThe update is performed by joining the countries table with the ranked_countries temporary table on the id column matching country_id. The procedure ensures that only countries within the specified score range and with valid percentile ranks are updated.\n\nFinally, the procedure commits the updates and returns void. No explicit return value is provided, as the procedure modifies data in the countries table."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named TransformOrderData that accepts four input parameters: p_old_status of type text, p_new_status of type text, p_product_type of type text, and p_date_threshold of type timestamp with time zone. The procedure begins by declaring a record variable named v_order_record to hold rows from a query. It then executes a loop over the distinct set of order_id and customer_id values retrieved from a query that joins the Customer_Orders table (aliased as co) with the Order_Items table (aliased as oi) on the order_id column, and further joins the result with the Products table (aliased as pr) on the product_id column. The join query selects only those rows where the order_status_code column in the Customer_Orders table equals the p_old_status parameter, the order_date column in the Customer_Orders table is earlier than the p_date_threshold parameter, and the product_type_code column in the Products table equals the p_product_type parameter. For each distinct order_id and customer_id pair fetched into the v_order_record variable, the procedure performs an insert operation into the Customer_Orders table. The values inserted are: for the order_id column, a subquery that calculates the maximum existing order_id value from the Customer_Orders table, uses the COALESCE function to substitute 0 if the maximum is null, and adds 1000 to the result; for the customer_id column, the customer_id value from the current v_order_record; for the order_date column, the current timestamp provided by the CURRENT_TIMESTAMP function; and for the order_status_code column, the value of the p_new_status input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"TransformOrderData\"(\"p_old_status\" text, \"p_new_status\" text, \"p_product_type\" text, \"p_date_threshold\" timestamp with time zone)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"v_order_record\" RECORD;\nBEGIN\n    FOR \"v_order_record\" IN \n        SELECT DISTINCT co.\"order_id\", co.\"customer_id\"\n        FROM \"Customer_Orders\" co\n        JOIN \"Order_Items\" oi ON co.\"order_id\" = oi.\"order_id\"\n        JOIN \"Products\" pr ON oi.\"product_id\" = pr.\"product_id\"\n        WHERE co.\"order_status_code\" = \"p_old_status\"\n        AND co.\"order_date\" < \"p_date_threshold\"\n        AND pr.\"product_type_code\" = \"p_product_type\"\n    LOOP\n        INSERT INTO \"Customer_Orders\"(\"order_id\", \"customer_id\", \"order_date\", \"order_status_code\")\n        VALUES ((SELECT COALESCE(MAX(\"order_id\"), 0) + 1000 FROM \"Customer_Orders\"), \n                \"v_order_record\".\"customer_id\", \n                CURRENT_TIMESTAMP, \n                \"p_new_status\");\n    END LOOP;\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "CALL \"TransformOrderData\"('Part', 'Completed', 'Hardware', '2023-01-01 00:00:00+00:00');",
      "CALL \"TransformOrderData\"('Pending', 'Shipped', 'Clothes', '2022-12-31 23:59:59+00:00');",
      "CALL \"TransformOrderData\"('Processing', 'Cancelled', 'Hardware', '2023-06-01 12:00:00+00:00');",
      "CALL \"TransformOrderData\"('On Hold', 'Returned', 'Clothes', '2023-03-15 08:00:00+00:00');",
      "CALL \"TransformOrderData\"('Backordered', 'Delivered', 'Hardware', '2023-09-30 18:30:00+00:00');"
    ],
    "summary": "Create a stored procedure named TransformOrderData that takes an old status, a new status, a product type, and a date threshold. For each distinct order and customer where the order has the old status, is older than the threshold date, and contains the specified product type, insert a new order for that customer with the new status and a new order ID (max ID + 1000).",
    "natural_language": "Alright, so we need a stored procedure called TransformOrderData. Here's the deal: it's gotta take in an old order status, a new status, a specific kind of product, and a cutoff date. For every unique order and customer combo where the order's still stuck with the old status, is older than that cutoff date, and has that product type in it, we gotta make a brand new order for that same customer. This new order gets the new status and a fresh order IDjust take the highest existing ID and bump it up by 1000.",
    "id": 68,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named TransformOrderData that accepts four parameters: p_old_status of type text, p_new_status of type text, p_product_type of type text, and p_cutoff_date of type timestamp with time zone. The procedure begins by declaring a local variable v_new_order_id of type bigint. It first performs a SELECT operation to find the maximum order_id from the Customer_Orders table, adds 1000 to that value, and stores the result in v_new_order_id. Next, the procedure identifies all distinct order and customer combinations that meet specific criteria. It selects distinct Customer_Orders.order_id and Customer_Orders.customer_id from the Customer_Orders table, joining with the Order_Items table on Customer_Orders.order_id = Order_Items.order_id, and then joining with the Products table on Order_Items.product_id = Products.product_id. The selection criteria include matching the order_status_code column in Customer_Orders with the p_old_status parameter, ensuring the order_date column in Customer_Orders is earlier than the p_cutoff_date parameter, and matching the product_type_code column in Products with the p_product_type parameter. For each distinct order and customer combination that satisfies these conditions, the procedure inserts a new record into the Customer_Orders table. The new record sets order_id to v_new_order_id, customer_id to the customer_id from the identified combination, order_date to the current timestamp (using the CURRENT_TIMESTAMP function), and order_status_code to the p_new_status parameter. After each insertion, the procedure increments v_new_order_id by 1 to ensure a unique order_id for subsequent new orders. The procedure does not return any value; it performs the insert operations and then completes."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named manage_department_head that accepts two integer input parameters: p_dept_id, which represents a department identifier, and p_head_id, which represents a head identifier. The procedure first checks for the existence of a record in the department table where the Department_ID column exactly matches the provided p_dept_id parameter. If such a department record exists, the procedure performs an INSERT operation into the management table, specifying values for three columns: it sets the department_ID column to the p_dept_id parameter value, sets the head_ID column to the p_head_id parameter value, and sets the temporary_acting column to the literal string 'No'. If the conditional check fails, meaning no department record with the specified Department_ID is found, the procedure executes a DELETE operation on the management table, removing all rows where the head_ID column is equal to the provided p_head_id parameter value.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_department_head(p_dept_id integer, p_head_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM department WHERE \"Department_ID\" = p_dept_id) THEN\n        INSERT INTO management(\"department_ID\", \"head_ID\", temporary_acting)\n        VALUES (p_dept_id, p_head_id, 'No');\n    ELSE\n        DELETE FROM management WHERE \"head_ID\" = p_head_id;\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL manage_department_head(1, 5);",
      "CALL manage_department_head(2, 4);",
      "CALL manage_department_head(3, 6);",
      "CALL manage_department_head(99, 1);",
      "CALL manage_department_head(15, 2);"
    ],
    "summary": "Create a stored procedure named manage_department_head that accepts two integer parameters: p_dept_id and p_head_id. If a department with the given ID exists, insert a new record into the management table with the provided IDs and set temporary_acting to 'No'. If the department does not exist, delete all records from the management table where the head_ID matches the provided p_head_id.",
    "natural_language": "Create a stored procedure called manage_department_head that takes two integer inputs: p_dept_id and p_head_id. If the specified department exists, insert a new management record with these IDs and set temporary_acting to 'No'. If the department does not exist, remove all management records where the head_ID equals the provided p_head_id.",
    "id": 69,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named manage_department_head that accepts two integer input parameters: p_dept_id to identify a department and p_head_id to identify a head. The procedure operates on the department_management database and involves conditional logic based on the existence of a department.\n\nFirst, the procedure checks if a department with the specified p_dept_id exists in the department table by performing a SELECT query on the Department_ID column, using the p_dept_id parameter as the search condition. The existence is determined by the presence of at least one matching row.\n\nIf the department exists (i.e., the SELECT query returns a row), the procedure inserts a new record into the management table. The inserted row includes the following column values: the p_dept_id parameter for the department_ID column, the p_head_id parameter for the head_ID column, and the literal string 'No' for the temporary_acting column.\n\nIf the department does not exist (i.e., the SELECT query returns no rows), the procedure executes a DELETE operation on the management table. This deletion removes all rows where the head_ID column matches the provided p_head_id parameter.\n\nThe procedure does not return any value; it is a void procedure that performs either an INSERT or a DELETE based on the conditional check."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `archive_old_memberships` that accepts two input parameters: `p_club_id` of type `integer`, representing the unique identifier of a club, and `p_cutoff_year` of type `integer`, representing a threshold year. The procedure begins by declaring a cursor named `v_member_cursor`. This cursor is designed to select specific member information by joining the `club_leader` table (aliased as `cl`) with the `member` table (aliased as `m`). The join condition links rows where the `\"Member_ID\"` column in `club_leader` matches the `\"Member_ID\"` column in `member`. The selection criteria for the cursor are as follows: it retrieves rows from the joined tables where the `\"Club_ID\"` column in the `club_leader` table is equal to the value provided in the `p_club_id` parameter, AND where the year extracted from the `\"Year_Join\"` column in the `club_leader` table is less than the value provided in the `p_cutoff_year` parameter. To extract the year, the `TO_DATE` function is first used to convert the string value in the `\"Year_Join\"` column into a date type, assuming a 'YYYY' format, and then the `EXTRACT(YEAR FROM ...)` function is applied to get the year component. For each matching record, the cursor selects the `\"Member_ID\"` from the `club_leader` table and the `\"Name\"` from the `member` table. A record variable named `v_member_rec` is also declared to hold the data fetched from the cursor.\n\nThe executable part of the procedure starts by opening the `v_member_cursor`. It then enters a loop. Inside the loop, it attempts to fetch the next row from `v_member_cursor` into the `v_member_rec` record variable. Immediately after the fetch operation, it checks if no row was found (`NOT FOUND`). If no row was found, the loop is exited. If a row was successfully fetched, the procedure executes a `DELETE` statement. This `DELETE` statement targets the `club_leader` table and removes rows where the `\"Club_ID\"` column matches the `p_club_id` parameter AND the `\"Member_ID\"` column matches the `\"Member_ID\"` value currently stored in `v_member_rec` (which was fetched from the cursor). This process effectively removes club leadership records for members who joined before the specified cutoff year for the given club. The loop continues until all relevant records identified by the cursor have been processed. After the loop finishes, the `v_member_cursor` is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_old_memberships(p_club_id integer, p_cutoff_year integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_cursor CURSOR FOR \n        SELECT cl.\"Member_ID\", m.\"Name\" \n        FROM club_leader cl \n        JOIN member m ON cl.\"Member_ID\" = m.\"Member_ID\" \n        WHERE cl.\"Club_ID\" = p_club_id AND EXTRACT(YEAR FROM TO_DATE(cl.\"Year_Join\", 'YYYY')) < p_cutoff_year;\n    v_member_rec RECORD;\nBEGIN\n    OPEN v_member_cursor;\n    LOOP\n        FETCH v_member_cursor INTO v_member_rec;\n        EXIT WHEN NOT FOUND;\n        DELETE FROM club_leader WHERE \"Club_ID\" = p_club_id AND \"Member_ID\" = v_member_rec.\"Member_ID\";\n    END LOOP;\n    CLOSE v_member_cursor;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL archive_old_memberships(1, 2019);",
      "CALL archive_old_memberships(3, 2016);",
      "CALL archive_old_memberships(4, 2017);",
      "CALL archive_old_memberships(1, 2015);",
      "CALL archive_old_memberships(3, 2018);"
    ],
    "summary": "Create a stored procedure named archive_old_memberships that takes a club ID and a cutoff year. For members of the specified club who joined before the cutoff year, delete their records from the club_leader table.",
    "natural_language": "Develop a stored procedure called archive_old_memberships that accepts two parameters: a specific club identifier and a designated cutoff year. This procedure should meticulously identify all members belonging to the indicated club whose membership commencement date precedes the provided cutoff year and subsequently, permanently remove their corresponding entries from the club_leader table.",
    "id": 70,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named archive_old_memberships that accepts two input parameters: an integer parameter named specific_club_identifier to identify a specific club, and a text parameter named designated_cutoff_year to specify a cutoff year for membership commencement. The procedure does not return a value. It begins by performing a DELETE operation on the club_leader table. The deletion targets rows where the Club_ID column matches the specific_club_identifier parameter and the Year_Join column, which is stored as text, represents a year that is less than the designated_cutoff_year parameter. Since Year_Join is text, the comparison is performed by casting both the Year_Join column and the designated_cutoff_year parameter to integer types to ensure a proper numeric comparison. The condition is that the integer value of Year_Join is strictly less than the integer value of designated_cutoff_year. This operation permanently removes all records from the club_leader table for the specified club where the member's join year is earlier than the cutoff year. The procedure does not involve any explicit variable declarations, control flow statements, or additional SQL operations beyond this single DELETE statement."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `calculate_festival_statistics` that accepts one input parameter, `p_year`, which is of type `text` and represents the year for which statistics are to be calculated. The procedure declares three local variables: `v_festival_count` of type `integer` to store the count of music festivals, `v_total_weeks` of type `real` to accumulate the total weeks on top, and `v_avg_weeks` of type `real` to store the calculated average weeks on top. The procedure begins by executing a `SELECT` statement to count the number of records in the `music_festival` table. This count is stored in the `v_festival_count` variable. The `WHERE` clause for this `SELECT` statement filters records where the `Date_of_ceremony` column contains the `p_year` string as a substring, using the `LIKE` operator with wildcard characters (`%`). Next, another `SELECT` statement is executed to calculate the sum of values from the `Weeks_on_Top` column in the `volume` table. This sum is stored in the `v_total_weeks` variable. The `WHERE` clause for this `SELECT` statement filters records where the `Issue_Date` column contains the `p_year` string as a substring, again using the `LIKE` operator with wildcard characters. Following these data retrievals, a conditional `IF` statement checks if the `v_festival_count` is greater than 0. If `v_festival_count` is positive, the `v_avg_weeks` variable is calculated by dividing `v_total_weeks` by `v_festival_count`. Otherwise, if `v_festival_count` is 0 or less, `v_avg_weeks` is set to 0. Finally, an `INSERT` statement is executed to add a new record into the `volume` table. The values for the columns are determined as follows: `Volume_ID` is set to one greater than the maximum existing `Volume_ID` in the `volume` table, using a subquery with `COALESCE` to handle cases where no `Volume_ID` exists (defaulting to 0 before adding 1); `Volume_Issue` is set to the concatenated string 'Statistics:' followed by the `p_year` parameter; `Issue_Date` is set to the current date converted to `text` using `CURRENT_DATE::text`; `Weeks_on_Top` is set to the calculated `v_avg_weeks`; `Song` is set to the literal string 'Festival Stats'; and `Artist_ID` is set to `NULL`.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_festival_statistics(p_year text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_festival_count integer;\n    v_total_weeks real;\n    v_avg_weeks real;\nBEGIN\n    SELECT COUNT(*) INTO v_festival_count\n    FROM music_festival\n    WHERE \"Date_of_ceremony\" LIKE '%' || p_year || '%';\n\n    SELECT SUM(\"Weeks_on_Top\") INTO v_total_weeks\n    FROM volume\n    WHERE \"Issue_Date\" LIKE '%' || p_year || '%';\n\n    IF v_festival_count > 0 THEN\n        v_avg_weeks := v_total_weeks / v_festival_count;\n    ELSE\n        v_avg_weeks := 0;\n    END IF;\n\n    INSERT INTO volume (\"Volume_ID\", \"Volume_Issue\", \"Issue_Date\", \"Weeks_on_Top\", \"Song\", \"Artist_ID\")\n    VALUES (\n        (SELECT COALESCE(MAX(\"Volume_ID\"), 0) + 1 FROM volume),\n        'Statistics:' || p_year,\n        CURRENT_DATE::text,\n        v_avg_weeks,\n        'Festival Stats',\n        NULL\n    );\nEND;\n$$;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "CALL calculate_festival_statistics('2011');",
      "CALL calculate_festival_statistics('1986');",
      "CALL calculate_festival_statistics('2007');",
      "CALL calculate_festival_statistics('2008');",
      "CALL calculate_festival_statistics('2009');"
    ],
    "summary": "Create a stored procedure named calculate_festival_statistics that accepts a year as text. Count music festivals for that year and sum the total weeks on top from the volume table. Calculate the average weeks per festival. Insert a new record into the volume table with the statistics, including the calculated average, a descriptive issue, the current date, and a default song title.",
    "natural_language": "Please construct a stored procedure designated as 'calculate_festival_statistics' that receives a year parameter in text format. The procedure should ascertain the count of music festivals for the specified year and compute the summation of total weeks on top from the volume table. Subsequently, calculate the average weeks per festival. Finally, insert a new entry into the volume table containing these statistics, the computed average, a descriptive issue, the current date, and a default song title.",
    "id": 71,
    "generated_ir": "Write a PostgreSQL PL/pgSQL procedure named `calculate_festival_statistics` that accepts a single input parameter `p_year` of type `TEXT`. The procedure performs several calculations based on the input year and inserts a new record into the `volume` table with the computed statistics.\n\nFirst, the procedure declares three local variables: `festival_count` of type `INTEGER` to store the number of music festivals, `total_weeks` of type `REAL` to store the sum of weeks on top, and `avg_weeks` of type `REAL` to store the calculated average weeks per festival.\n\nThe procedure begins by executing a `SELECT` statement on the `music_festival` table to count the number of rows where the `Date_of_ceremony` column contains the substring specified by the `p_year` input parameter. This count is assigned to the `festival_count` variable.\n\nNext, the procedure executes another `SELECT` statement on the `volume` table to calculate the sum of the `Weeks_on_Top` column. This sum is assigned to the `total_weeks` variable.\n\nThen, the procedure calculates the average weeks per festival by dividing the `total_weeks` by the `festival_count`. This calculation is performed only if `festival_count` is greater than zero to avoid division by zero; if `festival_count` is zero, `avg_weeks` is set to zero. The result is assigned to the `avg_weeks` variable.\n\nFinally, the procedure performs an `INSERT` operation into the `volume` table. The new row includes the following values: for the `Volume_ID` column, a value is generated automatically (assuming a sequence or default); for the `Volume_Issue` column, a descriptive text is inserted, specifically the concatenation of the string 'Statistics for year ' and the `p_year` parameter; for the `Issue_Date` column, the current date is inserted using the `CURRENT_DATE` function; for the `Weeks_on_Top` column, the computed `avg_weeks` value is inserted; for the `Song` column, a default song title 'Statistical Summary' is inserted; and for the `Artist_ID` column, a default value of 0 is inserted (or NULL if applicable, but specified as 0 here). The procedure does not return a value; it completes after the insertion."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named transfer_pets_between_students that accepts four input parameters: p_source_student of type bigint representing the student identifier from whom pets will be transferred, p_target_student of type bigint representing the student identifier to whom pets will be transferred, p_pet_type_to_transfer of type text specifying the species or type of pet to be moved, and p_max_pets_to_transfer of type bigint defining the maximum number of pets of the specified type to transfer. The procedure declares a local variable v_transferred_count of type bigint initialized to zero to track the number of pets successfully transferred, a variable v_pet_record of type RECORD to hold fetched rows, and a cursor named v_cursor defined by a SELECT statement that queries the Pets table aliased as p, performing an inner join with the Has_Pet table aliased as hp on the condition that p.PetID equals hp.PetID, filtering the results where the hp.StuID matches the p_source_student parameter and the p.PetType equals the p_pet_type_to_transfer parameter, and limiting the result set to the number of rows specified by the p_max_pets_to_transfer parameter, selecting only the p.PetID column. The procedure opens the cursor, then enters a loop where it fetches the next row from the cursor into v_pet_record, exiting the loop when no more rows are found. For each fetched row, it executes a DELETE operation on the Has_Pet table, removing the row where the StuID column equals p_source_student and the PetID column equals the v_pet_record.PetID value from the cursor, then performs an INSERT operation into the Has_Pet table, adding a new row with the StuID column set to p_target_student and the PetID column set to v_pet_record.PetID, and increments the v_transferred_count variable by one. After the loop concludes, the procedure closes the cursor. Finally, it executes an UPDATE statement on the Pets table, setting the weight column to its current value multiplied by 1.1 for all rows where the PetID is found in a subquery that selects the PetID from the Has_Pet table for rows where the StuID equals the p_target_student parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_pets_between_students(\n    p_source_student bigint,\n    p_target_student bigint,\n    p_pet_type_to_transfer text,\n    p_max_pets_to_transfer bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_transferred_count bigint := 0;\n    v_pet_record RECORD;\n    v_cursor CURSOR FOR\n        SELECT p.\"PetID\"\n        FROM \"Pets\" p\n        INNER JOIN \"Has_Pet\" hp ON p.\"PetID\" = hp.\"PetID\"\n        WHERE hp.\"StuID\" = p_source_student\n        AND p.\"PetType\" = p_pet_type_to_transfer\n        LIMIT p_max_pets_to_transfer;\nBEGIN\n    OPEN v_cursor;\n    \n    LOOP\n        FETCH v_cursor INTO v_pet_record;\n        EXIT WHEN NOT FOUND;\n        \n        DELETE FROM \"Has_Pet\"\n        WHERE \"StuID\" = p_source_student\n        AND \"PetID\" = v_pet_record.\"PetID\";\n        \n        INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\")\n        VALUES (p_target_student, v_pet_record.\"PetID\");\n        \n        v_transferred_count := v_transferred_count + 1;\n    END LOOP;\n    \n    CLOSE v_cursor;\n    \n    UPDATE \"Pets\"\n    SET \"weight\" = \"weight\" * 1.1\n    WHERE \"PetID\" IN (\n        SELECT \"PetID\" FROM \"Has_Pet\"\n        WHERE \"StuID\" = p_target_student\n    );\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "CALL transfer_pets_between_students(1001, 1002, 'dog', 2);",
      "CALL transfer_pets_between_students(1002, 1003, 'cat', 1);",
      "CALL transfer_pets_between_students(1001, 1003, 'dog', 5);",
      "CALL transfer_pets_between_students(1003, 1001, 'cat', 3);",
      "CALL transfer_pets_between_students(1002, 1001, 'dog', 1);"
    ],
    "summary": "Create a stored procedure named transfer_pets_between_students that transfers a specified type and maximum number of pets from a source student to a target student. It updates ownership records and increases the weight of the transferred pets by 10% for the new owner.",
    "natural_language": "Create a stored procedure named transfer_pets_between_students that carefully orchestrates the transfer of a specified type and a defined maximum number of beloved pets from a designated source student over to a grateful target student. This intricate procedure meticulously updates all relevant pet ownership records and, as a welcoming gesture for the new owner, thoughtfully increases the weight of each transferred pet by a full ten percent.",
    "id": 72,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named transfer_pets_between_students that orchestrates the transfer of a specified type and a defined maximum number of pets from a source student to a target student. The procedure accepts three input parameters: p_source_stuid of type BIGINT representing the unique identifier of the source student from whom pets will be transferred, p_target_stuid of type BIGINT representing the unique identifier of the target student who will receive the pets, p_pet_type of type TEXT specifying the type of pets to be transferred (e.g., 'cat' or 'dog'), and p_max_count of type BIGINT defining the maximum number of pets to transfer.\n\nThe procedure declares several variables: v_transfer_count of type BIGINT initialized to 0 to track the actual number of pets transferred, v_pet_record of type RECORD to hold each pet's details during iteration, v_new_weight of type REAL to store the recalculated weight for each transferred pet, and v_pet_id_list of type BIGINT[] initialized as an empty array to temporarily store the PetIDs of pets selected for transfer.\n\nThe procedure first validates that both the source and target students exist in the Student table by performing two separate SELECT queries, each checking for the existence of a record where the StuID matches the respective input parameter. If either student does not exist, the procedure raises an exception and terminates.\n\nNext, the procedure identifies eligible pets for transfer by querying the Has_Pet and Pets tables. It selects up to p_max_count pets that are owned by the source student (Has_Pet.StuID = p_source_stuid), are of the specified type (Pets.PetType = p_pet_type), and are not already owned by the target student (ensuring no duplicate ownership). This is achieved by joining the Has_Pet table with the Pets table on Has_Pet.PetID = Pets.PetID and filtering out any pets where the PetID is already associated with the target student in the Has_Pet table. The query orders the results by PetID to ensure deterministic selection and limits the result set to p_max_count rows. The PetIDs of the selected pets are stored in the v_pet_id_list array.\n\nIf no eligible pets are found (the array is empty), the procedure raises a notice indicating that no pets match the criteria and exits without further action.\n\nThe procedure then iterates through each PetID in the v_pet_id_list array. For each PetID, it performs an UPDATE operation on the Has_Pet table to change the ownership from the source student to the target student: it sets the StuID column to p_target_stuid where the current StuID equals p_source_stuid and the PetID matches the current PetID in the iteration.\n\nConcurrently, for each transferred pet, the procedure calculates a new weight by increasing the current weight by 10%. It retrieves the current weight from the Pets table for the current PetID, computes v_new_weight as weight * 1.10, and updates the Pets table by setting the weight column to v_new_weight for that PetID.\n\nAfter each successful update of ownership and weight, the v_transfer_count variable is incremented by 1.\n\nOnce all pets in the list have been processed, the procedure commits the changes implicitly (as typical in a stored procedure) and outputs a summary message indicating the number of pets successfully transferred from the source student to the target student, along with the pet type and the weight increase applied. The procedure does not return a value but may use RAISE NOTICE to log the outcome."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named remove_person_data that accepts three input parameters: an integer parameter p_people_id to specify a person identifier, an integer parameter p_min_age to specify a minimum age threshold, and a text parameter p_country to specify a country name, and performs a single delete operation on the table named people, specifically removing all rows from the people table where the value in the column named People_ID is exactly equal to the provided p_people_id parameter, and simultaneously, the value in the column named Age is greater than or equal to the provided p_min_age parameter, and simultaneously, the value in the column named Country is exactly equal to the provided p_country parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_person_data(p_people_id integer, p_min_age integer, p_country text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM people \n    WHERE \"People_ID\" = p_people_id \n    AND \"Age\" >= p_min_age \n    AND \"Country\" = p_country;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL remove_person_data(1, 30, 'Canada');",
      "CALL remove_person_data(2, 35, 'Sweden');",
      "CALL remove_person_data(3, 25, 'United States');",
      "CALL remove_person_data(1, 40, 'Canada');",
      "CALL remove_person_data(2, 32, 'Sweden');"
    ],
    "summary": "Create a stored procedure named remove_person_data that deletes records from the people table. It uses three parameters: a specific People_ID, a minimum Age, and a Country. All conditions must be met for a row to be deleted.",
    "natural_language": "Delete from people where People_ID, Age, and Country match given parameters.",
    "id": 73,
    "generated_ir": "Write a PostgreSQL PL/pgSQL procedure named remove_person_data that deletes rows from the people table where the People_ID, Age, and Country columns exactly match the values provided as input parameters. The procedure takes three input parameters: p_people_id of type integer, which specifies the People_ID to match; p_age of type integer, which specifies the Age to match; and p_country of type text, which specifies the Country to match. The procedure performs a DELETE operation on the people table, applying a WHERE clause that includes three equality conditions: the People_ID column must equal the value of p_people_id, the Age column must equal the value of p_age, and the Country column must equal the value of p_country. The procedure does not return any value."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes five input parameters: p_building_id (text), p_min_enrollment (integer), p_max_enrollment (integer), p_founded_year (real), and p_conference_filter (text). The procedure begins by retrieving the Name column from the building table for the row where the building_id matches the value of p_building_id and stores this value in the local variable v_building_name. Next, it calculates the count of rows in the Institution table where the building_id matches p_building_id, the Enrollment column falls between p_min_enrollment and p_max_enrollment, the Founded column is greater than or equal to p_founded_year, and the Primary_Conference column contains the substring specified in p_conference_filter. This count is stored in the local variable v_institution_count. The procedure then evaluates the value of v_institution_count using conditional logic. If v_institution_count is greater than 0, it deletes rows from the Institution table where the building_id matches p_building_id and the Enrollment column is less than p_min_enrollment. If v_institution_count equals 0, it inserts a new row into the Institution table with the following values: Institution_id set to the concatenation of p_building_id and '-NEW', Institution set to 'New Institution for ' concatenated with v_building_name, Location set to 'Unknown Location', Founded set to p_founded_year, Type set to 'Private', Enrollment set to p_min_enrollment, Team set to 'New Team', Primary_Conference set to p_conference_filter, and building_id set to p_building_id. If v_institution_count is neither greater than 0 nor equal to 0, it updates the Primary_Conference column in the Institution table to the result of the enum_last function applied to a null text value for rows where the building_id matches p_building_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_building_institutions(\n    IN p_building_id text,\n    IN p_min_enrollment integer,\n    IN p_max_enrollment integer,\n    IN p_founded_year real,\n    IN p_conference_filter text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_building_name text;\n    v_institution_count integer;\nBEGIN\n    SELECT \"Name\" INTO v_building_name\n    FROM \"building\"\n    WHERE \"building_id\" = p_building_id;\n\n    SELECT COUNT(*) INTO v_institution_count\n    FROM \"Institution\" i\n    WHERE i.\"building_id\" = p_building_id\n      AND i.\"Enrollment\" BETWEEN p_min_enrollment AND p_max_enrollment\n      AND i.\"Founded\" >= p_founded_year\n      AND i.\"Primary_Conference\" LIKE '%' || p_conference_filter || '%';\n\n    IF v_institution_count > 0 THEN\n        DELETE FROM \"Institution\"\n        WHERE \"building_id\" = p_building_id\n          AND \"Enrollment\" < p_min_enrollment;\n    ELSIF v_institution_count = 0 THEN\n        INSERT INTO \"Institution\" (\"Institution_id\", \"Institution\", \"Location\", \"Founded\", \"Type\", \"Enrollment\", \"Team\", \"Primary_Conference\", \"building_id\")\n        VALUES (p_building_id || '-NEW', 'New Institution for ' || v_building_name, 'Unknown Location', p_founded_year, 'Private', p_min_enrollment, 'New Team', p_conference_filter, p_building_id);\n    ELSE\n        UPDATE \"Institution\"\n        SET \"Primary_Conference\" = enum_last(null::text)\n        WHERE \"building_id\" = p_building_id;\n    END IF;\nEND;\n$$;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "CALL process_building_institutions('1', 1000, 5000, 1900.0, 'Sun');",
      "CALL process_building_institutions('3', 500, 2000, 1850.0, 'none');",
      "CALL process_building_institutions('0', 100, 1000, 2000.0, 'Big Ten');",
      "CALL process_building_institutions('1', 100, 200, 1950.0, 'SEC');",
      "CALL process_building_institutions('2', 2000, 10000, 1800.0, 'ACC');"
    ],
    "summary": "Create a PL/pgSQL procedure with parameters p_building_id (text), p_min_enrollment (integer), p_max_enrollment (integer), p_founded_year (real), and p_conference_filter (text). Get the building name for p_building_id. Count institutions in that building where enrollment is between p_min_enrollment and p_max_enrollment, founded >= p_founded_year, and primary conference contains p_conference_filter. If count > 0, delete institutions in the building with enrollment < p_min_enrollment. If count = 0, insert a new institution with ID (p_building_id + '-NEW'), name 'New Institution for [building_name]', and other provided/default values. Otherwise, update the primary conference for institutions in the building using the enum_last function.",
    "natural_language": "Write a procedure that takes a building ID, a range for how many students are enrolled, a founding year, and something about a conference. First, find out the building's name. Then, see roughly how many institutions are in that building that have a decent number of students within that range, were founded around or after that year, and whose main conference is somewhat related to the given filter text. If you find a fair number of such places, remove any institutions in the building that have a pretty low enrollment. If you don't find any at all, add a new institution with a made-up ID based on the building, a generic name for that building, and some other typical details. Otherwise, if there's some other outcome, adjust the primary conference for institutions there using a special function.",
    "id": 74,
    "generated_ir": "Write a PLpgSQL stored procedure that takes five input parameters: p_building_id (text), p_min_enrollment (integer), p_max_enrollment (integer), p_founded_year (real), and p_conference_filter (text). The procedure begins by retrieving the Name column from the building table for the row where the building_id matches the value of p_building_id and stores this value in the local variable v_building_name. Next, it calculates the count of rows in the Institution table where the building_id matches p_building_id, the Enrollment column falls between p_min_enrollment and p_max_enrollment, the Founded column is greater than or equal to p_founded_year, and the Primary_Conference column contains the substring specified in p_conference_filter. This count is stored in the local variable v_institution_count. The procedure then evaluates the value of v_institution_count using conditional logic. If v_institution_count is greater than 0, it deletes rows from the Institution table where the building_id matches p_building_id and the Enrollment column is less than p_min_enrollment. If v_institution_count equals 0, it inserts a new row into the Institution table with the following values: Institution_id set to the concatenation of p_building_id and '-NEW', Institution set to 'New Institution for ' concatenated with v_building_name, Location set to 'Unknown Location', Founded set to p_founded_year, Type set to 'Private', Enrollment set to p_min_enrollment, Team set to 'New Team', Primary_Conference set to p_conference_filter, and building_id set to p_building_id. If v_institution_count is neither greater than 0 nor equal to 0, it updates the Primary_Conference column in the Institution table to the result of the enum_last function applied to a null text value for rows where the building_id matches p_building_id."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named generate_pet_summary_report that accepts four input parameters: a real number p_min_weight, a real number p_max_weight, a text string p_name_prefix, and a big integer p_advisor_id. The procedure begins by declaring local variables v_type_summary as text, v_total_students, v_pet_count as bigint, and v_heaviest_pet_weight, v_lightest_pet_weight as real. It first uses a common table expression named pet_counts to select the PetType column and count rows from the Pets table where the weight column value falls between p_min_weight and p_max_weight inclusive, grouping the results by PetType. It then aggregates the results from this CTE into the v_type_summary variable by using STRING_AGG to concatenate each PetType with its corresponding count, separated by a colon, with each pair joined by a comma and space. Next, it calculates v_total_students by counting distinct StuID values from the Student table after performing an inner join with the Has_Pet table on matching StuID and another inner join with the Pets table on matching PetID, filtering for rows where the Student.Advisor column equals the p_advisor_id parameter and the Pets.weight column is greater than p_min_weight. It then finds the maximum weight from the Pets table where the PetType column starts with the string in p_name_prefix and stores it in v_heaviest_pet_weight, and similarly finds the minimum weight under the same PetType condition and stores it in v_lightest_pet_weight. Following this, a conditional block executes: if v_heaviest_pet_weight is greater than p_max_weight, it inserts a new row into the Student table with StuID 8888, Fname 'Heavy', LName 'PetOwner', Age 25, Sex 'F', Major 999, Advisor set to p_advisor_id, and city_code 'SUM', but only if a student with StuID 8888 does not already exist; else if v_lightest_pet_weight is less than p_min_weight, it inserts a new row with StuID 8889, Fname 'Light', LName 'PetOwner', Age 22, Sex 'M', Major 888, Advisor p_advisor_id, and city_code 'SUM', provided a student with StuID 8889 does not already exist; otherwise, it inserts a row with StuID 8890, Fname 'Average', LName 'PetOwner', Age 20, Sex 'F', Major 777, Advisor p_advisor_id, and city_code 'SUM', conditional on the non-existence of StuID 8890. Finally, the procedure updates the Pets table for all rows where PetType starts with p_name_prefix, incrementing the pet_age column by one and adjusting the weight column using a CASE expression: if weight is less than p_min_weight, weight is multiplied by 1.2; if weight is greater than p_max_weight, weight is multiplied by 0.9; otherwise, weight remains unchanged.",
    "plsql": "CREATE OR REPLACE PROCEDURE generate_pet_summary_report(\n    p_min_weight real,\n    p_max_weight real,\n    p_name_prefix text,\n    p_advisor_id bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_type_summary text;\n    v_total_students bigint;\n    v_heaviest_pet_weight real;\n    v_lightest_pet_weight real;\n    v_pet_count bigint;\nBEGIN\n    WITH pet_counts AS (\n        SELECT \"PetType\", COUNT(*) as type_count\n        FROM \"Pets\"\n        WHERE \"weight\" BETWEEN p_min_weight AND p_max_weight\n        GROUP BY \"PetType\"\n    )\n    SELECT STRING_AGG(\"PetType\" || ':' || type_count::text, ', ') INTO v_type_summary\n    FROM pet_counts;\n    \n    SELECT COUNT(DISTINCT s.\"StuID\") INTO v_total_students\n    FROM \"Student\" s\n    INNER JOIN \"Has_Pet\" hp ON s.\"StuID\" = hp.\"StuID\"\n    INNER JOIN \"Pets\" p ON hp.\"PetID\" = p.\"PetID\"\n    WHERE s.\"Advisor\" = p_advisor_id\n    AND p.\"weight\" > p_min_weight;\n    \n    SELECT MAX(\"weight\") INTO v_heaviest_pet_weight\n    FROM \"Pets\"\n    WHERE \"PetType\" LIKE p_name_prefix || '%';\n    \n    SELECT MIN(\"weight\") INTO v_lightest_pet_weight\n    FROM \"Pets\"\n    WHERE \"PetType\" LIKE p_name_prefix || '%';\n    \n    IF v_heaviest_pet_weight > p_max_weight THEN\n        INSERT INTO \"Student\" (\"StuID\", \"Fname\", \"LName\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n        SELECT 8888, 'Heavy', 'PetOwner', 25, 'F', 999, p_advisor_id, 'SUM'\n        WHERE NOT EXISTS (SELECT 1 FROM \"Student\" WHERE \"StuID\" = 8888);\n    ELSIF v_lightest_pet_weight < p_min_weight THEN\n        INSERT INTO \"Student\" (\"StuID\", \"Fname\", \"LName\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n        SELECT 8889, 'Light', 'PetOwner', 22, 'M', 888, p_advisor_id, 'SUM'\n        WHERE NOT EXISTS (SELECT 1 FROM \"Student\" WHERE \"StuID\" = 8889);\n    ELSE\n        INSERT INTO \"Student\" (\"StuID\", \"Fname\", \"LName\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\")\n        SELECT 8890, 'Average', 'PetOwner', 20, 'F', 777, p_advisor_id, 'SUM'\n        WHERE NOT EXISTS (SELECT 1 FROM \"Student\" WHERE \"StuID\" = 8890);\n    END IF;\n    \n    UPDATE \"Pets\"\n    SET \"pet_age\" = \"pet_age\" + 1,\n        \"weight\" = CASE\n            WHEN \"weight\" < p_min_weight THEN \"weight\" * 1.2\n            WHEN \"weight\" > p_max_weight THEN \"weight\" * 0.9\n            ELSE \"weight\"\n        END\n    WHERE \"PetType\" LIKE p_name_prefix || '%';\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "CALL generate_pet_summary_report(5.0, 15.0, 'c', 1121);",
      "CALL generate_pet_summary_report(10.0, 20.0, 'd', 7712);",
      "CALL generate_pet_summary_report(1.0, 10.0, 'b', 7792);",
      "CALL generate_pet_summary_report(8.0, 18.0, 'a', 1121);",
      "CALL generate_pet_summary_report(12.0, 25.0, 'f', 7712);"
    ],
    "summary": "Create a PL/pgSQL procedure named generate_pet_summary_report with parameters p_min_weight (real), p_max_weight (real), p_name_prefix (text), and p_advisor_id (bigint). Generate a summary string of pet types and their counts for weights between p_min_weight and p_max_weight. Count distinct students with pets (weight > p_min_weight) advised by p_advisor_id. Find the heaviest and lightest pet weight for types starting with p_name_prefix. Conditionally insert a student (ID 8888, 8889, or 8890) based on weight comparisons. Update pets of types starting with p_name_prefix: increment age by 1, adjust weight (multiply by 1.2 if < p_min_weight, by 0.9 if > p_max_weight).",
    "natural_language": "Develop a comprehensive PL/pgSQL procedure, which should be named generate_pet_summary_report, that accepts the following parameters: a minimum weight threshold p_min_weight (as a real number), a maximum weight threshold p_max_weight (also a real number), a text prefix for pet types p_name_prefix, and a specific advisor identifier p_advisor_id (as a bigint). This procedure must meticulously generate a detailed summary string that enumerates various pet types alongside their corresponding counts, specifically for those pets whose weights fall inclusively between the provided minimum and maximum parameters. Furthermore, it should accurately calculate the count of distinct students who are advised by the specified advisor and own pets weighing more than the p_min_weight threshold. Additionally, the procedure needs to diligently ascertain the single heaviest and the single lightest weight among all pets whose type names begin with the given p_name_prefix. Based on a conditional logic that compares these extreme weight values, the procedure must then insert a new student record, selecting the student ID from the set {8888, 8889, 8890}. Finally, it should perform an update on all pets whose types start with the provided prefix: increment each pet's age by one year, and carefully adjust its weight by multiplying it by 1.2 if the current weight is below p_min_weight, or by 0.9 if it exceeds p_max_weight.",
    "id": 75,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named generate_pet_summary_report that accepts four input parameters: a real number p_min_weight, a real number p_max_weight, a text string p_name_prefix, and a big integer p_advisor_id. The procedure begins by declaring local variables v_type_summary as text, v_total_students, v_pet_count as bigint, and v_heaviest_pet_weight, v_lightest_pet_weight as real. It first uses a common table expression named pet_counts to select the PetType column and count rows from the Pets table where the weight column value falls between p_min_weight and p_max_weight inclusive, grouping the results by PetType. It then aggregates the results from this CTE into the v_type_summary variable by using STRING_AGG to concatenate each PetType with its corresponding count, separated by a colon, with each pair joined by a comma and space. Next, it calculates v_total_students by counting distinct StuID values from the Student table after performing an inner join with the Has_Pet table on matching StuID and another inner join with the Pets table on matching PetID, filtering for rows where the Student.Advisor column equals the p_advisor_id parameter and the Pets.weight column is greater than p_min_weight. It then finds the maximum weight from the Pets table where the PetType column starts with the string in p_name_prefix and stores it in v_heaviest_pet_weight, and similarly finds the minimum weight under the same PetType condition and stores it in v_lightest_pet_weight. Following this, a conditional block executes: if v_heaviest_pet_weight is greater than p_max_weight, it inserts a new row into the Student table with StuID 8888, Fname 'Heavy', LName 'PetOwner', Age 25, Sex 'F', Major 999, Advisor set to p_advisor_id, and city_code 'SUM', but only if a student with StuID 8888 does not already exist; else if v_lightest_pet_weight is less than p_min_weight, it inserts a new row with StuID 8889, Fname 'Light', LName 'PetOwner', Age 22, Sex 'M', Major 888, Advisor p_advisor_id, and city_code 'SUM', provided a student with StuID 8889 does not already exist; otherwise, it inserts a row with StuID 8890, Fname 'Average', LName 'PetOwner', Age 20, Sex 'F', Major 777, Advisor p_advisor_id, and city_code 'SUM', conditional on the non-existence of StuID 8890. Finally, the procedure updates the Pets table for all rows where PetType starts with p_name_prefix, incrementing the pet_age column by one and adjusting the weight column using a CASE expression: if weight is less than p_min_weight, weight is multiplied by 1.2; if weight is greater than p_max_weight, weight is multiplied by 0.9; otherwise, weight remains unchanged."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `analyze_subject_performance` that accepts three input parameters: `p_subject_id` of type `bigint`, `p_start_date` of type `timestamp with time zone`, and `p_end_date` of type `timestamp with time zone`. The purpose of this procedure is to analyze student performance for a specific subject within a given date range and then perform a conditional data manipulation operation based on the analysis.\n\nThe procedure begins by declaring three local variables: `v_pass_count` of type `integer` to store the number of passing test results, `v_fail_count` of type `integer` to store the number of failing test results, and `v_total_students` of type `integer` to store the count of unique students enrolled in the subject.\n\nThe first operation is to calculate the number of passing test results. This is achieved by executing a `SELECT COUNT(*)` statement. This query retrieves data from the `\"Student_Tests_Taken\"` table, aliased as `stt`. It then performs an `INNER JOIN` with the `\"Student_Course_Enrolment\"` table, aliased as `sce`, on the condition `stt.registration_id = sce.registration_id`. Subsequently, it performs another `INNER JOIN` with the `\"Courses\"` table, aliased as `c`, on the condition `sce.course_id = c.course_id`. The results are filtered using a `WHERE` clause: `c.subject_id` must be equal to the input parameter `p_subject_id`, `stt.date_test_taken` must fall `BETWEEN` the input parameters `p_start_date` and `p_end_date` (inclusive), and `stt.test_result` must be equal to the string literal 'Pass'. The resulting count is stored in the `v_pass_count` variable.\n\nThe second operation is to calculate the number of failing test results. This is also achieved by executing a `SELECT COUNT(*)` statement, which is structurally identical to the first query. It retrieves data from `\"Student_Tests_Taken\"` (`stt`), `INNER JOIN`s with `\"Student_Course_Enrolment\"` (`sce`) on `stt.registration_id = sce.registration_id`, and then `INNER JOIN`s with `\"Courses\"` (`c`) on `sce.course_id = c.course_id`. The filtering conditions in the `WHERE` clause are: `c.subject_id` must be equal to `p_subject_id`, `stt.date_test_taken` must be `BETWEEN` `p_start_date` and `p_end_date`, and `stt.test_result` must be equal to the string literal 'Fail'. The resulting count is stored in the `v_fail_count` variable.\n\nThe third operation is to calculate the total number of unique students enrolled in the specified subject within the given date range. This is done by executing a `SELECT COUNT(DISTINCT sce.student_id)` statement. This query retrieves data from the `\"Student_Course_Enrolment\"` table, aliased as `sce`. It then performs an `INNER JOIN` with the `\"Courses\"` table, aliased as `c`, on the condition `sce.course_id = c.course_id`. The results are filtered using a `WHERE` clause: `c.subject_id` must be equal to the input parameter `p_subject_id`, and `sce.date_of_enrolment` must fall `BETWEEN` the input parameters `p_start_date` and `p_end_date` (inclusive). The count of distinct `student_id` values is stored in the `v_total_students` variable.\n\nFollowing these calculations, the procedure executes a conditional block using an `IF` statement.\nIf the value of `v_total_students` is `>` 0 (meaning there was at least one student enrolled in the subject within the specified period), then an `INSERT` operation is performed. A new row is inserted into the `\"Subjects\"` table. The `subject_id` column is populated with the value of `p_subject_id + 1000`. The `subject_name` column is populated with a concatenated string literal 'Analysis_', followed by the `v_pass_count` converted to `text` using `CAST(v_pass_count AS text)`, followed by an underscore '_', followed by the `v_fail_count` converted to `text` using `CAST(v_fail_count AS text)`.\n\nOtherwise (if `v_total_students` is not `>` 0, meaning `v_total_students` is 0 or less), a `DELETE` operation is performed. Rows are deleted from the `\"Student_Tests_Taken\"` table. The `WHERE` clause for the `DELETE` statement specifies that `registration_id` must be `IN` the result set of a subquery. This subquery selects `sce.registration_id` from the `\"Student_Course_Enrolment\"` table, aliased as `sce`, `INNER JOIN`ed with the `\"Courses\"` table, aliased as `c`, on `sce.course_id = c.course_id`. The subquery's results are filtered where `c.subject_id` is equal to the input parameter `p_subject_id`. This effectively deletes all test records for students enrolled in the specified subject, regardless of the date range.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_subject_performance(\n    p_subject_id bigint,\n    p_start_date timestamp with time zone,\n    p_end_date timestamp with time zone\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_pass_count integer;\n    v_fail_count integer;\n    v_total_students integer;\nBEGIN\n    SELECT COUNT(*) INTO v_pass_count\n    FROM \"Student_Tests_Taken\" stt\n    INNER JOIN \"Student_Course_Enrolment\" sce ON stt.registration_id = sce.registration_id\n    INNER JOIN \"Courses\" c ON sce.course_id = c.course_id\n    WHERE c.subject_id = p_subject_id\n    AND stt.date_test_taken BETWEEN p_start_date AND p_end_date\n    AND stt.test_result = 'Pass';\n    \n    SELECT COUNT(*) INTO v_fail_count\n    FROM \"Student_Tests_Taken\" stt\n    INNER JOIN \"Student_Course_Enrolment\" sce ON stt.registration_id = sce.registration_id\n    INNER JOIN \"Courses\" c ON sce.course_id = c.course_id\n    WHERE c.subject_id = p_subject_id\n    AND stt.date_test_taken BETWEEN p_start_date AND p_end_date\n    AND stt.test_result = 'Fail';\n    \n    SELECT COUNT(DISTINCT sce.student_id) INTO v_total_students\n    FROM \"Student_Course_Enrolment\" sce\n    INNER JOIN \"Courses\" c ON sce.course_id = c.course_id\n    WHERE c.subject_id = p_subject_id\n    AND sce.date_of_enrolment BETWEEN p_start_date AND p_end_date;\n    \n    IF v_total_students > 0 THEN\n        INSERT INTO \"Subjects\" (subject_id, subject_name)\n        VALUES (p_subject_id + 1000, 'Analysis_' || CAST(v_pass_count AS text) || '_' || CAST(v_fail_count AS text));\n    ELSE\n        DELETE FROM \"Student_Tests_Taken\"\n        WHERE registration_id IN (\n            SELECT sce.registration_id\n            FROM \"Student_Course_Enrolment\" sce\n            INNER JOIN \"Courses\" c ON sce.course_id = c.course_id\n            WHERE c.subject_id = p_subject_id\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "CALL analyze_subject_performance(1, '2018-01-01 00:00:00+00', '2018-12-31 23:59:59+00');",
      "CALL analyze_subject_performance(2, '2017-10-01 00:00:00+08', '2018-03-31 23:59:59+08');",
      "CALL analyze_subject_performance(3, '2018-03-01 00:00:00+00', '2018-03-31 23:59:59+00');",
      "CALL analyze_subject_performance(1, '2017-09-01 00:00:00+08', '2017-11-30 23:59:59+08');",
      "CALL analyze_subject_performance(2, '2018-01-15 00:00:00+00', '2018-02-15 23:59:59+00');"
    ],
    "summary": "Create a stored procedure named `analyze_subject_performance` that takes a subject ID, a start date, and an end date. Count the number of 'Pass' and 'Fail' test results for that subject within the date range, and count the distinct students enrolled. If at least one student was enrolled, insert a new subject record with an ID offset by 1000 and a name containing the pass and fail counts. Otherwise, delete all test records for students enrolled in that subject.",
    "natural_language": "Alright, so we need a stored procedure called `analyze_subject_performance`. It's gotta take a subject ID, a start date, and an end date. Here's what it does: it counts up how many tests got a 'Pass' or 'Fail' for that subject between those dates, and also figures out how many different students were signed up. If there was at least one student enrolled, then we pop a new subject record into the database. This new record's ID should be the old one plus 1000, and its name should include the pass and fail counts we just tallied. But if nobody was enrolled at all, then we gotta clean house and delete all the test records for any students who were ever in that subject.",
    "id": 76,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `analyze_subject_performance` that accepts three input parameters: `p_subject_id` of type `bigint`, `p_start_date` of type `timestamp with time zone`, and `p_end_date` of type `timestamp with time zone`. The purpose of this procedure is to analyze student performance for a specific subject within a given date range and then perform a conditional data manipulation operation based on the analysis.\n\nThe procedure begins by declaring three local variables: `v_pass_count` of type `integer` to store the number of passing test results, `v_fail_count` of type `integer` to store the number of failing test results, and `v_total_students` of type `integer` to store the count of unique students enrolled in the subject.\n\nThe first operation is to calculate the number of passing test results. This is achieved by executing a `SELECT COUNT(*)` statement. This query retrieves data from the `\"Student_Tests_Taken\"` table, aliased as `stt`. It then performs an `INNER JOIN` with the `\"Student_Course_Enrolment\"` table, aliased as `sce`, on the condition `stt.registration_id = sce.registration_id`. Subsequently, it performs another `INNER JOIN` with the `\"Courses\"` table, aliased as `c`, on the condition `sce.course_id = c.course_id`. The results are filtered using a `WHERE` clause: `c.subject_id` must be equal to the input parameter `p_subject_id`, `stt.date_test_taken` must fall `BETWEEN` the input parameters `p_start_date` and `p_end_date` (inclusive), and `stt.test_result` must be equal to the string literal 'Pass'. The resulting count is stored in the `v_pass_count` variable.\n\nThe second operation is to calculate the number of failing test results. This is also achieved by executing a `SELECT COUNT(*)` statement, which is structurally identical to the first query. It retrieves data from `\"Student_Tests_Taken\"` (`stt`), `INNER JOIN`s with `\"Student_Course_Enrolment\"` (`sce`) on `stt.registration_id = sce.registration_id`, and then `INNER JOIN`s with `\"Courses\"` (`c`) on `sce.course_id = c.course_id`. The filtering conditions in the `WHERE` clause are: `c.subject_id` must be equal to `p_subject_id`, `stt.date_test_taken` must be `BETWEEN` `p_start_date` and `p_end_date`, and `stt.test_result` must be equal to the string literal 'Fail'. The resulting count is stored in the `v_fail_count` variable.\n\nThe third operation is to calculate the total number of unique students enrolled in the specified subject within the given date range. This is done by executing a `SELECT COUNT(DISTINCT sce.student_id)` statement. This query retrieves data from the `\"Student_Course_Enrolment\"` table, aliased as `sce`. It then performs an `INNER JOIN` with the `\"Courses\"` table, aliased as `c`, on the condition `sce.course_id = c.course_id`. The results are filtered using a `WHERE` clause: `c.subject_id` must be equal to the input parameter `p_subject_id`, and `sce.date_of_enrolment` must fall `BETWEEN` the input parameters `p_start_date` and `p_end_date` (inclusive). The count of distinct `student_id` values is stored in the `v_total_students` variable.\n\nFollowing these calculations, the procedure executes a conditional block using an `IF` statement.\nIf the value of `v_total_students` is `>` 0 (meaning there was at least one student enrolled in the subject within the specified period), then an `INSERT` operation is performed. A new row is inserted into the `\"Subjects\"` table. The `subject_id` column is populated with the value of `p_subject_id + 1000`. The `subject_name` column is populated with a concatenated string literal 'Analysis_', followed by the `v_pass_count` converted to `text` using `CAST(v_pass_count AS text)`, followed by an underscore '_', followed by the `v_fail_count` converted to `text` using `CAST(v_fail_count AS text)`.\n\nOtherwise (if `v_total_students` is not `>` 0, meaning `v_total_students` is 0 or less), a `DELETE` operation is performed. Rows are deleted from the `\"Student_Tests_Taken\"` table. The `WHERE` clause for the `DELETE` statement specifies that `registration_id` must be `IN` the result set of a subquery. This subquery selects `sce.registration_id` from the `\"Student_Course_Enrolment\"` table, aliased as `sce`, `INNER JOIN`ed with the `\"Courses\"` table, aliased as `c`, on `sce.course_id = c.course_id`. The subquery's results are filtered where `c.subject_id` is equal to the input parameter `p_subject_id`. This effectively deletes all test records for students enrolled in the specified subject, regardless of the date range."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named remove_wedding_record that accepts three integer parameters: p_church_id, p_male_id, and p_female_id. This procedure performs a delete operation on the wedding table, specifically targeting rows where the Church_ID column matches the value of p_church_id, the Male_ID column matches the value of p_male_id, and the Female_ID column matches the value of p_female_id. The procedure does not include any conditional statements or function calls beyond the delete operation, and it directly removes records from the wedding table based on the specified criteria.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_wedding_record(p_church_id integer, p_male_id integer, p_female_id integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM wedding \n    WHERE \"Church_ID\" = p_church_id \n    AND \"Male_ID\" = p_male_id \n    AND \"Female_ID\" = p_female_id;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL remove_wedding_record(1, 1, 2);",
      "CALL remove_wedding_record(3, 3, 4);",
      "CALL remove_wedding_record(5, 5, 6);",
      "CALL remove_wedding_record(2, 10, 12);",
      "CALL remove_wedding_record(4, 15, 18);"
    ],
    "summary": "Create a stored procedure named remove_wedding_record that deletes a record from the wedding table. It uses three integer parameters (church ID, male ID, female ID) to identify the exact row to delete.",
    "natural_language": "Hey, can you whip up a stored procedure called remove_wedding_record that'll wipe a wedding from the records? You gotta use three numbers to pinpoint the exact one: the church ID, the guy's ID, and the lady's ID.",
    "id": 77,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named remove_wedding_record that accepts three input parameters: p_church_id of type integer representing the identifier of the church where the wedding took place, p_male_id of type integer representing the identifier of the male participant, and p_female_id of type integer representing the identifier of the female participant. The procedure does not declare any local variables. The procedure executes a DELETE operation on the wedding table. The WHERE clause of the DELETE statement specifies that the row to be deleted must have the church_id column equal to the p_church_id parameter, the male_id column equal to the p_male_id parameter, and the female_id column equal to the p_female_id parameter. This operation removes exactly one record from the wedding table, provided a matching row exists. The procedure does not return a value."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that inserts a new record into the song table with the following columns: Song_ID, Title, Singer_ID, Sales, and Highest_Position. The procedure takes three parameters: p_title of type text, p_singer_id of type integer, and p_sales of type real. The Song_ID is determined by selecting the maximum Song_ID currently in the song table, using the COALESCE function to handle cases where the table might be empty by defaulting to 0, and then incrementing this value by 1 to ensure a unique identifier for the new song. The Title column is set to the value of the p_title parameter, the Singer_ID column is set to the value of the p_singer_id parameter, and the Sales column is set to the value of the p_sales parameter. The Highest_Position column is initialized to 0. If an insertion conflict occurs on the Song_ID column, the procedure does nothing, effectively ignoring the insertion attempt.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_song(p_title text, p_singer_id integer, p_sales real)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO \"song\" (\"Song_ID\", \"Title\", \"Singer_ID\", \"Sales\", \"Highest_Position\")\n    VALUES ((SELECT COALESCE(MAX(\"Song_ID\"), 0) + 1 FROM \"song\"), p_title, p_singer_id, p_sales, 0)\n    ON CONFLICT (\"Song_ID\") DO NOTHING;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL insert_new_song('New Song 1', 1, 500000.0);",
      "CALL insert_new_song('New Song 2', 2, 600000.0);",
      "CALL insert_new_song('New Song 3', 3, 700000.0);",
      "CALL insert_new_song('New Song 4', 1, 800000.0);",
      "CALL insert_new_song('New Song 5', 2, 900000.0);"
    ],
    "summary": "Create a stored procedure that inserts a new song. Generate a unique Song_ID by incrementing the current maximum, use provided parameters for Title, Singer_ID, and Sales, set Highest_Position to 0, and ignore insertion conflicts on Song_ID.",
    "natural_language": "Write a stored procedure to insert a new song. Increment the current maximum to generate a unique Song_ID, take the provided Title, Singer_ID, and Sales as parameters, set Highest_Position to 0, and ignore any insertion conflicts on Song_ID.",
    "id": 78,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named insert_new_song that accepts three input parameters: p_title of type text, p_singer_id of type integer, and p_sales of type real. The procedure begins by declaring a local variable v_new_song_id of type integer. It then performs a SELECT operation to determine the maximum value of the Song_ID column in the song table, using COALESCE to default to 0 if no rows exist, and increments this value by 1 to generate a new unique Song_ID, storing it in the v_new_song_id variable. Next, the procedure executes an INSERT operation into the song table, adding a new row with the following column values: v_new_song_id for Song_ID, p_title for Title, p_singer_id for Singer_ID, p_sales for Sales, and 0.0 for Highest_Position. The INSERT statement includes an ON CONFLICT clause that specifies the conflict target as the Song_ID column and the action as DO NOTHING, which means any insertion conflict on the Song_ID primary key or unique constraint will be silently ignored without raising an error."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named reorganize_management_structure that accepts five parameters: p_budget_cutoff of type real, p_employee_limit of type real, p_target_state of type text, p_age_limit of type real, and p_new_status of type text. The procedure begins by declaring three local variables: v_dept_id, v_head_id, and v_ranking_val, all of type integer. It first selects the Department_ID from the department table where the Budget_in_Billions is greater than p_budget_cutoff and the Num_Employees is less than p_employee_limit, ordering the results by the Ranking column in ascending order, and limits the selection to one row, storing the result in v_dept_id. Next, it selects the head_ID from the head table where the born_state matches p_target_state and the age is less than p_age_limit, ordering the results by head_ID in descending order, and limits the selection to one row, storing the result in v_head_id. Then, it retrieves the Ranking value from the department table for the department with the Department_ID equal to v_dept_id and stores it in v_ranking_val. The procedure then evaluates the value of v_ranking_val: if it is less than 5, it deletes rows from the management table where the department_ID matches v_dept_id, and inserts a new row into the management table with department_ID set to v_dept_id, head_ID set to v_head_id, and temporary_acting set to p_new_status. If v_ranking_val is not less than 5 but v_head_id is not null, it inserts rows into the management table with department_ID from the department table where Budget_in_Billions is less than p_budget_cutoff, head_ID set to v_head_id, and temporary_acting set to 'Yes'. If neither condition is met, it deletes rows from the management table where temporary_acting is 'Yes' and department_ID is in the set of Department_IDs from the department table where Num_Employees is greater than p_employee_limit.",
    "plsql": "CREATE OR REPLACE PROCEDURE reorganize_management_structure(\n    p_budget_cutoff real,\n    p_employee_limit real,\n    p_target_state text,\n    p_age_limit real,\n    p_new_status text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_dept_id integer;\n    v_head_id integer;\n    v_ranking_val integer;\nBEGIN\n    SELECT \"Department_ID\" INTO v_dept_id\n    FROM department\n    WHERE \"Budget_in_Billions\" > p_budget_cutoff\n    AND \"Num_Employees\" < p_employee_limit\n    ORDER BY \"Ranking\" ASC\n    LIMIT 1;\n    \n    SELECT \"head_ID\" INTO v_head_id\n    FROM head\n    WHERE born_state = p_target_state\n    AND age < p_age_limit\n    ORDER BY \"head_ID\" DESC\n    LIMIT 1;\n    \n    SELECT \"Ranking\" INTO v_ranking_val\n    FROM department\n    WHERE \"Department_ID\" = v_dept_id;\n    \n    IF v_ranking_val < 5 THEN\n        DELETE FROM management\n        WHERE \"department_ID\" = v_dept_id;\n        \n        INSERT INTO management (\"department_ID\", \"head_ID\", temporary_acting)\n        VALUES (v_dept_id, v_head_id, p_new_status);\n    ELSIF v_head_id IS NOT NULL THEN\n        INSERT INTO management (\"department_ID\", \"head_ID\", temporary_acting)\n        SELECT \"Department_ID\", v_head_id, 'Yes'\n        FROM department\n        WHERE \"Budget_in_Billions\" < p_budget_cutoff;\n    ELSE\n        DELETE FROM management\n        WHERE temporary_acting = 'Yes'\n        AND \"department_ID\" IN (SELECT \"Department_ID\" FROM department WHERE \"Num_Employees\" > p_employee_limit);\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL reorganize_management_structure(10.0, 50000.0, 'California', 65.0, 'Yes');",
      "CALL reorganize_management_structure(5.5, 100000.0, 'Texas', 60.0, 'Interim');",
      "CALL reorganize_management_structure(50.0, 200000.0, 'New York', 70.0, 'Temporary');",
      "CALL reorganize_management_structure(1.0, 10000.0, 'Florida', 55.0, 'Acting');",
      "CALL reorganize_management_structure(100.0, 500000.0, 'Illinois', 75.0, 'Provisional');"
    ],
    "summary": "Create a stored procedure named reorganize_management_structure that uses several input parameters to: 1) Find a department ID based on budget and employee thresholds. 2) Find a head ID based on state and age. 3) Based on the found department's ranking, perform one of three actions: a) Delete and insert a new management record if ranking is low. b) Insert management records for low-budget departments if a head was found. c) Delete management records for 'Yes' status in high-employee departments if no other condition is met.",
    "natural_language": "Develop a comprehensive stored procedure, to be named reorganize_management_structure, which will utilize a series of specific input parameters to meticulously execute the following multi-step process: Firstly, it must intelligently locate a department's unique identifier by carefully evaluating predefined budgetary constraints and specific thresholds related to employee count. Subsequently, it should identify a suitable head personnel ID by thoroughly filtering candidates based on their geographical state and precise age criteria. Finally, depending critically on the ascertained ranking tier of the located department, the procedure must decisively initiate one of three distinct managerial actions: a) In scenarios where the department's ranking is determined to be unacceptably low, it will completely delete the existing management entry and seamlessly insert a brand-new management record. b) If, however, a qualified head was successfully identified, it will proceed to insert new management records specifically for those departments operating with notably constrained budgets. c) Should none of the preceding conditions be satisfied, it will then systematically delete all management records marked with a 'Yes' status, but only for those departments characterized by an exceptionally high volume of employees.",
    "id": 79,
    "generated_ir": "Write a PLpgSQL stored procedure named reorganize_management_structure that accepts five parameters: p_budget_cutoff of type real, p_employee_limit of type real, p_target_state of type text, p_age_limit of type real, and p_new_status of type text. The procedure begins by declaring three local variables: v_dept_id, v_head_id, and v_ranking_val, all of type integer. It first selects the Department_ID from the department table where the Budget_in_Billions is greater than p_budget_cutoff and the Num_Employees is less than p_employee_limit, ordering the results by the Ranking column in ascending order, and limits the selection to one row, storing the result in v_dept_id. Next, it selects the head_ID from the head table where the born_state matches p_target_state and the age is less than p_age_limit, ordering the results by head_ID in descending order, and limits the selection to one row, storing the result in v_head_id. Then, it retrieves the Ranking value from the department table for the department with the Department_ID equal to v_dept_id and stores it in v_ranking_val. The procedure then evaluates the value of v_ranking_val: if it is less than 5, it deletes rows from the management table where the department_ID matches v_dept_id, and inserts a new row into the management table with department_ID set to v_dept_id, head_ID set to v_head_id, and temporary_acting set to p_new_status. If v_ranking_val is not less than 5 but v_head_id is not null, it inserts rows into the management table with department_ID from the department table where Budget_in_Billions is less than p_budget_cutoff, head_ID set to v_head_id, and temporary_acting set to 'Yes'. If neither condition is met, it deletes rows from the management table where temporary_acting is 'Yes' and department_ID is in the set of Department_IDs from the department table where Num_Employees is greater than p_employee_limit."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes five parameters: p_prefix (text), p_suffix (text), p_location (text), p_capacity_change (bigint), and p_value_limit (real). The procedure first retrieves the \"Code\" of a warehouse from the \"Warehouses\" table where the \"Location\" matches the provided p_location and stores it in the variable v_warehouse_code. If a warehouse code is found (i.e., v_warehouse_code is not null), it updates the \"Capacity\" of the warehouse by adding the value of p_capacity_change to the current \"Capacity\" where the \"Code\" matches v_warehouse_code. Next, it checks if there exists any box in the \"Boxes\" table associated with this warehouse (i.e., where \"Warehouse\" equals v_warehouse_code) that has a \"Value\" greater than p_value_limit. This existence check result is stored in the boolean variable v_box_exists. If such a box exists (i.e., v_box_exists is true), the procedure initializes a counter v_counter to 1 and enters a loop that iterates three times. During each iteration, it inserts a new row into the \"Boxes\" table with the \"Code\" constructed by concatenating p_prefix, the current value of v_counter formatted as a string without leading spaces, and p_suffix. The \"Contents\" column is set to 'Generated', the \"Value\" is set to p_value_limit multiplied by the current v_counter, and the \"Warehouse\" is set to v_warehouse_code. After each insertion, the counter v_counter is incremented by 1. The loop continues until v_counter exceeds 3, at which point the procedure ends.",
    "plsql": "CREATE OR REPLACE PROCEDURE procedure_four(p_prefix text, p_suffix text, p_location text, p_capacity_change bigint, p_value_limit real)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_counter bigint;\n    v_warehouse_code bigint;\n    v_box_exists boolean;\nBEGIN\n    SELECT \"Code\" INTO v_warehouse_code FROM \"Warehouses\" WHERE \"Location\" = p_location;\n    IF v_warehouse_code IS NOT NULL THEN\n        UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" + p_capacity_change WHERE \"Code\" = v_warehouse_code;\n        SELECT EXISTS(SELECT 1 FROM \"Boxes\" WHERE \"Warehouse\" = v_warehouse_code AND \"Value\" > p_value_limit) INTO v_box_exists;\n        IF v_box_exists THEN\n            v_counter := 1;\n            WHILE v_counter <= 3 LOOP\n                INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") \n                VALUES (p_prefix || TO_CHAR(v_counter, 'FM999') || p_suffix, 'Generated', p_value_limit * v_counter, v_warehouse_code);\n                v_counter := v_counter + 1;\n            END LOOP;\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "CALL procedure_four('BOX', '_GEN', 'Chicago', 10, 200.0);",
      "CALL procedure_four('GEN', '_A', 'New York', -5, 150.0);",
      "CALL procedure_four('A', 'Z', 'Chicago', 20, 300.0);",
      "CALL procedure_four('TEST', '_END', 'New York', 0, 100.0);",
      "CALL procedure_four('X', 'Y', 'Chicago', 15, 250.0);"
    ],
    "summary": "Create a stored procedure with parameters: p_prefix (text), p_suffix (text), p_location (text), p_capacity_change (bigint), p_value_limit (real). Find a warehouse at the specified location. If found, increase its capacity by p_capacity_change. Then, check if any box in that warehouse has a value > p_value_limit. If such a box exists, insert three new boxes into that warehouse. The box codes should be constructed by concatenating p_prefix, the iteration number (1,2,3), and p_suffix. Set contents to 'Generated' and value to p_value_limit multiplied by the iteration number.",
    "natural_language": "Find a warehouse at the given location. If you find one, increase its capacity by the specified amount. Then, check if any box in that warehouse has a value exceeding the provided limit. If such a box exists, insert three new boxes into that warehouse. Construct the box codes by combining the given prefix, the iteration number (1, 2, or 3), and the given suffix. Set the contents to 'Generated' and set the value to the limit multiplied by the iteration number. Create a stored procedure with parameters for the prefix, suffix, location, capacity change, and value limit to perform these actions.",
    "id": 80,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named procedure_four that accepts five parameters: p_prefix of type text to be used as a prefix for generating new box codes, p_suffix of type text to be used as a suffix for generating new box codes, p_location of type text to specify the location of the warehouse to operate on, p_capacity_change of type bigint to specify the amount by which to increase the warehouse's capacity, and p_value_limit of type real to specify the value threshold for boxes. The procedure first queries the Warehouses table to find a warehouse where the Location column exactly matches the p_location parameter, storing the found warehouse's Code column value into a local variable, say v_warehouse_code. If such a warehouse is found, it performs an UPDATE on the Warehouses table, increasing the Capacity column by the p_capacity_change parameter for the row where Code equals v_warehouse_code. Then, it checks the Boxes table for the existence of at least one box where the Warehouse column equals v_warehouse_code and the Value column is greater than the p_value_limit parameter. If such a box exists, it executes a loop three times, for iteration numbers 1, 2, and 3. In each iteration, it constructs a new box code by concatenating the p_prefix parameter, the iteration number as text, and the p_suffix parameter. It then performs an INSERT into the Boxes table for each iteration, setting the Code column to the constructed box code, the Contents column to the literal string 'Generated', the Value column to the product of the p_value_limit parameter and the iteration number, and the Warehouse column to v_warehouse_code. If no warehouse is found at the specified location, no further actions are taken. The procedure does not return a value."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes three input parameters: p_source_musical (an integer representing the ID of the source musical), p_target_musical (an integer representing the ID of the target musical), and p_age_limit (an integer representing an age threshold). The procedure transfers actors from the source musical to the target musical if their age is greater than the specified age limit. It begins by iterating over all rows in the actor table where the \"Musical_ID\" column matches the value of p_source_musical and the age column is greater than p_age_limit. For each such row, it retrieves the values of the \"Actor_ID\", \"Name\", \"Character\", \"Duration\", and age columns. Within the loop, it inserts a new row into the actor table with the following values: a new \"Actor_ID\" generated by adding the current \"Actor_ID\" value to the result of a subquery that calculates the maximum \"Actor_ID\" in the actor table (or 0 if the table is empty), the \"Name\" value from the current row, the value of p_target_musical as the new \"Musical_ID\", the \"Character\" value from the current row, the \"Duration\" value from the current row, and the age value from the current row. After inserting the new row, the procedure deletes the original row from the actor table where the \"Actor_ID\" matches the \"Actor_ID\" of the current row being processed. This process repeats for all rows that meet the specified conditions.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_actors_between_musicals(IN p_source_musical integer, IN p_target_musical integer, IN p_age_limit integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    actor_rec RECORD;\nBEGIN\n    FOR actor_rec IN \n        SELECT \"Actor_ID\", \"Name\", \"Character\", \"Duration\", age \n        FROM actor \n        WHERE \"Musical_ID\" = p_source_musical AND age > p_age_limit\n    LOOP\n        INSERT INTO actor (\"Actor_ID\", \"Name\", \"Musical_ID\", \"Character\", \"Duration\", age)\n        VALUES (\n            (SELECT COALESCE(MAX(\"Actor_ID\"), 0) + 1 FROM actor) + actor_rec.\"Actor_ID\",\n            actor_rec.\"Name\",\n            p_target_musical,\n            actor_rec.\"Character\",\n            actor_rec.\"Duration\",\n            actor_rec.age\n        );\n        \n        DELETE FROM actor WHERE \"Actor_ID\" = actor_rec.\"Actor_ID\";\n    END LOOP;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL transfer_actors_between_musicals(1, 2, 25);",
      "CALL transfer_actors_between_musicals(2, 3, 20);",
      "CALL transfer_actors_between_musicals(1, 3, 22);",
      "CALL transfer_actors_between_musicals(3, 1, 21);",
      "CALL transfer_actors_between_musicals(2, 1, 26);"
    ],
    "summary": "Create a stored procedure that transfers actors from a source musical to a target musical if their age exceeds a given limit. For each qualifying actor, insert a new record with a new Actor_ID (current ID plus max ID) and the target musical ID, then delete the original record.",
    "natural_language": "How can I create a stored procedure to move actors from one musical to another if they are above a certain age? For each actor that qualifies, it should insert a new record with a new Actor_ID (calculated as the current ID plus the maximum existing ID) and the target musical's ID, and then delete the original actor record.",
    "id": 81,
    "generated_ir": "Write a PLpgSQL stored procedure that takes three input parameters: p_source_musical (an integer representing the ID of the source musical), p_target_musical (an integer representing the ID of the target musical), and p_age_limit (an integer representing an age threshold). The procedure transfers actors from the source musical to the target musical if their age is greater than the specified age limit. It begins by iterating over all rows in the actor table where the \"Musical_ID\" column matches the value of p_source_musical and the age column is greater than p_age_limit. For each such row, it retrieves the values of the \"Actor_ID\", \"Name\", \"Character\", \"Duration\", and age columns. Within the loop, it inserts a new row into the actor table with the following values: a new \"Actor_ID\" generated by adding the current \"Actor_ID\" value to the result of a subquery that calculates the maximum \"Actor_ID\" in the actor table (or 0 if the table is empty), the \"Name\" value from the current row, the value of p_target_musical as the new \"Musical_ID\", the \"Character\" value from the current row, the \"Duration\" value from the current row, and the age value from the current row. After inserting the new row, the procedure deletes the original row from the actor table where the \"Actor_ID\" matches the \"Actor_ID\" of the current row being processed. This process repeats for all rows that meet the specified conditions."
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `migrate_architect_legacy` that accepts two text parameters: `p_source_gender` and `p_target_gender`. This procedure is designed to migrate records from the \"architect\" table based on their gender, creating new architect records with a modified gender and potentially updating or deleting related records in the \"bridge\" and \"mill\" tables.\n\nThe procedure begins by declaring several local variables:\n- `v_cursor`: A cursor that will iterate over records from the \"architect\" table. This cursor is defined to select the \"id\", \"name\", \"nationality\", and \"gender\" columns from the \"architect\" table for all rows where the \"gender\" column matches the `p_source_gender` input parameter.\n- `v_record`: A `RECORD` type variable to hold the data fetched from `v_cursor` during each iteration.\n- `v_new_id`: A `TEXT` type variable to store the newly generated \"id\" for architect records.\n- `v_migration_count`: An `INTEGER` type variable initialized to `0`, used to count the total number of architect records processed and migrated.\n- `v_bridge_moved`: An `INTEGER` type variable initialized to `0`, used to count the number of \"bridge\" records that were associated with architects whose \"nationality\" contained '%American%'.\n- `v_mill_moved`: An `INTEGER` type variable initialized to `0`, used to count the number of \"mill\" records that were associated with architects whose \"nationality\" contained '%British%'.\n- `v_condition_check`: An `INTEGER` type variable initialized to `0`, used to track which conditional branch was executed for the last processed architect record.\n- `v_temp_count`: An `INTEGER` type variable used as a temporary storage for counts during conditional processing.\n\nThe procedure then opens the `v_cursor`.\n\nIt enters a `LOOP` that continues until no more rows are found by the cursor. Inside the loop:\n1. It fetches the next row from `v_cursor` into `v_record`.\n2. If no more rows are found (`NOT FOUND`), the loop exits.\n3. A new \"id\" for the architect record is generated and assigned to `v_new_id`. This new \"id\" is calculated by finding the maximum \"id\" (cast to `INTEGER`) in the \"architect\" table, adding `1` to it, and then casting the result back to `TEXT`. If no \"id\" exists, `0` is used as the starting point.\n\nNext, a series of conditional checks are performed on the `v_record`'s attributes:\n\n- **Condition 1: `v_record.\"nationality\" LIKE '%American%'`**\n    - If the \"nationality\" of the current architect record contains the substring 'American', a new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"` concatenated with ' (Migrated)'.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - The procedure then counts the number of records in the \"bridge\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) and stores this count in `v_temp_count`.\n    - `v_bridge_moved` is incremented by `v_temp_count`.\n    - `v_condition_check` is set to `1`.\n\n- **Condition 2: `v_record.\"nationality\" LIKE '%British%'` (executed if Condition 1 is false)**\n    - If the \"nationality\" of the current architect record contains the substring 'British', a new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"` concatenated with ' [Relocated]'.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - The procedure then counts the number of records in the \"mill\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) and stores this count in `v_temp_count`.\n    - `v_mill_moved` is incremented by `v_temp_count`.\n    - `v_condition_check` is set to `2`.\n\n- **Condition 3: `v_record.\"name\" LIKE '%Frank%'` (executed if Conditions 1 and 2 are false)**\n    - If the \"name\" of the current architect record contains the substring 'Frank', the \"architect_id\" in the \"bridge\" table is updated to `v_new_id` (cast to `INTEGER`) for all records where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`).\n    - Similarly, the \"architect_id\" in the \"mill\" table is updated to `v_new_id` (cast to `INTEGER`) for all records where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`).\n    - A new record is then inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"`.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `3`.\n\n- **Condition 4: `LENGTH(v_record.\"name\") > 15` (executed if Conditions 1, 2, and 3 are false)**\n    - If the length of the \"name\" of the current architect record is greater than `15`, all records in the \"bridge\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) are deleted.\n    - All records in the \"mill\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) are also deleted.\n    - A new record is then inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is a substring of the original `v_record.\"name\"`, taking the first `15` characters.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `4`.\n\n- **Else (executed if none of the above conditions are met)**\n    - A new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"`.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `5`.\n\nAfter the conditional block, regardless of which condition was met, the original architect record from which `v_record` was derived is deleted from the \"architect\" table where its \"id\" matches `v_record.\"id\"`.\n`v_migration_count` is incremented by `1`.\n\nAfter the loop finishes, the `v_cursor` is closed.\n\nFinally, a notice message is raised, indicating the completion of the migration. This message includes the total number of architects migrated (`v_migration_count`), the number of bridge records moved (`v_bridge_moved`), the number of mill records moved (`v_mill_moved`), and the `v_condition_check` value from the last processed record.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_architect_legacy(p_source_gender TEXT, p_target_gender TEXT)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cursor CURSOR FOR \n        SELECT \"id\", \"name\", \"nationality\", \"gender\"\n        FROM \"architect\"\n        WHERE \"gender\" = p_source_gender;\n    v_record RECORD;\n    v_new_id TEXT;\n    v_migration_count INTEGER := 0;\n    v_bridge_moved INTEGER := 0;\n    v_mill_moved INTEGER := 0;\n    v_condition_check INTEGER := 0;\n    v_temp_count INTEGER;\nBEGIN\n    OPEN v_cursor;\n    \n    LOOP\n        FETCH v_cursor INTO v_record;\n        EXIT WHEN NOT FOUND;\n        \n        v_new_id := (SELECT COALESCE(MAX(\"id\"::INTEGER), 0) + 1 FROM \"architect\")::TEXT;\n        \n        IF v_record.\"nationality\" LIKE '%American%' THEN\n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, v_record.\"name\" || ' (Migrated)', v_record.\"nationality\", p_target_gender);\n            \n            SELECT COUNT(*) INTO v_temp_count FROM \"bridge\" WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            v_bridge_moved := v_bridge_moved + v_temp_count;\n            \n            v_condition_check := 1;\n        ELSIF v_record.\"nationality\" LIKE '%British%' THEN\n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, v_record.\"name\" || ' [Relocated]', v_record.\"nationality\", p_target_gender);\n            \n            SELECT COUNT(*) INTO v_temp_count FROM \"mill\" WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            v_mill_moved := v_mill_moved + v_temp_count;\n            \n            v_condition_check := 2;\n        ELSIF v_record.\"name\" LIKE '%Frank%' THEN\n            UPDATE \"bridge\" SET \"architect_id\" = v_new_id::INTEGER WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            UPDATE \"mill\" SET \"architect_id\" = v_new_id::INTEGER WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            \n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, v_record.\"name\", v_record.\"nationality\", p_target_gender);\n            \n            v_condition_check := 3;\n        ELSIF LENGTH(v_record.\"name\") > 15 THEN\n            DELETE FROM \"bridge\" WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            DELETE FROM \"mill\" WHERE \"architect_id\" = v_record.\"id\"::INTEGER;\n            \n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, SUBSTRING(v_record.\"name\", 1, 15), v_record.\"nationality\", p_target_gender);\n            \n            v_condition_check := 4;\n        ELSE\n            INSERT INTO \"architect\" (\"id\", \"name\", \"nationality\", \"gender\")\n            VALUES (v_new_id, v_record.\"name\", v_record.\"nationality\", p_target_gender);\n            \n            v_condition_check := 5;\n        END IF;\n        \n        DELETE FROM \"architect\" WHERE \"id\" = v_record.\"id\";\n        v_migration_count := v_migration_count + 1;\n    END LOOP;\n    \n    CLOSE v_cursor;\n    \n    RAISE NOTICE 'Migration complete: % architects, % bridges, % mills, condition %', \n                 v_migration_count, v_bridge_moved, v_mill_moved, v_condition_check;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "CALL migrate_architect_legacy('male', 'non-binary');",
      "CALL migrate_architect_legacy('female', 'non-binary');",
      "CALL migrate_architect_legacy('male', 'female');",
      "CALL migrate_architect_legacy('female', 'male');",
      "CALL migrate_architect_legacy('non-binary', 'male');"
    ],
    "summary": "Create a stored procedure named migrate_architect_legacy that migrates architects from a source gender to a target gender. It loops through source architects. For each, it generates a new ID. Based on the architect's attributes: if nationality contains 'American', insert a migrated architect and count their bridges; if nationality contains 'British', insert a relocated architect and count their mills; if name contains 'Frank', update bridge and mill records to the new ID and insert the architect; if name length > 15, delete their bridges and mills and insert an architect with a truncated name; otherwise, just insert the architect. Delete the original architect record. Finally, output counts of migrated architects, moved bridges, moved mills, and the last condition code.",
    "natural_language": "Create a comprehensive stored procedure, meticulously named migrate_architect_legacy, which orchestrates the detailed migration of architects from a specified source gender to a designated target gender. The procedure thoughtfully iterates through each architect record from the source. For every individual architect, it first carefully generates a brand new, unique identifier. Subsequently, based on a thorough examination of the architect's specific attributes, it executes distinct logic: if the architect's nationality descriptively includes the term 'American', it inserts a migrated architect record and then diligently counts all associated bridges; if the nationality richly contains the word 'British', it inserts a relocated architect and meticulously tallies their related mills; if the architect's name prominently features 'Frank', it updates all existing bridge and mill records to reflect the new identifier and then inserts the architect; if the length of the name is determined to be impressively greater than fifteen characters, it permanently deletes all their bridges and mills and inserts an architect record with a neatly truncated name; otherwise, it simply inserts the architect. Following these conditional operations, it conscientiously deletes the original architect record. Finally, the procedure elegantly outputs the cumulative counts of migrated architects, moved bridges, moved mills, and the very last condition code that was processed.",
    "id": 82,
    "generated_ir": "Write a PL/pgSQL stored procedure named `migrate_architect_legacy` that accepts two text parameters: `p_source_gender` and `p_target_gender`. This procedure is designed to migrate records from the \"architect\" table based on their gender, creating new architect records with a modified gender and potentially updating or deleting related records in the \"bridge\" and \"mill\" tables.\n\nThe procedure begins by declaring several local variables:\n- `v_cursor`: A cursor that will iterate over records from the \"architect\" table. This cursor is defined to select the \"id\", \"name\", \"nationality\", and \"gender\" columns from the \"architect\" table for all rows where the \"gender\" column matches the `p_source_gender` input parameter.\n- `v_record`: A `RECORD` type variable to hold the data fetched from `v_cursor` during each iteration.\n- `v_new_id`: A `TEXT` type variable to store the newly generated \"id\" for architect records.\n- `v_migration_count`: An `INTEGER` type variable initialized to `0`, used to count the total number of architect records processed and migrated.\n- `v_bridge_moved`: An `INTEGER` type variable initialized to `0`, used to count the number of \"bridge\" records that were associated with architects whose \"nationality\" contained '%American%'.\n- `v_mill_moved`: An `INTEGER` type variable initialized to `0`, used to count the number of \"mill\" records that were associated with architects whose \"nationality\" contained '%British%'.\n- `v_condition_check`: An `INTEGER` type variable initialized to `0`, used to track which conditional branch was executed for the last processed architect record.\n- `v_temp_count`: An `INTEGER` type variable used as a temporary storage for counts during conditional processing.\n\nThe procedure then opens the `v_cursor`.\n\nIt enters a `LOOP` that continues until no more rows are found by the cursor. Inside the loop:\n1. It fetches the next row from `v_cursor` into `v_record`.\n2. If no more rows are found (`NOT FOUND`), the loop exits.\n3. A new \"id\" for the architect record is generated and assigned to `v_new_id`. This new \"id\" is calculated by finding the maximum \"id\" (cast to `INTEGER`) in the \"architect\" table, adding `1` to it, and then casting the result back to `TEXT`. If no \"id\" exists, `0` is used as the starting point.\n\nNext, a series of conditional checks are performed on the `v_record`'s attributes:\n\n- **Condition 1: `v_record.\"nationality\" LIKE '%American%'`**\n    - If the \"nationality\" of the current architect record contains the substring 'American', a new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"` concatenated with ' (Migrated)'.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - The procedure then counts the number of records in the \"bridge\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) and stores this count in `v_temp_count`.\n    - `v_bridge_moved` is incremented by `v_temp_count`.\n    - `v_condition_check` is set to `1`.\n\n- **Condition 2: `v_record.\"nationality\" LIKE '%British%'` (executed if Condition 1 is false)**\n    - If the \"nationality\" of the current architect record contains the substring 'British', a new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"` concatenated with ' [Relocated]'.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - The procedure then counts the number of records in the \"mill\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) and stores this count in `v_temp_count`.\n    - `v_mill_moved` is incremented by `v_temp_count`.\n    - `v_condition_check` is set to `2`.\n\n- **Condition 3: `v_record.\"name\" LIKE '%Frank%'` (executed if Conditions 1 and 2 are false)**\n    - If the \"name\" of the current architect record contains the substring 'Frank', the \"architect_id\" in the \"bridge\" table is updated to `v_new_id` (cast to `INTEGER`) for all records where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`).\n    - Similarly, the \"architect_id\" in the \"mill\" table is updated to `v_new_id` (cast to `INTEGER`) for all records where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`).\n    - A new record is then inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"`.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `3`.\n\n- **Condition 4: `LENGTH(v_record.\"name\") > 15` (executed if Conditions 1, 2, and 3 are false)**\n    - If the length of the \"name\" of the current architect record is greater than `15`, all records in the \"bridge\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) are deleted.\n    - All records in the \"mill\" table where the \"architect_id\" matches the \"id\" of the current `v_record` (cast to `INTEGER`) are also deleted.\n    - A new record is then inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is a substring of the original `v_record.\"name\"`, taking the first `15` characters.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `4`.\n\n- **Else (executed if none of the above conditions are met)**\n    - A new record is inserted into the \"architect\" table.\n    - The \"id\" for this new record is `v_new_id`.\n    - The \"name\" is the original `v_record.\"name\"`.\n    - The \"nationality\" is `v_record.\"nationality\"`.\n    - The \"gender\" is `p_target_gender`.\n    - `v_condition_check` is set to `5`.\n\nAfter the conditional block, regardless of which condition was met, the original architect record from which `v_record` was derived is deleted from the \"architect\" table where its \"id\" matches `v_record.\"id\"`.\n`v_migration_count` is incremented by `1`.\n\nAfter the loop finishes, the `v_cursor` is closed.\n\nFinally, a notice message is raised, indicating the completion of the migration. This message includes the total number of architects migrated (`v_migration_count`), the number of bridge records moved (`v_bridge_moved`), the number of mill records moved (`v_mill_moved`), and the `v_condition_check` value from the last processed record."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named migrate_young_members that accepts two integer input parameters: p_source_club_id to identify the originating club and p_target_club_id to identify the destination club. The procedure begins by declaring a local integer variable v_member_id and a local text variable v_new_year. It then calculates the value for v_new_year by taking the current date, adding an interval of one year to it, and converting the resulting date to a four-digit year string using the TO_CHAR function with the 'YYYY' format mask. The procedure enters a loop that iterates over a result set obtained from a SELECT query. This query retrieves the Member_ID column from the club_leader table, aliased as cl, by performing an inner join with the member table, aliased as m, on the condition that the Member_ID column from club_leader equals the Member_ID column from member. The query filters the joined records to include only those where the Club_ID column in the club_leader table matches the input parameter p_source_club_id and where the Age column in the member table is less than 20. For each member ID fetched into v_member_id during iteration, the procedure executes two data manipulation statements. First, it deletes a row from the club_leader table where the Club_ID column equals p_source_club_id and the Member_ID column equals the current loop variable v_member_id. Second, it inserts a new row into the club_leader table, providing values for three columns: the Club_ID column is set to the input parameter p_target_club_id, the Member_ID column is set to the current v_member_id, and the Year_Join column is set to the previously calculated v_new_year string.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_young_members(p_source_club_id integer, p_target_club_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_id integer;\n    v_new_year text;\nBEGIN\n    v_new_year := TO_CHAR(CURRENT_DATE + INTERVAL '1 year', 'YYYY');\n    \n    FOR v_member_id IN \n        SELECT cl.\"Member_ID\" \n        FROM club_leader cl \n        JOIN member m ON cl.\"Member_ID\" = m.\"Member_ID\" \n        WHERE cl.\"Club_ID\" = p_source_club_id AND m.\"Age\" < 20\n    LOOP\n        DELETE FROM club_leader WHERE \"Club_ID\" = p_source_club_id AND \"Member_ID\" = v_member_id;\n        INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (p_target_club_id, v_member_id, v_new_year);\n    END LOOP;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL migrate_young_members(1, 3);",
      "CALL migrate_young_members(1, 4);",
      "CALL migrate_young_members(3, 1);",
      "CALL migrate_young_members(3, 4);",
      "CALL migrate_young_members(4, 1);"
    ],
    "summary": "Create a stored procedure named migrate_young_members that transfers young members (under 20) from a source club to a target club. For each member, delete their leadership record from the source club and insert a new record in the target club with a join year set to next year.",
    "natural_language": "Develop a stored procedure called migrate_young_members that meticulously handles the transfer of all youthful members, specifically those who are under the age of twenty, from a designated source club to a specified target club. For every single one of these young members, the procedure must carefully delete their existing leadership entry from the original source club and then thoughtfully insert a brand-new record for them into the destination target club, explicitly setting their join year to the upcoming calendar year.",
    "id": 83,
    "generated_ir": "Write a PostgreSQL PLpgSQL stored procedure named migrate_young_members that accepts two integer input parameters: p_source_club_id to identify the originating club and p_target_club_id to identify the destination club. The procedure begins by declaring a local integer variable v_member_id and a local text variable v_new_year. It then calculates the value for v_new_year by taking the current date, adding an interval of one year to it, and converting the resulting date to a four-digit year string using the TO_CHAR function with the 'YYYY' format mask. The procedure enters a loop that iterates over a result set obtained from a SELECT query. This query retrieves the Member_ID column from the club_leader table, aliased as cl, by performing an inner join with the member table, aliased as m, on the condition that the Member_ID column from club_leader equals the Member_ID column from member. The query filters the joined records to include only those where the Club_ID column in the club_leader table matches the input parameter p_source_club_id and where the Age column in the member table is less than 20. For each member ID fetched into v_member_id during iteration, the procedure executes two data manipulation statements. First, it deletes a row from the club_leader table where the Club_ID column equals p_source_club_id and the Member_ID column equals the current loop variable v_member_id. Second, it inserts a new row into the club_leader table, providing values for three columns: the Club_ID column is set to the input parameter p_target_club_id, the Member_ID column is set to the current v_member_id, and the Year_Join column is set to the previously calculated v_new_year string."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named add_institution that accepts three input parameters: p_institution_name of type TEXT to hold the name of the institution, p_location of type TEXT to hold the geographical location of the institution, and p_founded of type INTEGER to hold the year the institution was founded, and performs a single INSERT operation into the database table named institution, specifically populating the columns \"Institution_Name\", \"Location\", and \"Founded\" with the values provided by the parameters p_institution_name, p_location, and p_founded respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_institution(\n    p_institution_name TEXT,\n    p_location TEXT,\n    p_founded INTEGER\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO institution (\"Institution_Name\", \"Location\", \"Founded\")\n    VALUES (p_institution_name, p_location, p_founded);\nEND;\n$$;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "CALL add_institution('University of California, Berkeley', 'Berkeley, California', 1868);",
      "CALL add_institution('Stanford University', 'Stanford, California', 1885);",
      "CALL add_institution('Massachusetts Institute of Technology', 'Cambridge, Massachusetts', 1861);",
      "CALL add_institution('Harvard University', 'Cambridge, Massachusetts', 1636);",
      "CALL add_institution('University of Oxford', 'Oxford, England', 1096);"
    ],
    "summary": "Create a stored procedure named add_institution that inserts a new institution record with its name, location, and founding year.",
    "natural_language": "Write a stored procedure called add_institution to insert a new institution record, including its name, location, and founding year.",
    "id": 84,
    "generated_ir": "Write a PostgreSQL PLpgSQL stored procedure named add_institution that accepts three input parameters: p_institution_name of type TEXT to hold the name of the institution, p_location of type TEXT to hold the geographical location of the institution, and p_founded of type INTEGER to hold the year the institution was founded, and performs a single INSERT operation into the database table named institution, specifically populating the columns \"Institution_Name\", \"Location\", and \"Founded\" with the values provided by the parameters p_institution_name, p_location, and p_founded respectively."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named redistribute_wealth that accepts three input parameters: a TEXT parameter p_citizenship, an INTEGER parameter p_birth_decade, and a REAL parameter p_redistribution_factor. The procedure operates on a table named singer, which contains columns including Singer_ID, Name, Birth_Year, Net_Worth_Millions, and Citizenship. It begins by calculating the total sum of the Net_Worth_Millions column and the count of rows from the singer table where the Citizenship column exactly matches the p_citizenship parameter and where the decade of the Birth_Year, derived by applying the FLOOR function to Birth_Year divided by 10 and then multiplying the result by 10, equals the p_birth_decade parameter; these aggregate results are stored into local variables v_total_worth and v_singer_count respectively. If the v_singer_count is greater than zero, it computes an average worth v_avg_worth by dividing v_total_worth by v_singer_count, then enters a loop that iterates over each singer record, identified by Singer_ID and Net_Worth_Millions, that satisfies the same citizenship and birth decade filter condition. For each singer record in this loop, it performs a conditional update to the singer table based on the singer's current Net_Worth_Millions relative to the calculated v_avg_worth: if the singer's net worth is greater than v_avg_worth, it reduces their Net_Worth_Millions by subtracting the product of the difference between their current worth and the average and the p_redistribution_factor; if the singer's net worth is less than 80% of the average (v_avg_worth * 0.8), it increases their Net_Worth_Millions by adding the product of the difference between the average and their current worth, the p_redistribution_factor, and a factor of 0.5; if the singer's net worth is less than 90% of the average (v_avg_worth * 0.9) but not less than 80%, it increases their Net_Worth_Millions by adding the product of the difference between the average and their current worth, the p_redistribution_factor, and a factor of 0.3; for all other cases (where the net worth is between 90% and 100% of the average, or exactly equal to the average), it sets the singer's Net_Worth_Millions directly to the v_avg_worth value. Each update is applied specifically to the row where the Singer_ID matches the v_singer_rec.Singer_ID from the current loop iteration. If the initial singer count v_singer_count is zero, indicating no singers match the provided citizenship and birth decade criteria, the procedure performs an INSERT into the singer table, attempting to add a new row with a Singer_ID of 999, a Name of 'Default Singer', a Birth_Year calculated as p_birth_decade plus 5, a Net_Worth_Millions of 10.0, and the Citizenship from the p_citizenship parameter, using an ON CONFLICT clause on the Singer_ID column to do nothing if a row with Singer_ID 999 already exists.",
    "plsql": "CREATE OR REPLACE PROCEDURE redistribute_wealth(\n    p_citizenship TEXT,\n    p_birth_decade INTEGER,\n    p_redistribution_factor REAL\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_worth REAL;\n    v_singer_count INTEGER;\n    v_avg_worth REAL;\n    v_singer_rec RECORD;\nBEGIN\n    SELECT SUM(\"Net_Worth_Millions\"), COUNT(*) INTO v_total_worth, v_singer_count\n    FROM singer \n    WHERE \"Citizenship\" = p_citizenship \n    AND FLOOR(\"Birth_Year\" / 10) * 10 = p_birth_decade;\n    \n    IF v_singer_count > 0 THEN\n        v_avg_worth := v_total_worth / v_singer_count;\n        \n        FOR v_singer_rec IN \n            SELECT \"Singer_ID\", \"Net_Worth_Millions\"\n            FROM singer \n            WHERE \"Citizenship\" = p_citizenship \n            AND FLOOR(\"Birth_Year\" / 10) * 10 = p_birth_decade\n        LOOP\n            IF v_singer_rec.\"Net_Worth_Millions\" > v_avg_worth THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" - \n                    (\"Net_Worth_Millions\" - v_avg_worth) * p_redistribution_factor\n                WHERE \"Singer_ID\" = v_singer_rec.\"Singer_ID\";\n            ELSIF v_singer_rec.\"Net_Worth_Millions\" < v_avg_worth * 0.8 THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" + \n                    (v_avg_worth - \"Net_Worth_Millions\") * p_redistribution_factor * 0.5\n                WHERE \"Singer_ID\" = v_singer_rec.\"Singer_ID\";\n            ELSIF v_singer_rec.\"Net_Worth_Millions\" < v_avg_worth * 0.9 THEN\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = \"Net_Worth_Millions\" + \n                    (v_avg_worth - \"Net_Worth_Millions\") * p_redistribution_factor * 0.3\n                WHERE \"Singer_ID\" = v_singer_rec.\"Singer_ID\";\n            ELSE\n                UPDATE singer \n                SET \"Net_Worth_Millions\" = v_avg_worth\n                WHERE \"Singer_ID\" = v_singer_rec.\"Singer_ID\";\n            END IF;\n        END LOOP;\n    ELSE\n        INSERT INTO singer (\"Singer_ID\", \"Name\", \"Birth_Year\", \"Net_Worth_Millions\", \"Citizenship\")\n        VALUES (999, 'Default Singer', p_birth_decade + 5, 10.0, p_citizenship)\n        ON CONFLICT (\"Singer_ID\") DO NOTHING;\n    END IF;\nEND;\n$$;",
    "database_name": "singer",
    "tables": [
      "singer",
      "song"
    ],
    "call_sqls": [
      "CALL redistribute_wealth('France', 1940, 0.5);",
      "CALL redistribute_wealth('United States', 1940, 0.3);",
      "CALL redistribute_wealth('France', 1950, 0.7);",
      "CALL redistribute_wealth('United States', 1950, 0.4);",
      "CALL redistribute_wealth('France', 1960, 0.6);"
    ],
    "summary": "Create a stored procedure named redistribute_wealth that accepts parameters p_citizenship (TEXT), p_birth_decade (INTEGER), and p_redistribution_factor (REAL). For singers matching the given citizenship and birth decade, calculate their total and average net worth. If singers exist, adjust each singer's net worth based on how it compares to the average: reduce it if above average, increase it if below 80% or 90% of the average using specific formulas and the redistribution factor, or set it to the average otherwise. If no singers match, insert a default singer record with ID 999, handling conflicts.",
    "natural_language": "Alright, so we need a stored procedure called redistribute_wealth. It's gotta take three things: p_citizenship (that's TEXT), p_birth_decade (an INTEGER), and p_redistribution_factor (a REAL number). Here's the deal: look up all the singers who match that citizenship and were born in that decade. Figure out their total and average net worth. If we find any singers, we're gonna tweak each one's net worth. If a singer's worth is above the average, we'll bring it down a bit. If it's below 80% or 90% of the average, we'll bump it up using these specific formulas and that redistribution factor. Otherwise, just set their worth to the average. Oh, and if we don't find any singers at all, just pop in a default singer record with ID 999, but make sure you handle it if that ID already exists.",
    "id": 85,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `redistribute_wealth` that accepts three input parameters: `p_citizenship` of type `TEXT`, `p_birth_decade` of type `INTEGER`, and `p_redistribution_factor` of type `REAL`. The procedure operates on the `singer` table in the `singer` database. It begins by declaring several local variables: `v_total_worth` of type `REAL`, `v_average_worth` of type `REAL`, `v_singer_count` of type `INTEGER`, `v_singer_id` of type `INTEGER`, `v_net_worth` of type `REAL`, `v_lower_threshold` of type `REAL`, and `v_new_worth` of type `REAL`. The procedure first calculates the total net worth and the count of singers from the `singer` table where the `Citizenship` column matches the `p_citizenship` parameter and the `Birth_Year` is within the specified decade, determined by checking if the floor of `Birth_Year` divided by 10 equals `p_birth_decade`. These aggregated values are stored into `v_total_worth` and `v_singer_count` using a `SELECT` statement with `SUM(Net_Worth_Millions)` and `COUNT(*)`. If `v_singer_count` is greater than zero, the procedure computes `v_average_worth` by dividing `v_total_worth` by `v_singer_count`. It then calculates `v_lower_threshold` as 80% of `v_average_worth`. Next, the procedure enters a `FOR` loop that iterates over each row in the `singer` table where the same citizenship and birth decade conditions hold, fetching `Singer_ID` into `v_singer_id` and `Net_Worth_Millions` into `v_net_worth`. For each singer record, the procedure evaluates the current net worth against the average. If `v_net_worth` is greater than `v_average_worth`, it sets `v_new_worth` to `v_net_worth` minus the product of `p_redistribution_factor` and the difference between `v_net_worth` and `v_average_worth`. If `v_net_worth` is less than `v_lower_threshold`, it sets `v_new_worth` to `v_net_worth` plus the product of `p_redistribution_factor` and the difference between `v_average_worth` and `v_net_worth`. Otherwise, for cases where `v_net_worth` is between `v_lower_threshold` and `v_average_worth` inclusive, it sets `v_new_worth` to `v_average_worth`. After determining `v_new_worth`, the procedure executes an `UPDATE` statement on the `singer` table, setting the `Net_Worth_Millions` column to `v_new_worth` for the row where `Singer_ID` equals `v_singer_id`. If `v_singer_count` is zero, indicating no singers match the criteria, the procedure attempts to insert a default singer record into the `singer` table with `Singer_ID` as 999, `Name` as 'Default Singer', `Birth_Year` as 1900.0, `Net_Worth_Millions` as 0.0, and `Citizenship` set to the value of `p_citizenship`. This `INSERT` is performed within a `BEGIN ... EXCEPTION` block to handle cases where a duplicate key violation occurs due to an existing record with `Singer_ID` 999, in which case the exception is caught and ignored, allowing the procedure to continue without interruption. The procedure does not return any value."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named balance_department_resources that accepts five input parameters: an integer p_ranking_filter, a real number p_employee_target, a text p_state_exclusion, a real number p_age_exclusion, and a text p_status_target. The procedure begins by declaring three local variables: v_total_departments as integer, v_eligible_heads as integer, and v_max_budget as real. It first calculates v_total_departments by counting all rows from the department table where the Ranking column is less than or equal to the p_ranking_filter parameter. It then calculates v_eligible_heads by counting all rows from the head table where the born_state column is not equal to p_state_exclusion and the age column is not equal to p_age_exclusion. Next, it determines v_max_budget by selecting the maximum value from the Budget_in_Billions column in the department table, but only for rows where the Num_Employees column is greater than the p_employee_target parameter. The procedure then executes a conditional IF-ELSIF-ELSE block. If v_total_departments is greater than v_eligible_heads, it performs two operations: first, it deletes rows from the management table by joining it with the head table on head_ID, specifically deleting any management record where the associated head's born_state column equals the p_state_exclusion parameter; second, it inserts up to three new rows into the management table, specifying columns department_ID, head_ID, and temporary_acting, by performing a cross join between the department and head tables, selecting department_ID from department where its Ranking is less than or equal to p_ranking_filter, and head_ID from head where its born_state is not equal to p_state_exclusion, and setting the temporary_acting column to the value of p_status_target, limiting the total inserted rows to three. Otherwise, if the first condition is false and v_max_budget is less than 1000, it deletes rows from the management table where the department_ID matches any Department_ID from the department table where the Budget_in_Billions column is less than the calculated v_max_budget. If neither of the previous conditions is true, the procedure executes the ELSE branch, which inserts three specific rows into the management table with hardcoded values: (2, 2, p_status_target), (3, 3, p_status_target), and (4, 4, p_status_target).",
    "plsql": "CREATE OR REPLACE PROCEDURE balance_department_resources(\n    p_ranking_filter integer,\n    p_employee_target real,\n    p_state_exclusion text,\n    p_age_exclusion real,\n    p_status_target text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_departments integer;\n    v_eligible_heads integer;\n    v_max_budget real;\nBEGIN\n    SELECT COUNT(*) INTO v_total_departments\n    FROM department\n    WHERE \"Ranking\" <= p_ranking_filter;\n    \n    SELECT COUNT(*) INTO v_eligible_heads\n    FROM head\n    WHERE born_state != p_state_exclusion\n    AND age != p_age_exclusion;\n    \n    SELECT MAX(\"Budget_in_Billions\") INTO v_max_budget\n    FROM department\n    WHERE \"Num_Employees\" > p_employee_target;\n    \n    IF v_total_departments > v_eligible_heads THEN\n        DELETE FROM management m\n        USING head h\n        WHERE m.head_ID = h.head_ID\n        AND h.born_state = p_state_exclusion;\n        \n        INSERT INTO management (department_ID, head_ID, temporary_acting)\n        SELECT d.\"Department_ID\", h.head_ID, p_status_target\n        FROM department d\n        CROSS JOIN head h\n        WHERE d.\"Ranking\" <= p_ranking_filter\n        AND h.born_state != p_state_exclusion\n        LIMIT 3;\n    ELSIF v_max_budget < 1000 THEN\n        DELETE FROM management\n        WHERE management.\"department_ID\" IN (\n            SELECT \"Department_ID\"\n            FROM department\n            WHERE \"Budget_in_Billions\" < v_max_budget\n        );\n    ELSE\n        INSERT INTO management (department_ID, head_ID, temporary_acting)\n        VALUES (2, 2, p_status_target),\n               (3, 3, p_status_target),\n               (4, 4, p_status_target);\n    END IF;\nEND;\n$$;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "CALL balance_department_resources(2, 100000.0, 'California', 67.0, 'Yes');",
      "CALL balance_department_resources(3, 200000.0, 'Alabama', 68.0, 'No');",
      "CALL balance_department_resources(1, 50000.0, 'Texas', 69.0, 'Yes');",
      "CALL balance_department_resources(2, 150000.0, 'New York', 67.0, 'No');",
      "CALL balance_department_resources(3, 250000.0, 'Florida', 68.0, 'Yes');"
    ],
    "summary": "Create a stored procedure named balance_department_resources that calculates department, head, and budget metrics. If the department count exceeds eligible heads, delete management records for heads from an excluded state and insert up to three new management records from a cross-join of filtered departments and heads. If not, but the maximum budget is below 1000, delete management records for departments with budgets below that maximum. Otherwise, insert three hardcoded management records.",
    "natural_language": "Alright, so we need a stored procedure called balance_department_resources. Here's the deal: it's gotta figure out some numbers for departments, their heads, and budgets. If there are more departments than there are eligible heads, then we gotta clean house a bitdelete the management records for any heads from that one state we're not including. After that, we can add up to three new management entries by mixing and matching the filtered departments and heads. If that first situation isn't true, but the biggest budget we've got is less than 1000, then we need to delete management records for any departments whose budgets are below that top number. And if neither of those things pan out? Just plug in three set-in-stone management records.",
    "id": 86,
    "generated_ir": "Write a PLpgSQL stored procedure named balance_department_resources that accepts five input parameters: an integer p_ranking_filter, a real number p_employee_target, a text p_state_exclusion, a real number p_age_exclusion, and a text p_status_target. The procedure begins by declaring three local variables: v_total_departments as integer, v_eligible_heads as integer, and v_max_budget as real. It first calculates v_total_departments by counting all rows from the department table where the Ranking column is less than or equal to the p_ranking_filter parameter. It then calculates v_eligible_heads by counting all rows from the head table where the born_state column is not equal to p_state_exclusion and the age column is not equal to p_age_exclusion. Next, it determines v_max_budget by selecting the maximum value from the Budget_in_Billions column in the department table, but only for rows where the Num_Employees column is greater than the p_employee_target parameter. The procedure then executes a conditional IF-ELSIF-ELSE block. If v_total_departments is greater than v_eligible_heads, it performs two operations: first, it deletes rows from the management table by joining it with the head table on head_ID, specifically deleting any management record where the associated head's born_state column equals the p_state_exclusion parameter; second, it inserts up to three new rows into the management table, specifying columns department_ID, head_ID, and temporary_acting, by performing a cross join between the department and head tables, selecting department_ID from department where its Ranking is less than or equal to p_ranking_filter, and head_ID from head where its born_state is not equal to p_state_exclusion, and setting the temporary_acting column to the value of p_status_target, limiting the total inserted rows to three. Otherwise, if the first condition is false and v_max_budget is less than 1000, it deletes rows from the management table where the department_ID matches any Department_ID from the department table where the Budget_in_Billions column is less than the calculated v_max_budget. If neither of the previous conditions is true, the procedure executes the ELSE branch, which inserts three specific rows into the management table with hardcoded values: (2, 2, p_status_target), (3, 3, p_status_target), and (4, 4, p_status_target)."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named synchronize_lens_photo_data that accepts four parameters: p_aperture_limit of type real, p_mountain_min of type integer, p_brand_select of type text, and p_color_select of type text. The procedure begins by declaring three local variables: v_lens_id of type integer, v_photo_record of type record, and v_counter of type integer initialized to 0. It then enters a loop that iterates over each lens ID from the camera_lens table where the brand matches p_brand_select and the max_aperture is less than or equal to p_aperture_limit. For each lens ID, it counts the number of records in the photos table where the camera_lens_id matches the current lens ID, the mountain_id is greater than or equal to p_mountain_min, and the color matches p_color_select, storing this count in v_counter. If v_counter is zero, it inserts a new record into the photos table with a randomly generated ID based on the lens ID, the current lens ID, a mountain_id calculated as p_mountain_min plus the modulus of the lens ID by 20, the color specified by p_color_select, and a name prefixed with 'Synced ' followed by p_brand_select. If v_counter is greater than 5, it deletes records from the photos table where the camera_lens_id matches the current lens ID, the color matches p_color_select, and the ID is among the lowest mountain_id values, limiting the deletion to v_counter minus 3 records. If v_counter is between 1 and 5, it inserts additional records into the photos table, generating IDs based on the lens ID and row number, setting the camera_lens_id to the current lens ID, calculating mountain_id as p_mountain_min plus the modulus of the lens ID plus row number by 30, setting the color to p_color_select if the modulus of the lens ID by 3 is zero, otherwise setting it to 'RBG', and assigning a name prefixed with 'Additional ' followed by p_brand_select, iterating from 1 to 5 minus v_counter using generate_series.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_lens_photo_data(p_aperture_limit real, p_mountain_min integer, p_brand_select text, p_color_select text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_lens_id integer;\n    v_photo_record record;\n    v_counter integer := 0;\nBEGIN\n    FOR v_lens_id IN \n        SELECT \"id\" FROM \"camera_lens\" \n        WHERE \"brand\" = p_brand_select \n        AND \"max_aperture\" <= p_aperture_limit\n    LOOP\n        SELECT COUNT(*) INTO v_counter\n        FROM \"photos\"\n        WHERE \"camera_lens_id\" = v_lens_id\n        AND \"mountain_id\" >= p_mountain_min\n        AND \"color\" = p_color_select;\n        \n        IF v_counter = 0 THEN\n            INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n            VALUES (\n                FLOOR(RANDOM() * 1000000) + v_lens_id,\n                v_lens_id,\n                p_mountain_min + MOD(v_lens_id, 20),\n                p_color_select,\n                'Synced ' || p_brand_select\n            );\n        ELSIF v_counter > 5 THEN\n            DELETE FROM \"photos\"\n            WHERE \"camera_lens_id\" = v_lens_id\n            AND \"color\" = p_color_select\n            AND \"id\" IN (\n                SELECT \"id\" FROM \"photos\"\n                WHERE \"camera_lens_id\" = v_lens_id\n                AND \"color\" = p_color_select\n                ORDER BY \"mountain_id\" ASC\n                LIMIT v_counter - 3\n            );\n        ELSE\n            INSERT INTO \"photos\" (\"id\", \"camera_lens_id\", \"mountain_id\", \"color\", \"name\")\n            SELECT \n                FLOOR(RANDOM() * 1000000) + v_lens_id + row_number() OVER (),\n                v_lens_id,\n                p_mountain_min + MOD(v_lens_id + row_number() OVER (), 30),\n                CASE WHEN MOD(v_lens_id, 3) = 0 THEN p_color_select ELSE 'RBG' END,\n                'Additional ' || p_brand_select\n            FROM generate_series(1, 5 - v_counter);\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "photos"
    ],
    "call_sqls": [
      "CALL synchronize_lens_photo_data(8.0, 1, 'Olympus', 'RBG');",
      "CALL synchronize_lens_photo_data(1.8, 5, 'Olympus', 'Black/White');",
      "CALL synchronize_lens_photo_data(4.0, 10, 'Olympus', 'Blue');",
      "CALL synchronize_lens_photo_data(2.8, 2, 'Olympus', 'Green');",
      "CALL synchronize_lens_photo_data(16.0, 15, 'Olympus', 'Red');"
    ],
    "summary": "Create a stored procedure named synchronize_lens_photo_data with parameters p_aperture_limit (real), p_mountain_min (integer), p_brand_select (text), and p_color_select (text). For each lens from camera_lens where brand matches p_brand_select and max_aperture <= p_aperture_limit, count matching photos (mountain_id >= p_mountain_min, color matches p_color_select). If count is 0, insert a new photo with a generated ID, the lens ID, a calculated mountain_id (p_mountain_min + lens_id % 20), the specified color, and a name prefixed 'Synced '. If count > 5, delete the oldest (lowest mountain_id) records, keeping only 3. If count is between 1 and 5, insert additional photos (up to 5 total) with generated IDs, the lens ID, a calculated mountain_id (p_mountain_min + (lens_id + row_num) % 30), a color based on lens_id % 3, and a name prefixed 'Additional '.",
    "natural_language": "Write a stored procedure called synchronize_lens_photo_data that takes p_aperture_limit (real), p_mountain_min (integer), p_brand_select (text), and p_color_select (text) as parameters. For each lens in camera_lens where the brand equals p_brand_select and the max_aperture is less than or equal to p_aperture_limit, count the photos that match (mountain_id is at least p_mountain_min and color equals p_color_select). If the count is zero, insert a new photo with a generated ID, the lens ID, a mountain_id calculated as p_mountain_min plus lens_id modulo 20, the specified color, and a name starting with 'Synced '. If the count exceeds 5, delete the oldest records (those with the lowest mountain_id), leaving only 3. If the count is between 1 and 5, insert extra photos to bring the total to 5. For these extra photos, use generated IDs, the lens ID, a mountain_id calculated as p_mountain_min plus (lens_id plus a row number) modulo 30, a color determined by lens_id modulo 3, and a name starting with 'Additional '.",
    "id": 87,
    "generated_ir": "Write a PLpgSQL stored procedure named synchronize_lens_photo_data that accepts four parameters: p_aperture_limit of type real, p_mountain_min of type integer, p_brand_select of type text, and p_color_select of type text. The procedure begins by declaring three local variables: v_lens_id of type integer, v_photo_record of type record, and v_counter of type integer initialized to 0. It then enters a loop that iterates over each lens ID from the camera_lens table where the brand matches p_brand_select and the max_aperture is less than or equal to p_aperture_limit. For each lens ID, it counts the number of records in the photos table where the camera_lens_id matches the current lens ID, the mountain_id is greater than or equal to p_mountain_min, and the color matches p_color_select, storing this count in v_counter. If v_counter is zero, it inserts a new record into the photos table with a randomly generated ID based on the lens ID, the current lens ID, a mountain_id calculated as p_mountain_min plus the modulus of the lens ID by 20, the color specified by p_color_select, and a name prefixed with 'Synced ' followed by p_brand_select. If v_counter is greater than 5, it deletes records from the photos table where the camera_lens_id matches the current lens ID, the color matches p_color_select, and the ID is among the lowest mountain_id values, limiting the deletion to v_counter minus 3 records. If v_counter is between 1 and 5, it inserts additional records into the photos table, generating IDs based on the lens ID and row number, setting the camera_lens_id to the current lens ID, calculating mountain_id as p_mountain_min plus the modulus of the lens ID plus row number by 30, setting the color to p_color_select if the modulus of the lens ID by 3 is zero, otherwise setting it to 'RBG', and assigning a name prefixed with 'Additional ' followed by p_brand_select, iterating from 1 to 5 minus v_counter using generate_series."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL stored procedure named remove_stock_by_criteria that accepts three input parameters: an integer parameter p_shop_id representing a specific shop identifier, an integer parameter p_device_id representing a specific device identifier, and an integer parameter p_min_quantity representing a minimum quantity threshold; the procedure performs a DELETE operation on the table named \"stock\", targeting all rows where the column \"Shop_ID\" exactly matches the provided p_shop_id value, and simultaneously the column \"Device_ID\" exactly matches the provided p_device_id value, and concurrently the column \"Quantity\" is greater than or equal to the provided p_min_quantity value.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_stock_by_criteria(IN p_shop_id INTEGER, IN p_device_id INTEGER, IN p_min_quantity INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"stock\" WHERE \"Shop_ID\" = p_shop_id AND \"Device_ID\" = p_device_id AND \"Quantity\" >= p_min_quantity;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL remove_stock_by_criteria(1, 6, 100);",
      "CALL remove_stock_by_criteria(2, 6, 110);",
      "CALL remove_stock_by_criteria(3, 6, 134);",
      "CALL remove_stock_by_criteria(1, 6, 50);",
      "CALL remove_stock_by_criteria(2, 6, 200);"
    ],
    "summary": "Create a stored procedure named `remove_stock_by_criteria` that takes three integer parameters: `p_shop_id`, `p_device_id`, and `p_min_quantity`. It deletes rows from the stock table where Shop_ID equals `p_shop_id`, Device_ID equals `p_device_id`, and Quantity is >= `p_min_quantity`.",
    "natural_language": "Please construct a stored procedure designated as `remove_stock_by_criteria`. This procedure is to accept three integer input parameters: `p_shop_id`, `p_device_id`, and `p_min_quantity`. Its function is to delete records from the stock table where the Shop_ID column matches the provided `p_shop_id`, the Device_ID column matches the provided `p_device_id`, and the Quantity column is greater than or equal to the specified `p_min_quantity`.",
    "id": 88,
    "generated_ir": "Write a PostgreSQL PLpgSQL stored procedure named remove_stock_by_criteria that accepts three input parameters: an integer parameter p_shop_id representing a specific shop identifier, an integer parameter p_device_id representing a specific device identifier, and an integer parameter p_min_quantity representing a minimum quantity threshold; the procedure performs a DELETE operation on the table named \"stock\", targeting all rows where the column \"Shop_ID\" exactly matches the provided p_shop_id value, and simultaneously the column \"Device_ID\" exactly matches the provided p_device_id value, and concurrently the column \"Quantity\" is greater than or equal to the provided p_min_quantity value."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named create_musical_summary that accepts three input parameters: an integer p_start_year, an integer p_end_year, and a text p_category_filter. The procedure first declares three local integer variables: v_musical_count, v_new_musical_id, and v_summary_year. It begins execution by performing a SELECT query on the musical table to count all rows where the Year column value falls inclusively between the p_start_year and p_end_year parameters and where the Category column contains the string from p_category_filter as a substring, achieved by using the LIKE operator with wildcard characters '%' on both sides of the filter parameter; the resulting count is stored in v_musical_count. Next, it executes another SELECT query to retrieve the maximum existing value from the Musical_ID column in the musical table, applies the COALESCE function to substitute a value of 0 if the maximum is NULL, adds 1 to this value, and assigns the result to v_new_musical_id. It then calculates v_summary_year by taking the average of p_start_year and p_end_year, dividing their sum by 2, and applying the FLOOR function to the result to obtain an integer. Finally, the procedure performs an INSERT operation into the musical table, specifying values for the columns Musical_ID, Name, Year, Award, Category, Nominee, and Result. The inserted values are: v_new_musical_id for Musical_ID; a string concatenation of the literal 'Summary Report ' and the text cast of v_musical_count for Name; v_summary_year for Year; the literal string 'Summary Award' for Award; the p_category_filter parameter for Category; the literal string 'System Generated' for Nominee; and the literal string 'Completed' for Result.",
    "plsql": "CREATE OR REPLACE PROCEDURE create_musical_summary(IN p_start_year integer, IN p_end_year integer, IN p_category_filter text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_musical_count integer;\n    v_new_musical_id integer;\n    v_summary_year integer;\nBEGIN\n    SELECT COUNT(*) INTO v_musical_count \n    FROM musical \n    WHERE \"Year\" BETWEEN p_start_year AND p_end_year \n    AND \"Category\" LIKE '%' || p_category_filter || '%';\n    \n    SELECT COALESCE(MAX(\"Musical_ID\"), 0) + 1 INTO v_new_musical_id FROM musical;\n    v_summary_year := FLOOR((p_start_year + p_end_year) / 2);\n    \n    INSERT INTO musical (\"Musical_ID\", \"Name\", \"Year\", \"Award\", \"Category\", \"Nominee\", \"Result\")\n    VALUES (\n        v_new_musical_id,\n        'Summary Report ' || v_musical_count::text,\n        v_summary_year,\n        'Summary Award',\n        p_category_filter,\n        'System Generated',\n        'Completed'\n    );\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "CALL create_musical_summary(1980, 1990, 'Best Book');",
      "CALL create_musical_summary(1990, 2000, 'Best Performance');",
      "CALL create_musical_summary(2000, 2010, 'Best Direction');",
      "CALL create_musical_summary(1985, 1995, 'Musical');",
      "CALL create_musical_summary(2010, 2020, 'Award');"
    ],
    "summary": "Create a stored procedure named create_musical_summary that counts musicals within a year range and matching a category substring. It then generates a new musical ID, calculates a summary year, and inserts a summary report record into the musical table with these calculated values.",
    "natural_language": "Please construct a stored procedure designated as 'create_musical_summary'. This procedure shall perform the following operations: it must count the number of musicals that fall within a specified year range and whose category contains a given substring. Subsequently, it is to generate a new musical identifier, compute a summary year, and finally insert a record into the musical table. This new record will constitute a summary report containing the aforementioned calculated values.",
    "id": 89,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named create_musical_summary that accepts three input parameters: an integer p_start_year, an integer p_end_year, and a text p_category_filter. The procedure first declares three local integer variables: v_musical_count, v_new_musical_id, and v_summary_year. It begins execution by performing a SELECT query on the musical table to count all rows where the Year column value falls inclusively between the p_start_year and p_end_year parameters and where the Category column contains the string from p_category_filter as a substring, achieved by using the LIKE operator with wildcard characters '%' on both sides of the filter parameter; the resulting count is stored in v_musical_count. Next, it executes another SELECT query to retrieve the maximum existing value from the Musical_ID column in the musical table, applies the COALESCE function to substitute a value of 0 if the maximum is NULL, adds 1 to this value, and assigns the result to v_new_musical_id. It then calculates v_summary_year by taking the average of p_start_year and p_end_year, dividing their sum by 2, and applying the FLOOR function to the result to obtain an integer. Finally, the procedure performs an INSERT operation into the musical table, specifying values for the columns Musical_ID, Name, Year, Award, Category, Nominee, and Result. The inserted values are: v_new_musical_id for Musical_ID; a string concatenation of the literal 'Summary Report ' and the text cast of v_musical_count for Name; v_summary_year for Year; the literal string 'Summary Award' for Award; the p_category_filter parameter for Category; the literal string 'System Generated' for Nominee; and the literal string 'Completed' for Result."
  },
  {
    "ir": "Write a PostgreSQL stored procedure named populate_club_leadership that accepts two input parameters: an integer p_min_age representing a minimum age threshold and an integer p_max_ranking representing a maximum ranking threshold. The procedure begins by declaring local integer variables v_club_id and v_member_id, and a text variable v_join_year. It initializes v_join_year by converting the current system date to a four-digit year string using the TO_CHAR function with the format 'YYYY'. It then queries the club table to select a single Club_ID value, assigning it to v_club_id, where the Overall_Ranking column is less than or equal to the p_max_ranking parameter, ordering the results by Overall_Ranking in ascending order and limiting the result to one row. Subsequently, it queries the member table to select a single Member_ID value, assigning it to v_member_id, where the Age column is greater than or equal to the p_min_age parameter and the length of the Name column is greater than 8 characters, ordering the results by Age in descending order and limiting the result to one row. If both v_club_id and v_member_id are not null, the procedure performs an insert into the club_leader table for the columns Club_ID, Member_ID, and Year_Join using the values from the variables v_club_id, v_member_id, and v_join_year, but only if a row with the same Club_ID and Member_ID combination does not already exist in the club_leader table, as determined by a WHERE NOT EXISTS subquery that selects the constant 1 from club_leader where Club_ID equals v_club_id and Member_ID equals v_member_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE populate_club_leadership(p_min_age integer, p_max_ranking integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_club_id integer;\n    v_member_id integer;\n    v_join_year text;\nBEGIN\n    v_join_year := TO_CHAR(CURRENT_DATE, 'YYYY');\n    \n    SELECT \"Club_ID\" INTO v_club_id FROM club WHERE \"Overall_Ranking\" <= p_max_ranking ORDER BY \"Overall_Ranking\" LIMIT 1;\n    SELECT \"Member_ID\" INTO v_member_id FROM member WHERE \"Age\" >= p_min_age AND LENGTH(\"Name\") > 8 ORDER BY \"Age\" DESC LIMIT 1;\n    \n    IF v_club_id IS NOT NULL AND v_member_id IS NOT NULL THEN\n        INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") \n        SELECT v_club_id, v_member_id, v_join_year\n        WHERE NOT EXISTS (\n            SELECT 1 FROM club_leader \n            WHERE \"Club_ID\" = v_club_id AND \"Member_ID\" = v_member_id\n        );\n    END IF;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL populate_club_leadership(20, 50);",
      "CALL populate_club_leadership(25, 30);",
      "CALL populate_club_leadership(18, 100);",
      "CALL populate_club_leadership(30, 10);",
      "CALL populate_club_leadership(22, 75);"
    ],
    "summary": "Create a stored procedure named populate_club_leadership that takes a minimum age and a maximum ranking. Select the club with the lowest ranking that meets the maximum ranking threshold. Select the oldest member who meets the minimum age and has a name longer than 8 characters. If both a club and a member are found, insert a record into the club_leader table for the current year, but only if the combination does not already exist.",
    "natural_language": "Construct a stored procedure called populate_club_leadership, which is designed to accept two distinct parameters: a specified minimum age and a defined maximum ranking. The procedure must first identify the single club that possesses the very lowest ranking, provided that this ranking does not exceed the supplied maximum threshold. Subsequently, it should locate the most elderly member from the entire roster, who is both at or above the stipulated minimum age and has a full name consisting of more than eight characters in length. In the event that both a qualifying club and a suitable member are successfully discovered, the procedure must then insert a new entry into the club_leader table for the present calendar year, taking careful precaution to ensure that this precise club-member pairing is not already recorded in the table to avoid any duplication.",
    "id": 90,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named populate_club_leadership that accepts two input parameters: p_min_age of type integer, which specifies the minimum age threshold for selecting a member, and p_max_ranking of type integer, which defines the maximum allowable ranking for selecting a club. The procedure first declares variables to store intermediate results: v_lowest_ranking_club_id of type integer to hold the Club_ID of the club with the lowest ranking, v_lowest_ranking of type integer to store the actual lowest ranking value, v_oldest_member_id of type integer to hold the Member_ID of the oldest qualifying member, v_oldest_member_age of type integer to store the age of that member, and v_current_year of type text to capture the current year as a text string.\n\nThe procedure begins by retrieving the current year using the EXTRACT function to get the year from the current date and converting it to text, storing it in v_current_year. Next, it identifies the club with the lowest ranking by performing a SELECT operation on the club table, selecting the Club_ID and Overall_Ranking columns, filtering rows where the Overall_Ranking is less than or equal to the p_max_ranking parameter, ordering the results by Overall_Ranking in ascending order, and limiting the result to one row. The selected Club_ID and Overall_Ranking are stored into v_lowest_ranking_club_id and v_lowest_ranking, respectively. If no club meets the criteria, these variables remain NULL.\n\nThen, the procedure locates the oldest member by performing a SELECT operation on the member table, selecting the Member_ID and Age columns, filtering rows where the Age is greater than or equal to the p_min_age parameter and the length of the Name column is greater than 8 characters, ordering the results by Age in descending order, and limiting the result to one row. The selected Member_ID and Age are stored into v_oldest_member_id and v_oldest_member_age, respectively. If no member meets the criteria, these variables remain NULL.\n\nAfter obtaining both the club and member identifiers, the procedure checks if both v_lowest_ranking_club_id and v_oldest_member_id are not NULL. If either is NULL, the procedure exits without performing any further actions. If both are not NULL, it performs a validation to avoid duplicate entries by checking if a record already exists in the club_leader table where the Club_ID matches v_lowest_ranking_club_id and the Member_ID matches v_oldest_member_id. This is done using a SELECT COUNT operation on the club_leader table with these conditions. If the count is zero, indicating no existing record, the procedure inserts a new record into the club_leader table with the following values: Club_ID set to v_lowest_ranking_club_id, Member_ID set to v_oldest_member_id, and Year_Join set to v_current_year. If a duplicate record exists, the procedure does nothing and exits. The procedure does not return any value; it performs the insertion conditionally based on the logic described."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named calculate_artist_artwork_counts that accepts three input parameters: p_artist_id of type bigint to identify an artist, p_min_year of type bigint to specify the lower bound of a year range, and p_max_year of type bigint to specify the upper bound of a year range. The procedure first declares three local variables: v_painting_count of type bigint, v_sculpture_count of type bigint, and v_artist_exists of type boolean. It then calculates the number of paintings by performing a SELECT COUNT(*) query from the \"Paintings\" table where the \"painterID\" column equals the input p_artist_id and the \"year\" column is between p_min_year and p_max_year inclusive, storing the result in v_painting_count. Next, it calculates the number of sculptures by performing a SELECT COUNT(*) query from the \"Sculptures\" table where the \"sculptorID\" column equals the input p_artist_id and the \"year\" column is between p_min_year and p_max_year inclusive, storing the result in v_sculpture_count. The procedure then checks for the existence of the artist by performing a SELECT EXISTS query on the \"Artists\" table where the \"artistID\" column equals p_artist_id, storing the boolean result in v_artist_exists. If v_artist_exists is FALSE, the procedure inserts a new row into the \"Artists\" table with the provided p_artist_id as \"artistID\", 'Temp' as \"lname\", 'Artist' as \"fname\", 1900 as \"birthYear\", and 2000 as \"deathYear\". Finally, the procedure deletes all rows from the \"Paintings\" table where the \"painterID\" column equals p_artist_id and the \"year\" column is less than the input p_min_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_artist_artwork_counts(\n    p_artist_id bigint,\n    p_min_year bigint,\n    p_max_year bigint\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_painting_count bigint;\n    v_sculpture_count bigint;\n    v_artist_exists boolean;\nBEGIN\n    SELECT COUNT(*) INTO v_painting_count\n    FROM \"Paintings\"\n    WHERE \"painterID\" = p_artist_id AND \"year\" BETWEEN p_min_year AND p_max_year;\n    \n    SELECT COUNT(*) INTO v_sculpture_count\n    FROM \"Sculptures\"\n    WHERE \"sculptorID\" = p_artist_id AND \"year\" BETWEEN p_min_year AND p_max_year;\n    \n    SELECT EXISTS(SELECT 1 FROM \"Artists\" WHERE \"artistID\" = p_artist_id) INTO v_artist_exists;\n    \n    IF NOT v_artist_exists THEN\n        INSERT INTO \"Artists\" (\"artistID\", \"lname\", \"fname\", \"birthYear\", \"deathYear\")\n        VALUES (p_artist_id, 'Temp', 'Artist', 1900, 2000);\n    END IF;\n    \n    DELETE FROM \"Paintings\"\n    WHERE \"painterID\" = p_artist_id AND \"year\" < p_min_year;\nEND;\n$$;",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "CALL calculate_artist_artwork_counts(111, 1880, 1890);",
      "CALL calculate_artist_artwork_counts(222, 1940, 1950);",
      "CALL calculate_artist_artwork_counts(333, 1850, 1860);",
      "CALL calculate_artist_artwork_counts(555, 1880, 1890);",
      "CALL calculate_artist_artwork_counts(999, 1900, 2000);"
    ],
    "summary": "Create a stored procedure named calculate_artist_artwork_counts with parameters p_artist_id, p_min_year, and p_max_year. Count paintings and sculptures for the artist within the year range. If the artist does not exist, insert a temporary artist record. Finally, delete all paintings by the artist created before p_min_year.",
    "natural_language": "Develop a stored procedure, which should be named calculate_artist_artwork_counts, that accepts three distinct parameters: p_artist_id, p_min_year, and p_max_year. This procedure must meticulously count the total number of paintings and sculptures produced by the specified artist within the provided inclusive year range. Importantly, if the artist's record cannot be found in the database, the procedure should gracefully insert a temporary record for that artist. Subsequently, as a final step, it must comprehensively delete every single painting created by that particular artist which dates from before the specified p_min_year threshold.",
    "id": 91,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named calculate_artist_artwork_counts that accepts three input parameters: p_artist_id of type bigint to identify an artist, p_min_year of type bigint to specify the lower bound of a year range, and p_max_year of type bigint to specify the upper bound of a year range. The procedure first declares three local variables: v_painting_count of type bigint, v_sculpture_count of type bigint, and v_artist_exists of type boolean. It then calculates the number of paintings by performing a SELECT COUNT(*) query from the \"Paintings\" table where the \"painterID\" column equals the input p_artist_id and the \"year\" column is between p_min_year and p_max_year inclusive, storing the result in v_painting_count. Next, it calculates the number of sculptures by performing a SELECT COUNT(*) query from the \"Sculptures\" table where the \"sculptorID\" column equals the input p_artist_id and the \"year\" column is between p_min_year and p_max_year inclusive, storing the result in v_sculpture_count. The procedure then checks for the existence of the artist by performing a SELECT EXISTS query on the \"Artists\" table where the \"artistID\" column equals p_artist_id, storing the boolean result in v_artist_exists. If v_artist_exists is FALSE, the procedure inserts a new row into the \"Artists\" table with the provided p_artist_id as \"artistID\", 'Temp' as \"lname\", 'Artist' as \"fname\", 1900 as \"birthYear\", and 2000 as \"deathYear\". Finally, the procedure deletes all rows from the \"Paintings\" table where the \"painterID\" column equals p_artist_id and the \"year\" column is less than the input p_min_year."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"DeleteOldCourses\" that accepts one input parameter called cutoff_date of type TEXT, which is intended to represent a date string used as a boundary for deletion, and performs a conditional delete operation on the \"course\" table: if the provided cutoff_date parameter is not NULL, the procedure executes a DELETE statement that removes all rows from the \"course\" table where the value in the column named \"Staring_Date\", after being converted to a date using the TO_DATE function with the format mask 'DD Mon' (interpreted as day of month followed by a space and an abbreviated month name), is chronologically earlier than the date derived from the cutoff_date input string, which is also converted to a date using the TO_DATE function with the identical 'DD Mon' format mask.",
    "plsql": "CREATE OR REPLACE PROCEDURE \"DeleteOldCourses\"(cutoff_date TEXT)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF cutoff_date IS NOT NULL THEN\n        DELETE FROM \"course\"\n        WHERE TO_DATE(\"Staring_Date\", 'DD Mon') < TO_DATE(cutoff_date, 'DD Mon');\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course"
    ],
    "call_sqls": [
      "CALL \"DeleteOldCourses\"('1 May');",
      "CALL \"DeleteOldCourses\"('10 May');",
      "CALL \"DeleteOldCourses\"('15 Apr');",
      "CALL \"DeleteOldCourses\"('31 Dec');",
      "CALL \"DeleteOldCourses\"(NULL);"
    ],
    "summary": "Create a stored procedure named DeleteOldCourses that deletes all courses whose starting date (in 'DD Mon' format) is earlier than a specified cutoff date, but only if the cutoff date is provided.",
    "natural_language": "Create procedure DeleteOldCourses to remove courses starting before a given cutoff date, if provided.",
    "id": 92,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named \"DeleteOldCourses\" that accepts one input parameter called cutoff_date of type TEXT, which is intended to represent a date string used as a boundary for deletion, and performs a conditional delete operation on the \"course\" table: if the provided cutoff_date parameter is not NULL, the procedure executes a DELETE statement that removes all rows from the \"course\" table where the value in the column named \"Staring_Date\", after being converted to a date using the TO_DATE function with the format mask 'DD Mon' (interpreted as day of month followed by a space and an abbreviated month name), is chronologically earlier than the date derived from the cutoff_date input string, which is also converted to a date using the TO_DATE function with the identical 'DD Mon' format mask."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named `transfer_members_between_clubs` that accepts two integer parameters: `p_source_club_id` and `p_target_club_id`. The `p_source_club_id` parameter represents the unique identifier of the club from which members are to be transferred, and the `p_target_club_id` parameter represents the unique identifier of the club to which members will be transferred. The procedure begins by declaring two local variables: `v_member_record`, which is of type `RECORD` and will be used to hold individual member records during iteration, and `v_current_year`, which is of type `text` and will store the current year. The procedure first initializes `v_current_year` by calling the `TO_CHAR` function with `CURRENT_DATE` and the format mask 'YYYY', effectively extracting the four-digit year from the current date. Following this, the procedure enters a `FOR` loop that iterates over a result set obtained by selecting the `Member_ID` column from the `club_leader` table. The selection is filtered by a `WHERE` clause where the `Club_ID` column matches the value provided in the `p_source_club_id` parameter. For each `v_member_record` retrieved in this loop, the procedure performs two operations. First, it executes a `DELETE` statement on the `club_leader` table, removing rows where the `Club_ID` column matches `p_source_club_id` AND the `Member_ID` column matches the `Member_ID` value from the current `v_member_record`. Second, it executes an `INSERT` statement into the `club_leader` table, adding a new row with values for `Club_ID` set to `p_target_club_id`, `Member_ID` set to the `Member_ID` from the current `v_member_record`, and `Year_Join` set to the `v_current_year` variable. This sequence of operations effectively moves each member associated with the source club to the target club by deleting their association with the source club and creating a new association with the target club, recording the current year as their join year for the new club.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_members_between_clubs(p_source_club_id integer, p_target_club_id integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_member_record RECORD;\n    v_current_year text;\nBEGIN\n    v_current_year := TO_CHAR(CURRENT_DATE, 'YYYY');\n    \n    FOR v_member_record IN \n        SELECT \"Member_ID\" FROM club_leader WHERE \"Club_ID\" = p_source_club_id\n    LOOP\n        DELETE FROM club_leader WHERE \"Club_ID\" = p_source_club_id AND \"Member_ID\" = v_member_record.\"Member_ID\";\n        INSERT INTO club_leader (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (p_target_club_id, v_member_record.\"Member_ID\", v_current_year);\n    END LOOP;\nEND;\n$$;",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "CALL transfer_members_between_clubs(1, 3);",
      "CALL transfer_members_between_clubs(3, 4);",
      "CALL transfer_members_between_clubs(4, 1);",
      "CALL transfer_members_between_clubs(1, 4);",
      "CALL transfer_members_between_clubs(3, 1);"
    ],
    "summary": "Create a stored procedure named transfer_members_between_clubs that takes a source club ID and a target club ID. For each member associated with the source club in the club_leader table, delete that association and insert a new association with the target club, setting the join year to the current year.",
    "natural_language": "Please construct a stored procedure designated as 'transfer_members_between_clubs'. This procedure must accept two input parameters: a source club identifier and a target club identifier. For every member currently affiliated with the source club as recorded in the club_leader table, the procedure shall remove that existing affiliation. Subsequently, it shall establish a new affiliation for each such member with the specified target club, assigning the current year as the join year.",
    "id": 93,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named transfer_members_between_clubs that accepts two input parameters: a source club identifier and a target club identifier, both of type integer. The procedure operates on the club_leader table within the club_leader database. It first performs a SELECT query to retrieve all Member_ID values from the club_leader table where the Club_ID column matches the provided source club identifier parameter, storing these member IDs in a result set. For each member ID in this result set, the procedure executes two sequential database operations. First, it performs a DELETE operation on the club_leader table to remove the existing affiliation record where both Club_ID equals the source club identifier and Member_ID equals the current member ID from the result set. Second, it performs an INSERT operation into the club_leader table to create a new affiliation record. This new record sets the Club_ID column to the value of the target club identifier parameter, sets the Member_ID column to the current member ID, and sets the Year_Join column to a text representation of the current calendar year obtained by calling the EXTRACT(YEAR FROM CURRENT_DATE) function and casting the result to text. The procedure processes all members associated with the source club, effectively transferring their affiliations to the target club with an updated join year. The procedure does not return a value."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `add_new_stock_entry` that accepts three input parameters: `new_shop_id` of type `INTEGER`, representing the unique identifier for a shop; `new_device_id` of type `INTEGER`, representing the unique identifier for a device; and `initial_quantity` of type `INTEGER`, representing the quantity of the device to be added or updated in stock. The procedure performs an `INSERT` operation into the `stock` table. Specifically, it attempts to insert a new row with the value of `new_shop_id` into the `\"Shop_ID\"` column, the value of `new_device_id` into the `\"Device_ID\"` column, and the value of `initial_quantity` into the `\"Quantity\"` column. This `INSERT` operation includes an `ON CONFLICT` clause that specifies a conflict target on the combination of the `\"Shop_ID\"` and `\"Device_ID\"` columns. If a conflict occurs (i.e., a row with the same `\"Shop_ID\"` and `\"Device_ID\"` already exists in the `stock` table), the procedure executes an `UPDATE` operation instead of inserting a new row. During this `UPDATE`, the `\"Quantity\"` column of the existing row in the `stock` table is incremented by the value of `EXCLUDED.\"Quantity\"`, which refers to the `initial_quantity` value that was attempted to be inserted. After the `INSERT` or `UPDATE` operation is completed, the procedure issues a `RAISE NOTICE` statement. This notice message, formatted as 'Added/updated stock entry for shop % and device % with quantity %', displays the values of `new_shop_id`, `new_device_id`, and `initial_quantity` to the client, indicating that a stock entry has been successfully added or updated for the specified shop and device with the given quantity.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_new_stock_entry(IN new_shop_id INTEGER, IN new_device_id INTEGER, IN initial_quantity INTEGER)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO stock (\"Shop_ID\", \"Device_ID\", \"Quantity\")\n    VALUES (new_shop_id, new_device_id, initial_quantity)\n    ON CONFLICT (\"Shop_ID\", \"Device_ID\") \n    DO UPDATE SET \"Quantity\" = stock.\"Quantity\" + EXCLUDED.\"Quantity\";\n    \n    RAISE NOTICE 'Added/updated stock entry for shop % and device % with quantity %', new_shop_id, new_device_id, initial_quantity;\nEND;\n$$;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "CALL add_new_stock_entry(1, 1, 50);",
      "CALL add_new_stock_entry(2, 2, 75);",
      "CALL add_new_stock_entry(3, 3, 100);",
      "CALL add_new_stock_entry(1, 2, 60);",
      "CALL add_new_stock_entry(2, 3, 80);"
    ],
    "summary": "Create a stored procedure named add_new_stock_entry that accepts a shop ID, device ID, and initial quantity. It inserts a new stock entry. If an entry for that shop and device already exists, it updates the quantity by adding the new value. Upon completion, it outputs a notice confirming the addition or update.",
    "natural_language": "Develop a stored procedure, which should be named 'add_new_stock_entry', that is designed to accept three distinct input parameters: a specific shop identifier, a corresponding device identifier, and an initial quantity value for stock. This procedure will meticulously insert a brand new entry into the stock records. However, if a pre-existing stock entry for that precise combination of shop and device is already found within the database, the procedure will instead intelligently update the current quantity by carefully adding the newly provided value to the existing amount. Upon its successful completion, the procedure must gracefully output a clear and descriptive notice that explicitly confirms whether a new addition or an update to an existing record has been performed.",
    "id": 94,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `add_new_stock_entry` that accepts three input parameters: `new_shop_id` of type `INTEGER`, representing the unique identifier for a shop; `new_device_id` of type `INTEGER`, representing the unique identifier for a device; and `initial_quantity` of type `INTEGER`, representing the quantity of the device to be added or updated in stock. The procedure performs an `INSERT` operation into the `stock` table. Specifically, it attempts to insert a new row with the value of `new_shop_id` into the `\"Shop_ID\"` column, the value of `new_device_id` into the `\"Device_ID\"` column, and the value of `initial_quantity` into the `\"Quantity\"` column. This `INSERT` operation includes an `ON CONFLICT` clause that specifies a conflict target on the combination of the `\"Shop_ID\"` and `\"Device_ID\"` columns. If a conflict occurs (i.e., a row with the same `\"Shop_ID\"` and `\"Device_ID\"` already exists in the `stock` table), the procedure executes an `UPDATE` operation instead of inserting a new row. During this `UPDATE`, the `\"Quantity\"` column of the existing row in the `stock` table is incremented by the value of `EXCLUDED.\"Quantity\"`, which refers to the `initial_quantity` value that was attempted to be inserted. After the `INSERT` or `UPDATE` operation is completed, the procedure issues a `RAISE NOTICE` statement. This notice message, formatted as 'Added/updated stock entry for shop % and device % with quantity %', displays the values of `new_shop_id`, `new_device_id`, and `initial_quantity` to the client, indicating that a stock entry has been successfully added or updated for the specified shop and device with the given quantity."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes two input parameters, teacher_id of type integer and grade of type integer, and performs conditional operations on the teacher and course_arrange tables. First, it checks if a row exists in the teacher table where the Teacher_ID column matches the value of teacher_id. If such a row exists, it updates the Grade column in the course_arrange table to the value of grade for all rows where the Teacher_ID column matches teacher_id. If no row exists in the teacher table with the specified Teacher_ID and no row exists in the course_arrange table where the Teacher_ID column matches teacher_id, it inserts a new row into the course_arrange table with the values 1 for the Course_ID column, teacher_id for the Teacher_ID column, and grade for the Grade column. If neither of the above conditions is met, meaning a row exists in the course_arrange table with the specified Teacher_ID but no corresponding row exists in the teacher table, it deletes all rows from the course_arrange table where the Teacher_ID column matches teacher_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_grade_to_teacher(IN teacher_id integer, IN grade integer)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"teacher\" WHERE \"Teacher_ID\" = teacher_id) THEN\n        UPDATE \"course_arrange\"\n        SET \"Grade\" = grade\n        WHERE \"Teacher_ID\" = teacher_id;\n    ELSIF NOT EXISTS (SELECT 1 FROM \"course_arrange\" WHERE \"Teacher_ID\" = teacher_id) THEN\n        INSERT INTO \"course_arrange\" (\"Course_ID\", \"Teacher_ID\", \"Grade\")\n        VALUES (1, teacher_id, grade);\n    ELSE\n        DELETE FROM \"course_arrange\" WHERE \"Teacher_ID\" = teacher_id;\n    END IF;\nEND;\n$$;",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "CALL assign_grade_to_teacher(1, 4);",
      "CALL assign_grade_to_teacher(2, 5);",
      "CALL assign_grade_to_teacher(3, 3);",
      "CALL assign_grade_to_teacher(5, 2);",
      "CALL assign_grade_to_teacher(6, 1);"
    ],
    "summary": "Create a stored procedure that accepts teacher_id (integer) and grade (integer). If the teacher exists, update all course_arrange rows for that teacher with the grade. If the teacher does not exist and the teacher has no course_arrange records, insert a new course_arrange row (Course_ID=1, Teacher_ID=teacher_id, Grade=grade). If the teacher does not exist but has course_arrange records, delete all course_arrange rows for that teacher.",
    "natural_language": "Update course_arrange grade for a teacher. If teacher missing and has no records, insert new row. If teacher missing but has records, delete them.",
    "id": 95,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named assign_grade_to_teacher that operates within the course_teach database. The procedure accepts two input parameters: teacher_id_input of type integer, representing the identifier of a teacher, and grade_input of type integer, representing the grade value to be assigned. The procedure does not return a value.\n\nThe procedure begins by checking for the existence of the specified teacher in the teacher table. It performs a SELECT query on the teacher table, counting the number of rows where the Teacher_ID column matches the teacher_id_input parameter. The result is stored in a local variable, teacher_exists_flag, of type integer.\n\nBased on the value of teacher_exists_flag, the procedure executes one of two conditional branches.\n\nIf teacher_exists_flag is equal to 0, indicating the teacher does not exist in the teacher table, the procedure then checks if the teacher has any existing records in the course_arrange table. It performs a SELECT query on the course_arrange table, counting the number of rows where the Teacher_ID column matches the teacher_id_input parameter. The result is stored in a local variable, arrange_records_flag, of type integer.\n\nIf arrange_records_flag is equal to 0, meaning the teacher has no records in course_arrange, the procedure performs an INSERT operation. It inserts a new row into the course_arrange table. The values for the columns are set as follows: the Course_ID column is set to a default value of 0, the Teacher_ID column is set to the teacher_id_input parameter, and the Grade column is set to the grade_input parameter.\n\nIf arrange_records_flag is greater than 0, meaning the teacher has existing records in course_arrange despite not being in the teacher table, the procedure performs a DELETE operation. It deletes all rows from the course_arrange table where the Teacher_ID column matches the teacher_id_input parameter.\n\nIf teacher_exists_flag is greater than 0, indicating the teacher exists in the teacher table, the procedure performs an UPDATE operation on the course_arrange table. It updates the Grade column to the value of the grade_input parameter for all rows where the Teacher_ID column matches the teacher_id_input parameter. If no such rows exist, this UPDATE statement will affect zero rows."
  },
  {
    "ir": "Write a PL/pgSQL stored procedure named `analyze_ship_mission_stats` that accepts four input parameters: `p_nationality_filter` of type `text`, `p_min_tonnage` of type `integer`, `p_year_threshold` of type `integer`, and `p_fate_pattern` of type `text`. The procedure begins by declaring three local variables: `v_ship_count` of type `integer`, `v_avg_speed` of type `numeric`, and `v_mission_count` of type `integer`. The procedure then executes a `SELECT` statement to count the number of records in the `ship` table. This count is stored in the `v_ship_count` variable. The `ship` records are filtered based on two conditions: the value in the `\"Nationality\"` column must exactly match the `p_nationality_filter` parameter, and the value in the `\"Tonnage\"` column must be strictly greater than the `p_min_tonnage` parameter. Next, the procedure executes another `SELECT` statement to calculate the average of the `\"Speed_knots\"` column from the `mission` table. This average is stored in the `v_avg_speed` variable. This `SELECT` statement involves a `JOIN` operation between the `mission` table (aliased as `m`) and the `ship` table (aliased as `s`) on the condition that `m.\"Ship_ID\"` equals `s.\"Ship_ID\"`. The joined records are filtered based on two conditions: the value in the `s.\"Nationality\"` column must exactly match the `p_nationality_filter` parameter, and the value in the `m.\"Launched_Year\"` column must be strictly greater than the `p_year_threshold` parameter. Subsequently, the procedure executes a third `SELECT` statement to count the number of records in the `mission` table. This count is stored in the `v_mission_count` variable. The `mission` records are filtered based on a single condition: the value in the `\"Fate\"` column must contain the `p_fate_pattern` parameter as a substring, with the `LIKE` operator used for pattern matching, where `p_fate_pattern` is concatenated with wildcard characters (`%`) on both sides. Following these selections, the procedure performs an `INSERT` operation into the `ship` table, populating the columns `\"Ship_ID\"`, `\"Name\"`, `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"`. The value for `\"Ship_ID\"` is determined by a subquery that selects the maximum existing `\"Ship_ID\"` from the `ship` table, uses `COALESCE` to default to `0` if no `MAX` value is found, and then adds `1` to the result. The `\"Name\"` column is set to the literal string 'Analysis_Record'. The `\"Type\"` column is set to the literal string 'Statistical'. The `\"Nationality\"` column is set to the value of the `p_nationality_filter` parameter. The `\"Tonnage\"` column is set to the product of the `v_ship_count` variable and `1000`. Finally, the procedure executes a `DELETE` statement to remove records from the `mission` table. The records to be deleted are filtered based on two conditions: the value in the `\"Speed_knots\"` column must be strictly less than `10`, and the value in the `\"Launched_Year\"` column must be strictly less than the `p_year_threshold` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_ship_mission_stats(\n    p_nationality_filter text,\n    p_min_tonnage integer,\n    p_year_threshold integer,\n    p_fate_pattern text\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_ship_count integer;\n    v_avg_speed numeric;\n    v_mission_count integer;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_ship_count\n    FROM ship s\n    WHERE s.\"Nationality\" = p_nationality_filter\n    AND s.\"Tonnage\" > p_min_tonnage;\n\n    SELECT AVG(m.\"Speed_knots\")\n    INTO v_avg_speed\n    FROM mission m\n    JOIN ship s ON m.\"Ship_ID\" = s.\"Ship_ID\"\n    WHERE s.\"Nationality\" = p_nationality_filter\n    AND m.\"Launched_Year\" > p_year_threshold;\n\n    SELECT COUNT(*)\n    INTO v_mission_count\n    FROM mission m\n    WHERE m.\"Fate\" LIKE '%' || p_fate_pattern || '%';\n\n    INSERT INTO ship (\"Ship_ID\", \"Name\", \"Type\", \"Nationality\", \"Tonnage\")\n    VALUES (\n        (SELECT COALESCE(MAX(\"Ship_ID\"), 0) + 1 FROM ship),\n        'Analysis_Record',\n        'Statistical',\n        p_nationality_filter,\n        v_ship_count * 1000\n    );\n\n    DELETE FROM mission\n    WHERE \"Speed_knots\" < 10\n    AND \"Launched_Year\" < p_year_threshold;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "CALL analyze_ship_mission_stats('United Kingdom', 3000, 1920, 'Decommissioned');",
      "CALL analyze_ship_mission_stats('United States', 3500, 1935, 'Lost');",
      "CALL analyze_ship_mission_stats('Germany', 2000, 1910, 'burned');",
      "CALL analyze_ship_mission_stats('United Kingdom', 4000, 1940, '1950');",
      "CALL analyze_ship_mission_stats('United States', 2500, 1900, '1931');"
    ],
    "summary": "Create a stored procedure named \"analyze_ship_mission_stats\" that takes nationality, minimum tonnage, year threshold, and fate pattern as input. Count ships matching the nationality and tonnage filter. Calculate the average mission speed for missions launched after the year threshold for ships of that nationality. Count missions where the fate contains the pattern. Insert a new statistical record into the ship table with a name, the input nationality, and tonnage based on the ship count. Delete missions with speed less than 10 and launched before the year threshold.",
    "natural_language": "Develop a comprehensive stored procedure, to be designated as \"analyze_ship_mission_stats\", which must accept four distinct input parameters: a specified nationality, a defined minimum tonnage, a particular year threshold, and a specific fate pattern. This procedure should meticulously count all ships that correspond precisely to the provided nationality and also meet or exceed the stipulated minimum tonnage. Subsequently, it must compute the precise average mission speed exclusively for those missions which were launched after the given year threshold and involve ships belonging to the indicated nationality. Furthermore, it is required to tally all missions where the recorded fate description incorporates the provided pattern. Following these calculations, the procedure must insert a fresh statistical entry into the ship table; this new record should include a generated name, the originally input nationality, and a tonnage value that is directly derived from the total count of ships identified earlier. Finally, the procedure must conclusively delete any and all mission records where the calculated speed is determined to be less than 10 and where the launch date regrettably occurred before the established year threshold.",
    "id": 96,
    "generated_ir": "Write a PL/pgSQL stored procedure named `analyze_ship_mission_stats` that accepts four input parameters: `p_nationality_filter` of type `text`, `p_min_tonnage` of type `integer`, `p_year_threshold` of type `integer`, and `p_fate_pattern` of type `text`. The procedure begins by declaring three local variables: `v_ship_count` of type `integer`, `v_avg_speed` of type `numeric`, and `v_mission_count` of type `integer`. The procedure then executes a `SELECT` statement to count the number of records in the `ship` table. This count is stored in the `v_ship_count` variable. The `ship` records are filtered based on two conditions: the value in the `\"Nationality\"` column must exactly match the `p_nationality_filter` parameter, and the value in the `\"Tonnage\"` column must be strictly greater than the `p_min_tonnage` parameter. Next, the procedure executes another `SELECT` statement to calculate the average of the `\"Speed_knots\"` column from the `mission` table. This average is stored in the `v_avg_speed` variable. This `SELECT` statement involves a `JOIN` operation between the `mission` table (aliased as `m`) and the `ship` table (aliased as `s`) on the condition that `m.\"Ship_ID\"` equals `s.\"Ship_ID\"`. The joined records are filtered based on two conditions: the value in the `s.\"Nationality\"` column must exactly match the `p_nationality_filter` parameter, and the value in the `m.\"Launched_Year\"` column must be strictly greater than the `p_year_threshold` parameter. Subsequently, the procedure executes a third `SELECT` statement to count the number of records in the `mission` table. This count is stored in the `v_mission_count` variable. The `mission` records are filtered based on a single condition: the value in the `\"Fate\"` column must contain the `p_fate_pattern` parameter as a substring, with the `LIKE` operator used for pattern matching, where `p_fate_pattern` is concatenated with wildcard characters (`%`) on both sides. Following these selections, the procedure performs an `INSERT` operation into the `ship` table, populating the columns `\"Ship_ID\"`, `\"Name\"`, `\"Type\"`, `\"Nationality\"`, and `\"Tonnage\"`. The value for `\"Ship_ID\"` is determined by a subquery that selects the maximum existing `\"Ship_ID\"` from the `ship` table, uses `COALESCE` to default to `0` if no `MAX` value is found, and then adds `1` to the result. The `\"Name\"` column is set to the literal string 'Analysis_Record'. The `\"Type\"` column is set to the literal string 'Statistical'. The `\"Nationality\"` column is set to the value of the `p_nationality_filter` parameter. The `\"Tonnage\"` column is set to the product of the `v_ship_count` variable and `1000`. Finally, the procedure executes a `DELETE` statement to remove records from the `mission` table. The records to be deleted are filtered based on two conditions: the value in the `\"Speed_knots\"` column must be strictly less than `10`, and the value in the `\"Launched_Year\"` column must be strictly less than the `p_year_threshold` parameter."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `reconcile_dog_treatments` that accepts three input parameters: `p_start_date` of type `timestamp`, `p_end_date` of type `timestamp`, and `p_treatment_type` of type `text`. The purpose of this procedure is to iterate through a specific subset of dogs and, for each dog, perform conditional operations on their treatments based on the count and cost of treatments of a specified type.\n\nThe procedure begins by declaring three local variables: `v_dog_record` of type `RECORD` to hold dog-related data during iteration, `v_treatment_count` of type `integer` to store the number of treatments, and `v_total_cost` of type `numeric` to accumulate the total cost of treatments. Another local variable, `v_avg_cost` of type `numeric`, is declared to store the calculated average cost of treatments.\n\nThe core logic involves a `FOR` loop that iterates over a result set obtained by selecting `dog_id`, `name`, and `breed_code` from the `\"Dogs\"` table. The selection is filtered by a `WHERE` clause, ensuring that only dogs whose `date_arrived` falls inclusively between the `p_start_date` and `p_end_date` parameters are considered. For each `v_dog_record` retrieved in this loop, the procedure executes a `SELECT` statement. This `SELECT` statement counts the number of treatments and calculates the sum of `cost_of_treatment` from the `\"Treatments\"` table. The `COALESCE` function is used to ensure that if `SUM(cost_of_treatment)` returns `NULL` (meaning no treatments are found), `0` is used instead. These aggregated values are then assigned to `v_treatment_count` and `v_total_cost`, respectively. The `SELECT` statement is filtered by a `WHERE` clause that matches the `dog_id` with `v_dog_record.dog_id` and the `treatment_type_code` with the `p_treatment_type` parameter.\n\nFollowing this aggregation, a conditional `IF-ELSIF-ELSE` block determines the subsequent action:\n\n1.  **`IF v_treatment_count > 3 THEN`**: If the `v_treatment_count` for the current dog and specified treatment type is greater than 3, the procedure calculates `v_avg_cost`. This calculation uses a `CASE` statement: if `v_treatment_count` is greater than 0, `v_avg_cost` is computed as `v_total_cost` divided by `v_treatment_count`; otherwise, it is set to `0`. After calculating `v_avg_cost`, an `INSERT` statement is executed into the `\"Treatments\"` table. A new `treatment_id` is generated using `nextval('treatments_treatment_id_seq')`. The `dog_id` is set to `v_dog_record.dog_id`, `professional_id` is set to `100`, `treatment_type_code` is set to the literal string `'EXAM'`, `date_of_treatment` is set to `CURRENT_TIMESTAMP`, and `cost_of_treatment` is set to the calculated `v_avg_cost`.\n\n2.  **`ELSIF v_treatment_count = 0 THEN`**: If the `v_treatment_count` for the current dog and specified treatment type is exactly 0, the procedure performs two `DELETE` operations. First, it deletes all records from the `\"Treatments\"` table where the `dog_id` matches `v_dog_record.dog_id`. Second, it deletes records from the `\"Dogs\"` table where the `dog_id` matches `v_dog_record.dog_id` AND the `abandoned_yn` column has a value of `'1'`.\n\n3.  **`ELSE`**: If neither of the above conditions is met (meaning `v_treatment_count` is between 1 and 3, inclusive), an `UPDATE` statement is executed on the `\"Treatments\"` table. This `UPDATE` increases the `cost_of_treatment` by 10% (multiplying it by `1.1`). The `UPDATE` is applied to records where the `dog_id` matches `v_dog_record.dog_id`, the `treatment_type_code` matches `p_treatment_type`, AND the `date_of_treatment` is older than 30 days from the `CURRENT_TIMESTAMP` (specifically, `CURRENT_TIMESTAMP - INTERVAL '30 days'`).\n\nThe loop continues until all dogs matching the initial `date_arrived` criteria have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE reconcile_dog_treatments(p_start_date timestamp, p_end_date timestamp, p_treatment_type text)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_dog_record RECORD;\n    v_treatment_count integer;\n    v_total_cost numeric;\n    v_avg_cost numeric;\nBEGIN\n    FOR v_dog_record IN SELECT d.dog_id, d.name, d.breed_code FROM \"Dogs\" d WHERE d.date_arrived BETWEEN p_start_date AND p_end_date\n    LOOP\n        SELECT COUNT(*), COALESCE(SUM(cost_of_treatment), 0) INTO v_treatment_count, v_total_cost\n        FROM \"Treatments\"\n        WHERE dog_id = v_dog_record.dog_id\n        AND treatment_type_code = p_treatment_type;\n        \n        IF v_treatment_count > 3 THEN\n            v_avg_cost := CASE WHEN v_treatment_count > 0 THEN v_total_cost / v_treatment_count ELSE 0 END;\n            INSERT INTO \"Treatments\" (treatment_id, dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment)\n            VALUES (nextval('treatments_treatment_id_seq'), v_dog_record.dog_id, 100, 'EXAM', CURRENT_TIMESTAMP, v_avg_cost);\n        ELSIF v_treatment_count = 0 THEN\n            DELETE FROM \"Treatments\" WHERE dog_id = v_dog_record.dog_id;\n            DELETE FROM \"Dogs\" WHERE dog_id = v_dog_record.dog_id AND abandoned_yn = '1';\n        ELSE\n            UPDATE \"Treatments\" SET cost_of_treatment = cost_of_treatment * 1.1\n            WHERE dog_id = v_dog_record.dog_id\n            AND treatment_type_code = p_treatment_type\n            AND date_of_treatment < CURRENT_TIMESTAMP - INTERVAL '30 days';\n        END IF;\n    END LOOP;\nEND;\n$$;",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Owners",
      "Breeds",
      "Sizes",
      "Treatments"
    ],
    "call_sqls": [
      "CALL reconcile_dog_treatments('2017-01-01 00:00:00', '2017-12-31 23:59:59', 'EXAM');",
      "CALL reconcile_dog_treatments('2018-01-01 00:00:00', '2018-03-31 23:59:59', 'VAC');",
      "CALL reconcile_dog_treatments('2017-06-01 00:00:00', '2017-08-31 23:59:59', 'WALK');",
      "CALL reconcile_dog_treatments('2016-01-01 00:00:00', '2016-12-31 23:59:59', 'GROOM');",
      "CALL reconcile_dog_treatments('2017-09-01 00:00:00', '2017-11-30 23:59:59', 'MEDS');"
    ],
    "summary": "Create a stored procedure named `reconcile_dog_treatments` that takes a start date, end date, and treatment type. For each dog that arrived within the date range, count its treatments of that type and sum their cost. If the count is greater than 3, insert a new 'EXAM' treatment with a cost equal to the average cost. If the count is zero, delete all treatments for that dog and also delete the dog if it is marked as abandoned. Otherwise (count 1-3), increase the cost of matching treatments older than 30 days by 10%.",
    "natural_language": "Alright, so we need a stored procedure called `reconcile_dog_treatments`. It's gotta take a start date, an end date, and a treatment type. For every pooch that showed up between those dates, we'll tally up how many treatments of that type it got and add up what they cost. If the count's more than 3, we gotta slip in a new 'EXAM' treatment, and its cost should be the average of the others. If the count's a big fat zero, we need to wipe out all treatments for that dog, and if the dog's marked as abandoned, boot it from the records too. For the restyou know, if the count's between 1 and 3just bump up the cost by 10% for any matching treatments that are older than a month.",
    "id": 97,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `reconcile_dog_treatments` that accepts three input parameters: `p_start_date` of type `timestamp with time zone`, `p_end_date` of type `timestamp with time zone`, and `p_treatment_type` of type `text`. The procedure processes dogs that arrived at the kennel within the specified date range and performs operations based on the count of treatments of the given type each dog received.\n\nFirst, the procedure declares several variables: `v_dog_id` of type `bigint` to store the current dog's identifier, `v_treatment_count` of type `integer` to hold the number of treatments of the specified type for the current dog, `v_total_cost` of type `numeric` to accumulate the total cost of those treatments, `v_avg_cost` of type `numeric` to compute the average cost when needed, `v_abandoned_status` of type `text` to check if the dog is abandoned, and `v_new_treatment_id` of type `bigint` to generate a new identifier for inserting treatments.\n\nThe procedure operates by iterating through each dog in the `Dogs` table where the `date_arrived` column falls between `p_start_date` and `p_end_date` (inclusive). For each such dog, it performs the following steps:\n\n1. Retrieve the dog's `dog_id` and `abandoned_yn` status from the `Dogs` table.\n2. Calculate the treatment count and total cost by querying the `Treatments` table. Specifically, it counts the number of rows where `dog_id` matches the current dog's ID and `treatment_type_code` equals `p_treatment_type`, storing the result in `v_treatment_count`. Simultaneously, it sums the `cost_of_treatment` for those rows, storing the result in `v_total_cost`. If no treatments are found, `v_treatment_count` is set to 0 and `v_total_cost` to 0.\n\nBased on the value of `v_treatment_count`, the procedure executes conditional logic:\n\n- If `v_treatment_count` is greater than 3:\n   - Compute the average cost `v_avg_cost` by dividing `v_total_cost` by `v_treatment_count`.\n   - Determine the next available `treatment_id` by selecting the maximum `treatment_id` from the `Treatments` table, defaulting to 0 if the table is empty, and incrementing it by 1, storing it in `v_new_treatment_id`.\n   - Insert a new row into the `Treatments` table with `treatment_id` set to `v_new_treatment_id`, `dog_id` set to the current dog's ID, `treatment_type_code` set to 'EXAM', `date_of_treatment` set to the current date and time (using `CURRENT_TIMESTAMP`), and `cost_of_treatment` set to `v_avg_cost`. The `professional_id` column is left as null.\n\n- If `v_treatment_count` is 0:\n   - Delete all rows from the `Treatments` table where `dog_id` matches the current dog's ID.\n   - Check if `v_abandoned_status` (from the `Dogs` table) is '1' (indicating abandoned). If true, delete the dog's record from the `Dogs` table where `dog_id` matches the current dog's ID.\n\n- If `v_treatment_count` is between 1 and 3 (inclusive):\n   - Update the `Treatments` table for the current dog. Increase the `cost_of_treatment` by 10% (multiplying by 1.10) for all rows where `dog_id` matches the current dog's ID, `treatment_type_code` equals `p_treatment_type`, and `date_of_treatment` is older than one month from the current date (specifically, where `date_of_treatment` is less than `CURRENT_TIMESTAMP - INTERVAL '1 month'`).\n\nThe procedure uses explicit cursor iteration to process each dog sequentially. After processing all dogs that arrived within the date range, the procedure completes without returning a value (it is a void procedure). The operations involve data manipulation (INSERT, UPDATE, DELETE) across the `Dogs` and `Treatments` tables, with joins implicitly handled via foreign key relationships (e.g., `Treatments.dog_id` references `Dogs.dog_id`)."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL stored procedure named `remove_student_city_data` that accepts two input parameters: `p_city_code` of type `text` and `p_min_age` of type `bigint`. The purpose of this procedure is to remove specific data related to students and direct distances based on the provided city code and minimum age. The procedure first performs a `DELETE` operation on the table named `\"Student\"`. This deletion targets rows where the value in the `city_code` column exactly matches the value provided in the `p_city_code` parameter AND the value in the `\"Age\"` column is strictly less than the value provided in the `p_min_age` parameter. Following this, the procedure performs a second `DELETE` operation on the table named `\"Direct_distance\"`. This deletion targets rows where the value in the `city1_code` column exactly matches the value provided in the `p_city_code` parameter OR the value in the `city2_code` column exactly matches the value provided in the `p_city_code` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE remove_student_city_data(p_city_code text, p_min_age bigint)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DELETE FROM \"Student\" \n    WHERE city_code = p_city_code AND \"Age\" < p_min_age;\n    \n    DELETE FROM \"Direct_distance\" \n    WHERE city1_code = p_city_code OR city2_code = p_city_code;\nEND;\n$$;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "CALL remove_student_city_data('BAL', 20);",
      "CALL remove_student_city_data('PIT', 18);",
      "CALL remove_student_city_data('PHL', 19);",
      "CALL remove_student_city_data('BAL', 21);",
      "CALL remove_student_city_data('PIT', 22);"
    ],
    "summary": "Create a stored procedure named remove_student_city_data that accepts a city code and a minimum age. First, delete from the Student table where the city_code matches and the age is less than the minimum. Then, delete from the Direct_distance table where the provided city code matches either the city1_code or city2_code column.",
    "natural_language": "What stored procedure can be created to remove student and distance data based on a city code and a minimum age? The procedure should first delete students from the Student table who are from the specified city and are younger than the given minimum age, and then it should delete any records from the Direct_distance table where the provided city code is either the starting or ending city.",
    "id": 98,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `remove_student_city_data` that accepts two input parameters: `p_city_code` of type `text` and `p_min_age` of type `bigint`. The purpose of this procedure is to remove specific data related to students and direct distances based on the provided city code and minimum age. The procedure first performs a `DELETE` operation on the table named `\"Student\"`. This deletion targets rows where the value in the `city_code` column exactly matches the value provided in the `p_city_code` parameter AND the value in the `\"Age\"` column is strictly less than the value provided in the `p_min_age` parameter. Following this, the procedure performs a second `DELETE` operation on the table named `\"Direct_distance\"`. This deletion targets rows where the value in the `city1_code` column exactly matches the value provided in the `p_city_code` parameter OR the value in the `city2_code` column exactly matches the value provided in the `p_city_code` parameter."
  },
  {
    "ir": "Write a PLpgSQL stored procedure that takes two integer parameters, p_start_year and p_end_year, and iterates over records in the wedding table where the Year column is between these two parameters, inclusive. For each record, it selects the Church_ID, Male_ID, Female_ID, and Year from the wedding table and the Name from the church table by joining on Church_ID. It then deletes from the wedding table any row that matches the Church_ID, Male_ID, and Female_ID of the current record in the loop.",
    "plsql": "CREATE OR REPLACE PROCEDURE find_weddings_in_year_range(p_start_year INTEGER, p_end_year INTEGER)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_wedding_record RECORD;\nBEGIN\n    FOR v_wedding_record IN \n        SELECT w.\"Church_ID\", w.\"Male_ID\", w.\"Female_ID\", w.\"Year\",\n               c.\"Name\" as church_name\n        FROM \"wedding\" w\n        JOIN \"church\" c ON w.\"Church_ID\" = c.\"Church_ID\"\n        WHERE w.\"Year\" BETWEEN p_start_year AND p_end_year\n    LOOP\n        DELETE FROM \"wedding\" \n        WHERE \"Church_ID\" = v_wedding_record.\"Church_ID\" \n        AND \"Male_ID\" = v_wedding_record.\"Male_ID\"\n        AND \"Female_ID\" = v_wedding_record.\"Female_ID\";\n    END LOOP;\nEND;\n$$;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "CALL find_weddings_in_year_range(2010, 2015);",
      "CALL find_weddings_in_year_range(2000, 2005);",
      "CALL find_weddings_in_year_range(2015, 2020);",
      "CALL find_weddings_in_year_range(1990, 1995);",
      "CALL find_weddings_in_year_range(2020, 2023);"
    ],
    "summary": "Create a stored procedure that accepts a start year and end year (INTEGER). For each wedding record where the Year is between the provided years, get the Church_ID, Male_ID, Female_ID, Year, and the church Name via a join. Delete the current wedding record from the wedding table based on its Church_ID, Male_ID, and Female_ID.",
    "natural_language": "Please construct a stored procedure that receives two integer parameters, designated as the start year and the end year. For each entry in the wedding records where the Year falls within the specified inclusive range, retrieve the Church_ID, Male_ID, Female_ID, Year, and the corresponding church Name by performing a join with the relevant table. Subsequently, delete the identified wedding record from the wedding table, using its composite key of Church_ID, Male_ID, and Female_ID as the deletion criteria.",
    "id": 99,
    "generated_ir": "Write a PostgreSQL PL/pgSQL stored procedure named `find_weddings_in_year_range` that accepts two input parameters: `p_start_year` of type `integer` representing the inclusive lower bound of the year range, and `p_end_year` of type `integer` representing the inclusive upper bound of the year range. The procedure begins by declaring a local variable named `v_church_id` of type `integer` to temporarily store the church identifier from each wedding record, a local variable named `v_male_id` of type `integer` to temporarily store the male person identifier, a local variable named `v_female_id` of type `integer` to temporarily store the female person identifier, a local variable named `v_year` of type `integer` to temporarily store the wedding year, and a local variable named `v_church_name` of type `text` to temporarily store the name of the church. It then declares a cursor named `wedding_cursor` that is designed to select data from the `wedding` table joined with the `church` table. Specifically, the cursor's query selects the `wedding.Church_ID` column, the `wedding.Male_ID` column, the `wedding.Female_ID` column, the `wedding.Year` column, and the `church.Name` column from the `wedding` table. It performs an inner join with the `church` table on the condition that the `wedding.Church_ID` column equals the `church.Church_ID` column. The query includes a `WHERE` clause that filters the results to only include rows where the `wedding.Year` column is greater than or equal to the input parameter `p_start_year` and less than or equal to the input parameter `p_end_year`. The procedure proceeds to open the `wedding_cursor`, initiating the retrieval of data. It then enters a loop, where in each iteration, it fetches the next row from `wedding_cursor` into the `v_church_id`, `v_male_id`, `v_female_id`, `v_year`, and `v_church_name` variables. The loop continues until no more rows are found in the cursor, at which point it exits. Inside the loop, after fetching a row, the procedure performs a `DELETE` operation on the `wedding` table. This `DELETE` statement removes the row where the composite key columns `Church_ID`, `Male_ID`, and `Female_ID` exactly match the values currently stored in the `v_church_id`, `v_male_id`, and `v_female_id` variables, respectively. After the loop completes, the `wedding_cursor` is closed, releasing its resources. The procedure does not return a value; it is a void procedure that performs the described operations."
  },
  {
    "ir": "Write a PLpgSQL stored procedure named analyze_movie_ratings that accepts a single integer parameter p_year_threshold, which serves as a threshold year for categorizing movies into old and new. The procedure begins by declaring several integer and numeric variables: v_old_movie_count, v_new_movie_count, v_high_rating_count, v_low_rating_count, v_avg_rating, and v_total_reviewers. It then performs a series of SELECT operations to populate these variables. First, it counts the number of distinct movies released before the threshold year and stores this count in v_old_movie_count. Next, it counts the number of distinct movies released in or after the threshold year and stores this count in v_new_movie_count. It then counts the number of ratings with 4 or more stars and stores this count in v_high_rating_count, followed by counting ratings with 2 or fewer stars and storing this count in v_low_rating_count. The procedure calculates the average star rating across all ratings and stores this value in v_avg_rating. Finally, it counts the number of distinct reviewers and stores this count in v_total_reviewers. The procedure then evaluates several conditional statements based on the values of these variables. If the count of old movies exceeds the count of new movies and the average rating is greater than 3, it deletes ratings with fewer than 3 stars for movies released before the threshold year. If the count of new movies exceeds the count of old movies and the average rating is 3 or less, it deletes ratings with more than 3 stars for movies released in or after the threshold year. If the count of high ratings exceeds the count of low ratings and there are reviewers available, it inserts new ratings with 3 stars for up to 5 combinations of reviewers and movies where the reviewer has not yet rated the movie. If the count of low ratings exceeds the count of high ratings and there are reviewers available, it inserts new ratings with 4 stars for up to 3 combinations of reviewers and movies where the reviewer has not yet rated the movie. If the average rating is null, indicating no ratings exist, it inserts a default rating of 3 stars for a specific reviewer and movie. Otherwise, it inserts a new rating with 2 stars for one combination of reviewer and movie where the reviewer has not yet rated the movie.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_movie_ratings(p_year_threshold integer)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_old_movie_count integer;\n    v_new_movie_count integer;\n    v_high_rating_count integer;\n    v_low_rating_count integer;\n    v_avg_rating numeric;\n    v_total_reviewers integer;\nBEGIN\n    SELECT COUNT(DISTINCT m.\"mID\") INTO v_old_movie_count FROM \"Movie\" m WHERE m.\"year\" < p_year_threshold;\n    SELECT COUNT(DISTINCT m.\"mID\") INTO v_new_movie_count FROM \"Movie\" m WHERE m.\"year\" >= p_year_threshold;\n    SELECT COUNT(*) INTO v_high_rating_count FROM \"Rating\" rt WHERE rt.\"stars\" >= 4;\n    SELECT COUNT(*) INTO v_low_rating_count FROM \"Rating\" rt WHERE rt.\"stars\" <= 2;\n    SELECT AVG(rt.\"stars\") INTO v_avg_rating FROM \"Rating\" rt;\n    SELECT COUNT(DISTINCT r.\"rID\") INTO v_total_reviewers FROM \"Reviewer\" r;\n    \n    IF v_old_movie_count > v_new_movie_count AND v_avg_rating > 3 THEN\n        DELETE FROM \"Rating\" rt WHERE rt.\"mID\" IN (SELECT m.\"mID\" FROM \"Movie\" m WHERE m.\"year\" < p_year_threshold) AND rt.\"stars\" < 3;\n    ELSIF v_new_movie_count > v_old_movie_count AND v_avg_rating <= 3 THEN\n        DELETE FROM \"Rating\" rt WHERE rt.\"mID\" IN (SELECT m.\"mID\" FROM \"Movie\" m WHERE m.\"year\" >= p_year_threshold) AND rt.\"stars\" > 3;\n    ELSIF v_high_rating_count > v_low_rating_count AND v_total_reviewers > 0 THEN\n        INSERT INTO \"Rating\" (\"rID\", \"mID\", \"stars\", \"ratingDate\") SELECT r.\"rID\", m.\"mID\", 3, CURRENT_DATE FROM \"Reviewer\" r CROSS JOIN \"Movie\" m WHERE r.\"rID\" NOT IN (SELECT \"rID\" FROM \"Rating\" WHERE \"mID\" = m.\"mID\") LIMIT 5;\n    ELSIF v_low_rating_count > v_high_rating_count AND v_total_reviewers > 0 THEN\n        INSERT INTO \"Rating\" (\"rID\", \"mID\", \"stars\", \"ratingDate\") SELECT r.\"rID\", m.\"mID\", 4, CURRENT_DATE FROM \"Reviewer\" r CROSS JOIN \"Movie\" m WHERE r.\"rID\" NOT IN (SELECT \"rID\" FROM \"Rating\" WHERE \"mID\" = m.\"mID\") LIMIT 3;\n    ELSIF v_avg_rating IS NULL THEN\n        INSERT INTO \"Rating\" (\"rID\", \"mID\", \"stars\", \"ratingDate\") VALUES (1, 1, 3, CURRENT_DATE);\n    ELSE\n        INSERT INTO \"Rating\" (\"rID\", \"mID\", \"stars\", \"ratingDate\") SELECT r.\"rID\", m.\"mID\", 2, CURRENT_DATE FROM \"Reviewer\" r CROSS JOIN \"Movie\" m WHERE r.\"rID\" NOT IN (SELECT \"rID\" FROM \"Rating\" WHERE \"mID\" = m.\"mID\") LIMIT 1;\n    END IF;\nEND;\n$$;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "CALL analyze_movie_ratings(1950);",
      "CALL analyze_movie_ratings(1960);",
      "CALL analyze_movie_ratings(1970);",
      "CALL analyze_movie_ratings(1980);",
      "CALL analyze_movie_ratings(1990);"
    ],
    "summary": "Create a stored procedure named analyze_movie_ratings that takes a year threshold. Count old and new movies, high and low ratings, calculate the average rating, and count total reviewers. Based on these counts and averages: delete low-rated old movies if old movies outnumber new ones and average rating > 3; delete high-rated new movies if new movies outnumber old ones and average rating <= 3; insert up to 5 new 3-star ratings if high ratings outnumber low ratings and reviewers exist; insert up to 3 new 4-star ratings if low ratings outnumber high ratings and reviewers exist; insert a default 3-star rating if no ratings exist; otherwise, insert one new 2-star rating.",
    "natural_language": "What stored procedure can be created to analyze movie ratings based on a given year threshold? The procedure should count old and new movies, high and low ratings, calculate the average rating, and count total reviewers. Based on these results, what actions should it take: deleting low-rated old movies if old movies outnumber new ones and the average rating is above 3; deleting high-rated new movies if new movies outnumber old ones and the average rating is 3 or less; inserting up to 5 new 3-star ratings if high ratings outnumber low ratings and reviewers exist; inserting up to 3 new 4-star ratings if low ratings outnumber high ratings and reviewers exist; inserting a default 3-star rating if no ratings exist; or otherwise inserting one new 2-star rating?",
    "id": 100,
    "generated_ir": "Write a PLpgSQL stored procedure named analyze_movie_ratings that accepts a single integer parameter p_year_threshold, which serves as a threshold year for categorizing movies into old and new. The procedure begins by declaring several integer and numeric variables: v_old_movie_count, v_new_movie_count, v_high_rating_count, v_low_rating_count, v_avg_rating, and v_total_reviewers. It then performs a series of SELECT operations to populate these variables. First, it counts the number of distinct movies released before the threshold year and stores this count in v_old_movie_count. Next, it counts the number of distinct movies released in or after the threshold year and stores this count in v_new_movie_count. It then counts the number of ratings with 4 or more stars and stores this count in v_high_rating_count, followed by counting ratings with 2 or fewer stars and storing this count in v_low_rating_count. The procedure calculates the average star rating across all ratings and stores this value in v_avg_rating. Finally, it counts the number of distinct reviewers and stores this count in v_total_reviewers. The procedure then evaluates several conditional statements based on the values of these variables. If the count of old movies exceeds the count of new movies and the average rating is greater than 3, it deletes ratings with fewer than 3 stars for movies released before the threshold year. If the count of new movies exceeds the count of old movies and the average rating is 3 or less, it deletes ratings with more than 3 stars for movies released in or after the threshold year. If the count of high ratings exceeds the count of low ratings and there are reviewers available, it inserts new ratings with 3 stars for up to 5 combinations of reviewers and movies where the reviewer has not yet rated the movie. If the count of low ratings exceeds the count of high ratings and there are reviewers available, it inserts new ratings with 4 stars for up to 3 combinations of reviewers and movies where the reviewer has not yet rated the movie. If the average rating is null, indicating no ratings exist, it inserts a default rating of 3 stars for a specific reviewer and movie. Otherwise, it inserts a new rating with 2 stars for one combination of reviewer and movie where the reviewer has not yet rated the movie."
  }
]