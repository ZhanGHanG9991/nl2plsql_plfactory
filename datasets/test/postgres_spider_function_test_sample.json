[
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_staff_conference_roles` that accepts a single input parameter, `p_staff_id`, which is of type `integer`. This function is designed to return an array of text (`text[]`). Inside the function, a local variable named `roles` of type `text[]` is declared to store the results. The function's logic proceeds through a series of conditional checks.\n\nFirst, it checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id` AND whose `Age` is strictly greater than 30. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" > 30`. If this condition is true, the function then selects all `role` values from the `conference_participation` table where the `staff_ID` matches the input `p_staff_id`. These selected `role` values are collected into an array using `ARRAY(SELECT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id)` and assigned to the `roles` variable.\n\nIf the first condition is false, the function proceeds to an `ELSIF` block. This block checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id` AND whose `Age` is less than or equal to 30. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" <= 30`. If this second condition is true, the function then selects distinct `role` values from the `conference_participation` table where the `staff_ID` matches the input `p_staff_id`. These distinct `role` values are collected into an array using `ARRAY(SELECT DISTINCT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id)` and assigned to the `roles` variable.\n\nIf both the first and second conditions are false, the function proceeds to another `ELSIF` block. This block checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id`. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id`. If this third condition is true (meaning the staff member exists but did not meet the age criteria for the previous two branches), the `roles` variable is assigned a single-element array containing the text literal 'No participation' using `ARRAY['No participation']`.\n\nFinally, if none of the preceding conditions are met (meaning no staff member with the given `p_staff_id` was found in the `staff` table), the function executes the `ELSE` block. In this case, the `roles` variable is assigned a single-element array containing the text literal 'Staff not found' using `ARRAY['Staff not found']`.\n\nAfter evaluating all conditional statements and assigning a value to the `roles` variable, the function returns the final `roles` array.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_conference_roles(p_staff_id integer)\nRETURNS text[] AS $$\nDECLARE\n    roles text[];\nBEGIN\n    IF EXISTS (SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" > 30) THEN\n        SELECT ARRAY(SELECT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id) INTO roles;\n    ELSIF EXISTS (SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" <= 30) THEN\n        SELECT ARRAY(SELECT DISTINCT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id) INTO roles;\n    ELSIF EXISTS (SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id) THEN\n        roles := ARRAY['No participation'];\n    ELSE\n        roles := ARRAY['Staff not found'];\n    END IF;\n    RETURN roles;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "staff"
    ],
    "call_sqls": [
      "SELECT get_staff_conference_roles(1);",
      "SELECT get_staff_conference_roles(2);",
      "SELECT get_staff_conference_roles(3);",
      "SELECT get_staff_conference_roles(4);",
      "SELECT get_staff_conference_roles(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_staff_conference_roles` that accepts a staff_id parameter and returns a text array. Return all roles if staff age > 30, distinct roles if age â‰¤ 30, ['No participation'] if staff exists without age criteria, or ['Staff not found'] if staff doesn't exist.",
    "natural_language": "Write a PL/pgSQL function called `get_staff_conference_roles` that takes a staff_id. It should give back a list of text. For staff members who are a bit older, return all their roles. For the younger ones, just the different roles. If the person is on staff but we don't have their age info, say they haven't participated. And if we can't find the staff member at all, indicate they're not found.",
    "id": 1,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_staff_conference_roles` that accepts a single input parameter, `p_staff_id`, which is of type `integer`. This function is designed to return an array of text (`text[]`). Inside the function, a local variable named `roles` of type `text[]` is declared to store the results. The function's logic proceeds through a series of conditional checks.\n\nFirst, it checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id` AND whose `Age` is strictly greater than 30. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" > 30`. If this condition is true, the function then selects all `role` values from the `conference_participation` table where the `staff_ID` matches the input `p_staff_id`. These selected `role` values are collected into an array using `ARRAY(SELECT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id)` and assigned to the `roles` variable.\n\nIf the first condition is false, the function proceeds to an `ELSIF` block. This block checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id` AND whose `Age` is less than or equal to 30. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id AND \"Age\" <= 30`. If this second condition is true, the function then selects distinct `role` values from the `conference_participation` table where the `staff_ID` matches the input `p_staff_id`. These distinct `role` values are collected into an array using `ARRAY(SELECT DISTINCT role FROM conference_participation WHERE \"staff_ID\" = p_staff_id)` and assigned to the `roles` variable.\n\nIf both the first and second conditions are false, the function proceeds to another `ELSIF` block. This block checks if a staff member exists in the `staff` table with a `staff_ID` matching the input `p_staff_id`. This check is performed using an `EXISTS` subquery: `SELECT 1 FROM staff WHERE \"staff_ID\" = p_staff_id`. If this third condition is true (meaning the staff member exists but did not meet the age criteria for the previous two branches), the `roles` variable is assigned a single-element array containing the text literal 'No participation' using `ARRAY['No participation']`.\n\nFinally, if none of the preceding conditions are met (meaning no staff member with the given `p_staff_id` was found in the `staff` table), the function executes the `ELSE` block. In this case, the `roles` variable is assigned a single-element array containing the text literal 'Staff not found' using `ARRAY['Staff not found']`.\n\nAfter evaluating all conditional statements and assigning a value to the `roles` variable, the function returns the final `roles` array."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_stock_per_shop that accepts a single integer input parameter named p_device_id, which is used to identify a specific device, and returns a numeric value; within the function, a local numeric variable v_avg is declared, then a SELECT query is executed against the table named \"stock\" to compute the average value of the column named \"Quantity\" for all rows where the column named \"Device_ID\" is exactly equal to the provided p_device_id parameter, and this computed average is stored into the v_avg variable; the function concludes by returning the value of v_avg, but if the SELECT query found no matching rows resulting in v_avg being NULL, the COALESCE function is used to substitute that NULL with the numeric value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_stock_per_shop(p_device_id integer) RETURNS numeric AS $$\nDECLARE\n    v_avg numeric;\nBEGIN\n    SELECT AVG(\"Quantity\") INTO v_avg FROM \"stock\" WHERE \"Device_ID\" = p_device_id;\n    RETURN COALESCE(v_avg, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT calculate_average_stock_per_shop(1);",
      "SELECT calculate_average_stock_per_shop(2);",
      "SELECT calculate_average_stock_per_shop(3);",
      "SELECT calculate_average_stock_per_shop(6);",
      "SELECT calculate_average_stock_per_shop(10);"
    ],
    "summary": "Create a function named calculate_average_stock_per_shop that takes a device ID as input and returns the average quantity of that device per shop from the stock table. Return 0 if no average can be calculated.",
    "natural_language": "Develop a function called calculate_average_stock_per_shop which, when provided with a specific device identifier as its input parameter, meticulously computes and delivers the mean quantity of that particular device held in inventory across each individual retail outlet, as recorded in the stock table; if for any reason an average value cannot be determined, the function should gracefully return a default result of zero.",
    "id": 2,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_stock_per_shop that accepts a single integer input parameter named p_device_id, which is used to identify a specific device, and returns a numeric value; within the function, a local numeric variable v_avg is declared, then a SELECT query is executed against the table named \"stock\" to compute the average value of the column named \"Quantity\" for all rows where the column named \"Device_ID\" is exactly equal to the provided p_device_id parameter, and this computed average is stored into the v_avg variable; the function concludes by returning the value of v_avg, but if the SELECT query found no matching rows resulting in v_avg being NULL, the COALESCE function is used to substitute that NULL with the numeric value 0."
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, p_catalog_id of type bigint and p_attribute_id of type bigint, and returns an integer representing the count of distinct catalog entries. The function begins by declaring a local variable v_count of type integer to store the result of the count operation. It then performs a SELECT query to count the number of distinct catalog_entry_id values from the \"Catalog_Contents\" table, which is aliased as cc. This table is joined with the \"Catalog_Structure\" table, aliased as cs, using the catalog_level_number column from both tables to establish the relationship. Additionally, the \"Catalog_Contents_Additional_Attributes\" table, aliased as ccaa, is joined using the catalog_entry_id column from both the \"Catalog_Contents\" and \"Catalog_Contents_Additional_Attributes\" tables. The WHERE clause of the query filters the results to include only those rows where the catalog_id in the \"Catalog_Structure\" table matches the p_catalog_id parameter and the attribute_id in the \"Catalog_Contents_Additional_Attributes\" table matches the p_attribute_id parameter. The result of the COUNT operation is stored in the v_count variable, which is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION count_entries_by_attribute(p_catalog_id bigint, p_attribute_id bigint)\nRETURNS integer AS $$\nDECLARE\n    v_count integer;\nBEGIN\n    SELECT COUNT(DISTINCT cc.catalog_entry_id) INTO v_count FROM \"Catalog_Contents\" cc JOIN \"Catalog_Structure\" cs ON cc.catalog_level_number = cs.catalog_level_number JOIN \"Catalog_Contents_Additional_Attributes\" ccaa ON cc.catalog_entry_id = ccaa.catalog_entry_id WHERE cs.catalog_id = p_catalog_id AND ccaa.attribute_id = p_attribute_id;\n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "SELECT count_entries_by_attribute(1, 1);",
      "SELECT count_entries_by_attribute(2, 2);",
      "SELECT count_entries_by_attribute(3, 3);",
      "SELECT count_entries_by_attribute(1, 2);",
      "SELECT count_entries_by_attribute(2, 3);"
    ],
    "summary": "Create a PL/pgSQL function that takes a catalog_id and an attribute_id (both bigint) and returns an integer count of distinct catalog_entry_id values. The count is derived from joining Catalog_Contents, Catalog_Structure (on catalog_level_number), and Catalog_Contents_Additional_Attributes (on catalog_entry_id), filtered by the provided catalog_id and attribute_id.",
    "natural_language": "How many distinct catalog entries are there for a given catalog and attribute, based on a join of the Catalog_Contents, Catalog_Structure, and Catalog_Contents_Additional_Attributes tables?",
    "id": 3,
    "generated_ir": "Write a PLpgSQL function that takes two parameters, p_catalog_id of type bigint and p_attribute_id of type bigint, and returns an integer representing the count of distinct catalog entries. The function begins by declaring a local variable v_count of type integer to store the result of the count operation. It then performs a SELECT query to count the number of distinct catalog_entry_id values from the \"Catalog_Contents\" table, which is aliased as cc. This table is joined with the \"Catalog_Structure\" table, aliased as cs, using the catalog_level_number column from both tables to establish the relationship. Additionally, the \"Catalog_Contents_Additional_Attributes\" table, aliased as ccaa, is joined using the catalog_entry_id column from both the \"Catalog_Contents\" and \"Catalog_Contents_Additional_Attributes\" tables. The WHERE clause of the query filters the results to include only those rows where the catalog_id in the \"Catalog_Structure\" table matches the p_catalog_id parameter and the attribute_id in the \"Catalog_Contents_Additional_Attributes\" table matches the p_attribute_id parameter. The result of the COUNT operation is stored in the v_count variable, which is then returned as the output of the function."
  },
  {
    "ir": "Write a PLpgSQL function that calculates the experience of an actor by taking two input parameters: actor_id of type integer, which identifies the actor, and base_year of type integer, which represents the reference year for the calculation. The function outputs two values: experience_years of type integer, which is the difference between the base_year and the actor's birth_year, and experience_score of type numeric, which is computed as the exponential of the experience_years divided by 10.0. The function performs a SELECT operation on the actor table, retrieving the birth_year of the actor whose aid matches the provided actor_id. The difference between base_year and birth_year is calculated to determine experience_years, and the experience_score is calculated using the exponential function exp() applied to the quotient of experience_years and 10.0. The results are stored in the output parameters experience_years and experience_score.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_actor_experience(IN actor_id integer, IN base_year integer, OUT experience_years integer, OUT experience_score numeric) LANGUAGE plpgsql AS $$\nBEGIN\n    SELECT \n        base_year - \"birth_year\",\n        exp((base_year - \"birth_year\") / 10.0)\n    INTO experience_years, experience_score\n    FROM \"actor\"\n    WHERE \"aid\" = actor_id;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "actor",
      "cast",
      "director",
      "directed_by",
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "SELECT calculate_actor_experience(1, 2023);",
      "SELECT calculate_actor_experience(2, 2020);",
      "SELECT calculate_actor_experience(3, 2024);",
      "SELECT calculate_actor_experience(4, 2019);",
      "SELECT calculate_actor_experience(5, 2022);"
    ],
    "summary": "Create a function that takes an actor_id integer and a base_year integer. It returns the actor's experience_years (base_year minus birth_year) and experience_score (exp(experience_years/10.0)) by looking up the actor in the actor table.",
    "natural_language": "For actor_id and base_year, return experience_years (base_year - birth_year) and experience_score (exp(experience_years/10.0)).",
    "id": 4,
    "generated_ir": "Write a PLpgSQL function that calculates the experience of an actor by taking two input parameters: actor_id of type integer, which identifies the actor, and base_year of type integer, which represents the reference year for the calculation. The function outputs two values: experience_years of type integer, which is the difference between the base_year and the actor's birth_year, and experience_score of type numeric, which is computed as the exponential of the experience_years divided by 10.0. The function performs a SELECT operation on the actor table, retrieving the birth_year of the actor whose aid matches the provided actor_id. The difference between base_year and birth_year is calculated to determine experience_years, and the experience_score is calculated using the exponential function exp() applied to the quotient of experience_years and 10.0. The results are stored in the output parameters experience_years and experience_score."
  },
  {
    "ir": "Write a PLpgSQL function named get_player_position that accepts a single parameter, p_player_id, which is of integer type and represents the unique identifier of a player. The function is designed to return a text value that corresponds to the position of the player within a sports team or organization. The function begins by declaring a local variable, v_position, of text type, which will be used to store the position retrieved from the database. The core operation of the function involves executing a SELECT statement that targets the player table, specifically aiming to extract the value from the \"Position\" column. This extraction is conditional upon the \"Player_ID\" column matching the value provided in the p_player_id parameter. The result of this SELECT operation is stored into the v_position variable using the INTO clause, which is a mechanism in PLpgSQL for assigning the result of a query to a variable. After successfully retrieving the position, the function concludes by returning the value stored in v_position, thereby providing the caller with the position of the player identified by the given player ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_position(p_player_id integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_position text;\nBEGIN\n    SELECT \"Position\" INTO v_position\n    FROM player\n    WHERE \"Player_ID\" = p_player_id;\n\n    RETURN v_position;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT get_player_position(1);",
      "SELECT get_player_position(2);",
      "SELECT get_player_position(3);",
      "SELECT get_player_position(15);",
      "SELECT get_player_position(NULL);"
    ],
    "summary": "Create a PLpgSQL function named get_player_position that takes an integer parameter p_player_id and returns a text value. The function should retrieve the 'Position' column value from the player table where the 'Player_ID' column matches the input parameter.",
    "natural_language": "How can I create a PLpgSQL function called get_player_position that accepts a player ID as an integer parameter and returns the text value of that player's position from the player table?",
    "id": 5,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_player_position` that accepts a single input parameter, `p_player_id`, which is of type `integer`. This function is designed to return a value of type `text`. Internally, the function declares a local variable named `v_position` of type `text` to temporarily store the retrieved player position. The function's execution flow begins with a `SELECT` statement. This `SELECT` statement retrieves the value from the `Position` column of the `player` table. The retrieval is filtered by a `WHERE` clause, which specifies that only the row where the `Player_ID` column matches the value of the input parameter `p_player_id` should be considered. The retrieved `Position` value is then assigned to the local variable `v_position`. Finally, the function returns the value stored in the `v_position` variable as its output."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter dept_id of type numeric, retrieves the city name associated with the department identified by the given dept_id, and returns this city name as a text value. The function begins by declaring a local variable location_name of type text to store the result of the query. It then performs a SELECT statement to fetch the value of the \"CITY\" column from the locations table, which is joined with the departments table using the condition that the \"LOCATION_ID\" column in the departments table matches the \"LOCATION_ID\" column in the locations table. The SELECT statement includes a WHERE clause that filters rows in the departments table to only those where the \"DEPARTMENT_ID\" column matches the input parameter dept_id. The result of this query is assigned to the location_name variable using the INTO clause. Finally, the function returns the value stored in location_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_location(dept_id numeric)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    location_name text;\nBEGIN\n    SELECT l.\"CITY\" INTO location_name\n    FROM departments d\n    JOIN locations l ON d.\"LOCATION_ID\" = l.\"LOCATION_ID\"\n    WHERE d.\"DEPARTMENT_ID\" = dept_id;\n    RETURN location_name;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_department_location(10);",
      "SELECT get_department_location(20);",
      "SELECT get_department_location(30);",
      "SELECT get_department_location(40);",
      "SELECT get_department_location(50);"
    ],
    "summary": "Create a PL/pgSQL function that takes a department ID and returns the associated city name as text. The function should retrieve the city from the locations table by joining with the departments table on location ID, where the department ID matches the input.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function that, when I give it a department's ID, spits back the city name where that department is? It's gotta look up the city in the locations table by linking it with the departments table using the location ID, but only for the department ID I'm asking about.",
    "id": 6,
    "generated_ir": "Write a PLpgSQL function that takes a single parameter dept_id of type numeric, retrieves the city name associated with the department identified by the given dept_id, and returns this city name as a text value. The function begins by declaring a local variable location_name of type text to store the result of the query. It then performs a SELECT statement to fetch the value of the \"CITY\" column from the locations table, which is joined with the departments table using the condition that the \"LOCATION_ID\" column in the departments table matches the \"LOCATION_ID\" column in the locations table. The SELECT statement includes a WHERE clause that filters rows in the departments table to only those where the \"DEPARTMENT_ID\" column matches the input parameter dept_id. The result of this query is assigned to the location_name variable using the INTO clause. Finally, the function returns the value stored in location_name."
  },
  {
    "ir": "Write a PLpgSQL function that calculates the average price of lessons for a specific customer by taking a parameter p_customer_id of type bigint, which represents the unique identifier of the customer. The function declares a variable v_average_price of type double precision to store the result of the average calculation. It performs a SELECT operation to compute the average of the \"price\" column from the \"Lessons\" table, filtering the rows where the \"customer_id\" column matches the provided p_customer_id. The result of this average calculation is stored into the v_average_price variable. The function then checks if v_average_price is NULL, which would indicate that there are no lessons associated with the given customer_id. If v_average_price is NULL, the function returns 0.0; otherwise, it returns the calculated average price stored in v_average_price.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_lesson_price(p_customer_id bigint)\nRETURNS double precision AS $$\nDECLARE\n    v_average_price double precision;\nBEGIN\n    SELECT AVG(\"price\") INTO v_average_price FROM \"Lessons\" WHERE \"customer_id\" = p_customer_id;\n    \n    IF v_average_price IS NULL THEN\n        RETURN 0.0;\n    ELSE\n        RETURN v_average_price;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Lessons",
      "Staff",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT calculate_average_lesson_price(1);",
      "SELECT calculate_average_lesson_price(2);",
      "SELECT calculate_average_lesson_price(3);",
      "SELECT calculate_average_lesson_price(6);",
      "SELECT calculate_average_lesson_price(8);"
    ],
    "summary": "Create a PL/pgSQL function that takes a customer_id (bigint) and returns the average price of their lessons. If no lessons are found, return 0.0.",
    "natural_language": "Please construct a PL/pgSQL function that accepts a customer identifier of type bigint as its parameter. The function shall compute and return the average price of all lessons associated with the provided customer. In the event that no lessons are found for the specified customer, the function must return the value 0.0.",
    "id": 7,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_lesson_price that accepts a single input parameter of type BIGINT, which represents the customer identifier used to filter the lessons. The function returns a value of type DOUBLE PRECISION, which is the computed average price.\n\nThe function begins by declaring a local variable named avg_price of type DOUBLE PRECISION to store the result of the calculation.\n\nThe core operation is a SELECT statement that queries the Lessons table. It uses the AVG aggregate function on the price column to calculate the average lesson price. A WHERE clause filters the rows to include only those where the customer_id column matches the value of the input parameter provided to the function. The result of this SELECT statement is assigned directly into the declared avg_price variable.\n\nFollowing this query, the function implements business logic to handle the case where no lessons are found for the specified customer. It uses an IF-THEN control flow statement to check if the avg_price variable is NULL. The AVG function returns NULL when no rows match the condition. If avg_price is NULL, the function sets the avg_price variable to the value 0.0.\n\nFinally, the function concludes by returning the value stored in the avg_price variable, which will be either the computed average price or 0.0."
  },
  {
    "ir": "Write a PLpgSQL function named get_church_open_date that accepts a single parameter p_church_id of type integer, which represents the unique identifier of a church. The function is designed to retrieve the open date of a church from the church table. It declares a local variable v_open_date of type integer to store the result of the query. The function performs a SELECT operation on the church table, specifically targeting the Open_Date column, and assigns the retrieved value to the v_open_date variable. The selection is based on the condition that the Church_ID column in the church table matches the value of the input parameter p_church_id. After successfully retrieving the open date, the function returns the value stored in v_open_date. The function is written in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_church_open_date(p_church_id integer)\nRETURNS integer AS $$\nDECLARE\n    v_open_date integer;\nBEGIN\n    SELECT c.\"Open_Date\" INTO v_open_date\n    FROM church c\n    WHERE c.\"Church_ID\" = p_church_id;\n    \n    RETURN v_open_date;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT get_church_open_date(1);",
      "SELECT get_church_open_date(2);",
      "SELECT get_church_open_date(3);",
      "SELECT get_church_open_date(4);",
      "SELECT get_church_open_date(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_church_open_date` that takes a church ID as an integer input and returns the integer open date for that church from the church table.",
    "natural_language": "Write a function called `get_church_open_date` that, when given a church's ID number, fetches and gives back roughly when that church first opened from the main list, as a simple number.",
    "id": 8,
    "generated_ir": "Write a PLpgSQL function named get_church_open_date that accepts a single parameter p_church_id of type integer, which represents the unique identifier of a church. The function is designed to retrieve the open date of a church from the church table. It declares a local variable v_open_date of type integer to store the result of the query. The function performs a SELECT operation on the church table, specifically targeting the Open_Date column, and assigns the retrieved value to the v_open_date variable. The selection is based on the condition that the Church_ID column in the church table matches the value of the input parameter p_church_id. After successfully retrieving the open date, the function returns the value stored in v_open_date. The function is written in the PLpgSQL language."
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters: writer_id of type integer and multiplier of type numeric, and returns a table with two columns: episode_count of type integer and productivity_score of type numeric. The function performs a SELECT operation on the writer table, specifically retrieving the num_of_episodes column for the row where the wid column matches the provided writer_id parameter. It then calculates the productivity_score by applying the exponential function exp() to the product of num_of_episodes and the multiplier parameter. The function returns the num_of_episodes value as episode_count and the calculated productivity_score for the specified writer_id.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_writer_productivity(writer_id integer, multiplier numeric)\nRETURNS TABLE(episode_count integer, productivity_score numeric) LANGUAGE plpgsql AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        \"num_of_episodes\",\n        exp(\"num_of_episodes\" * multiplier)\n    FROM \"writer\"\n    WHERE \"wid\" = writer_id;\nEND;\n$$;",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "actor",
      "cast",
      "director",
      "directed_by",
      "writer",
      "written_by",
      "genre"
    ],
    "call_sqls": [
      "SELECT * FROM analyze_writer_productivity(1, 0.1);",
      "SELECT * FROM analyze_writer_productivity(5, 0.05);",
      "SELECT * FROM analyze_writer_productivity(10, 0.2);",
      "SELECT * FROM analyze_writer_productivity(15, 0.01);",
      "SELECT * FROM analyze_writer_productivity(20, 0.15);"
    ],
    "summary": "Create a PLpgSQL function that returns a table with episode_count and productivity_score for a given writer_id. It calculates productivity_score as exp(num_of_episodes * multiplier).",
    "natural_language": "Please construct a PL/pgSQL function that yields a table containing the columns 'episode_count' and 'productivity_score' for a specified writer identifier. The function must compute the productivity score by applying the exponential function to the product of the number of episodes and a predetermined multiplier.",
    "id": 9,
    "generated_ir": "Write a PLpgSQL function that takes two parameters: writer_id of type integer and multiplier of type numeric, and returns a table with two columns: episode_count of type integer and productivity_score of type numeric. The function performs a SELECT operation on the writer table, specifically retrieving the num_of_episodes column for the row where the wid column matches the provided writer_id parameter. It then calculates the productivity_score by applying the exponential function exp() to the product of num_of_episodes and the multiplier parameter. The function returns the num_of_episodes value as episode_count and the calculated productivity_score for the specified writer_id."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_pet_weight` that accepts two input parameters: `p_pet_id` of type `bigint` and `p_weight_threshold` of type `real`. This function is designed to return a single value of type `real`. Inside the function, a local variable named `v_weight` of type `real` is declared to temporarily store the retrieved weight. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"weight\"` from the table named `\"Pets\"`. The retrieved value is then assigned to the local variable `v_weight`. The selection of rows from the `\"Pets\"` table is subject to two conditions connected by an `AND` operator: first, the value in the column named `\"PetID\"` must be equal to the value provided in the input parameter `p_pet_id`; and second, the value in the column named `\"weight\"` must be strictly greater than the value provided in the input parameter `p_weight_threshold`. After the `SELECT` statement has been executed and `v_weight` has been populated with the result, the function returns the value currently stored in the `v_weight` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_pet_weight(p_pet_id bigint, p_weight_threshold real)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_weight real;\nBEGIN\n    SELECT \"weight\"\n    INTO v_weight\n    FROM \"Pets\"\n    WHERE \"PetID\" = p_pet_id\n    AND \"weight\" > p_weight_threshold;\n    \n    RETURN v_weight;\nEND;\n$$;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_pet_weight(2001, 10.0);",
      "SELECT get_pet_weight(2002, 13.0);",
      "SELECT get_pet_weight(2003, 5.0);",
      "SELECT get_pet_weight(2001, 15.0);",
      "SELECT get_pet_weight(2002, 11.0);"
    ],
    "summary": "Create a function named `get_pet_weight` that returns a `real` value. It takes a `bigint` pet ID and a `real` weight threshold as input. The function selects the `weight` from the `\"Pets\"` table where the `\"PetID\"` matches the input ID and the `\"weight\"` is greater than the input threshold, then returns that weight.",
    "natural_language": "Make a function `get_pet_weight` returning real. It takes a bigint pet ID and a real weight threshold. Return the weight from \"Pets\" where \"PetID\" matches and \"weight\" exceeds the threshold.",
    "id": 10,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_pet_weight that returns a real value, accepts two input parameters: pet_id of type bigint, which identifies a specific pet, and weight_threshold of type real, which specifies a minimum weight value; this function performs a read operation on the Pets table by selecting the weight column value into a local variable, specifically from the row where the PetID column matches the provided pet_id parameter and the weight column value is greater than the provided weight_threshold parameter; if such a row exists, the function returns the retrieved weight value; if no row satisfies both conditions, the function returns NULL."
  },
  {
    "ir": "Write a PLpgSQL function named count_actors_in_musical that accepts a single integer input parameter named p_musical_id, which is used to identify a specific musical, and returns an integer value representing a count; within the function, it declares a local integer variable named actor_count, then executes a SELECT statement that queries the actor table to count all rows where the value in the column named \"Musical_ID\" exactly matches the provided p_musical_id parameter, storing the result of this COUNT(*) aggregation into the actor_count variable, and finally returns the value stored in the actor_count variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION count_actors_in_musical(p_musical_id integer)\nRETURNS integer AS $$\nDECLARE\n    actor_count integer;\nBEGIN\n    SELECT COUNT(*) INTO actor_count\n    FROM actor\n    WHERE \"Musical_ID\" = p_musical_id;\n    RETURN actor_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT count_actors_in_musical(1);",
      "SELECT count_actors_in_musical(2);",
      "SELECT count_actors_in_musical(3);",
      "SELECT count_actors_in_musical(4);",
      "SELECT count_actors_in_musical(5);"
    ],
    "summary": "Create a PL/pgSQL function named count_actors_in_musical that takes an integer p_musical_id and returns an integer. It should count and return the number of actors in the actor table where the \"Musical_ID\" matches the input parameter.",
    "natural_language": "Write a function called count_actors_in_musical that takes a musical ID number and gives back a count. It should figure out roughly how many actors are in the actor list for that specific musical, more or less.",
    "id": 11,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named count_actors_in_musical that accepts a single input parameter p_musical_id of type integer, which represents the unique identifier of a musical record, and returns an integer value representing the count of actors. The function begins by declaring a local variable v_actor_count of type integer to store the computed count. The function's logic executes a SELECT statement that queries the actor table, specifically performing a COUNT(*) aggregation on all rows where the Musical_ID column matches the provided p_musical_id parameter. This count operation calculates the total number of actor records associated with the given musical ID. The resulting count value is then assigned into the v_actor_count variable. Finally, the function concludes by returning the value stored in the v_actor_count variable."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_account_summary` that accepts a single input parameter, `account_id_input`, which is of data type `BIGINT`. This function is designed to return a set of rows, effectively acting as a table-returning function. The output table will consist of two columns: `account_name` of data type `TEXT` and `date_account_opened` of data type `TIMESTAMPTZ`. The core operation performed by this function is a `SELECT` statement. Specifically, it selects the `account_name` column and the `date_account_opened` column from the table named `\"Accounts\"`, aliased as `a`. The selection of rows is filtered by a `WHERE` clause, which specifies that only those rows where the `account_id` column in the `\"Accounts\"` table (`a.account_id`) is equal to the value provided by the `account_id_input` parameter will be included in the result set. The `RETURN QUERY` statement is used to return the entire result set of this `SELECT` query as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_account_summary(account_id_input BIGINT)\nRETURNS TABLE(account_name TEXT, date_account_opened TIMESTAMPTZ)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT a.account_name, a.date_account_opened\n    FROM \"Accounts\" a\n    WHERE a.account_id = account_id_input;\nEND;\n$$;",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Financial_Transactions"
    ],
    "call_sqls": [
      "SELECT * FROM get_account_summary(1);",
      "SELECT * FROM get_account_summary(2);",
      "SELECT * FROM get_account_summary(3);",
      "SELECT * FROM get_account_summary(8);",
      "SELECT * FROM get_account_summary(13);"
    ],
    "summary": "Create a PL/pgSQL function named get_account_summary that takes an account ID (bigint). It returns a table with columns account_name (text) and date_account_opened (timestamptz). The function selects and returns the account name and opening date for the specified account ID.",
    "natural_language": "What is the account name and opening date for a specified account ID? Create a PL/pgSQL function named get_account_summary that takes an account ID (bigint) and returns a table with these columns.",
    "id": 12,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_account_summary` that accepts a single input parameter, `account_id_input`, which is of data type `BIGINT`. This function is designed to return a set of rows, effectively acting as a table-returning function. The output table will consist of two columns: `account_name` of data type `TEXT` and `date_account_opened` of data type `TIMESTAMPTZ`. The core operation performed by this function is a `SELECT` statement. Specifically, it selects the `account_name` column and the `date_account_opened` column from the table named `\"Accounts\"`, aliased as `a`. The selection of rows is filtered by a `WHERE` clause, which specifies that only those rows where the `account_id` column in the `\"Accounts\"` table (`a.account_id`) is equal to the value provided by the `account_id_input` parameter will be included in the result set. The `RETURN QUERY` statement is used to return the entire result set of this `SELECT` query as the output of the function."
  },
  {
    "ir": "Write a PL/pgSQL function named `get_album_year_or_default` that accepts a single input parameter named `album_id` of type `bigint`. This function is designed to return a `bigint` value. Inside the function, a local variable named `result` of type `bigint` is declared. The function then executes a `SELECT` statement to retrieve the value from the column named `\"Year\"` from the table named `\"Albums\"`. This selection is performed for the row where the value in the column named `\"AId\"` is equal to the value provided by the input parameter `album_id`. The retrieved value is then assigned to the local variable `result`. Following this, a conditional check is performed: if the value stored in the `result` variable is `NULL`, the function immediately returns the `bigint` literal value `2000`. If the `result` variable is not `NULL`, the function proceeds to return the value currently stored in the `result` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_album_year_or_default(album_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    result bigint;\nBEGIN\n    SELECT \"Year\" INTO result FROM \"Albums\" WHERE \"AId\" = album_id;\n    IF result IS NULL THEN\n        RETURN 2000;\n    END IF;\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Songs",
      "Tracklists",
      "Instruments",
      "Vocals"
    ],
    "call_sqls": [
      "SELECT get_album_year_or_default(1);",
      "SELECT get_album_year_or_default(2);",
      "SELECT get_album_year_or_default(3);",
      "SELECT get_album_year_or_default(4);",
      "SELECT get_album_year_or_default(5);"
    ],
    "summary": "Create a function named get_album_year_or_default that takes a bigint album_id and returns a bigint. It selects the Year from the Albums table where AId matches the input. If the result is NULL, return 2000; otherwise, return the result.",
    "natural_language": "Create a function, which should be named get_album_year_or_default, that is designed to accept a single bigint parameter representing an album_id. This function must return a bigint value. Its core operation involves querying the Albums table to carefully select the Year column specifically for the entry whose AId column precisely matches the provided input identifier. In the detailed scenario where this query yields a NULL result, indicating the year is absent, the function should thoughtfully return a default value of 2000. Conversely, if a valid year is successfully retrieved, it should simply and directly return that actual result.",
    "id": 13,
    "generated_ir": "Write a PLpgSQL function named get_album_year_or_default that accepts a single input parameter named p_album_id of type bigint, representing the unique identifier of an album. The function returns a single bigint value. Within the function, a local variable named v_year of type bigint is declared to store the retrieved year value. The function executes a SELECT statement that queries the Albums table, specifically retrieving the Year column for the row where the AId column exactly matches the provided p_album_id parameter. The result of this query is stored into the v_year variable. Following this, a conditional check is performed using an IF statement. If the v_year variable is found to be NULL, the function returns the default bigint value 2000. Otherwise, if v_year is not NULL, the function returns the value contained in the v_year variable."
  },
  {
    "ir": "Write a PLpgSQL function that calculates the total sales count for a specific product by summing the order quantities from the \"Order_Items\" table where the product_id matches the provided parameter p_product_id, which is of type bigint. The function begins by declaring a variable v_sales_count of type bigint to store the result of the summation. It then performs a SELECT operation to sum the order_quantity column, casting each value to an integer, from the \"Order_Items\" table, filtering the rows where the product_id column equals the input parameter p_product_id. The result of this summation is stored into the v_sales_count variable. The function concludes by returning the value of v_sales_count, using the COALESCE function to ensure that if v_sales_count is null, a default value of 0 is returned instead.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_sales_count(p_product_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_sales_count bigint;\nBEGIN\n    SELECT SUM(oi.order_quantity::int) INTO v_sales_count\n    FROM \"Order_Items\" oi\n    WHERE oi.product_id = p_product_id;\n    \n    RETURN COALESCE(v_sales_count, 0);\nEND;\n$$;",
    "database_name": "customers_and_orders",
    "tables": [
      "Addresses",
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "SELECT get_product_sales_count(1);",
      "SELECT get_product_sales_count(2);",
      "SELECT get_product_sales_count(3);",
      "SELECT get_product_sales_count(10);",
      "SELECT get_product_sales_count(13);"
    ],
    "summary": "Create a function that takes a product_id (bigint) and returns the total sales count (bigint) by summing the order_quantity from the Order_Items table for that product, returning 0 if no sales are found.",
    "natural_language": "Calculate the total sales count for a given product ID by summing the order quantities from the Order_Items table. Return 0 if there are no sales for that product.",
    "id": 14,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_product_sales_count that accepts a single input parameter product_id_input of type bigint and returns a bigint value. The function declares a local variable total_sales of type bigint, initializing it to 0. It then executes a SELECT query that sums the order_quantity column from the Order_Items table, converting the text values to bigint using the CAST function, where the product_id column matches the provided product_id_input parameter. The result of this sum is stored in the total_sales variable. If the sum returns NULL, indicating no matching records, the function returns 0; otherwise, it returns the calculated total_sales value, representing the total sales count for the specified product ID."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_age that accepts a single input parameter named musical_name of type text, which represents the name of a musical, and returns a value of type numeric; the function declares a local numeric variable named avg_age, then executes a SELECT statement that calculates the average age by applying the AVG aggregate function to the age column from the actor table, which is aliased as a; this calculation is performed on rows obtained by performing an inner join between the actor table and the musical table, aliased as m, using the condition that the Musical_ID column from the actor table matches the Musical_ID column from the musical table; the join is further filtered by a WHERE clause that requires the Name column from the musical table to be exactly equal to the provided musical_name parameter; the result of the AVG calculation is stored into the local variable avg_age using the INTO clause, and finally, the function returns the value stored in the avg_age variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_age(musical_name text)\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    avg_age numeric;\nBEGIN\n    SELECT AVG(a.age) INTO avg_age\n    FROM actor a\n    JOIN musical m ON a.\"Musical_ID\" = m.\"Musical_ID\"\n    WHERE m.\"Name\" = musical_name;\n\n    RETURN avg_age;\nEND;\n$$;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT calculate_average_age('The Phantom of the Opera');",
      "SELECT calculate_average_age('Les MisÃ©rables');",
      "SELECT calculate_average_age('Wicked');",
      "SELECT calculate_average_age('Cats');",
      "SELECT calculate_average_age('Hamilton');"
    ],
    "summary": "Create a function named calculate_average_age that takes a musical name as text input and returns a numeric value. It calculates the average age of actors from the actor table who are associated with that specific musical by joining the actor and musical tables on Musical_ID.",
    "natural_language": "Develop a function called calculate_average_age which accepts a single text parameter representing the name of a musical. This function should meticulously compute and return a precise numeric value, specifically the average age of all actors listed in the actor table who have performed in that particular musical. This calculation is achieved by performing a detailed join between the actor and musical tables using the common Musical_ID field to correctly associate each actor with their respective production.",
    "id": 15,
    "generated_ir": "Write a PLpgSQL function named calculate_average_age that accepts a single input parameter p_musical_name of type text, which represents the name of a musical production, and returns a numeric value representing the computed average age. The function begins by declaring a local variable v_average_age of type numeric to store the result. The function body executes a SQL query that calculates the average age of actors associated with the specified musical. This is done by performing an inner join between the actor table and the musical table using the common column Musical_ID to link actors to their respective musical productions. The query includes a condition in the WHERE clause to filter rows where the Name column in the musical table matches the provided p_musical_name parameter. For the filtered set of rows, the query computes the average value of the age column from the actor table using the AVG(age) aggregate function, and the result is cast to the numeric data type to ensure precision. The computed average is then stored into the variable v_average_age. Finally, the function returns the value stored in v_average_age using the RETURN statement, providing the precise numeric average age of all actors who have performed in that particular musical."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_total_debt_accounts` that accepts a single input parameter, `p_master_id`, which is of type `bigint` and represents a master customer identifier. This function is designed to return an `integer` value representing the total count of debt accounts associated with the specified master customer.\n\nUpon execution, the function declares a local variable named `v_total` of type `integer` to store the calculated sum of debt accounts. The core operation involves a single `SELECT` statement that calculates the sum of counts from four distinct categories of debt accounts. Each category's count is determined by performing a `COUNT(*)` operation on a specific debt-related table, joined with the `CMI_Cross_References` table.\n\nSpecifically, the function performs the following four sub-queries and sums their results:\n1. It counts the number of records in the `\"Benefits_Overpayments\"` table. This count is filtered by joining `\"Benefits_Overpayments\"` (aliased as `bo`) with the `\"CMI_Cross_References\"` table (aliased as `cr`) on the common column `cmi_cross_ref_id` (i.e., `bo.cmi_cross_ref_id = cr.cmi_cross_ref_id`). The resulting set is further filtered to include only those records where the `master_customer_id` column in the `CMI_Cross_References` table matches the input parameter `p_master_id`.\n2. It counts the number of records in the `\"Business_Rates\"` table. This count is filtered by joining `\"Business_Rates\"` (aliased as `br`) with the `\"CMI_Cross_References\"` table (aliased as `cr`) on the common column `cmi_cross_ref_id` (i.e., `br.cmi_cross_ref_id = cr.cmi_cross_ref_id`). The resulting set is further filtered to include only those records where the `master_customer_id` column in the `CMI_Cross_References` table matches the input parameter `p_master_id`.\n3. It counts the number of records in the `\"Council_Tax\"` table. This count is filtered by joining `\"Council_Tax\"` (aliased as `ct`) with the `\"CMI_Cross_References\"` table (aliased as `cr`) on the common column `cmi_cross_ref_id` (i.e., `ct.cmi_cross_ref_id = cr.cmi_cross_ref_id`). The resulting set is further filtered to include only those records where the `master_customer_id` column in the `CMI_Cross_References` table matches the input parameter `p_master_id`.\n4. It counts the number of records in the `\"Rent_Arrears\"` table. This count is filtered by joining `\"Rent_Arrears\"` (aliased as `ra`) with the `\"CMI_Cross_References\"` table (aliased as `cr`) on the common column `cmi_cross_ref_id` (i.e., `ra.cmi_cross_ref_id = cr.cmi_cross_ref_id`). The resulting set is further filtered to include only those records where the `master_customer_id` column in the `CMI_Cross_References` table matches the input parameter `p_master_id`.\n\nThe sum of these four individual counts is then assigned to the `v_total` variable. Finally, the function returns the value stored in `v_total` as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_debt_accounts(p_master_id bigint)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total integer;\nBEGIN\n    SELECT (SELECT COUNT(*) FROM \"Benefits_Overpayments\" bo JOIN \"CMI_Cross_References\" cr ON bo.cmi_cross_ref_id = cr.cmi_cross_ref_id WHERE cr.master_customer_id = p_master_id) +\n           (SELECT COUNT(*) FROM \"Business_Rates\" br JOIN \"CMI_Cross_References\" cr ON br.cmi_cross_ref_id = cr.cmi_cross_ref_id WHERE cr.master_customer_id = p_master_id) +\n           (SELECT COUNT(*) FROM \"Council_Tax\" ct JOIN \"CMI_Cross_References\" cr ON ct.cmi_cross_ref_id = cr.cmi_cross_ref_id WHERE cr.master_customer_id = p_master_id) +\n           (SELECT COUNT(*) FROM \"Rent_Arrears\" ra JOIN \"CMI_Cross_References\" cr ON ra.cmi_cross_ref_id = cr.cmi_cross_ref_id WHERE cr.master_customer_id = p_master_id)\n    INTO v_total;\n    RETURN v_total;\nEND;\n$$;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "SELECT calculate_total_debt_accounts(1);",
      "SELECT calculate_total_debt_accounts(2);",
      "SELECT calculate_total_debt_accounts(3);",
      "SELECT calculate_total_debt_accounts(4);",
      "SELECT calculate_total_debt_accounts(5);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_total_debt_accounts` that takes a master customer ID (`bigint`) and returns an integer total. The function should sum the counts of records from four debt tables (`Benefits_Overpayments`, `Business_Rates`, `Council_Tax`, `Rent_Arrears`) where each record is linked to the provided master ID via the `CMI_Cross_References` table, and return this total.",
    "natural_language": "Write a function that gives us a rough total number of debt-related entries for a certain customer. It should look through a few different debt tablesâ€”like for overpayments, business charges, local taxes, and rentâ€”and add up how many records seem to be connected to that person via a reference table. Just return that overall count.",
    "id": 16,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_total_debt_accounts that accepts one input parameter p_master_customer_id of type bigint and returns a single bigint value representing the total count of debt-related entries for the specified customer. The function operates within the local_govt_mdm database and queries multiple tables: Benefits_Overpayments, Business_Rates, Council_Tax, and Rent_Arrears, which are all linked to the Customer_Master_Index via the CMI_Cross_References table.\n\nThe function begins by declaring a variable total_debt_count of type bigint, initialized to 0. It then executes a series of SELECT statements, each counting distinct entries from one of the debt tables that are associated with the given master_customer_id through the CMI_ross_References table. Specifically, for each debt table, it performs a JOIN with CMI_Cross_References on the cmi_cross_ref_id column to filter records where the master_customer_id matches the input parameter p_master_customer_id.\n\nFirst, it queries the Benefits_Overpayments table, counting the number of distinct council_tax_id values (since council_tax_id is the primary key) where the associated cmi_cross_ref_id in CMI_Cross_References corresponds to p_master_customer_id. This count is added to total_debt_count.\n\nSecond, it queries the Business_Rates table, counting the number of distinct business_rates_id values (the primary key) where the associated cmi_cross_ref_id in CMI_Cross_References corresponds to p_master_customer_id. This count is added to total_debt_count.\n\nThird, it queries the Council_Tax table, counting the number of distinct council_tax_id values (the primary key) where the associated cmi_cross_ref_id in CMI_Cross_References corresponds to p_master_customer_id. This count is added to total_debt_count.\n\nFourth, it queries the Rent_Arrears table, counting the number of distinct council_tax_id values (the primary key) where the associated cmi_cross_ref_id in CMI_Cross_References corresponds to p_master_customer_id. This count is added to total_debt_count.\n\nAfter aggregating these counts, the function returns the total_debt_count as the final result, which represents the sum of all debt-related entries across the four tables for the specified customer. No ordering or grouping is applied, as the function simply returns a single aggregate count."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_device_stock_total` that accepts a single input parameter, `p_device_id`, which is of type `integer`. This function is designed to return an `integer` value. Upon execution, the function declares a local variable named `v_total` of type `integer`. The core operation involves performing a `SELECT` statement to calculate the sum of all values in the column named `\"Quantity\"` from the table named `\"stock\"`. This summation is conditional, applying only to rows where the value in the column named `\"Device_ID\"` is equal to the value provided by the input parameter `p_device_id`. The result of this `SUM` aggregation is then stored into the local variable `v_total`. Finally, the function returns the value of `v_total`. If `v_total` is `NULL` (which would occur if no matching rows were found in the `\"stock\"` table for the given `p_device_id`), the `COALESCE` function ensures that `0` is returned instead of `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_stock_total(p_device_id integer) RETURNS integer AS $$\nDECLARE\n    v_total integer;\nBEGIN\n    SELECT SUM(\"Quantity\") INTO v_total FROM \"stock\" WHERE \"Device_ID\" = p_device_id;\n    RETURN COALESCE(v_total, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT get_device_stock_total(1);",
      "SELECT get_device_stock_total(2);",
      "SELECT get_device_stock_total(3);",
      "SELECT get_device_stock_total(6);",
      "SELECT get_device_stock_total(NULL);"
    ],
    "summary": "Create a function named get_device_stock_total that takes a device ID as input and returns the total quantity of that device from the stock table. Return 0 if no stock is found.",
    "natural_language": "Function get_device_stock_total returns total stock for a given device ID, or 0 if none.",
    "id": 17,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_device_stock_total` that accepts one input parameter: `p_device_id`, which is of type `integer` and represents the unique identifier of a device. This function is designed to return an integer value representing the total stock quantity for the specified device across all shops. Upon execution, the function declares one local variable: `total_stock` of type `integer` to store the computed total quantity. The function then performs a `SELECT` operation that uses the `SUM` aggregate function to calculate the total of the `quantity` column from the `stock` table. This aggregation is conditioned by a `WHERE` clause that matches the `device_id` column in the `stock` table with the value provided in the `p_device_id` input parameter. The result of this `SUM` operation is then assigned to the `total_stock` local variable. If no records are found in the `stock` table for the given `p_device_id`, the `SUM` function would return `NULL`. To handle this, the function uses the `COALESCE` function to convert any `NULL` result to `0`, ensuring that `total_stock` is always a valid integer. Finally, the function returns the value stored in the `total_stock` variable as its output."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter named chain_id of type bigint and returns an integer. This function calculates the number of department stores associated with a specific department store chain. It declares a local variable store_count of type integer to store the result of the calculation. The function performs a SELECT operation to count the number of rows in the \"Department_Stores\" table where the dept_store_chain_id column matches the provided chain_id parameter. The COUNT function is used to determine the total number of department stores that belong to the specified chain. The result of this count is stored in the store_count variable. Finally, the function returns the value of store_count, which represents the total number of department stores associated with the given chain_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_store_count_by_chain(chain_id bigint) RETURNS integer AS $$\nDECLARE\n    store_count integer;\nBEGIN\n    SELECT COUNT(dept_store_id) INTO store_count\n    FROM \"Department_Stores\"\n    WHERE dept_store_chain_id = chain_id;\n    RETURN store_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Department_Stores",
      "Departments",
      "Staff",
      "Staff_Department_Assignments",
      "Department_Store_Chain"
    ],
    "call_sqls": [
      "SELECT get_store_count_by_chain(1);",
      "SELECT get_store_count_by_chain(2);",
      "SELECT get_store_count_by_chain(3);",
      "SELECT get_store_count_by_chain(4);",
      "SELECT get_store_count_by_chain(5);"
    ],
    "summary": "Create a PL/pgSQL function that takes a chain_id (bigint) and returns the count of department stores for that chain.",
    "natural_language": "Hey, can you whip up a function in PL/pgSQL that, given a chain's ID (as a bigint), spits back how many department stores that chain has?",
    "id": 18,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_store_count_by_chain that accepts a single input parameter chain_id of type BIGINT and returns a BIGINT value, which calculates and returns the total number of department stores belonging to a specific department store chain identified by its chain ID. The function declares a local variable store_count of type BIGINT to store the computed count. The function executes a SELECT query with the COUNT aggregate function on the Department_Stores table, counting all rows where the dept_store_chain_id column matches the provided chain_id parameter. This count is directly retrieved and stored into the store_count variable using the INTO clause. Finally, the function returns the value stored in the store_count variable."
  },
  {
    "ir": "Write a PLpgSQL function that takes three input parameters: p_musical_id of type integer, p_age_threshold of type integer, and p_duration_prefix of type text, and returns an integer value. The function performs a SELECT operation to count the number of rows in the actor table that satisfy the following conditions: the value in the Musical_ID column matches the value of the p_musical_id parameter, the value in the age column is greater than the value of the p_age_threshold parameter, and the first part of the value in the Duration column (split by the delimiter 'â€”') matches the value of the p_duration_prefix parameter. The split_part function is used to extract the first segment of the Duration column's value based on the delimiter 'â€”'. The COUNT(*) function is applied to determine the total number of rows meeting these criteria, and this count is returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION count_actors_by_criteria(p_musical_id integer, p_age_threshold integer, p_duration_prefix text)\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM actor WHERE \"Musical_ID\" = p_musical_id AND age > p_age_threshold AND split_part(\"Duration\", 'â€”', 1) = p_duration_prefix);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT count_actors_by_criteria(1, 25, '1988');",
      "SELECT count_actors_by_criteria(2, 20, '1992');",
      "SELECT count_actors_by_criteria(1, 30, '1988');",
      "SELECT count_actors_by_criteria(3, 18, '1993');",
      "SELECT count_actors_by_criteria(2, 25, '1988');"
    ],
    "summary": "Create a function that returns an integer count. It takes a musical ID, an age threshold, and a duration prefix as inputs. The function counts rows in the actor table where the \"Musical_ID\" matches the input ID, the age is greater than the input threshold, and the first part of the \"Duration\" column (split by 'â€”') matches the input prefix.",
    "natural_language": "How many actors are there where the Musical_ID matches a given ID, their age is above a specified threshold, and the first part of the Duration (before the 'â€”') matches a provided prefix?",
    "id": 19,
    "generated_ir": "Write a PLpgSQL function that takes three input parameters: p_musical_id of type integer, p_age_threshold of type integer, and p_duration_prefix of type text, and returns an integer value. The function performs a SELECT operation to count the number of rows in the actor table that satisfy the following conditions: the value in the Musical_ID column matches the value of the p_musical_id parameter, the value in the age column is greater than the value of the p_age_threshold parameter, and the first part of the value in the Duration column (split by the delimiter 'â€”') matches the value of the p_duration_prefix parameter. The split_part function is used to extract the first segment of the Duration column's value based on the delimiter 'â€”'. The COUNT(*) function is applied to determine the total number of rows meeting these criteria, and this count is returned as the output of the function."
  },
  {
    "ir": "Write a PLpgSQL function named get_staff_problem_summary that accepts a single parameter, staff_id_input, of type bigint, and returns a table with two columns: reported_count and assigned_count, both of type bigint. The function begins by executing a RETURN QUERY statement, which performs two subqueries. The first subquery counts the number of rows in the Problems table where the reported_by_staff_id column matches the value of staff_id_input, effectively calculating how many problems have been reported by the specified staff member. The second subquery counts the number of rows in the Problem_Log table where the assigned_to_staff_id column equals the staff_id_input, determining how many problems have been assigned to the specified staff member. The results of these two subqueries are returned as a single row with two columns, reported_count and assigned_count, representing the total number of problems reported by and assigned to the staff member identified by staff_id_input, respectively.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_problem_summary(staff_id_input bigint) RETURNS TABLE(reported_count bigint, assigned_count bigint) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n        (SELECT COUNT(*) FROM \"Problems\" WHERE reported_by_staff_id = staff_id_input),\n        (SELECT COUNT(*) FROM \"Problem_Log\" WHERE assigned_to_staff_id = staff_id_input);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "SELECT * FROM get_staff_problem_summary(1);",
      "SELECT * FROM get_staff_problem_summary(2);",
      "SELECT * FROM get_staff_problem_summary(10);",
      "SELECT * FROM get_staff_problem_summary(11);",
      "SELECT * FROM get_staff_problem_summary(12);"
    ],
    "summary": "Create a function named get_staff_problem_summary that accepts a staff_id_input (bigint) and returns a table with columns reported_count and assigned_count (both bigint). The function should return a single row containing: the count of problems reported by the staff member from the \"Problems\" table, and the count of problems assigned to the staff member from the \"Problem_Log\" table.",
    "natural_language": "Construct a function called get_staff_problem_summary which is designed to take a single input parameter, specifically a staff_id_input of type bigint. This function must return a results table featuring precisely two columns: reported_count and assigned_count, both defined as bigint. The function's purpose is to meticulously calculate and deliver, within a single row of output, the following detailed counts: firstly, the total number of problems that were originally reported by the specified staff member, diligently extracted from the \"Problems\" table; and secondly, the comprehensive count of all problems that have been officially assigned to that staff member, carefully gathered from the records within the \"Problem_Log\" table.",
    "id": 20,
    "generated_ir": "Write a PLpgSQL function named get_staff_problem_summary that accepts a single parameter, staff_id_input, of type bigint, and returns a table with two columns: reported_count and assigned_count, both of type bigint. The function begins by executing a RETURN QUERY statement, which performs two subqueries. The first subquery counts the number of rows in the Problems table where the reported_by_staff_id column matches the value of staff_id_input, effectively calculating how many problems have been reported by the specified staff member. The second subquery counts the number of rows in the Problem_Log table where the assigned_to_staff_id column equals the staff_id_input, determining how many problems have been assigned to the specified staff member. The results of these two subqueries are returned as a single row with two columns, reported_count and assigned_count, representing the total number of problems reported by and assigned to the staff member identified by staff_id_input, respectively."
  },
  {
    "ir": "Write a PLpgSQL function named evaluate_cross_reference that accepts a single parameter p_cmi_cross_ref_id of type bigint, which represents the identifier for a cross-reference entry in the CMI_Cross_References table. The function begins by declaring two local variables: v_source_code and v_evaluation, both of type text. The function performs a SELECT operation to retrieve the value from the source_system_code column of the CMI_Cross_References table where the cmi_cross_ref_id column matches the provided p_cmi_cross_ref_id parameter, storing this value into the v_source_code variable. The function then evaluates the value of v_source_code using a series of conditional statements. If v_source_code equals 'Rent', the function assigns the text 'RENT_SOURCE' to the v_evaluation variable. If v_source_code equals 'Parking', it assigns 'PARKING_SOURCE' to v_evaluation. If v_source_code equals 'Benefits', it assigns 'BENEFITS_SOURCE' to v_evaluation. If v_source_code equals 'Council', it assigns 'COUNCIL_SOURCE' to v_evaluation. For any other value of v_source_code, the function assigns 'OTHER_SOURCE' to v_evaluation. Finally, the function returns the value stored in v_evaluation.",
    "plsql": "CREATE OR REPLACE FUNCTION evaluate_cross_reference(p_cmi_cross_ref_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_source_code text;\n    v_evaluation text;\nBEGIN\n    SELECT source_system_code INTO v_source_code FROM \"CMI_Cross_References\" WHERE cmi_cross_ref_id = p_cmi_cross_ref_id;\n\n    IF v_source_code = 'Rent' THEN\n        v_evaluation := 'RENT_SOURCE';\n    ELSIF v_source_code = 'Parking' THEN\n        v_evaluation := 'PARKING_SOURCE';\n    ELSIF v_source_code = 'Benefits' THEN\n        v_evaluation := 'BENEFITS_SOURCE';\n    ELSIF v_source_code = 'Council' THEN\n        v_evaluation := 'COUNCIL_SOURCE';\n    ELSE\n        v_evaluation := 'OTHER_SOURCE';\n    END IF;\n\n    RETURN v_evaluation;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Council_Tax",
      "CMI_Cross_References",
      "Customer_Master_Index"
    ],
    "call_sqls": [
      "SELECT evaluate_cross_reference(2);",
      "SELECT evaluate_cross_reference(4);",
      "SELECT evaluate_cross_reference(8);",
      "SELECT evaluate_cross_reference(65);",
      "SELECT evaluate_cross_reference(41);"
    ],
    "summary": "Create a PLpgSQL function named evaluate_cross_reference that takes a bigint parameter p_cmi_cross_ref_id. It retrieves the source_system_code from CMI_Cross_References for the given ID, maps it to a descriptive text value ('RENT_SOURCE' for 'Rent', 'PARKING_SOURCE' for 'Parking', 'BENEFITS_SOURCE' for 'Benefits', 'COUNCIL_SOURCE' for 'Council', else 'OTHER_SOURCE'), and returns that text.",
    "natural_language": "Write a PLpgSQL function called evaluate_cross_reference that uses a bigint parameter for the cross-reference ID. It should fetch the source system code from the CMI_Cross_References table for that ID and then figure out what descriptive label to return. Basically, if the code is something like 'Rent', map it to 'RENT_SOURCE', if it's 'Parking', use 'PARKING_SOURCE', and do similar for a couple of other known types like 'Benefits' and 'Council'. For any other codes that pop up, just return a generic 'OTHER_SOURCE' label.",
    "id": 21,
    "generated_ir": "Write a PLpgSQL function named evaluate_cross_reference that accepts a single parameter p_cmi_cross_ref_id of type bigint, which represents the identifier for a cross-reference entry in the CMI_Cross_References table. The function begins by declaring two local variables: v_source_code and v_evaluation, both of type text. The function performs a SELECT operation to retrieve the value from the source_system_code column of the CMI_Cross_References table where the cmi_cross_ref_id column matches the provided p_cmi_cross_ref_id parameter, storing this value into the v_source_code variable. The function then evaluates the value of v_source_code using a series of conditional statements. If v_source_code equals 'Rent', the function assigns the text 'RENT_SOURCE' to the v_evaluation variable. If v_source_code equals 'Parking', it assigns 'PARKING_SOURCE' to v_evaluation. If v_source_code equals 'Benefits', it assigns 'BENEFITS_SOURCE' to v_evaluation. If v_source_code equals 'Council', it assigns 'COUNCIL_SOURCE' to v_evaluation. For any other value of v_source_code, the function assigns 'OTHER_SOURCE' to v_evaluation. Finally, the function returns the value stored in v_evaluation."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_classroom of type bigint, representing the identifier of a classroom, and calculates a value based on the number of students and their total grades in that classroom. The function begins by declaring two local variables: v_student_count of type bigint, which will store the count of students in the specified classroom, and v_grade_sum of type bigint, which will store the sum of grades for all students in the same classroom. It then assigns to v_student_count the result of a SELECT COUNT(*) query on the list table, where the \"Classroom\" column matches the value of the input parameter p_classroom. Next, it assigns to v_grade_sum the result of a SELECT SUM(\"Grade\") query on the same table, again filtering rows where the \"Classroom\" column equals p_classroom. Finally, the function returns the product of v_student_count and v_grade_sum as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION compute_class_total(p_classroom bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_student_count bigint;\n    v_grade_sum bigint;\nBEGIN\n    v_student_count := (SELECT COUNT(*) FROM list WHERE \"Classroom\" = p_classroom);\n    v_grade_sum := (SELECT SUM(\"Grade\") FROM list WHERE \"Classroom\" = p_classroom);\n    RETURN v_student_count * v_grade_sum;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT compute_class_total(101);",
      "SELECT compute_class_total(112);",
      "SELECT compute_class_total(107);",
      "SELECT compute_class_total(102);",
      "SELECT compute_class_total(103);"
    ],
    "summary": "Create a PL/pgSQL function that takes a `bigint` parameter `p_classroom`. It calculates the count of students and the sum of their `\"Grade\"` values from the `list` table for that classroom. The function returns the product of the student count and the total grade sum.",
    "natural_language": "Please construct a PL/pgSQL function that accepts a parameter `p_classroom` of type `bigint`. This function shall compute both the number of students and the aggregate sum of their `\"Grade\"` values from the `list` table, specifically for the provided classroom identifier. The function is then to return the mathematical product of the aforementioned student count and the total grade sum.",
    "id": 22,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named compute_class_total that accepts a single input parameter p_classroom of type bigint, returns a single numeric value, and operates on the student_1 database. The function first declares two local variables: student_count of type bigint to store the number of students, and total_grade_sum of type bigint to store the sum of all Grade values. It then performs a SELECT statement on the list table, using the WHERE clause to filter rows where the Classroom column equals the provided p_classroom parameter. In this SELECT, it calculates the count of rows as the student count and the sum of the Grade column as the total grade sum, storing both results into the respective variables with a single query. If no rows match the classroom filter, both variables are set to 0. After retrieving these values, the function computes the mathematical product of student_count and total_grade_sum by multiplying them together. Finally, it returns this product as the output of the function."
  },
  {
    "ir": "Write a PLpgSQL function named get_related_collections that accepts a single input parameter named collection_id of type bigint, which represents the unique identifier of a collection, and returns a single bigint value; within the function, a local variable named related_count of type bigint is declared; the function's logic begins by executing a SELECT statement that performs a COUNT(*) aggregation on the table named \"Collection_Subset_Members\", specifically counting all rows where the value in the column named \"Collection_ID\" is exactly equal to the input parameter collection_id; the result of this count operation is stored into the local variable related_count; the function then returns the value of related_count, which signifies the total number of related subset member records found for the given collection_id; the function includes an exception handling block that catches the specific predefined exception condition named undefined_table, which occurs if the query references a table that does not exist, and in that event, the function execution is diverted to return the value 0 instead of propagating the error.",
    "plsql": "CREATE OR REPLACE FUNCTION get_related_collections(collection_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    related_count bigint;\nBEGIN\n    SELECT COUNT(*)\n    INTO related_count\n    FROM \"Collection_Subset_Members\"\n    WHERE \"Collection_ID\" = get_related_collections.collection_id;\n\n    RETURN related_count;\nEXCEPTION\n    WHEN undefined_table THEN\n        RETURN 0;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Collections",
      "Collection_Subsets",
      "Collection_Subset_Members",
      "Documents_in_Collections"
    ],
    "call_sqls": [
      "SELECT get_related_collections(6);",
      "SELECT get_related_collections(7);",
      "SELECT get_related_collections(1);",
      "SELECT get_related_collections(100);",
      "SELECT get_related_collections(NULL);"
    ],
    "summary": "Create a function named get_related_collections that takes a bigint parameter collection_id and returns a bigint. Declare a bigint variable related_count. Count the rows in the \"Collection_Subset_Members\" table where \"Collection_ID\" equals collection_id and store the result in related_count. Return related_count. Handle the undefined_table exception by returning 0.",
    "natural_language": "Count the related collections for a given collection ID. To do this, create a function called get_related_collections that accepts a bigint parameter named collection_id and returns a bigint. Inside the function, declare a bigint variable named related_count. Then, count the rows in the \"Collection_Subset_Members\" table where the \"Collection_ID\" matches the provided collection_id and store that count in related_count. Finally, return the value of related_count. Ensure the function handles the undefined_table exception by returning 0.",
    "id": 23,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_related_collections that accepts a single input parameter collection_id of type bigint, representing the unique identifier of a collection, and returns a bigint value. The function begins execution by declaring a local variable related_count of type bigint to store the computed count. The function includes an exception handling block to catch the undefined_table exception. Within the main block, it performs a SELECT query that counts all rows from the Collection_Subset_Members table where the Collection_ID column exactly matches the input parameter collection_id, and stores this count result into the variable related_count. After the count is computed, the function returns the value of related_count. If an undefined_table exception is raised during the execution of the SELECT query, the exception handler catches it and returns 0 as the function's result."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named check_shop_exists that accepts a single input parameter p_shop_name of type text, which represents the name of a shop to be verified for existence, and returns a boolean value indicating the result of this verification; the function's logic begins by evaluating a conditional IF statement that checks for the existence of at least one record in the table named \"shop\" where the value in the column \"Shop_Name\" exactly matches, using a case-sensitive equality comparison, the provided input parameter p_shop_name; if such a record exists, the function execution proceeds to the THEN branch and returns the boolean value true; if no such record is found, the function execution proceeds to the ELSE branch and returns the boolean value false.",
    "plsql": "CREATE OR REPLACE FUNCTION check_shop_exists(p_shop_name text)\nRETURNS boolean AS $$\nBEGIN\n    IF EXISTS(SELECT 1 FROM \"shop\" WHERE \"Shop_Name\" = p_shop_name) THEN\n        RETURN true;\n    ELSE\n        RETURN false;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT check_shop_exists('Dinas Device');",
      "SELECT check_shop_exists('Best Buy');",
      "SELECT check_shop_exists('Ferndale');",
      "SELECT check_shop_exists('Non-Existent Shop');",
      "SELECT check_shop_exists('Walmart');"
    ],
    "summary": "Create a PL/pgSQL function named check_shop_exists that takes a shop_name (text) parameter and returns a boolean. Return TRUE if a record with that exact Shop_Name exists in the shop table, otherwise return FALSE.",
    "natural_language": "Write a PL/pgSQL function called check_shop_exists that accepts a shop_name text parameter and returns a boolean. Have it return TRUE if a record with that exact Shop_Name is found in the shop table, and FALSE otherwise.",
    "id": 24,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named check_shop_exists that accepts a single input parameter p_shop_name of type text, which represents the name of a shop to be verified for existence, and returns a boolean value indicating the result of this verification; the function's logic begins by evaluating a conditional IF statement that checks for the existence of at least one record in the table named \"shop\" where the value in the column \"Shop_Name\" exactly matches, using a case-sensitive equality comparison, the provided input parameter p_shop_name; if such a record exists, the function execution proceeds to the THEN branch and returns the boolean value true; if no such record is found, the function execution proceeds to the ELSE branch and returns the boolean value false."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_state of type text and returns a numeric value representing the average enrollment from the university table. The function performs a SELECT operation to calculate the average of the \"Enrollment\" column for rows where the \"State\" column matches the value of the p_state parameter. The function uses the AVG() aggregate function to compute the average enrollment, and the result is returned directly from the SELECT statement. The function is defined using the plpgsql language and does not include any conditional statements or additional logic beyond the selection and aggregation of data based on the specified state condition.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_enrollment_by_state(p_state text)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (SELECT AVG(\"Enrollment\") FROM university WHERE \"State\" = p_state);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT get_average_enrollment_by_state('Illinois');",
      "SELECT get_average_enrollment_by_state('Wisconsin');",
      "SELECT get_average_enrollment_by_state('California');",
      "SELECT get_average_enrollment_by_state('New York');",
      "SELECT get_average_enrollment_by_state('Texas');"
    ],
    "summary": "Create a PLpgSQL function that takes a text p_state and returns a numeric average enrollment from the university table for rows matching the given state.",
    "natural_language": "Write a PLpgSQL function that, for a provided state text, gives back a rough average of the enrollment numbers from the university data where the state is about right.",
    "id": 25,
    "generated_ir": "Write a PLpgSQL function that takes a single parameter p_state of type text and returns a numeric value representing the average enrollment from the university table. The function performs a SELECT operation to calculate the average of the \"Enrollment\" column for rows where the \"State\" column matches the value of the p_state parameter. The function uses the AVG() aggregate function to compute the average enrollment, and the result is returned directly from the SELECT statement. The function is defined using the plpgsql language and does not include any conditional statements or additional logic beyond the selection and aggregation of data based on the specified state condition."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_overpayment_details` that accepts one input parameter, `p_system_code`, which is of type `text`. This function is designed to return a set of rows, specifically a table, with two columns: `customer_name` of type `text` and `overpayment_count` of type `bigint`. The function's primary purpose is to retrieve customer details and, conditionally, their associated overpayment counts based on the provided system code.\n\nUpon execution, the function first evaluates a conditional statement. It converts the `p_system_code` parameter to lowercase using the `LOWER()` function and compares it to the literal string 'parking'.\n\nIf the lowercase `p_system_code` is equal to 'parking', the function executes a `RETURN QUERY` statement to select data from multiple tables. It selects the `cmi_details` column from the `\"Customer_Master_Index\"` table, aliased as `cmi`, and counts the occurrences of the `council_tax_id` column from the `\"Benefits_Overpayments\"` table, aliased as `bo`, using the `COUNT()` aggregate function. These selections are performed by joining three tables: `\"Customer_Master_Index\"` (`cmi`), `\"CMI_Cross_References\"` (`ccr`), and `\"Benefits_Overpayments\"` (`bo`). The first join connects `cmi` and `ccr` on the condition that `cmi.\"master_customer_id\"` is equal to `ccr.\"master_customer_id\"`. The second join connects `ccr` and `bo` on the condition that `ccr.\"cmi_cross_ref_id\"` is equal to `bo.\"cmi_cross_ref_id\"`. A `WHERE` clause further filters the results, ensuring that only rows where `ccr.\"source_system_code\"` is equal to the literal string 'Parking' are considered. Finally, the results are grouped by `cmi.\"cmi_details\"`.\n\nIf the lowercase `p_system_code` is not equal to 'parking', the function executes an alternative `RETURN QUERY` statement. In this case, it selects the `cmi_details` column from the `\"Customer_Master_Index\"` table, aliased as `cmi`, and a constant value of `0` cast to `bigint` for the `overpayment_count`. This selection is performed by joining two tables: `\"Customer_Master_Index\"` (`cmi`) and `\"CMI_Cross_References\"` (`ccr`). The join condition is `cmi.\"master_customer_id\"` equals `ccr.\"master_customer_id\"`. A `WHERE` clause filters these results, including only rows where `ccr.\"source_system_code\"` is equal to the value of the `p_system_code` parameter. The results are then grouped by `cmi.\"cmi_details\"`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_overpayment_details(p_system_code text)\nRETURNS TABLE(customer_name text, overpayment_count bigint) AS $$\nBEGIN\n    IF LOWER(p_system_code) = 'parking' THEN\n        RETURN QUERY SELECT cmi.\"cmi_details\", COUNT(bo.\"council_tax_id\")\n        FROM \"Customer_Master_Index\" cmi\n        JOIN \"CMI_Cross_References\" ccr ON cmi.\"master_customer_id\" = ccr.\"master_customer_id\"\n        JOIN \"Benefits_Overpayments\" bo ON ccr.\"cmi_cross_ref_id\" = bo.\"cmi_cross_ref_id\"\n        WHERE ccr.\"source_system_code\" = 'Parking'\n        GROUP BY cmi.\"cmi_details\";\n    ELSE\n        RETURN QUERY SELECT cmi.\"cmi_details\", 0::bigint\n        FROM \"Customer_Master_Index\" cmi\n        JOIN \"CMI_Cross_References\" ccr ON cmi.\"master_customer_id\" = ccr.\"master_customer_id\"\n        WHERE ccr.\"source_system_code\" = p_system_code\n        GROUP BY cmi.\"cmi_details\";\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_Cross_References",
      "Customer_Master_Index",
      "Council_Tax",
      "Benefits_Overpayments"
    ],
    "call_sqls": [
      "SELECT * FROM get_overpayment_details('Parking');",
      "SELECT * FROM get_overpayment_details('Rent');",
      "SELECT * FROM get_overpayment_details('parking');",
      "SELECT * FROM get_overpayment_details('Council Tax');",
      "SELECT * FROM get_overpayment_details('Unknown System');"
    ],
    "summary": "Create a function named get_overpayment_details that returns a table with columns customer_name (text) and overpayment_count (bigint). It accepts a text parameter p_system_code. If the lowercased p_system_code equals 'parking', return a query joining Customer_Master_Index, CMI_Cross_References, and Benefits_Overpayments, filtering where source_system_code = 'Parking', grouping by cmi_details, and selecting cmi_details and count of council_tax_id. Otherwise, return a query joining Customer_Master_Index and CMI_Cross_References, filtering where source_system_code = p_system_code, grouping by cmi_details, and selecting cmi_details and a constant 0 for overpayment_count.",
    "natural_language": "Write a function called get_overpayment_details that returns a table with customer_name (text) and overpayment_count (bigint) columns. It should take a text parameter p_system_code. If the lowercased parameter is 'parking', join Customer_Master_Index, CMI_Cross_References, and Benefits_Overpayments, filter for source_system_code = 'Parking', group by cmi_details, and select cmi_details and the count of council_tax_id. Otherwise, join just Customer_Master_Index and CMI_Cross_References, filter for source_system_code = p_system_code, group by cmi_details, and select cmi_details and a constant 0 as overpayment_count.",
    "id": 26,
    "generated_ir": "Write a PL/pgSQL function named get_overpayment_details in the local_govt_mdm database. The function accepts a single input parameter p_system_code of type text and returns a table with two columns: customer_name of type text and overpayment_count of type bigint.\n\nThe function begins by checking the value of the input parameter. It uses a conditional IF statement to compare the lowercased version of p_system_code to the string literal 'parking'. The LOWER function is applied to the parameter for case-insensitive comparison.\n\nIf the condition LOWER(p_system_code) = 'parking' evaluates to true, the function executes a RETURN QUERY statement. This query performs a SELECT operation that joins three tables: Customer_Master_Index (aliased as cmi), CMI_Cross_References (aliased as cr), and Benefits_Overpayments (aliased as bo). The join conditions are: cmi.master_customer_id = cr.master_customer_id and cr.cmi_cross_ref_id = bo.cmi_cross_ref_id. The WHERE clause filters the results to include only rows where the source_system_code column from the CMI_Cross_References table equals the exact string 'Parking'. The results are then grouped by the cmi_details column from the Customer_Master_Index table. For each group, the SELECT statement retrieves the cmi_details column, aliasing it as customer_name. It also calculates the overpayment_count by performing a COUNT aggregation on the council_tax_id column from the Benefits_Overpayments table.\n\nIf the initial condition is false (meaning the lowercased parameter is not 'parking'), the function executes an ELSE block containing a different RETURN QUERY statement. This query performs a SELECT operation that joins only two tables: Customer_Master_Index (aliased as cmi) and CMI_Cross_References (aliased as cr). The join condition is cmi.master_customer_id = cr.master_customer_id. The WHERE clause filters the results to include only rows where the source_system_code column from the CMI_Cross_References table equals the value of the input parameter p_system_code. The results are grouped by the cmi_details column from the Customer_Master_Index table. For each group, the SELECT statement retrieves the cmi_details column, aliasing it as customer_name. It returns a constant value of 0 for the overpayment_count column, casting it to bigint.\n\nThe function uses the plpgsql language and is defined to return the specified table structure. The logic ensures that for the specific system code 'Parking', the function returns actual overpayment counts by including the Benefits_Overpayments table in the join and counting related council_tax_id values. For any other system code provided, it returns a list of customer names with an overpayment count of zero, based on the join between Customer_Master_Index and CMI_Cross_References filtered by the provided source_system_code."
  },
  {
    "ir": "Write a PLpgSQL function named justify_collection_days that accepts two parameters: \"Collection_ID\" of type bigint and days_interval of type interval. The function aims to process the days_interval parameter using the PostgreSQL built-in function justify_days, which adjusts the interval to normalize the number of days, months, and years. The function begins by declaring a local variable justified_interval of type interval to store the result of the justify_days operation. Within the function body, it assigns the result of justify_days applied to days_interval to justified_interval. A conditional statement then checks if justified_interval is not null, and if this condition is true, the function returns justified_interval. If the condition is false, meaning justified_interval is null, the function returns an interval of '0 days'. The function does not interact with any tables, perform any updates, inserts, deletes, or selects, nor does it utilize any other functions or special operations beyond justify_days. The logic flow is straightforward, with a single conditional statement determining the return value based on the presence or absence of a non-null justified interval.",
    "plsql": "CREATE OR REPLACE FUNCTION justify_collection_days(\"Collection_ID\" bigint, days_interval interval)\nRETURNS interval\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    justified_interval interval;\nBEGIN\n    justified_interval := justify_days(days_interval);\n    IF justified_interval IS NOT NULL THEN\n        RETURN justified_interval;\n    END IF;\n    RETURN interval '0 days';\nEND;\n$$;",
    "database_name": "cre_Doc_and_collections",
    "tables": [
      "Collections",
      "Documents_in_Collections"
    ],
    "call_sqls": [
      "SELECT justify_collection_days(6, INTERVAL '5 days');",
      "SELECT justify_collection_days(7, INTERVAL '10 days');",
      "SELECT justify_collection_days(6, INTERVAL '1 day');",
      "SELECT justify_collection_days(7, INTERVAL '0 days');",
      "SELECT justify_collection_days(6, INTERVAL '20 days');"
    ],
    "summary": "Create a PL/pgSQL function named justify_collection_days that accepts a bigint Collection_ID and an interval days_interval. It uses justify_days on the interval, stores the result, and returns that result if not null, otherwise returns an interval of '0 days'.",
    "natural_language": "Alright, so we need a PL/pgSQL function called justify_collection_days. It's gotta take in a bigint for the Collection_ID and an interval called days_interval. The function should run justify_days on that interval, stash the result, and then spit it back out if it's not null. If it is null, just hand back an interval of '0 days'.",
    "id": 27,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `justify_collection_days`. The function accepts two input parameters: `p_collection_id` of type `bigint`, which represents the unique identifier of a collection, and `p_days_interval` of type `interval`, which represents a time interval to be processed. The function returns a value of type `interval`.\n\nInside the function, a local variable named `v_justified_interval` of type `interval` is declared. This variable will temporarily store the result of the `justify_days` operation.\n\nThe core operation of the function involves calling the built-in PostgreSQL function `justify_days` with the input parameter `p_days_interval`. The `justify_days` function adjusts the interval by converting days exceeding 30 into months. The result of this function call is assigned to the variable `v_justified_interval`.\n\nFollowing this assignment, the function uses a conditional `IF` statement to check if the value stored in `v_justified_interval` is `NULL`. If `v_justified_interval` is `NULL`, the function returns a literal interval of `'0 days'`. If `v_justified_interval` is not `NULL`, the function returns the value stored in the `v_justified_interval` variable.\n\nThe function does not perform any SQL operations (such as `SELECT`, `INSERT`, `UPDATE`, or `DELETE`) on the `Collections` or `Documents_in_Collections` tables. It solely processes the input interval parameter using a built-in function and returns the result based on a null-check condition."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_department_creation_year` that accepts a single input parameter, `p_department_id`, which is of type `integer`. This function is designed to retrieve the creation year of a specific department. Inside the function, a local variable named `v_creation_year` is declared, which is of type `text`. The function then executes a `SELECT` statement to query the `department` table. Specifically, it selects the value from the column named `\"Creation\"` and attempts to store this value into the `v_creation_year` variable. This selection is conditional, applying a `WHERE` clause that filters rows based on the `\"Department_ID\"` column. Only the row where the value in the `\"Department_ID\"` column exactly matches the value provided in the `p_department_id` input parameter will be considered. After successfully retrieving the `Creation` value into `v_creation_year`, the function returns the value stored in `v_creation_year` as its output, which is of type `text`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_creation_year(p_department_id integer) RETURNS text AS $$\nDECLARE\n    v_creation_year text;\nBEGIN\n    SELECT \"Creation\" INTO v_creation_year FROM \"department\" WHERE \"Department_ID\" = p_department_id;\n    RETURN v_creation_year;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT get_department_creation_year(1);",
      "SELECT get_department_creation_year(2);",
      "SELECT get_department_creation_year(3);",
      "SELECT get_department_creation_year(4);",
      "SELECT get_department_creation_year(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_department_creation_year` that accepts a department ID (integer) and returns the department's creation year (text) by selecting the \"Creation\" column from the department table where the \"Department_ID\" matches the input.",
    "natural_language": "Write a function called `get_department_creation_year` that, when given a department ID number, fetches and returns a text value for roughly when that department was set up. It should look in the department table for a matching ID and pull the date from the \"Creation\" field.",
    "id": 28,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_department_creation_year that accepts a single input parameter of type integer, which represents the department ID number. The function returns a single text value. The function is designed to retrieve the approximate year when a specific department was established, based on the provided department ID.\n\nThe function declares a local variable v_creation_year of type text, which will be used to store the result fetched from the database.\n\nThe core operation of the function is a SELECT INTO statement. This statement queries the department table, specifically selecting the Creation column. The WHERE clause filters the rows to only include the row where the Department_ID column exactly matches the input parameter value provided to the function. The result of this query is assigned directly to the local variable v_creation_year.\n\nAfter the SELECT INTO statement executes, the function returns the value stored in v_creation_year using a RETURN statement. This is a scalar-returning function, so it returns a single text value. If no row in the department table matches the provided department ID, the SELECT INTO statement will not assign a value to v_creation_year, leaving it as NULL, and the function will consequently return NULL. The function performs a read-only operation on the department table and does not modify any data."
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the total outstanding balance for all customers in the \"Customers\" table who have a customer_status_code equal to 'Good Customer'. The function is named get_total_outstanding_balance and does not take any input parameters. It returns a value of type double precision. Inside the function, a variable named total_balance of type double precision is declared to store the result of the calculation. The function executes a SELECT statement that computes the sum of the values in the amount_outstanding column from the public.\"Customers\" table, but only for rows where the customer_status_code column has the value 'Good Customer'. The result of this aggregation is assigned to the total_balance variable using the INTO clause. Finally, the function returns the value stored in total_balance.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_outstanding_balance()\nRETURNS double precision AS $$\nDECLARE\n    total_balance double precision;\nBEGIN\n    SELECT SUM(amount_outstanding)\n    INTO total_balance\n    FROM public.\"Customers\"\n    WHERE customer_status_code = 'Good Customer';\n    RETURN total_balance;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT get_total_outstanding_balance();",
      "SELECT * FROM get_total_outstanding_balance();",
      "SELECT get_total_outstanding_balance() AS total_good_customer_balance;",
      "DO $$\nDECLARE\n    total double precision;\nBEGIN\n    total := get_total_outstanding_balance();\n    RAISE NOTICE 'Total outstanding balance for good customers: %', total;\nEND $$;",
      "SELECT get_total_outstanding_balance()\nFROM (VALUES (1)) AS t;"
    ],
    "summary": "Create a PLpgSQL function named get_total_outstanding_balance with no parameters. It returns a double precision value representing the sum of the amount_outstanding column from the Customers table for all rows where customer_status_code is 'Good Customer'.",
    "natural_language": "Please construct a PL/pgSQL function designated as 'get_total_outstanding_balance'. This function shall accept no parameters and must yield a value of type double precision. The returned value should constitute the aggregate sum of the 'amount_outstanding' column, sourced from the 'Customers' table, specifically for those records where the 'customer_status_code' is equivalent to 'Good Customer'.",
    "id": 29,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_total_outstanding_balance that accepts no parameters and returns a single value of type double precision. The function operates on the driving_school database. The function begins by declaring a local variable, v_total_balance, of type double precision, to store the computed sum. The function executes a single SQL SELECT statement that calculates the sum of the amount_outstanding column from the Customers table. The SELECT statement includes a WHERE clause that filters the rows to only those where the customer_status_code column exactly matches the string 'Good Customer'. The result of this aggregation is assigned directly to the v_total_balance variable. The function concludes by returning the value stored in v_total_balance."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named \"consolidate_order_data\" that accepts one input parameter, `p_driver_threshold`, which is of type `BIGINT`. This function is designed to return a table with four columns: `order_id` of type `BIGINT`, `status` of type `TEXT`, `delivery_location` of type `TEXT`, and `driver_experience` of type `TEXT`. The function's core operation is to execute a `SELECT` query to retrieve and consolidate order-related data.\n\nThe `SELECT` statement performs a `LEFT JOIN` between two tables: `\"Actual_Orders\"` (aliased as `ao`) and `\"Order_Deliveries\"` (aliased as `od`). The join condition links rows from `\"Actual_Orders\"` to `\"Order_Deliveries\"` where the `actual_order_id` column in `\"Actual_Orders\"` matches the `actual_order_id` column in `\"Order_Deliveries\"`. This `LEFT JOIN` ensures that all orders from `\"Actual_Orders\"` are included in the result set, even if there is no corresponding entry in `\"Order_Deliveries\"`.\n\nThe `WHERE` clause filters the results to include only orders from `\"Actual_Orders\"` where the `actual_order_date` is more recent than 30 days prior to the current timestamp. This is achieved by comparing `ao.\"actual_order_date\"` with the result of `CURRENT_TIMESTAMP - INTERVAL '30 days'`.\n\nThe `SELECT` list specifies the columns to be returned:\n1.  `ao.\"actual_order_id\"`: This directly selects the `actual_order_id` from the `\"Actual_Orders\"` table and renames it to `order_id` in the output table.\n2.  `ao.\"order_status_code\"`: This directly selects the `order_status_code` from the `\"Actual_Orders\"` table and renames it to `status` in the output table.\n3.  `COALESCE(od.\"location_code\", 'Unknown')`: This expression selects the `location_code` from the `\"Order_Deliveries\"` table. If `od.\"location_code\"` is `NULL` (which can happen due to the `LEFT JOIN` if an order has no delivery record, or if the `location_code` itself is `NULL` in `\"Order_Deliveries\"`), it defaults to the string literal `'Unknown'`. This result is renamed to `delivery_location` in the output table.\n4.  A `CASE` statement determines the `driver_experience` based on the `driver_employee_id` from the `\"Order_Deliveries\"` table:\n    *   `WHEN od.\"driver_employee_id\" IS NULL THEN 'No Driver'`: If the `driver_employee_id` in `\"Order_Deliveries\"` is `NULL` (again, possibly due to the `LEFT JOIN` or an actual `NULL` value), the `driver_experience` is set to the string literal `'No Driver'`.\n    *   `WHEN od.\"driver_employee_id\" < p_driver_threshold THEN 'Junior Driver'`: If the `driver_employee_id` is not `NULL` and its value is less than the input parameter `p_driver_threshold`, the `driver_experience` is set to the string literal `'Junior Driver'`.\n    *   `WHEN od.\"driver_employee_id\" = p_driver_threshold THEN 'Mid Driver'`: If the `driver_employee_id` is not `NULL` and its value is equal to the input parameter `p_driver_threshold`, the `driver_experience` is set to the string literal `'Mid Driver'`.\n    *   `ELSE 'Senior Driver'`: For all other cases (i.e., if `driver_employee_id` is not `NULL` and is greater than `p_driver_threshold`), the `driver_experience` is set to the string literal `'Senior Driver'`.\n    This result is renamed to `driver_experience` in the output table.\n\nThe `RETURN QUERY` statement then returns the entire result set generated by this `SELECT` query as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION \"consolidate_order_data\"(p_driver_threshold BIGINT) RETURNS TABLE(order_id BIGINT, status TEXT, delivery_location TEXT, driver_experience TEXT) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT ao.\"actual_order_id\", \n           ao.\"order_status_code\",\n           COALESCE(od.\"location_code\", 'Unknown'),\n           CASE \n               WHEN od.\"driver_employee_id\" IS NULL THEN 'No Driver'\n               WHEN od.\"driver_employee_id\" < p_driver_threshold THEN 'Junior Driver'\n               WHEN od.\"driver_employee_id\" = p_driver_threshold THEN 'Mid Driver'\n               ELSE 'Senior Driver'\n           END\n    FROM \"Actual_Orders\" ao\n    LEFT JOIN \"Order_Deliveries\" od ON ao.\"actual_order_id\" = od.\"actual_order_id\"\n    WHERE ao.\"actual_order_date\" > CURRENT_TIMESTAMP - INTERVAL '30 days';\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Order_Deliveries"
    ],
    "call_sqls": [
      "SELECT * FROM consolidate_order_data(5);",
      "SELECT * FROM consolidate_order_data(10);",
      "SELECT * FROM consolidate_order_data(15);",
      "SELECT * FROM consolidate_order_data(20);",
      "SELECT * FROM consolidate_order_data(25);"
    ],
    "summary": "Create a PostgreSQL function named \"consolidate_order_data\" that returns a table with columns order_id (BIGINT), status (TEXT), delivery_location (TEXT), and driver_experience (TEXT). It accepts a BIGINT parameter p_driver_threshold. The function performs a LEFT JOIN between \"Actual_Orders\" and \"Order_Deliveries\" on actual_order_id, filters for orders from the last 30 days, and selects: the order ID, status code, location (defaulting to 'Unknown' if NULL), and a driver experience category ('No Driver', 'Junior', 'Mid', or 'Senior') based on comparing driver_employee_id to the threshold.",
    "natural_language": "How can I create a PostgreSQL function called \"consolidate_order_data\" that returns a table with order_id, status, delivery_location, and driver_experience columns? The function should take a BIGINT parameter p_driver_threshold, perform a LEFT JOIN between \"Actual_Orders\" and \"Order_Deliveries\" on actual_order_id, filter for orders from the last 30 days, and then select the order ID, status code, a location (defaulting to 'Unknown' if NULL), and a driver experience category ('No Driver', 'Junior', 'Mid', or 'Senior') based on comparing driver_employee_id to the provided threshold.",
    "id": 30,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named \"consolidate_order_data\" that accepts one input parameter, `p_driver_threshold`, which is of type `BIGINT`. This function is designed to return a table with four columns: `order_id` of type `BIGINT`, `status` of type `TEXT`, `delivery_location` of type `TEXT`, and `driver_experience` of type `TEXT`. The function's core operation is to execute a `SELECT` query to retrieve and consolidate order-related data.\n\nThe `SELECT` statement performs a `LEFT JOIN` between two tables: `\"Actual_Orders\"` (aliased as `ao`) and `\"Order_Deliveries\"` (aliased as `od`). The join condition links rows from `\"Actual_Orders\"` to `\"Order_Deliveries\"` where the `actual_order_id` column in `\"Actual_Orders\"` matches the `actual_order_id` column in `\"Order_Deliveries\"`. This `LEFT JOIN` ensures that all orders from `\"Actual_Orders\"` are included in the result set, even if there is no corresponding entry in `\"Order_Deliveries\"`.\n\nThe `WHERE` clause filters the results to include only orders from `\"Actual_Orders\"` where the `actual_order_date` is more recent than 30 days prior to the current timestamp. This is achieved by comparing `ao.\"actual_order_date\"` with the result of `CURRENT_TIMESTAMP - INTERVAL '30 days'`.\n\nThe `SELECT` list specifies the columns to be returned:\n1.  `ao.\"actual_order_id\"`: This directly selects the `actual_order_id` from the `\"Actual_Orders\"` table and renames it to `order_id` in the output table.\n2.  `ao.\"order_status_code\"`: This directly selects the `order_status_code` from the `\"Actual_Orders\"` table and renames it to `status` in the output table.\n3.  `COALESCE(od.\"location_code\", 'Unknown')`: This expression selects the `location_code` from the `\"Order_Deliveries\"` table. If `od.\"location_code\"` is `NULL` (which can happen due to the `LEFT JOIN` if an order has no delivery record, or if the `location_code` itself is `NULL` in `\"Order_Deliveries\"`), it defaults to the string literal `'Unknown'`. This result is renamed to `delivery_location` in the output table.\n4.  A `CASE` statement determines the `driver_experience` based on the `driver_employee_id` from the `\"Order_Deliveries\"` table:\n    *   `WHEN od.\"driver_employee_id\" IS NULL THEN 'No Driver'`: If the `driver_employee_id` in `\"Order_Deliveries\"` is `NULL` (again, possibly due to the `LEFT JOIN` or an actual `NULL` value), the `driver_experience` is set to the string literal `'No Driver'`.\n    *   `WHEN od.\"driver_employee_id\" < p_driver_threshold THEN 'Junior Driver'`: If the `driver_employee_id` is not `NULL` and its value is less than the input parameter `p_driver_threshold`, the `driver_experience` is set to the string literal `'Junior Driver'`.\n    *   `WHEN od.\"driver_employee_id\" = p_driver_threshold THEN 'Mid Driver'`: If the `driver_employee_id` is not `NULL` and its value is equal to the input parameter `p_driver_threshold`, the `driver_experience` is set to the string literal `'Mid Driver'`.\n    *   `ELSE 'Senior Driver'`: For all other cases (i.e., if `driver_employee_id` is not `NULL` and is greater than `p_driver_threshold`), the `driver_experience` is set to the string literal `'Senior Driver'`.\n    This result is renamed to `driver_experience` in the output table.\n\nThe `RETURN QUERY` statement then returns the entire result set generated by this `SELECT` query as the output of the function."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_grade of type integer, representing a specific grade level, and calculates the number of \"popular\" students in that grade based on specific criteria. The function begins by declaring a local variable popular_count of type integer, initialized to 0, which will store the count of popular students. It then performs a SELECT query to count the number of rows in the \"Highschooler\" table (aliased as h) joined with the \"Likes\" table (aliased as l) on the condition that the \"ID\" column of the \"Highschooler\" table matches the liked_id column of the \"Likes\" table. The query filters rows where the grade column in the \"Highschooler\" table matches the input parameter p_grade and where the student_id column in the \"Likes\" table is not equal to the liked_id column, ensuring that students are not liking themselves. The result of this query is stored in the popular_count variable. The function then evaluates the value of popular_count using conditional logic: if popular_count is greater than 10, the function returns the value of popular_count; if popular_count is greater than 5 but less than or equal to 10, the function returns half of popular_count (using integer division); otherwise, if popular_count is 5 or less, the function returns 0. The function is written in the PLpgSQL language and is designed to return an integer value.",
    "plsql": "CREATE OR REPLACE FUNCTION find_popular_students(p_grade integer)\nRETURNS integer AS $$\nDECLARE\n    popular_count integer := 0;\nBEGIN\n    SELECT COUNT(*) INTO popular_count FROM \"Highschooler\" h\n    JOIN \"Likes\" l ON h.\"ID\" = l.liked_id\n    WHERE h.grade = p_grade AND l.student_id <> l.liked_id;\n\n    IF popular_count > 10 THEN\n        RETURN popular_count;\n    ELSIF popular_count > 5 THEN\n        RETURN popular_count / 2;\n    ELSE\n        RETURN 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT find_popular_students(9);",
      "SELECT find_popular_students(10);",
      "SELECT find_popular_students(11);",
      "SELECT find_popular_students(12);",
      "SELECT find_popular_students(8);"
    ],
    "summary": "Create a PLpgSQL function that takes a grade level and returns an integer count of popular students in that grade. A popular student is defined as a Highschooler in that grade who is liked by someone other than themselves in the Likes table. If the count is greater than 10, return the count. If between 6 and 10, return half the count. Otherwise, return 0.",
    "natural_language": "Write a PLpgSQL function that, for a given grade level, figures out roughly how many students are considered popular there. We're talking about Highschoolers in that grade who are liked by at least one other person (not themselves) according to the Likes data. If that number seems pretty highâ€”say, more than 10â€”just give back the total. If it's a moderate amount, somewhere around 6 to 10, then return about half of it. Otherwise, if it's just a few or none, return 0.",
    "id": 31,
    "generated_ir": "Write a PLpgSQL function that takes a single input parameter p_grade of type integer, representing a specific grade level, and calculates the number of \"popular\" students in that grade based on specific criteria. The function begins by declaring a local variable popular_count of type integer, initialized to 0, which will store the count of popular students. It then performs a SELECT query to count the number of rows in the \"Highschooler\" table (aliased as h) joined with the \"Likes\" table (aliased as l) on the condition that the \"ID\" column of the \"Highschooler\" table matches the liked_id column of the \"Likes\" table. The query filters rows where the grade column in the \"Highschooler\" table matches the input parameter p_grade and where the student_id column in the \"Likes\" table is not equal to the liked_id column, ensuring that students are not liking themselves. The result of this query is stored in the popular_count variable. The function then evaluates the value of popular_count using conditional logic: if popular_count is greater than 10, the function returns the value of popular_count; if popular_count is greater than 5 but less than or equal to 10, the function returns half of popular_count (using integer division); otherwise, if popular_count is 5 or less, the function returns 0. The function is written in the PLpgSQL language and is designed to return an integer value."
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, gymnast_id of type integer and event_name of type text, and returns a real value representing the total points scored by a gymnast in a specific gymnastics event. The function begins by declaring a local variable total_points of type real to store the result. It then evaluates the value of the event_name parameter using a series of conditional statements (IF, ELSIF). If the event_name is 'Floor_Exercise', the function executes a SELECT statement to calculate the sum of the \"Floor_Exercise_Points\" column from the gymnast table for rows where the \"Gymnast_ID\" column matches the gymnast_id parameter, and assigns the result to the total_points variable. If the event_name is 'Pommel_Horse', it performs a similar operation, summing the \"Pommel_Horse_Points\" column for the specified gymnast_id. This pattern is repeated for the events 'Rings', 'Vault', 'Parallel_Bars', and 'Horizontal_Bar', where the function sums the respective columns \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", and \"Horizontal_Bar_Points\" from the gymnast table for the given gymnast_id. If the event_name does not match any of these predefined values, the function assigns NULL to the total_points variable. Finally, the function returns the value of total_points.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_event_total_points(gymnast_id integer, event_name text)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_points real;\nBEGIN\n    IF event_name = 'Floor_Exercise' THEN\n        SELECT SUM(\"Floor_Exercise_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Pommel_Horse' THEN\n        SELECT SUM(\"Pommel_Horse_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Rings' THEN\n        SELECT SUM(\"Rings_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Vault' THEN\n        SELECT SUM(\"Vault_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Parallel_Bars' THEN\n        SELECT SUM(\"Parallel_Bars_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Horizontal_Bar' THEN\n        SELECT SUM(\"Horizontal_Bar_Points\") INTO total_points FROM gymnast WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSE\n        total_points := NULL;\n    END IF;\n    RETURN total_points;\nEND;\n$$;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT get_gymnast_event_total_points(1, 'Floor_Exercise');",
      "SELECT get_gymnast_event_total_points(2, 'Pommel_Horse');",
      "SELECT get_gymnast_event_total_points(4, 'Rings');",
      "SELECT get_gymnast_event_total_points(1, 'Vault');",
      "SELECT get_gymnast_event_total_points(2, 'Horizontal_Bar');"
    ],
    "summary": "Create a PLpgSQL function that takes a gymnast_id (integer) and an event_name (text) and returns a real value. The function calculates the total points for the specified gymnast by summing the column in the gymnast table that corresponds to the event_name (e.g., 'Floor_Exercise' sums the \"Floor_Exercise_Points\" column). If the event_name is not recognized, return NULL.",
    "natural_language": "How can I create a PLpgSQL function that, given a gymnast's ID and an event name, calculates and returns their total points for that event by summing the corresponding column in the gymnast table, and returns NULL if the event name is not recognized?",
    "id": 32,
    "generated_ir": "Write a PLpgSQL function that takes two parameters, gymnast_id of type integer and event_name of type text, and returns a real value representing the total points scored by a gymnast in a specific gymnastics event. The function begins by declaring a local variable total_points of type real to store the result. It then evaluates the value of the event_name parameter using a series of conditional statements (IF, ELSIF). If the event_name is 'Floor_Exercise', the function executes a SELECT statement to calculate the sum of the \"Floor_Exercise_Points\" column from the gymnast table for rows where the \"Gymnast_ID\" column matches the gymnast_id parameter, and assigns the result to the total_points variable. If the event_name is 'Pommel_Horse', it performs a similar operation, summing the \"Pommel_Horse_Points\" column for the specified gymnast_id. This pattern is repeated for the events 'Rings', 'Vault', 'Parallel_Bars', and 'Horizontal_Bar', where the function sums the respective columns \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", and \"Horizontal_Bar_Points\" from the gymnast table for the given gymnast_id. If the event_name does not match any of these predefined values, the function assigns NULL to the total_points variable. Finally, the function returns the value of total_points."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_hotel_rating_category` that accepts a single input parameter. This parameter, named `p_star_code`, is of data type `text` and is intended to represent a star rating code for a hotel. The function is designed to return a `text` value, which will be a descriptive category corresponding to the provided star code. The core logic of the function involves a `CASE` statement that evaluates the value of `p_star_code`. If `p_star_code` is exactly equal to the string literal `'1'`, the function will return the string literal `'Basic'`. If `p_star_code` is exactly equal to the string literal `'2'`, the function will return the string literal `'Standard'`. If `p_star_code` is exactly equal to the string literal `'3'`, the function will return the string literal `'Superior'`. For any other value of `p_star_code` that does not match `'1'`, `'2'`, or `'3'`, the function will default to returning the string literal `'Premium'`. The function does not interact with any database tables, perform any data manipulation language (DML) operations such as `INSERT`, `UPDATE`, or `DELETE`, nor does it execute any `SELECT` statements against tables. It solely performs a conditional evaluation of its input parameter to determine an appropriate output string.",
    "plsql": "CREATE OR REPLACE FUNCTION get_hotel_rating_category(p_star_code text)\nRETURNS text AS $$\nBEGIN\n    RETURN CASE \n        WHEN p_star_code = '1' THEN 'Basic'\n        WHEN p_star_code = '2' THEN 'Standard'\n        WHEN p_star_code = '3' THEN 'Superior'\n        ELSE 'Premium'\n    END;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "cre_Theme_park",
    "tables": [
      "Hotels",
      "Ref_Hotel_Star_Ratings",
      "Features",
      "Tourist_Attraction_Features",
      "Ref_Attraction_Types"
    ],
    "call_sqls": [
      "SELECT get_hotel_rating_category('1');",
      "SELECT get_hotel_rating_category('2');",
      "SELECT get_hotel_rating_category('3');",
      "SELECT get_hotel_rating_category('4');",
      "SELECT get_hotel_rating_category('5');"
    ],
    "summary": "Create a function named get_hotel_rating_category that takes a text parameter p_star_code and returns a text value. Use a CASE statement to return 'Basic' for '1', 'Standard' for '2', 'Superior' for '3', and 'Premium' for any other input.",
    "natural_language": "Develop a function called get_hotel_rating_category, which is designed to accept a single text parameter named p_star_code and subsequently provides a text value as its output. Within this function, implement a comprehensive CASE statement that meticulously evaluates the input: specifically, it should return the descriptive label 'Basic' when the code is precisely '1', it should return 'Standard' for the exact code '2', it should yield 'Superior' if the code is '3', and finally, for any other conceivable input value, it must categorically return the designation 'Premium'.",
    "id": 33,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_hotel_rating_category that accepts a single input parameter p_star_code of type text and returns a text value. The function implements a CASE statement that evaluates the value of the p_star_code parameter. The CASE statement has four branches: when the p_star_code is exactly equal to the string '1', the function returns the text string 'Basic'; when the p_star_code is exactly equal to the string '2', the function returns the text string 'Standard'; when the p_star_code is exactly equal to the string '3', the function returns the text string 'Superior'; and for any other value of p_star_code (including NULL, or any string not matching '1', '2', or '3'), the function returns the text string 'Premium'. The function does not query any database tables; it performs only this conditional logic based on the input parameter."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_lastname of type text, retrieves the \"FirstName\" and \"Classroom\" values from the \"list\" table for the row where the \"LastName\" column matches the value of p_lastname, and returns a concatenated string consisting of the retrieved \"FirstName\" value, followed by the string ' - Room ', and then the retrieved \"Classroom\" value. The function begins by declaring two local variables, v_firstname of type text and v_classroom of type bigint, to store the retrieved values. It then assigns to v_firstname the result of a SELECT query that retrieves the \"FirstName\" column from the \"list\" table where the \"LastName\" column equals the input parameter p_lastname. Similarly, it assigns to v_classroom the result of a SELECT query that retrieves the \"Classroom\" column from the \"list\" table where the \"LastName\" column equals the input parameter p_lastname. Finally, the function concatenates the values of v_firstname, the string ' - Room ', and v_classroom, and returns the resulting string.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_info(p_lastname text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_firstname text;\n    v_classroom bigint;\nBEGIN\n    v_firstname := (SELECT \"FirstName\" FROM list WHERE \"LastName\" = p_lastname);\n    v_classroom := (SELECT \"Classroom\" FROM list WHERE \"LastName\" = p_lastname);\n    RETURN v_firstname || ' - Room ' || v_classroom;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT get_student_info('CAR');",
      "SELECT get_student_info('KRISTENSEN');",
      "SELECT get_student_info('VANDERWOUDE');",
      "SELECT get_student_info('MACROSTIE');",
      "SELECT get_student_info('MOYER');"
    ],
    "summary": "Create a PL/pgSQL function that takes a `text` parameter `p_lastname`. It retrieves the `\"FirstName\"` and `\"Classroom\"` from the `list` table where `\"LastName\"` matches the parameter. The function returns a concatenated string in the format: `FirstName - Room Classroom`.",
    "natural_language": "How can I create a PL/pgSQL function that, given a last name as a text parameter, fetches the first name and classroom from the list table for matching records and returns them formatted as 'FirstName - Room Classroom'?",
    "id": 34,
    "generated_ir": "Write a PLpgSQL function named get_student_info that takes a single input parameter of type text, which represents a student's last name, and returns a set of text values. The function queries the list table to retrieve the FirstName and Classroom columns for all rows where the LastName column matches the provided parameter value exactly. For each matching row, the function constructs a formatted string by concatenating the FirstName value, the literal string ' - Room ', and the Classroom value, converting the Classroom from bigint to text implicitly during concatenation. The function then returns this set of formatted strings as the output."
  },
  {
    "ir": "Write a PLpgSQL function that takes an integer parameter p_school_id and returns an integer. The function is designed to calculate the number of records in the school_performance table where the School_Id column matches the provided p_school_id parameter. It begins by declaring a local variable v_performance_count of type integer to store the result of the count operation. The function then executes a SELECT statement that counts all rows in the school_performance table where the School_Id column is equal to the value of p_school_id. The result of this count is stored in the v_performance_count variable. Finally, the function returns the value of v_performance_count, which represents the total number of matching records found in the school_performance table for the specified school identifier.",
    "plsql": "CREATE OR REPLACE FUNCTION get_school_performance_count(p_school_id integer)\nRETURNS integer\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_performance_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_performance_count\n    FROM school_performance\n    WHERE \"School_Id\" = p_school_id;\n\n    RETURN v_performance_count;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT get_school_performance_count(1);",
      "SELECT get_school_performance_count(2);",
      "SELECT get_school_performance_count(3);",
      "SELECT get_school_performance_count(10);",
      "SELECT get_school_performance_count(99);"
    ],
    "summary": "Create a PLpgSQL function that takes an integer parameter p_school_id and returns an integer. The function should count and return the number of records in the school_performance table where the 'School_Id' column equals the input parameter.",
    "natural_language": "Please construct a PL/pgSQL function that accepts an integer parameter designated as p_school_id and yields an integer as its return value. The function's purpose is to compute and provide the count of records within the school_performance table for which the value in the 'School_Id' column is equivalent to the supplied input parameter.",
    "id": 35,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_school_performance_count that accepts a single input parameter p_school_id of type INTEGER, which is used to identify a specific school, and returns a value of type INTEGER; this function first declares a local INTEGER variable, typically named v_count, to store the result of the count operation; it then performs a SELECT operation on the school_performance table to calculate the count of all rows where the School_Id column value is exactly equal to the provided p_school_id parameter, storing the result into the v_count variable; finally, the function returns the value stored in v_count as its output."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_ship_type_by_speed` that accepts a single input parameter named `\"Speed_knots\"`, which is of the `integer` data type. This function is designed to determine and return a textual description of a ship's type based on its speed. The function's logic involves a conditional evaluation: it first checks if the value provided for the `\"Speed_knots\"` parameter is strictly greater than the integer literal `24`. If this condition evaluates to `TRUE`, the function immediately returns the string literal `'Fast Ship'` as its output, which is of the `text` data type. If the initial condition (`\"Speed_knots\" > 24`) evaluates to `FALSE` (meaning `\"Speed_knots\"` is less than or equal to `24`), the function then proceeds to the `ELSE` block and returns the string literal `'Standard Ship'` as its output, also of the `text` data type. The function does not interact with any database tables, perform any data manipulation operations (inserts, updates, deletes), or call any other functions.",
    "plsql": "CREATE OR REPLACE FUNCTION get_ship_type_by_speed(\"Speed_knots\" integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    IF \"Speed_knots\" > 24 THEN\n        RETURN 'Fast Ship';\n    ELSE\n        RETURN 'Standard Ship';\n    END IF;\nEND;\n$$;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT get_ship_type_by_speed(25);",
      "SELECT get_ship_type_by_speed(23);",
      "SELECT get_ship_type_by_speed(24);",
      "SELECT get_ship_type_by_speed(30);",
      "SELECT get_ship_type_by_speed(20);"
    ],
    "summary": "Create a PL/pgSQL function named `get_ship_type_by_speed` that takes an integer parameter `Speed_knots` and returns a text value. Return 'Fast Ship' if the speed is greater than 24, otherwise return 'Standard Ship'.",
    "natural_language": "What PL/pgSQL function, named `get_ship_type_by_speed`, should be created to take an integer parameter `Speed_knots` and return a text value of 'Fast Ship' if the speed is greater than 24, otherwise returning 'Standard Ship'?",
    "id": 36,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_ship_type_by_speed` that accepts a single input parameter named `\"Speed_knots\"`, which is of the `integer` data type. This function is designed to determine and return a textual description of a ship's type based on its speed. The function's logic involves a conditional evaluation: it first checks if the value provided for the `\"Speed_knots\"` parameter is strictly greater than the integer literal `24`. If this condition evaluates to `TRUE`, the function immediately returns the string literal `'Fast Ship'` as its output, which is of the `text` data type. If the initial condition (`\"Speed_knots\" > 24`) evaluates to `FALSE` (meaning `\"Speed_knots\"` is less than or equal to `24`), the function then proceeds to the `ELSE` block and returns the string literal `'Standard Ship'` as its output, also of the `text` data type. The function does not interact with any database tables, perform any data manipulation operations (inserts, updates, deletes), or call any other functions."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_oldest_person_in_church` that accepts a single input parameter, `p_church_id`, which is of type `integer` and represents the unique identifier of a church. This function is designed to return a value of type `text`, which will be the name of the oldest person associated with the specified church.\n\nUpon execution, the function declares a local variable named `v_oldest_person` of type `text` to temporarily store the name of the identified oldest person. The core operation involves a `SELECT` statement that retrieves data from the `people` table, aliased as `p`. This `SELECT` statement is joined with the `wedding` table, aliased as `w`, using an `ON` clause. The join condition specifies that a record from the `people` table is linked to a record from the `wedding` table if the `People_ID` column from the `people` table (`p.\"People_ID\"`) matches either the `Male_ID` column (`w.\"Male_ID\"`) or the `Female_ID` column (`w.\"Female_ID\"`) in the `wedding` table. This effectively links individuals to their wedding records.\n\nFollowing the join, a `WHERE` clause filters the results to include only those records where the `Church_ID` column from the `wedding` table (`w.\"Church_ID\"`) is equal to the input parameter `p_church_id`. This ensures that only people associated with the specified church are considered.\n\nThe filtered results are then ordered in descending order based on the `Age` column from the `people` table (`p.\"Age\"`), meaning the oldest individuals will appear first. Finally, the `LIMIT 1` clause restricts the output to only the single top record after sorting, which corresponds to the oldest person.\n\nThe `Name` column from this single oldest person's record (`p.\"Name\"`) is then assigned to the `v_oldest_person` variable. After this assignment, the function returns the value stored in `v_oldest_person`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_person_in_church(p_church_id integer)\nRETURNS text AS $$\nDECLARE\n    v_oldest_person text;\nBEGIN\n    SELECT p.\"Name\" INTO v_oldest_person\n    FROM people p\n    JOIN wedding w ON p.\"People_ID\" IN (w.\"Male_ID\", w.\"Female_ID\")\n    WHERE w.\"Church_ID\" = p_church_id\n    ORDER BY p.\"Age\" DESC\n    LIMIT 1;\n    \n    RETURN v_oldest_person;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT get_oldest_person_in_church(1);",
      "SELECT get_oldest_person_in_church(3);",
      "SELECT get_oldest_person_in_church(5);",
      "SELECT get_oldest_person_in_church(2);",
      "SELECT get_oldest_person_in_church(4);"
    ],
    "summary": "Create a PL/pgSQL function named `get_oldest_person_in_church` that takes a church ID as an integer input and returns the name (as text) of the oldest person associated with that church by joining the people and wedding tables.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_oldest_person_in_church`. This function should accept a church identifier as an integer parameter. Its purpose is to retrieve and return, as a text value, the name of the most senior individual affiliated with the specified church. This determination is to be made by performing a join operation between the `people` and `wedding` tables.",
    "id": 37,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_oldest_person_in_church that accepts one input parameter, a church identifier, of type integer. The function returns a single text value, which is the name of the oldest person associated with the specified church. The function's logic involves querying the database to find the person with the maximum age among those linked to the given church through wedding records.\n\nThe function begins by declaring a local text variable, oldest_person_name, to store the result. It then executes a SELECT query that retrieves the name from the people table. This is done by joining the people table with the wedding table. The join condition is that the People_ID from the people table must match either the Male_ID or the Female_ID in the wedding table, ensuring all individuals (both male and female) who were married in a wedding are considered. The query includes a WHERE clause to filter the wedding records, selecting only those rows where the Church_ID column in the wedding table equals the input church identifier parameter.\n\nFrom this filtered and joined dataset, the function selects the person with the highest age. It uses the ORDER BY clause on the Age column from the people table in descending order (DESC) and limits the result to the first row using the LIMIT 1 clause. The selected name is then stored into the oldest_person_name variable using the INTO clause. Finally, the function returns the value stored in the oldest_person_name variable. If no matching records are found for the given church identifier, the variable will be null, and the function will return null."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `categorize_protein_divergence` that accepts a single input parameter named `prot_name` of data type `text`. This function is designed to return a `text` value representing a categorical description of a protein's evolutionary divergence. Inside the function, a local variable named `v_divergence` of data type `real` is declared to temporarily store a numerical divergence value. The function then executes a `SELECT` statement to retrieve the `divergence_from_human_lineage` column's value from the `protein` table. This retrieval is conditional, specifically targeting the row where the `protein_name` column in the `protein` table exactly matches the value provided by the input parameter `prot_name`. The retrieved `divergence_from_human_lineage` value is then assigned to the `v_divergence` variable. Following this data retrieval, a series of conditional checks are performed on the `v_divergence` value. If `v_divergence` is strictly greater than `700`, the function immediately returns the text string `'Very Distant'`. Otherwise, if the first condition is false, it checks if `v_divergence` is strictly greater than `500`. If this second condition is true, the function returns the text string `'Distant'`. If both previous conditions are false, it proceeds to check if `v_divergence` is strictly greater than `300`. If this third condition is true, the function returns the text string `'Moderate'`. Finally, if none of the preceding conditions are met (meaning `v_divergence` is less than or equal to `300`), the function returns the text string `'Close'`.",
    "plsql": "CREATE OR REPLACE FUNCTION categorize_protein_divergence(prot_name text)\nRETURNS text AS $$\nDECLARE\n    v_divergence real;\nBEGIN\n    SELECT divergence_from_human_lineage INTO v_divergence FROM protein WHERE protein.protein_name = prot_name;\n    IF v_divergence > 700 THEN\n        RETURN 'Very Distant';\n    ELSIF v_divergence > 500 THEN\n        RETURN 'Distant';\n    ELSIF v_divergence > 300 THEN\n        RETURN 'Moderate';\n    ELSE\n        RETURN 'Close';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "SELECT categorize_protein_divergence('uncharacterized protein C20orf...');",
      "SELECT categorize_protein_divergence('uncharacterized protein LOC578...');",
      "SELECT categorize_protein_divergence('Centromeric protein E, putativ...');",
      "SELECT categorize_protein_divergence('protein_name_example_1');",
      "SELECT categorize_protein_divergence('protein_name_example_2');"
    ],
    "summary": "Create a PLpgSQL function named categorize_protein_divergence that takes a protein_name (text) and returns a text category. The function retrieves the protein's divergence_from_human_lineage value and categorizes it as 'Very Distant' (>700), 'Distant' (>500), 'Moderate' (>300), or 'Close' (<=300).",
    "natural_language": "Develop a PLpgSQL function, to be named categorize_protein_divergence, which accepts a single input parameter of type text representing a protein name and yields a text-based classification. This function should first query and obtain the specific value for divergence_from_human_lineage associated with the given protein. It must then perform a detailed categorization, meticulously assigning one of four descriptive labels based on the retrieved numerical value: if the divergence exceeds 700, it is deemed 'Very Distant'; if it is greater than 500 but up to 700, it is classified as 'Distant'; for values surpassing 300 up to 500, the category is 'Moderate'; and finally, for any value that is less than or equal to 300, it is considered 'Close'.",
    "id": 38,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `categorize_protein_divergence` that accepts a single input parameter named `prot_name` of data type `text`. This function is designed to return a `text` value representing a categorical description of a protein's evolutionary divergence. Inside the function, a local variable named `v_divergence` of data type `real` is declared to temporarily store a numerical divergence value. The function then executes a `SELECT` statement to retrieve the `divergence_from_human_lineage` column's value from the `protein` table. This retrieval is conditional, specifically targeting the row where the `protein_name` column in the `protein` table exactly matches the value provided by the input parameter `prot_name`. The retrieved `divergence_from_human_lineage` value is then assigned to the `v_divergence` variable. Following this data retrieval, a series of conditional checks are performed on the `v_divergence` value. If `v_divergence` is strictly greater than `700`, the function immediately returns the text string `'Very Distant'`. Otherwise, if the first condition is false, it checks if `v_divergence` is strictly greater than `500`. If this second condition is true, the function returns the text string `'Distant'`. If both previous conditions are false, it proceeds to check if `v_divergence` is strictly greater than `300`. If this third condition is true, the function returns the text string `'Moderate'`. Finally, if none of the preceding conditions are met (meaning `v_divergence` is less than or equal to `300`), the function returns the text string `'Close'`."
  },
  {
    "ir": "Write a PLpgSQL function named get_architect_structures that accepts two input parameters: an integer parameter named arch_id representing the unique identifier of an architect, and a text parameter named structure_type specifying the category of structure to count. The function returns a single integer value. The function declares a local integer variable named structure_count to hold the result of the count operation. The function's logic begins with a conditional IF statement that checks if the provided structure_type parameter is exactly equal to the string literal 'bridge'. If this condition evaluates to true, the function executes a SELECT statement that performs a COUNT(*) aggregation on the bridge table, counting all rows where the architect_id column value matches the input arch_id parameter, and stores the resulting count into the structure_count variable. If the condition in the IF statement evaluates to false, meaning the structure_type is not 'bridge', the function executes an alternative SELECT statement that performs a COUNT(*) aggregation on the mill table, counting all rows where the architect_id column value matches the input arch_id parameter, and stores this count into the structure_count variable. After the conditional block, the function returns the value stored in the structure_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_architect_structures(arch_id INTEGER, structure_type TEXT)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    structure_count INTEGER;\nBEGIN\n    IF structure_type = 'bridge' THEN\n        SELECT COUNT(*) INTO structure_count FROM bridge WHERE architect_id = arch_id;\n    ELSE\n        SELECT COUNT(*) INTO structure_count FROM mill WHERE architect_id = arch_id;\n    END IF;\n    \n    RETURN structure_count;\nEND;\n$$;",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "SELECT get_architect_structures(1, 'bridge');",
      "SELECT get_architect_structures(2, 'mill');",
      "SELECT get_architect_structures(3, 'bridge');",
      "SELECT get_architect_structures(1, 'mill');",
      "SELECT get_architect_structures(2, 'bridge');"
    ],
    "summary": "Create a PL/pgSQL function named get_architect_structures that takes an architect ID (integer) and a structure type (text). It returns an integer count. If the structure type is 'bridge', count the architect's bridges. Otherwise, count the architect's mills.",
    "natural_language": "Please construct a PL/pgSQL function designated as 'get_architect_structures'. This function shall accept two parameters: an architect identifier of integer type and a structure type of text type. The function is to return an integer value representing a count. The logic is as follows: if the provided structure type is precisely 'bridge', the function must return the count of bridges associated with the specified architect. For any other structure type input, the function must return the count of mills associated with the architect.",
    "id": 39,
    "generated_ir": "Write a PLpgSQL function named get_architect_structures that takes two input parameters: an integer parameter for the architect identifier and a text parameter for the structure type. The function returns an integer value representing a count. The function begins by declaring a local variable named result_count of type integer, which will be used to store the computed count. The function then checks the value of the structure type parameter using an IF statement. If the structure type parameter is exactly equal to the string 'bridge', the function executes a SELECT statement to count the number of rows in the bridge table where the architect_id column matches the provided architect identifier parameter. This count is stored into the result_count variable using the INTO clause. Otherwise, for any other value of the structure type parameter, the function executes a SELECT statement to count the number of rows in the mill table where the architect_id column matches the provided architect identifier parameter, and stores this count into the result_count variable. After the conditional logic, the function returns the value of result_count."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_reputation_ratio` that accepts two integer input parameters: `min_reputation` and `max_reputation`. This function is designed to return a set of records, effectively acting as a table, with three columns: `\"University_ID\"` of type integer, `\"Reputation_point\"` of type integer, and `\"Ratio\"` of type numeric. The core operation of this function is to perform a `SELECT` query on the table named `\"overall_ranking\"`. The `SELECT` statement retrieves the `\"University_ID\"` column and the `\"Reputation_point\"` column directly from the `\"overall_ranking\"` table. Additionally, it calculates a new column named `\"Ratio\"`. The calculation for `\"Ratio\"` involves casting the value of the `\"Reputation_point\"` column from the `\"overall_ranking\"` table to a numeric type, then dividing this numeric value by the square root of the value of the `\"Total\"` column from the `\"overall_ranking\"` table, which is also cast to a numeric type before the square root operation. The rows included in the result set are filtered by a `WHERE` clause, which specifies that only those rows from the `\"overall_ranking\"` table where the value of the `\"Reputation_point\"` column is inclusively between the `min_reputation` parameter and the `max_reputation` parameter will be returned. The `RETURN QUERY` statement is used to return the results of this `SELECT` query directly as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_reputation_ratio(min_reputation integer, max_reputation integer)\nRETURNS TABLE(\"University_ID\" integer, \"Reputation_point\" integer, \"Ratio\" numeric) AS $$\nBEGIN\n    RETURN QUERY SELECT overall_ranking.\"University_ID\", overall_ranking.\"Reputation_point\", \n    (overall_ranking.\"Reputation_point\"::numeric / sqrt(overall_ranking.\"Total\"::numeric)) AS \"Ratio\"\n    FROM \"overall_ranking\"\n    WHERE overall_ranking.\"Reputation_point\" BETWEEN min_reputation AND max_reputation;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_reputation_ratio(1, 10);",
      "SELECT * FROM calculate_reputation_ratio(3, 7);",
      "SELECT * FROM calculate_reputation_ratio(0, 5);",
      "SELECT * FROM calculate_reputation_ratio(4, 15);",
      "SELECT * FROM calculate_reputation_ratio(2, 8);"
    ],
    "summary": "Create a PLpgSQL function named calculate_reputation_ratio that returns a table (University_ID integer, Reputation_point integer, Ratio numeric). It takes min_reputation and max_reputation integer parameters. The function selects from the overall_ranking table where Reputation_point is between the parameters, calculating Ratio as Reputation_point / SQRT(Total).",
    "natural_language": "What is the PLpgSQL function definition for calculate_reputation_ratio that returns a table with University_ID, Reputation_point, and Ratio, and takes min_reputation and max_reputation as parameters to select from overall_ranking where Reputation_point falls between them, calculating the Ratio as Reputation_point divided by the square root of Total?",
    "id": 40,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_reputation_ratio that returns a table with three columns: University_ID of type integer, Reputation_point of type integer, and Ratio of type numeric. The function accepts two input parameters: min_reputation of type integer and max_reputation of type integer, which define the inclusive range for filtering reputation points. The function operates on the overall_ranking table within the university_rank database. The function begins by executing a SELECT query that retrieves the University_ID and Reputation_point columns directly from the overall_ranking table, and calculates a derived column Ratio. The Ratio is computed for each row by dividing the Reputation_point value by the square root of the Total column value from the same row, using the SQL sqrt() function. The WHERE clause of this SELECT query filters the rows to include only those where the Reputation_point column value is greater than or equal to the min_reputation parameter and less than or equal to the max_reputation parameter. The result set of this query, comprising the three columns, is returned as the output table of the function. The function uses the RETURN QUERY statement to directly return the query results. No local variables are declared, and no additional control flow or data manipulation is performed beyond the described SELECT operation."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_staff_performance_rank that accepts a single input parameter p_staff_id of type bigint, representing the unique identifier of a staff member, and returns a bigint value representing a performance rank. The function begins by declaring three local variables: v_closed_count as integer, v_avg_resolution_days as numeric, and v_rank as bigint. It then executes a SELECT statement on the \"Complaints\" table to compute two metrics for the specified staff member. The SELECT statement filters rows where the staff_id column equals the input parameter p_staff_id. For the filtered rows, it calculates the count of complaints where the complaint_status_code column is exactly 'Closed' using a CASE expression that yields 1 for 'Closed' status and NULL otherwise, storing this count into v_closed_count. Simultaneously, it calculates the average resolution time for closed complaints by using another CASE expression that, only when complaint_status_code is 'Closed', computes the difference in days between the date_complaint_closed column and the date_complaint_raised column using the EXTRACT(days FROM ...) function, storing this average into v_avg_resolution_days. Following the data retrieval, the function uses a conditional IF-ELSIF-ELSE block to assign a performance rank based on the computed metrics. If v_closed_count is greater than 20 and v_avg_resolution_days is less than 5, the v_rank is set to 1. Otherwise, if v_closed_count is greater than 10 and v_avg_resolution_days is less than 10, v_rank is set to 2. Otherwise, if v_closed_count is greater than 5 and v_avg_resolution_days is less than 15, v_rank is set to 3. If none of these conditions are met, v_rank is set to 4. Finally, the function returns the value of v_rank.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_performance_rank(p_staff_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_closed_count integer;\n    v_avg_resolution_days numeric;\n    v_rank bigint;\nBEGIN\n    SELECT COUNT(CASE WHEN complaint_status_code = 'Closed' THEN 1 END),\n           AVG(CASE WHEN complaint_status_code = 'Closed' THEN EXTRACT(days FROM date_complaint_closed - date_complaint_raised) END)\n    INTO v_closed_count, v_avg_resolution_days\n    FROM \"Complaints\"\n    WHERE staff_id = p_staff_id;\n    \n    IF v_closed_count > 20 AND v_avg_resolution_days < 5 THEN\n        v_rank := 1;\n    ELSIF v_closed_count > 10 AND v_avg_resolution_days < 10 THEN\n        v_rank := 2;\n    ELSIF v_closed_count > 5 AND v_avg_resolution_days < 15 THEN\n        v_rank := 3;\n    ELSE\n        v_rank := 4;\n    END IF;\n    \n    RETURN v_rank;\nEND;\n$$;",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "SELECT get_staff_performance_rank(114);",
      "SELECT get_staff_performance_rank(120);",
      "SELECT get_staff_performance_rank(115);",
      "SELECT get_staff_performance_rank(116);",
      "SELECT get_staff_performance_rank(117);"
    ],
    "summary": "Create a function named get_staff_performance_rank that takes a staff_id (bigint) and returns a performance rank (bigint). It calculates the number of closed complaints and the average resolution days for the staff member. Rank is 1 if >20 closed and avg <5 days, 2 if >10 closed and avg <10 days, 3 if >5 closed and avg <15 days, otherwise 4.",
    "natural_language": "What is the performance rank for a staff member with a given ID, based on the number of complaints they have closed and their average resolution time?",
    "id": 41,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_staff_performance_rank that accepts a single input parameter, p_staff_id of type bigint, representing the identifier of a staff member. The function returns a text value representing the performance rank of the staff member. Within the function, declare three variables: closed_complaints_count of type integer, avg_resolution_days of type numeric, and performance_rank of type text.\n\nFirst, execute a SELECT statement to calculate the number of complaints closed by the staff member. This query counts the rows from the Complaints table where the staff_id matches the provided p_staff_id and the complaint_status_code is 'Closed'. The result is stored in the closed_complaints_count variable.\n\nSecond, execute another SELECT statement to calculate the average resolution time in days for the closed complaints handled by the staff member. This query computes the average difference in days between the date_complaint_closed and date_complaint_raised for rows in the Complaints table where the staff_id matches p_staff_id and the complaint_status_code is 'Closed'. The EXTRACT(EPOCH FROM ...) function is used to get the difference in seconds, which is then divided by 86400 to convert to days. The result is stored in the avg_resolution_days variable.\n\nThen, evaluate a conditional statement to determine the performance rank based on the calculated metrics. If the closed_complaints_count is greater than or equal to 10 and the avg_resolution_days is less than or equal to 5, assign the value 'High' to performance_rank. Else if the closed_complaints_count is greater than or equal to 5 and the avg_resolution_days is less than or equal to 10, assign the value 'Medium' to performance_rank. Else, assign the value 'Low' to performance_rank.\n\nFinally, return the value stored in the performance_rank variable."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves and returns a table consisting of the LastName and FirstName columns from the teachers table for rows where the Classroom column matches the provided parameter classroom_number, which is of type bigint. The function is defined to return a table with two columns: LastName of type text and FirstName of type text. It uses the RETURN QUERY statement to execute a SELECT operation that filters the teachers table based on the condition that the Classroom column is equal to the input parameter classroom_number, thereby extracting the relevant teacher names associated with the specified classroom number. The function is implemented using the plpgsql language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_teacher_by_classroom(classroom_number bigint) RETURNS TABLE(LastName text, FirstName text) AS $$\nBEGIN\n    RETURN QUERY SELECT \"LastName\", \"FirstName\" FROM teachers WHERE \"Classroom\" = classroom_number;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT * FROM get_teacher_by_classroom(101);",
      "SELECT * FROM get_teacher_by_classroom(102);",
      "SELECT * FROM get_teacher_by_classroom(103);",
      "SELECT * FROM get_teacher_by_classroom(112);",
      "SELECT * FROM get_teacher_by_classroom(107);"
    ],
    "summary": "Create a function that returns a table of teacher last names and first names from the \"teachers\" table for a specified classroom number.",
    "natural_language": "Make a function that gives back a list of teacher names from the teachers table, but only for a classroom number that's kind of around a certain area or section.",
    "id": 42,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_teacher_by_classroom that accepts a single input parameter, p_classroom_section, which is of the bigint data type. The purpose of this parameter is to specify a classroom number or a section identifier to filter the results. The function is designed to return a table with two columns: teacher_last_name of type text and teacher_first_name of type text, representing the list of teacher names.\n\nThe function performs a SELECT operation on the teachers table. This SELECT statement retrieves the LastName and FirstName columns from the teachers table. The query includes a WHERE clause to filter the results based on the Classroom column. The filtering condition is that the Classroom value must be between the value of the input parameter p_classroom_section minus 10 and the value of p_classroom_section plus 10, inclusive. This creates a range to select classrooms that are within approximately 10 units of the specified p_classroom_section, effectively targeting classrooms \"around a certain area or section.\"\n\nThe result set is ordered by the Classroom column in ascending order to provide a sorted list. The function then returns this result set as a table of teacher names, with each row containing the last name and first name of a teacher whose assigned classroom falls within the specified numerical range."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_city_code of type text, retrieves data from the City table, and returns a result set containing two columns: latitude and longitude, both of type double precision. The function begins by executing a SQL SELECT query on the City table, specifically targeting the latitude and longitude columns. The query includes a WHERE clause that filters rows based on the condition that the city_code column in the City table matches the value of the input parameter p_city_code. The function uses the RETURN QUERY statement to return the result set directly to the caller. The City table is referenced with its column names enclosed in double quotes, indicating case sensitivity or special characters in the column names. The function is written in the PLpgSQL language and is designed to return a table structure with the specified columns and data types.",
    "plsql": "CREATE OR REPLACE FUNCTION get_city_coordinates(p_city_code text)\nRETURNS TABLE(latitude double precision, longitude double precision) AS $$\nBEGIN\n    RETURN QUERY SELECT \"City\".\"latitude\", \"City\".\"longitude\" FROM \"City\" WHERE \"city_code\" = p_city_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_city_coordinates('BAL');",
      "SELECT * FROM get_city_coordinates('PIT');",
      "SELECT * FROM get_city_coordinates('PHL');",
      "SELECT * FROM get_city_coordinates('ATL');",
      "SELECT * FROM get_city_coordinates('BKK');"
    ],
    "summary": "Create a PL/pgSQL function that takes a text parameter p_city_code and returns a table with columns (latitude double precision, longitude double precision). The function returns a query selecting the latitude and longitude columns from the City table where the city_code column equals p_city_code.",
    "natural_language": "Function returning latitude and longitude for a given city code.",
    "id": 43,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_city_coordinates` that accepts a single input parameter `p_city_code` of type `text`, representing the city code for which to retrieve geographic coordinates. The function returns a record or composite type containing two `double precision` values: the latitude and longitude of the specified city. The function operates within the `address_1` database.\n\nThe function begins by declaring two local variables: `v_latitude` of type `double precision` to store the latitude value, and `v_longitude` of type `double precision` to store the longitude value.\n\nThe core operation is a `SELECT` statement that retrieves the `latitude` and `longitude` columns from the `City` table. The `WHERE` clause filters the query to return only the row where the `city_code` column exactly matches the input parameter `p_city_code`. The retrieved values are assigned directly into the `v_latitude` and `v_longitude` variables.\n\nAfter the `SELECT` operation, the function returns the values stored in `v_latitude` and `v_longitude` as its output. If no row is found in the `City` table with the given `p_city_code`, both return values will be `NULL`. The function does not contain any conditional logic, loops, or additional data transformations; its sole purpose is to fetch and return the coordinate data from the `City` table based on the provided city code."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_settlement_ratio that accepts a single input parameter named policy_id_param of type bigint, which represents the unique identifier of an insurance policy, and returns a numeric value; the function begins by declaring two local bigint variables, claimed_amount and settled_amount; it then executes a SELECT query on the \"Claims\" table to retrieve and sum the values from the \"Amount_Claimed\" and \"Amount_Settled\" columns for all rows where the \"Policy_ID\" column matches the provided policy_id_param; the COALESCE function is used in the SELECT statement to convert any NULL summation results from the SUM aggregate function to the numeric value 0, ensuring both variables are initialized; the results of these aggregated sums are assigned into the declared variables claimed_amount and settled_amount; following this data retrieval, the function implements a conditional IF-THEN-ELSE block: if the value of claimed_amount is equal to 0, the function immediately returns the numeric value 0; otherwise, the function proceeds to calculate a ratio by dividing the settled_amount by the claimed_amount, explicitly casting both bigint variables to the numeric data type to ensure precise decimal division, and then applies the ROUND function to the result of this division, rounding the numeric quotient to two decimal places, and this rounded value is returned as the function's final result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_settlement_ratio(policy_id_param bigint) RETURNS numeric AS $$\nDECLARE\n    claimed_amount bigint;\n    settled_amount bigint;\nBEGIN\n    SELECT COALESCE(SUM(\"Amount_Claimed\"), 0), COALESCE(SUM(\"Amount_Settled\"), 0)\n    INTO claimed_amount, settled_amount\n    FROM \"Claims\"\n    WHERE \"Policy_ID\" = policy_id_param;\n    \n    IF claimed_amount = 0 THEN\n        RETURN 0;\n    ELSE\n        RETURN ROUND(settled_amount::numeric / claimed_amount::numeric, 2);\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "SELECT calculate_settlement_ratio(744);",
      "SELECT calculate_settlement_ratio(552);",
      "SELECT calculate_settlement_ratio(473);",
      "SELECT calculate_settlement_ratio(119);",
      "SELECT calculate_settlement_ratio(141);"
    ],
    "summary": "Create a function named calculate_settlement_ratio that takes a policy_id bigint and returns a numeric value. It calculates the ratio of total settled amount to total claimed amount for the policy, returning 0 if no claims exist, and rounds the result to two decimal places.",
    "natural_language": "Create a function, which should be named calculate_settlement_ratio, that accepts a single input parameter: a policy identifier of the bigint data type. This function is designed to compute a precise numeric ratio by carefully dividing the aggregate sum of all settled amounts by the total sum of all claimed amounts specifically associated with the provided policy. To ensure robustness, it must gracefully handle scenarios where no claims exist by explicitly returning a value of zero. Finally, for clear and standardized presentation, the computed result must be rounded to exactly two decimal places before being returned.",
    "id": 44,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named calculate_settlement_ratio that accepts a single input parameter named policy_id_param of type bigint, which represents the unique identifier of an insurance policy, and returns a numeric value; the function begins by declaring two local bigint variables, claimed_amount and settled_amount; it then executes a SELECT query on the \"Claims\" table to retrieve and sum the values from the \"Amount_Claimed\" and \"Amount_Settled\" columns for all rows where the \"Policy_ID\" column matches the provided policy_id_param; the COALESCE function is used in the SELECT statement to convert any NULL summation results from the SUM aggregate function to the numeric value 0, ensuring both variables are initialized; the results of these aggregated sums are assigned into the declared variables claimed_amount and settled_amount; following this data retrieval, the function implements a conditional IF-THEN-ELSE block: if the value of claimed_amount is equal to 0, the function immediately returns the numeric value 0; otherwise, the function proceeds to calculate a ratio by dividing the settled_amount by the claimed_amount, explicitly casting both bigint variables to the numeric data type to ensure precise decimal division, and then applies the ROUND function to the result of this division, rounding the numeric quotient to two decimal places, and this rounded value is returned as the function's final result."
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the total sum of the values in the business_rates_id column from the Business_Rates table, but only for rows where the cmi_cross_ref_id column matches any value in the cmi_cross_ref_id column of the CMI_Cross_References table. The function does not take any input parameters and returns a single bigint value. Inside the function, a local variable named total_business_rates of type bigint is declared to store the result of the calculation. The function performs a SELECT statement with a SUM aggregate function on the business_rates_id column from the Business_Rates table, applying a WHERE clause to filter rows based on the cmi_cross_ref_id column. The filtering condition uses a subquery that retrieves all cmi_cross_ref_id values from the CMI_Cross_References table. The result of the SUM operation is assigned to the total_business_rates variable using the INTO clause. Finally, the function returns the value stored in total_business_rates.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_business_rates()\nRETURNS bigint AS $$\nDECLARE\n    total_business_rates bigint;\nBEGIN\n    SELECT SUM(business_rates_id)\n    INTO total_business_rates\n    FROM public.\"Business_Rates\"\n    WHERE cmi_cross_ref_id IN (SELECT cmi_cross_ref_id FROM public.\"CMI_Cross_References\");\n    RETURN total_business_rates;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Business_Rates",
      "CMI_Cross_References"
    ],
    "call_sqls": [
      "SELECT calculate_total_business_rates();",
      "SELECT * FROM calculate_total_business_rates();",
      "SELECT calculate_total_business_rates() AS total_business_rates;",
      "DO $$\nDECLARE\n    result bigint;\nBEGIN\n    result := calculate_total_business_rates();\n    RAISE NOTICE 'Total Business Rates: %', result;\nEND $$;",
      "WITH total AS (SELECT calculate_total_business_rates() AS total_value)\nSELECT total_value FROM total;"
    ],
    "summary": "Create a PL/pgSQL function with no parameters that returns a bigint. It should calculate and return the total sum of the business_rates_id column from the Business_Rates table, but only for rows where the cmi_cross_ref_id exists in the CMI_Cross_References table.",
    "natural_language": "Calculate and return the total sum of the business_rates_id column from the Business_Rates table, but only for rows where the cmi_cross_ref_id exists in the CMI_Cross_References table. Implement this as a PL/pgSQL function with no parameters that returns a bigint.",
    "id": 45,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_total_business_rates that resides in the local_govt_mdm database. The function takes no input parameters and returns a single value of type bigint. Within the function, a variable named total_sum of type bigint is declared to store the computed result. The function performs a SELECT operation that calculates the sum of the business_rates_id column from the Business_Rates table. This summation is filtered to include only those rows where the cmi_cross_ref_id in the Business_Rates table exists in the CMI_Cross_References table, effectively performing an implicit join based on the equality of the cmi_cross_ref_id columns between the two tables. The result of this aggregation is stored directly into the total_sum variable. Finally, the function returns the value stored in total_sum as the output."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the claim history for a specific insurance policy identified by the input parameter policy_id_input of type bigint. The function returns a table with three columns: claim_date of type date, amount_claimed of type bigint, and amount_settled of type bigint. Within the function, a SQL query is executed to select data from the \"Claims\" table, specifically the \"Date_Claim_Made\" column for the claim date, the \"Amount_Claimed\" column for the amount claimed, and the \"Amount_Settled\" column for the amount settled. The query filters rows where the \"Policy_ID\" column in the \"Claims\" table matches the value of the input parameter policy_id_input. The results are ordered in descending order based on the \"Date_Claim_Made\" column, ensuring that the most recent claims appear first. The function uses the RETURN QUERY statement to directly return the result set of the query to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION get_policy_claim_history(policy_id_input bigint) RETURNS TABLE(claim_date date, amount_claimed bigint, amount_settled bigint) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT c.\"Date_Claim_Made\", c.\"Amount_Claimed\", c.\"Amount_Settled\"\n    FROM \"Claims\" c\n    WHERE c.\"Policy_ID\" = policy_id_input\n    ORDER BY c.\"Date_Claim_Made\" DESC;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Settlements"
    ],
    "call_sqls": [
      "SELECT * FROM get_policy_claim_history(744);",
      "SELECT * FROM get_policy_claim_history(552);",
      "SELECT * FROM get_policy_claim_history(473);",
      "SELECT * FROM get_policy_claim_history(119);",
      "SELECT * FROM get_policy_claim_history(141);"
    ],
    "summary": "Create a function that takes a policy_id bigint and returns a table of claim history. The table includes claim_date, amount_claimed, and amount_settled for the specified policy, ordered by the most recent claim date first.",
    "natural_language": "Function returning claim_date, amount_claimed, amount_settled for given policy_id, sorted by latest claim_date.",
    "id": 46,
    "generated_ir": "Write a PLpgSQL function that retrieves the claim history for a specific insurance policy identified by the input parameter policy_id_input of type bigint. The function returns a table with three columns: claim_date of type date, amount_claimed of type bigint, and amount_settled of type bigint. Within the function, a SQL query is executed to select data from the \"Claims\" table, specifically the \"Date_Claim_Made\" column for the claim date, the \"Amount_Claimed\" column for the amount claimed, and the \"Amount_Settled\" column for the amount settled. The query filters rows where the \"Policy_ID\" column in the \"Claims\" table matches the value of the input parameter policy_id_input. The results are ordered in descending order based on the \"Date_Claim_Made\" column, ensuring that the most recent claims appear first. The function uses the RETURN QUERY statement to directly return the result set of the query to the caller."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named generate_problem_hash that accepts a single input parameter called problem_id_input of type bigint, which is used to identify a specific record in the \"Problems\" table, and returns a value of type text; the function begins by declaring a local text variable named hash_result, then executes a SELECT query that retrieves a single row from the \"Problems\" table where the problem_id column exactly matches the provided problem_id_input parameter, and for that row, it calculates an MD5 cryptographic hash by concatenating the value from the problem_description column with the value from the other_problem_details column and passing the concatenated string to the built-in md5() function, storing the resulting hash string into the hash_result variable, and finally the function returns the value stored in hash_result.",
    "plsql": "CREATE OR REPLACE FUNCTION generate_problem_hash(problem_id_input bigint) RETURNS text AS $$\nDECLARE\n    hash_result text;\nBEGIN\n    SELECT md5(problem_description || other_problem_details)\n    INTO hash_result\n    FROM \"Problems\"\n    WHERE problem_id = problem_id_input;\n    RETURN hash_result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "SELECT generate_problem_hash(1);",
      "SELECT generate_problem_hash(2);",
      "SELECT generate_problem_hash(3);",
      "SELECT generate_problem_hash(11);",
      "SELECT generate_problem_hash(8);"
    ],
    "summary": "Create a function named generate_problem_hash that accepts a problem_id_input (bigint) and returns a text value. The function should retrieve the row from the \"Problems\" table matching the input ID, calculate an MD5 hash by concatenating the problem_description and other_problem_details columns, and return the hash string.",
    "natural_language": "Please construct a function designated as 'generate_problem_hash'. This function shall accept a single parameter of type bigint, named 'problem_id_input', and shall return a value of type text. The function's operation must involve querying the \"Problems\" table to locate the record corresponding to the provided identifier. Subsequently, it must compute an MD5 hash by concatenating the contents of the 'problem_description' and 'other_problem_details' columns from that record. The resultant hash string is to be returned as the function's output.",
    "id": 47,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named generate_problem_hash that accepts a single input parameter called problem_id_input of type bigint, which is used to identify a specific record in the \"Problems\" table, and returns a value of type text; the function begins by declaring a local text variable named hash_result, then executes a SELECT query that retrieves a single row from the \"Problems\" table where the problem_id column exactly matches the provided problem_id_input parameter, and for that row, it calculates an MD5 cryptographic hash by concatenating the value from the problem_description column with the value from the other_problem_details column and passing the concatenated string to the built-in md5() function, storing the resulting hash string into the hash_result variable, and finally the function returns the value stored in hash_result."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named count_residents_in_property that accepts a single input parameter p_property_id of type BIGINT, which represents the unique identifier of a property, and returns an integer value; the function declares a local integer variable resident_count, then executes a SELECT statement to query the Residents table, specifically counting all rows where the property_id column matches the provided input parameter p_property_id, storing the resulting count into the resident_count variable, and finally returns the value of resident_count as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_residents_in_property(\n    p_property_id BIGINT\n)\nRETURNS INTEGER\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    resident_count INTEGER;\nBEGIN\n    SELECT COUNT(*)\n    INTO resident_count\n    FROM \"Residents\"\n    WHERE property_id = p_property_id;\n    \n    RETURN resident_count;\nEND;\n$$;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Residents",
      "Properties"
    ],
    "call_sqls": [
      "SELECT count_residents_in_property(24);",
      "SELECT count_residents_in_property(107);",
      "SELECT count_residents_in_property(108);",
      "SELECT count_residents_in_property(605);",
      "SELECT count_residents_in_property(879);"
    ],
    "summary": "Create a PL/pgSQL function named count_residents_in_property that takes a property_id (BIGINT) and returns the count of residents in the Residents table for that property.",
    "natural_language": "How many residents are recorded in the Residents table for a given property_id?",
    "id": 48,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `count_residents_in_property` that accepts a single input parameter, `p_property_id`, which is of type `bigint`. This function is designed to return a `bigint` value representing the count of residents. Inside the function, a local variable `resident_count` of type `bigint` is declared. The function's core logic begins by executing a `SELECT` statement with a `COUNT` aggregate function. This `SELECT` statement counts the number of rows from the `Residents` table. The `WHERE` clause filters the rows to include only those where the `property_id` column matches the value of the input parameter `p_property_id`. The result of this count operation is then assigned to the `resident_count` local variable. Finally, the function returns the value stored in the `resident_count` variable."
  },
  {
    "ir": "Write a PLpgSQL function named get_instrument_diversity that returns a text value, which accepts three input parameters: a bigint parameter named p_song_id to identify a specific song, a bigint parameter named p_min_bandmate_id to set a minimum bandmate identifier, and a text parameter named p_instrument_filter to specify an instrument to exclude; the function's logic executes a single SQL SELECT query on the \"Instruments\" table, where the query selects the \"Instrument\" column, applies a DISTINCT modifier to eliminate duplicate instrument names, and filters rows using a WHERE clause with three conditions that must all be true: the \"SongId\" column must exactly equal the input parameter p_song_id, the \"BandmateId\" column must be greater than or equal to the input parameter p_min_bandmate_id, and the \"Instrument\" column must not be equal to the input parameter p_instrument_filter; the resulting set of distinct instrument names is then aggregated into a single text string using the STRING_AGG function, which concatenates the instrument names separated by commas, and this aggregated string is returned as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_instrument_diversity(p_song_id bigint, p_min_bandmate_id bigint, p_instrument_filter text)\nRETURNS text AS $$\nBEGIN\n    RETURN (SELECT STRING_AGG(DISTINCT \"Instrument\", ',') FROM \"Instruments\" WHERE \"SongId\" = p_song_id AND \"BandmateId\" >= p_min_bandmate_id AND \"Instrument\" != p_instrument_filter);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "SELECT get_instrument_diversity(1, 1, 'Guitar');",
      "SELECT get_instrument_diversity(2, 3, 'Drums');",
      "SELECT get_instrument_diversity(5, 2, 'Bass');",
      "SELECT get_instrument_diversity(10, 1, 'Piano');",
      "SELECT get_instrument_diversity(7, 4, 'Vocals');"
    ],
    "summary": "Create a PLpgSQL function named get_instrument_diversity that returns a text value. It accepts three parameters: p_song_id (bigint), p_min_bandmate_id (bigint), and p_instrument_filter (text). The function returns a comma-separated string of distinct instrument names from the \"Instruments\" table where SongId equals p_song_id, BandmateId is greater than or equal to p_min_bandmate_id, and Instrument is not equal to p_instrument_filter.",
    "natural_language": "Write a PLpgSQL function called get_instrument_diversity that gives back a text result. It should take three inputs: a song ID, a minimum bandmate ID, and a text to filter instruments by. The function needs to produce a list, separated by commas, of the different kinds of instruments found in the \"Instruments\" table for a certain song, but only for bandmates with IDs at or above a certain number, and leaving out any instruments that match the given filter text.",
    "id": 49,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_instrument_diversity that returns a text value. The function accepts three input parameters: p_song_id of type bigint representing the unique identifier of a song, p_min_bandmate_id of type bigint representing the minimum bandmate identifier to include, and p_instrument_filter of type text representing a string to exclude matching instruments. The function declares a local variable v_result of type text to store the final comma-separated list of instruments. The core operation involves executing a SELECT query that uses the STRING_AGG function to concatenate distinct instrument names from the Instruments table. The query selects the Instrument column from the Instruments table. It includes a WHERE clause with three conditions: the SongId column must equal the p_song_id parameter, the BandmateId column must be greater than or equal to the p_min_bandmate_id parameter, and the Instrument column must not be equal to the p_instrument_filter parameter. The STRING_AGG function aggregates the distinct values of the Instrument column, using a comma followed by a space as the delimiter. The result of this aggregation is stored directly into the v_result variable using the INTO clause. Finally, the function returns the value of v_result, which will be a comma-separated string of instrument names or an empty string if no matching rows are found."
  },
  {
    "ir": "Write a PostgreSQL SQL function that retrieves the top company by sales from the company table. This function, named get_top_company_by_sales, returns a table with three columns: Company_ID of type integer, Company of type text, and Sales_billion of type real. The function performs a SELECT operation on the company table, extracting the Company_ID, Company, and Sales_billion columns. It orders the results by the Sales_billion column in descending order to ensure the company with the highest sales is prioritized. The function limits the result set to a single row using the LIMIT 1 clause, effectively selecting the company with the highest sales figure. There are no conditional statements or special operations like function calls within this function. The logic flow is straightforward, focusing solely on retrieving and ordering data based on sales figures.",
    "plsql": "CREATE OR REPLACE FUNCTION get_top_company_by_sales()\nRETURNS TABLE(\"Company_ID\" integer, \"Company\" text, \"Sales_billion\" real)\nLANGUAGE sql AS $$\nSELECT \"Company_ID\", \"Company\", \"Sales_billion\" FROM \"company\" ORDER BY \"Sales_billion\" DESC LIMIT 1;\n$$;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "station_company"
    ],
    "call_sqls": [
      "SELECT * FROM get_top_company_by_sales();",
      "SELECT \"Company\", \"Sales_billion\" FROM get_top_company_by_sales();",
      "SELECT \"Company_ID\" FROM get_top_company_by_sales();",
      "SELECT * FROM get_top_company_by_sales() AS top_company;",
      "SELECT \"Company_ID\", \"Company\" FROM get_top_company_by_sales();"
    ],
    "summary": "Create a PostgreSQL SQL function named get_top_company_by_sales that returns a single row table with Company_ID, Company, and Sales_billion for the company with the highest sales.",
    "natural_language": "What is the company ID, name, and sales in billions for the company with the highest sales?",
    "id": 50,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_top_company_by_sales that returns a record consisting of three fields: an integer for company ID, a text for company name, and a real for sales in billions. The function is designed to operate on the gas_company database. It performs a SELECT operation on the company table to retrieve the Company_ID column, the Company column, and the Sales_billion column. The function includes an ORDER BY clause that sorts the results in descending order based on the Sales_billion column to prioritize the highest sales value. It then uses a LIMIT clause to restrict the result set to only the first row, which corresponds to the company with the maximum sales. The function uses the RETURN QUERY statement to return this single row as the output record. The function is defined using the PLpgSQL language."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_total_missions that takes no input parameters and returns a single integer value; the function's purpose is to calculate and return the total count of all rows currently present in the database table named mission by executing a SELECT statement that uses the COUNT(*) aggregate function on the entire mission table without any filtering conditions, joins, or grouping, and directly returns the resulting scalar count value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_missions()\nRETURNS INTEGER AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM mission);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT get_total_missions();",
      "SELECT * FROM get_total_missions();",
      "SELECT get_total_missions() AS total_missions;",
      "DO $$\nDECLARE\n    total INTEGER;\nBEGIN\n    total := get_total_missions();\n    RAISE NOTICE 'Total missions: %', total;\nEND $$;",
      "SELECT get_total_missions() INTO TEMP TABLE mission_count;"
    ],
    "summary": "Create a PL/pgSQL function named get_total_missions that returns the total row count from the mission table.",
    "natural_language": "Please construct a PL/pgSQL function, designated as `get_total_missions`, which shall return the aggregate number of rows present within the mission table.",
    "id": 51,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named get_total_missions that takes no input parameters and returns a single integer value; the function's purpose is to calculate and return the total count of all rows currently present in the database table named mission by executing a SELECT statement that uses the COUNT(*) aggregate function on the entire mission table without any filtering conditions, joins, or grouping, and directly returns the resulting scalar count value."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_device_carrier that accepts a single integer input parameter named p_device_id, which represents the unique identifier for a device record, and returns a text value; within the function, a local text variable v_carrier is declared to temporarily hold the result, then a SELECT query is executed to retrieve the value from the \"Carrier\" column of the \"device\" table specifically from the row where the \"Device_ID\" column exactly matches the provided p_device_id input parameter, and this retrieved value is stored into the v_carrier variable using the INTO clause, after which the function concludes by returning the value contained in the v_carrier variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_carrier(p_device_id integer) RETURNS text AS $$\nDECLARE\n    v_carrier text;\nBEGIN\n    SELECT \"Carrier\" INTO v_carrier FROM \"device\" WHERE \"Device_ID\" = p_device_id;\n    RETURN v_carrier;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT get_device_carrier(1);",
      "SELECT get_device_carrier(2);",
      "SELECT get_device_carrier(3);",
      "SELECT get_device_carrier(6);",
      "SELECT get_device_carrier(10);"
    ],
    "summary": "Create a function named get_device_carrier that takes a device ID as input and returns the carrier text for that device from the device table.",
    "natural_language": "Make a function called get_device_carrier that, when given a device identifier, fetches and gives back the roughly corresponding service provider details from the device records.",
    "id": 52,
    "generated_ir": "Write a PLpgSQL function named get_device_carrier that accepts a single input parameter p_device_id of type integer, which specifies the unique identifier of a device for lookup, and returns a table structure with two output columns: p_device of type text and p_carrier of type text; the function's body executes a single SQL SELECT query that retrieves the Device and Carrier columns from the device table for the row where the Device_ID column exactly matches the value provided in the p_device_id input parameter, and then returns the entire result set of this query directly as the function's output."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_employee_salary` that accepts a single input parameter, `p_employee_id`, which is of the `numeric` data type. This function is designed to return a `numeric` value representing an employee's salary. The core logic of the function involves a conditional check: if the value of `p_employee_id` is strictly greater than `0`, the function proceeds to execute a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"SALARY\"` from the table named `employees`. The retrieval is filtered by a `WHERE` clause, ensuring that only the row where the column `\"EMPLOYEE_ID\"` matches the provided `p_employee_id` is considered. The value obtained from this `SELECT` statement is then returned as the result of the function. Conversely, if the value of `p_employee_id` is not strictly greater than `0` (i.e., it is less than or equal to `0`), the function explicitly returns a `NULL` value, indicating that no valid salary could be retrieved under that condition.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_salary(p_employee_id numeric)\nRETURNS numeric\nAS $$\nBEGIN\n    IF p_employee_id > 0 THEN\n        RETURN (SELECT \"SALARY\" FROM employees WHERE \"EMPLOYEE_ID\" = p_employee_id);\n    ELSE\n        RETURN NULL; -- Explicitly return NULL if p_employee_id is not positive\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "hr_1",
    "tables": [
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations"
    ],
    "call_sqls": [
      "SELECT get_employee_salary(100);",
      "SELECT get_employee_salary(101);",
      "SELECT get_employee_salary(102);",
      "SELECT get_employee_salary(200);",
      "SELECT get_employee_salary(201);"
    ],
    "summary": "Create a PL/pgSQL function named get_employee_salary that returns a numeric salary. If the input p_employee_id is greater than 0, return the SALARY from the employees table where EMPLOYEE_ID matches. Otherwise, return NULL.",
    "natural_language": "Write a function called get_employee_salary that gives back a salary amount. If you provide a somewhat valid employee ID, like a positive number, fetch the corresponding pay from the employees list. For any other kind of input, just return nothing.",
    "id": 53,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_employee_salary that accepts one input parameter: p_employee_id of type numeric, representing the unique identifier of an employee. This function is designed to return a numeric value, which corresponds to the salary amount of the specified employee.\n\nUpon execution, the function first evaluates a conditional IF statement. The condition checks if the p_employee_id input parameter is greater than zero, ensuring it is a positive number.\n\nIf the condition p_employee_id > 0 evaluates to true, meaning a valid positive employee ID is provided, the function proceeds to execute a SELECT statement. This SELECT statement retrieves the value from the salary column of the employees table. This retrieval is conditional, specifically targeting the row where the employee_id column matches the value provided by the p_employee_id input parameter. The retrieved salary value is then directly returned as the function's output.\n\nConversely, if the condition p_employee_id > 0 evaluates to false, meaning the input is not a positive number (e.g., zero, negative, or NULL), the function executes an ELSE block. Within this ELSE block, the function returns NULL, indicating no valid salary data is available for the given input.\n\nAfter either the IF or ELSE block has been executed, the function concludes its operation."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_organization_name that accepts a single input parameter p_organization_id of type bigint, which represents the unique identifier for an organization, and returns a value of type text. The function declares a local variable v_name of type text to temporarily store the result. The function's logic executes a SELECT query that retrieves the value from the organization_name column within the Organizations table, specifically from the row where the organization_id column exactly matches the provided input parameter p_organization_id, and assigns this retrieved value into the local variable v_name. The function then concludes by returning the value stored in v_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_organization_name(p_organization_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_name text;\nBEGIN\n    SELECT \"organization_name\" INTO v_name\n    FROM \"Organizations\"\n    WHERE \"organization_id\" = p_organization_id;\n    RETURN v_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_government",
    "tables": [
      "Parties",
      "Individuals",
      "Organizations",
      "Addresses",
      "Party_Addresses"
    ],
    "call_sqls": [
      "SELECT get_organization_name(1);",
      "SELECT get_organization_name(2);",
      "SELECT get_organization_name(3);",
      "SELECT get_organization_name(4);",
      "SELECT get_organization_name(5);"
    ],
    "summary": "Create a PL/pgSQL function named `get_organization_name` that takes a bigint parameter `p_organization_id` and returns text. Select and return the `organization_name` from the `Organizations` table where the `organization_id` matches the provided parameter.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_organization_name`. This function shall accept a single parameter of type bigint, named `p_organization_id`, and is defined to return a text value. Its operational logic must involve querying the `Organizations` table to retrieve and subsequently return the `organization_name` for the record whose `organization_id` corresponds precisely to the supplied input parameter.",
    "id": 54,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_organization_name that accepts a single input parameter p_organization_id of type bigint, which represents the unique identifier for an organization, and returns a value of type text. The function declares a local variable v_name of type text to temporarily store the result. The function's logic executes a SELECT query that retrieves the value from the organization_name column within the Organizations table, specifically from the row where the organization_id column exactly matches the provided input parameter p_organization_id, and assigns this retrieved value into the local variable v_name. The function then concludes by returning the value stored in v_name."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_average_age_by_school that accepts a single integer input parameter named school_id_input, returns a real number, and performs the following operations: it declares a local real variable named avg_age; it executes a SELECT query on the player table to compute the average value of the Age column for all rows where the School_ID column exactly matches the provided school_id_input parameter, storing the result into the avg_age variable; it then evaluates the value of avg_age with a conditional IF-ELSIF-ELSE block: if avg_age is NULL, it assigns the value -1 to avg_age; otherwise, if avg_age is less than 15, it multiplies avg_age by 1.1 and reassigns the result to avg_age; otherwise, for any other case where avg_age is 15 or greater, it adds 2 to avg_age and reassigns the result; finally, the function returns the final value of the avg_age variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_age_by_school(school_id_input integer)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    avg_age real;\nBEGIN\n    SELECT AVG(\"Age\") INTO avg_age\n    FROM player\n    WHERE \"School_ID\" = school_id_input;\n\n    IF avg_age IS NULL THEN\n        avg_age := -1;\n    ELSIF avg_age < 15 THEN\n        avg_age := avg_age * 1.1;\n    ELSE\n        avg_age := avg_age + 2;\n    END IF;\n\n    RETURN avg_age;\nEND;\n$$;",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "SELECT calculate_average_age_by_school(1);",
      "SELECT calculate_average_age_by_school(2);",
      "SELECT calculate_average_age_by_school(3);",
      "SELECT calculate_average_age_by_school(10);",
      "SELECT calculate_average_age_by_school(NULL);"
    ],
    "summary": "Create a function named calculate_average_age_by_school that takes an integer parameter school_id_input and returns a real number. Declare a real variable avg_age. Calculate the average Age from the player table where School_ID equals school_id_input and store it in avg_age. If avg_age is NULL, set it to -1. If avg_age is less than 15, multiply it by 1.1. Otherwise, add 2 to it. Return the final avg_age.",
    "natural_language": "Make a function called calculate_average_age_by_school that needs a school ID number. It should give back a real number. Figure out the typical age from the player data for that particular school. If you can't really find a solid average, just use -1. If that typical age seems on the younger side, bump it up a little, say by 10 percent. If it's not that young, just add a small amount like 2 to it. Then return whatever that final number ends up being.",
    "id": 55,
    "generated_ir": "Write a PLpgSQL function named calculate_average_age_by_school that accepts a single integer input parameter named school_id_input, returns a real number, and performs the following operations: it declares a local real variable named avg_age; it executes a SELECT query on the player table to compute the average value of the Age column for all rows where the School_ID column exactly matches the provided school_id_input parameter, storing the result into the avg_age variable; it then evaluates the value of avg_age with a conditional IF-ELSIF-ELSE block: if avg_age is NULL, it assigns the value -1 to avg_age; otherwise, if avg_age is less than 15, it multiplies avg_age by 1.1 and reassigns the result to avg_age; otherwise, for any other case where avg_age is 15 or greater, it adds 2 to avg_age and reassigns the result; finally, the function returns the final value of the avg_age variable."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_mutual_friends_count` that accepts two integer parameters: `student1_id` and `student2_id`. This function is designed to calculate and return the total number of mutual friends shared between the two students identified by these input IDs. The core operation involves a single `SELECT` statement that queries the `\"Friend\"` table. This `SELECT` statement performs an inner join of the `\"Friend\"` table with itself, aliasing the first instance as `f1` and the second as `f2`. The join condition `f1.\"friend_id\" = f2.\"friend_id\"` links rows where the `friend_id` column values are identical across both aliased instances of the table. This effectively identifies common friends. A `WHERE` clause is applied to filter the joined results: `f1.\"student_id\" = student1_id` ensures that the first instance of the friend relationship (`f1`) belongs to the student identified by the `student1_id` parameter, and `f2.\"student_id\" = student2_id` ensures that the second instance of the friend relationship (`f2`) belongs to the student identified by the `student2_id` parameter. The `COUNT(*)` aggregate function is then applied to the filtered and joined rows to determine the total number of such relationships, which represents the count of mutual friends. The result of `COUNT(*)` is explicitly cast to an `integer` type using `::integer` before being returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_mutual_friends_count(student1_id integer, student2_id integer)\nRETURNS integer AS $$\nBEGIN\n    RETURN (\n        SELECT COUNT(*)::integer\n        FROM \"Friend\" f1\n        JOIN \"Friend\" f2 ON f1.\"friend_id\" = f2.\"friend_id\"\n        WHERE f1.\"student_id\" = student1_id AND f2.\"student_id\" = student2_id\n    );\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT get_mutual_friends_count(1510, 1689);",
      "SELECT get_mutual_friends_count(1689, 1510);",
      "SELECT get_mutual_friends_count(1381, 1709);",
      "SELECT get_mutual_friends_count(1510, 1381);",
      "SELECT get_mutual_friends_count(1709, 1689);"
    ],
    "summary": "Create a function named get_mutual_friends_count that takes two student IDs and returns an integer count of their mutual friends by joining the Friend table on itself.",
    "natural_language": "Function get_mutual_friends_count: takes two student IDs, returns integer count of their mutual friends via Friend table self-join.",
    "id": 56,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_mutual_friends_count that accepts two input parameters, both of type integer, representing two student IDs. The function returns a single integer value representing the count of mutual friends between the two specified students. The function operates on the Friend table, which contains student_id and friend_id columns representing friendships.\n\nThe function begins by declaring a variable to hold the mutual friend count, typically named v_mutual_count of type integer. It then executes a SELECT query that performs a self-join on the Friend table to identify mutual friends. Specifically, it joins two instances of the Friend table: the first instance (alias f1) represents friendships of the first student, and the second instance (alias f2) represents friendships of the second student. The join condition matches the friend_id from f1 with the friend_id from f2, ensuring that the same person is a friend of both students. The query filters f1 to include only rows where student_id equals the first input parameter, and filters f2 to include only rows where student_id equals the second input parameter. This identifies all individuals who are friends with both students. The query then counts the number of distinct friend_id values from these matched rows, as mutual friends should be counted only once per individual. The result of this count is stored in the v_mutual_count variable.\n\nFinally, the function returns the value of v_mutual_count as the output integer. The function does not involve the Highschooler or Likes tables, as it solely relies on the Friend table structure to compute mutual friendships via a self-join operation."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single integer parameter p_student_id, representing the ID of a student, and analyzes the friendship patterns of that student based on data stored in the \"Friend\" table. The function begins by declaring two local integer variables, friend_count and mutual_friend_count, to store the total number of friends and the number of mutual friendships, respectively. It first calculates the total number of friends for the given student by executing a SELECT COUNT(*) query on the \"Friend\" table, filtering rows where the student_id column matches the value of p_student_id, and stores the result in the friend_count variable. Next, it calculates the number of mutual friendships by performing a JOIN operation between two instances of the \"Friend\" table, where the first instance (f1) represents friendships initiated by the given student and the second instance (f2) represents friendships initiated by the student's friends. The JOIN condition ensures that f1.friend_id matches f2.student_id and f2.friend_id matches the original p_student_id, effectively identifying mutual friendships. The result of this query is stored in the mutual_friend_count variable. The function then evaluates the relationship between mutual_friend_count and friend_count using conditional logic. If mutual_friend_count is greater than half of friend_count, the function returns the text 'Strong mutual connections'. If mutual_friend_count is greater than zero but not more than half of friend_count, it returns 'Some mutual connections'. If mutual_friend_count is zero, it returns 'No mutual connections'. The function uses the RETURN statement to output the appropriate text based on the conditions evaluated.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_friendship_pattern(p_student_id integer)\nRETURNS text AS $$\nDECLARE\n    friend_count integer;\n    mutual_friend_count integer;\nBEGIN\n    SELECT COUNT(*) INTO friend_count FROM \"Friend\" WHERE student_id = p_student_id;\n    SELECT COUNT(*) INTO mutual_friend_count FROM \"Friend\" f1\n    JOIN \"Friend\" f2 ON f1.friend_id = f2.student_id\n    WHERE f1.student_id = p_student_id AND f2.friend_id = p_student_id;\n\n    IF mutual_friend_count > friend_count / 2 THEN\n        RETURN 'Strong mutual connections';\n    ELSIF mutual_friend_count > 0 THEN\n        RETURN 'Some mutual connections';\n    ELSE\n        RETURN 'No mutual connections';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT analyze_friendship_pattern(1510);",
      "SELECT analyze_friendship_pattern(1689);",
      "SELECT analyze_friendship_pattern(1381);",
      "SELECT analyze_friendship_pattern(1709);",
      "SELECT analyze_friendship_pattern(1782);"
    ],
    "summary": "Create a PLpgSQL function that takes a student ID and returns a text analysis of their friendship patterns. It counts the student's total friends and mutual friendships from the Friend table. Return 'Strong mutual connections' if mutual friends are more than half of total friends, 'Some mutual connections' if mutual friends exist but are half or less, or 'No mutual connections' if none exist.",
    "natural_language": "Hey, can you whip up a PLpgSQL function that, given a student's ID, gives us the lowdown on their friend scene? It should tally up their total buddies and mutual pals from the Friend table. Then, spit out 'Strong mutual connections' if the mutual friends are over half the total, 'Some mutual connections' if there are mutuals but they're half or less, or 'No mutual connections' if there aren't any.",
    "id": 57,
    "generated_ir": "Write a PLpgSQL function that takes a single integer parameter p_student_id, representing the ID of a student, and analyzes the friendship patterns of that student based on data stored in the \"Friend\" table. The function begins by declaring two local integer variables, friend_count and mutual_friend_count, to store the total number of friends and the number of mutual friendships, respectively. It first calculates the total number of friends for the given student by executing a SELECT COUNT(*) query on the \"Friend\" table, filtering rows where the student_id column matches the value of p_student_id, and stores the result in the friend_count variable. Next, it calculates the number of mutual friendships by performing a JOIN operation between two instances of the \"Friend\" table, where the first instance (f1) represents friendships initiated by the given student and the second instance (f2) represents friendships initiated by the student's friends. The JOIN condition ensures that f1.friend_id matches f2.student_id and f2.friend_id matches the original p_student_id, effectively identifying mutual friendships. The result of this query is stored in the mutual_friend_count variable. The function then evaluates the relationship between mutual_friend_count and friend_count using conditional logic. If mutual_friend_count is greater than half of friend_count, the function returns the text 'Strong mutual connections'. If mutual_friend_count is greater than zero but not more than half of friend_count, it returns 'Some mutual connections'. If mutual_friend_count is zero, it returns 'No mutual connections'. The function uses the RETURN statement to output the appropriate text based on the conditions evaluated."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves recent payment records from the Customer_Payments table for a specified customer and within a given time interval. The function, named get_recent_payments, accepts two parameters: p_customer_id of type bigint, which represents the unique identifier of the customer whose payment records are to be fetched, and p_days_interval of type integer, which specifies the number of days to look back from the current date to filter the payment records. The function returns a table with three columns: customer_id of type bigint, datetime_payment of type timestamp with time zone, and amount_payment of type double precision. The function executes a SELECT query on the Customer_Payments table, filtering records where the customer_id column matches the provided p_customer_id parameter and the datetime_payment column is greater than the current timestamp minus the interval defined by p_days_interval days. The query results are returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_recent_payments(p_customer_id bigint, p_days_interval integer)\nRETURNS TABLE(customer_id bigint, datetime_payment timestamp with time zone, amount_payment double precision)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Customer_Payments\".\"customer_id\", \"Customer_Payments\".\"datetime_payment\", \"Customer_Payments\".\"amount_payment\"\n    FROM \"Customer_Payments\"\n    WHERE \"Customer_Payments\".\"customer_id\" = p_customer_id\n    AND \"Customer_Payments\".\"datetime_payment\" > NOW() - INTERVAL '1 day' * p_days_interval;\nEND;\n$$;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT * FROM get_recent_payments(11, 30);",
      "SELECT * FROM get_recent_payments(2, 7);",
      "SELECT * FROM get_recent_payments(14, 90);",
      "SELECT * FROM get_recent_payments(1, 1);",
      "SELECT * FROM get_recent_payments(3, 60);"
    ],
    "summary": "Create a PL/pgSQL function named `get_recent_payments` that returns a table with columns `customer_id` (bigint), `datetime_payment` (timestamptz), and `amount_payment` (double precision). The function accepts `p_customer_id` (bigint) and `p_days_interval` (integer). It queries the `Customer_Payments` table where `customer_id` equals `p_customer_id` and `datetime_payment` is within the last `p_days_interval` days from the current timestamp.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_recent_payments`. This function shall yield a table comprising the following columns: `customer_id` of type bigint, `datetime_payment` of type timestamptz, and `amount_payment` of type double precision. The function must accept two input parameters: `p_customer_id` as a bigint and `p_days_interval` as an integer. Its operational logic is to query the `Customer_Payments` table, retrieving records where the `customer_id` matches the provided `p_customer_id` parameter and where the `datetime_payment` falls within the specified number of days (`p_days_interval`) preceding the current timestamp.",
    "id": 58,
    "generated_ir": "Write a PLpgSQL function that retrieves recent payment records from the Customer_Payments table for a specified customer and within a given time interval. The function, named get_recent_payments, accepts two parameters: p_customer_id of type bigint, which represents the unique identifier of the customer whose payment records are to be fetched, and p_days_interval of type integer, which specifies the number of days to look back from the current date to filter the payment records. The function returns a table with three columns: customer_id of type bigint, datetime_payment of type timestamp with time zone, and amount_payment of type double precision. The function executes a SELECT query on the Customer_Payments table, filtering records where the customer_id column matches the provided p_customer_id parameter and the datetime_payment column is greater than the current timestamp minus the interval defined by p_days_interval days. The query results are returned as the output of the function."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_grade_stats` that accepts a single input parameter named `p_classroom` of data type `bigint`. This function is designed to compute and return a `numeric` value. Upon execution, the function first declares two local variables: `v_avg_grade` of data type `numeric` and `v_min_grade` of data type `bigint`. The function then proceeds to perform two separate `SELECT` operations. The first `SELECT` statement calculates the average of the values in the `\"Grade\"` column from the table named `list`, specifically for rows where the value in the `\"Classroom\"` column is equal to the value provided in the `p_classroom` input parameter. The result of this average calculation is assigned to the local variable `v_avg_grade`. The second `SELECT` statement calculates the minimum value in the `\"Grade\"` column from the table named `list`, again specifically for rows where the value in the `\"Classroom\"` column is equal to the value provided in the `p_classroom` input parameter. The result of this minimum calculation is assigned to the local variable `v_min_grade`. Finally, the function returns the sum of the values stored in `v_avg_grade` and `v_min_grade`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_grade_stats(p_classroom bigint)\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_avg_grade numeric;\n    v_min_grade bigint;\nBEGIN\n    v_avg_grade := (SELECT AVG(\"Grade\") FROM list WHERE \"Classroom\" = p_classroom);\n    v_min_grade := (SELECT MIN(\"Grade\") FROM list WHERE \"Classroom\" = p_classroom);\n    RETURN v_avg_grade + v_min_grade;\nEND;\n$$;",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "SELECT calculate_grade_stats(101);",
      "SELECT calculate_grade_stats(112);",
      "SELECT calculate_grade_stats(107);",
      "SELECT calculate_grade_stats(102);",
      "SELECT calculate_grade_stats(103);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_grade_stats` that takes a `bigint` parameter `p_classroom`. It calculates the average and minimum `\"Grade\"` from the `list` table for that classroom, storing them in local variables. The function returns the sum of the average and minimum grade.",
    "natural_language": "Write a PL/pgSQL function called `calculate_grade_stats` that accepts a `bigint` parameter `p_classroom`. Compute the average and minimum `\"Grade\"` from the `list` table for the specified classroom, storing the results in local variables. Then, return the sum of the computed average and minimum grade.",
    "id": 59,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `calculate_grade_stats` that accepts a single input parameter named `p_classroom` of data type `bigint`. This function is designed to compute and return a `numeric` value. Upon execution, the function first declares two local variables: `v_avg_grade` of data type `numeric` and `v_min_grade` of data type `bigint`. The function then proceeds to perform two separate `SELECT` operations. The first `SELECT` statement calculates the average of the values in the `\"Grade\"` column from the table named `list`, specifically for rows where the value in the `\"Classroom\"` column is equal to the value provided in the `p_classroom` input parameter. The result of this average calculation is assigned to the local variable `v_avg_grade`. The second `SELECT` statement calculates the minimum value in the `\"Grade\"` column from the table named `list`, again specifically for rows where the value in the `\"Classroom\"` column is equal to the value provided in the `p_classroom` input parameter. The result of this minimum calculation is assigned to the local variable `v_min_grade`. Finally, the function returns the sum of the values stored in `v_avg_grade` and `v_min_grade`."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_round_theme_by_member` that accepts a single input parameter. This parameter, named `member_id`, is of the `integer` data type and represents the unique identifier for a member. The function is designed to return a single value of the `text` data type, which will represent the decoration theme associated with a specific round.\n\nUpon execution, the function declares a local variable named `theme` of the `text` data type. This variable is used to temporarily store the retrieved decoration theme. The core operation of the function is a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"Decoration_Theme\"` from the table named `\"round\"`. The retrieval is conditional, meaning only rows that satisfy a specific criterion are considered. The condition for selection is that the value in the column named `\"Member_ID\"` within the `\"round\"` table must be equal to the value provided by the input parameter `member_id`. The single value retrieved from the `\"Decoration_Theme\"` column of the matching row is then assigned to the local variable `theme`. Finally, the function returns the value currently stored in the `theme` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_round_theme_by_member(member_id integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  theme text;\nBEGIN\n  SELECT \"Decoration_Theme\" INTO theme FROM \"round\" WHERE \"Member_ID\" = member_id;\n  RETURN theme;\nEND;\n$$;",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "SELECT get_round_theme_by_member(1);",
      "SELECT get_round_theme_by_member(2);",
      "SELECT get_round_theme_by_member(10);",
      "SELECT get_round_theme_by_member(3);",
      "SELECT get_round_theme_by_member(5);"
    ],
    "summary": "Create a PL/pgSQL function named get_round_theme_by_member that takes an integer parameter 'member_id' and returns text. Select the \"Decoration_Theme\" from the \"round\" table where \"Member_ID\" equals the input parameter and return the value.",
    "natural_language": "Function get_round_theme_by_member(member_id integer) returns text. Fetch Decoration_Theme from round where Member_ID matches given member_id.",
    "id": 60,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_round_theme_by_member` that accepts a single input parameter. This parameter, named `member_id`, is of the `integer` data type and represents the unique identifier for a member. The function is designed to return a single value of the `text` data type, which will represent the decoration theme associated with a specific round.\n\nUpon execution, the function declares a local variable named `theme` of the `text` data type. This variable is used to temporarily store the retrieved decoration theme. The core operation of the function is a `SELECT` statement. This `SELECT` statement retrieves the value from the column named `\"Decoration_Theme\"` from the table named `\"round\"`. The retrieval is conditional, meaning only rows that satisfy a specific criterion are considered. The condition for selection is that the value in the column named `\"Member_ID\"` within the `\"round\"` table must be equal to the value provided by the input parameter `member_id`. The single value retrieved from the `\"Decoration_Theme\"` column of the matching row is then assigned to the local variable `theme`. Finally, the function returns the value currently stored in the `theme` variable as its output."
  },
  {
    "ir": "Write a PLpgSQL function named get_distance_between_cities that accepts two input parameters, p_city1_code of type text and p_city2_code of type text, and returns a single bigint value; the function's logic consists of executing a SELECT query on the table named Direct_distance, specifically retrieving the value from the column named distance for the row where the column city1_code is equal to the first input parameter p_city1_code and simultaneously the column city2_code is equal to the second input parameter p_city2_code, and then returning that retrieved distance value directly as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_distance_between_cities(p_city1_code text, p_city2_code text)\nRETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT \"distance\" FROM \"Direct_distance\" WHERE \"city1_code\" = p_city1_code AND \"city2_code\" = p_city2_code);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_distance_between_cities('BAL', 'PIT');",
      "SELECT get_distance_between_cities('PHL', 'BAL');",
      "SELECT get_distance_between_cities('ATL', 'BKK');",
      "SELECT get_distance_between_cities('BAL', 'BAL');",
      "SELECT get_distance_between_cities('PIT', 'PHL');"
    ],
    "summary": "Create a PL/pgSQL function named get_distance_between_cities that takes two text parameters (p_city1_code, p_city2_code) and returns a bigint. The function selects the distance column from the Direct_distance table where city1_code equals p_city1_code and city2_code equals p_city2_code, then returns that value.",
    "natural_language": "Write a PL/pgSQL function called get_distance_between_cities that accepts a couple of text inputs for city codes and gives back a big integer. It should look in the Direct_distance table and return the distance value for when the city codes are roughly matching the provided ones.",
    "id": 61,
    "generated_ir": "Write a PLpgSQL function named get_distance_between_cities that accepts two input parameters, p_city1_code of type text and p_city2_code of type text, and returns a single bigint value; the function's logic consists of executing a SELECT query on the table named Direct_distance, specifically retrieving the value from the column named distance for the row where the column city1_code is equal to the first input parameter p_city1_code and simultaneously the column city2_code is equal to the second input parameter p_city2_code, and then returning that retrieved distance value directly as the function's result."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `find_shop_with_max_stock` that accepts a single input parameter, `p_device_id`, which is of type `integer`. The purpose of this function is to identify and return the `Shop_ID` of the shop that holds the maximum quantity of a specific device. Inside the function, a local variable named `v_shop_id` of type `integer` is declared to temporarily store the retrieved `Shop_ID`. The core operation involves executing a `SELECT` statement to query the table named `\"stock\"`. This `SELECT` statement retrieves the value from the `\"Shop_ID\"` column. The `WHERE` clause filters the rows in the `\"stock\"` table, considering only those where the value in the `\"Device_ID\"` column is equal to the value provided by the input parameter `p_device_id`. The results of this filtered selection are then ordered in descending order based on the values in the `\"Quantity\"` column. Finally, the `LIMIT 1` clause restricts the output to only the first row after sorting, which corresponds to the shop with the highest quantity for the specified device. The `INTO v_shop_id` clause assigns the `\"Shop_ID\"` value from this single selected row into the local variable `v_shop_id`. After the `SELECT` statement completes, the function returns the value stored in `v_shop_id` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION find_shop_with_max_stock(p_device_id integer) RETURNS integer AS $$\nDECLARE\n    v_shop_id integer;\nBEGIN\n    SELECT \"Shop_ID\" INTO v_shop_id FROM \"stock\" WHERE \"Device_ID\" = p_device_id ORDER BY \"Quantity\" DESC LIMIT 1;\n    RETURN v_shop_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "device",
    "tables": [
      "device",
      "shop",
      "stock"
    ],
    "call_sqls": [
      "SELECT find_shop_with_max_stock(1);",
      "SELECT find_shop_with_max_stock(2);",
      "SELECT find_shop_with_max_stock(3);",
      "SELECT find_shop_with_max_stock(6);",
      "SELECT find_shop_with_max_stock(10);"
    ],
    "summary": "Create a function named find_shop_with_max_stock that takes a device ID as input and returns the shop ID that has the highest quantity of that device in the stock table.",
    "natural_language": "Function find_shop_with_max_stock: input device ID, output shop ID with highest device quantity in stock.",
    "id": 62,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named find_shop_with_max_stock that returns an integer value, which is the shop ID of the shop with the highest quantity of a specific device in stock. The function accepts one input parameter: a device ID of type integer, representing the device for which we want to find the shop with the maximum stock quantity. The function begins by declaring a variable to hold the resulting shop ID, such as v_shop_id of type integer. Then, it executes a SQL query that selects the Shop_ID from the stock table where the Device_ID column matches the provided input device ID, grouping the results by Shop_ID to aggregate quantities, and ordering the aggregated quantities in descending order to find the maximum. Specifically, the query sums the Quantity column for each Shop_ID where Device_ID equals the input parameter, then orders these summed quantities in descending order, and finally limits the result to the first row to retrieve the Shop_ID with the highest total quantity. If multiple shops have the same highest quantity, the function returns the first one based on the order, which could be arbitrary unless further ordering is specified. If no stock records exist for the given device ID, the function returns NULL. The function then assigns the selected Shop_ID to the v_shop_id variable and returns this value as the function's output."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_actor_producer_stats that takes a single integer input parameter named p_birth_year and returns a table with three columns: total_actors of type BIGINT, total_producers of type BIGINT, and avg_birth_year of type NUMERIC. The function's logic is determined by conditional branching based on the value of p_birth_year. If p_birth_year is less than 1950, the function executes a query that selects from the actor table, counting all rows where the birth_year column is less than 1950 to populate total_actors, hardcoding total_producers as 0, and calculating the rounded average of the birth_year column for those rows to two decimal places for avg_birth_year. If p_birth_year is between 1950 and 1980 inclusive, the function executes a query that selects from the actor table, counting all rows where the birth_year column is between 1950 and 1980 inclusive to populate both total_actors and total_producers, and calculating the rounded average of the birth_year column for those rows to two decimal places for avg_birth_year. If p_birth_year is greater than 1980, the function executes a query that performs a FULL OUTER JOIN between the actor table (aliased as a) and the producer table (aliased as p) on the condition that a.nationality equals p.nationality, where the filter condition is that either a.birth_year is greater than 1980 or p.birth_year is greater than 1980; from this result set, it calculates total_actors as the distinct count of a.aid, total_producers as the distinct count of p.pid, and avg_birth_year as the rounded average to two decimal places of a COALESCE operation that takes a.birth_year if not null, otherwise p.birth_year. For any other input value of p_birth_year, which specifically handles the NULL case or exact values not caught by the previous branches, the function returns a single row with all three output columns hardcoded to zero.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_producer_stats(p_birth_year INTEGER)\nRETURNS TABLE(total_actors BIGINT, total_producers BIGINT, avg_birth_year NUMERIC) AS $$\nBEGIN\n    IF p_birth_year < 1950 THEN\n        RETURN QUERY SELECT COUNT(*) as total_actors, 0::BIGINT as total_producers, ROUND(AVG(birth_year), 2) as avg_birth_year FROM actor WHERE birth_year < 1950;\n    ELSIF p_birth_year BETWEEN 1950 AND 1980 THEN\n        RETURN QUERY SELECT COUNT(*) as total_actors, COUNT(*) as total_producers, ROUND(AVG(birth_year), 2) as avg_birth_year FROM actor WHERE birth_year BETWEEN 1950 AND 1980;\n    ELSIF p_birth_year > 1980 THEN\n        RETURN QUERY SELECT COUNT(DISTINCT a.aid) as total_actors, COUNT(DISTINCT p.pid) as total_producers, ROUND(AVG(COALESCE(a.birth_year, p.birth_year)), 2) as avg_birth_year FROM actor a FULL OUTER JOIN producer p ON a.nationality = p.nationality WHERE a.birth_year > 1980 OR p.birth_year > 1980;\n    ELSE\n        RETURN QUERY SELECT 0::BIGINT as total_actors, 0::BIGINT as total_producers, 0::NUMERIC as avg_birth_year;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "producer",
      "made_by",
      "company"
    ],
    "call_sqls": [
      "SELECT * FROM get_actor_producer_stats(1940);",
      "SELECT * FROM get_actor_producer_stats(1955);",
      "SELECT * FROM get_actor_producer_stats(1990);",
      "SELECT * FROM get_actor_producer_stats(NULL);",
      "SELECT total_actors, total_producers, avg_birth_year FROM get_actor_producer_stats(1975);"
    ],
    "summary": "Create a PL/pgSQL function named get_actor_producer_stats that takes an integer parameter p_birth_year and returns a table with columns total_actors (BIGINT), total_producers (BIGINT), and avg_birth_year (NUMERIC). If p_birth_year < 1950, count actors with birth_year < 1950, set producers to 0, and calculate the rounded average birth_year. If p_birth_year is between 1950 and 1980 inclusive, count actors and producers with birth_year in that range and calculate the rounded average. If p_birth_year > 1980, perform a FULL OUTER JOIN between actor and producer tables on nationality where either birth_year > 1980, then calculate distinct counts and the rounded average of birth years. For any other input (including NULL), return a row with all zeros.",
    "natural_language": "Write a function called get_actor_producer_stats that takes a birth year number. It should give back a table with the total number of actors, total number of producers, and an average birth year. The way it counts things depends on the input year in a kind of fuzzy way. If the given year is pretty old, like before 1950, then just count the older actors and ignore producers, also figure out the typical birth year from that group. If the year is sort of in the middle, say between 1950 and around 1980, then count both actors and producers from roughly that era and get their average year. For more recent years, after 1980, you need to loosely combine data from actors and producers based on where they're from, but only for the newer people, then count them and find an average. If the input is weird or missing, just return zeros for everything.",
    "id": 63,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_actor_producer_stats that operates on the imdb database. The function accepts a single input parameter, input_birth_year of type integer, representing the birth year number provided. It returns a table with three columns: total_actors of type integer, total_producers of type integer, and avg_birth_year of type numeric, which holds the average birth year calculated.\n\nThe function declares three local variables: actor_count of type integer to store the total number of actors, producer_count of type integer to store the total number of producers, and average_year of type numeric to store the computed average birth year.\n\nThe function implements conditional logic based on the input_birth_year parameter, using IF-ELSIF-ELSE statements to handle different ranges with fuzzy matching.\n\nIf input_birth_year is less than 1950, the function counts only actors whose birth_year is less than or equal to input_birth_year, ignoring producers entirely. It executes a SELECT query on the actor table to count the number of rows where birth_year is less than or equal to input_birth_year, storing the result in actor_count. It also calculates the average birth_year from the same filtered actor rows, storing it in average_year. The producer_count is set to 0.\n\nIf input_birth_year is between 1950 and 1980 (inclusive), the function counts both actors and producers whose birth_year is within a range of plus or minus 5 years from input_birth_year, i.e., between input_birth_year - 5 and input_birth_year + 5. It executes two separate SELECT queries: one on the actor table to count rows where birth_year is within this range, storing the count in actor_count, and another on the producer table to count rows where birth_year is within the same range, storing the count in producer_count. It then calculates the average birth_year by combining data from both tables: it performs a SELECT query that unions the birth_year values from the actor and producer tables filtered by the same range, computes the average of these combined birth_year values, and stores it in average_year.\n\nIf input_birth_year is greater than 1980, the function counts actors and producers whose birth_year is greater than or equal to input_birth_year, but only includes those where the nationality column matches between the actor and producer tables. It executes a SELECT query that joins the actor and producer tables on the nationality column, counting distinct actor.aid values to get actor_count and distinct producer.pid values to get producer_count, where both actor.birth_year and producer.birth_year are greater than or equal to input_birth_year. It then calculates the average birth_year by taking the average of birth_year from the combined set of matching actors and producers, storing it in average_year.\n\nIf input_birth_year is NULL or does not fit into any of the above categories (e.g., a negative value or other edge cases), the function sets actor_count, producer_count, and average_year all to 0.\n\nFinally, the function returns a single row with the values of actor_count as total_actors, producer_count as total_producers, and average_year as avg_birth_year in the output table."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_gymnast_average_points` that accepts two input parameters: `gymnast_id` of type `integer` and `event_name` of type `text`. This function is designed to calculate and return the average points for a specific gymnast in a particular event, with the return type being `real`.\n\nUpon execution, the function declares a local variable named `average_points` of type `real` to store the calculated average. The core logic of the function is implemented using a series of conditional statements (`IF...ELSIF...ELSE`) that evaluate the value of the `event_name` parameter.\n\nIf the `event_name` is exactly equal to the string literal 'Floor_Exercise', the function executes a `SELECT` statement to calculate the average of the values in the `\"Floor_Exercise_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise' but is exactly equal to the string literal 'Pommel_Horse', the function executes a `SELECT` statement to calculate the average of the values in the `\"Pommel_Horse_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise' or 'Pommel_Horse' but is exactly equal to the string literal 'Rings', the function executes a `SELECT` statement to calculate the average of the values in the `\"Rings_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', or 'Rings' but is exactly equal to the string literal 'Vault', the function executes a `SELECT` statement to calculate the average of the values in the `\"Vault_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', 'Rings', or 'Vault' but is exactly equal to the string literal 'Parallel_Bars', the function executes a `SELECT` statement to calculate the average of the values in the `\"Parallel_Bars_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', 'Rings', 'Vault', or 'Parallel_Bars' but is exactly equal to the string literal 'Horizontal_Bar', the function executes a `SELECT` statement to calculate the average of the values in the `\"Horizontal_Bar_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` does not match any of the specified event names ('Floor_Exercise', 'Pommel_Horse', 'Rings', 'Vault', 'Parallel_Bars', 'Horizontal_Bar'), the `ELSE` block is executed, and the `average_points` variable is explicitly set to `NULL`.\n\nFinally, after the conditional logic has been processed and `average_points` has been assigned a value (either a calculated average or `NULL`), the function returns the value stored in the `average_points` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_average_points(gymnast_id integer, event_name text)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    average_points real;\nBEGIN\n    IF event_name = 'Floor_Exercise' THEN\n        SELECT AVG(\"Floor_Exercise_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Pommel_Horse' THEN\n        SELECT AVG(\"Pommel_Horse_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Rings' THEN\n        SELECT AVG(\"Rings_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Vault' THEN\n        SELECT AVG(\"Vault_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Parallel_Bars' THEN\n        SELECT AVG(\"Parallel_Bars_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Horizontal_Bar' THEN\n        SELECT AVG(\"Horizontal_Bar_Points\") INTO average_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSE\n        average_points := NULL;\n    END IF;\n    \n    RETURN average_points;\nEND;\n$$;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT get_gymnast_average_points(1, 'Floor_Exercise');",
      "SELECT get_gymnast_average_points(2, 'Pommel_Horse');",
      "SELECT get_gymnast_average_points(4, 'Rings');",
      "SELECT get_gymnast_average_points(1, 'Vault');",
      "SELECT get_gymnast_average_points(2, 'Horizontal_Bar');"
    ],
    "summary": "Create a PL/pgSQL function named get_gymnast_average_points that returns a real value. It takes a gymnast_id integer and an event_name text. Using conditional logic, calculate the average of the column corresponding to the event_name (e.g., 'Floor_Exercise' maps to Floor_Exercise_Points) from the gymnast table for the given gymnast_id. If the event_name is not recognized, return NULL.",
    "natural_language": "Hey, can you whip up a PL/pgSQL function called get_gymnast_average_points that spits back a real number? It needs a gymnast's ID (as an integer) and the name of an event (as text). Basically, you gotta use some IF/ELSE logic to figure out the average score for that specific event column in the gymnast table for that athlete. Like, if the event_name is 'Floor_Exercise', you'd average the Floor_Exercise_Points column. If someone throws in an event name we don't handle, just give back NULL.",
    "id": 64,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_gymnast_average_points` that accepts two input parameters: `gymnast_id` of type `integer` and `event_name` of type `text`. This function is designed to calculate and return the average points for a specific gymnast in a particular event, with the return type being `real`.\n\nUpon execution, the function declares a local variable named `average_points` of type `real` to store the calculated average. The core logic of the function is implemented using a series of conditional statements (`IF...ELSIF...ELSE`) that evaluate the value of the `event_name` parameter.\n\nIf the `event_name` is exactly equal to the string literal 'Floor_Exercise', the function executes a `SELECT` statement to calculate the average of the values in the `\"Floor_Exercise_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise' but is exactly equal to the string literal 'Pommel_Horse', the function executes a `SELECT` statement to calculate the average of the values in the `\"Pommel_Horse_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise' or 'Pommel_Horse' but is exactly equal to the string literal 'Rings', the function executes a `SELECT` statement to calculate the average of the values in the `\"Rings_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', or 'Rings' but is exactly equal to the string literal 'Vault', the function executes a `SELECT` statement to calculate the average of the values in the `\"Vault_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', 'Rings', or 'Vault' but is exactly equal to the string literal 'Parallel_Bars', the function executes a `SELECT` statement to calculate the average of the values in the `\"Parallel_Bars_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` is not 'Floor_Exercise', 'Pommel_Horse', 'Rings', 'Vault', or 'Parallel_Bars' but is exactly equal to the string literal 'Horizontal_Bar', the function executes a `SELECT` statement to calculate the average of the values in the `\"Horizontal_Bar_Points\"` column from the `\"gymnast\"` table. This average is calculated only for rows where the `\"Gymnast_ID\"` column matches the value provided in the `gymnast_id` input parameter. The resulting average value is then assigned to the `average_points` variable.\n\nIf the `event_name` does not match any of the specified event names ('Floor_Exercise', 'Pommel_Horse', 'Rings', 'Vault', 'Parallel_Bars', 'Horizontal_Bar'), the `ELSE` block is executed, and the `average_points` variable is explicitly set to `NULL`.\n\nFinally, after the conditional logic has been processed and `average_points` has been assigned a value (either a calculated average or `NULL`), the function returns the value stored in the `average_points` variable."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_wedding_church_name` that accepts three input parameters: `p_male_id` of type `integer`, representing the unique identifier for the male participant in a wedding; `p_female_id` of type `integer`, representing the unique identifier for the female participant in a wedding; and `p_year` of type `integer`, representing the year in which the wedding took place. This function is designed to return a single value of type `text`, which will be the name of the church where a specific wedding occurred. The function's core operation involves executing a `SELECT` statement to retrieve data. Specifically, it selects the value from the `\"Name\"` column of the `church` table. This selection is performed by joining the `church` table (aliased as `c`) with the `wedding` table (aliased as `w`). The join condition establishes a link between these two tables where the value in the `\"Church_ID\"` column of the `church` table is equal to the value in the `\"Church_ID\"` column of the `wedding` table. Furthermore, the `SELECT` statement includes a `WHERE` clause to filter the results. This `WHERE` clause specifies three conditions that must all be met for a row to be included in the result set: first, the value in the `\"Male_ID\"` column of the `wedding` table must be equal to the `p_male_id` input parameter; second, the value in the `\"Female_ID\"` column of the `wedding` table must be equal to the `p_female_id` input parameter; and third, the value in the `\"Year\"` column of the `wedding` table must be equal to the `p_year` input parameter. The function then returns the single `text` value obtained from this `SELECT` query.",
    "plsql": "CREATE OR REPLACE FUNCTION get_wedding_church_name(p_male_id integer, p_female_id integer, p_year integer)\nRETURNS text AS $$\nBEGIN\n    RETURN (SELECT c.\"Name\" FROM church c JOIN wedding w ON c.\"Church_ID\" = w.\"Church_ID\" WHERE w.\"Male_ID\" = p_male_id AND w.\"Female_ID\" = p_female_id AND w.\"Year\" = p_year);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "SELECT get_wedding_church_name(1, 2, 2014);",
      "SELECT get_wedding_church_name(3, 4, 2015);",
      "SELECT get_wedding_church_name(5, 6, 2016);",
      "SELECT get_wedding_church_name(7, 8, 2017);",
      "SELECT get_wedding_church_name(9, 10, 2018);"
    ],
    "summary": "Create a PL/pgSQL function named `get_wedding_church_name` that takes three `integer` parameters: `p_male_id`, `p_female_id`, and `p_year`. It retrieves the church `\"Name\"` by joining the `wedding` and `church` tables on `\"Church_ID\"`, where the wedding's `\"Male_ID\"`, `\"Female_ID\"`, and `\"Year\"` match the input parameters. The function returns the church name as `text`.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_wedding_church_name`. This function shall accept three integer parameters: `p_male_id`, `p_female_id`, and `p_year`. Its purpose is to retrieve the `\"Name\"` of a church by performing an inner join between the `wedding` and `church` tables, utilizing the `\"Church_ID\"` column as the join condition. The selection must be constrained to records where the wedding's `\"Male_ID\"`, `\"Female_ID\"`, and `\"Year\"` correspond precisely to the provided input parameters. The function is to return the church name as a text data type.",
    "id": 65,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_wedding_church_name` that accepts three input parameters: `p_male_id` of type `integer`, representing the unique identifier for the male participant in a wedding; `p_female_id` of type `integer`, representing the unique identifier for the female participant in a wedding; and `p_year` of type `integer`, representing the year in which the wedding took place. This function is designed to return a single value of type `text`, which will be the name of the church where a specific wedding occurred. The function's core operation involves executing a `SELECT` statement to retrieve data. Specifically, it selects the value from the `\"Name\"` column of the `church` table. This selection is performed by joining the `church` table (aliased as `c`) with the `wedding` table (aliased as `w`). The join condition establishes a link between these two tables where the value in the `\"Church_ID\"` column of the `church` table is equal to the value in the `\"Church_ID\"` column of the `wedding` table. Furthermore, the `SELECT` statement includes a `WHERE` clause to filter the results. This `WHERE` clause specifies three conditions that must all be met for a row to be included in the result set: first, the value in the `\"Male_ID\"` column of the `wedding` table must be equal to the `p_male_id` input parameter; second, the value in the `\"Female_ID\"` column of the `wedding` table must be equal to the `p_female_id` input parameter; and third, the value in the `\"Year\"` column of the `wedding` table must be equal to the `p_year` input parameter. The function then returns the single `text` value obtained from this `SELECT` query."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_student_enrolment_status that accepts a single input parameter called student_id_input of type BIGINT, which represents the unique identifier of a student, and returns a value of type TEXT; the function declares a local variable named enrolment_status of type TEXT to store the result; it performs a SELECT query on the table named \"Student_Course_Enrolment\" (aliased as e), specifically counting the number of registration_id values for rows where the student_id column matches the provided student_id_input parameter; the query uses a CASE expression to evaluate the result of the COUNT(e.registration_id) aggregation: if the count is greater than zero, the expression yields the string literal 'Enrolled', otherwise it yields the string literal 'Not Enrolled'; the result of this CASE expression is assigned into the enrolment_status variable via a SELECT INTO statement; finally, the function returns the value stored in the enrolment_status variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_enrolment_status(student_id_input BIGINT)\nRETURNS TEXT AS $$\nDECLARE\n  enrolment_status TEXT;\nBEGIN\n  SELECT CASE \n           WHEN COUNT(e.registration_id) > 0 THEN 'Enrolled'\n           ELSE 'Not Enrolled'\n         END INTO enrolment_status\n  FROM \"Student_Course_Enrolment\" e\n  WHERE e.student_id = student_id_input;\n\n  RETURN enrolment_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_student_enrolment_status(1);",
      "SELECT get_student_enrolment_status(11);",
      "SELECT get_student_enrolment_status(15);",
      "SELECT get_student_enrolment_status(100);",
      "SELECT get_student_enrolment_status(3);"
    ],
    "summary": "Create a function named get_student_enrolment_status that takes a student_id_input (BIGINT) and returns TEXT. It determines if the student is 'Enrolled' or 'Not Enrolled' by checking for any matching registration_id in the Student_Course_Enrolment table.",
    "natural_language": "Write a function called get_student_enrolment_status that accepts a student_id_input of type BIGINT and outputs TEXT. The function should check the Student_Course_Enrolment table for any matching registration_id and return 'Enrolled' if found, otherwise 'Not Enrolled'.",
    "id": 66,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_student_enrolment_status that accepts a single input parameter called student_id_input of type BIGINT, which represents the unique identifier of a student, and returns a value of type TEXT; the function declares a local variable named enrolment_status of type TEXT to store the result; it performs a SELECT query on the table named \"Student_Course_Enrolment\" (aliased as e), specifically counting the number of registration_id values for rows where the student_id column matches the provided student_id_input parameter; the query uses a CASE expression to evaluate the result of the COUNT(e.registration_id) aggregation: if the count is greater than zero, the expression yields the string literal 'Enrolled', otherwise it yields the string literal 'Not Enrolled'; the result of this CASE expression is assigned into the enrolment_status variable via a SELECT INTO statement; finally, the function returns the value stored in the enrolment_status variable."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_department_head_count that accepts a single integer input parameter named p_department_id, which represents the identifier of a specific department, and returns an integer value; within the function, a local integer variable v_count is declared, then a SELECT statement is executed to query the management table, specifically counting all rows where the value in the department_ID column exactly matches the provided p_department_id parameter value, and this resulting count is stored into the v_count variable, which is subsequently returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_head_count(p_department_id integer) RETURNS integer AS $$\nDECLARE\n    v_count integer;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM \"management\" WHERE \"department_ID\" = p_department_id;\n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "SELECT get_department_head_count(1);",
      "SELECT get_department_head_count(2);",
      "SELECT get_department_head_count(3);",
      "SELECT get_department_head_count(15);",
      "SELECT get_department_head_count(NULL);"
    ],
    "summary": "Create a PL/pgSQL function named `get_department_head_count` that accepts a department ID (integer) and returns an integer count of heads in that department by counting rows in the management table where the department_ID matches the input.",
    "natural_language": "Function `get_department_head_count` returns head count for a given department ID from management table.",
    "id": 67,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_department_head_count that accepts a single integer input parameter named p_department_id, which represents the identifier of a specific department, and returns an integer value; within the function, a local integer variable v_count is declared, then a SELECT statement is executed to query the management table, specifically counting all rows where the value in the department_ID column exactly matches the provided p_department_id parameter value, and this resulting count is stored into the v_count variable, which is subsequently returned as the function's output."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves specific address information for a customer based on provided parameters. The function, named get_customer_address_info, accepts two parameters: p_customer_id of type bigint, which represents the unique identifier of a customer, and p_city of type text, which specifies a city name or substring to filter the address records. The function returns a table with three columns: line_1_number_building, city, and zip_postcode, all of type text. The function performs a SELECT operation to extract data from the Addresses table, specifically the columns line_1_number_building, city, and zip_postcode. It joins the Customers table with the Addresses table using the condition that the customer_address_id column in the Customers table matches the address_id column in the Addresses table. The WHERE clause filters the results to include only those rows where the customer_id column in the Customers table equals the value of the p_customer_id parameter and the city column in the Addresses table contains the substring specified by the p_city parameter, using the strpos function to determine if p_city is present within the city column.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_address_info(p_customer_id bigint, p_city text)\nRETURNS TABLE(line_1_number_building text, city text, zip_postcode text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT \"Addresses\".\"line_1_number_building\", \"Addresses\".\"city\", \"Addresses\".\"zip_postcode\"\n    FROM \"Customers\"\n    JOIN \"Addresses\" ON \"Customers\".\"customer_address_id\" = \"Addresses\".\"address_id\"\n    WHERE \"Customers\".\"customer_id\" = p_customer_id\n    AND strpos(\"Addresses\".\"city\", p_city) > 0;\nEND;\n$$;",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Customer_Payments",
      "Addresses"
    ],
    "call_sqls": [
      "SELECT * FROM get_customer_address_info(1, 'Port Melyssa');",
      "SELECT * FROM get_customer_address_info(2, 'Hagenesfurt');",
      "SELECT * FROM get_customer_address_info(3, 'Lake Elaina');",
      "SELECT * FROM get_customer_address_info(1, 'Lake Elaina');",
      "SELECT * FROM get_customer_address_info(2, 'Port Melyssa');"
    ],
    "summary": "Create a PL/pgSQL function named `get_customer_address_info` that returns a table with columns `line_1_number_building`, `city`, and `zip_postcode` (all text). The function accepts `p_customer_id` (bigint) and `p_city` (text). It queries the `Addresses` table, joining with the `Customers` table on `address_id` = `customer_address_id`. Return rows where `customer_id` equals `p_customer_id` and the `city` column contains the substring `p_city`.",
    "natural_language": "What are the line_1_number_building, city, and zip_postcode details for a specific customer ID, filtered to addresses in a city containing a given substring?",
    "id": 68,
    "generated_ir": "Write a PLpgSQL function that retrieves specific address information for a customer based on provided parameters. The function, named get_customer_address_info, accepts two parameters: p_customer_id of type bigint, which represents the unique identifier of a customer, and p_city of type text, which specifies a city name or substring to filter the address records. The function returns a table with three columns: line_1_number_building, city, and zip_postcode, all of type text. The function performs a SELECT operation to extract data from the Addresses table, specifically the columns line_1_number_building, city, and zip_postcode. It joins the Customers table with the Addresses table using the condition that the customer_address_id column in the Customers table matches the address_id column in the Addresses table. The WHERE clause filters the results to include only those rows where the customer_id column in the Customers table equals the value of the p_customer_id parameter and the city column in the Addresses table contains the substring specified by the p_city parameter, using the strpos function to determine if p_city is present within the city column."
  },
  {
    "ir": "Write a PLpgSQL function named process_customer_status that accepts a single parameter p_master_id of type bigint, which represents the master customer ID. The function retrieves the cmi_details column from the Customer_Master_Index table where the master_customer_id matches the provided p_master_id. The retrieved value is stored in a local variable v_details of type text. The function then evaluates the length of v_details using conditional statements to determine the appropriate status. If v_details is null, the function assigns the text 'NO_DETAILS' to the local variable v_status. If the length of v_details exceeds 100 characters, v_status is set to 'LONG_DETAILS'. If the length is greater than 50 but less than or equal to 100, v_status is set to 'MEDIUM_DETAILS'. If the length is greater than 20 but less than or equal to 50, v_status is set to 'SHORT_DETAILS'. If the length is 20 or fewer characters, v_status is set to 'VERY_SHORT_DETAILS'. Finally, the function returns the value of v_status as the result.",
    "plsql": "CREATE OR REPLACE FUNCTION process_customer_status(p_master_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_details text;\n    v_status text;\nBEGIN\n    SELECT cmi_details INTO v_details FROM \"Customer_Master_Index\" WHERE master_customer_id = p_master_id;\n\n    IF v_details IS NULL THEN\n        v_status := 'NO_DETAILS';\n    ELSIF LENGTH(v_details) > 100 THEN\n        v_status := 'LONG_DETAILS';\n    ELSIF LENGTH(v_details) > 50 THEN\n        v_status := 'MEDIUM_DETAILS';\n    ELSIF LENGTH(v_details) > 20 THEN\n        v_status := 'SHORT_DETAILS';\n    ELSE\n        v_status := 'VERY_SHORT_DETAILS';\n    END IF;\n\n    RETURN v_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Council_Tax",
      "CMI_Cross_References",
      "Customer_Master_Index"
    ],
    "call_sqls": [
      "SELECT process_customer_status(1);",
      "SELECT process_customer_status(2);",
      "SELECT process_customer_status(3);",
      "SELECT process_customer_status(4);",
      "SELECT process_customer_status(5);"
    ],
    "summary": "Create a PL/pgSQL function named process_customer_status that takes a master_id (bigint) and returns a text status. It retrieves the cmi_details from the Customer_Master_Index table. The status is determined by the length of the details: 'NO_DETAILS' if null, 'LONG_DETAILS' if >100, 'MEDIUM_DETAILS' if >50 and <=100, 'SHORT_DETAILS' if >20 and <=50, else 'VERY_SHORT_DETAILS'.",
    "natural_language": "Develop a comprehensive PL/pgSQL function, which should be named process_customer_status, that is designed to accept a single input parameter of type bigint representing a master_id and subsequently returns a text value indicating a status. This function must first retrieve the cmi_details field from the Customer_Master_Index table corresponding to the provided identifier. The status is then meticulously determined by evaluating the length of the retrieved details string: it should return 'NO_DETAILS' if the details are null, 'LONG_DETAILS' if the character count exceeds 100, 'MEDIUM_DETAILS' if the length is greater than 50 but does not exceed 100, 'SHORT_DETAILS' for lengths greater than 20 and up to 50 characters, and finally 'VERY_SHORT_DETAILS' for any remaining cases where the length is 20 characters or less.",
    "id": 69,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named process_customer_status that accepts a single input parameter named master_id of type bigint, which is used to identify a specific customer record, and returns a text value representing a status category. The function operates within the local_govt_mdm database. It begins by retrieving the cmi_details field from the Customer_Master_Index table, specifically selecting the cmi_details column where the master_customer_id column equals the provided master_id input parameter. The function then evaluates the retrieved cmi_details string to determine its status based on length. If the cmi_details value is null, the function returns the text 'NO_DETAILS'. If the cmi_details is not null, the function calculates its character length using the length function. If the length exceeds 100 characters, the function returns 'LONG_DETAILS'. If the length is greater than 50 but does not exceed 100, the function returns 'MEDIUM_DETAILS'. If the length is greater than 20 but is 50 or less, the function returns 'SHORT_DETAILS'. For any remaining case where the length is 20 characters or less, the function returns 'VERY_SHORT_DETAILS'. The function does not perform any data modification operations such as INSERT, UPDATE, or DELETE; it only reads from the Customer_Master_Index table and returns a computed text status based on the conditional logic applied to the length of the cmi_details field."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_reviewer_average` that accepts a single input parameter named `reviewer_id` of type `integer`. This function is designed to compute and return the average rating (represented as a numeric value) for a specific reviewer identified by the provided `reviewer_id`. The function initializes a local variable named `total_stars` of type `integer` to `0` and another local variable named `avg_rating` of type `numeric` to `0.0`. The first operation performed is a `SELECT` statement that queries the `Rating` table. This `SELECT` statement calculates the sum of all values in the `stars` column for rows where the `rID` column matches the input `reviewer_id`. The `COALESCE` function is applied to this sum, ensuring that if no matching rows are found (and thus `SUM` returns `NULL`), the `total_stars` variable is assigned `0` instead of `NULL`. The result of this sum (or `0`) is then stored into the `total_stars` local variable. Following this, the `avg_rating` local variable is assigned a calculated value. This calculation involves dividing the `total_stars` by the greater of two values: either the count of rows in the `Rating` table where the `rID` column matches the input `reviewer_id`, or `1`. The `GREATEST` function is used to ensure that the divisor is never zero, preventing a division-by-zero error. The `COUNT(*)` aggregate function is used to determine the number of ratings for the specified reviewer. The entire division result is then rounded to two decimal places using the `ROUND` function. Finally, the function returns the calculated `avg_rating` value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_reviewer_average(\"reviewer_id\" integer)\nRETURNS numeric AS $$\nDECLARE\n    \"total_stars\" integer := 0;\n    \"avg_rating\" numeric := 0.0;\nBEGIN\n    SELECT COALESCE(SUM(\"stars\"), 0) INTO \"total_stars\" FROM \"Rating\" WHERE \"rID\" = \"reviewer_id\";\n    \"avg_rating\" := ROUND(\"total_stars\" / GREATEST((SELECT COUNT(*) FROM \"Rating\" WHERE \"rID\" = \"reviewer_id\"), 1), 2);\n    RETURN \"avg_rating\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "SELECT calculate_reviewer_average(201);",
      "SELECT calculate_reviewer_average(202);",
      "SELECT calculate_reviewer_average(203);",
      "SELECT calculate_reviewer_average(204);",
      "SELECT calculate_reviewer_average(205);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `calculate_reviewer_average` that takes an INTEGER parameter `reviewer_id` and returns NUMERIC. Calculate the average stars for the reviewer, using COALESCE to handle NULL sums and GREATEST to prevent division by zero. Round the result to two decimal places.",
    "natural_language": "Please construct a PostgreSQL PL/pgSQL function designated `calculate_reviewer_average`. This function shall accept a single INTEGER parameter, `reviewer_id`, and yield a NUMERIC value. The function's logic must compute the average star rating associated with the specified reviewer. It is required to employ the COALESCE function to manage potential NULL values in the sum of stars and the GREATEST function to safeguard against division by zero. The final computed average must be rounded to two decimal places.",
    "id": 70,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_reviewer_average that accepts a single input parameter reviewer_id of type integer and returns a numeric value. The function computes the average star rating for the specified reviewer by first declaring a numeric variable v_avg_stars to hold the result. It then calculates the average by executing a SQL query that selects from the Rating table, using the COALESCE function to handle potential NULL values in the sum of the stars column and the GREATEST function to prevent division by zero. Specifically, the query computes the sum of the stars column for all rows in the Rating table where the rID column equals the provided reviewer_id parameter, and divides this sum by the count of such rows, ensuring the divisor is at least 1 to avoid division by zero. The COALESCE function wraps the sum of stars to return 0 if the sum is NULL (i.e., if no ratings exist for the reviewer). The result is rounded to two decimal places using the ROUND function. The computed value is assigned to v_avg_stars, and the function returns this variable as the output. The function operates on the movie_1 database, using the Rating table with columns rID and stars, and does not involve other tables or joins since only the Rating table is needed to compute the average based on the reviewer's ID."
  },
  {
    "ir": "Write a PLpgSQL function named check_rating_exists that accepts two integer input parameters, the first named reviewer_id and the second named movie_id, and returns a boolean value; within the function, it declares a local integer variable named rating_exists initialized to zero and a local boolean variable named result_flag initialized to false; the function executes a SELECT statement that queries the Rating table, using the COUNT(*) aggregate function to count the number of rows where the rID column value equals the input reviewer_id parameter and the mID column value equals the input movie_id parameter, and stores the resulting count into the rating_exists variable; it then evaluates the condition rating_exists > 0, assigning the boolean result of this comparison to the result_flag variable; finally, the function returns the value of the result_flag variable.",
    "plsql": "CREATE OR REPLACE FUNCTION check_rating_exists(\"reviewer_id\" integer, \"movie_id\" integer)\nRETURNS boolean AS $$\nDECLARE\n    \"rating_exists\" integer := 0;\n    \"result_flag\" boolean := false;\nBEGIN\n    SELECT COUNT(*) INTO \"rating_exists\" FROM \"Rating\" WHERE \"rID\" = \"reviewer_id\" AND \"mID\" = \"movie_id\";\n    \"result_flag\" := \"rating_exists\" > 0;\n    RETURN \"result_flag\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "SELECT check_rating_exists(201, 101);",
      "SELECT check_rating_exists(202, 106);",
      "SELECT check_rating_exists(203, 101);",
      "SELECT check_rating_exists(201, 102);",
      "SELECT check_rating_exists(202, 103);"
    ],
    "summary": "Create a PLpgSQL function named check_rating_exists that takes reviewer_id and movie_id as integer parameters and returns a boolean. It should check if a rating exists in the Rating table for the given reviewer and movie ID, returning true if found and false otherwise.",
    "natural_language": "Write a PLpgSQL function called check_rating_exists that uses integer inputs for reviewer and movie. It should see if there's any kind of rating in the Rating table for those IDs, giving back true if there seems to be one and false if it looks like there isn't.",
    "id": 71,
    "generated_ir": "Write a PLpgSQL function named check_rating_exists that accepts two integer input parameters, the first named reviewer_id and the second named movie_id, and returns a boolean value; within the function, it declares a local integer variable named rating_exists initialized to zero and a local boolean variable named result_flag initialized to false; the function executes a SELECT statement that queries the Rating table, using the COUNT(*) aggregate function to count the number of rows where the rID column value equals the input reviewer_id parameter and the mID column value equals the input movie_id parameter, and stores the resulting count into the rating_exists variable; it then evaluates the condition rating_exists > 0, assigning the boolean result of this comparison to the result_flag variable; finally, the function returns the value of the result_flag variable."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_customer_total_payments that accepts a single input parameter p_customer_id of type bigint, which is used to identify a specific customer, and returns a value of type double precision; the function's body executes a single SQL query that selects from the table named \"Customer_Payments\", applying a filter condition where the column customer_id must exactly equal the provided input parameter p_customer_id, and within that filtered result set, it calculates the sum of all values in the amount_payment column; the COALESCE function is then applied to this sum result to handle cases where the query returns a NULL valueâ€”such as when no matching rows are found for the given customer_idâ€”by converting that NULL to the numeric value 0; this final computed result, which represents the total sum of payment amounts for the specified customer or zero if no payments exist, is immediately returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_total_payments(p_customer_id bigint)\nRETURNS double precision AS $$\nBEGIN\n    RETURN (SELECT COALESCE(SUM(amount_payment), 0) FROM \"Customer_Payments\" WHERE customer_id = p_customer_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Addresses",
      "Customer_Payments",
      "Customers",
      "Lessons",
      "Staff",
      "Vehicles"
    ],
    "call_sqls": [
      "SELECT get_customer_total_payments(11);",
      "SELECT get_customer_total_payments(2);",
      "SELECT get_customer_total_payments(14);",
      "SELECT get_customer_total_payments(1);",
      "SELECT get_customer_total_payments(3);"
    ],
    "summary": "Create a function named get_customer_total_payments that takes a customer ID. Return the sum of all payment amounts for that customer from the Customer_Payments table, or 0 if no payments are found.",
    "natural_language": "Define a function designated as 'get_customer_total_payments' that accepts a customer ID as its input parameter. The function shall compute and return the aggregate sum of all payment amounts associated with the specified customer, as recorded in the Customer_Payments table. In the event that no corresponding payments are located, the function must return a value of zero.",
    "id": 72,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_customer_total_payments that accepts a single input parameter p_customer_id of type bigint, which is used to identify a specific customer, and returns a value of type double precision; the function's body executes a single SQL query that selects from the table named \"Customer_Payments\", applying a filter condition where the column customer_id must exactly equal the provided input parameter p_customer_id, and within that filtered result set, it calculates the sum of all values in the amount_payment column; the COALESCE function is then applied to this sum result to handle cases where the query returns a NULL valueâ€”such as when no matching rows are found for the given customer_idâ€”by converting that NULL to the numeric value 0; this final computed result, which represents the total sum of payment amounts for the specified customer or zero if no payments exist, is immediately returned as the function's output."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_book_rating_ratio` that accepts two input parameters: `p_book_id`, an integer representing the unique identifier of a book, and `p_multiplier`, a real number used as a scaling factor. This function is designed to return a single real number as its result. Upon execution, the function declares a local variable named `v_ratio` of type real. The core operation involves executing a `SELECT` statement to retrieve data from the `review` table. Specifically, it calculates a value by dividing the numerical content of the column named `\"Rating\"` by the numerical content of the column named `\"Readers_in_Million\"`, and then multiplies this intermediate result by the value provided in the `p_multiplier` input parameter. The outcome of this calculation is then assigned to the local variable `v_ratio`. This selection is conditional, applying only to rows in the `review` table where the value in the column named `\"Book_ID\"` precisely matches the integer value provided in the `p_book_id` input parameter. Finally, the function returns the calculated value stored in the `v_ratio` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_book_rating_ratio(p_book_id integer, p_multiplier real)\nRETURNS real AS $$\nDECLARE\n    v_ratio real;\nBEGIN\n    SELECT (\"Rating\" / \"Readers_in_Million\") * p_multiplier INTO v_ratio FROM review WHERE \"Book_ID\" = p_book_id;\n    RETURN v_ratio;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "SELECT calculate_book_rating_ratio(1, 1.5);",
      "SELECT calculate_book_rating_ratio(2, 2.0);",
      "SELECT calculate_book_rating_ratio(3, 0.8);",
      "SELECT calculate_book_rating_ratio(4, 1.2);",
      "SELECT calculate_book_rating_ratio(1, 1.0);"
    ],
    "summary": "Create a PL/pgSQL function named `calculate_book_rating_ratio` that takes a book ID (`integer`) and a multiplier (`real`), and returns a `real`. For the given book ID in the `review` table, calculate the ratio by dividing the `\"Rating\"` by `\"Readers_in_Million\"` and then multiplying by the provided multiplier. Return this calculated ratio.",
    "natural_language": "Write a function called `calculate_book_rating_ratio` that gives back a real number. It needs a book ID and a multiplier. For that book, look at its reviews and figure out a value. Basically, take the rating, divide it by how many readers it has, and then adjust that result using the multiplier. Return whatever that final number comes out to be.",
    "id": 73,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `calculate_book_rating_ratio` that accepts two input parameters: `p_book_id`, an integer representing the unique identifier of a book, and `p_multiplier`, a real number used as a scaling factor. This function is designed to return a single real number as its result. Upon execution, the function declares a local variable named `v_ratio` of type real. The core operation involves executing a `SELECT` statement to retrieve data from the `review` table. Specifically, it calculates a value by dividing the numerical content of the column named `\"Rating\"` by the numerical content of the column named `\"Readers_in_Million\"`, and then multiplies this intermediate result by the value provided in the `p_multiplier` input parameter. The outcome of this calculation is then assigned to the local variable `v_ratio`. This selection is conditional, applying only to rows in the `review` table where the value in the column named `\"Book_ID\"` precisely matches the integer value provided in the `p_book_id` input parameter. Finally, the function returns the calculated value stored in the `v_ratio` variable as its output."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_address_details that accepts a single input parameter named address_id_param of type bigint, which represents the unique identifier of an address record to be retrieved, and returns a result set with a defined table structure consisting of five text columns named address_details, city, zip_postcode, state_province_county, and country; the function's logic executes a single SELECT query that retrieves the columns address_details, city, zip_postcode, state_province_county, and country from the table named Addresses, using the alias A for the table, where the value in the address_id column of the Addresses table is strictly equal to the value supplied in the address_id_param input parameter, and then returns the result of this query directly as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_address_details(\"address_id_param\" bigint)\nRETURNS TABLE(\"address_details\" text, \"city\" text, \"zip_postcode\" text, \"state_province_county\" text, \"country\" text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT\n        A.\"address_details\",\n        A.\"city\",\n        A.\"zip_postcode\",\n        A.\"state_province_county\",\n        A.\"country\"\n    FROM \"Addresses\" AS A\n    WHERE A.\"address_id\" = \"address_id_param\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_deliveries",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Addresses",
      "Actual_Orders",
      "Actual_Order_Products",
      "Products",
      "Order_Deliveries",
      "Delivery_Route_Locations",
      "Trucks"
    ],
    "call_sqls": [
      "SELECT * FROM get_address_details(1);",
      "SELECT * FROM get_address_details(2);",
      "SELECT * FROM get_address_details(3);",
      "SELECT * FROM get_address_details(5);",
      "SELECT * FROM get_address_details(6);"
    ],
    "summary": "Create a function named get_address_details that takes an address_id and returns a result set with columns address_details, city, zip_postcode, state_province_county, and country from the Addresses table.",
    "natural_language": "Please construct a function designated as 'get_address_details'. This function should accept an address_id as its input parameter and yield a result set comprising the columns address_details, city, zip_postcode, state_province_county, and country, which are to be retrieved from the Addresses table.",
    "id": 74,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_address_details` that accepts a single input parameter, `address_id_input`, of type `bigint`. This function is designed to return a result set comprising the columns `address_details`, `city`, `zip_postcode`, `state_province_county`, and `country`, all of type `text`. The function performs a `SELECT` operation on the `Addresses` table. This `SELECT` statement retrieves the values from the `address_details`, `city`, `zip_postcode`, `state_province_county`, and `country` columns for the row where the `address_id` column matches the input `address_id_input` parameter. The function returns the result set directly from this query."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the name of an actor from the actor table, identified by the Actor_ID column matching the provided actor_id parameter of type integer, and transforms this name into capitalized form using the initcap function, which converts the first letter of each word to uppercase and the rest to lowercase, storing the result in a variable named actor_name of type text, and then returns this capitalized name as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION capitalize_actor_name(actor_id integer)\nRETURNS text AS $$\nDECLARE\n    actor_name text;\nBEGIN\n    SELECT initcap(\"Name\") INTO actor_name FROM \"actor\" WHERE \"Actor_ID\" = actor_id;\n    RETURN actor_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT capitalize_actor_name(1);",
      "SELECT capitalize_actor_name(2);",
      "SELECT capitalize_actor_name(3);",
      "SELECT capitalize_actor_name(4);",
      "SELECT capitalize_actor_name(5);"
    ],
    "summary": "Create a PLpgSQL function that returns text. It accepts an actor_id. The function should retrieve the actor's name from the actor table where Actor_ID matches the input, transform the name to capitalized form (first letter of each word uppercase), and return the result.",
    "natural_language": "Develop a PLpgSQL function that yields a text output. This function must take a single actor identifier as its parameter. Within the function, query the actor table to fetch the full name of the actor whose unique Actor_ID corresponds precisely to the provided input value. Subsequently, apply a transformation to convert the retrieved name into a properly capitalized format, where the initial letter of every individual word is changed to uppercase, while all other letters are set to lowercase. Finally, the function should elegantly return this meticulously formatted name as its result.",
    "id": 75,
    "generated_ir": "Write a PLpgSQL function that retrieves the name of an actor from the actor table, identified by the Actor_ID column matching the provided actor_id parameter of type integer, and transforms this name into capitalized form using the initcap function, which converts the first letter of each word to uppercase and the rest to lowercase, storing the result in a variable named actor_name of type text, and then returns this capitalized name as the function's output."
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters: staff_name of type TEXT and conference_name of type TEXT. The function returns a BOOLEAN value. It begins by declaring a local variable is_participating of type BOOLEAN, initialized to FALSE. The function first checks if there exists a record in the staff table where the name column matches the provided staff_name. If such a record exists, it proceeds to execute a nested SELECT query. This query checks for the existence of a record in the conference_participation table, aliased as cp, where the staff_ID column matches the staff_ID of the staff member with the given staff_name. This is determined by a subquery that selects the staff_ID from the staff table where the name matches staff_name. Additionally, the query joins the conference table, aliased as c, on the condition that the Conference_ID column in conference_participation matches the Conference_ID in conference. The WHERE clause of this query further filters the results to ensure that the Conference_Name in the conference table matches the provided conference_name. The result of this EXISTS query is assigned to the is_participating variable. Finally, the function returns the value of is_participating, indicating whether the specified staff member is participating in the specified conference.",
    "plsql": "CREATE OR REPLACE FUNCTION check_staff_participation(staff_name TEXT, conference_name TEXT)\nRETURNS BOOLEAN AS $$\nDECLARE\n    is_participating BOOLEAN := FALSE;\nBEGIN\n    IF EXISTS(SELECT 1 FROM staff WHERE name = staff_name) THEN\n        SELECT EXISTS(\n            SELECT 1 FROM conference_participation cp\n            JOIN conference c ON cp.\"Conference_ID\" = c.\"Conference_ID\"\n            WHERE c.\"Conference_Name\" = conference_name AND cp.\"staff_ID\" = (SELECT \"staff_ID\" FROM staff WHERE name = staff_name)\n        ) INTO is_participating;\n    END IF;\n    RETURN is_participating;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "staff"
    ],
    "call_sqls": [
      "SELECT check_staff_participation('Bobby Jackson', 'ACL');",
      "SELECT check_staff_participation('Casey Jacobsen', 'Naccl');",
      "SELECT check_staff_participation('Alexander Johnson', 'ACL');",
      "SELECT check_staff_participation('Bobby Jackson', 'Naccl');",
      "SELECT check_staff_participation('Casey Jacobsen', 'ACL');"
    ],
    "summary": "Create a PL/pgSQL function that returns a BOOLEAN indicating if a staff member with a given name is participating in a conference with a given name.",
    "natural_language": "Write a function that checks, maybe, if a staff person whose name is roughly like a certain one is involved in a conference that has a name kind of similar to another given one, and returns a true or false result.",
    "id": 76,
    "generated_ir": "Write a PLpgSQL function named check_staff_participation that accepts two input parameters: p_staff_name_pattern of type text, representing a pattern to match against staff names, and p_conference_name_pattern of type text, representing a pattern to match against conference names. The function returns a boolean value indicating whether a staff member whose name matches the given pattern participates in a conference whose name matches the given pattern.\n\nThe function begins by declaring a local variable v_exists of type boolean, initialized to false. It then performs a SELECT operation with an EXISTS subquery to check for the existence of at least one matching record. The query joins three tables: staff, conference_participation, and conference. The join conditions are: staff.staff_ID equals conference_participation.staff_ID, and conference_participation.Conference_ID equals conference.Conference_ID. The WHERE clause includes two conditions using the ILIKE operator for case-insensitive pattern matching: staff.name must match the p_staff_name_pattern, and conference.Conference_Name must match the p_conference_name_pattern. The result of this existence check is stored into the variable v_exists. Finally, the function returns the value of v_exists."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter p_student_id of type integer, representing the ID of a student, and returns a text value describing the level of mutual likes between the specified student and others in the \"Likes\" table. The function begins by declaring a local variable mutual_like_count of type integer to store the count of mutual likes. It then executes a SELECT query that calculates the number of mutual likes for the given student. This query joins the \"Likes\" table, aliased as l1, with itself, aliased as l2, using the condition that the liked_id column in l1 matches the student_id column in l2. The WHERE clause further filters the rows to include only those where the student_id in l1 matches the input parameter p_student_id and the liked_id in l2 matches the input parameter p_student_id, effectively identifying mutual likes where both students have liked each other. The result of this query is stored in the mutual_like_count variable. The function then evaluates the value of mutual_like_count using a series of conditional statements. If mutual_like_count is greater than 5, the function returns the text 'Strong mutual likes'. If mutual_like_count is greater than 0 but less than or equal to 5, the function returns the text 'Some mutual likes'. If mutual_like_count is 0, the function returns the text 'No mutual likes'. The function is implemented in the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION mutual_like_analysis(p_student_id integer)\nRETURNS text AS $$\nDECLARE\n    mutual_like_count integer;\nBEGIN\n    SELECT COUNT(*) INTO mutual_like_count FROM \"Likes\" l1\n    JOIN \"Likes\" l2 ON l1.liked_id = l2.student_id\n    WHERE l1.student_id = p_student_id AND l2.liked_id = p_student_id;\n\n    IF mutual_like_count > 5 THEN\n        RETURN 'Strong mutual likes';\n    ELSIF mutual_like_count > 0 THEN\n        RETURN 'Some mutual likes';\n    ELSE\n        RETURN 'No mutual likes';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "SELECT mutual_like_analysis(1510);",
      "SELECT mutual_like_analysis(1689);",
      "SELECT mutual_like_analysis(1381);",
      "SELECT mutual_like_analysis(1709);",
      "SELECT mutual_like_analysis(1782);"
    ],
    "summary": "Create a PLpgSQL function that takes a student ID and returns a text description of their mutual likes level. It counts how many mutual likes (where two students like each other) the student has in the Likes table. Return 'Strong mutual likes' if count > 5, 'Some mutual likes' if count is between 1 and 5, or 'No mutual likes' if count is 0.",
    "natural_language": "Write a PLpgSQL function that, given a student's ID, gives back a text summary about their mutual likes situation. It should figure out the approximate number of mutual likes (where two students are into each other) for that student from the Likes table. If the number seems pretty high, say more than a handful, return 'Strong mutual likes'. If there are a few, maybe between one and a small number, return 'Some mutual likes'. If there aren't really any, return 'No mutual likes'.",
    "id": 77,
    "generated_ir": "Write a PLpgSQL function that takes a single input parameter p_student_id of type integer, representing the ID of a student, and returns a text value describing the level of mutual likes between the specified student and others in the \"Likes\" table. The function begins by declaring a local variable mutual_like_count of type integer to store the count of mutual likes. It then executes a SELECT query that calculates the number of mutual likes for the given student. This query joins the \"Likes\" table, aliased as l1, with itself, aliased as l2, using the condition that the liked_id column in l1 matches the student_id column in l2. The WHERE clause further filters the rows to include only those where the student_id in l1 matches the input parameter p_student_id and the liked_id in l2 matches the input parameter p_student_id, effectively identifying mutual likes where both students have liked each other. The result of this query is stored in the mutual_like_count variable. The function then evaluates the value of mutual_like_count using a series of conditional statements. If mutual_like_count is greater than 5, the function returns the text 'Strong mutual likes'. If mutual_like_count is greater than 0 but less than or equal to 5, the function returns the text 'Some mutual likes'. If mutual_like_count is 0, the function returns the text 'No mutual likes'. The function is implemented in the PLpgSQL language."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_nationality_stats` that accepts a single input parameter, `p_nationality`, which is of type `TEXT`. This function is designed to return a table-like result set with two columns: `total_actors` of type `BIGINT` and `total_producers` of type `BIGINT`. The function's logic proceeds conditionally based on the value of the `p_nationality` parameter.\n\nIf the value of `p_nationality` is exactly equal to the string literal 'American', the function executes a `SELECT` query. This query counts the total number of rows in the `actor` table where the `nationality` column is equal to 'American'. The result of this count is aliased as `total_actors`. Simultaneously, it returns a constant value of `0` explicitly cast to `BIGINT` as `total_producers`. The results of this query are then returned by the function.\n\nAlternatively, if the value of `p_nationality` is exactly equal to the string literal 'British', the function executes a different `SELECT` query. This query counts the total number of rows in the `producer` table where the `nationality` column is equal to 'British'. The result of this count is aliased as `total_producers`. Concurrently, it returns a constant value of `0` explicitly cast to `BIGINT` as `total_actors`. The results of this query are then returned by the function.\n\nIn all other cases, meaning if `p_nationality` is neither 'American' nor 'British', the function executes a third `SELECT` query. This query performs a Cartesian product (or cross join) between the `actor` table and the `producer` table. From this combined set of rows, it then filters the results to include only those rows where the `nationality` column from the `actor` table is equal to the `nationality` column from the `producer` table. It then counts the total number of rows resulting from this filtered join operation, aliasing this count as `total_actors`. Simultaneously, it also counts the total number of rows from this same filtered join operation, aliasing this second count as `total_producers`. The results of this query are then returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_nationality_stats(p_nationality TEXT)\nRETURNS TABLE(total_actors BIGINT, total_producers BIGINT) AS $$\nBEGIN\n    IF p_nationality = 'American' THEN\n        RETURN QUERY SELECT COUNT(*) as total_actors, 0::BIGINT as total_producers FROM actor WHERE nationality = 'American';\n    ELSIF p_nationality = 'British' THEN\n        RETURN QUERY SELECT 0::BIGINT as total_actors, COUNT(*) as total_producers FROM producer WHERE nationality = 'British';\n    ELSE\n        RETURN QUERY SELECT COUNT(*) as total_actors, COUNT(*) as total_producers FROM actor, producer WHERE actor.nationality = producer.nationality;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "producer",
      "made_by",
      "company"
    ],
    "call_sqls": [
      "SELECT * FROM get_nationality_stats('American');",
      "SELECT * FROM get_nationality_stats('British');",
      "SELECT * FROM get_nationality_stats('French');",
      "SELECT * FROM get_nationality_stats('German');",
      "SELECT * FROM get_nationality_stats('Canadian');"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_nationality_stats` that takes a TEXT parameter `p_nationality` and returns a table with columns `total_actors` BIGINT and `total_producers` BIGINT. If `p_nationality` is 'American', count actors with that nationality and return 0 for producers. If it's 'British', count producers with that nationality and return 0 for actors. For any other value, perform a cross join between actor and producer tables, filter where nationalities match, and count rows from both tables.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called `get_nationality_stats`? It needs a TEXT parameter, let's call it `p_nationality`. It should spit out a table with two columns: `total_actors` (as a BIGINT) and `total_producers` (also a BIGINT). Here's the deal: if `p_nationality` is 'American', just count up the actors with that nationality and set the producer count to zero. If it's 'British', do the oppositeâ€”count the producers and set the actor count to zero. For any other nationality you throw at it, it should do a cross join between the actor and producer tables, filter so the nationalities match, and then count up the rows from both tables.",
    "id": 78,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_nationality_stats` that accepts a single input parameter, `p_nationality`, which is of type `TEXT`. This function is designed to return a table-like result set with two columns: `total_actors` of type `BIGINT` and `total_producers` of type `BIGINT`. The function's logic proceeds conditionally based on the value of the `p_nationality` parameter.\n\nIf the value of `p_nationality` is exactly equal to the string literal 'American', the function executes a `SELECT` query. This query counts the total number of rows in the `actor` table where the `nationality` column is equal to 'American'. The result of this count is aliased as `total_actors`. Simultaneously, it returns a constant value of `0` explicitly cast to `BIGINT` as `total_producers`. The results of this query are then returned by the function.\n\nAlternatively, if the value of `p_nationality` is exactly equal to the string literal 'British', the function executes a different `SELECT` query. This query counts the total number of rows in the `producer` table where the `nationality` column is equal to 'British'. The result of this count is aliased as `total_producers`. Concurrently, it returns a constant value of `0` explicitly cast to `BIGINT` as `total_actors`. The results of this query are then returned by the function.\n\nIn all other cases, meaning if `p_nationality` is neither 'American' nor 'British', the function executes a third `SELECT` query. This query performs a Cartesian product (or cross join) between the `actor` table and the `producer` table. From this combined set of rows, it then filters the results to include only those rows where the `nationality` column from the `actor` table is equal to the `nationality` column from the `producer` table. It then counts the total number of rows resulting from this filtered join operation, aliasing this count as `total_actors`. Simultaneously, it also counts the total number of rows from this same filtered join operation, aliasing this second count as `total_producers`. The results of this query are then returned by the function."
  },
  {
    "ir": "Write a PLpgSQL function named `get_artist_age` that accepts a single input parameter, `p_artist_id`, which is of type `INTEGER`. The purpose of this function is to retrieve the age of a specific artist from the `artist` table. The function's logic begins with a conditional check: it evaluates whether the value of `p_artist_id` is greater than `0`. If this condition is true, the function proceeds to execute a `SELECT` statement. This `SELECT` statement queries the `artist` table to retrieve the value from the `\"Age\"` column. The retrieval is filtered by a `WHERE` clause, which specifies that the `\"Artist_ID\"` column in the `artist` table must match the value provided by the `p_artist_id` input parameter. The result of this `SELECT` statement (the artist's age) is then returned by the function. If the initial conditional check (`p_artist_id > 0`) evaluates to false, meaning `p_artist_id` is `0` or a negative value, the `SELECT` statement is bypassed, and the function directly returns `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_age(p_artist_id INTEGER)\nRETURNS INTEGER AS $$\nBEGIN\n    IF p_artist_id > 0 THEN\n        RETURN (SELECT \"Age\" FROM artist WHERE \"Artist_ID\" = p_artist_id);\n    END IF;\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "music_4",
    "tables": [
      "artist",
      "music_festival",
      "volume"
    ],
    "call_sqls": [
      "SELECT get_artist_age(1);",
      "SELECT get_artist_age(2);",
      "SELECT get_artist_age(3);",
      "SELECT get_artist_age(10);",
      "SELECT get_artist_age(NULL);"
    ],
    "summary": "Create a PL/pgSQL function named get_artist_age that takes an artist_id (integer) and returns an integer. If the artist_id is greater than 0, retrieve and return the Age from the artist table where Artist_ID matches. Otherwise, return NULL.",
    "natural_language": "Write a function called get_artist_age that uses an artist_id number. If you give it a decent, positive-looking ID, it should fetch and give back the Age from the artist table for that particular artist. If the ID isn't really valid or seems off, just return nothing.",
    "id": 79,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_artist_age that operates within the music_4 database. The function accepts a single input parameter named artist_id of type integer, which is used to identify a specific artist. The function returns a value of type integer, representing the artist's age.\n\nThe function begins by declaring a local variable named artist_age of type integer to store the result retrieved from the database. It then executes a SELECT statement to query the artist table, specifically retrieving the value from the Age column for the row where the Artist_ID column matches the provided artist_id input parameter. The retrieved value is assigned into the local variable artist_age.\n\nFollowing the query, the function uses a conditional IF statement to check if the artist_id parameter is valid. The condition evaluates whether the artist_id is greater than 0, which is interpreted as a \"decent, positive-looking ID.\" If the condition evaluates to true, the function returns the value stored in the artist_age variable. If the condition evaluates to false, meaning the artist_id is not positive (e.g., it is zero, negative, or NULL), the function returns NULL, effectively returning nothing as specified. The function does not include explicit error handling for cases where the artist_id does not exist in the table; in such a scenario, the SELECT statement would not find a matching row, the artist_age variable would remain NULL, and the function would still execute the IF block. Since the condition would be true for a positive artist_id, it would return the NULL value stored in artist_age."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_service_details` that accepts a single input parameter, `p_resident_id`, which is of type `bigint`. This function is designed to return a single value of type `text`. Inside the function, a local variable named `v_service_details` of type `text` is declared to temporarily store the retrieved service details. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `other_details` column from the table named `\"Residents_Services\"`. The retrieved value is then immediately assigned to the local variable `v_service_details`. The selection of rows from the `\"Residents_Services\"` table is constrained by two conditions in the `WHERE` clause: first, the value in the `resident_id` column must be equal to the value provided in the input parameter `p_resident_id`; and second, the value in the `date_provided` column must not be `NULL`. The results of this filtered selection are then ordered in descending order based on the values in the `date_provided` column. Finally, the `LIMIT 1` clause ensures that only the first row from the ordered result set is considered. After the `SELECT` statement completes and the `v_service_details` variable is populated, the function returns the value currently stored in `v_service_details` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_service_details(p_resident_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_service_details text;\nBEGIN\n    SELECT \"other_details\"\n    INTO v_service_details\n    FROM \"Residents_Services\"\n    WHERE \"resident_id\" = p_resident_id\n    AND \"date_provided\" IS NOT NULL\n    ORDER BY \"date_provided\" DESC\n    LIMIT 1;\n    RETURN v_service_details;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events",
      "Customers",
      "Residents",
      "Properties",
      "Residents_Services"
    ],
    "call_sqls": [
      "SELECT get_service_details(6);",
      "SELECT get_service_details(23);",
      "SELECT get_service_details(28);",
      "SELECT get_service_details(10);",
      "SELECT get_service_details(19);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_service_details that takes a resident_id (bigint) and returns a text value. Select the other_details from the Residents_Services table where the resident_id matches the input and date_provided is not NULL, order by date_provided descending, and return the first result.",
    "natural_language": "Write a function called get_service_details that, given a resident's ID number, fetches a text field. It should look up records for that resident where a service date is recorded, sort them to put newer entries first, and give back the details from the most recent one.",
    "id": 80,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_service_details` that accepts a single input parameter, `p_resident_id`, which is of type `bigint`. This function is designed to return a single value of type `text`. Inside the function, a local variable named `v_service_details` of type `text` is declared to temporarily store the retrieved service details. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `other_details` column from the table named `\"Residents_Services\"`. The retrieved value is then immediately assigned to the local variable `v_service_details`. The selection of rows from the `\"Residents_Services\"` table is constrained by two conditions in the `WHERE` clause: first, the value in the `resident_id` column must be equal to the value provided in the input parameter `p_resident_id`; and second, the value in the `date_provided` column must not be `NULL`. The results of this filtered selection are then ordered in descending order based on the values in the `date_provided` column. Finally, the `LIMIT 1` clause ensures that only the first row from the ordered result set is considered. After the `SELECT` statement completes and the `v_service_details` variable is populated, the function returns the value currently stored in `v_service_details` as its output."
  },
  {
    "ir": "Write a PL/pgSQL function named `get_region_name_by_country` that accepts a single input parameter named `country_id` of data type `text`. The purpose of this `country_id` parameter is to specify the unique identifier of a country for which the corresponding region name is to be retrieved. The function is designed to return a single value of data type `text`, which will represent the name of the region associated with the provided country identifier.\n\nUpon execution, the function declares a local variable named `region_name` of data type `text` to temporarily store the retrieved region name. The core operation of the function involves executing a `SELECT` statement to fetch data. This `SELECT` statement targets the `REGION_NAME` column from the `regions` table. The value retrieved from `r.\"REGION_NAME\"` is then assigned to the local variable `region_name`.\n\nThe `SELECT` statement performs a `JOIN` operation between two tables: `countries` (aliased as `c`) and `regions` (aliased as `r`). The join condition specifies that rows from `countries` and `regions` tables are matched when the value in the `REGION_ID` column of the `countries` table (`c.\"REGION_ID\"`) is equal to the value in the `REGION_ID` column of the `regions` table (`r.\"REGION_ID\"`).\n\nFurthermore, a `WHERE` clause is applied to filter the results of the join. This `WHERE` clause ensures that only rows where the value in the `COUNTRY_ID` column of the `countries` table (`c.\"COUNTRY_ID\"`) is equal to the value passed in the input parameter `country_id` are considered.\n\nAfter the `SELECT` statement successfully retrieves the `REGION_NAME` and assigns it to the `region_name` variable, the function concludes by returning the value stored in the `region_name` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_name_by_country(country_id text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    region_name text;\nBEGIN\n    SELECT r.\"REGION_NAME\" INTO region_name\n    FROM countries c\n    JOIN regions r ON c.\"REGION_ID\" = r.\"REGION_ID\"\n    WHERE c.\"COUNTRY_ID\" = country_id;\n    RETURN region_name;\nEND;\n$$;",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_region_name_by_country('AR');",
      "SELECT get_region_name_by_country('AU');",
      "SELECT get_region_name_by_country('BE');",
      "SELECT get_region_name_by_country('IT');",
      "SELECT get_region_name_by_country('JP');"
    ],
    "summary": "Create a PL/pgSQL function named `get_region_name_by_country` that takes a `text` parameter `country_id` and returns the `text` region name. It should join the `countries` and `regions` tables on `REGION_ID` and select the `REGION_NAME` where the `COUNTRY_ID` matches the input parameter.",
    "natural_language": "Please construct a PL/pgSQL function designated as `get_region_name_by_country`. This function shall accept a single `text` parameter named `country_id` and is to return a `text` value representing the region name. The implementation must perform an inner join between the `countries` and `regions` tables utilizing the `REGION_ID` column as the join condition. Subsequently, it should select the `REGION_NAME` from the joined result set where the `COUNTRY_ID` column corresponds precisely to the provided input parameter.",
    "id": 81,
    "generated_ir": "Write a PL/pgSQL function named `get_region_name_by_country` that accepts a single input parameter named `country_id` of data type `text`. The purpose of this `country_id` parameter is to specify the unique identifier of a country for which the corresponding region name is to be retrieved. The function is designed to return a single value of data type `text`, which will represent the name of the region associated with the provided country identifier.\n\nUpon execution, the function declares a local variable named `region_name` of data type `text` to temporarily store the retrieved region name. The core operation of the function involves executing a `SELECT` statement to fetch data. This `SELECT` statement targets the `REGION_NAME` column from the `regions` table. The value retrieved from `r.\"REGION_NAME\"` is then assigned to the local variable `region_name`.\n\nThe `SELECT` statement performs a `JOIN` operation between two tables: `countries` (aliased as `c`) and `regions` (aliased as `r`). The join condition specifies that rows from `countries` and `regions` tables are matched when the value in the `REGION_ID` column of the `countries` table (`c.\"REGION_ID\"`) is equal to the value in the `REGION_ID` column of the `regions` table (`r.\"REGION_ID\"`).\n\nFurthermore, a `WHERE` clause is applied to filter the results of the join. This `WHERE` clause ensures that only rows where the value in the `COUNTRY_ID` column of the `countries` table (`c.\"COUNTRY_ID\"`) is equal to the value passed in the input parameter `country_id` are considered.\n\nAfter the `SELECT` statement successfully retrieves the `REGION_NAME` and assigns it to the `region_name` variable, the function concludes by returning the value stored in the `region_name` variable as its output."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_actor_musical_name` that accepts a single input parameter, `p_actor_id`, which is of type `integer`, and is intended to represent the unique identifier of an actor. This function is designed to return a value of type `text`, which will be the name of the musical associated with the provided actor ID. Upon execution, the function declares a local variable named `musical_name` of type `text` to temporarily store the retrieved musical name. The core operation involves a `SELECT` statement that retrieves the value from the `\"Name\"` column of the `musical` table. This retrieved value is then assigned to the `musical_name` local variable. The `SELECT` statement performs an `INNER JOIN` operation between the `musical` table (aliased as `m`) and the `actor` table (aliased as `a`). The join condition specifies that rows from both tables are matched where the value in the `\"Musical_ID\"` column of the `musical` table is equal to the value in the `\"Musical_ID\"` column of the `actor` table. Furthermore, a `WHERE` clause is applied to filter the joined results, ensuring that only rows where the value in the `\"Actor_ID\"` column of the `actor` table is equal to the value of the input parameter `p_actor_id` are considered. Finally, the function returns the value stored in the `musical_name` local variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_musical_name(p_actor_id integer)\nRETURNS text AS $$\nDECLARE\n    musical_name text;\nBEGIN\n    SELECT m.\"Name\" INTO musical_name\n    FROM musical m\n    JOIN actor a ON m.\"Musical_ID\" = a.\"Musical_ID\"\n    WHERE a.\"Actor_ID\" = p_actor_id;\n    RETURN musical_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "musical",
    "tables": [
      "actor",
      "musical"
    ],
    "call_sqls": [
      "SELECT get_actor_musical_name(1);",
      "SELECT get_actor_musical_name(2);",
      "SELECT get_actor_musical_name(3);",
      "SELECT get_actor_musical_name(4);",
      "SELECT get_actor_musical_name(5);"
    ],
    "summary": "Create a PL/pgSQL function named get_actor_musical_name that takes an integer p_actor_id and returns text. It should return the musical's \"Name\" for the given actor by joining the musical and actor tables on Musical_ID.",
    "natural_language": "Write a PL/pgSQL function get_actor_musical_name(p_actor_id integer) returning text. It joins musical and actor on Musical_ID to output the musical's Name for the specified actor.",
    "id": 82,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_actor_musical_name that accepts a single input parameter p_actor_id of type integer and returns a text value. The function is designed to retrieve the name of a musical associated with a specific actor. It begins by declaring a variable musical_name of type text to store the result. The function then executes a SELECT query that retrieves the Name column from the musical table. This is achieved by performing an inner join between the musical table and the actor table using the common column Musical_ID. The join condition ensures that only rows where the Musical_ID in the musical table matches the Musical_ID in the actor table are considered. The query includes a WHERE clause that filters the results to only include rows where the Actor_ID column in the actor table equals the provided p_actor_id input parameter. The retrieved musical name from the musical table is then assigned to the musical_name variable. Finally, the function returns the value stored in the musical_name variable as its output."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_lesson_revenue that accepts a single parameter p_staff_id of type bigint, which represents the identifier of a staff member. The function returns a value of type double precision, which is the calculated revenue from lessons associated with the specified staff member. Within the function, a SELECT statement is executed to retrieve the sum of the price column from the Lessons table, where the staff_id column matches the provided p_staff_id parameter and the lesson_status_code column does not equal 'Cancelled'. The COALESCE function is used to ensure that if the sum of prices is NULL, a default value of 0 is returned instead. The result of this SELECT statement is returned as the output of the function. The function is defined using the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_lesson_revenue(p_staff_id bigint)\nRETURNS double precision AS $$\nBEGIN\n    RETURN (SELECT COALESCE(SUM(price), 0) FROM \"Lessons\" WHERE staff_id = p_staff_id AND lesson_status_code != 'Cancelled');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "driving_school",
    "tables": [
      "Addresses",
      "Customer_Payments",
      "Customers",
      "Lessons",
      "Staff",
      "Vehicles"
    ],
    "call_sqls": [
      "SELECT calculate_lesson_revenue(1);",
      "SELECT calculate_lesson_revenue(8);",
      "SELECT calculate_lesson_revenue(14);",
      "SELECT calculate_lesson_revenue(11);",
      "SELECT calculate_lesson_revenue(2);"
    ],
    "summary": "Create a function named calculate_lesson_revenue that takes a staff ID. Return the sum of prices for all lessons assigned to that staff member where the status is not 'Cancelled', or 0 if none exist.",
    "natural_language": "Construct a function called calculate_lesson_revenue which accepts a specific staff identifier as its input. This function should meticulously compute and deliver the total sum of prices from every single lesson that has been assigned to the designated staff member, but only for those lessons whose current status is explicitly not marked as 'Cancelled'. In the event that no such qualifying lessons are found for the provided staff ID, the function must gracefully return a value of zero.",
    "id": 83,
    "generated_ir": "Write a PLpgSQL function named calculate_lesson_revenue that accepts a single parameter p_staff_id of type bigint, which represents the identifier of a staff member. The function returns a value of type double precision, which is the calculated revenue from lessons associated with the specified staff member. Within the function, a SELECT statement is executed to retrieve the sum of the price column from the Lessons table, where the staff_id column matches the provided p_staff_id parameter and the lesson_status_code column does not equal 'Cancelled'. The COALESCE function is used to ensure that if the sum of prices is NULL, a default value of 0 is returned instead. The result of this SELECT statement is returned as the output of the function. The function is defined using the PLpgSQL language."
  },
  {
    "ir": "Write a PLpgSQL function that takes two integer parameters, min_code and max_code, and returns a table containing three columns: Major_ID (integer), Major_Name (text), and Major_Code (integer). The function retrieves data from the \"major\" table, specifically selecting the columns \"Major_ID\", \"Major_Name\", and \"Major_Code\". It filters the rows based on the condition that the \"Major_Code\" column value must fall within the inclusive range defined by the min_code and max_code parameters. The function uses the RETURN QUERY statement to execute the SELECT query and return the resulting rows as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_major_by_code_range(min_code integer, max_code integer)\nRETURNS TABLE(\"Major_ID\" integer, \"Major_Name\" text, \"Major_Code\" integer) AS $$\nBEGIN\n    RETURN QUERY \n    SELECT m.\"Major_ID\", m.\"Major_Name\", m.\"Major_Code\"\n    FROM \"major\" m\n    WHERE m.\"Major_Code\" BETWEEN min_code AND max_code;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT * FROM get_major_by_code_range(1050, 1060);",
      "SELECT * FROM get_major_by_code_range(1000, 1100);",
      "SELECT * FROM get_major_by_code_range(1053, 1054);",
      "SELECT * FROM get_major_by_code_range(1150, 1160);",
      "SELECT * FROM get_major_by_code_range(1040, 1200);"
    ],
    "summary": "Create a PLpgSQL function that returns a table (Major_ID integer, Major_Name text, Major_Code integer). It takes min_code and max_code integer parameters and selects from the major table where Major_Code is between the parameters.",
    "natural_language": "What PLpgSQL function can be written to return a table with columns for Major_ID, Major_Name, and Major_Code, given integer parameters for min_code and max_code, that selects from the major table where Major_Code falls between those two values?",
    "id": 84,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_major_by_code_range that takes two input parameters: min_code of type integer representing the lower bound of the major code range, and max_code of type integer representing the upper bound of the major code range. The function returns a table with three columns: Major_ID of type integer, Major_Name of type text, and Major_Code of type integer. The function's core operation involves executing a SELECT query to retrieve data from the major table. The query selects the Major_ID, Major_Name, and Major_Code columns directly from the major table. The WHERE clause filters the results to include only rows where the Major_Code column is greater than or equal to the min_code parameter and less than or equal to the max_code parameter. The function uses the RETURN QUERY statement to return the result set of this SELECT query as the output table."
  },
  {
    "ir": "Write a PLpgSQL function that calculates the average enrollment of universities located in a specified state. The function, named calculate_avg_enrollment_by_state, accepts a single parameter \"State\" of type text, which represents the name of the state for which the average enrollment is to be calculated. The function returns a numeric value representing the average enrollment rounded to two decimal places. Within the function, a SELECT statement is executed to compute the average of the \"Enrollment\" column from the \"university\" table, where the \"State\" column in the \"university\" table matches the provided \"State\" parameter. The AVG function is used to calculate the average enrollment, and the ROUND function is applied to round the result to two decimal places. The function is defined using the PLpgSQL language.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_avg_enrollment_by_state(\"State\" text)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (SELECT ROUND(AVG(\"Enrollment\"), 2) FROM \"university\" WHERE \"university\".\"State\" = $1);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT calculate_avg_enrollment_by_state('Illinois');",
      "SELECT calculate_avg_enrollment_by_state('Wisconsin');",
      "SELECT calculate_avg_enrollment_by_state('California');",
      "SELECT calculate_avg_enrollment_by_state('New York');",
      "SELECT calculate_avg_enrollment_by_state('Texas');"
    ],
    "summary": "Create a PostgreSQL function named \"calculate_avg_enrollment_by_state\" that returns a NUMERIC value rounded to two decimal places. It accepts a TEXT parameter \"State\". The function calculates the average of the \"Enrollment\" column from the \"university\" table where the \"State\" column matches the provided parameter.",
    "natural_language": "Develop a PostgreSQL function called \"calculate_avg_enrollment_by_state\" which is designed to return a NUMERIC value that is carefully rounded to precisely two decimal places. This specialized function should accept a single TEXT parameter named \"State\". Its primary purpose is to meticulously compute the average value from the \"Enrollment\" column within the extensive \"university\" table, specifically filtering for those records where the \"State\" column exactly corresponds to the parameter that is supplied.",
    "id": 85,
    "generated_ir": "Write a PLpgSQL function that calculates the average enrollment of universities located in a specified state. The function, named calculate_avg_enrollment_by_state, accepts a single parameter \"State\" of type text, which represents the name of the state for which the average enrollment is to be calculated. The function returns a numeric value representing the average enrollment rounded to two decimal places. Within the function, a SELECT statement is executed to compute the average of the \"Enrollment\" column from the \"university\" table, where the \"State\" column in the \"university\" table matches the provided \"State\" parameter. The AVG function is used to calculate the average enrollment, and the ROUND function is applied to round the result to two decimal places. The function is defined using the PLpgSQL language."
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the average value of the \"Tonnage\" column from the \"ship\" table. This function, named get_average_tonnage, does not take any parameters and returns a numeric value representing the average tonnage. The function performs a single operation: it executes a SELECT statement to compute the average of all entries in the \"Tonnage\" column of the \"ship\" table using the AVG() aggregate function. The result of this calculation is returned as the output of the function. The function is defined using the PLpgSQL language, and it encapsulates the logic for retrieving the average tonnage from the specified table without any conditional statements or additional logic.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_tonnage()\nRETURNS NUMERIC AS $$\nBEGIN\n    RETURN (SELECT AVG(\"Tonnage\") FROM ship);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "ship_mission",
    "tables": [
      "mission",
      "ship"
    ],
    "call_sqls": [
      "SELECT get_average_tonnage();",
      "SELECT * FROM get_average_tonnage();",
      "SELECT get_average_tonnage() AS avg_tonnage;",
      "SELECT get_average_tonnage() FROM ship LIMIT 1;",
      "SELECT get_average_tonnage() INTO avg_result;"
    ],
    "summary": "Create a PL/pgSQL function named get_average_tonnage that returns the average value of the Tonnage column from the ship table.",
    "natural_language": "Develop a PL/pgSQL function, which should be named get_average_tonnage, that meticulously calculates and returns the precise average value, derived from all entries, for the Tonnage column found within the comprehensive ship table.",
    "id": 86,
    "generated_ir": "Write a PLpgSQL function that calculates and returns the average value of the \"Tonnage\" column from the \"ship\" table. This function, named get_average_tonnage, does not take any parameters and returns a numeric value representing the average tonnage. The function performs a single operation: it executes a SELECT statement to compute the average of all entries in the \"Tonnage\" column of the \"ship\" table using the AVG() aggregate function. The result of this calculation is returned as the output of the function. The function is defined using the PLpgSQL language, and it encapsulates the logic for retrieving the average tonnage from the specified table without any conditional statements or additional logic."
  },
  {
    "ir": "Write a PLpgSQL function that takes two parameters, gymnast_id of type integer and event_name of type text, and returns a real value representing the minimum points scored by the specified gymnast in the specified event. The function begins by declaring a local variable min_points of type real to store the result. It then uses a conditional structure to determine the event specified by the event_name parameter. If the event_name matches 'Floor_Exercise', the function executes a SELECT statement to retrieve the minimum value of the \"Floor_Exercise_Points\" column from the \"gymnast\" table for rows where the \"Gymnast_ID\" column matches the gymnast_id parameter, and assigns this value to the min_points variable. Similarly, if the event_name matches 'Pommel_Horse', the function retrieves the minimum value of the \"Pommel_Horse_Points\" column under the same condition and assigns it to min_points. This pattern is repeated for the events 'Rings', 'Vault', 'Parallel_Bars', and 'Horizontal_Bar', with the function querying the respective columns \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", and \"Horizontal_Bar_Points\" in the \"gymnast\" table, always filtering rows based on the \"Gymnast_ID\" column matching the gymnast_id parameter. If the event_name does not match any of the predefined event names, the function assigns NULL to the min_points variable. Finally, the function returns the value stored in min_points.",
    "plsql": "CREATE OR REPLACE FUNCTION get_gymnast_event_min_points(gymnast_id integer, event_name text)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    min_points real;\nBEGIN\n    IF event_name = 'Floor_Exercise' THEN\n        SELECT MIN(\"Floor_Exercise_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Pommel_Horse' THEN\n        SELECT MIN(\"Pommel_Horse_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Rings' THEN\n        SELECT MIN(\"Rings_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Vault' THEN\n        SELECT MIN(\"Vault_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Parallel_Bars' THEN\n        SELECT MIN(\"Parallel_Bars_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSIF event_name = 'Horizontal_Bar' THEN\n        SELECT MIN(\"Horizontal_Bar_Points\") INTO min_points FROM \"gymnast\" WHERE \"Gymnast_ID\" = gymnast_id;\n    ELSE\n        min_points := NULL;\n    END IF;\n    \n    RETURN min_points;\nEND;\n$$;",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "SELECT get_gymnast_event_min_points(1, 'Floor_Exercise');",
      "SELECT get_gymnast_event_min_points(2, 'Pommel_Horse');",
      "SELECT get_gymnast_event_min_points(4, 'Rings');",
      "SELECT get_gymnast_event_min_points(1, 'Vault');",
      "SELECT get_gymnast_event_min_points(2, 'Horizontal_Bar');"
    ],
    "summary": "Create a PL/pgSQL function that returns a real value representing the minimum points for a gymnast in a specific event. It takes a gymnast_id integer and an event_name text. Using conditional logic, query the gymnast table to find the minimum value from the column corresponding to the event_name for the given gymnast_id. If the event_name is not recognized, return NULL.",
    "natural_language": "Please construct a PL/pgSQL function that yields a real number, which shall represent the minimum score achieved by a specified gymnast in a designated event. The function must accept two parameters: an integer for the gymnast's identifier and a text value for the event name. The implementation shall employ conditional logic to query the gymnast table, retrieving the minimum value from the column that corresponds to the provided event name for the given gymnast identifier. Should the supplied event name not correspond to a recognized column, the function is to return a NULL value.",
    "id": 87,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_gymnast_event_min_points` that accepts two input parameters: `p_gymnast_id` of type `integer` and `p_event_name` of type `text`. This function is designed to return a value of type `real`. The function's purpose is to determine the minimum score achieved by a specific gymnast in a specific event, based on the provided gymnast identifier and event name.\n\nThe function begins by declaring a local variable `v_min_points` of type `real`, which will hold the result. The function then uses conditional logic to check the value of the `p_event_name` input parameter against a list of predefined, hardcoded event names that correspond to column names in the `gymnast` table.\n\nThe conditional logic is structured as a series of `IF` and `ELSIF` statements. First, the function checks if `p_event_name` is exactly equal to the string `'Floor_Exercise'`. If this condition is true, the function executes a `SELECT` statement. This `SELECT` statement queries the `gymnast` table, specifically retrieving the value from the `Floor_Exercise_Points` column for the row where the `Gymnast_ID` column matches the value provided in the `p_gymnast_id` parameter. The retrieved value is assigned to the `v_min_points` variable.\n\nIf the first condition is false, the function proceeds to the next `ELSIF` condition. It checks if `p_event_name` is exactly equal to the string `'Pommel_Horse'`. If true, it executes a `SELECT` statement to retrieve the value from the `Pommel_Horse_Points` column for the specified `Gymnast_ID` and assigns it to `v_min_points`.\n\nThis pattern continues sequentially for each recognized event. The function checks `p_event_name` against the following strings in order:\n- `'Rings'` -> selects from the `Rings_Points` column.\n- `'Vault'` -> selects from the `Vault_Points` column.\n- `'Parallel_Bars'` -> selects from the `Parallel_Bars_Points` column.\n- `'Horizontal_Bar'` -> selects from the `Horizontal_Bar_Points` column.\n\nIf `p_event_name` matches any of these six strings, the corresponding `SELECT` statement is executed to fetch the specific event points for the given gymnast.\n\nIf, after checking all six conditions, the `p_event_name` does not match any of the recognized event names, the function enters an `ELSE` block. In this block, the function sets the `v_min_points` variable to `NULL`.\n\nAfter the conditional block completes, the function returns the value stored in the `v_min_points` variable. This value will be either the real number score from the appropriate column for the specified gymnast, or `NULL` if the event name was invalid. The function does not perform any aggregation or calculation of a minimum value across multiple rows; it simply retrieves a single value from a specific column for a specific gymnast, which is described as the \"minimum score\" in the context of being the sole recorded value for that gymnast-event pair."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_department_count_by_store that accepts a single input parameter named store_id of type bigint, which represents the unique identifier of a store, and returns a single integer value; within the function, declare a local integer variable named department_count; then execute a SELECT query on the table named \"Departments\" to count the number of distinct department_id values for all rows where the column dept_store_id is equal to the provided store_id parameter, storing the resulting count into the department_count variable; finally, return the value stored in the department_count variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_department_count_by_store(store_id bigint) RETURNS integer AS $$\nDECLARE\n    department_count integer;\nBEGIN\n    SELECT COUNT(department_id) INTO department_count\n    FROM \"Departments\"\n    WHERE dept_store_id = store_id;\n    RETURN department_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "department_store",
    "tables": [
      "Department_Stores",
      "Departments",
      "Staff",
      "Staff_Department_Assignments",
      "Department_Store_Chain"
    ],
    "call_sqls": [
      "SELECT get_department_count_by_store(5);",
      "SELECT get_department_count_by_store(11);",
      "SELECT get_department_count_by_store(4);",
      "SELECT get_department_count_by_store(1);",
      "SELECT get_department_count_by_store(2);"
    ],
    "summary": "Create a PL/pgSQL function named get_department_count_by_store that takes a store_id (bigint) and returns the count of distinct departments in that store.",
    "natural_language": "Write a PL/pgSQL function called get_department_count_by_store that accepts a store_id (bigint) and gives back the number of distinct departments for that store.",
    "id": 88,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_department_count_by_store that accepts a single input parameter named store_id of type bigint, representing the unique identifier of a specific store. The function returns a single integer value, which is the count of distinct departments associated with the provided store_id.\n\nThe function declares a local variable named department_count of type integer to store the result of the count operation. The core operation of the function is to execute a SELECT query that counts the distinct department records. This query retrieves data from the Departments table, aliased as d. It uses the COUNT aggregate function with the DISTINCT keyword applied to the d.department_id column to ensure each department is counted only once, even if there are multiple staff assignments or other potential duplicates in related tables.\n\nThe selection is filtered by a single condition: d.dept_store_id = store_id. This condition ensures that only departments belonging to the specific store, as identified by the input store_id parameter, are included in the count. The result of this COUNT operation is then assigned directly to the department_count variable.\n\nFinally, the function returns the value stored in the department_count variable, which represents the total number of distinct departments for the specified store."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_students_with_pet_age_mod that returns a table structure with five columns: StuID of type bigint, Fname of type text, LName of type text, PetID of type bigint, and pet_age_mod of type bigint. The function begins execution by issuing a RETURN QUERY command to return the result set of a SELECT statement. This SELECT statement retrieves data from three tables: Student (aliased as s), Has_Pet (aliased as hp), and Pets (aliased as p). It specifically selects the StuID column from the Student table, the Fname column from the Student table, the LName column from the Student table, the PetID column from the Pets table, and a computed column using the MOD function. The MOD function is applied to the pet_age column from the Pets table with a divisor of 2, and the result is aliased as pet_age_mod. The tables are joined using INNER JOIN operations: first, the Student table is joined with the Has_Pet table on the condition that the StuID column from Student equals the StuID column from Has_Pet. Then, the result of that join is joined with the Pets table on the condition that the PetID column from Has_Pet equals the PetID column from Pets. The function returns all rows resulting from this joined query, effectively listing each student, their associated pet, and a modified pet age which is the remainder when the pet's age is divided by two.",
    "plsql": "CREATE OR REPLACE FUNCTION get_students_with_pet_age_mod()\nRETURNS TABLE(StuID bigint, Fname text, LName text, PetID bigint, pet_age_mod bigint) AS $$\nBEGIN\n  RETURN QUERY \n  SELECT s.\"StuID\", s.\"Fname\", s.\"LName\", p.\"PetID\", MOD(p.\"pet_age\", 2) AS pet_age_mod\n  FROM \"Student\" s\n  JOIN \"Has_Pet\" hp ON s.\"StuID\" = hp.\"StuID\"\n  JOIN \"Pets\" p ON hp.\"PetID\" = p.\"PetID\";\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "SELECT * FROM get_students_with_pet_age_mod();",
      "SELECT StuID, Fname, LName FROM get_students_with_pet_age_mod() WHERE pet_age_mod = 0;",
      "SELECT * FROM get_students_with_pet_age_mod() WHERE LName = 'Smith';",
      "SELECT * FROM get_students_with_pet_age_mod() ORDER BY pet_age_mod DESC, LName;",
      "SELECT COUNT(*) AS student_count, AVG(pet_age_mod) AS avg_age_mod FROM get_students_with_pet_age_mod();"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named get_students_with_pet_age_mod that returns a table (StuID bigint, Fname text, LName text, PetID bigint, pet_age_mod bigint). The function uses RETURN QUERY to select from the Student (s), Has_Pet (hp), and Pets (p) tables. Join s to hp on s.StuID = hp.StuID, then join to p on hp.PetID = p.PetID. Return s.StuID, s.Fname, s.LName, p.PetID, and MOD(p.pet_age, 2) as pet_age_mod.",
    "natural_language": "What PostgreSQL PL/pgSQL function can be created to return a table with StuID, Fname, LName, PetID, and pet_age_mod by selecting and joining the Student, Has_Pet, and Pets tables, and calculating MOD(p.pet_age, 2)?",
    "id": 89,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_students_with_pet_age_mod that returns a table structure with five columns: StuID of type bigint, Fname of type text, LName of type text, PetID of type bigint, and pet_age_mod of type bigint. The function begins execution by issuing a RETURN QUERY command to return the result set of a SELECT statement. This SELECT statement retrieves data from three tables: Student (aliased as s), Has_Pet (aliased as hp), and Pets (aliased as p). It specifically selects the StuID column from the Student table, the Fname column from the Student table, the LName column from the Student table, the PetID column from the Pets table, and a computed column using the MOD function. The MOD function is applied to the pet_age column from the Pets table with a divisor of 2, and the result is aliased as pet_age_mod. The tables are joined using INNER JOIN operations: first, the Student table is joined with the Has_Pet table on the condition that the StuID column from Student equals the StuID column from Has_Pet. Then, the result of that join is joined with the Pets table on the condition that the PetID column from Has_Pet equals the PetID column from Pets. The function returns all rows resulting from this joined query, effectively listing each student, their associated pet, and a modified pet age which is the remainder when the pet's age is divided by two."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_council_tax_summary that returns a table with two columns, customer_name of type text and tax_count of type bigint, and accepts one input parameter p_min_tax_id of type bigint, which serves as a threshold identifier for filtering council tax records. The function's logic is determined by a conditional IF statement that checks if the input parameter p_min_tax_id is greater than 100. If this condition is true, the function executes a RETURN QUERY that performs a SELECT statement joining three tables: it starts from the \"Customer_Master_Index\" table aliased as cmi, performs an INNER JOIN with the \"CMI_Cross_References\" table aliased as ccr on the condition that cmi.master_customer_id equals ccr.master_customer_id, and then performs an INNER JOIN with the \"Council_Tax\" table aliased as ct on the condition that ccr.cmi_cross_ref_id equals ct.cmi_cross_ref_id. The WHERE clause filters the results to include only rows from the \"Council_Tax\" table where the ct.council_tax_id column value is strictly greater than the input parameter p_min_tax_id. The query then groups the result set by the cmi.cmi_details column and, for each group, returns the cmi.cmi_details value and a count of the number of ct.council_tax_id entries in that group. If the initial IF condition is false (meaning p_min_tax_id is less than or equal to 100), the function executes an alternative RETURN QUERY with a SELECT statement that also queries from the \"Customer_Master_Index\" table aliased as cmi but uses LEFT JOIN operations: first a LEFT JOIN with the \"CMI_Cross_References\" table aliased as ccr on cmi.master_customer_id = ccr.master_customer_id, and then a LEFT JOIN with the \"Council_Tax\" table aliased as ct on ccr.cmi_cross_ref_id = ct.cmi_cross_ref_id. This query groups all results by the cmi.cmi_details column and, for each unique cmi.cmi_details value, returns that value along with a constant integer 0 cast explicitly as a bigint, effectively returning a zero count for every customer regardless of the existence of related cross-reference or council tax records.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_council_tax_summary(p_min_tax_id bigint)\nRETURNS TABLE(customer_name text, tax_count bigint) AS $$\nBEGIN\n    IF p_min_tax_id > 100 THEN\n        RETURN QUERY SELECT cmi.cmi_details, COUNT(ct.council_tax_id)\n        FROM \"Customer_Master_Index\" cmi\n        JOIN \"CMI_Cross_References\" ccr ON cmi.master_customer_id = ccr.master_customer_id\n        JOIN \"Council_Tax\" ct ON ccr.cmi_cross_ref_id = ct.cmi_cross_ref_id\n        WHERE ct.council_tax_id > p_min_tax_id\n        GROUP BY cmi.cmi_details;\n    ELSE\n        RETURN QUERY SELECT cmi.cmi_details, 0::bigint\n        FROM \"Customer_Master_Index\" cmi\n        LEFT JOIN \"CMI_Cross_References\" ccr ON cmi.master_customer_id = ccr.master_customer_id\n        LEFT JOIN \"Council_Tax\" ct ON ccr.cmi_cross_ref_id = ct.cmi_cross_ref_id\n        GROUP BY cmi.cmi_details;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_Cross_References",
      "Customer_Master_Index",
      "Council_Tax",
      "Benefits_Overpayments"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_council_tax_summary(1);",
      "SELECT * FROM calculate_council_tax_summary(50);",
      "SELECT * FROM calculate_council_tax_summary(101);",
      "SELECT * FROM calculate_council_tax_summary(1000);",
      "SELECT * FROM calculate_council_tax_summary(0);"
    ],
    "summary": "Create a function named calculate_council_tax_summary that returns a table with columns customer_name (text) and tax_count (bigint). It accepts a bigint parameter p_min_tax_id. If p_min_tax_id > 100, return a query joining Customer_Master_Index, CMI_Cross_References, and Council_Tax with INNER JOINs, filtering where council_tax_id > p_min_tax_id, grouping by cmi_details, and selecting cmi_details and count of council_tax_id. Otherwise, return a query joining the same tables with LEFT JOINs, grouping by cmi_details, and selecting cmi_details and a constant 0 for tax_count.",
    "natural_language": "Create function calculate_council_tax_summary returning table(customer_name text, tax_count bigint). Takes bigint p_min_tax_id. If p_min_tax_id > 100, inner join Customer_Master_Index, CMI_Cross_References, and Council_Tax where council_tax_id > p_min_tax_id, group by cmi_details, select cmi_details and count(council_tax_id). Else, left join same tables, group by cmi_details, select cmi_details and 0 as tax_count.",
    "id": 90,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `calculate_council_tax_summary` that accepts one input parameter `p_min_tax_id` of type `bigint` and returns a table structure with two columns: `customer_name` of type `text` and `tax_count` of type `bigint`. The function's primary purpose is to generate a summary of council tax records, counting them per customer, but its behavior changes based on the value of the input parameter.\n\nThe function does not declare any explicit local variables. Its logic is entirely contained within a conditional SQL query.\n\nThe function's execution begins by evaluating the input parameter `p_min_tax_id`. The control flow is determined by an `IF` statement that checks if `p_min_tax_id` is greater than `100`.\n\nIf the condition `p_min_tax_id > 100` evaluates to `TRUE`, the function executes a `SELECT` query that performs an inner join across three tables: `Customer_Master_Index`, `CMI_Cross_References`, and `Council_Tax`. The join conditions are as follows: the `Customer_Master_Index` table is joined to the `CMI_Cross_References` table on the equality of `Customer_Master_Index.master_customer_id` and `CMI_Cross_References.master_customer_id`. The resulting set is then joined to the `Council_Tax` table on the equality of `CMI_Cross_References.cmi_cross_ref_id` and `Council_Tax.cmi_cross_ref_id`. This query includes a `WHERE` clause that filters the results to include only those rows from the `Council_Tax` table where the `council_tax_id` column is greater than the input parameter `p_min_tax_id`. The results are then grouped by the `cmi_details` column from the `Customer_Master_Index` table. For each group, the query selects the `cmi_details` value (aliased as `customer_name`) and the count of distinct `council_tax_id` values from the `Council_Tax` table (aliased as `tax_count`). The result set of this query is returned directly by the function.\n\nIf the condition `p_min_tax_id > 100` evaluates to `FALSE` (i.e., `p_min_tax_id` is less than or equal to 100), the function executes a different `SELECT` query. This query performs a left join across the same three tables: `Customer_Master_Index`, `CMI_Cross_References`, and `Council_Tax`. The join conditions are identical: `Customer_Master_Index` is left joined to `CMI_Cross_References` on `master_customer_id`, and the result is left joined to `Council_Tax` on `cmi_cross_ref_id`. This query does not have a `WHERE` clause filtering on `council_tax_id`. The results are grouped by the `cmi_details` column from the `Customer_Master_Index` table. For each group, the query selects the `cmi_details` value (aliased as `customer_name`) and a constant value of `0` (aliased as `tax_count`). The result set of this query is returned directly by the function.\n\nThe function concludes by returning the appropriate result set based on the evaluated condition. The `Benefits_Overpayments` table is not referenced or used in either branch of the function's logic."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single input parameter subject_id_input of type BIGINT, representing the unique identifier of a subject, and returns a BIGINT value indicating the total number of student registrations associated with courses under that subject. The function begins by declaring a local variable enrolment_count of type BIGINT to store the count of registrations. It then performs a SELECT query to count the number of rows in the \"Student_Course_Enrolment\" table, specifically the registration_id column, where the course_id in the \"Student_Course_Enrolment\" table matches the course_id in the \"Courses\" table, and the subject_id in the \"Courses\" table matches the input parameter subject_id_input. The result of this query is stored in the enrolment_count variable. After the query execution, the function evaluates whether enrolment_count is greater than 0 using an IF conditional statement. If enrolment_count is greater than 0, the function returns the value of enrolment_count; otherwise, it returns 0.",
    "plsql": "CREATE OR REPLACE FUNCTION get_subject_popularity(subject_id_input BIGINT)\nRETURNS BIGINT AS $$\nDECLARE\n  enrolment_count BIGINT;\nBEGIN\n  SELECT COUNT(e.registration_id) INTO enrolment_count\n  FROM \"Student_Course_Enrolment\" e\n  JOIN \"Courses\" c ON e.course_id = c.course_id\n  WHERE c.subject_id = subject_id_input;\n\n  IF enrolment_count > 0 THEN\n    RETURN enrolment_count;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_subject_popularity(1);",
      "SELECT get_subject_popularity(2);",
      "SELECT get_subject_popularity(3);",
      "SELECT get_subject_popularity(100);",
      "SELECT get_subject_popularity(5);"
    ],
    "summary": "Create a function that takes a subject_id_input (BIGINT) and returns a BIGINT count of student registrations for courses under that subject from the Student_Course_Enrolment and Courses tables. Return 0 if the count is zero.",
    "natural_language": "Please construct a function that accepts a subject identifier, of type BIGINT, as its input parameter. This function shall compute and return a BIGINT value representing the total number of student registrations for all courses associated with the specified subject, utilizing data from the Student_Course_Enrolment and Courses tables. In the event that no such registrations are found, the function must return a value of zero.",
    "id": 91,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_subject_popularity that takes a single input parameter named subject_identifier of data type BIGINT and returns a value of data type BIGINT. The function will compute the total number of student registrations for all courses associated with the specified subject identifier. This is achieved by performing a SELECT query that aggregates data from the Student_Course_Enrolment and Courses tables. Specifically, the query will join the Courses table with the Student_Course_Enrolment table using the course_id column as the join condition. The join will be an inner join, ensuring that only courses with existing student registrations are considered. The WHERE clause will filter the results to include only those rows where the subject_id column in the Courses table matches the input parameter subject_identifier. The aggregation will use the COUNT function applied to the registration_id column from the Student_Course_Enrolment table to calculate the total number of registrations. The result of this COUNT aggregation will be stored into a variable of type BIGINT. The function will include exception handling using a BEGIN...EXCEPTION block to catch any errors that occur during the SELECT operation. If an error is caught, the function will return a value of zero. Additionally, if the SELECT query returns no rows or a NULL value for the count, the function will also return zero. The function will end by returning the computed count value. The database context is e_learning, and the object type is a PostgreSQL PL/pgSQL function."
  },
  {
    "ir": "Write a PLpgSQL function named determine_overpayment_category that accepts a single parameter p_council_tax_id of type bigint, which represents the council tax identifier. The function aims to categorize overpayments based on the source system code associated with the given council tax ID. It begins by declaring two local variables: v_source_code and v_category, both of type text. The function performs a SELECT operation to retrieve the source_system_code from the Benefits_Overpayments table, aliased as bo, by joining it with the CMI_Cross_References table, aliased as cr, using the cmi_cross_ref_id column as the join condition. The WHERE clause filters the results to match the council_tax_id column in the Benefits_Overpayments table with the input parameter p_council_tax_id. The retrieved source_system_code is stored in the v_source_code variable. The function then uses a series of conditional statements to determine the overpayment category based on the value of v_source_code. If v_source_code equals 'Rent', the v_category variable is set to 'RENTAL_OVERPAY'. If v_source_code equals 'Parking', v_category is set to 'PARKING_OVERPAY'. If v_source_code equals 'Benefits', v_category is set to 'BENEFIT_OVERPAY'. If v_source_code equals 'Council', v_category is set to 'COUNCIL_OVERPAY'. If none of these conditions are met, v_category defaults to 'OTHER_OVERPAY'. The function concludes by returning the value of v_category. Additionally, the function includes an exception handler for the NO_DATA_FOUND exception, which returns 'UNKNOWN_OVERPAY' if no matching data is found during the SELECT operation.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_overpayment_category(p_council_tax_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_source_code text;\n    v_category text;\nBEGIN\n    SELECT source_system_code INTO v_source_code\n    FROM \"Benefits_Overpayments\" bo\n    JOIN \"CMI_Cross_References\" cr ON bo.cmi_cross_ref_id = cr.cmi_cross_ref_id\n    WHERE bo.council_tax_id = p_council_tax_id;\n\n    IF v_source_code = 'Rent' THEN\n        v_category := 'RENTAL_OVERPAY';\n    ELSIF v_source_code = 'Parking' THEN\n        v_category := 'PARKING_OVERPAY';\n    ELSIF v_source_code = 'Benefits' THEN\n        v_category := 'BENEFIT_OVERPAY';\n    ELSIF v_source_code = 'Council' THEN\n        v_category := 'COUNCIL_OVERPAY';\n    ELSE\n        v_category := 'OTHER_OVERPAY';\n    END IF;\n\n    RETURN v_category;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 'UNKNOWN_OVERPAY';\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Council_Tax",
      "CMI_Cross_References",
      "Customer_Master_Index"
    ],
    "call_sqls": [
      "SELECT determine_overpayment_category(3);",
      "SELECT determine_overpayment_category(6);",
      "SELECT determine_overpayment_category(7);",
      "SELECT determine_overpayment_category(1);",
      "SELECT determine_overpayment_category(999);"
    ],
    "summary": "Create a PL/pgSQL function named determine_overpayment_category that takes a council_tax_id (bigint) and returns a text category. It retrieves the source_system_code from a join of Benefits_Overpayments and CMI_Cross_References tables. The category is set based on the source code: 'RENTAL_OVERPAY' for 'Rent', 'PARKING_OVERPAY' for 'Parking', 'BENEFIT_OVERPAY' for 'Benefits', 'COUNCIL_OVERPAY' for 'Council', else 'OTHER_OVERPAY'. Handle NO_DATA_FOUND by returning 'UNKNOWN_OVERPAY'.",
    "natural_language": "Write a PL/pgSQL function called determine_overpayment_category that accepts a council_tax_id (bigint) and outputs a text category. Fetch the source_system_code by joining the Benefits_Overpayments and CMI_Cross_References tables. Assign the category as follows: 'RENTAL_OVERPAY' for 'Rent', 'PARKING_OVERPAY' for 'Parking', 'BENEFIT_OVERPAY' for 'Benefits', 'COUNCIL_OVERPAY' for 'Council', and 'OTHER_OVERPAY' for any other source. If no data is found, return 'UNKNOWN_OVERPAY'.",
    "id": 92,
    "generated_ir": "Write a PLpgSQL function named determine_overpayment_category that accepts a single parameter p_council_tax_id of type bigint, which represents the council tax identifier. The function aims to categorize overpayments based on the source system code associated with the given council tax ID. It begins by declaring two local variables: v_source_code and v_category, both of type text. The function performs a SELECT operation to retrieve the source_system_code from the Benefits_Overpayments table, aliased as bo, by joining it with the CMI_Cross_References table, aliased as cr, using the cmi_cross_ref_id column as the join condition. The WHERE clause filters the results to match the council_tax_id column in the Benefits_Overpayments table with the input parameter p_council_tax_id. The retrieved source_system_code is stored in the v_source_code variable. The function then uses a series of conditional statements to determine the overpayment category based on the value of v_source_code. If v_source_code equals 'Rent', the v_category variable is set to 'RENTAL_OVERPAY'. If v_source_code equals 'Parking', v_category is set to 'PARKING_OVERPAY'. If v_source_code equals 'Benefits', v_category is set to 'BENEFIT_OVERPAY'. If v_source_code equals 'Council', v_category is set to 'COUNCIL_OVERPAY'. If none of these conditions are met, v_category defaults to 'OTHER_OVERPAY'. The function concludes by returning the value of v_category. Additionally, the function includes an exception handler for the NO_DATA_FOUND exception, which returns 'UNKNOWN_OVERPAY' if no matching data is found during the SELECT operation."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_student_test_status` that accepts a single input parameter, `student_id_input`, of type `BIGINT`. This function is designed to return a `TEXT` value indicating whether a specific student has taken any tests.\n\nUpon execution, the function declares a local variable named `test_status` of type `TEXT` to store the determined status.\n\nThe core operation of the function involves a `SELECT` statement that queries two tables: `\"Student_Course_Enrolment\"` (aliased as `e`) and `\"Student_Tests_Taken\"` (aliased as `t`). The `SELECT` statement performs a `LEFT JOIN` operation between these two tables. The join condition `e.registration_id = t.registration_id` links records from `\"Student_Course_Enrolment\"` to `\"Student_Tests_Taken\"` based on their common `registration_id` column. This `LEFT JOIN` ensures that all enrolment records for the specified student are considered, even if there are no corresponding test records.\n\nA `WHERE` clause filters the results of the join, specifically targeting records where the `student_id` column in the `\"Student_Course_Enrolment\"` table matches the value provided by the `student_id_input` parameter.\n\nWithin the `SELECT` statement, a `CASE` expression is used to determine the `test_status`. The `CASE` expression evaluates the `COUNT(t.test_result)` aggregate function. This counts the number of non-NULL values in the `test_result` column from the `\"Student_Tests_Taken\"` table for the joined records.\nIf `COUNT(t.test_result)` is greater than `0`, meaning at least one test result exists for the student's enrolments, the `CASE` expression evaluates to the string literal `'Tests Taken'`.\nOtherwise, if `COUNT(t.test_result)` is `0` (indicating no test results or no tests associated with the student's enrolments), the `CASE` expression evaluates to the string literal `'No Tests Taken'`.\n\nThe result of this `CASE` expression is then assigned to the `test_status` local variable using the `INTO` clause.\n\nFinally, the function returns the value stored in the `test_status` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_test_status(student_id_input BIGINT)\nRETURNS TEXT AS $$\nDECLARE\n  test_status TEXT;\nBEGIN\n  SELECT CASE \n           WHEN COUNT(t.test_result) > 0 THEN 'Tests Taken'\n           ELSE 'No Tests Taken'\n         END INTO test_status\n  FROM \"Student_Course_Enrolment\" e\n  LEFT JOIN \"Student_Tests_Taken\" t ON e.registration_id = t.registration_id\n  WHERE e.student_id = student_id_input;\n\n  RETURN test_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_learning",
    "tables": [
      "Course_Authors_and_Tutors",
      "Courses",
      "Student_Course_Enrolment",
      "Student_Tests_Taken",
      "Students",
      "Subjects"
    ],
    "call_sqls": [
      "SELECT get_student_test_status(11);",
      "SELECT get_student_test_status(15);",
      "SELECT get_student_test_status(10);",
      "SELECT get_student_test_status(1);",
      "SELECT get_student_test_status(100);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_student_test_status` that takes a `BIGINT` parameter `student_id_input` and returns a `TEXT` status. It should perform a left join between `\"Student_Course_Enrolment\"` and `\"Student_Tests_Taken\"` on `registration_id` for the given student. Use a CASE expression to return 'Tests Taken' if `COUNT(test_result) > 0`, otherwise return 'No Tests Taken'.",
    "natural_language": "Develop a comprehensive PostgreSQL PL/pgSQL function, which should be named `get_student_test_status`, designed to accept a single input parameter of type `BIGINT` called `student_id_input` and to ultimately yield a `TEXT` value representing a status. This function must meticulously execute a left join operation, specifically between the `\"Student_Course_Enrolment\"` table and the `\"Student_Tests_Taken\"` table, using the `registration_id` column as the joining condition, but only for the specific student identified by the provided input parameter. Furthermore, within its logic, it should employ a detailed CASE expression to carefully evaluate the data; if the count of `test_result` entries is determined to be greater than zero, it must thoughtfully return the status message 'Tests Taken', otherwise, it should conclusively return the alternative status message 'No Tests Taken'.",
    "id": 93,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_student_test_status` that accepts a single input parameter, `student_id_input`, of type `BIGINT`. This function is designed to return a `TEXT` value indicating whether a specific student has taken any tests.\n\nUpon execution, the function declares a local variable named `test_status` of type `TEXT` to store the determined status.\n\nThe core operation of the function involves a `SELECT` statement that queries two tables: `\"Student_Course_Enrolment\"` (aliased as `e`) and `\"Student_Tests_Taken\"` (aliased as `t`). The `SELECT` statement performs a `LEFT JOIN` operation between these two tables. The join condition `e.registration_id = t.registration_id` links records from `\"Student_Course_Enrolment\"` to `\"Student_Tests_Taken\"` based on their common `registration_id` column. This `LEFT JOIN` ensures that all enrolment records for the specified student are considered, even if there are no corresponding test records.\n\nA `WHERE` clause filters the results of the join, specifically targeting records where the `student_id` column in the `\"Student_Course_Enrolment\"` table matches the value provided by the `student_id_input` parameter.\n\nWithin the `SELECT` statement, a `CASE` expression is used to determine the `test_status`. The `CASE` expression evaluates the `COUNT(t.test_result)` aggregate function. This counts the number of non-NULL values in the `test_result` column from the `\"Student_Tests_Taken\"` table for the joined records.\nIf `COUNT(t.test_result)` is greater than `0`, meaning at least one test result exists for the student's enrolments, the `CASE` expression evaluates to the string literal `'Tests Taken'`.\nOtherwise, if `COUNT(t.test_result)` is `0` (indicating no test results or no tests associated with the student's enrolments), the `CASE` expression evaluates to the string literal `'No Tests Taken'`.\n\nThe result of this `CASE` expression is then assigned to the `test_status` local variable using the `INTO` clause.\n\nFinally, the function returns the value stored in the `test_status` variable as its output."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_professional_revenue that accepts two input parameters: a bigint parameter named p_prof_id representing a professional identifier and a text parameter named p_treatment_type representing a treatment type code, and returns a numeric value; within the function, a local numeric variable v_total_revenue is declared; the function executes a SELECT statement that queries the \"Treatments\" table, using the TRUNC function to round the sum of values from the cost_of_treatment column to two decimal places, and stores the result into the v_total_revenue variable; the SELECT statement includes a WHERE clause with two conditions joined by AND: the first condition filters rows where the professional_id column equals the input parameter p_prof_id, and the second condition filters rows where the treatment_type_code column equals the input parameter p_treatment_type; the function concludes by using the COALESCE function to return the value of v_total_revenue if it is not null, otherwise returning 0.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_professional_revenue(p_prof_id bigint, p_treatment_type text)\nRETURNS numeric AS $$\nDECLARE\n    v_total_revenue numeric;\nBEGIN\n    SELECT trunc(SUM(cost_of_treatment), 2) INTO v_total_revenue\n    FROM \"Treatments\"\n    WHERE professional_id = p_prof_id\n      AND treatment_type_code = p_treatment_type;\n    \n    RETURN COALESCE(v_total_revenue, 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Owners",
      "Treatments",
      "Professionals"
    ],
    "call_sqls": [
      "SELECT calculate_professional_revenue(9, 'WALK');",
      "SELECT calculate_professional_revenue(10, 'VAC');",
      "SELECT calculate_professional_revenue(4, 'EXAM');",
      "SELECT calculate_professional_revenue(1, 'GROOM');",
      "SELECT calculate_professional_revenue(2, 'BOARD');"
    ],
    "summary": "Create a PL/pgSQL function named calculate_professional_revenue that takes a professional ID (bigint) and a treatment type code (text) and returns a numeric. It calculates the total revenue by summing the cost_of_treatment for matching records in the Treatments table, rounds the result to two decimal places, and returns it. If no revenue is found, return 0.",
    "natural_language": "Write a function called calculate_professional_revenue that, for a given professional and a kind of treatment, figures out the total money brought in. It should add up the treatment costs from the relevant entries, give back the amount rounded to the nearest cent, and just return zero if there's nothing to sum up.",
    "id": 94,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named calculate_professional_revenue that accepts two input parameters: p_professional_id of type bigint, representing the unique identifier of a professional, and p_treatment_type_code of type text, representing the code for a specific treatment type. The function returns a numeric value representing the total revenue rounded to two decimal places. The function begins by declaring a local variable v_total_revenue of type numeric, initialized to zero. The function executes a single SELECT statement that sums the cost_of_treatment column from the Treatments table, filtering the rows where the professional_id column matches the input parameter p_professional_id and the treatment_type_code column matches the input parameter p_treatment_type_code. The result of the summation is stored directly into v_total_revenue. If no rows satisfy the conditions, the SUM function returns NULL, which is handled by using the COALESCE function to convert NULL to zero. The function then rounds v_total_revenue to two decimal places using the ROUND function. Finally, the function returns the rounded v_total_revenue as its output."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_birth_city_stats that accepts a single input parameter p_birth_city of type TEXT and returns a table with two columns: total_actors of type BIGINT and total_producers of type BIGINT. The function's logic is determined by the value of the p_birth_city parameter. If the parameter value is exactly equal to the string 'New York', the function executes a query that counts all rows in the actor table where the birth_city column equals 'New York', returns this count as total_actors, and returns a hardcoded zero as total_producers. If the parameter value is exactly equal to the string 'Los Angeles', the function executes a query that counts all rows in the producer table where the birth_city column equals 'Los Angeles', returns this count as total_producers, and returns a hardcoded zero as total_actors. For any other parameter value, the function executes a query that performs a Cartesian product between the actor and producer tables, then counts all rows from the actor table as total_actors and all rows from the producer table as total_producers, but only includes rows in these counts where the birth_city column from the actor table is equal to the birth_city column from the producer table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_birth_city_stats(p_birth_city TEXT)\nRETURNS TABLE(total_actors BIGINT, total_producers BIGINT) AS $$\nBEGIN\n    IF p_birth_city = 'New York' THEN\n        RETURN QUERY SELECT COUNT(*) as total_actors, 0::BIGINT as total_producers FROM actor WHERE birth_city = 'New York';\n    ELSIF p_birth_city = 'Los Angeles' THEN\n        RETURN QUERY SELECT 0::BIGINT as total_actors, COUNT(*) as total_producers FROM producer WHERE birth_city = 'Los Angeles';\n    ELSE\n        RETURN QUERY SELECT COUNT(*) as total_actors, COUNT(*) as total_producers FROM actor, producer WHERE actor.birth_city = producer.birth_city;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "producer",
      "made_by",
      "company"
    ],
    "call_sqls": [
      "SELECT * FROM get_birth_city_stats('New York');",
      "SELECT * FROM get_birth_city_stats('Los Angeles');",
      "SELECT * FROM get_birth_city_stats('Chicago');",
      "SELECT * FROM get_birth_city_stats('London');",
      "SELECT * FROM get_birth_city_stats(NULL);"
    ],
    "summary": "Create a PostgreSQL PL/pgSQL function named `get_birth_city_stats` that takes a TEXT parameter `p_birth_city` and returns a table with columns `total_actors` BIGINT and `total_producers` BIGINT. If `p_birth_city` is 'New York', count actors born there and return 0 for producers. If it's 'Los Angeles', count producers born there and return 0 for actors. For other values, perform a cross join between actor and producer tables, filter where birth cities match, and count rows from both tables.",
    "natural_language": "Write a PostgreSQL function called `get_birth_city_stats` that accepts a TEXT input for a city. It should give back a table with two columns: one for the total number of actors and another for the total number of producers, both as BIGINT. If the provided city is roughly 'New York', figure out how many actors come from around there and just put zero for producers. If it's more or less 'Los Angeles', do the oppositeâ€”tally up the producers from that general area and set the actor count to nothing. For any other city name, somehow link the actor and producer tables together, find entries where their birth cities seem to match, and then come up with counts for both groups.",
    "id": 95,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named get_birth_city_stats that accepts a single input parameter p_birth_city of type TEXT and returns a table with two columns: total_actors of type BIGINT and total_producers of type BIGINT. The function's logic is determined by the value of the p_birth_city parameter. If the parameter value is exactly equal to the string 'New York', the function executes a query that counts all rows in the actor table where the birth_city column equals 'New York', returns this count as total_actors, and returns a hardcoded zero as total_producers. If the parameter value is exactly equal to the string 'Los Angeles', the function executes a query that counts all rows in the producer table where the birth_city column equals 'Los Angeles', returns this count as total_producers, and returns a hardcoded zero as total_actors. For any other parameter value, the function executes a query that performs a Cartesian product between the actor and producer tables, then counts all rows from the actor table as total_actors and all rows from the producer table as total_producers, but only includes rows in these counts where the birth_city column from the actor table is equal to the birth_city column from the producer table."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_age_difference that accepts two integer parameters: p_actor_id and p_producer_id. The purpose of this function is to compute the absolute difference in birth years between an actor and a producer. The function first checks if there exists a record in the actor table with the aid column matching the value of p_actor_id. If such a record exists, the function proceeds to calculate the age difference by selecting the birth_year from the actor table where aid equals p_actor_id and the birth_year from the producer table where pid equals p_producer_id. It then computes the absolute difference between these two birth_year values using the ABS() function and returns this result. If no record exists in the actor table with the specified p_actor_id, the function returns -1.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_age_difference(p_actor_id integer, p_producer_id integer)\nRETURNS integer AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM actor WHERE aid = p_actor_id) THEN\n        RETURN ABS((SELECT birth_year FROM actor WHERE aid = p_actor_id) - (SELECT birth_year FROM producer WHERE pid = p_producer_id));\n    ELSE\n        RETURN -1;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "imdb",
    "tables": [
      "actor",
      "cast",
      "made_by",
      "producer"
    ],
    "call_sqls": [
      "SELECT calculate_age_difference(1, 100);",
      "SELECT calculate_age_difference(5, 150);",
      "SELECT calculate_age_difference(10, 200);",
      "SELECT calculate_age_difference(15, 250);",
      "SELECT calculate_age_difference(20, 300);"
    ],
    "summary": "Create a function named calculate_age_difference that takes an actor ID and a producer ID. Return the absolute difference in their birth years. If the actor ID does not exist, return -1.",
    "natural_language": "Hey, can you whip up a function called calculate_age_difference? It needs to take an actor's ID and a producer's ID. Just give me the absolute gap between their birth years. But if that actor ID isn't in the system, just spit out -1.",
    "id": 96,
    "generated_ir": "Write a PLpgSQL function named calculate_age_difference that accepts two integer parameters: p_actor_id and p_producer_id. The purpose of this function is to compute the absolute difference in birth years between an actor and a producer. The function first checks if there exists a record in the actor table with the aid column matching the value of p_actor_id. If such a record exists, the function proceeds to calculate the age difference by selecting the birth_year from the actor table where aid equals p_actor_id and the birth_year from the producer table where pid equals p_producer_id. It then computes the absolute difference between these two birth_year values using the ABS() function and returns this result. If no record exists in the actor table with the specified p_actor_id, the function returns -1."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_language_status that accepts two input parameters: a text parameter named lang_name representing a language name and a text parameter named country_name representing a country name, and returns a text value. The function declares a local integer variable named lang_count. It executes a SELECT statement that performs a COUNT(*) operation by joining three tables: the official_languages table aliased as ol, the languages table aliased as l, and the countries table aliased as c. The join condition links ol.language_id to l.id and ol.country_id to c.id. The WHERE clause filters the joined result set to rows where the name column from the languages table equals the input lang_name and the name column from the countries table equals the input country_name. The result of the count is stored into the lang_count variable. Following this, an IF statement checks if lang_count is greater than zero; if true, the function returns the string 'Official Language'. If the condition is false, the function executes a nested IF statement containing an EXISTS subquery. The subquery selects the constant value 1 from the languages table where the name column equals the input lang_name. If the EXISTS subquery returns true, the function returns the string 'Not Official'. If the EXISTS subquery returns false, the function returns the string 'Unknown Language'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_language_status(\"lang_name\" text, \"country_name\" text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    \"lang_count\" integer;\nBEGIN\n    SELECT COUNT(*) INTO \"lang_count\" FROM \"official_languages\" \"ol\" JOIN \"languages\" \"l\" ON \"ol\".\"language_id\" = \"l\".\"id\" JOIN \"countries\" \"c\" ON \"ol\".\"country_id\" = \"c\".\"id\" WHERE \"l\".\"name\" = \"lang_name\" AND \"c\".\"name\" = \"country_name\";\n    IF \"lang_count\" > 0 THEN\n        RETURN 'Official Language';\n    ELSE\n        IF EXISTS(SELECT 1 FROM \"languages\" WHERE \"name\" = \"lang_name\") THEN\n            RETURN 'Not Official';\n        ELSE\n            RETURN 'Unknown Language';\n        END IF;\n    END IF;\nEND;\n$$;",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "SELECT get_language_status('English', 'Canada');",
      "SELECT get_language_status('Swedish', 'Sweden');",
      "SELECT get_language_status('Icelandic', 'Iceland');",
      "SELECT get_language_status('French', 'Canada');",
      "SELECT get_language_status('Spanish', 'Sweden');"
    ],
    "summary": "Create a function named get_language_status that takes a language name and a country name. Return 'Official Language' if the language is officially used in that country, 'Not Official' if the language exists but is not official there, or 'Unknown Language' if the language does not exist.",
    "natural_language": "Define a function called 'get_language_status' that accepts two parameters: a language name and a country name. The function shall return the string 'Official Language' if the specified language holds official status in the given country. Should the language be present in the country but not possess official status, the function must return 'Not Official'. In the event the language is not associated with the country, the function is to return 'Unknown Language'.",
    "id": 97,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_language_status that accepts two input parameters: a text parameter named lang_name representing a language name and a text parameter named country_name representing a country name, and returns a text value. The function declares a local integer variable named lang_count. It executes a SELECT statement that performs a COUNT(*) operation by joining three tables: the official_languages table aliased as ol, the languages table aliased as l, and the countries table aliased as c. The join condition links ol.language_id to l.id and ol.country_id to c.id. The WHERE clause filters the joined result set to rows where the name column from the languages table equals the input lang_name and the name column from the countries table equals the input country_name. The result of the count is stored into the lang_count variable. Following this, an IF statement checks if lang_count is greater than zero; if true, the function returns the string 'Official Language'. If the condition is false, the function executes a nested IF statement containing an EXISTS subquery. The subquery selects the constant value 1 from the languages table where the name column equals the input lang_name. If the EXISTS subquery returns true, the function returns the string 'Not Official'. If the EXISTS subquery returns false, the function returns the string 'Unknown Language'."
  },
  {
    "ir": "Write a PLpgSQL function that takes an integer parameter p_university_id and returns an integer representing the count of rows in the major_ranking table where the University_ID column matches the provided p_university_id. The function performs a SELECT COUNT(*) operation on the major_ranking table, filtering the results based on the condition that the University_ID column is equal to the input parameter p_university_id. The function is defined using the plpgsql language and is designed to encapsulate the logic for counting the number of majors associated with a specific university, identified by the university's unique identifier passed as the parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION count_majors_for_university(p_university_id integer)\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM major_ranking WHERE \"University_ID\" = p_university_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_rank",
    "tables": [
      "major",
      "major_ranking",
      "overall_ranking",
      "university"
    ],
    "call_sqls": [
      "SELECT count_majors_for_university(1);",
      "SELECT count_majors_for_university(2);",
      "SELECT count_majors_for_university(3);",
      "SELECT count_majors_for_university(10);",
      "SELECT count_majors_for_university(NULL);"
    ],
    "summary": "Create a PLpgSQL function that takes an integer p_university_id and returns an integer count of majors in the major_ranking table for that university.",
    "natural_language": "How many majors are listed in the major_ranking table for a given university, identified by its ID?",
    "id": 98,
    "generated_ir": "Write a PLpgSQL function that takes an integer parameter p_university_id and returns an integer representing the count of rows in the major_ranking table where the University_ID column matches the provided p_university_id. The function performs a SELECT COUNT(*) operation on the major_ranking table, filtering the results based on the condition that the University_ID column is equal to the input parameter p_university_id. The function is defined using the plpgsql language and is designed to encapsulate the logic for counting the number of majors associated with a specific university, identified by the university's unique identifier passed as the parameter."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_student_major_count` that accepts a single input parameter named `city_code_input` of data type `TEXT`. This function is designed to return a single value of data type `BIGINT`. The primary purpose of this function is to calculate and return the count of distinct major values associated with students residing in a specific city, as identified by the provided `city_code_input`.\n\nUpon execution, the function declares a local variable named `major_count` of data type `BIGINT`. The core operation involves a `SELECT` statement that queries the table named `\"Student\"`. Within this `SELECT` statement, the `COUNT` aggregate function is applied to the `DISTINCT` values found in the column named `\"Major\"`. This `COUNT(DISTINCT \"Major\")` operation effectively tallies the number of unique major designations. The selection of rows for this count is constrained by a `WHERE` clause, which specifies that only those rows where the value in the column named `\"city_code\"` is exactly equal to the value provided in the `city_code_input` parameter should be considered. The result of this `COUNT(DISTINCT \"Major\")` operation is then assigned to the previously declared local variable `major_count`. Finally, the function concludes by returning the value stored in the `major_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_major_count(city_code_input TEXT) RETURNS BIGINT AS $$\nDECLARE\n    major_count BIGINT;\nBEGIN\n    SELECT COUNT(DISTINCT \"Major\") INTO major_count FROM \"Student\" WHERE \"city_code\" = city_code_input;\n    RETURN major_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "SELECT get_student_major_count('BAL');",
      "SELECT get_student_major_count('PIT');",
      "SELECT get_student_major_count('PHL');",
      "SELECT get_student_major_count('HKG');",
      "SELECT get_student_major_count('WAS');"
    ],
    "summary": "Create a PL/pgSQL function named get_student_major_count that takes a TEXT city_code_input and returns a BIGINT. It counts the distinct \"Major\" values from the \"Student\" table where the \"city_code\" matches the input parameter.",
    "natural_language": "How many distinct majors are there for students in a given city code?",
    "id": 99,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_student_major_count that takes a single input parameter of type text, representing a city code, and returns a bigint value. The function operates on the address_1 database and uses the City and Student tables. The function's purpose is to count the number of distinct majors for students residing in the specified city code.\n\nWithin the function, it declares a variable of type bigint to hold the result. The function executes a SELECT query that performs an inner join between the Student table and the City table using the city_code column as the join condition. The query filters the joined result set to include only rows where the Student.city_code matches the input parameter value. From this filtered set, it counts the distinct values in the Student.Major column using the COUNT(DISTINCT ...) aggregate function. The result of this count is stored in the declared variable.\n\nThe function then returns the value of this variable, which represents the total number of distinct majors among students in the given city code. The function is defined using the PL/pgSQL language."
  },
  {
    "ir": "Write a PLpgSQL function named get_book_release_year that accepts two parameters: p_book_id of type integer, which specifies the unique identifier of a book, and p_format_type of type text, which determines the format of the release date to be returned. The function declares a local variable v_result of type text to store the result. It begins by checking if the value of p_format_type is equal to 'YEAR'. If this condition is true, the function executes a SELECT statement that retrieves the year part of the \"Release\" date from the book table, where the \"Book_ID\" column matches the provided p_book_id. The \"Release\" column is expected to be in the format 'Month YYYY', and the EXTRACT function is used to extract the year after converting the \"Release\" string to a date using the TO_DATE function. The extracted year is then cast to text and stored in v_result. If the condition is false, the function executes an alternative SELECT statement that retrieves the entire \"Release\" value from the book table for the specified \"Book_ID\" and stores it in v_result. Finally, the function returns the value of v_result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_book_release_year(p_book_id integer, p_format_type text)\nRETURNS text AS $$\nDECLARE\n    v_result text;\nBEGIN\n    IF p_format_type = 'YEAR' THEN\n        SELECT EXTRACT(YEAR FROM TO_DATE(\"Release\", 'Month YYYY'))::text INTO v_result FROM book WHERE \"Book_ID\" = p_book_id;\n    ELSE\n        SELECT \"Release\" INTO v_result FROM book WHERE \"Book_ID\" = p_book_id;\n    END IF;\n    RETURN v_result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "SELECT get_book_release_year(1, 'YEAR');",
      "SELECT get_book_release_year(2, 'YEAR');",
      "SELECT get_book_release_year(3, 'YEAR');",
      "SELECT get_book_release_year(1, 'FULL');",
      "SELECT get_book_release_year(2, 'FULL');"
    ],
    "summary": "Create a PL/pgSQL function named get_book_release_year that returns the release date for a given Book_ID. If the format parameter is 'YEAR', return only the year part; otherwise, return the full date string.",
    "natural_language": "What is the PL/pgSQL function definition for get_book_release_year that returns the release date for a specified Book_ID, and how does it handle returning only the year when the format is 'YEAR' versus the full date string otherwise?",
    "id": 100,
    "generated_ir": "Write a PLpgSQL function named get_book_release_year that accepts two parameters: p_book_id of type integer, which specifies the unique identifier of a book, and p_format_type of type text, which determines the format of the release date to be returned. The function declares a local variable v_result of type text to store the result. It begins by checking if the value of p_format_type is equal to 'YEAR'. If this condition is true, the function executes a SELECT statement that retrieves the year part of the \"Release\" date from the book table, where the \"Book_ID\" column matches the provided p_book_id. The \"Release\" column is expected to be in the format 'Month YYYY', and the EXTRACT function is used to extract the year after converting the \"Release\" string to a date using the TO_DATE function. The extracted year is then cast to text and stored in v_result. If the condition is false, the function executes an alternative SELECT statement that retrieves the entire \"Release\" value from the book table for the specified \"Book_ID\" and stores it in v_result. Finally, the function returns the value of v_result."
  }
]