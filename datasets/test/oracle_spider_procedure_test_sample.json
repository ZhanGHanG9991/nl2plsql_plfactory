[
  {
    "ir": "Write an Oracle PL/SQL stored procedure named 'sp' that accepts five input parameters: a numeric parameter 'para_stuid' representing a student identifier, a string parameter 'para_pettype' representing a type of pet, a numeric parameter 'para_age' representing an age, a numeric parameter 'para_weight' representing a weight, and a numeric parameter 'para_major' representing a major code. The procedure first checks if a student with the provided 'para_stuid' exists in the STUDENT table by selecting the count of rows where the STUID column equals 'para_stuid' into the variable 'student_exists'. If 'student_exists' is greater than zero, indicating the student exists, the procedure then selects the count of rows in the HAS_PET table where the STUID column equals 'para_stuid' into the variable 'pet_count' to determine how many pets the student currently has. If 'pet_count' equals zero, meaning the student has no pets, the procedure checks if a pet with the exact combination of type and age provided in parameters 'para_pettype' and 'para_age' already exists in the PETS table by selecting the count of rows where the PETTYPE column equals 'para_pettype' and the PET_AGE column equals 'para_age' into the variable 'pet_exists'. If 'pet_exists' is greater than zero, the procedure calculates a new pet identifier by selecting the maximum existing PETID value from the PETS table, using the NVL function to default to 2000 if the maximum is null, and adding 1 to that result, storing it in the variable 'new_petid'. It then inserts a new row into the PETS table with columns PETID set to 'new_petid', PETTYPE set to 'para_pettype', PET_AGE set to 'para_age', and WEIGHT set to 'para_weight', and subsequently inserts a new row into the HAS_PET table with columns STUID set to 'para_stuid' and PETID set to 'new_petid' to establish the ownership relationship. If, however, 'pet_exists' is zero, the procedure calculates the average WEIGHT from the PETS table for all pets of the type specified in 'para_pettype', storing the result in the variable 'avg_weight'. If 'avg_weight' is greater than the input parameter 'para_weight', the procedure inserts a new row directly into the PETS table with columns PETID set to the value of 'para_stuid' plus 1000, PETTYPE set to 'para_pettype', PET_AGE set to 'para_age', and WEIGHT set to 'para_weight'. If 'avg_weight' is not greater than 'para_weight', the procedure deletes the student's record from the STUDENT table where the STUID column equals 'para_stuid'. If the initial 'pet_count' for the existing student is equal to 1, the procedure calculates the average PET_AGE for the pets owned by that specific student by joining the PETS table (aliased as 'p') and the HAS_PET table (aliased as 'hp') on the PETID column and selecting the average where 'hp.STUID' equals 'para_stuid', storing the result in the variable 'avg_weight'. If this calculated average age ('avg_weight') is greater than the input parameter 'para_age', the procedure deletes the ownership record from the HAS_PET table for that student where the STUID column equals 'para_stuid'. If the average age is not greater than 'para_age', the procedure inserts a new row into the PETS table with columns PETID set to the value of 'para_stuid' plus 2000, PETTYPE set to 'para_pettype', PET_AGE set to 'para_age', and WEIGHT set to 'para_weight'. If the initial 'pet_count' for the existing student is neither 0 nor 1 (meaning the student has two or more pets), the procedure deletes a single ownership record from the HAS_PET table for that student where the STUID column equals 'para_stuid', using the condition 'ROWNUM = 1' to limit the deletion to one arbitrary row. If the initial check finds that 'student_exists' is zero, meaning the student does not exist, the procedure inserts a new row into the STUDENT table with columns STUID set to 'para_stuid', LNAME set to the literal string 'Default', FNAME set to the literal string 'Student', AGE set to the input parameter 'para_age', and MAJOR set to the input parameter 'para_major'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_stuid NUMBER, para_pettype VARCHAR2, para_age NUMBER, para_weight NUMBER, para_major NUMBER) IS\npet_count NUMBER;\nstudent_exists NUMBER;\nnew_petid NUMBER;\npet_exists NUMBER;\navg_weight NUMBER;\nBEGIN\nSELECT COUNT(*) INTO student_exists FROM STUDENT WHERE STUID = para_stuid;\nIF student_exists > 0 THEN\nSELECT COUNT(*) INTO pet_count FROM HAS_PET WHERE STUID = para_stuid;\nIF pet_count = 0 THEN\nSELECT COUNT(*) INTO pet_exists FROM PETS WHERE PETTYPE = para_pettype AND PET_AGE = para_age;\nIF pet_exists > 0 THEN\nSELECT NVL(MAX(PETID), 2000) + 1 INTO new_petid FROM PETS;\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (new_petid, para_pettype, para_age, para_weight);\nINSERT INTO HAS_PET (STUID, PETID) VALUES (para_stuid, new_petid);\nELSE\nSELECT AVG(WEIGHT) INTO avg_weight FROM PETS WHERE PETTYPE = para_pettype;\nIF avg_weight > para_weight THEN\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (para_stuid + 1000, para_pettype, para_age, para_weight);\nELSE\nDELETE FROM STUDENT WHERE STUID = para_stuid;\nEND IF;\nEND IF;\nELSIF pet_count = 1 THEN\nSELECT AVG(PET_AGE) INTO avg_weight FROM PETS p JOIN HAS_PET hp ON p.PETID = hp.PETID WHERE hp.STUID = para_stuid;\nIF avg_weight > para_age THEN\nDELETE FROM HAS_PET WHERE STUID = para_stuid;\nELSE\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (para_stuid + 2000, para_pettype, para_age, para_weight);\nEND IF;\nELSE\nDELETE FROM HAS_PET WHERE STUID = para_stuid AND ROWNUM = 1;\nEND IF;\nELSE\nINSERT INTO STUDENT (STUID, LNAME, FNAME, AGE, MAJOR) VALUES (para_stuid, 'Default', 'Student', para_age, para_major);\nEND IF;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1004, 'dog', 2, 15.5, 600);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1005, 'cat', 4, 8.2, 550);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1001, 'bird', 1, 0.5, 600);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1002, 'dog', 3, 25.0, 620);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(9999, 'rabbit', 2, 3.7, 580);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named 'sp' that adds a pet for a student. Inputs: student ID, pet type, age, weight, and major code. If the student exists, check their current pet count. If they have no pets, check if a pet with the same type and age exists. If it does, generate a new pet ID, insert the pet, and link it to the student. If it doesn't, compare the pet's weight to the average weight for its type. If the weight is lower, insert the pet with an ID based on the student ID. If not, delete the student. If the student has one pet, compare the input age to the student's average pet age. If the input age is lower, delete the pet link. If not, insert a new pet with an ID based on the student ID. If the student has two or more pets, delete one arbitrary pet link. If the student does not exist, insert a new default student record.",
    "natural_language": "Write a stored procedure called 'sp' to add a pet for a student. Use the student ID, pet type, age, weight, and major code as inputs. First, check if the student exists. If they do, examine their current number of pets. For a student with no pets, see if a pet with the same type and age already exists. If such a pet exists, generate a new pet ID, insert the pet, and link it to the student. If it doesn't, compare the pet's weight to the average weight for its type. Insert the pet with an ID based on the student ID if the weight is lower; otherwise, delete the student. For a student with one pet, compare the input age to the student's average pet age. Delete the pet link if the input age is lower; if not, insert a new pet with an ID based on the student ID. If the student has two or more pets, delete one arbitrary pet link. If the student does not exist, insert a new default student record.",
    "id": 1,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts five input parameters: `p_stuid` of type `NUMBER`, `p_pettype` of type `VARCHAR2`, `p_pet_age` of type `NUMBER`, `p_weight` of type `NUMBER`, and `p_major_code` of type `NUMBER`. The procedure is designed to add a pet for a student based on the student's current pet ownership status and various conditions related to existing pets.\n\nFirst, the procedure declares several local variables:\n- `v_student_exists` of type `NUMBER` to store a count indicating whether the student exists.\n- `v_pet_count` of type `NUMBER` to store the current number of pets owned by the student.\n- `v_avg_weight` of type `NUMBER` to store the average weight for a given pet type.\n- `v_avg_pet_age` of type `NUMBER` to store the average age of pets owned by the student.\n- `v_existing_petid` of type `NUMBER` to store the `PETID` of an existing pet that matches the input type and age.\n- `v_new_petid` of type `NUMBER` to store a newly generated pet ID.\n- `v_arbitrary_petid` of type `NUMBER` to store an arbitrary `PETID` from the student's current pets.\n\nThe procedure begins by checking if the student exists. It executes a `SELECT COUNT(*)` query on the `STUDENT` table, counting rows where the `STUID` column equals the input parameter `p_stuid`. The result is stored in `v_student_exists`.\n\nIf `v_student_exists` is greater than 0 (meaning the student exists), the procedure then determines the student's current number of pets. It executes a `SELECT COUNT(*)` query on the `HAS_PET` table, counting rows where the `STUID` column equals `p_stuid`. The result is stored in `v_pet_count`.\n\nThe procedure then branches based on the value of `v_pet_count`:\n\nCase 1: `v_pet_count` equals 0 (student has no pets).\n- The procedure checks if a pet with the same type and age already exists. It executes a `SELECT PETID` query on the `PETS` table, retrieving the `PETID` where the `PETTYPE` column equals `p_pettype` and the `PET_AGE` column equals `p_pet_age`. This result is stored in `v_existing_petid`.\n- If `v_existing_petid` is not `NULL` (such a pet exists), the procedure generates a new pet ID by selecting the maximum `PETID` from the `PETS` table, using `NVL` to treat `NULL` as 0, and adding 1. This value is stored in `v_new_petid`. It then inserts a new row into the `PETS` table with `PETID` set to `v_new_petid`, `PETTYPE` set to `p_pettype`, `PET_AGE` set to `p_pet_age`, and `WEIGHT` set to `p_weight`. Finally, it inserts a new row into the `HAS_PET` table linking `p_stuid` and `v_new_petid`.\n- If `v_existing_petid` is `NULL` (no such pet exists), the procedure calculates the average weight for the input pet type. It executes a `SELECT AVG(WEIGHT)` query on the `PETS` table where `PETTYPE` equals `p_pettype`, storing the result in `v_avg_weight`. Then, it compares the input `p_weight` to `v_avg_weight`. If `p_weight` is less than `v_avg_weight`, it generates a new pet ID by concatenating `p_stuid` with a sequence number (e.g., `p_stuid * 1000 + 1`), stores it in `v_new_petid`, and inserts a new row into the `PETS` table with `PETID` set to `v_new_petid`, `PETTYPE` set to `p_pettype`, `PET_AGE` set to `p_pet_age`, and `WEIGHT` set to `p_weight`, followed by inserting a link in `HAS_PET`. If `p_weight` is not less than `v_avg_weight`, it deletes the student from the `STUDENT` table where `STUID` equals `p_stuid`.\n\nCase 2: `v_pet_count` equals 1 (student has one pet).\n- The procedure calculates the average age of the student's pets. It executes a `SELECT AVG(PET_AGE)` query from the `PETS` table, joining with `HAS_PET` on `PETID` where `HAS_PET.STUID` equals `p_stuid`, storing the result in `v_avg_pet_age`.\n- It then compares the input `p_pet_age` to `v_avg_pet_age`. If `p_pet_age` is less than `v_avg_pet_age`, it deletes the pet link by executing a `DELETE` on the `HAS_PET` table where `STUID` equals `p_stuid` (removing the single existing link). If `p_pet_age` is not less than `v_avg_pet_age`, it generates a new pet ID by concatenating `p_stuid` with a sequence number (e.g., `p_stuid * 1000 + 2`), stores it in `v_new_petid`, and inserts a new row into the `PETS` table with `PETID` set to `v_new_petid`, `PETTYPE` set to `p_pettype`, `PET_AGE` set to `p_pet_age`, and `WEIGHT` set to `p_weight`, followed by inserting a link in `HAS_PET`.\n\nCase 3: `v_pet_count` is greater than or equal to 2 (student has two or more pets).\n- The procedure selects an arbitrary `PETID` from the `HAS_PET` table where `STUID` equals `p_stuid` (e.g., using `MIN(PETID)` or a similar method) and stores it in `v_arbitrary_petid`. It then deletes the pet link by executing a `DELETE` on the `HAS_PET` table where `STUID` equals `p_stuid` and `PETID` equals `v_arbitrary_petid`.\n\nIf `v_student_exists` is 0 (meaning the student does not exist), the procedure inserts a new default student record into the `STUDENT` table. It sets `STUID` to `p_stuid`, `LNAME` to a default value like 'Unknown', `FNAME` to a default value like 'Unknown', `AGE` to a default value like 18, `SEX` to a default value like 'U', `MAJOR` to the input `p_major_code`, `ADVISOR` to a default value like 0, and `CITY_CODE` to a default value like 'XXX'.\n\nThe procedure uses tables `STUDENT`, `PETS`, and `HAS_PET` with their respective columns as described, leveraging the relationships `HAS_PET.PETID = PETS.PETID` and `HAS_PET.STUID = STUDENT.STUID` for joins and conditions."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_party_payment_method` that accepts four parameters: `p_party_id` of type `NUMBER`, `p_new_payment_method` of type `VARCHAR2`, `p_email_filter` of type `VARCHAR2`, and `o_rows_updated` of type `NUMBER` which is an `OUT` parameter. The purpose of this procedure is to modify existing records within the `PARTIES` table. Specifically, it performs an `UPDATE` operation on the `PARTIES` table. For each row that satisfies the specified conditions, the `PAYMENT_METHOD_CODE` column will be set to the value provided by the `p_new_payment_method` parameter. The conditions for updating a row are as follows: the `PARTY_ID` column must exactly match the value provided by the `p_party_id` parameter, AND the `PARTY_EMAIL` column must contain the substring specified by the `p_email_filter` parameter. The `LIKE` operator is used for this substring matching, with wildcard characters (`%`) prepended and appended to the `p_email_filter` value, meaning the `PARTY_EMAIL` can contain the filter string anywhere within its value. After the `UPDATE` statement completes, the procedure assigns the number of rows that were successfully updated by the `UPDATE` statement to the `o_rows_updated` `OUT` parameter using the `SQL%ROWCOUNT` attribute.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_party_payment_method(p_party_id NUMBER, p_new_payment_method VARCHAR2, p_email_filter VARCHAR2, o_rows_updated OUT NUMBER)\nIS\nBEGIN\n    UPDATE PARTIES \n    SET PAYMENT_METHOD_CODE = p_new_payment_method \n    WHERE PARTY_ID = p_party_id \n    AND PARTY_EMAIL LIKE '%' || p_email_filter || '%';\n    o_rows_updated := SQL%ROWCOUNT;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS",
      "SERVICES"
    ],
    "call_sqls": [
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(1, 'Credit Card', 'enrico09', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(2, 'Cheque', 'brakus.aliya', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(3, 'Credit Card', 'frida57', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(1, 'Cheque', 'example.com', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n  v_rows_updated NUMBER;\nBEGIN\n  update_party_payment_method(2, 'Credit Card', 'example.org', v_rows_updated);\n  DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;"
    ],
    "summary": "Create a stored procedure named update_party_payment_method that updates the PAYMENT_METHOD_CODE in the PARTIES table where PARTY_ID matches the input ID and PARTY_EMAIL contains a specified substring. Return the number of updated rows via an OUT parameter.",
    "natural_language": "How can I create a stored procedure called update_party_payment_method that updates the PAYMENT_METHOD_CODE in the PARTIES table for a given party ID and where the party's email contains a specific substring, and how do I return the count of affected rows through an OUT parameter?",
    "id": 2,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_party_payment_method that operates within the e_government database. The procedure accepts three parameters: p_party_id as an input parameter of type NUMBER, which specifies the unique identifier of the party to update; p_email_substring as an input parameter of type VARCHAR2, which defines the substring to search for within the party's email address; and p_affected_rows as an output parameter of type NUMBER, which will hold the count of rows updated by the procedure.\n\nThe procedure performs a single SQL UPDATE operation on the PARTIES table. It updates the PAYMENT_METHOD_CODE column for rows where two conditions are met: the PARTY_ID column must exactly match the input parameter p_party_id, and the PARTY_EMAIL column must contain the substring specified by p_email_substring, using a case-insensitive search. The new value for PAYMENT_METHOD_CODE is set to 'Credit Card'. After the UPDATE operation, the procedure uses the SQL%ROWCOUNT attribute to capture the number of rows affected by the update and assigns this count to the output parameter p_affected_rows."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named merge_catalog_attributes that accepts two mandatory input parameters, both of the NUMBER data type: p_source_entry, which represents the source catalog entry identifier, and p_target_entry, which represents the target catalog entry identifier. The procedure performs a single data manipulation operation by inserting new rows into the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table. The data for the insert is sourced from a SELECT query that retrieves all rows from the same CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the CATALOG_ENTRY_ID column exactly matches the value of the input parameter p_source_entry. For each row retrieved from this source query, the INSERT statement populates the new row's columns with the following values: the CATALOG_ENTRY_ID column is set to the value of the input parameter p_target_entry, the CATALOG_LEVEL_NUMBER column is set to the CATALOG_LEVEL_NUMBER value from the source row, the ATTRIBUTE_ID column is set to the ATTRIBUTE_ID value from the source row, and the ATTRIBUTE_VALUE column is set to the ATTRIBUTE_VALUE from the source row. This operation effectively copies all additional attribute records associated with the source catalog entry (p_source_entry) to the target catalog entry (p_target_entry).",
    "plsql": "CREATE OR REPLACE PROCEDURE merge_catalog_attributes(p_source_entry NUMBER, p_target_entry NUMBER)\nIS\nBEGIN\n   INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE)\n   SELECT p_target_entry, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE\n   FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES\n   WHERE CATALOG_ENTRY_ID = p_source_entry;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 5, p_target_entry => 15);\nEND;",
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 15, p_target_entry => 11);\nEND;",
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 11, p_target_entry => 5);\nEND;",
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 5, p_target_entry => 5);\nEND;",
      "BEGIN\n  merge_catalog_attributes(p_source_entry => 1, p_target_entry => 2);\nEND;"
    ],
    "summary": "Create a stored procedure named `merge_catalog_attributes` that copies all additional attribute records from a source catalog entry to a target catalog entry in the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. It accepts the source and target entry IDs as input parameters.",
    "natural_language": "How can I create a stored procedure called `merge_catalog_attributes` that will copy all additional attribute records from a source catalog entry to a target catalog entry in the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table, using the source and target entry IDs as input parameters?",
    "id": 3,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named merge_catalog_attributes that accepts two mandatory input parameters, both of the NUMBER data type: p_source_entry, which represents the source catalog entry identifier, and p_target_entry, which represents the target catalog entry identifier. The procedure performs a single data manipulation operation by inserting new rows into the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table. The data for the insert is sourced from a SELECT query that retrieves all rows from the same CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the CATALOG_ENTRY_ID column exactly matches the value of the input parameter p_source_entry. For each row retrieved from this source query, the INSERT statement populates the new row's columns with the following values: the CATALOG_ENTRY_ID column is set to the value of the input parameter p_target_entry, the CATALOG_LEVEL_NUMBER column is set to the CATALOG_LEVEL_NUMBER value from the source row, the ATTRIBUTE_ID column is set to the ATTRIBUTE_ID value from the source row, and the ATTRIBUTE_VALUE column is set to the ATTRIBUTE_VALUE from the source row. This operation effectively copies all additional attribute records associated with the source catalog entry (p_source_entry) to the target catalog entry (p_target_entry)."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_warehouse_capacity` that accepts two input parameters: `p_warehouse_code` of data type `NUMBER`, representing the unique identifier for a specific warehouse, and `p_new_capacity` of data type `NUMBER`, representing the new capacity value to be assigned to that warehouse. The procedure's primary action is to perform an `UPDATE` operation on the `WAREHOUSES` table. Specifically, it sets the value of the `CAPACITY` column to the value provided by the `p_new_capacity` parameter. This update is conditional and applies only to rows in the `WAREHOUSES` table where the `CODE` column matches the value provided by the `p_warehouse_code` parameter. Furthermore, an additional condition must be met for the update to occur: there must exist at least one record in the `BOXES` table where the `WAREHOUSE` column matches the `p_warehouse_code` parameter. This `EXISTS` subquery effectively checks if the warehouse identified by `p_warehouse_code` currently contains any boxes. If both conditions (matching `CODE` in `WAREHOUSES` and existence of associated boxes in `BOXES`) are true, the `CAPACITY` of that specific warehouse is updated.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_warehouse_capacity(p_warehouse_code NUMBER, p_new_capacity NUMBER)\nIS\nBEGIN\n    UPDATE WAREHOUSES \n    SET CAPACITY = p_new_capacity \n    WHERE CODE = p_warehouse_code \n    AND EXISTS (SELECT 1 FROM BOXES WHERE WAREHOUSE = p_warehouse_code);\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 1, p_new_capacity => 10);\nEND;",
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 3, p_new_capacity => 5);\nEND;",
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 4, p_new_capacity => 8);\nEND;",
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 1, p_new_capacity => 12);\nEND;",
      "BEGIN\n    update_warehouse_capacity(p_warehouse_code => 3, p_new_capacity => 6);\nEND;"
    ],
    "summary": "Create a stored procedure named 'update_warehouse_capacity' to update a warehouse's capacity. Inputs: a warehouse code and a new capacity value. Update the warehouse's capacity only if the warehouse exists and currently has at least one box stored in it.",
    "natural_language": "Develop a stored procedure, which should be named 'update_warehouse_capacity', to modify the maximum capacity of a specified warehouse. This procedure must accept two input parameters: the unique identifier code for the warehouse and the new numerical value for its capacity. The update operation should proceed only under the condition that the warehouse in question is present in our records and is currently holding at least one physical box within its storage space.",
    "id": 4,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `update_warehouse_capacity` that accepts two input parameters: `p_warehouse_code` of data type `NUMBER`, representing the unique identifier for a specific warehouse, and `p_new_capacity` of data type `NUMBER`, representing the new capacity value to be assigned to that warehouse. The procedure's primary action is to perform an `UPDATE` operation on the `WAREHOUSES` table. Specifically, it sets the value of the `CAPACITY` column to the value provided by the `p_new_capacity` parameter. This update is conditional and applies only to rows in the `WAREHOUSES` table where the `CODE` column matches the value provided by the `p_warehouse_code` parameter. Furthermore, an additional condition must be met for the update to occur: there must exist at least one record in the `BOXES` table where the `WAREHOUSE` column matches the `p_warehouse_code` parameter. This `EXISTS` subquery effectively checks if the warehouse identified by `p_warehouse_code` currently contains any boxes. If both conditions (matching `CODE` in `WAREHOUSES` and existence of associated boxes in `BOXES`) are true, the `CAPACITY` of that specific warehouse is updated."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named add_pet_for_student that accepts three input parameters: a numeric parameter p_stuid representing a student identifier, a string parameter p_pettype representing the type of pet, and a numeric parameter p_pet_age representing the age of the pet. The procedure first declares a local numeric variable v_new_petid. It then performs a SELECT query on the pets table to calculate the next available pet identifier by taking the maximum existing value from the petid column and incrementing it by one, storing the result into the variable v_new_petid. Next, the procedure executes an INSERT statement into the pets table, specifying values for four columns: the petid column is set to the calculated v_new_petid, the pettype column is set to the input parameter p_pettype, the pet_age column is set to the input parameter p_pet_age, and the weight column is calculated as the product of the input parameter p_pet_age multiplied by four. Following this, the procedure executes a second INSERT statement into the has_pet table, inserting a new record where the stuid column is set to the input parameter p_stuid and the petid column is set to the newly generated v_new_petid.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_pet_for_student(p_stuid IN NUMBER, p_pettype IN VARCHAR2, p_pet_age IN NUMBER)\nIS\n    v_new_petid NUMBER;\nBEGIN\n    SELECT MAX(petid) + 1 INTO v_new_petid FROM pets;\n    \n    INSERT INTO pets (petid, pettype, pet_age, weight) VALUES (v_new_petid, p_pettype, p_pet_age, p_pet_age * 4);\n    INSERT INTO has_pet (stuid, petid) VALUES (p_stuid, v_new_petid);\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "BEGIN\n  add_pet_for_student(1001, 'dog', 3);\n  COMMIT;\nEND;",
      "BEGIN\n  add_pet_for_student(1002, 'cat', 2);\n  COMMIT;\nEND;",
      "BEGIN\n  add_pet_for_student(1001, 'rabbit', 1);\n  COMMIT;\nEND;",
      "BEGIN\n  add_pet_for_student(1002, 'hamster', 1);\n  COMMIT;\nEND;",
      "BEGIN\n  add_pet_for_student(1001, 'bird', 4);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named add_pet_for_student that accepts a student ID, pet type, and pet age. Generate a new pet ID by incrementing the maximum existing ID. Insert a new pet with the generated ID, type, age, and a weight calculated as age * 4. Then insert a record into has_pet linking the student and the new pet.",
    "natural_language": "Create procedure add_pet_for_student with student ID, pet type, and age. Generate new pet ID, insert pet (ID, type, age, weight as age*4), then link to student in has_pet.",
    "id": 5,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `add_pet_for_student` that accepts three input parameters: `p_stu_id` of type `NUMBER`, representing the student's ID; `p_pet_type` of type `VARCHAR2`, representing the type of the pet; and `p_pet_age` of type `NUMBER`, representing the age of the pet.\n\nUpon execution, the procedure first declares a local variable `v_new_pet_id` of type `NUMBER`. This variable will be used to store the newly generated unique identifier for the pet.\n\nThe procedure then performs its first operation, which is a `SELECT` statement. This statement queries the `PETS` table to find the maximum existing value in the `PETID` column. The result of the `MAX(PETID)` function is incremented by `1` to generate a new, unique pet ID. This calculated value is selected into the local variable `v_new_pet_id`.\n\nNext, the procedure executes an `INSERT` statement. This statement inserts a new row into the `PETS` table. The values inserted are as follows: the `PETID` column receives the value stored in `v_new_pet_id`; the `PETTYPE` column receives the value provided in the input parameter `p_pet_type`; the `PET_AGE` column receives the value provided in the input parameter `p_pet_age`; and the `WEIGHT` column receives a calculated value, which is the product of the input parameter `p_pet_age` multiplied by `4`.\n\nFollowing the insertion into the `PETS` table, the procedure executes a second `INSERT` statement. This statement inserts a new row into the `HAS_PET` table to establish the ownership link between the student and the newly created pet. The values inserted are as follows: the `STUID` column receives the value provided in the input parameter `p_stu_id`; and the `PETID` column receives the value stored in `v_new_pet_id`.\n\nThe procedure concludes after these two insert operations, with the new pet record created and linked to the specified student."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_wedding_records that accepts three parameters: p_church_id of type NUMBER, p_year_limit of type NUMBER, and p_country_filter of type VARCHAR2. The procedure begins by declaring two local variables, v_male_count and v_female_count, both of type NUMBER. It then executes a SELECT statement to count the number of male individuals in the PEOPLE table where the COUNTRY column matches the value of p_country_filter and the IS_MALE column is 'T', storing the result in v_male_count. Similarly, it counts the number of female individuals in the PEOPLE table with the same COUNTRY filter and IS_MALE column set to 'F', storing this count in v_female_count. The procedure then evaluates a series of conditional statements: if v_male_count is greater than v_female_count, it deletes records from the WEDDING table where the CHURCH_ID matches p_church_id and the YEAR is less than p_year_limit. If v_female_count is greater than v_male_count, it inserts a new record into the WEDDING table with the CHURCH_ID set to p_church_id, MALE_ID and FEMALE_ID both set to PEOPLE_ID and PEOPLE_ID + 1 respectively from the first male individual in the PEOPLE table matching the COUNTRY filter, and the YEAR set to the current year extracted from the system date. If the counts are equal, it deletes all records from the WEDDING table where the CHURCH_ID matches p_church_id, and inserts a new record into the PEOPLE table with PEOPLE_ID set to one greater than the current maximum PEOPLE_ID, NAME set to 'Balanced Entry', COUNTRY set to p_country_filter, IS_MALE set to 'T', and AGE set to 30.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_wedding_records(\n    p_church_id NUMBER,\n    p_year_limit NUMBER,\n    p_country_filter VARCHAR2\n)\nIS\n    v_male_count NUMBER;\n    v_female_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_male_count FROM PEOPLE WHERE COUNTRY = p_country_filter AND IS_MALE = 'T';\n    SELECT COUNT(*) INTO v_female_count FROM PEOPLE WHERE COUNTRY = p_country_filter AND IS_MALE = 'F';\n    IF v_male_count > v_female_count THEN\n        DELETE FROM WEDDING WHERE CHURCH_ID = p_church_id AND YEAR < p_year_limit;\n    ELSIF v_female_count > v_male_count THEN\n        INSERT INTO WEDDING (CHURCH_ID, MALE_ID, FEMALE_ID, YEAR)\n        SELECT p_church_id, PEOPLE_ID, PEOPLE_ID + 1, EXTRACT(YEAR FROM CURRENT_DATE)\n        FROM PEOPLE WHERE COUNTRY = p_country_filter AND IS_MALE = 'T' AND ROWNUM = 1;\n    ELSE\n        DELETE FROM WEDDING WHERE CHURCH_ID = p_church_id;\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES ((SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE), 'Balanced Entry', p_country_filter, 'T', 30);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  manage_wedding_records(1, 2010, 'United States');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_wedding_records(2, 2015, 'Canada');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_wedding_records(3, 2000, 'Sweden');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_wedding_records(1, 2020, 'United Kingdom');\n  COMMIT;\nEND;",
      "BEGIN\n  manage_wedding_records(5, 2018, 'Australia');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `manage_wedding_records` that accepts a church ID, a year limit, and a country filter. It counts males and females from that country. If there are more males, delete old weddings for that church before the year limit. If there are more females, insert a new wedding record for the current year using the first matching male and female. If counts are equal, delete all weddings for that church and insert a new 'Balanced Entry' person record.",
    "natural_language": "Alright, so we need a stored procedure called `manage_wedding_records`. You'll feed it a church ID, a cutoff year, and a country to filter by. First, it tallies up how many guys and gals are from that country. If there are more dudes, it wipes out any old weddings for that church that happened before the year limit. If there are more ladies, it adds a fresh wedding record for this year, pairing up the first available guy and girl from the list. If the counts are dead even, it does a clean sweepâ€”deletes all weddings for that church and then pops in a new 'Balanced Entry' person record.",
    "id": 6,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named manage_wedding_records that accepts three parameters: p_church_id of type NUMBER, p_year_limit of type NUMBER, and p_country_filter of type VARCHAR2. The procedure begins by declaring two local variables, v_male_count and v_female_count, both of type NUMBER. It then executes a SELECT statement to count the number of male individuals in the PEOPLE table where the COUNTRY column matches the value of p_country_filter and the IS_MALE column is 'T', storing the result in v_male_count. Similarly, it counts the number of female individuals in the PEOPLE table with the same COUNTRY filter and IS_MALE column set to 'F', storing this count in v_female_count. The procedure then evaluates a series of conditional statements: if v_male_count is greater than v_female_count, it deletes records from the WEDDING table where the CHURCH_ID matches p_church_id and the YEAR is less than p_year_limit. If v_female_count is greater than v_male_count, it inserts a new record into the WEDDING table with the CHURCH_ID set to p_church_id, MALE_ID and FEMALE_ID both set to PEOPLE_ID and PEOPLE_ID + 1 respectively from the first male individual in the PEOPLE table matching the COUNTRY filter, and the YEAR set to the current year extracted from the system date. If the counts are equal, it deletes all records from the WEDDING table where the CHURCH_ID matches p_church_id, and inserts a new record into the PEOPLE table with PEOPLE_ID set to one greater than the current maximum PEOPLE_ID, NAME set to 'Balanced Entry', COUNTRY set to p_country_filter, IS_MALE set to 'T', and AGE set to 30."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named consolidate_church_operations that accepts three input parameters: a numeric parameter p_year, a variable-length string parameter p_organizer_pattern, and a variable-length string parameter p_country. The procedure begins by declaring two local numeric variables, v_church_records and v_people_records. It first queries the CHURCH table to count the number of records where the OPEN_DATE column equals the p_year parameter value, storing the result in v_church_records. It then queries the PEOPLE table to count the number of records where the COUNTRY column equals the p_country parameter value, storing the result in v_people_records. The procedure then executes a conditional IF-ELSIF-ELSE block. If v_church_records is greater than 3, it deletes from the CHURCH table all rows where the OPEN_DATE equals p_year and the ORGANIZED_BY column contains the p_organizer_pattern string (using a LIKE pattern with wildcards '%' before and after the pattern). Following this deletion, it inserts a new record into the CHURCH table with a CHURCH_ID calculated as the maximum existing CHURCH_ID plus one, a NAME of 'Consolidated Church', an ORGANIZED_BY value of 'System', and an OPEN_DATE set to the current year extracted from the system date using the EXTRACT(YEAR FROM CURRENT_DATE) function. If the first condition is false and v_people_records is greater than v_church_records, the procedure deletes from the WEDDING table all rows where the CHURCH_ID matches any CHURCH_ID from the CHURCH table where OPEN_DATE equals p_year. It then inserts into the PEOPLE table new records by selecting from the PEOPLE table where COUNTRY equals p_country, limiting the selection to the first two rows (using ROWNUM <= 2), and transforming the data by adding 1000 to the original PEOPLE_ID value while keeping the original NAME, COUNTRY, IS_MALE, and AGE values. If neither of the previous conditions is true, the procedure executes an ELSE block which first deletes from the PEOPLE table all rows where COUNTRY equals p_country, and then deletes from the WEDDING table all rows where the CHURCH_ID is found in the result set of a subquery selecting CHURCH_ID from the CHURCH table where OPEN_DATE equals p_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_church_operations(\n    p_year NUMBER,\n    p_organizer_pattern VARCHAR2,\n    p_country VARCHAR2\n)\nIS\n    v_church_records NUMBER;\n    v_people_records NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_church_records FROM CHURCH WHERE OPEN_DATE = p_year;\n    SELECT COUNT(*) INTO v_people_records FROM PEOPLE WHERE COUNTRY = p_country;\n    IF v_church_records > 3 THEN\n        DELETE FROM CHURCH WHERE OPEN_DATE = p_year AND ORGANIZED_BY LIKE '%' || p_organizer_pattern || '%';\n        INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE)\n        VALUES ((SELECT MAX(CHURCH_ID) + 1 FROM CHURCH), 'Consolidated Church', 'System', EXTRACT(YEAR FROM CURRENT_DATE));\n    ELSIF v_people_records > v_church_records THEN\n        DELETE FROM WEDDING WHERE CHURCH_ID IN (SELECT CHURCH_ID FROM CHURCH WHERE OPEN_DATE = p_year);\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        SELECT PEOPLE_ID + 1000, NAME, COUNTRY, IS_MALE, AGE\n        FROM PEOPLE WHERE COUNTRY = p_country AND ROWNUM <= 2;\n    ELSE\n        DELETE FROM PEOPLE WHERE COUNTRY = p_country;\n        DELETE FROM WEDDING WHERE CHURCH_ID IN (SELECT CHURCH_ID FROM CHURCH WHERE OPEN_DATE = p_year);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  consolidate_church_operations(1831, 'Clark', 'Canada');\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_church_operations(1832, 'Booth', 'United States');\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_church_operations(1836, 'Hoton', 'Sweden');\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_church_operations(1840, 'Smith', 'United Kingdom');\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_church_operations(1820, 'Jones', 'Australia');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `consolidate_church_operations` that accepts a year, an organizer name pattern, and a country. It counts churches opened in that year and people from that country. If more than 3 churches exist, delete those matching the organizer pattern and insert a new 'Consolidated Church'. If more people exist than churches, delete weddings for churches from that year and duplicate the first two people with modified IDs. Otherwise, delete all people from the country and weddings for churches from that year.",
    "natural_language": "Create a stored procedure called `consolidate_church_operations` that takes a year, a kind of organizer name, and a country. It should figure out roughly how many churches started around that year and get a count of individuals associated with that country. If there are quite a few churches, maybe more than a handful, remove the ones that sort of match the organizer description and add a new 'Consolidated Church' entry. If the number of people seems notably larger than the church count, then clean up the wedding records for churches from that general time and copy the first couple of people with tweaked IDs. If neither of those cases fits, just clear out all the people linked to that country and remove the wedding info for churches from around that year.",
    "id": 7,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `consolidate_church_operations` that accepts three input parameters: `p_year` of type `NUMBER`, representing the target year for analysis; `p_organizer_name` of type `VARCHAR2`, representing a partial or descriptive name of a church organizer to match against; and `p_country` of type `VARCHAR2`, representing the country to filter individuals.\n\nUpon execution, the procedure first declares several local variables: `v_church_count` of type `NUMBER` to store the approximate count of churches founded around the input year; `v_people_count` of type `NUMBER` to store the count of individuals from the specified country; `v_threshold_church` of type `NUMBER` initialized to 5, representing the \"handful\" threshold for church count; `v_new_church_id` of type `NUMBER` to store a new identifier for a potential consolidated church entry; `v_first_male_id` of type `NUMBER` to store the identifier of the first male person from the country; `v_first_female_id` of type `NUMBER` to store the identifier of the first female person from the country; and `v_temp_id` of type `NUMBER` for temporary ID manipulation.\n\nThe procedure begins by calculating `v_church_count`. It executes a `SELECT COUNT(*)` query against the `CHURCH` table where the `OPEN_DATE` column is within a range of plus or minus 2 years from the `p_year` parameter (i.e., `OPEN_DATE BETWEEN p_year - 2 AND p_year + 2`), storing the result in `v_church_count`.\n\nNext, the procedure calculates `v_people_count`. It executes a `SELECT COUNT(*)` query against the `PEOPLE` table where the `COUNTRY` column exactly matches the `p_country` parameter, storing the result in `v_people_count`.\n\nFollowing these calculations, the procedure evaluates the conditions using a conditional `IF-ELSIF-ELSE` block.\n\nIf `v_church_count` is greater than `v_threshold_church` (i.e., \"more than a handful\"), the procedure enters the first branch. It first executes a `DELETE` operation on the `CHURCH` table where the `ORGANIZED_BY` column contains the `p_organizer_name` string as a substring (using a `LIKE` condition with `'%' || p_organizer_name || '%'`). Then, it determines a new church ID by executing a `SELECT NVL(MAX(CHURCH_ID), 0) + 1` query against the `CHURCH` table, storing the result in `v_new_church_id`. Finally, it executes an `INSERT` operation into the `CHURCH` table, populating `CHURCH_ID` with `v_new_church_id`, `NAME` with the string literal 'Consolidated Church', `ORGANIZED_BY` with `p_organizer_name`, `OPEN_DATE` with `p_year`, and `CONTINUATION_OF` with `NULL`.\n\nIf the first condition is not met, but `v_people_count` is \"notably larger\" than `v_church_count` (interpreted as `v_people_count > v_church_count * 2`), the procedure enters the second branch. It first executes a `DELETE` operation on the `WEDDING` table where the `CHURCH_ID` exists in a subquery: a `SELECT CHURCH_ID` from the `CHURCH` table where `OPEN_DATE` is within plus or minus 2 years of `p_year`. Then, it retrieves the first male and female persons from the specified country by executing two `SELECT` queries against the `PEOPLE` table. For the male, it selects `PEOPLE_ID` where `COUNTRY` equals `p_country` and `IS_MALE` equals 'T', ordering by `PEOPLE_ID` ascending and fetching the first row, storing the ID in `v_first_male_id`. For the female, it does the same but with `IS_MALE` equal to 'F', storing the ID in `v_first_female_id`. If these IDs are not null, the procedure then executes an `INSERT` operation into the `PEOPLE` table twice: first, inserting a new person with `PEOPLE_ID` set to `v_first_male_id + 1000`, `NAME` set to the original name concatenated with ' (Copy)', and other columns copied from the original male record; second, doing the same for the female with `PEOPLE_ID` set to `v_first_female_id + 1000`.\n\nIf neither of the above conditions is true, the procedure executes the default `ELSE` branch. It first executes a `DELETE` operation on the `PEOPLE` table where the `COUNTRY` column exactly matches `p_country`. Then, it executes a `DELETE` operation on the `WEDDING` table where the `CHURCH_ID` exists in a subquery: a `SELECT CHURCH_ID` from the `CHURCH` table where `OPEN_DATE` is within plus or minus 2 years of `p_year`.\n\nThe procedure does not have an explicit return value; it performs data manipulation operations based on the conditional logic."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_insert_resident_service that accepts three input parameters: p_resident_id of type NUMBER, p_service_id of type NUMBER, and p_date_requested of type VARCHAR2, and performs a MERGE operation into the RESIDENTS_SERVICES table, aliased as rs, using a single-row source data set constructed from the input parameters via a SELECT statement from the DUAL table, aliasing p_resident_id as resident_id, p_service_id as service_id, and p_date_requested as date_requested, with the merge condition checking for a match where the existing rs.RESIDENT_ID equals the source resident_id and the existing rs.SERVICE_ID equals the source service_id; when a matching row is found, the procedure updates the existing row's DATE_REQUESTED column with the value from the source date_requested; when no matching row is found, the procedure inserts a new row into RESIDENTS_SERVICES, populating the RESIDENT_ID, SERVICE_ID, and DATE_REQUESTED columns with the values from the source resident_id, service_id, and date_requested respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_insert_resident_service(\n    p_resident_id IN NUMBER,\n    p_service_id IN NUMBER,\n    p_date_requested IN VARCHAR2\n)\nIS\nBEGIN\n    MERGE INTO RESIDENTS_SERVICES rs\n    USING (SELECT p_resident_id AS resident_id, p_service_id AS service_id, p_date_requested AS date_requested FROM DUAL) src\n    ON (rs.RESIDENT_ID = src.resident_id AND rs.SERVICE_ID = src.service_id)\n    WHEN MATCHED THEN\n        UPDATE SET rs.DATE_REQUESTED = src.date_requested\n    WHEN NOT MATCHED THEN\n        INSERT (RESIDENT_ID, SERVICE_ID, DATE_REQUESTED)\n        VALUES (src.resident_id, src.service_id, src.date_requested);\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "SERVICES",
      "RESIDENTS_SERVICES",
      "THINGS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 6, p_service_id => 49, p_date_requested => '2023-01-15 10:00:00');\nEND;",
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 23, p_service_id => 41, p_date_requested => '2023-02-20 14:30:00');\nEND;",
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 28, p_service_id => 11, p_date_requested => '2023-03-01 09:00:00');\nEND;",
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 6, p_service_id => 49, p_date_requested => '2023-04-10 11:00:00');\nEND;",
      "BEGIN\n  proc_insert_resident_service(p_resident_id => 10, p_service_id => 10, p_date_requested => '2023-05-05 16:00:00');\nEND;"
    ],
    "summary": "Create a stored procedure named proc_insert_resident_service that accepts p_resident_id NUMBER, p_service_id NUMBER, and p_date_requested VARCHAR2. Perform a MERGE into RESIDENTS_SERVICES using the input parameters as the source. When a row matches on RESIDENT_ID and SERVICE_ID, update DATE_REQUESTED. When no match is found, insert a new row with the provided values.",
    "natural_language": "Create proc_insert_resident_service with inputs p_resident_id NUMBER, p_service_id NUMBER, p_date_requested VARCHAR2. MERGE into RESIDENTS_SERVICES. Match on RESIDENT_ID and SERVICE_ID to update DATE_REQUESTED. If no match, insert new row.",
    "id": 8,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named proc_insert_resident_service that accepts three input parameters: p_resident_id of type NUMBER, p_service_id of type NUMBER, and p_date_requested of type VARCHAR2, and performs a MERGE operation into the RESIDENTS_SERVICES table, aliased as rs, using a single-row source data set constructed from the input parameters via a SELECT statement from the DUAL table, aliasing p_resident_id as resident_id, p_service_id as service_id, and p_date_requested as date_requested, with the merge condition checking for a match where the existing rs.RESIDENT_ID equals the source resident_id and the existing rs.SERVICE_ID equals the source service_id; when a matching row is found, the procedure updates the existing row's DATE_REQUESTED column with the value from the source date_requested; when no matching row is found, the procedure inserts a new row into RESIDENTS_SERVICES, populating the RESIDENT_ID, SERVICE_ID, and DATE_REQUESTED columns with the values from the source resident_id, service_id, and date_requested respectively."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_calculate_total_forms that accepts a single input parameter para_party_id of the NUMBER data type, which is used to identify a specific party. The procedure begins by declaring a local variable total_forms of type NUMBER. It then executes a SELECT statement to query the PARTY_FORMS table, calculating the sum of all FORM_ID values for rows where the PARTY_ID column matches the input parameter para_party_id, and stores this aggregated result into the total_forms variable. Following this calculation, the procedure uses an IF-THEN-ELSE conditional block to evaluate the value of total_forms. If total_forms is greater than 50, the procedure performs an INSERT operation into the PARTY_FORMS table, creating a new row with the following column values: the PARTY_ID is set to the input para_party_id, the FORM_ID is set to the calculated total_forms value incremented by one, the DATE_COMPLETION_STARTED column is populated with the current system date and time formatted as a string in 'YYYY-MM-DD HH24:MI:SS' format using the TO_CHAR and SYSDATE functions, the FORM_STATUS_CODE is set to the literal string 'Completed', and the DATE_FULLY_COMPLETED column is explicitly set to NULL. Conversely, if the condition total_forms > 50 evaluates to FALSE (i.e., total_forms is less than or equal to 50), the procedure executes a DELETE operation on the PARTY_FORMS table, removing all rows where the PARTY_ID equals the input para_party_id and the FORM_STATUS_CODE column exactly matches the string 'Partially Completed'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_calculate_total_forms(para_party_id NUMBER) IS\n  total_forms NUMBER;\nBEGIN\n  SELECT SUM(FORM_ID) INTO total_forms FROM PARTY_FORMS WHERE PARTY_ID = para_party_id;\n  IF total_forms > 50 THEN\n    INSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, DATE_COMPLETION_STARTED, FORM_STATUS_CODE, DATE_FULLY_COMPLETED)\n    VALUES (para_party_id, total_forms + 1, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 'Completed', NULL);\n  ELSE\n    DELETE FROM PARTY_FORMS WHERE PARTY_ID = para_party_id AND FORM_STATUS_CODE = 'Partially Completed';\n  END IF;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_calculate_total_forms(1);\n  commit;\nEND;",
      "BEGIN\n  sp_calculate_total_forms(2);\n  commit;\nEND;",
      "BEGIN\n  sp_calculate_total_forms(3);\n  commit;\nEND;",
      "BEGIN\n  sp_calculate_total_forms(15);\n  commit;\nEND;",
      "BEGIN\n  sp_calculate_total_forms(8);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_calculate_total_forms that accepts a party ID number. Calculate the total number of forms for that party. If the total is greater than 50, insert a new 'Completed' form record for the party with an incremented ID and the current timestamp. Otherwise, delete all 'Partially Completed' forms for that party.",
    "natural_language": "How can I create a stored procedure called sp_calculate_total_forms that takes a party ID, calculates the total number of forms for that party, and then, if the total exceeds 50, inserts a new 'Completed' form record with an incremented ID and the current timestamp, otherwise deletes all 'Partially Completed' forms for that party?",
    "id": 9,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp_calculate_total_forms` that operates on the `e_government` database. The procedure accepts one input parameter: `p_party_id`, which is of data type `NUMBER` and represents the unique identifier for a specific party. The procedure's purpose is to calculate the total number of forms associated with the given party ID and then perform conditional operations based on that count.\n\nInternally, the procedure declares two local variables. The first variable is `v_total_forms`, of type `NUMBER`, which will store the result of the count calculation. The second variable is `v_new_form_id`, of type `NUMBER`, which will be used to hold an incremented form ID when needed.\n\nThe core logic begins with a `SELECT` statement that performs an aggregation on the `PARTY_FORMS` table. This statement uses the `COUNT(*)` function to count all rows where the `PARTY_ID` column matches the value provided in the `p_party_id` input parameter. The result of this count operation is assigned to the `v_total_forms` variable using the `INTO` clause.\n\nFollowing this calculation, the procedure implements conditional control flow using an `IF-THEN-ELSE` construct. The condition checks if the value stored in `v_total_forms` is greater than 50.\n\nIf the condition is true (i.e., `v_total_forms` > 50), the procedure executes a sequence of operations. First, it performs a `SELECT` statement to determine the next available `FORM_ID` for the specified party. This is achieved by querying the `PARTY_FORMS` table for the maximum value of the `FORM_ID` column where the `PARTY_ID` matches `p_party_id`, and then adding 1 to that maximum value. The result is assigned to the `v_new_form_id` variable. Subsequently, the procedure performs an `INSERT` operation into the `PARTY_FORMS` table. The inserted row includes the following column values: the `PARTY_ID` is set to the input `p_party_id`; the `FORM_ID` is set to the calculated `v_new_form_id`; the `DATE_COMPLETION_STARTED` is set to the current system timestamp using the `SYSTIMESTAMP` function; the `FORM_STATUS_CODE` is set to the literal string `'Completed'`; and the `DATE_FULLY_COMPLETED` is also set to the current system timestamp using `SYSTIMESTAMP`.\n\nIf the condition is false (i.e., `v_total_forms` is 50 or less), the procedure executes a `DELETE` operation on the `PARTY_FORMS` table. This deletion targets all rows where two conditions are met simultaneously: the `PARTY_ID` column matches the input `p_party_id`, and the `FORM_STATUS_CODE` column exactly matches the literal string `'Partially Completed'`.\n\nThe procedure concludes after executing the appropriate branch of the conditional logic, without returning any value."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc1 that accepts a single parameter, para_artist_id, of type NUMBER, which represents the unique identifier of an artist. The procedure performs two main operations. First, it deletes a record from the ARTIST table where the ARTIST_ID column matches the value of para_artist_id and the AGE column is less than 25. This operation removes young artists with the specified ID from the database. Second, the procedure inserts a new record into the MUSIC_FESTIVAL table. The ID column of the new record is assigned a value that is one greater than the current maximum ID value found in the MUSIC_FESTIVAL table, using the NVL function to handle cases where the table might be empty by defaulting to 0. The MUSIC_FESTIVAL column is set to the string 'New Festival', indicating the name of the festival. The VOLUME column is populated with the count of records from the VOLUME table where the ARTIST_ID column matches the value of para_artist_id, effectively recording the number of volumes associated with the specified artist.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc1(para_artist_id NUMBER) IS\nBEGIN\n  DELETE FROM ARTIST WHERE ARTIST_ID = para_artist_id AND AGE < 25;\n  INSERT INTO MUSIC_FESTIVAL (ID, MUSIC_FESTIVAL, VOLUME) \n  VALUES ((SELECT NVL(MAX(ID),0)+1 FROM MUSIC_FESTIVAL), 'New Festival', (SELECT COUNT(*) FROM VOLUME WHERE ARTIST_ID = para_artist_id));\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc1(1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(10);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_proc1(15);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc1 with one input parameter para_artist_id (NUMBER). First, delete from ARTIST where ARTIST_ID = para_artist_id and AGE < 25. Then, insert into MUSIC_FESTIVAL (ID, MUSIC_FESTIVAL, VOLUME) values (NVL((SELECT MAX(ID) FROM MUSIC_FESTIVAL), 0) + 1, 'New Festival', (SELECT COUNT(*) FROM VOLUME WHERE ARTIST_ID = para_artist_id)).",
    "natural_language": "Hey, can you whip up a stored procedure called sp_proc1? It needs one number input called para_artist_id. First off, get rid of any artists from the ARTIST table where their ARTIST_ID matches that input and they're under 25. After that, pop a new entry into the MUSIC_FESTIVAL table. For the ID, take the biggest current ID from MUSIC_FESTIVAL (or start at 0 if it's empty) and just add 1 to it. Set the MUSIC_FESTIVAL name to 'New Festival'. For the VOLUME, grab the count of all records in the VOLUME table that are linked to that same artist ID.",
    "id": 10,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_proc1 that accepts one parameter: para_artist_id of type NUMBER. The procedure performs two main operations: a deletion from the ARTIST table and an insertion into the MUSIC_FESTIVAL table.\n\nFirst, the procedure executes a DELETE statement on the ARTIST table. It deletes rows where the ARTIST_ID column matches the input parameter para_artist_id AND the AGE column is less than 25.\n\nSecond, the procedure prepares to insert a new row into the MUSIC_FESTIVAL table. To determine the value for the ID column in the new row, it executes a SELECT statement to find the maximum current ID value from the MUSIC_FESTIVAL table. This query uses the MAX(ID) function. If the MUSIC_FESTIVAL table is empty, the MAX(ID) function will return NULL. The procedure handles this by using the NVL function to convert a NULL result to 0. It then adds 1 to this value to generate the new ID. This calculated value is stored in a local variable, for example, v_new_id.\n\nTo determine the value for the VOLUME column in the new row, the procedure executes another SELECT statement. This query counts the number of records in the VOLUME table where the ARTIST_ID column matches the input parameter para_artist_id. It uses the COUNT(*) function. This count is stored in a local variable, for example, v_volume_count.\n\nFinally, the procedure executes an INSERT statement into the MUSIC_FESTIVAL table. The inserted row contains the following values:\n- The ID column is set to the value of v_new_id.\n- The MUSIC_FESTIVAL column is set to the literal string 'New Festival'.\n- The VOLUME column is set to the value of v_volume_count.\nThe other columns in the MUSIC_FESTIVAL table (DATE_OF_CEREMONY, CATEGORY, RESULT) are not specified in the INSERT and will therefore be set to NULL, assuming the table schema allows it.\n\nThe procedure does not have any explicit return value or output parameters. It performs the deletion and insertion operations sequentially. There is no explicit control flow described beyond the sequential execution of these SQL statements. The procedure operates on the ARTIST, MUSIC_FESTIVAL, and VOLUME tables within the music_4 database."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `assign_teacher_to_course` that accepts three input parameters: `p_course_id` of type `NUMBER`, representing the unique identifier of a course; `p_teacher_id` of type `NUMBER`, representing the unique identifier of a teacher; and `p_grade` of type `NUMBER`, representing the grade to be assigned. The procedure first declares two local variables: `v_course_exists` of type `NUMBER` and `v_teacher_exists` of type `NUMBER`. It then executes a `SELECT COUNT(*)` statement to determine if a course with the `COURSE_ID` matching the `p_course_id` input parameter exists in the `COURSE` table, storing the count in `v_course_exists`. Subsequently, it executes another `SELECT COUNT(*)` statement to determine if a teacher with the `TEACHER_ID` matching the `p_teacher_id` input parameter exists in the `TEACHER` table, storing the count in `v_teacher_exists`. Following these checks, the procedure evaluates a conditional `IF` statement. If both `v_course_exists` is greater than 0 (indicating the course exists) AND `v_teacher_exists` is greater than 0 (indicating the teacher exists), the procedure proceeds to execute a `MERGE` statement. This `MERGE` statement targets the `COURSE_ARRANGE` table, aliased as `ca`. The `USING` clause constructs a derived table from `DUAL`, providing the `p_course_id` as `course_id`, `p_teacher_id` as `teacher_id`, and `p_grade` as `grade`, aliased as `src`. The `ON` clause specifies the join condition for the `MERGE` operation as `ca.COURSE_ID = src.course_id AND ca.TEACHER_ID = src.teacher_id`. If a match is found based on this condition (`WHEN MATCHED THEN`), the `GRADE` column in the `COURSE_ARRANGE` table (`ca.GRADE`) is updated to the value of `src.grade`. If no match is found (`WHEN NOT MATCHED THEN`), a new row is inserted into the `COURSE_ARRANGE` table, populating the `COURSE_ID`, `TEACHER_ID`, and `GRADE` columns with the values from `src.course_id`, `src.teacher_id`, and `src.grade`, respectively. The procedure concludes after this conditional `MERGE` operation.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_teacher_to_course(\n    p_course_id IN NUMBER,\n    p_teacher_id IN NUMBER,\n    p_grade IN NUMBER\n) IS\n    v_course_exists NUMBER;\n    v_teacher_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_course_exists FROM COURSE WHERE COURSE_ID = p_course_id;\n    SELECT COUNT(*) INTO v_teacher_exists FROM TEACHER WHERE TEACHER_ID = p_teacher_id;\n    \n    IF v_course_exists > 0 AND v_teacher_exists > 0 THEN\n        MERGE INTO COURSE_ARRANGE ca\n        USING (SELECT p_course_id AS course_id, p_teacher_id AS teacher_id, p_grade AS grade FROM DUAL) src\n        ON (ca.COURSE_ID = src.course_id AND ca.TEACHER_ID = src.teacher_id)\n        WHEN MATCHED THEN\n            UPDATE SET ca.GRADE = src.grade\n        WHEN NOT MATCHED THEN\n            INSERT (ca.COURSE_ID, ca.TEACHER_ID, ca.GRADE)\n            VALUES (src.course_id, src.teacher_id, src.grade);\n    END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  assign_teacher_to_course(1, 1, 3);\n  commit;\nEND;",
      "BEGIN\n  assign_teacher_to_course(2, 2, 5);\n  commit;\nEND;",
      "BEGIN\n  assign_teacher_to_course(3, 3, 1);\n  commit;\nEND;",
      "BEGIN\n  assign_teacher_to_course(1, 2, 4);\n  commit;\nEND;",
      "BEGIN\n  assign_teacher_to_course(2, 3, 2);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named assign_teacher_to_course that accepts a course ID, teacher ID, and grade. It first verifies the existence of the course and teacher in their respective tables. If both exist, it uses a MERGE statement on the COURSE_ARRANGE table to update the grade if a matching record exists, or insert a new record if no match is found.",
    "natural_language": "Compose a stored procedure designated as `assign_teacher_to_course`. This procedure shall accept three parameters: a course identifier, a teacher identifier, and a grade. Its initial operation is to validate the existence of the specified course and teacher within their respective database tables. Provided both entities are confirmed to exist, the procedure will subsequently execute a MERGE operation on the COURSE_ARRANGE table. This MERGE statement will update the grade for any pre-existing record that matches the provided identifiers. In the absence of such a matching record, the statement will insert a new entry.",
    "id": 11,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `assign_teacher_to_course` that accepts three input parameters: `p_course_id` of type `NUMBER` representing the course identifier, `p_teacher_id` of type `NUMBER` representing the teacher identifier, and `p_grade` of type `NUMBER` representing the grade. The procedure declares two local variables: `v_course_exists` of type `NUMBER` and `v_teacher_exists` of type `NUMBER`. The procedure's first operation is to validate the existence of the specified course by executing a `SELECT` statement with a `COUNT` aggregation on the `COURSE` table, specifically counting the number of rows where the `COURSE_ID` column equals the input parameter `p_course_id`. The result of this query is stored in the variable `v_course_exists`. The procedure then validates the existence of the specified teacher by executing a `SELECT` statement with a `COUNT` aggregation on the `TEACHER` table, specifically counting the number of rows where the `TEACHER_ID` column equals the input parameter `p_teacher_id`. The result of this query is stored in the variable `v_teacher_exists`. The procedure then implements a conditional check: if both `v_course_exists` and `v_teacher_exists` are greater than zero, it proceeds to execute a `MERGE` operation on the `COURSE_ARRANGE` table. The `MERGE` statement uses the combination of the input parameters `p_course_id` and `p_teacher_id` to match against the `COURSE_ID` and `TEACHER_ID` columns in the `COURSE_ARRANGE` table. When a matching row is found (i.e., when `COURSE_ARRANGE.COURSE_ID` equals `p_course_id` and `COURSE_ARRANGE.TEACHER_ID` equals `p_teacher_id`), the statement performs an `UPDATE` operation, setting the `GRADE` column in the `COURSE_ARRANGE` table to the value of the input parameter `p_grade`. When no matching row is found, the statement performs an `INSERT` operation, creating a new row in the `COURSE_ARRANGE` table with the `COURSE_ID` column set to `p_course_id`, the `TEACHER_ID` column set to `p_teacher_id`, and the `GRADE` column set to `p_grade`. If the conditional check fails (i.e., if either `v_course_exists` or `v_teacher_exists` is zero), the procedure does not execute the `MERGE` statement and performs no further action."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateCatalogPrice that accepts three input parameters: p_catalog_entry_id, p_new_price_in_dollars, and p_catalog_level_number, all of which are of the NUMBER data type. The procedure updates the CATALOG_CONTENTS table by setting the PRICE_IN_DOLLARS column to the value provided in the p_new_price_in_dollars parameter. This update operation is performed only for the row where the CATALOG_ENTRY_ID column matches the value of the p_catalog_entry_id parameter and the CATALOG_LEVEL_NUMBER column matches the value of the p_catalog_level_number parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateCatalogPrice(\n    p_catalog_entry_id IN NUMBER,\n    p_new_price_in_dollars IN NUMBER,\n    p_catalog_level_number IN NUMBER\n) AS\nBEGIN\n    UPDATE CATALOG_CONTENTS\n    SET PRICE_IN_DOLLARS = p_new_price_in_dollars\n    WHERE CATALOG_ENTRY_ID = p_catalog_entry_id\n    AND CATALOG_LEVEL_NUMBER = p_catalog_level_number;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateCatalogPrice(1, 250.00, 1);\n  commit;\nEND;",
      "BEGIN\n  UpdateCatalogPrice(2, 700.00, 8);\n  commit;\nEND;",
      "BEGIN\n  UpdateCatalogPrice(3, 400.00, 1);\n  commit;\nEND;",
      "BEGIN\n  UpdateCatalogPrice(1, 300.00, 8);\n  commit;\nEND;",
      "BEGIN\n  UpdateCatalogPrice(2, 750.00, 1);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateCatalogPrice that updates the price of a specific catalog entry. It accepts a catalog entry ID, a new price, and a catalog level number. The procedure updates the PRICE_IN_DOLLARS in the CATALOG_CONTENTS table for the row matching both the provided entry ID and level number.",
    "natural_language": "Update catalog price for a given entry ID and level.",
    "id": 12,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateCatalogPrice that operates on the product_catalog database. The procedure accepts two input parameters: p_entry_id of type NUMBER, representing the catalog entry ID to update, and p_level of type NUMBER, representing the catalog level number. The procedure declares two local variables: v_catalog_id of type NUMBER to store the catalog ID associated with the given level, and v_attribute_id of type NUMBER to store the attribute ID for the price adjustment attribute.\n\nThe procedure first executes a SELECT statement to retrieve the catalog_id from the CATALOG_STRUCTURE table where the catalog_level_number matches the p_level parameter. This value is stored in the v_catalog_id variable.\n\nNext, the procedure executes another SELECT statement to retrieve the attribute_id from the ATTRIBUTE_DEFINITIONS table where the attribute_name is exactly 'Price Adjustment' and the attribute_data_type is exactly 'Bool'. This value is stored in the v_attribute_id variable.\n\nThen, the procedure executes an UPDATE operation on the CATALOG_CONTENTS table, aliased as cc. It updates the price_in_dollars, price_in_euros, and price_in_pounds columns. For price_in_dollars, the new value is calculated by multiplying the current price_in_dollars by a factor derived from a subquery. The subquery selects the attribute_value from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table, aliased as ccaa, where the catalog_entry_id matches the p_entry_id parameter, the catalog_level_number matches the p_level parameter, and the attribute_id matches the v_attribute_id variable. The attribute_value, which is expected to be '1' or '0', is converted to a number using TO_NUMBER. If the attribute_value is '1', it is multiplied by 1.1 (a 10% increase); if it is '0', it is multiplied by 0.9 (a 10% decrease). This calculated factor is then multiplied by the current price_in_dollars. The same calculation is applied to price_in_euros and price_in_pounds using their respective current values.\n\nThe UPDATE operation applies only to rows in the CATALOG_CONTENTS table where the catalog_entry_id matches the p_entry_id parameter. Additionally, there must exist a corresponding row in the CATALOG_STRUCTURE table, aliased as cs, where the catalog_level_number matches the p_level parameter and the catalog_id matches the v_catalog_id variable. This ensures the update only occurs for entries at the specified level within the correct catalog structure.\n\nAfter the update, the procedure executes a final UPDATE operation on the CATALOGS table. It sets the date_of_latest_revision column to the current system timestamp, formatted as 'YYYY-MM-DD HH24:MI:SS'. This update applies to rows where the catalog_id matches the v_catalog_id variable, ensuring the catalog's revision date is updated to reflect the price change."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_update_service_details` that is designed to modify existing service records within a database table. This procedure accepts three parameters: `p_service_id`, an `IN` parameter of type `NUMBER`, which represents the unique identifier of the service whose details are to be updated; `p_new_details`, an `IN` parameter of type `VARCHAR2`, which provides the new textual description or details that will replace the current details for the specified service; and `p_rows_updated`, an `OUT` parameter of type `NUMBER`, which will return the count of rows that were successfully modified by the update operation. The core operation performed by this procedure is an `UPDATE` statement targeting the `SERVICES` table. Within this `UPDATE` statement, the `SERVICE_DETAILS` column is set to the value provided by the `p_new_details` parameter. This update is conditionally applied, meaning it only affects rows where the value in the `SERVICE_ID` column matches the value passed in the `p_service_id` parameter. Following the execution of the `UPDATE` statement, the procedure assigns the number of rows affected by the preceding `UPDATE` operation to the `p_rows_updated` `OUT` parameter. This count is obtained using the `SQL%ROWCOUNT` SQL attribute, which specifically returns the number of rows processed by the most recently executed SQL statement in the current session.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_update_service_details(\n    p_service_id IN NUMBER,\n    p_new_details IN VARCHAR2,\n    p_rows_updated OUT NUMBER\n)\nIS\nBEGIN\n    UPDATE SERVICES\n    SET SERVICE_DETAILS = p_new_details\n    WHERE SERVICE_ID = p_service_id;\n    p_rows_updated := SQL%ROWCOUNT;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "SERVICES",
      "RESIDENTS_SERVICES",
      "THINGS"
    ],
    "call_sqls": [
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 10, p_new_details => 'Updated details for service 10', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 11, p_new_details => 'New description for service 11', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 13, p_new_details => 'Service 13 details changed', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 49, p_new_details => 'Details for service 49 updated', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;",
      "DECLARE\n    v_rows_updated NUMBER;\nBEGIN\n    proc_update_service_details(p_service_id => 41, p_new_details => 'Service 41 details modified', p_rows_updated => v_rows_updated);\n    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || v_rows_updated);\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_update_service_details` that updates the SERVICE_DETAILS column in the SERVICES table for a given SERVICE_ID. It takes an IN parameter for the service ID, an IN parameter for the new details, and an OUT parameter that returns the number of rows updated.",
    "natural_language": "Hey, can you whip up a stored procedure called `proc_update_service_details`? It's gotta update the SERVICE_DETAILS field in the SERVICES table whenever we give it a specific SERVICE_ID. We'll need to pass in the service ID and the new details, and it should spit back out how many rows it actually changed.",
    "id": 13,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named proc_update_service_details that accepts two input parameters: a numeric parameter p_service_id to identify a specific service record, and a string parameter p_new_service_details to provide the new text for the service details. The procedure also includes one output parameter, p_rows_updated of type NUMBER, which is used to return the count of rows modified by the operation.\n\nThe procedure performs a single SQL UPDATE operation on the SERVICES table. It modifies the SERVICE_DETAILS column for the row or rows where the SERVICE_ID column value exactly matches the value provided in the input parameter p_service_id. The update sets the SERVICE_DETAILS column to the value supplied in the p_new_service_details parameter.\n\nImmediately following the UPDATE, the procedure uses the SQL%ROWCOUNT implicit cursor attribute to capture the number of rows affected by the update statement. This count is then assigned directly to the output parameter p_rows_updated."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `MergeSchoolInfo` that accepts three input parameters: `p_school_id` of data type `NUMBER`, `p_nickname` of data type `VARCHAR2`, and `p_colors` of data type `VARCHAR2`. The primary purpose of this procedure is to perform a conditional data modification operation on the `SCHOOL_DETAILS` table. This operation involves either updating an existing record or inserting a new record based on the presence of a matching `SCHOOL_ID`. The procedure utilizes a `MERGE` statement, which combines `INSERT` and `UPDATE` functionalities into a single SQL statement. The target table for this `MERGE` operation is `SCHOOL_DETAILS`, aliased as `sd`. The source for the `MERGE` operation is a subquery `(SELECT p_school_id AS sid FROM DUAL) src`. This subquery effectively creates a single-row, single-column virtual table where the column `sid` holds the value passed into the `p_school_id` parameter of the procedure. The `MERGE` statement's `ON` clause specifies the join condition between the target table `SCHOOL_DETAILS` and the source `src`. This condition is `sd.SCHOOL_ID = src.sid`, meaning that records in `SCHOOL_DETAILS` are matched with the source record if their `SCHOOL_ID` column value is equal to the `sid` value from the source (which is `p_school_id`).\n\nIf a match is found based on this condition (`WHEN MATCHED THEN`), the procedure executes an `UPDATE` operation on the matched row in the `SCHOOL_DETAILS` table. Specifically, it sets the `NICKNAME` column of the matched row to the value provided by the `p_nickname` parameter, and it sets the `COLORS` column of the matched row to the value provided by the `p_colors` parameter.\n\nIf no match is found based on the `ON` clause condition (`WHEN NOT MATCHED THEN`), the procedure executes an `INSERT` operation. A new row is inserted into the `SCHOOL_DETAILS` table. The `SCHOOL_ID` column of this new row is populated with the value from the `p_school_id` parameter, the `NICKNAME` column is populated with the value from the `p_nickname` parameter, and the `COLORS` column is populated with the value from the `p_colors` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE MergeSchoolInfo (\n    p_school_id IN NUMBER,\n    p_nickname IN VARCHAR2,\n    p_colors IN VARCHAR2\n) AS\nBEGIN\n    MERGE INTO SCHOOL_DETAILS sd\n    USING (SELECT p_school_id AS sid FROM DUAL) src\n    ON (sd.SCHOOL_ID = src.sid)\n    WHEN MATCHED THEN\n        UPDATE SET sd.NICKNAME = p_nickname, sd.COLORS = p_colors\n    WHEN NOT MATCHED THEN\n        INSERT (SCHOOL_ID, NICKNAME, COLORS)\n        VALUES (p_school_id, p_nickname, p_colors);\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "BEGIN\n  MergeSchoolInfo(1, 'Tigers', 'Blue and Gold');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeSchoolInfo(5, 'Eagles', 'Green and White');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeSchoolInfo(2, 'Auks', 'Dark Green and White');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeSchoolInfo(3, 'Buccaneers', 'Garnet and White');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeSchoolInfo(10, 'Lions', 'Purple and Black');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named MergeSchoolInfo that accepts a school ID (NUMBER), nickname (VARCHAR2), and colors (VARCHAR2). Use a MERGE statement to update the SCHOOL_DETAILS table if a matching SCHOOL_ID exists, setting NICKNAME and COLORS. If no match exists, insert a new row with the provided values.",
    "natural_language": "Hey, can you whip up a stored procedure called MergeSchoolInfo? It needs to take in a school ID (as a NUMBER), a nickname (as a VARCHAR2), and some colors (also a VARCHAR2). Here's the deal: use a MERGE statement to check the SCHOOL_DETAILS table. If you find a row with the same SCHOOL_ID, just go ahead and update its NICKNAME and COLORS. If that ID isn't there at all, no worriesâ€”just pop in a brand new row with all the info we've got.",
    "id": 14,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `MergeSchoolInfo` that accepts three input parameters: `p_school_id` of data type `NUMBER`, `p_nickname` of data type `VARCHAR2`, and `p_colors` of data type `VARCHAR2`. The primary purpose of this procedure is to perform a conditional data modification operation on the `SCHOOL_DETAILS` table. This operation involves either updating an existing record or inserting a new record based on the presence of a matching `SCHOOL_ID`. The procedure utilizes a `MERGE` statement, which combines `INSERT` and `UPDATE` functionalities into a single SQL statement. The target table for this `MERGE` operation is `SCHOOL_DETAILS`, aliased as `sd`. The source for the `MERGE` operation is a subquery `(SELECT p_school_id AS sid FROM DUAL) src`. This subquery effectively creates a single-row, single-column virtual table where the column `sid` holds the value passed into the `p_school_id` parameter of the procedure. The `MERGE` statement's `ON` clause specifies the join condition between the target table `SCHOOL_DETAILS` and the source `src`. This condition is `sd.SCHOOL_ID = src.sid`, meaning that records in `SCHOOL_DETAILS` are matched with the source record if their `SCHOOL_ID` column value is equal to the `sid` value from the source (which is `p_school_id`).\n\nIf a match is found based on this condition (`WHEN MATCHED THEN`), the procedure executes an `UPDATE` operation on the matched row in the `SCHOOL_DETAILS` table. Specifically, it sets the `NICKNAME` column of the matched row to the value provided by the `p_nickname` parameter, and it sets the `COLORS` column of the matched row to the value provided by the `p_colors` parameter.\n\nIf no match is found based on the `ON` clause condition (`WHEN NOT MATCHED THEN`), the procedure executes an `INSERT` operation. A new row is inserted into the `SCHOOL_DETAILS` table. The `SCHOOL_ID` column of this new row is populated with the value from the `p_school_id` parameter, the `NICKNAME` column is populated with the value from the `p_nickname` parameter, and the `COLORS` column is populated with the value from the `p_colors` parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_update_department` that accepts two input parameters: `p_department_id` of data type `NUMBER`, which represents the unique identifier for a department, and `p_budget_limit` of data type `NUMBER`, which represents a monetary threshold for the department's budget. The procedure performs a `DELETE` operation on the `DEPARTMENT` table. This `DELETE` operation targets rows in the `DEPARTMENT` table where two conditions are simultaneously met: first, the value in the `DEPARTMENT_ID` column of the `DEPARTMENT` table must be equal to the value provided in the `p_department_id` input parameter, and second, the value in the `BUDGET_IN_BILLIONS` column of the `DEPARTMENT` table must be strictly less than the value provided in the `p_budget_limit` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_department(p_department_id NUMBER, p_budget_limit NUMBER) IS\nBEGIN\n  DELETE FROM DEPARTMENT WHERE DEPARTMENT_ID = p_department_id AND BUDGET_IN_BILLIONS < p_budget_limit;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_department(1, 10);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_department(2, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_department(3, 500);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_department(1, 15);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_department(2, 12);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_department that deletes a department. It takes a department ID and a budget limit as numbers. It deletes rows from the DEPARTMENT table where the DEPARTMENT_ID matches the input ID AND the BUDGET_IN_BILLIONS is less than the input budget limit.",
    "natural_language": "Delete a department by creating a stored procedure named sp_update_department. The procedure must accept a department ID and a budget limit as numbers. It should remove rows from the DEPARTMENT table where the DEPARTMENT_ID equals the provided ID and the BUDGET_IN_BILLIONS is below the given budget limit.",
    "id": 15,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp_update_department` that accepts two input parameters: `p_department_id` of data type `NUMBER`, which represents the unique identifier for a department, and `p_budget_limit` of data type `NUMBER`, which represents a monetary threshold for the department's budget. The procedure performs a `DELETE` operation on the `DEPARTMENT` table. This `DELETE` operation targets rows in the `DEPARTMENT` table where two conditions are simultaneously met: first, the value in the `DEPARTMENT_ID` column of the `DEPARTMENT` table must be equal to the value provided in the `p_department_id` input parameter, and second, the value in the `BUDGET_IN_BILLIONS` column of the `DEPARTMENT` table must be strictly less than the value provided in the `p_budget_limit` input parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named 'sp' that accepts four input parameters: a numeric parameter 'p_company_id' representing a company identifier, a numeric parameter 'p_station_id' representing a station identifier, a numeric parameter 'p_rank' representing a rank value, and a numeric parameter 'p_open_year' representing a year, though this last parameter is not used within the procedure's logic. The procedure begins by declaring a local numeric variable 'v_count'. It then executes a SELECT statement to query the 'STATION_COMPANY' table, counting the number of existing rows where the 'COMPANY_ID' column matches the input parameter 'p_company_id' and the 'STATION_ID' column matches the input parameter 'p_station_id', storing the result of this count into the variable 'v_count'. Following this query, an IF conditional statement evaluates whether the value of 'v_count' is equal to zero. If this condition is true, indicating that no matching record exists in the 'STATION_COMPANY' table for the given company and station combination, the procedure performs an INSERT operation into the 'STATION_COMPANY' table. This INSERT statement specifies values for three columns: it sets the 'STATION_ID' column to the value of the input parameter 'p_station_id', sets the 'COMPANY_ID' column to the value of the input parameter 'p_company_id', and sets the 'RANK_OF_THE_YEAR' column to the value of the input parameter 'p_rank'. If the condition in the IF statement is false, meaning 'v_count' is not zero and a matching record already exists, the procedure takes no further action and concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_company_id NUMBER, p_station_id NUMBER, p_rank NUMBER, p_open_year NUMBER) IS\n   v_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_count FROM STATION_COMPANY WHERE COMPANY_ID = p_company_id AND STATION_ID = p_station_id;\n   IF v_count = 0 THEN\n      INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR) VALUES (p_station_id, p_company_id, p_rank);\n   END IF;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1, 1, 1, 1998);\n  commit;\nEND;",
      "BEGIN\n  sp(2, 2, 3, 1999);\n  commit;\nEND;",
      "BEGIN\n  sp(3, 3, 4, 2000);\n  commit;\nEND;",
      "BEGIN\n  sp(1, 2, 1, 1999);\n  commit;\nEND;",
      "BEGIN\n  sp(2, 3, 3, 2000);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named 'sp' that inserts a record into the STATION_COMPANY table for a given company and station if it does not already exist. The procedure accepts parameters for company ID, station ID, and rank. A fourth parameter for year is accepted but not used.",
    "natural_language": "How can I create a stored procedure named 'sp' that will insert a record into the STATION_COMPANY table for a specified company and station, but only if the record does not already exist? The procedure should accept parameters for company ID, station ID, and rank, and also accept a fourth parameter for year that is not used.",
    "id": 16,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named 'sp' that accepts four input parameters: a numeric parameter 'p_company_id' representing a company identifier, a numeric parameter 'p_station_id' representing a station identifier, a numeric parameter 'p_rank' representing a rank value, and a numeric parameter 'p_open_year' representing a year, though this last parameter is not used within the procedure's logic. The procedure begins by declaring a local numeric variable 'v_count'. It then executes a SELECT statement to query the 'STATION_COMPANY' table, counting the number of existing rows where the 'COMPANY_ID' column matches the input parameter 'p_company_id' and the 'STATION_ID' column matches the input parameter 'p_station_id', storing the result of this count into the variable 'v_count'. Following this query, an IF conditional statement evaluates whether the value of 'v_count' is equal to zero. If this condition is true, indicating that no matching record exists in the 'STATION_COMPANY' table for the given company and station combination, the procedure performs an INSERT operation into the 'STATION_COMPANY' table. This INSERT statement specifies values for three columns: it sets the 'STATION_ID' column to the value of the input parameter 'p_station_id', sets the 'COMPANY_ID' column to the value of the input parameter 'p_company_id', and sets the 'RANK_OF_THE_YEAR' column to the value of the input parameter 'p_rank'. If the condition in the IF statement is false, meaning 'v_count' is not zero and a matching record already exists, the procedure takes no further action and concludes."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `TransformServiceDetails` that accepts two input parameters: `p_resident_id` of type `NUMBER`, representing the unique identifier for a resident, and `p_service_id` of type `NUMBER`, representing the unique identifier for a service. The procedure declares four local variables: `v_service_details` of type `VARCHAR2(255)` to store service details, `v_other_details` of type `VARCHAR2(255)` to store other service-related details, `v_new_details` of type `VARCHAR2(255)` to store the transformed service details, and `v_record_exists` of type `NUMBER` initialized to `0` to indicate whether a record exists.\n\nThe procedure begins by executing a `SELECT` statement to retrieve data from the `SERVICES` and `RESIDENTS_SERVICES` tables. It selects the `SERVICE_DETAILS` column from the `SERVICES` table into `v_service_details` and the `OTHER_DETAILS` column from the `RESIDENTS_SERVICES` table into `v_other_details`. This `SELECT` statement performs a `LEFT JOIN` between `SERVICES` (aliased as `s`) and `RESIDENTS_SERVICES` (aliased as `rs`) on the condition that `s.SERVICE_ID` equals `rs.SERVICE_ID` and `rs.RESIDENT_ID` equals the input parameter `p_resident_id`. The `WHERE` clause further filters the results to records where `s.SERVICE_ID` equals the input parameter `p_service_id`.\n\nFollowing the data retrieval, the procedure enters a conditional logic block to determine the value of `v_new_details`.\nIf `v_service_details` is equal to the string literal 'Satisfied' AND `v_other_details` is NOT `NULL`, then `v_new_details` is assigned a value constructed by concatenating the uppercase version of the first three characters of `v_other_details` (obtained using `UPPER(SUBSTR(v_other_details, 1, 3))`) with the string literal '_COMPLETE'.\nElse if `v_service_details` IS `NULL`, then `v_new_details` is assigned the string literal 'UNKNOWN_STATUS'.\nOtherwise (if `v_service_details` is not 'Satisfied' and not `NULL`), `v_new_details` is assigned a value constructed by concatenating the lowercase version of `v_service_details` (obtained using `LOWER(v_service_details)`) with the string literal '_PROCESSED'.\n\nNext, the procedure executes another `SELECT` statement to check for the existence of a record in the `RESIDENTS_SERVICES` table. It counts the number of rows where `RESIDENT_ID` equals `p_resident_id` and `SERVICE_ID` equals `p_service_id`, storing this count in the `v_record_exists` variable.\n\nSubsequently, the procedure enters another conditional logic block based on the value of `v_record_exists`.\nIf `v_record_exists` is greater than `0` (meaning a matching record exists), the procedure executes an `UPDATE` statement on the `RESIDENTS_SERVICES` table. It sets the `OTHER_DETAILS` column to the value of `v_new_details` and the `DATE_PROVIDED` column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' (obtained using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`). This update is applied to the row(s) where `RESIDENT_ID` equals `p_resident_id` and `SERVICE_ID` equals `p_service_id`.\nElse (if `v_record_exists` is not greater than `0`, meaning no matching record exists), the procedure outputs a message to the `DBMS_OUTPUT` buffer indicating that no existing record was found for the given `RESIDENT_ID` and `SERVICE_ID`. The message is constructed by concatenating the string literal 'No existing record found for RESIDENT_ID: ', the value of `p_resident_id`, the string literal ', SERVICE_ID: ', and the value of `p_service_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE TransformServiceDetails(\n  p_resident_id IN NUMBER,\n  p_service_id IN NUMBER\n) AS\n  v_service_details VARCHAR2(255);\n  v_other_details VARCHAR2(255);\n  v_new_details VARCHAR2(255);\n  v_record_exists NUMBER := 0;\nBEGIN\n  SELECT s.SERVICE_DETAILS, rs.OTHER_DETAILS INTO v_service_details, v_other_details\n  FROM SERVICES s\n  LEFT JOIN RESIDENTS_SERVICES rs ON s.SERVICE_ID = rs.SERVICE_ID AND rs.RESIDENT_ID = p_resident_id\n  WHERE s.SERVICE_ID = p_service_id;\n\n  IF v_service_details = 'Satisfied' AND v_other_details IS NOT NULL THEN\n    v_new_details := UPPER(SUBSTR(v_other_details, 1, 3)) || '_COMPLETE';\n  ELSIF v_service_details IS NULL THEN\n    v_new_details := 'UNKNOWN_STATUS';\n  ELSE\n    v_new_details := LOWER(v_service_details) || '_PROCESSED';\n  END IF;\n\n  -- Check if record exists in RESIDENTS_SERVICES\n  SELECT COUNT(*) INTO v_record_exists\n  FROM RESIDENTS_SERVICES\n  WHERE RESIDENT_ID = p_resident_id AND SERVICE_ID = p_service_id;\n\n  IF v_record_exists > 0 THEN\n    -- Update existing record\n    UPDATE RESIDENTS_SERVICES\n    SET OTHER_DETAILS = v_new_details,\n        DATE_PROVIDED = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n    WHERE RESIDENT_ID = p_resident_id AND SERVICE_ID = p_service_id;\n  ELSE\n    -- Record doesn't exist, cannot insert due to foreign key constraints\n    -- Log or handle this case as needed\n    DBMS_OUTPUT.PUT_LINE('No existing record found for RESIDENT_ID: ' || p_resident_id || ', SERVICE_ID: ' || p_service_id);\n  END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  TransformServiceDetails(6, 49);\n  commit;\nEND;",
      "BEGIN\n  TransformServiceDetails(23, 41);\n  commit;\nEND;",
      "BEGIN\n  TransformServiceDetails(28, 11);\n  commit;\nEND;",
      "BEGIN\n  TransformServiceDetails(6, 11);\n  commit;\nEND;",
      "BEGIN\n  TransformServiceDetails(23, 49);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named TransformServiceDetails that transforms and updates service details for a resident. It retrieves service details and other details via a join. It generates new transformed details based on conditional logic comparing these values. Then it checks for an existing record. If exists: updates OTHER_DETAILS and DATE_PROVIDED. If not exists: outputs a message indicating no record found.",
    "natural_language": "Hey, can you whip up a stored procedure called TransformServiceDetails? Basically, it needs to grab a resident's service info by joining some tables, then cook up some new details based on a few if-then checks comparing the old values. After that, it should look to see if there's already a record for this. If it finds one, it'll just update the OTHER_DETAILS and DATE_PROVIDED fields. If it comes up empty, just have it spit out a message saying \"No record found.\"",
    "id": 17,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `TransformServiceDetails` that accepts two input parameters: `p_resident_id` of type `NUMBER`, representing the unique identifier for a resident, and `p_service_id` of type `NUMBER`, representing the unique identifier for a service. The procedure declares four local variables: `v_service_details` of type `VARCHAR2(255)` to store service details, `v_other_details` of type `VARCHAR2(255)` to store other service-related details, `v_new_details` of type `VARCHAR2(255)` to store the transformed service details, and `v_record_exists` of type `NUMBER` initialized to `0` to indicate whether a record exists.\n\nThe procedure begins by executing a `SELECT` statement to retrieve data from the `SERVICES` and `RESIDENTS_SERVICES` tables. It selects the `SERVICE_DETAILS` column from the `SERVICES` table into `v_service_details` and the `OTHER_DETAILS` column from the `RESIDENTS_SERVICES` table into `v_other_details`. This `SELECT` statement performs a `LEFT JOIN` between `SERVICES` (aliased as `s`) and `RESIDENTS_SERVICES` (aliased as `rs`) on the condition that `s.SERVICE_ID` equals `rs.SERVICE_ID` and `rs.RESIDENT_ID` equals the input parameter `p_resident_id`. The `WHERE` clause further filters the results to records where `s.SERVICE_ID` equals the input parameter `p_service_id`.\n\nFollowing the data retrieval, the procedure enters a conditional logic block to determine the value of `v_new_details`.\nIf `v_service_details` is equal to the string literal 'Satisfied' AND `v_other_details` is NOT `NULL`, then `v_new_details` is assigned a value constructed by concatenating the uppercase version of the first three characters of `v_other_details` (obtained using `UPPER(SUBSTR(v_other_details, 1, 3))`) with the string literal '_COMPLETE'.\nElse if `v_service_details` IS `NULL`, then `v_new_details` is assigned the string literal 'UNKNOWN_STATUS'.\nOtherwise (if `v_service_details` is not 'Satisfied' and not `NULL`), `v_new_details` is assigned a value constructed by concatenating the lowercase version of `v_service_details` (obtained using `LOWER(v_service_details)`) with the string literal '_PROCESSED'.\n\nNext, the procedure executes another `SELECT` statement to check for the existence of a record in the `RESIDENTS_SERVICES` table. It counts the number of rows where `RESIDENT_ID` equals `p_resident_id` and `SERVICE_ID` equals `p_service_id`, storing this count in the `v_record_exists` variable.\n\nSubsequently, the procedure enters another conditional logic block based on the value of `v_record_exists`.\nIf `v_record_exists` is greater than `0` (meaning a matching record exists), the procedure executes an `UPDATE` statement on the `RESIDENTS_SERVICES` table. It sets the `OTHER_DETAILS` column to the value of `v_new_details` and the `DATE_PROVIDED` column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' (obtained using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`). This update is applied to the row(s) where `RESIDENT_ID` equals `p_resident_id` and `SERVICE_ID` equals `p_service_id`.\nElse (if `v_record_exists` is not greater than `0`, meaning no matching record exists), the procedure outputs a message to the `DBMS_OUTPUT` buffer indicating that no existing record was found for the given `RESIDENT_ID` and `SERVICE_ID`. The message is constructed by concatenating the string literal 'No existing record found for RESIDENT_ID: ', the value of `p_resident_id`, the string literal ', SERVICE_ID: ', and the value of `p_service_id`."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_department_restructure that accepts three input parameters: a numeric parameter p_old_dept_id representing the source department identifier, a numeric parameter p_new_dept_id representing the target department identifier, and a string parameter p_cutoff_date representing a specific date boundary. The procedure begins by declaring a cursor named emp_cursor that selects the employee_id and job_id columns from the employees table for all rows where the department_id column matches the p_old_dept_id parameter and the hire_date column is earlier than the p_cutoff_date parameter. It then declares a record variable v_emp_record based on the row structure of this cursor. The procedure opens the cursor and enters a loop, fetching each row from the cursor into the v_emp_record variable. The loop continues until no more rows are found in the cursor. For each fetched record, the procedure performs two operations: first, it inserts a new row into the job_history table, populating the employee_id column with the value from v_emp_record.employee_id, the start_date and end_date columns both with the p_cutoff_date parameter value, the job_id column with the value from v_emp_record.job_id, and the department_id column with the p_old_dept_id parameter value; second, it updates the employees table, setting the department_id column to the p_new_dept_id parameter value for the row where the employee_id column matches v_emp_record.employee_id. After processing all cursor rows, the procedure closes the cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_department_restructure(\n    p_old_dept_id IN NUMBER,\n    p_new_dept_id IN NUMBER,\n    p_cutoff_date IN VARCHAR2\n) IS\n    CURSOR emp_cursor IS\n        SELECT employee_id, job_id\n        FROM employees\n        WHERE department_id = p_old_dept_id\n        AND hire_date < p_cutoff_date;\n    \n    v_emp_record emp_cursor%ROWTYPE;\nBEGIN\n    OPEN emp_cursor;\n    LOOP\n        FETCH emp_cursor INTO v_emp_record;\n        EXIT WHEN emp_cursor%NOTFOUND;\n        \n        INSERT INTO job_history (employee_id, start_date, end_date, job_id, department_id)\n        VALUES (v_emp_record.employee_id, p_cutoff_date, p_cutoff_date, v_emp_record.job_id, p_old_dept_id);\n        \n        UPDATE employees\n        SET department_id = p_new_dept_id\n        WHERE employee_id = v_emp_record.employee_id;\n    END LOOP;\n    CLOSE emp_cursor;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY"
    ],
    "call_sqls": [
      "BEGIN\n  process_department_restructure(90, 100, '2024-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  process_department_restructure(60, 80, '2023-06-30');\n  COMMIT;\nEND;",
      "BEGIN\n  process_department_restructure(50, 40, '2024-03-15');\n  COMMIT;\nEND;",
      "BEGIN\n  process_department_restructure(30, 10, '2022-12-31');\n  COMMIT;\nEND;",
      "BEGIN\n  process_department_restructure(20, 30, '2024-05-20');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named process_department_restructure that accepts an old department ID, a new department ID, and a cutoff date. For each employee in the old department hired before the cutoff date, insert a record into job_history with the cutoff date and their current job, then update their department to the new one.",
    "natural_language": "Please construct a stored procedure designated as 'process_department_restructure'. This procedure shall accept three parameters: an old department identifier, a new department identifier, and a specified cutoff date. For every employee currently assigned to the old department whose hire date precedes the provided cutoff date, the procedure must perform the following operations in sequence: first, insert a corresponding record into the 'job_history' table, documenting the cutoff date and the employee's present job details; subsequently, update the employee's department assignment to the new department identifier.",
    "id": 18,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named process_department_restructure that accepts three input parameters: a numeric parameter p_old_dept_id representing the source department identifier, a numeric parameter p_new_dept_id representing the target department identifier, and a string parameter p_cutoff_date representing a specific date boundary. The procedure begins by declaring a cursor named emp_cursor that selects the employee_id and job_id columns from the employees table for all rows where the department_id column matches the p_old_dept_id parameter and the hire_date column is earlier than the p_cutoff_date parameter. It then declares a record variable v_emp_record based on the row structure of this cursor. The procedure opens the cursor and enters a loop, fetching each row from the cursor into the v_emp_record variable. The loop continues until no more rows are found in the cursor. For each fetched record, the procedure performs two operations: first, it inserts a new row into the job_history table, populating the employee_id column with the value from v_emp_record.employee_id, the start_date and end_date columns both with the p_cutoff_date parameter value, the job_id column with the value from v_emp_record.job_id, and the department_id column with the p_old_dept_id parameter value; second, it updates the employees table, setting the department_id column to the p_new_dept_id parameter value for the row where the employee_id column matches v_emp_record.employee_id. After processing all cursor rows, the procedure closes the cursor."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ValidateAndCleanServices` that accepts two input parameters: `p_resident_id` of type `NUMBER`, representing the unique identifier of a resident, and `p_min_property_id` of type `NUMBER`, representing a minimum property identifier threshold. The procedure begins by declaring three local variables: `v_invalid_count` of type `NUMBER` to store the count of invalid service records, `v_valid_count` of type `NUMBER` to store the count of valid service records, and `v_service_id_to_keep` of type `NUMBER` to store the `SERVICE_ID` of a valid service record that will be retained or used for insertion.\n\nThe procedure first executes a `SELECT` statement to count the number of \"invalid\" service records associated with the `p_resident_id`. This count is stored in `v_invalid_count`. The `SELECT` statement queries the `RESIDENTS_SERVICES` table, aliased as `rs`, and joins it with the `SERVICES` table, aliased as `s`, on the condition `rs.SERVICE_ID = s.SERVICE_ID`. The filtering conditions for invalid records are: `rs.RESIDENT_ID` must equal `p_resident_id`, AND (`rs.PROPERTY_ID` must be less than `p_min_property_id` OR `rs.DATE_REQUESTED` must be `NULL` OR `s.SERVICE_DETAILS` must be `NULL`).\n\nNext, the procedure executes another `SELECT` statement to count the number of \"valid\" service records associated with the `p_resident_id`. This count is stored in `v_valid_count`. This `SELECT` statement also queries the `RESIDENTS_SERVICES` table (aliased as `rs`) and joins it with the `SERVICES` table (aliased as `s`) on `rs.SERVICE_ID = s.SERVICE_ID`. The filtering conditions for valid records are: `rs.RESIDENT_ID` must equal `p_resident_id`, AND `rs.PROPERTY_ID` must be greater than or equal to `p_min_property_id`, AND `rs.DATE_REQUESTED` must NOT be `NULL`, AND `s.SERVICE_DETAILS` must NOT be `NULL`.\n\nFollowing these counts, the procedure enters a conditional block: `IF v_invalid_count > 0 THEN`. This means the subsequent operations will only execute if at least one invalid service record was found.\n\nInside this conditional block, a `SELECT` statement is executed to find the maximum `SERVICE_ID` among the valid service records for the given `p_resident_id`. This maximum `SERVICE_ID` is stored in `v_service_id_to_keep`. The `SELECT` statement queries `RESIDENTS_SERVICES` (aliased as `rs`) joined with `SERVICES` (aliased as `s`) on `rs.SERVICE_ID = s.SERVICE_ID`. The conditions for selecting these records are: `rs.RESIDENT_ID` must equal `p_resident_id`, AND `rs.PROPERTY_ID` must be greater than or equal to `p_min_property_id`, AND `rs.DATE_REQUESTED` must NOT be `NULL`, AND `s.SERVICE_DETAILS` must NOT be `NULL`.\n\nSubsequently, a `DELETE` statement is executed to remove specific records from the `RESIDENTS_SERVICES` table. The records to be deleted are those where `RESIDENT_ID` equals `p_resident_id` AND (`PROPERTY_ID` is less than `p_min_property_id` OR `DATE_REQUESTED` is `NULL`). Note that this `DELETE` statement does not consider the `SERVICES` table or the `SERVICE_DETAILS` column for its deletion criteria, only `RESIDENTS_SERVICES` table columns.\n\nAfter the deletion, another nested conditional block is entered: `IF v_service_id_to_keep IS NOT NULL THEN`. This means an insertion will only occur if a valid `SERVICE_ID` was found and stored in `v_service_id_to_keep`.\n\nInside this nested conditional block, an `INSERT` statement is executed to add a new record into the `RESIDENTS_SERVICES` table. The columns being populated are `RESIDENT_ID`, `SERVICE_ID`, `DATE_MOVED_IN`, `PROPERTY_ID`, `DATE_REQUESTED`, `DATE_PROVIDED`, and `OTHER_DETAILS`. The values for these columns are derived as follows:\n- `RESIDENT_ID` is set to `p_resident_id`.\n- `SERVICE_ID` is set to `v_service_id_to_keep`.\n- `DATE_MOVED_IN` is set to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`.\n- `PROPERTY_ID` is set to the maximum `PROPERTY_ID` found in the `RESIDENTS_SERVICES` table for the given `p_resident_id`. This value is obtained from a subquery `SELECT MAX(PROPERTY_ID) FROM RESIDENTS_SERVICES WHERE RESIDENT_ID = p_resident_id`.\n- `DATE_REQUESTED` is set to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`.\n- `DATE_PROVIDED` is set to `NULL`.\n- `OTHER_DETAILS` is set to a concatenated string 'Cleaned: ' followed by the value of `v_invalid_count` and then ' invalid'.",
    "plsql": "CREATE OR REPLACE PROCEDURE ValidateAndCleanServices(\n  p_resident_id IN NUMBER,\n  p_min_property_id IN NUMBER\n) AS\n  v_invalid_count NUMBER;\n  v_valid_count NUMBER;\n  v_service_id_to_keep NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_invalid_count\n  FROM RESIDENTS_SERVICES rs\n  JOIN SERVICES s ON rs.SERVICE_ID = s.SERVICE_ID\n  WHERE rs.RESIDENT_ID = p_resident_id\n  AND (rs.PROPERTY_ID < p_min_property_id OR rs.DATE_REQUESTED IS NULL OR s.SERVICE_DETAILS IS NULL);\n\n  SELECT COUNT(*) INTO v_valid_count\n  FROM RESIDENTS_SERVICES rs\n  JOIN SERVICES s ON rs.SERVICE_ID = s.SERVICE_ID\n  WHERE rs.RESIDENT_ID = p_resident_id\n  AND rs.PROPERTY_ID >= p_min_property_id\n  AND rs.DATE_REQUESTED IS NOT NULL\n  AND s.SERVICE_DETAILS IS NOT NULL;\n\n  IF v_invalid_count > 0 THEN\n    SELECT MAX(rs.SERVICE_ID) INTO v_service_id_to_keep\n    FROM RESIDENTS_SERVICES rs\n    JOIN SERVICES s ON rs.SERVICE_ID = s.SERVICE_ID\n    WHERE rs.RESIDENT_ID = p_resident_id\n    AND rs.PROPERTY_ID >= p_min_property_id\n    AND rs.DATE_REQUESTED IS NOT NULL\n    AND s.SERVICE_DETAILS IS NOT NULL;\n\n    DELETE FROM RESIDENTS_SERVICES\n    WHERE RESIDENT_ID = p_resident_id\n    AND (PROPERTY_ID < p_min_property_id OR DATE_REQUESTED IS NULL);\n\n    IF v_service_id_to_keep IS NOT NULL THEN\n      INSERT INTO RESIDENTS_SERVICES (RESIDENT_ID, SERVICE_ID, DATE_MOVED_IN, PROPERTY_ID, DATE_REQUESTED, DATE_PROVIDED, OTHER_DETAILS)\n      SELECT p_resident_id, v_service_id_to_keep, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), MAX(PROPERTY_ID), TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), NULL, 'Cleaned: ' || v_invalid_count || ' invalid'\n      FROM RESIDENTS_SERVICES\n      WHERE RESIDENT_ID = p_resident_id;\n    END IF;\n  END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  ValidateAndCleanServices(6, 500);\n  commit;\nEND;",
      "BEGIN\n  ValidateAndCleanServices(23, 700);\n  commit;\nEND;",
      "BEGIN\n  ValidateAndCleanServices(28, 800);\n  commit;\nEND;",
      "BEGIN\n  ValidateAndCleanServices(6, 600);\n  commit;\nEND;",
      "BEGIN\n  ValidateAndCleanServices(23, 900);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ValidateAndCleanServices that validates and cleans service records for a resident. It counts invalid records (PROPERTY_ID below threshold, or DATE_REQUESTED NULL, or SERVICE_DETAILS NULL) and valid records. If invalid records exist, it finds the maximum SERVICE_ID among valid records. It deletes the invalid records. If a valid SERVICE_ID was found, it inserts a new clean record using that ID, the maximum PROPERTY_ID for the resident, current timestamps, and a note about the cleanup count.",
    "natural_language": "Develop a comprehensive stored procedure called ValidateAndCleanServices, which meticulously validates and subsequently cleanses all service records associated with a specific resident. This procedure thoroughly examines the records, carefully counting both those deemed invalidâ€”where the PROPERTY_ID falls below a specified threshold, or the DATE_REQUESTED is null, or the SERVICE_DETAILS are missingâ€”and those that are valid. Should any invalid records be discovered, the procedure then diligently identifies the highest SERVICE_ID from among the valid entries. It proceeds to permanently delete all of the flawed, invalid records. Furthermore, if a valid SERVICE_ID was successfully located during this process, the procedure thoughtfully constructs and inserts a brand new, clean service record. This new record utilizes that identified ID, assigns the maximum PROPERTY_ID available for the resident, stamps it with the current date and time, and includes a detailed note documenting the total number of records cleaned up during this operation.",
    "id": 19,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named ValidateAndCleanServices that operates on the local_govt_and_lot database. The procedure takes one input parameter: a numeric parameter p_resident_id to identify a specific resident. The procedure validates and cleans service records for that resident from the RESIDENTS_SERVICES table, with reference to the SERVICES table.\n\nFirst, the procedure declares several variables: v_invalid_count of type NUMBER to store the count of invalid records, v_valid_count of type NUMBER to store the count of valid records, v_max_valid_service_id of type NUMBER to store the highest SERVICE_ID among valid records (initialized to NULL), v_max_property_id of type NUMBER to store the maximum PROPERTY_ID for the resident, v_current_timestamp of type VARCHAR2(255) to store the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS', and v_note_details of type VARCHAR2(255) to store a note about the cleanup.\n\nThe procedure begins by counting invalid and valid records for the specified resident. It performs a SELECT COUNT(*) query on the RESIDENTS_SERVICES table, joining with the SERVICES table on RESIDENTS_SERVICES.SERVICE_ID = SERVICES.SERVICE_ID, where RESIDENTS_SERVICES.RESIDENT_ID equals p_resident_id and the record is considered invalid if any of the following conditions are met: RESIDENTS_SERVICES.PROPERTY_ID is less than a specified threshold (e.g., 100, assuming a hardcoded threshold), or RESIDENTS_SERVICES.DATE_REQUESTED is NULL, or SERVICES.SERVICE_DETAILS is NULL. The result is stored in v_invalid_count. Similarly, it performs another SELECT COUNT(*) query with the same join and resident condition, but where the record is valid (i.e., RESIDENTS_SERVICES.PROPERTY_ID is greater than or equal to the threshold, RESIDENTS_SERVICES.DATE_REQUESTED is NOT NULL, and SERVICES.SERVICE_DETAILS is NOT NULL), storing the result in v_valid_count.\n\nIf v_invalid_count is greater than 0, indicating invalid records exist, the procedure then identifies the highest SERVICE_ID from among the valid records. It performs a SELECT MAX(RESIDENTS_SERVICES.SERVICE_ID) query from the RESIDENTS_SERVICES table, joining with the SERVICES table on RESIDENTS_SERVICES.SERVICE_ID = SERVICES.SERVICE_ID, where RESIDENTS_SERVICES.RESIDENT_ID equals p_resident_id and the record is valid (using the same validity conditions as above), storing the result in v_max_valid_service_id.\n\nNext, the procedure deletes all invalid records for the resident. It executes a DELETE operation on the RESIDENTS_SERVICES table, using a subquery to join with the SERVICES table on RESIDENTS_SERVICES.SERVICE_ID = SERVICES.SERVICE_ID, where RESIDENTS_SERVICES.RESIDENT_ID equals p_resident_id and the record meets any of the invalidity conditions (PROPERTY_ID below threshold, DATE_REQUESTED NULL, or SERVICE_DETAILS NULL).\n\nAfter the deletion, if v_max_valid_service_id is not NULL (meaning at least one valid SERVICE_ID was found), the procedure proceeds to create a new clean service record. First, it determines the maximum PROPERTY_ID for the resident by performing a SELECT MAX(PROPERTY_ID) query on the RESIDENTS_SERVICES table where RESIDENT_ID equals p_resident_id, storing the result in v_max_property_id (using NVL to default to 0 if NULL). It then sets v_current_timestamp to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'). It constructs v_note_details by concatenating the string 'Cleaned up ' with v_invalid_count and ' invalid records'.\n\nFinally, the procedure inserts a new record into the RESIDENTS_SERVICES table with the following values: RESIDENT_ID set to p_resident_id, SERVICE_ID set to v_max_valid_service_id, DATE_MOVED_IN set to v_current_timestamp (assuming it serves as a timestamp for the new record), PROPERTY_ID set to v_max_property_id, DATE_REQUESTED set to v_current_timestamp, DATE_PROVIDED set to v_current_timestamp, and OTHER_DETAILS set to v_note_details. The procedure does not return a value but performs the validation, cleanup, and insertion operations as described."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateCourseDate that accepts four input parameters: a numeric parameter p_course_id representing a course identifier, a string parameter p_new_date representing a new date, a numeric parameter p_teacher_id representing a teacher identifier, and a numeric parameter p_grade representing a grade level. The procedure first executes a DELETE operation on the COURSE_ARRANGE table, removing any rows where the COURSE_ID column matches p_course_id, the TEACHER_ID column matches p_teacher_id, and the GRADE column matches p_grade. Following the deletion, the procedure performs an UPDATE operation on the COURSE table, setting the STARING_DATE column to the value of p_new_date and the COURSE column to the literal string 'Updated Course' for the row where the COURSE_ID column equals p_course_id. After the update, the procedure checks the SQL%ROWCOUNT attribute; if its value is zero, indicating no rows were updated in the COURSE table, the procedure raises an application error with error code -20001 and the message 'Course ID does not exist.'",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateCourseDate(\n    p_course_id IN NUMBER,\n    p_new_date IN VARCHAR2,\n    p_teacher_id IN NUMBER,\n    p_grade IN NUMBER\n) AS\nBEGIN\n    DELETE FROM COURSE_ARRANGE\n    WHERE COURSE_ID = p_course_id AND TEACHER_ID = p_teacher_id AND GRADE = p_grade;\n    \n    UPDATE COURSE\n    SET STARING_DATE = p_new_date, COURSE = 'Updated Course'\n    WHERE COURSE_ID = p_course_id;\n    \n    IF SQL%ROWCOUNT = 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Course ID does not exist.');\n    END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateCourseDate(1, '10 May', 3, 3);\n  commit;\nEND;",
      "BEGIN\n  UpdateCourseDate(2, '11 May', 5, 1);\n  commit;\nEND;",
      "BEGIN\n  UpdateCourseDate(3, '12 May', 2, 5);\n  commit;\nEND;",
      "BEGIN\n  UpdateCourseDate(1, '13 May', 2, 3);\n  commit;\nEND;",
      "BEGIN\n  UpdateCourseDate(2, '14 May', 3, 5);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateCourseDate that takes a course ID, a new date, a teacher ID, and a grade. First, delete the corresponding arrangement from the COURSE_ARRANGE table using the course ID, teacher ID, and grade. Then, update the COURSE table for that course ID, setting the starting date to the new date and the course name to 'Updated Course'. If no course was updated, raise an application error 'Course ID does not exist.'",
    "natural_language": "How can I create a stored procedure called UpdateCourseDate that accepts a course ID, a new date, a teacher ID, and a grade? The procedure should first remove the matching record from the COURSE_ARRANGE table using the provided course ID, teacher ID, and grade. Then, it should update the COURSE table for that course ID by setting the starting date to the new date and the course name to 'Updated Course'. What should happen if no course is updated? An application error with the message 'Course ID does not exist.' should be raised.",
    "id": 20,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateCourseDate that accepts four input parameters: a numeric parameter p_course_id representing a course identifier, a string parameter p_new_date representing a new date, a numeric parameter p_teacher_id representing a teacher identifier, and a numeric parameter p_grade representing a grade level. The procedure first executes a DELETE operation on the COURSE_ARRANGE table, removing any rows where the COURSE_ID column matches p_course_id, the TEACHER_ID column matches p_teacher_id, and the GRADE column matches p_grade. Following the deletion, the procedure performs an UPDATE operation on the COURSE table, setting the STARING_DATE column to the value of p_new_date and the COURSE column to the literal string 'Updated Course' for the row where the COURSE_ID column equals p_course_id. After the update, the procedure checks the SQL%ROWCOUNT attribute; if its value is zero, indicating no rows were updated in the COURSE table, the procedure raises an application error with error code -20001 and the message 'Course ID does not exist.'"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_create_customer_address` that accepts three input parameters: `p_customer_id` of type `NUMBER`, `p_customer_name` of type `VARCHAR2`, and `p_address_details` of type `VARCHAR2`. The procedure declares three local variables: `v_address_id` of type `NUMBER`, `v_customer_exists` of type `NUMBER`, and `v_truncated_address` of type `VARCHAR2(255)`. The execution begins by assigning a truncated version of the `p_address_details` parameter to the `v_truncated_address` variable. This truncation is performed using the `SUBSTRB` function, which extracts a substring of bytes from `p_address_details`, starting from the first byte and extending for a maximum of 255 bytes. Next, the procedure queries the `CUSTOMERS` table to determine if a customer with the provided `p_customer_id` already exists. It does this by performing a `SELECT COUNT(*)` operation, storing the count of matching rows into the `v_customer_exists` variable, where the `CUSTOMER_ID` column equals the `p_customer_id` parameter. Following this, a conditional block is executed: `IF v_customer_exists = 0 THEN`. This means the subsequent operations will only proceed if no customer with the given `p_customer_id` was found in the `CUSTOMERS` table. Inside this conditional block, the procedure first attempts to determine a new `ADDRESS_ID`. It does this by performing a `SELECT MAX(ADDRESS_ID) + 1` operation from the `ADDRESSES` table, storing the result into `v_address_id`. If the `v_address_id` obtained from this query is `NULL` (which would happen if the `ADDRESSES` table is empty), then `v_address_id` is explicitly set to `1`. After determining the `v_address_id`, the procedure performs an `INSERT` operation into the `ADDRESSES` table. It inserts a new row with the `ADDRESS_ID` column set to the value of `v_address_id` and the `ADDRESS_DETAILS` column set to the value of `v_truncated_address`. Immediately after this, another `INSERT` operation is performed, this time into the `CUSTOMERS` table. A new customer record is inserted with the `CUSTOMER_ID` column set to `p_customer_id`, the `ADDRESS_ID` column set to `v_address_id`, the `CUSTOMER_NAME` column set to `p_customer_name`, and the `CUSTOMER_ADDRESS` column set to `v_truncated_address`. The `CUSTOMER_PHONE`, `CUSTOMER_EMAIL`, `PAYMENT_METHOD_CODE`, and `CUSTOMER_NUMBER` columns are all explicitly set to `NULL` during this insertion. The conditional block then concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_create_customer_address(p_customer_id IN NUMBER, p_customer_name IN VARCHAR2, p_address_details IN VARCHAR2)\nIS\n    v_address_id NUMBER;\n    v_customer_exists NUMBER;\n    v_truncated_address VARCHAR2(255);\nBEGIN\n    v_truncated_address := SUBSTRB(p_address_details, 1, 255);\n    SELECT COUNT(*) INTO v_customer_exists FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    IF v_customer_exists = 0 THEN\n        SELECT MAX(ADDRESS_ID) + 1 INTO v_address_id FROM ADDRESSES;\n        IF v_address_id IS NULL THEN\n            v_address_id := 1;\n        END IF;\n        INSERT INTO ADDRESSES (ADDRESS_ID, ADDRESS_DETAILS)\n        VALUES (v_address_id, v_truncated_address);\n        INSERT INTO CUSTOMERS (CUSTOMER_ID, ADDRESS_ID, CUSTOMER_NAME, CUSTOMER_ADDRESS, CUSTOMER_PHONE, CUSTOMER_EMAIL, PAYMENT_METHOD_CODE, CUSTOMER_NUMBER)\n        VALUES (p_customer_id, v_address_id, p_customer_name, v_truncated_address, NULL, NULL, NULL, NULL);\n    END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_create_customer_address(6, 'Alice', '123 Elm Street Apt. 4B');\n  commit;\nEND;",
      "BEGIN\n  proc_create_customer_address(7, 'Bob', '456 Oak Avenue Suite 12');\n  commit;\nEND;",
      "BEGIN\n  proc_create_customer_address(8, 'Charlie', '789 Pine Road');\n  commit;\nEND;",
      "BEGIN\n  proc_create_customer_address(9, 'Diana', '101 Maple Lane');\n  commit;\nEND;",
      "BEGIN\n  proc_create_customer_address(10, 'Eve', '202 Birch Boulevard');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_create_customer_address` that accepts a customer ID, name, and address details. It checks if the customer ID already exists. If not, it generates a new address ID, inserts a truncated address (255 bytes) into the ADDRESSES table, and then inserts a new customer record with the provided ID, name, and address, setting other columns to NULL.",
    "natural_language": "Please construct a stored procedure designated as `proc_create_customer_address`. This procedure is to accept parameters for a customer identifier, a customer name, and address details. Its function is to verify the non-existence of the provided customer ID. Should the ID be absent, the procedure shall generate a new address identifier, insert a version of the address truncated to 255 bytes into the ADDRESSES table, and subsequently insert a new customer record utilizing the supplied identifier, name, and the generated address ID. All other columns within this new customer record are to be initialized with NULL values.",
    "id": 21,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `proc_create_customer_address` that accepts three input parameters: `p_customer_id` of type `NUMBER`, `p_customer_name` of type `VARCHAR2`, and `p_address_details` of type `VARCHAR2`. The procedure declares three local variables: `v_address_id` of type `NUMBER`, `v_customer_exists` of type `NUMBER`, and `v_truncated_address` of type `VARCHAR2(255)`. The execution begins by assigning a truncated version of the `p_address_details` parameter to the `v_truncated_address` variable. This truncation is performed using the `SUBSTRB` function, which extracts a substring of bytes from `p_address_details`, starting from the first byte and extending for a maximum of 255 bytes. Next, the procedure queries the `CUSTOMERS` table to determine if a customer with the provided `p_customer_id` already exists. It does this by performing a `SELECT COUNT(*)` operation, storing the count of matching rows into the `v_customer_exists` variable, where the `CUSTOMER_ID` column equals the `p_customer_id` parameter. Following this, a conditional block is executed: `IF v_customer_exists = 0 THEN`. This means the subsequent operations will only proceed if no customer with the given `p_customer_id` was found in the `CUSTOMERS` table. Inside this conditional block, the procedure first attempts to determine a new `ADDRESS_ID`. It does this by performing a `SELECT MAX(ADDRESS_ID) + 1` operation from the `ADDRESSES` table, storing the result into `v_address_id`. If the `v_address_id` obtained from this query is `NULL` (which would happen if the `ADDRESSES` table is empty), then `v_address_id` is explicitly set to `1`. After determining the `v_address_id`, the procedure performs an `INSERT` operation into the `ADDRESSES` table. It inserts a new row with the `ADDRESS_ID` column set to the value of `v_address_id` and the `ADDRESS_DETAILS` column set to the value of `v_truncated_address`. Immediately after this, another `INSERT` operation is performed, this time into the `CUSTOMERS` table. A new customer record is inserted with the `CUSTOMER_ID` column set to `p_customer_id`, the `ADDRESS_ID` column set to `v_address_id`, the `CUSTOMER_NAME` column set to `p_customer_name`, and the `CUSTOMER_ADDRESS` column set to `v_truncated_address`. The `CUSTOMER_PHONE`, `CUSTOMER_EMAIL`, `PAYMENT_METHOD_CODE`, and `CUSTOMER_NUMBER` columns are all explicitly set to `NULL` during this insertion. The conditional block then concludes."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named transfer_customer_data that accepts five parameters: p_source_customer_id and p_target_customer_id of type NUMBER, which represent the IDs of the source and target customers respectively; p_new_address_line, p_new_city, and p_new_zip of type VARCHAR2, which represent the new address line, city, and zip code for the target customer. The procedure begins by declaring a local variable v_max_address_id of type NUMBER to store the maximum address ID currently present in the ADDRESSES table. It then retrieves the maximum value of the ADDRESS_ID column from the ADDRESSES table and stores it in v_max_address_id. Next, the procedure inserts a new row into the ADDRESSES table with the ADDRESS_ID set to v_max_address_id plus one, LINE_1_NUMBER_BUILDING set to p_new_address_line, CITY set to p_new_city, ZIP_POSTCODE set to p_new_zip, STATE_PROVINCE_COUNTY set to 'Unknown', and COUNTRY set to 'USA'. Following this, the procedure deletes all rows from the CUSTOMER_PAYMENTS table where the CUSTOMER_ID matches p_source_customer_id. It then deletes the row from the CUSTOMERS table where the CUSTOMER_ID matches p_source_customer_id. Finally, the procedure inserts a new row into the CUSTOMER_PAYMENTS table with CUSTOMER_ID set to p_target_customer_id, DATETIME_PAYMENT set to '2023-10-10 10:10:10', PAYMENT_METHOD_CODE set to 'Transfer', and AMOUNT_PAYMENT set to 1000, using a SELECT statement from the DUAL table.",
    "plsql": "CREATE OR REPLACE PROCEDURE transfer_customer_data(\n    p_source_customer_id IN NUMBER,\n    p_target_customer_id IN NUMBER,\n    p_new_address_line IN VARCHAR2,\n    p_new_city IN VARCHAR2,\n    p_new_zip IN VARCHAR2\n)\nIS\n    v_max_address_id NUMBER;\nBEGIN\n    SELECT MAX(ADDRESS_ID) INTO v_max_address_id FROM ADDRESSES;\n    \n    INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY)\n    VALUES (v_max_address_id + 1, p_new_address_line, p_new_city, p_new_zip, 'Unknown', 'USA');\n    \n    DELETE FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = p_source_customer_id;\n    \n    DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = p_source_customer_id;\n    \n    INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT)\n    SELECT p_target_customer_id, '2023-10-10 10:10:10', 'Transfer', 1000 FROM DUAL;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "ADDRESSES"
    ],
    "call_sqls": [
      "BEGIN\n  transfer_customer_data(1, 3, '123 New Street', 'New City', '12345');\n  commit;\nEND;",
      "BEGIN\n  transfer_customer_data(3, 4, '456 Old Road', 'Old City', '67890');\n  commit;\nEND;",
      "BEGIN\n  transfer_customer_data(4, 1, '789 Main Ave', 'Main City', '11223');\n  commit;\nEND;",
      "BEGIN\n  transfer_customer_data(1, 4, '321 Side St', 'Side City', '44556');\n  commit;\nEND;",
      "BEGIN\n  transfer_customer_data(3, 1, '654 Back Ln', 'Back City', '77889');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named transfer_customer_data that transfers data from a source customer to a target customer. It accepts source and target customer IDs, and a new address (line, city, zip). The procedure generates a new address ID, inserts the new address into the ADDRESSES table with default state and country, deletes the source customer's payment records and the customer record, and inserts a default payment record for the target customer.",
    "natural_language": "Create a comprehensive stored procedure named transfer_customer_data that meticulously handles the transfer of all relevant data from a specified source customer to a designated target customer. This procedure must gracefully accept the unique identifiers for both the source and target customers, along with a complete new address comprising the street line, the city, and the postal zip code. Internally, it will first generate a fresh, unique address identifier. Subsequently, it will insert the provided new address details into the ADDRESSES table, thoughtfully applying default values for the state and country fields. Following this, it will permanently remove all existing payment records associated with the source customer and then delete the source customer's main record itself. Finally, to ensure continuity, the procedure will insert a single, standardized default payment record specifically for the identified target customer.",
    "id": 22,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named transfer_customer_data that accepts five parameters: p_source_customer_id and p_target_customer_id of type NUMBER, which represent the IDs of the source and target customers respectively; p_new_address_line, p_new_city, and p_new_zip of type VARCHAR2, which represent the new address line, city, and zip code for the target customer. The procedure begins by declaring a local variable v_max_address_id of type NUMBER to store the maximum address ID currently present in the ADDRESSES table. It then retrieves the maximum value of the ADDRESS_ID column from the ADDRESSES table and stores it in v_max_address_id. Next, the procedure inserts a new row into the ADDRESSES table with the ADDRESS_ID set to v_max_address_id plus one, LINE_1_NUMBER_BUILDING set to p_new_address_line, CITY set to p_new_city, ZIP_POSTCODE set to p_new_zip, STATE_PROVINCE_COUNTY set to 'Unknown', and COUNTRY set to 'USA'. Following this, the procedure deletes all rows from the CUSTOMER_PAYMENTS table where the CUSTOMER_ID matches p_source_customer_id. It then deletes the row from the CUSTOMERS table where the CUSTOMER_ID matches p_source_customer_id. Finally, the procedure inserts a new row into the CUSTOMER_PAYMENTS table with CUSTOMER_ID set to p_target_customer_id, DATETIME_PAYMENT set to '2023-10-10 10:10:10', PAYMENT_METHOD_CODE set to 'Transfer', and AMOUNT_PAYMENT set to 1000, using a SELECT statement from the DUAL table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp1` that accepts three input parameters: `para_title` of type `VARCHAR2`, `para_type` of type `VARCHAR2`, and `para_rating` of type `NUMBER`. The procedure's logic is controlled by a conditional statement that evaluates the value of `para_rating`. If the value of `para_rating` is strictly greater than 5, the procedure executes a `DELETE` operation. This `DELETE` operation targets rows in the `REVIEW` table where two conditions are met: first, the `RATING` column's value is less than the value provided in `para_rating`, and second, the `BOOK_ID` column's value matches the `BOOK_ID` retrieved from the `BOOK` table. The `BOOK_ID` for this second condition is determined by a subquery that selects the `BOOK_ID` from the `BOOK` table where the `TITLE` column's value is equal to the `para_title` parameter. If the value of `para_rating` is not strictly greater than 5 (i.e., it is less than or equal to 5), the procedure executes an `INSERT` operation into the `REVIEW` table. This `INSERT` operation populates the `REVIEW_ID`, `BOOK_ID`, `RATING`, `READERS_IN_MILLION`, and `RANK` columns. The `REVIEW_ID` is generated by a subquery that calculates the next available `REVIEW_ID` by selecting the maximum existing `REVIEW_ID` from the `REVIEW` table, using the `NVL` function to treat a `NULL` result (meaning no existing `REVIEW_ID`s) as 0, and then adding 1 to that result. The `BOOK_ID` is obtained by a subquery that selects the `BOOK_ID` from the `BOOK` table where the `TITLE` column's value matches the `para_title` parameter. The `RATING` column is populated with the value of the `para_rating` parameter. The `READERS_IN_MILLION` column is set to a fixed value of `1.0`. The `RANK` column is set to a fixed value of `10`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp1(para_title VARCHAR2, para_type VARCHAR2, para_rating NUMBER) IS\nBEGIN\n  IF para_rating > 5 THEN\n    DELETE FROM REVIEW WHERE RATING < para_rating AND BOOK_ID = (SELECT BOOK_ID FROM BOOK WHERE TITLE = para_title);\n  ELSE\n    INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (\n      (SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW),\n      (SELECT BOOK_ID FROM BOOK WHERE TITLE = para_title),\n      para_rating,\n      1.0,\n      10\n    );\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp1('A Game of Thrones', 'Novel', 6);\n  commit;\nEND;",
      "BEGIN\n  sp1('A Clash of Kings', 'Novel', 4);\n  commit;\nEND;",
      "BEGIN\n  sp1('A Storm of Swords', 'Novel', 7);\n  commit;\nEND;",
      "BEGIN\n  sp1('A Game of Thrones', 'Novel', 3);\n  commit;\nEND;",
      "BEGIN\n  sp1('A Clash of Kings', 'Novel', 8);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp1 that conditionally modifies the REVIEW table. If the input rating is greater than 5, delete reviews with a lower rating for a book matching the input title. Otherwise, insert a new review for that book with the input rating, a fixed readers value of 1.0, and a fixed rank of 10. Generate the new REVIEW_ID automatically.",
    "natural_language": "Make a stored procedure called sp1 that handles the REVIEW table in a conditional way. If the provided rating seems on the higher side, get rid of some of the less favorable reviews for a book with a title like the one given. Otherwise, just add a new review entry for that book using the provided rating, setting readers to a typical value like 1.0 and rank to something around 10. The REVIEW_ID should be created automatically.",
    "id": 23,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp1` that operates on the `book_review` database. The procedure accepts two input parameters: `p_title` of type `VARCHAR2` to specify a book title pattern, and `p_rating` of type `NUMBER` to specify a rating value. The procedure declares two local variables: `v_book_id` of type `NUMBER` to store a book ID, and `v_new_review_id` of type `NUMBER` to store a new review ID.\n\nThe procedure begins by performing a `SELECT` statement to retrieve the `BOOK_ID` from the `BOOK` table where the `TITLE` column matches the pattern provided in `p_title` using the `LIKE` operator. The result is stored in `v_book_id`. If no book is found, `v_book_id` remains `NULL`.\n\nNext, the procedure implements conditional logic based on the value of `p_rating`. If `p_rating` is greater than or equal to 7.0 (considered \"on the higher side\"), it performs a `DELETE` operation on the `REVIEW` table. The deletion targets rows where the `BOOK_ID` equals `v_book_id` and the `RATING` is less than 5.0 (considered \"less favorable reviews\"). This removes lower-rated reviews for the identified book.\n\nIf `p_rating` is less than 7.0, the procedure performs an `INSERT` operation into the `REVIEW` table. First, it generates a new `REVIEW_ID` by selecting the maximum `REVIEW_ID` from the `REVIEW` table, using `NVL` to treat a `NULL` result as 0, and adding 1 to it. This new ID is stored in `v_new_review_id`. Then, it inserts a new row with the following values:\n- `REVIEW_ID`: `v_new_review_id`\n- `BOOK_ID`: `v_book_id`\n- `RATING`: `p_rating`\n- `READERS_IN_MILLION`: 1.0 (a typical value)\n- `RANK`: 10 (a value around 10)\n\nIf `v_book_id` is `NULL` (i.e., no matching book is found), the procedure does not perform any `DELETE` or `INSERT` operations and exits without action. The procedure does not return a value; it executes the conditional database operations as described."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_student_likes that accepts two input parameters: p_student_id of type NUMBER and p_liked_id of type NUMBER. The procedure first declares two local NUMBER variables, v_student_exists and v_liked_exists. It begins execution by querying the HIGHSCHOOLER table to count rows where the ID column equals p_student_id, storing the result in v_student_exists, and then performs another query on the same table to count rows where the ID column equals p_liked_id, storing that result in v_liked_exists. The procedure then uses an IF-THEN-ELSE conditional block: if both v_student_exists and v_liked_exists are greater than zero, meaning both provided IDs exist in the HIGHSCHOOLER table, it performs a MERGE operation into the LIKES table (aliased as L). The MERGE uses a source subquery selecting the input parameters as STUDENT_ID and LIKED_ID from the DUAL table (aliased as S) and matches on the condition that L.STUDENT_ID equals S.STUDENT_ID and L.LIKED_ID equals S.LIKED_ID; when no matching row is found in the target LIKES table, it inserts a new row using the source's STUDENT_ID and LIKED_ID values. If the initial condition is not met (meaning at least one of the provided IDs does not exist in HIGHSCHOOLER), the ELSE branch executes a DELETE statement on the LIKES table, removing any rows where the STUDENT_ID column equals p_student_id or the LIKED_ID column equals p_liked_id. Following this, the procedure executes a second, independent IF-THEN-ELSE block that checks only if v_student_exists is greater than zero. If true, it performs another MERGE operation, this time into the FRIEND table (aliased as F). This MERGE uses a source subquery selecting p_student_id as STUDENT_ID and p_liked_id as FRIEND_ID from DUAL (aliased as S) and matches on the condition F.STUDENT_ID equals S.STUDENT_ID and F.FRIEND_ID equals S.FRIEND_ID; when no match is found, it inserts a new row with the source's STUDENT_ID and FRIEND_ID values. If v_student_exists is not greater than zero, the ELSE branch executes a DELETE statement on the FRIEND table, removing any rows where the STUDENT_ID column equals p_student_id or the FRIEND_ID column equals p_liked_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_student_likes(\n    p_student_id IN NUMBER,\n    p_liked_id IN NUMBER\n) IS\n    v_student_exists NUMBER;\n    v_liked_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_student_exists FROM HIGHSCHOOLER WHERE ID = p_student_id;\n    SELECT COUNT(*) INTO v_liked_exists FROM HIGHSCHOOLER WHERE ID = p_liked_id;\n\n    IF v_student_exists > 0 AND v_liked_exists > 0 THEN\n        MERGE INTO LIKES L\n        USING (SELECT p_student_id AS STUDENT_ID, p_liked_id AS LIKED_ID FROM DUAL) S\n        ON (L.STUDENT_ID = S.STUDENT_ID AND L.LIKED_ID = S.LIKED_ID)\n        WHEN NOT MATCHED THEN\n            INSERT (STUDENT_ID, LIKED_ID) VALUES (S.STUDENT_ID, S.LIKED_ID);\n    ELSE\n        DELETE FROM LIKES WHERE STUDENT_ID = p_student_id OR LIKED_ID = p_liked_id;\n    END IF;\n\n    IF v_student_exists > 0 THEN\n        MERGE INTO FRIEND F\n        USING (SELECT p_student_id AS STUDENT_ID, p_liked_id AS FRIEND_ID FROM DUAL) S\n        ON (F.STUDENT_ID = S.STUDENT_ID AND F.FRIEND_ID = S.FRIEND_ID)\n        WHEN NOT MATCHED THEN\n            INSERT (STUDENT_ID, FRIEND_ID) VALUES (S.STUDENT_ID, S.FRIEND_ID);\n    ELSE\n        DELETE FROM FRIEND WHERE STUDENT_ID = p_student_id OR FRIEND_ID = p_liked_id;\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "BEGIN\n  manage_student_likes(1510, 1689);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_student_likes(1381, 1510);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_student_likes(1247, 1101);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_student_likes(9999, 1510);\n  COMMIT;\nEND;",
      "BEGIN\n  manage_student_likes(1510, 9999);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named manage_student_likes that accepts a student ID and a liked ID. Check if both IDs exist in the HIGHSCHOOLER table. If they do, insert a like relationship into the LIKES table if it doesn't already exist. If at least one ID does not exist, delete any likes involving either ID. Then, if the student ID exists, insert a friend relationship into the FRIEND table if it doesn't already exist. If the student ID does not exist, delete any friend relationships involving either ID.",
    "natural_language": "Create procedure manage_student_likes with student ID and liked ID. If both IDs are in HIGHSCHOOLER, add to LIKES if new. Otherwise, delete their likes. If student ID exists, add to FRIENDS if new. Otherwise, delete their friends.",
    "id": 24,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named manage_student_likes that accepts two input parameters: p_student_id of type NUMBER and p_liked_id of type NUMBER. The procedure first declares two local NUMBER variables, v_student_exists and v_liked_exists. It begins execution by querying the HIGHSCHOOLER table to count rows where the ID column equals p_student_id, storing the result in v_student_exists, and then performs another query on the same table to count rows where the ID column equals p_liked_id, storing that result in v_liked_exists. The procedure then uses an IF-THEN-ELSE conditional block: if both v_student_exists and v_liked_exists are greater than zero, meaning both provided IDs exist in the HIGHSCHOOLER table, it performs a MERGE operation into the LIKES table (aliased as L). The MERGE uses a source subquery selecting the input parameters as STUDENT_ID and LIKED_ID from the DUAL table (aliased as S) and matches on the condition that L.STUDENT_ID equals S.STUDENT_ID and L.LIKED_ID equals S.LIKED_ID; when no matching row is found in the target LIKES table, it inserts a new row using the source's STUDENT_ID and LIKED_ID values. If the initial condition is not met (meaning at least one of the provided IDs does not exist in HIGHSCHOOLER), the ELSE branch executes a DELETE statement on the LIKES table, removing any rows where the STUDENT_ID column equals p_student_id or the LIKED_ID column equals p_liked_id. Following this, the procedure executes a second, independent IF-THEN-ELSE block that checks only if v_student_exists is greater than zero. If true, it performs another MERGE operation, this time into the FRIEND table (aliased as F). This MERGE uses a source subquery selecting p_student_id as STUDENT_ID and p_liked_id as FRIEND_ID from DUAL (aliased as S) and matches on the condition F.STUDENT_ID equals S.STUDENT_ID and F.FRIEND_ID equals S.FRIEND_ID; when no match is found, it inserts a new row with the source's STUDENT_ID and FRIEND_ID values. If v_student_exists is not greater than zero, the ELSE branch executes a DELETE statement on the FRIEND table, removing any rows where the STUDENT_ID column equals p_student_id or the FRIEND_ID column equals p_liked_id."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp5` that accepts four input parameters: `para_SONGID` of type `NUMBER`, `para_BANDMATE` of type `NUMBER`, `para_TYPE` of type `VARCHAR2`, and `para_TITLE` of type `VARCHAR2`. The purpose of this procedure is to manage song and vocal records based on the existence of vocal entries for a given song.\n\nThe procedure begins by declaring two local variables: `v_vocal_count` of type `NUMBER` to store the count of vocal records, and `v_new_title` of type `VARCHAR2(255)` to store a newly generated song title.\n\nFirst, the procedure executes a `SELECT` statement to count the number of records in the `VOCALS` table where the `SONGID` column matches the input parameter `para_SONGID`. The result of this count is stored in the `v_vocal_count` variable.\n\nNext, it constructs a new song title by concatenating the current date formatted as 'YYYYMMDD' (e.g., '20231027') with an underscore character `_` and the input parameter `para_TITLE`. This new title is assigned to the `v_new_title` variable using the `TO_CHAR` function with `CURRENT_DATE`.\n\nFollowing this, the procedure enters a conditional block (`IF v_vocal_count > 0 THEN`).\n\nIf `v_vocal_count` is greater than 0, indicating that vocal records already exist for the `para_SONGID` in the `VOCALS` table, the procedure executes an `UPDATE` statement on the `SONGS` table. This `UPDATE` statement sets the `TITLE` column to the value stored in `v_new_title` for the row where the `SONGID` column matches the input parameter `para_SONGID`.\n\nIf `v_vocal_count` is not greater than 0 (i.e., it is 0), indicating that no vocal records exist for the `para_SONGID` in the `VOCALS` table, the procedure executes a `MERGE INTO` statement on the `SONGS` table. This `MERGE` statement uses a `DUAL` table subquery to provide the `para_SONGID` as `SONGID` and `para_TITLE` as `TITLE` for comparison. The `MERGE` operation attempts to match records in the `SONGS` table (`s`) with the provided `SONGID` from the `DUAL` source (`d`) using the condition `s.SONGID = d.SONGID`. If a match is `NOT MATCHED` (meaning no song with `para_SONGID` exists in the `SONGS` table), an `INSERT` operation is performed into the `SONGS` table, inserting the `SONGID` from `d.SONGID` (which is `para_SONGID`) and the `TITLE` from `d.TITLE` (which is `para_TITLE`). This ensures that a parent record for the song exists in the `SONGS` table before attempting to insert a vocal record.\n\nAfter the `MERGE` statement (which guarantees the existence of the song in the `SONGS` table), the procedure then executes an `INSERT` statement into the `VOCALS` table. This `INSERT` statement adds a new vocal record with the `SONGID` set to `para_SONGID`, the `BANDMATE` set to `para_BANDMATE`, and the `TYPE` set to `para_TYPE`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp5(para_SONGID NUMBER, para_BANDMATE NUMBER, para_TYPE VARCHAR2, para_TITLE VARCHAR2) IS\n  v_vocal_count NUMBER;\n  v_new_title VARCHAR2(255);\nBEGIN\n  SELECT COUNT(*) INTO v_vocal_count FROM VOCALS WHERE SONGID = para_SONGID;\n  v_new_title := TO_CHAR(CURRENT_DATE, 'YYYYMMDD') || '_' || para_TITLE;\n\n  IF v_vocal_count > 0 THEN\n    -- If vocals exist for the song, update the song's title.\n    -- Deleting and re-inserting SONGS would violate foreign key constraints\n    -- with INSTRUMENTS, PERFORMANCE, and VOCALS if child records exist.\n    UPDATE SONGS\n    SET TITLE = v_new_title\n    WHERE SONGID = para_SONGID;\n  ELSE\n    -- If no vocals exist, first ensure the song exists in SONGS,\n    -- then insert the new vocal record.\n    -- Check if the song already exists to avoid primary key violation on SONGS.\n    MERGE INTO SONGS s\n    USING (SELECT para_SONGID AS SONGID, para_TITLE AS TITLE FROM DUAL) d\n    ON (s.SONGID = d.SONGID)\n    WHEN NOT MATCHED THEN\n      INSERT (SONGID, TITLE) VALUES (d.SONGID, d.TITLE);\n\n    -- Now insert into VOCALS, as the parent record in SONGS is guaranteed to exist.\n    INSERT INTO VOCALS (SONGID, BANDMATE, TYPE) VALUES (para_SONGID, para_BANDMATE, para_TYPE);\n  END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "BEGIN\n  sp5(para_SONGID => 101, para_BANDMATE => 1, para_TYPE => 'Lead', para_TITLE => 'New Song Title One');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(para_SONGID => 102, para_BANDMATE => 2, para_TYPE => 'Backing', para_TITLE => 'Another Song');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(para_SONGID => 101, para_BANDMATE => 3, para_TYPE => 'Harmony', para_TITLE => 'Updated Song Title');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(para_SONGID => 103, para_BANDMATE => 4, para_TYPE => 'Lead', para_TITLE => 'Brand New Track');\n  COMMIT;\nEND;",
      "BEGIN\n  sp5(para_SONGID => 104, para_BANDMATE => 5, para_TYPE => 'Backing', para_TITLE => 'Fifth Song');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `sp5` with parameters `para_SONGID` (NUMBER), `para_BANDMATE` (NUMBER), `para_TYPE` (VARCHAR2), and `para_TITLE` (VARCHAR2). Count the vocal records for the song. If vocals exist, update the song's title to a new title formatted as 'YYYYMMDD_TITLE'. If no vocals exist, ensure the song exists in the SONGS table using a MERGE operation (insert if not present), then insert a new record into the VOCALS table.",
    "natural_language": "How can I create a stored procedure named `sp5` that takes parameters `para_SONGID` (NUMBER), `para_BANDMATE` (NUMBER), `para_TYPE` (VARCHAR2), and `para_TITLE` (VARCHAR2), counts the vocal records for the specified song, and then updates the song's title to a 'YYYYMMDD_TITLE' format if vocals exist, or uses a MERGE to ensure the song exists and inserts a new vocal record if no vocals are found?",
    "id": 25,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp5` that accepts four input parameters: `para_SONGID` of type `NUMBER`, `para_BANDMATE` of type `NUMBER`, `para_TYPE` of type `VARCHAR2`, and `para_TITLE` of type `VARCHAR2`. The purpose of this procedure is to manage song and vocal records based on the existence of vocal entries for a given song.\n\nThe procedure begins by declaring two local variables: `v_vocal_count` of type `NUMBER` to store the count of vocal records, and `v_new_title` of type `VARCHAR2(255)` to store a newly generated song title.\n\nFirst, the procedure executes a `SELECT` statement to count the number of records in the `VOCALS` table where the `SONGID` column matches the input parameter `para_SONGID`. The result of this count is stored in the `v_vocal_count` variable.\n\nNext, it constructs a new song title by concatenating the current date formatted as 'YYYYMMDD' (e.g., '20231027') with an underscore character `_` and the input parameter `para_TITLE`. This new title is assigned to the `v_new_title` variable using the `TO_CHAR` function with `CURRENT_DATE`.\n\nFollowing this, the procedure enters a conditional block (`IF v_vocal_count > 0 THEN`).\n\nIf `v_vocal_count` is greater than 0, indicating that vocal records already exist for the `para_SONGID` in the `VOCALS` table, the procedure executes an `UPDATE` statement on the `SONGS` table. This `UPDATE` statement sets the `TITLE` column to the value stored in `v_new_title` for the row where the `SONGID` column matches the input parameter `para_SONGID`.\n\nIf `v_vocal_count` is not greater than 0 (i.e., it is 0), indicating that no vocal records exist for the `para_SONGID` in the `VOCALS` table, the procedure executes a `MERGE INTO` statement on the `SONGS` table. This `MERGE` statement uses a `DUAL` table subquery to provide the `para_SONGID` as `SONGID` and `para_TITLE` as `TITLE` for comparison. The `MERGE` operation attempts to match records in the `SONGS` table (`s`) with the provided `SONGID` from the `DUAL` source (`d`) using the condition `s.SONGID = d.SONGID`. If a match is `NOT MATCHED` (meaning no song with `para_SONGID` exists in the `SONGS` table), an `INSERT` operation is performed into the `SONGS` table, inserting the `SONGID` from `d.SONGID` (which is `para_SONGID`) and the `TITLE` from `d.TITLE` (which is `para_TITLE`). This ensures that a parent record for the song exists in the `SONGS` table before attempting to insert a vocal record.\n\nAfter the `MERGE` statement (which guarantees the existence of the song in the `SONGS` table), the procedure then executes an `INSERT` statement into the `VOCALS` table. This `INSERT` statement adds a new vocal record with the `SONGID` set to `para_SONGID`, the `BANDMATE` set to `para_BANDMATE`, and the `TYPE` set to `para_TYPE`."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_service_participant_count that accepts a single parameter, para_service_type, of type VARCHAR2, which represents the service type code to be used in the procedure's logic. The procedure begins by declaring a local variable v_participant_count of type NUMBER to store the count of participants associated with the specified service type. It then executes a SELECT statement to count the number of participants who are linked to events that are associated with services matching the provided service type code. This is achieved by joining the PARTICIPANTS table with the PARTICIPANTS_IN_EVENTS table on the PARTICIPANT_ID column, then joining the resulting set with the EVENTS table on the EVENT_ID column, and finally joining with the SERVICES table on the SERVICE_ID column. The WHERE clause filters the results to include only those rows where the SERVICE_TYPE_CODE column in the SERVICES table, converted to uppercase using the UPPER() function, matches the uppercase version of the para_service_type parameter. The count result is stored in the v_participant_count variable. Following the SELECT operation, the procedure checks if the value of v_participant_count is less than 5 using an IF conditional statement. If this condition is true, the procedure performs an INSERT operation into the PARTICIPANTS table, adding a new row with a PARTICIPANT_ID value that is one greater than the current maximum PARTICIPANT_ID in the table, or 1 if the table is empty, determined using a subquery with the COALESCE() function. The new row is assigned a PARTICIPANT_TYPE_CODE of 'Volunteer' and PARTICIPANT_DETAILS of 'New Volunteer'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_service_participant_count(para_service_type VARCHAR2) IS\n   v_participant_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_participant_count\n   FROM PARTICIPANTS p\n   JOIN PARTICIPANTS_IN_EVENTS pie ON p.PARTICIPANT_ID = pie.PARTICIPANT_ID\n   JOIN EVENTS e ON pie.EVENT_ID = e.EVENT_ID\n   JOIN SERVICES s ON e.SERVICE_ID = s.SERVICE_ID\n   WHERE UPPER(s.SERVICE_TYPE_CODE) = UPPER(para_service_type);\n   \n   IF v_participant_count < 5 THEN\n      INSERT INTO PARTICIPANTS (PARTICIPANT_ID, PARTICIPANT_TYPE_CODE, PARTICIPANT_DETAILS)\n      VALUES ((SELECT COALESCE(MAX(PARTICIPANT_ID),0)+1 FROM PARTICIPANTS), 'Volunteer', 'New Volunteer');\n   END IF;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_service_participant_count('Marriage');\n  commit;\nEND;",
      "BEGIN\n  sp_service_participant_count('Death Proof');\n  commit;\nEND;",
      "BEGIN\n  sp_service_participant_count('Birth Proof');\n  commit;\nEND;",
      "BEGIN\n  sp_service_participant_count('Education');\n  commit;\nEND;",
      "BEGIN\n  sp_service_participant_count('Health');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_service_participant_count that accepts a VARCHAR2 parameter para_service_type. Count participants linked to events of that service type (case-insensitive). If the count is less than 5, insert a new 'Volunteer' participant into the PARTICIPANTS table with an ID one greater than the current maximum.",
    "natural_language": "Please construct a stored procedure designated as sp_service_participant_count, which shall accept a single VARCHAR2 input parameter named para_service_type. The procedure is to compute the total number of participants associated with events corresponding to the specified service type, disregarding case sensitivity. Should the resultant count be fewer than five, the procedure must then insert a new participant record into the PARTICIPANTS table. This new record shall be of the type 'Volunteer' and shall be assigned an ID value that is one greater than the current maximum ID present in the table.",
    "id": 26,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_service_participant_count that accepts one input parameter: para_service_type of type VARCHAR2, representing a service type code. The procedure begins by declaring a local variable v_participant_count of type NUMBER to store the total count of participants, and v_max_participant_id of type NUMBER to store the maximum participant ID. The procedure first computes the total number of participants associated with events for the specified service type by performing a SELECT COUNT(DISTINCT PARTICIPANTS_IN_EVENTS.PARTICIPANT_ID) INTO v_participant_count from the PARTICIPANTS_IN_EVENTS table. It joins with the EVENTS table on PARTICIPANTS_IN_EVENTS.EVENT_ID = EVENTS.EVENT_ID, and then joins with the SERVICES table on EVENTS.SERVICE_ID = SERVICES.SERVICE_ID. The join condition includes a WHERE clause that uses UPPER(SERVICES.SERVICE_TYPE_CODE) = UPPER(para_service_type) to ensure case-insensitive matching. After obtaining the count, the procedure checks if v_participant_count is less than 5. If true, it retrieves the maximum PARTICIPANT_ID from the PARTICIPANTS table using SELECT MAX(PARTICIPANT_ID) INTO v_max_participant_id. If the maximum ID is NULL (indicating no existing participants), it sets v_max_participant_id to 0. It then calculates the new participant ID as v_max_participant_id + 1. The procedure inserts a new record into the PARTICIPANTS table with the following values: PARTICIPANT_ID set to the calculated new ID, PARTICIPANT_TYPE_CODE set to 'Volunteer', and PARTICIPANT_DETAILS set to NULL (or an empty string, as not specified). If the count is 5 or greater, no insertion occurs. The procedure does not return any value but performs the insertion conditionally based on the computed participant count."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_proc3 that accepts two input parameters: a numeric parameter p_location_id and a string parameter p_new_city. The procedure begins by executing three separate SELECT COUNT(*) queries. The first query counts the number of rows in the DEPARTMENTS table where the LOCATION_ID column matches the input p_location_id, storing the result in variable v_dept_count. The second query counts the number of rows in the EMPLOYEES table where the DEPARTMENT_ID is found in the set of DEPARTMENT_ID values from the DEPARTMENTS table for rows with the specified LOCATION_ID, storing the result in variable v_emp_count. The third query counts the number of rows in the JOBS table where the JOB_ID is found in the set of JOB_ID values from the EMPLOYEES table for employees whose DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table for the specified LOCATION_ID, storing the result in variable v_job_count.\n\nFollowing these counts, the procedure uses an IF-ELSIF-ELSE conditional block. If v_dept_count is greater than 5, it executes an UPDATE statement on the LOCATIONS table, setting the CITY column to the value of p_new_city for the row where LOCATION_ID equals p_location_id. Otherwise, if v_emp_count is greater than 20, it executes a DELETE statement on the DEPARTMENTS table, removing all rows where LOCATION_ID equals p_location_id. If neither condition is true, it executes an INSERT statement into the DEPARTMENTS table, specifying columns DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, and LOCATION_ID. The value for DEPARTMENT_ID is derived from a subquery that calculates the maximum existing DEPARTMENT_ID plus one, DEPARTMENT_NAME is set to the literal string 'New Department', MANAGER_ID is set to NULL, and LOCATION_ID is set to the input p_location_id.\n\nSubsequently, the procedure uses a second IF-ELSE conditional block based on the v_job_count variable. If v_job_count is greater than 10, it executes an UPDATE statement on the JOBS table, setting the JOB_TITLE column to the literal string 'Updated Job' for rows where the JOB_ID is in the set of JOB_ID values from the EMPLOYEES table for employees whose DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table for the specified LOCATION_ID. If v_job_count is 10 or less, it executes a DELETE statement on the JOB_HISTORY table, removing rows where the DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table for the specified LOCATION_ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_proc3(p_location_id NUMBER, p_new_city VARCHAR2) IS\n  v_dept_count NUMBER;\n  v_emp_count NUMBER;\n  v_job_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_dept_count FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id;\n  SELECT COUNT(*) INTO v_emp_count FROM EMPLOYEES WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id);\n  SELECT COUNT(*) INTO v_job_count FROM JOBS WHERE JOB_ID IN (SELECT JOB_ID FROM EMPLOYEES WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id));\n  \n  IF v_dept_count > 5 THEN\n    UPDATE LOCATIONS SET CITY = p_new_city WHERE LOCATION_ID = p_location_id;\n  ELSIF v_emp_count > 20 THEN\n    DELETE FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id;\n  ELSE\n    INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID) VALUES ((SELECT MAX(DEPARTMENT_ID)+1 FROM DEPARTMENTS), 'New Department', NULL, p_location_id);\n  END IF;\n  \n  IF v_job_count > 10 THEN\n    UPDATE JOBS SET JOB_TITLE = 'Updated Job' WHERE JOB_ID IN (SELECT JOB_ID FROM EMPLOYEES WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id));\n  ELSE\n    DELETE FROM JOB_HISTORY WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = p_location_id);\n  END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_proc3(1700, 'New York');\n  commit;\nEND;",
      "BEGIN\n  sp_proc3(1800, 'Los Angeles');\n  commit;\nEND;",
      "BEGIN\n  sp_proc3(1000, 'Chicago');\n  commit;\nEND;",
      "BEGIN\n  sp_proc3(1100, 'Houston');\n  commit;\nEND;",
      "BEGIN\n  sp_proc3(1200, 'Phoenix');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_proc3 that accepts a location ID and a new city. Count departments at that location, employees in those departments, and jobs held by those employees. If the department count exceeds 5, update the location's city. Else, if the employee count exceeds 20, delete departments at that location. Otherwise, insert a new department. Then, if the job count exceeds 10, update those job titles. Otherwise, delete related job history records.",
    "natural_language": "What stored procedure, named sp_proc3, can be created to accept a location ID and a new city, count the departments at that location, the employees in those departments, and the jobs held by those employees, and then, if the department count exceeds 5, update the location's city, or else if the employee count exceeds 20, delete departments at that location, or otherwise insert a new department, and subsequently, if the job count exceeds 10, update those job titles, or otherwise delete the related job history records?",
    "id": 27,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_proc3 that accepts two input parameters: p_location_id of type NUMBER to identify a specific location, and p_new_city of type VARCHAR2 to specify a new city name. The procedure declares three local variables: v_dept_count of type NUMBER to store the count of departments at the given location, v_emp_count of type NUMBER to store the count of employees in those departments, and v_job_count of type NUMBER to store the count of distinct jobs held by those employees. The procedure first initializes all three variables to 0.\n\nThe procedure then performs a SELECT statement to count the number of departments from the DEPARTMENTS table where the LOCATION_ID column matches the input parameter p_location_id, storing the result in v_dept_count. Next, it performs another SELECT statement to count the number of employees from the EMPLOYEES table where the DEPARTMENT_ID is in the set of DEPARTMENT_ID values retrieved from a subquery that selects DEPARTMENT_ID from the DEPARTMENTS table where LOCATION_ID equals p_location_id, storing the result in v_emp_count. Then, it performs a third SELECT statement to count the number of distinct JOB_ID values from the EMPLOYEES table where the DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table where LOCATION_ID equals p_location_id, storing the result in v_job_count.\n\nThe procedure uses a conditional IF-ELSIF-ELSE statement to handle three scenarios based on v_dept_count. If v_dept_count is greater than 5, it executes an UPDATE operation on the LOCATIONS table, setting the CITY column to the value of p_new_city for the row where LOCATION_ID equals p_location_id. Otherwise, if v_emp_count is greater than 20, it executes a DELETE operation on the DEPARTMENTS table, removing all rows where LOCATION_ID equals p_location_id. Otherwise, if neither condition is met, it executes an INSERT operation into the DEPARTMENTS table, inserting a new row with a DEPARTMENT_ID generated by selecting the maximum existing DEPARTMENT_ID from the DEPARTMENTS table and adding 1, a DEPARTMENT_NAME set to 'New Department', a MANAGER_ID set to NULL, and a LOCATION_ID set to p_location_id.\n\nFollowing this, the procedure uses another conditional IF-ELSE statement to handle two scenarios based on v_job_count. If v_job_count is greater than 10, it executes an UPDATE operation on the JOBS table, setting the JOB_TITLE column to 'Updated Title' for rows where JOB_ID is in the set of distinct JOB_ID values retrieved from a subquery that selects distinct JOB_ID from the EMPLOYEES table where DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table where LOCATION_ID equals p_location_id. Otherwise, if v_job_count is 10 or less, it executes a DELETE operation on the JOB_HISTORY table, removing all rows where EMPLOYEE_ID is in the set of EMPLOYEE_ID values retrieved from a subquery that selects EMPLOYEE_ID from the EMPLOYEES table where DEPARTMENT_ID is in the set of DEPARTMENT_ID values from the DEPARTMENTS table where LOCATION_ID equals p_location_id.\n\nThe procedure does not return a value but performs the described database operations based on the counts and conditions."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named MODIFY_ARCHITECT_RECORDS that accepts two input parameters: a string parameter P_NATIONALITY of type VARCHAR2, which specifies a nationality to filter architect records, and a string parameter P_NAME_SUFFIX of type VARCHAR2, which provides a text suffix to be appended to names. The procedure begins by declaring three local NUMBER variables: V_ARCHITECT_COUNT, V_AVG_NAME_LENGTH, and V_NATIONALITY_COUNT. It first executes a SELECT statement to count the total number of rows in the ARCHITECT table where the NATIONALITY column exactly matches the input P_NATIONALITY, storing the result in V_ARCHITECT_COUNT. It then executes a second SELECT statement to calculate the average character length of all values in the NAME column of the ARCHITECT table, storing the result in V_AVG_NAME_LENGTH. A third SELECT statement counts the number of distinct values present in the NATIONALITY column across the entire ARCHITECT table, storing the result in V_NATIONALITY_COUNT. The core logic uses a conditional IF-ELSIF-ELSE block. If the value of V_ARCHITECT_COUNT is greater than 5, the procedure performs an UPDATE operation on the ARCHITECT table, setting the NAME column to its current value concatenated with a single space and then the input P_NAME_SUFFIX, but only for rows where the NATIONALITY column equals P_NATIONALITY. If the first condition is false and V_AVG_NAME_LENGTH is greater than 12, the procedure executes a DELETE operation on the ARCHITECT table, removing rows where the character length of the NAME column is greater than the calculated V_AVG_NAME_LENGTH and the NATIONALITY column equals P_NATIONALITY. If neither of the first two conditions is met, the procedure enters a nested IF-ELSE block. Within this block, if V_NATIONALITY_COUNT is greater than 3, an INSERT operation is performed on the ARCHITECT table, adding a new row with specific values: the ID column is set to the string 'MOD_' concatenated with the current system date and time formatted as 'YYYYMMDDHH24MISS' using the TO_CHAR function with SYSDATE, the NAME column is set to the input P_NAME_SUFFIX concatenated with the string ' Diverse', the NATIONALITY column is set to 'Multinational', and the GENDER column is set to 'female'. If V_NATIONALITY_COUNT is 3 or less, a DELETE operation is executed on the ARCHITECT table, removing rows where the NATIONALITY value is not found in the list of distinct nationalities limited to the first two distinct nationalities retrieved by the subquery `SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2`.",
    "plsql": "CREATE OR REPLACE PROCEDURE modify_architect_records(\n    p_nationality VARCHAR2,\n    p_name_suffix VARCHAR2\n) IS\n    v_architect_count NUMBER;\n    v_avg_name_length NUMBER;\n    v_nationality_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_architect_count FROM ARCHITECT WHERE NATIONALITY = p_nationality;\n    SELECT AVG(LENGTH(NAME)) INTO v_avg_name_length FROM ARCHITECT;\n    SELECT COUNT(DISTINCT NATIONALITY) INTO v_nationality_count FROM ARCHITECT;\n    \n    IF v_architect_count > 5 THEN\n        UPDATE ARCHITECT SET NAME = NAME || ' ' || p_name_suffix WHERE NATIONALITY = p_nationality;\n    ELSIF v_avg_name_length > 12 THEN\n        DELETE FROM ARCHITECT WHERE LENGTH(NAME) > v_avg_name_length AND NATIONALITY = p_nationality;\n    ELSE\n        IF v_nationality_count > 3 THEN\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('MOD_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_suffix || ' Diverse', 'Multinational', 'female');\n        ELSE\n            DELETE FROM ARCHITECT WHERE NATIONALITY NOT IN (SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2);\n        END IF;\n    END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT"
    ],
    "call_sqls": [
      "BEGIN\n  modify_architect_records('American', 'Jr.');\n  commit;\nEND;",
      "BEGIN\n  modify_architect_records('Canadian', 'Sr.');\n  commit;\nEND;",
      "BEGIN\n  modify_architect_records('Iraqi, British', 'III');\n  commit;\nEND;",
      "BEGIN\n  modify_architect_records('British', 'IV');\n  commit;\nEND;",
      "BEGIN\n  modify_architect_records('French', 'V');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `MODIFY_ARCHITECT_RECORDS` that takes a nationality and a name suffix. First, count architects with that nationality, calculate the average name length, and count distinct nationalities. If the specific nationality count >5, append the suffix to their names. Else if average name length >12, delete architects of that nationality with names longer than the average. Else, if distinct nationality count >3, insert a new 'Multinational'/'female' architect with a generated ID. Otherwise, delete architects whose nationality is not among the first two distinct nationalities found.",
    "natural_language": "Create procedure MODIFY_ARCHITECT_RECORDS with nationality and suffix parameters. Count architects by nationality, get average name length, and count distinct nationalities. If nationality count >5, append suffix to their names. Else if average length >12, delete architects of that nationality with long names. Else if distinct nationalities >3, insert a new 'Multinational'/'female' architect. Otherwise, delete architects not in the top two nationalities.",
    "id": 28,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named MODIFY_ARCHITECT_RECORDS that accepts two input parameters: a string parameter P_NATIONALITY of type VARCHAR2, which specifies a nationality to filter architect records, and a string parameter P_NAME_SUFFIX of type VARCHAR2, which provides a text suffix to be appended to names. The procedure begins by declaring three local NUMBER variables: V_ARCHITECT_COUNT, V_AVG_NAME_LENGTH, and V_NATIONALITY_COUNT. It first executes a SELECT statement to count the total number of rows in the ARCHITECT table where the NATIONALITY column exactly matches the input P_NATIONALITY, storing the result in V_ARCHITECT_COUNT. It then executes a second SELECT statement to calculate the average character length of all values in the NAME column of the ARCHITECT table, storing the result in V_AVG_NAME_LENGTH. A third SELECT statement counts the number of distinct values present in the NATIONALITY column across the entire ARCHITECT table, storing the result in V_NATIONALITY_COUNT. The core logic uses a conditional IF-ELSIF-ELSE block. If the value of V_ARCHITECT_COUNT is greater than 5, the procedure performs an UPDATE operation on the ARCHITECT table, setting the NAME column to its current value concatenated with a single space and then the input P_NAME_SUFFIX, but only for rows where the NATIONALITY column equals P_NATIONALITY. If the first condition is false and V_AVG_NAME_LENGTH is greater than 12, the procedure executes a DELETE operation on the ARCHITECT table, removing rows where the character length of the NAME column is greater than the calculated V_AVG_NAME_LENGTH and the NATIONALITY column equals P_NATIONALITY. If neither of the first two conditions is met, the procedure enters a nested IF-ELSE block. Within this block, if V_NATIONALITY_COUNT is greater than 3, an INSERT operation is performed on the ARCHITECT table, adding a new row with specific values: the ID column is set to the string 'MOD_' concatenated with the current system date and time formatted as 'YYYYMMDDHH24MISS' using the TO_CHAR function with SYSDATE, the NAME column is set to the input P_NAME_SUFFIX concatenated with the string ' Diverse', the NATIONALITY column is set to 'Multinational', and the GENDER column is set to 'female'. If V_NATIONALITY_COUNT is 3 or less, a DELETE operation is executed on the ARCHITECT table, removing rows where the NATIONALITY value is not found in the list of distinct nationalities limited to the first two distinct nationalities retrieved by the subquery `SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2`."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named MergeDuplicateMovies that accepts three input parameters: p_source_mid of type NUMBER representing the movie ID to be merged away, p_target_mid of type NUMBER representing the movie ID to be kept, and p_keep_ratings of type VARCHAR2 specifying which set of user ratings to preserve. The procedure first queries the MOVIE table to count rows where the MID column equals p_source_mid, storing the result in variable v_source_exists, and similarly counts rows where MID equals p_target_mid, storing the result in v_target_exists. If both counts are exactly one, confirming both source and target movies exist uniquely, the procedure proceeds based on the p_keep_ratings value: if p_keep_ratings is 'SOURCE', it deletes all rows from the RATING table where the MID column equals p_target_mid, then updates all rows in the RATING table where MID equals p_source_mid, changing their MID to p_target_mid; if p_keep_ratings is 'TARGET', it deletes all rows from the RATING table where MID equals p_source_mid; for any other value of p_keep_ratings, it deletes all rows from the RATING table where MID equals p_source_mid and also deletes all rows where MID equals p_target_mid. Finally, after handling the ratings, the procedure deletes the row from the MOVIE table where the MID column equals p_source_mid.",
    "plsql": "CREATE OR REPLACE PROCEDURE MergeDuplicateMovies(\n    p_source_mid IN NUMBER,\n    p_target_mid IN NUMBER,\n    p_keep_ratings IN VARCHAR2\n) AS\n    v_source_exists NUMBER;\n    v_target_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_source_exists FROM MOVIE WHERE MID = p_source_mid;\n    SELECT COUNT(*) INTO v_target_exists FROM MOVIE WHERE MID = p_target_mid;\n    \n    IF v_source_exists = 1 AND v_target_exists = 1 THEN\n        IF p_keep_ratings = 'SOURCE' THEN\n            DELETE FROM RATING WHERE MID = p_target_mid;\n            UPDATE RATING SET MID = p_target_mid WHERE MID = p_source_mid;\n        ELSIF p_keep_ratings = 'TARGET' THEN\n            DELETE FROM RATING WHERE MID = p_source_mid;\n        ELSE\n            DELETE FROM RATING WHERE MID = p_source_mid;\n            DELETE FROM RATING WHERE MID = p_target_mid;\n        END IF;\n        \n        DELETE FROM MOVIE WHERE MID = p_source_mid;\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "BEGIN\n  MergeDuplicateMovies(101, 102, 'SOURCE');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeDuplicateMovies(103, 104, 'TARGET');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeDuplicateMovies(105, 106, 'NONE');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeDuplicateMovies(107, 108, 'SOURCE');\n  COMMIT;\nEND;",
      "BEGIN\n  MergeDuplicateMovies(109, 110, 'TARGET');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named MergeDuplicateMovies to merge two movie records. It confirms both source (p_source_mid) and target (p_target_mid) movies exist. Based on the p_keep_ratings parameter ('SOURCE', 'TARGET', or other), it manages the RATING table to keep the specified ratings, delete others, and updates ratings to point to the target movie ID. Finally, it deletes the source movie record.",
    "natural_language": "How can I create a stored procedure named MergeDuplicateMovies to merge two movie records, ensuring both the source (p_source_mid) and target (p_target_mid) movies exist, and based on the p_keep_ratings parameter ('SOURCE', 'TARGET', or other), manage the RATING table to keep the specified ratings, delete others, update ratings to point to the target movie ID, and finally delete the source movie record?",
    "id": 29,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named MergeDuplicateMovies in the movie_1 database. This procedure is designed to merge two movie records by consolidating their associated ratings and then removing the source movie. It accepts three input parameters: p_source_mid of type NUMBER to identify the movie record to be merged and removed, p_target_mid of type NUMBER to identify the movie record that will remain after the merge, and p_keep_ratings of type VARCHAR2 to specify which set of ratings to retain. The p_keep_ratings parameter accepts the values 'SOURCE', 'TARGET', or any other value, which dictates the logic for handling the RATING table.\n\nThe procedure begins by validating the existence of both the source and target movies. It performs two separate SELECT statements into dummy variables using the COUNT(*) function on the MOVIE table. The first check counts rows where the MID column equals p_source_mid, and the second check counts rows where the MID column equals p_target_mid. If either count returns zero, the procedure raises an application error indicating that one or both movies do not exist, and then exits.\n\nFollowing successful validation, the procedure handles the RATING table based on the value of p_keep_ratings. The logic branches into three distinct paths.\n\nIf p_keep_ratings is 'SOURCE', the procedure first deletes all rows from the RATING table where the MID column equals p_target_mid. This removes all ratings originally associated with the target movie. It then performs an UPDATE on the RATING table, setting the MID column to p_target_mid for all rows where the MID column currently equals p_source_mid. This reassigns all source movie ratings to the target movie.\n\nIf p_keep_ratings is 'TARGET', the procedure first deletes all rows from the RATING table where the MID column equals p_source_mid. This removes all ratings originally associated with the source movie. No update is necessary in this branch, as the target movie's ratings are already correctly associated.\n\nFor any other value of p_keep_ratings (neither 'SOURCE' nor 'TARGET'), the procedure performs a consolidated operation. It executes an UPDATE on the RATING table, setting the MID column to p_target_mid for all rows where the MID column equals p_source_mid. This reassigns the source movie's ratings to the target movie. Ratings for both movies now point to the target movie ID, effectively merging them. No deletions are performed in this branch, preserving all rating records from both movies under the target movie ID.\n\nAfter the rating management logic is complete, regardless of the branch taken, the procedure performs a final DELETE operation on the MOVIE table. It deletes the single row where the MID column equals p_source_mid, thereby removing the now-redundant source movie record from the database. The procedure then ends. There is no explicit return value; the outcome is the state change in the database tables."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ManageStudentCourseEnrollment` that accepts two input parameters: `p_student_id` of data type `NUMBER`, representing the unique identifier for a student, and `p_course_id` of data type `NUMBER`, representing the unique identifier for a course.\n\nThe procedure begins by declaring three local variables of data type `NUMBER`: `v_student_exists`, `v_course_exists`, and `v_enrollment_exists`, which will be used to store counts indicating the existence of a student, a course, and a student's enrollment in a course, respectively. It also declares a local variable `v_registration_id` of data type `NUMBER` to hold a generated registration identifier.\n\nFirst, the procedure executes a `SELECT COUNT(*)` statement to determine if a student with the `STUDENT_ID` matching the input parameter `p_student_id` exists in the `STUDENTS` table. The result of this count is stored in the `v_student_exists` variable.\n\nNext, it executes another `SELECT COUNT(*)` statement to determine if a course with the `COURSE_ID` matching the input parameter `p_course_id` exists in the `COURSES` table. The result of this count is stored in the `v_course_exists` variable.\n\nSubsequently, it executes a third `SELECT COUNT(*)` statement to determine if an existing enrollment record exists in the `STUDENT_COURSE_ENROLMENT` table for the student identified by `p_student_id` and the course identified by `p_course_id`. The result of this count is stored in the `v_enrollment_exists` variable.\n\nFollowing these checks, the procedure enters a conditional logic block:\n\n1.  **If `v_student_exists` is equal to `0` (meaning the student does not exist):** The procedure immediately terminates using a `RETURN` statement, performing no further actions.\n\n2.  **Else if `v_course_exists` is equal to `0` (meaning the course does not exist):** The procedure immediately terminates using a `RETURN` statement, performing no further actions.\n\n3.  **Else if `v_enrollment_exists` is equal to `0` (meaning the student is not currently enrolled in the specified course):**\n    *   The procedure calculates a new `REGISTRATION_ID` by executing a `SELECT NVL(MAX(REGISTRATION_ID), 0) + 1` statement from the `STUDENT_COURSE_ENROLMENT` table. This statement retrieves the maximum existing `REGISTRATION_ID`, replaces `NULL` with `0` if no records exist, and then increments the result by `1` to generate a unique new identifier. This calculated value is stored in the `v_registration_id` variable.\n    *   An `INSERT` statement is then executed to add a new record into the `STUDENT_COURSE_ENROLMENT` table. The new record includes the generated `v_registration_id` for the `REGISTRATION_ID` column, the input `p_student_id` for the `STUDENT_ID` column, the input `p_course_id` for the `COURSE_ID` column, and the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')` for the `DATE_OF_ENROLMENT` column.\n\n4.  **Else (meaning `v_student_exists` is not `0`, `v_course_exists` is not `0`, and `v_enrollment_exists` is not `0`, indicating an existing enrollment):**\n    *   A `DELETE` statement is executed to remove the existing enrollment record from the `STUDENT_COURSE_ENROLMENT` table where the `STUDENT_ID` matches `p_student_id` and the `COURSE_ID` matches `p_course_id`.\n\nFinally, the procedure concludes its execution.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageStudentCourseEnrollment(\n    p_student_id NUMBER,\n    p_course_id NUMBER\n) AS\n    v_student_exists NUMBER;\n    v_course_exists NUMBER;\n    v_enrollment_exists NUMBER;\n    v_registration_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_student_exists FROM STUDENTS WHERE STUDENT_ID = p_student_id;\n    SELECT COUNT(*) INTO v_course_exists FROM COURSES WHERE COURSE_ID = p_course_id;\n    SELECT COUNT(*) INTO v_enrollment_exists FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n\n    IF v_student_exists = 0 THEN\n        RETURN;\n    ELSIF v_course_exists = 0 THEN\n        RETURN;\n    ELSIF v_enrollment_exists = 0 THEN\n        SELECT NVL(MAX(REGISTRATION_ID), 0) + 1 INTO v_registration_id FROM STUDENT_COURSE_ENROLMENT;\n        INSERT INTO STUDENT_COURSE_ENROLMENT (REGISTRATION_ID, STUDENT_ID, COURSE_ID, DATE_OF_ENROLMENT)\n        VALUES (v_registration_id, p_student_id, p_course_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n    ELSE\n        DELETE FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  ManageStudentCourseEnrollment(1, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageStudentCourseEnrollment(2, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageStudentCourseEnrollment(3, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageStudentCourseEnrollment(1, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  ManageStudentCourseEnrollment(2, 3);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `ManageStudentCourseEnrollment` that toggles a student's enrollment in a course. It accepts a student ID and a course ID. First, check if the student and course exist. If either does not exist, exit. If the student is not enrolled, generate a new registration ID and insert a new enrollment record with the current timestamp. If the student is already enrolled, delete the existing enrollment record.",
    "natural_language": "How can I create a stored procedure named `ManageStudentCourseEnrollment` that toggles a student's enrollment in a course? The procedure should accept a student ID and a course ID. First, how do I check if the student and course exist, and exit if either does not? If the student is not enrolled, how should I generate a new registration ID and insert a new enrollment record with the current timestamp? Conversely, if the student is already enrolled, how do I delete the existing enrollment record?",
    "id": 30,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `ManageStudentCourseEnrollment` that accepts two input parameters: `p_student_id` of data type `NUMBER`, representing the unique identifier for a student, and `p_course_id` of data type `NUMBER`, representing the unique identifier for a course.\n\nThe procedure begins by declaring three local variables of data type `NUMBER`: `v_student_exists`, `v_course_exists`, and `v_enrollment_exists`, which will be used to store counts indicating the existence of a student, a course, and a student's enrollment in a course, respectively. It also declares a local variable `v_registration_id` of data type `NUMBER` to hold a generated registration identifier.\n\nFirst, the procedure executes a `SELECT COUNT(*)` statement to determine if a student with the `STUDENT_ID` matching the input parameter `p_student_id` exists in the `STUDENTS` table. The result of this count is stored in the `v_student_exists` variable.\n\nNext, it executes another `SELECT COUNT(*)` statement to determine if a course with the `COURSE_ID` matching the input parameter `p_course_id` exists in the `COURSES` table. The result of this count is stored in the `v_course_exists` variable.\n\nSubsequently, it executes a third `SELECT COUNT(*)` statement to determine if an existing enrollment record exists in the `STUDENT_COURSE_ENROLMENT` table for the student identified by `p_student_id` and the course identified by `p_course_id`. The result of this count is stored in the `v_enrollment_exists` variable.\n\nFollowing these checks, the procedure enters a conditional logic block:\n\n1.  **If `v_student_exists` is equal to `0` (meaning the student does not exist):** The procedure immediately terminates using a `RETURN` statement, performing no further actions.\n\n2.  **Else if `v_course_exists` is equal to `0` (meaning the course does not exist):** The procedure immediately terminates using a `RETURN` statement, performing no further actions.\n\n3.  **Else if `v_enrollment_exists` is equal to `0` (meaning the student is not currently enrolled in the specified course):**\n    *   The procedure calculates a new `REGISTRATION_ID` by executing a `SELECT NVL(MAX(REGISTRATION_ID), 0) + 1` statement from the `STUDENT_COURSE_ENROLMENT` table. This statement retrieves the maximum existing `REGISTRATION_ID`, replaces `NULL` with `0` if no records exist, and then increments the result by `1` to generate a unique new identifier. This calculated value is stored in the `v_registration_id` variable.\n    *   An `INSERT` statement is then executed to add a new record into the `STUDENT_COURSE_ENROLMENT` table. The new record includes the generated `v_registration_id` for the `REGISTRATION_ID` column, the input `p_student_id` for the `STUDENT_ID` column, the input `p_course_id` for the `COURSE_ID` column, and the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')` for the `DATE_OF_ENROLMENT` column.\n\n4.  **Else (meaning `v_student_exists` is not `0`, `v_course_exists` is not `0`, and `v_enrollment_exists` is not `0`, indicating an existing enrollment):**\n    *   A `DELETE` statement is executed to remove the existing enrollment record from the `STUDENT_COURSE_ENROLMENT` table where the `STUDENT_ID` matches `p_student_id` and the `COURSE_ID` matches `p_course_id`.\n\nFinally, the procedure concludes its execution."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteBookReviews that accepts a single input parameter p_book_id of the NUMBER data type, which is used to identify a specific book, and executes a DELETE operation on the database table named REVIEW, targeting and removing all rows from that table where the value in the column BOOK_ID is exactly equal to the value provided by the input parameter p_book_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteBookReviews(p_book_id IN NUMBER) AS\nBEGIN\n  DELETE FROM REVIEW\n  WHERE BOOK_ID = p_book_id;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteBookReviews(1);\n  commit;\nEND;",
      "BEGIN\n  DeleteBookReviews(2);\n  commit;\nEND;",
      "BEGIN\n  DeleteBookReviews(3);\n  commit;\nEND;",
      "BEGIN\n  DeleteBookReviews(4);\n  commit;\nEND;",
      "BEGIN\n  DeleteBookReviews(5);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteBookReviews that deletes all rows from the REVIEW table where the BOOK_ID matches a given input parameter.",
    "natural_language": "Make a stored procedure called DeleteBookReviews that removes a bunch of reviews from the REVIEW table for books that are kind of like the one you give it.",
    "id": 31,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DeleteBookReviews that accepts a single input parameter p_book_id of the NUMBER data type, which is used to identify a specific book, and executes a DELETE operation on the database table named REVIEW, targeting and removing all rows from that table where the value in the column BOOK_ID is exactly equal to the value provided by the input parameter p_book_id."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `add_new_country` that accepts four input parameters: `para_name` of type `VARCHAR2`, `para_population` of type `NUMBER`, `para_area` of type `NUMBER`, and `para_languages` of type `VARCHAR2`. The purpose of this procedure is to insert a new record into the `COUNTRY` table. The `COUNTRY_ID` column for the new record is determined by first querying the `COUNTRY` table to find the maximum existing `COUNTRY_ID` value. If no records exist in the `COUNTRY` table, `NVL` (Null Value Logic) function ensures that `0` is used instead of `NULL`. This maximum value (or `0`) is then incremented by `1` to generate a unique `COUNTRY_ID` for the new record. The `NAME` column of the new record is populated with the value provided by the `para_name` parameter. The `POPULATION` column is populated with the value from the `para_population` parameter. The `AREA` column is populated with the value from the `para_area` parameter. Finally, the `LANGUAGES` column is populated with the value from the `para_languages` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_new_country(para_name VARCHAR2, para_population NUMBER, para_area NUMBER, para_languages VARCHAR2) IS \nBEGIN \n  INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) \n  VALUES ((SELECT NVL(MAX(COUNTRY_ID), 0) + 1 FROM COUNTRY), para_name, para_population, para_area, para_languages); \nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "BEGIN\n  add_new_country('France', 65273511, 643801, 'French');\n  commit;\nEND;",
      "BEGIN\n  add_new_country('Germany', 83019200, 357022, 'German');\n  commit;\nEND;",
      "BEGIN\n  add_new_country('Japan', 126476461, 377975, 'Japanese');\n  commit;\nEND;",
      "BEGIN\n  add_new_country('Canada', 37589262, 9984670, 'English French');\n  commit;\nEND;",
      "BEGIN\n  add_new_country('Australia', 25364307, 7692024, 'English');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ADD_NEW_COUNTRY to insert a new country. It takes parameters for name, population, area, and languages. Generate a new COUNTRY_ID by finding the maximum existing ID, using 0 if none exist, and adding 1. Insert all values into the COUNTRY table.",
    "natural_language": "Hey, can you whip up a stored procedure called ADD_NEW_COUNTRY to add a new country? It needs to take in the country's name, how many people live there, its size, and the languages spoken. For the ID, just grab the highest one already in there, start from 0 if the table's empty, and bump it up by one. Then just shove all that info into the COUNTRY table.",
    "id": 32,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `add_new_country` that inserts a new record into the `COUNTRY` table. The procedure accepts four input parameters: `p_name` of type `VARCHAR2`, representing the country's name; `p_population` of type `NUMBER`, representing the country's population; `p_area` of type `NUMBER`, representing the country's area in square units; and `p_languages` of type `VARCHAR2`, representing the languages spoken in the country.\n\nThe procedure first declares a local variable `v_new_country_id` of type `NUMBER` to store the calculated new country identifier.\n\nThe procedure's logic begins with a `SELECT` statement that queries the `COUNTRY` table to find the maximum existing value in the `COUNTRY_ID` column. This query uses the `NVL` function to handle the case where the table is empty; if the maximum `COUNTRY_ID` is `NULL` (indicating no rows), the function returns 0. The result of this query is then incremented by 1 to generate the new `COUNTRY_ID`, and this value is assigned to the `v_new_country_id` variable.\n\nFollowing this calculation, the procedure performs an `INSERT` operation into the `COUNTRY` table. It inserts a single new row with the following column values: the `COUNTRY_ID` column is set to the calculated `v_new_country_id`; the `NAME` column is set to the input parameter `p_name`; the `POPULATION` column is set to the input parameter `p_population`; the `AREA` column is set to the input parameter `p_area`; and the `LANGUAGES` column is set to the input parameter `p_languages`."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateProductRevenue that accepts five input parameters: a numeric parameter p_product_code representing a product identifier, a numeric parameter p_new_price representing a proposed new price, a numeric parameter p_revenue_threshold representing a revenue limit, a numeric parameter p_manufacturer_code representing a manufacturer identifier, and a numeric parameter p_default_price representing a baseline price. The procedure executes a conditional block where, if the p_new_price value is strictly greater than the p_default_price value, it performs an update on the PRODUCTS table, setting the PRICE column to the p_new_price value for the specific row where the CODE column equals p_product_code and the MANUFACTURER column equals p_manufacturer_code. If the p_new_price value is less than or equal to the p_default_price value, the procedure executes a delete operation on the PRODUCTS table, removing rows where the CODE column equals p_product_code and the MANUFACTURER column value is found in a subquery result; this subquery selects the CODE column from the MANUFACTURERS table for all rows where the REVENUE column value is less than the p_revenue_threshold parameter. If neither of the previous conditions is true, which logically cannot occur as the conditions are exhaustive, the procedure executes an insert operation into the PRODUCTS table, specifying values for the columns CODE, NAME, PRICE, and MANUFACTURER; the value for the CODE column is derived from a scalar subquery that calculates the next available integer by selecting the maximum value from the CODE column in the PRODUCTS table, using the NVL function to substitute a zero if the maximum is null, and then adding one to that result, the NAME column is set to the literal string 'New Product', the PRICE column is set to the p_default_price parameter value, and the MANUFACTURER column is set to the p_manufacturer_code parameter value.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateProductRevenue(\n  p_product_code IN NUMBER,\n  p_new_price IN NUMBER,\n  p_revenue_threshold IN NUMBER,\n  p_manufacturer_code IN NUMBER,\n  p_default_price IN NUMBER\n) AS\nBEGIN\n  IF p_new_price > p_default_price THEN\n    UPDATE PRODUCTS\n    SET PRICE = p_new_price\n    WHERE CODE = p_product_code AND MANUFACTURER = p_manufacturer_code;\n  ELSIF p_new_price <= p_default_price THEN\n    DELETE FROM PRODUCTS\n    WHERE CODE = p_product_code AND MANUFACTURER IN (\n      SELECT CODE FROM MANUFACTURERS WHERE REVENUE < p_revenue_threshold\n    );\n  ELSE\n    INSERT INTO PRODUCTS (CODE, NAME, PRICE, MANUFACTURER)\n    VALUES (\n      (SELECT NVL(MAX(CODE), 0) + 1 FROM PRODUCTS),\n      'New Product',\n      p_default_price,\n      p_manufacturer_code\n    );\n  END IF;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateProductRevenue(1, 300, 80, 1, 250);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateProductRevenue(2, 100, 60, 2, 120);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateProductRevenue(3, 200, 70, 3, 150);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateProductRevenue(4, 90, 50, 1, 100);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateProductRevenue(5, 400, 90, 2, 350);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateProductRevenue that, for given product and manufacturer codes, a new price, a revenue threshold, and a default price: if the new price exceeds the default, update the product's price. If the new price is less than or equal to the default, delete the product if its manufacturer's revenue is below the threshold. Otherwise, insert a new product with an auto-generated code, name 'New Product', the default price, and the given manufacturer code.",
    "natural_language": "Create a stored procedure called UpdateProductRevenue that, for a specific product and its maker, a proposed price, a certain revenue level, and a standard price: if the proposed price is higher than the standard, adjust the product's price. If the proposed price isn't higher, remove the product provided its maker's earnings are kind of low compared to that level. If not, add a new product entry with an auto-made code, a name like 'New Product', the standard price, and that maker's code.",
    "id": 33,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateProductRevenue that accepts five input parameters: a numeric parameter p_product_code representing a product identifier, a numeric parameter p_new_price representing a proposed new price, a numeric parameter p_revenue_threshold representing a revenue limit, a numeric parameter p_manufacturer_code representing a manufacturer identifier, and a numeric parameter p_default_price representing a baseline price. The procedure executes a conditional block where, if the p_new_price value is strictly greater than the p_default_price value, it performs an update on the PRODUCTS table, setting the PRICE column to the p_new_price value for the specific row where the CODE column equals p_product_code and the MANUFACTURER column equals p_manufacturer_code. If the p_new_price value is less than or equal to the p_default_price value, the procedure executes a delete operation on the PRODUCTS table, removing rows where the CODE column equals p_product_code and the MANUFACTURER column value is found in a subquery result; this subquery selects the CODE column from the MANUFACTURERS table for all rows where the REVENUE column value is less than the p_revenue_threshold parameter. If neither of the previous conditions is true, which logically cannot occur as the conditions are exhaustive, the procedure executes an insert operation into the PRODUCTS table, specifying values for the columns CODE, NAME, PRICE, and MANUFACTURER; the value for the CODE column is derived from a scalar subquery that calculates the next available integer by selecting the maximum value from the CODE column in the PRODUCTS table, using the NVL function to substitute a zero if the maximum is null, and then adding one to that result, the NAME column is set to the literal string 'New Product', the PRICE column is set to the p_default_price parameter value, and the MANUFACTURER column is set to the p_manufacturer_code parameter value."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named assign_professional_to_dog that accepts two mandatory input parameters: p_dog_id of type NUMBER, which identifies a specific dog, and p_professional_id of type NUMBER, which identifies a specific professional. The procedure performs a single INSERT operation into the TREATMENTS table. It constructs a new row for this table by populating the following columns: for the TREATMENT_ID column, it executes a subquery to calculate the value by selecting the current maximum value from the TREATMENT_ID column in the TREATMENTS table, applying the NVL function to that result to convert any NULL value to 0, and then adding 1 to this result; for the DOG_ID column, it uses the value of the input parameter p_dog_id; for the PROFESSIONAL_ID column, it uses the value of the input parameter p_professional_id; for the TREATMENT_TYPE_CODE column, it inserts the literal string 'EXAM'; for the DATE_OF_TREATMENT column, it uses the TO_CHAR function to convert the current system date and time from the SYSDATE function into a string formatted as 'YYYY-MM-DD HH24:MI:SS'; and for the COST_OF_TREATMENT column, it inserts the literal numeric value 100.",
    "plsql": "CREATE OR REPLACE PROCEDURE assign_professional_to_dog(p_dog_id NUMBER, p_professional_id NUMBER)\nIS\nBEGIN\n   INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT)\n   VALUES ((SELECT NVL(MAX(TREATMENT_ID),0) + 1 FROM TREATMENTS), p_dog_id, p_professional_id, 'EXAM', TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 100);\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 1, p_professional_id => 1);\nEND;",
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 2, p_professional_id => 2);\nEND;",
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 3, p_professional_id => 3);\nEND;",
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 14, p_professional_id => 9);\nEND;",
      "BEGIN\n  assign_professional_to_dog(p_dog_id => 4, p_professional_id => 10);\nEND;"
    ],
    "summary": "Create a stored procedure named assign_professional_to_dog that accepts a dog ID and a professional ID (both NUMBER). Insert a new record into the TREATMENTS table with a new TREATMENT_ID (max existing ID + 1), the provided dog and professional IDs, a TREATMENT_TYPE_CODE of 'EXAM', the current date/time (formatted as 'YYYY-MM-DD HH24:MI:SS'), and a COST_OF_TREATMENT of 100.",
    "natural_language": "Create procedure assign_professional_to_dog with dog ID and professional ID. Insert into TREATMENTS using next TREATMENT_ID, given IDs, 'EXAM' type, current timestamp, and cost 100.",
    "id": 34,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named assign_professional_to_dog that accepts two input parameters: p_dog_id of type NUMBER used to specify a dog identifier, and p_professional_id of type NUMBER used to specify a professional identifier; the procedure performs a single INSERT operation into the TREATMENTS table, where it inserts a new row with the following column values: the TREATMENT_ID column is populated by retrieving the next value from the sequence associated with the TREATMENT_ID primary key, typically using a sequence like TREATMENTS_SEQ.NEXTVAL, the DOG_ID column is set to the input parameter p_dog_id, the PROFESSIONAL_ID column is set to the input parameter p_professional_id, the TREATMENT_TYPE_CODE column is set to the constant string 'EXAM', the DATE_OF_TREATMENT column is set to the current system timestamp using the SYSTIMESTAMP function, and the COST_OF_TREATMENT column is set to the constant numeric value 100."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `delete_major_rankings` that is designed to remove specific records from the `MAJOR_RANKING` table. This procedure accepts four input parameters: `p_major_id` of data type `NUMBER`, which represents the unique identifier for a major; `p_university_id` of data type `NUMBER`, which represents the unique identifier for a university; `p_min_rank` of data type `NUMBER`, which specifies the lower bound of a rank range; and `p_max_rank` of data type `NUMBER`, which specifies the upper bound of the same rank range. The core operation performed by this procedure is a `DELETE` statement targeting the `MAJOR_RANKING` table. This `DELETE` operation is conditional, meaning it only removes rows that satisfy a set of criteria defined in its `WHERE` clause. Specifically, a row will be deleted if its `MAJOR_ID` column value exactly matches the value provided in the `p_major_id` input parameter, AND its `UNIVERSITY_ID` column value exactly matches the value provided in the `p_university_id` input parameter, AND its `RANK` column value falls inclusively within the range defined by `p_min_rank` and `p_max_rank`. This means that the `RANK` column value must be greater than or equal to `p_min_rank` AND less than or equal to `p_max_rank`. The procedure does not perform any other operations such as inserts, updates, or selections, nor does it involve any function calls or complex logical flows beyond the single conditional delete statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_major_rankings(\n    p_major_id IN NUMBER,\n    p_university_id IN NUMBER,\n    p_min_rank IN NUMBER,\n    p_max_rank IN NUMBER\n)\nIS\nBEGIN\n    DELETE FROM MAJOR_RANKING\n    WHERE MAJOR_ID = p_major_id\n    AND UNIVERSITY_ID = p_university_id\n    AND RANK BETWEEN p_min_rank AND p_max_rank;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  delete_major_rankings(p_major_id => 1, p_university_id => 1, p_min_rank => 1, p_max_rank => 10);\nEND;",
      "BEGIN\n  delete_major_rankings(p_major_id => 2, p_university_id => 3, p_min_rank => 5, p_max_rank => 15);\nEND;",
      "BEGIN\n  delete_major_rankings(p_major_id => 3, p_university_id => 2, p_min_rank => 1, p_max_rank => 5);\nEND;",
      "BEGIN\n  delete_major_rankings(p_major_id => 1, p_university_id => 3, p_min_rank => 1, p_max_rank => 1);\nEND;",
      "BEGIN\n  delete_major_rankings(p_major_id => 2, p_university_id => 1, p_min_rank => 10, p_max_rank => 20);\nEND;"
    ],
    "summary": "Create a stored procedure named delete_major_rankings that deletes records from the MAJOR_RANKING table where MAJOR_ID equals input p_major_id, UNIVERSITY_ID equals input p_university_id, and RANK is between input p_min_rank and p_max_rank inclusive.",
    "natural_language": "Delete MAJOR_RANKING records for given major and university where rank is within a specified range.",
    "id": 35,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named delete_major_rankings that accepts four input parameters: p_major_id of type NUMBER which identifies a specific major, p_university_id of type NUMBER which identifies a specific university, p_low_rank of type NUMBER which defines the lower bound of the rank range, and p_high_rank of type NUMBER which defines the upper bound of the rank range. The procedure performs a DELETE operation on the MAJOR_RANKING table. The deletion condition is that the MAJOR_ID column must equal the p_major_id parameter, the UNIVERSITY_ID column must equal the p_university_id parameter, and the RANK column must be greater than or equal to p_low_rank and less than or equal to p_high_rank. This operation removes all records from the MAJOR_RANKING table that match the specified major, university, and fall within the inclusive rank range. The procedure does not return a value."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp that accepts two parameters: para_weight_limit of type NUMBER and para_age_limit of type NUMBER. The procedure begins by declaring a cursor named pet_cursor, which retrieves data from the PETS table joined with the HAS_PET table based on the PETID column, selecting PETID, PETTYPE, PET_AGE, WEIGHT, and STUID columns. It declares variables pet_rec of type pet_cursor%ROWTYPE, student_age of type NUMBER, pet_type_decoded of type VARCHAR2(50), and student_count of type NUMBER. The procedure opens the pet_cursor and enters a loop to fetch each record into pet_rec. It exits the loop when no more records are found. For each fetched record, it uses the DECODE function to translate the PETTYPE column value into 'canine' for 'dog', 'feline' for 'cat', or 'unknown' for other values, storing the result in pet_type_decoded. It attempts to select the AGE column from the STUDENT table where STUID matches pet_rec.STUID, storing the result in student_age, and handles the NO_DATA_FOUND exception by setting student_age to NULL. The procedure then evaluates several conditions based on pet_rec.WEIGHT, pet_rec.PET_AGE, and student_age. If pet_rec.WEIGHT exceeds para_weight_limit, it checks if pet_rec.PET_AGE exceeds para_age_limit and if student_age is greater than 20, deleting the record from HAS_PET where PETID matches pet_rec.PETID. If student_age is not greater than 20, it inserts a new record into PETS with PETID incremented by 5000, pet_type_decoded, pet_rec.PET_AGE, and pet_rec.WEIGHT. If pet_rec.PET_AGE does not exceed para_age_limit, it checks if student_age is not NULL, counts the number of students with the same age, and if student_count is greater than 1, deletes records from HAS_PET and PETS where PETID matches pet_rec.PETID. If student_count is not greater than 1, it inserts a new record into HAS_PET with STUID and PETID incremented by 6000. If student_age is NULL, it performs no operation. If pet_rec.WEIGHT does not exceed para_weight_limit, it checks if pet_rec.PET_AGE is less than para_age_limit, deleting records from HAS_PET and STUDENT where STUID matches pet_rec.STUID. If pet_rec.PET_AGE is not less than para_age_limit, it inserts a new record into PETS with PETID incremented by 7000, pet_type_decoded, pet_rec.PET_AGE incremented by 1, and pet_rec.WEIGHT incremented by 1. The procedure closes the pet_cursor after processing all records.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_weight_limit NUMBER, para_age_limit NUMBER) IS\nCURSOR pet_cursor IS SELECT p.PETID, p.PETTYPE, p.PET_AGE, p.WEIGHT, hp.STUID FROM PETS p JOIN HAS_PET hp ON p.PETID = hp.PETID;\npet_rec pet_cursor%ROWTYPE;\nstudent_age NUMBER;\npet_type_decoded VARCHAR2(50);\nstudent_count NUMBER;\nBEGIN\nOPEN pet_cursor;\nLOOP\nFETCH pet_cursor INTO pet_rec;\nEXIT WHEN pet_cursor%NOTFOUND;\nSELECT DECODE(pet_rec.PETTYPE, 'dog', 'canine', 'cat', 'feline', 'unknown') INTO pet_type_decoded FROM DUAL;\nBEGIN\nSELECT AGE INTO student_age FROM STUDENT WHERE STUID = pet_rec.STUID;\nEXCEPTION\nWHEN NO_DATA_FOUND THEN\nstudent_age := NULL;\nEND;\nIF pet_rec.WEIGHT > para_weight_limit THEN\nIF pet_rec.PET_AGE > para_age_limit THEN\nIF student_age > 20 THEN\nDELETE FROM HAS_PET WHERE PETID = pet_rec.PETID;\nELSE\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (pet_rec.PETID + 5000, pet_type_decoded, pet_rec.PET_AGE, pet_rec.WEIGHT);\nEND IF;\nELSE\nIF student_age IS NOT NULL THEN\nSELECT COUNT(*) INTO student_count FROM STUDENT WHERE AGE = student_age;\nIF student_count > 1 THEN\nDELETE FROM HAS_PET WHERE PETID = pet_rec.PETID;\nDELETE FROM PETS WHERE PETID = pet_rec.PETID;\nELSE\nINSERT INTO HAS_PET (STUID, PETID) VALUES (pet_rec.STUID, pet_rec.PETID + 6000);\nEND IF;\nELSE\n-- If student_age is NULL, skip this block or handle appropriately\nNULL;\nEND IF;\nEND IF;\nELSE\nIF pet_rec.PET_AGE < para_age_limit THEN\nDELETE FROM HAS_PET WHERE STUID = pet_rec.STUID;\nDELETE FROM STUDENT WHERE STUID = pet_rec.STUID;\nELSE\nINSERT INTO PETS (PETID, PETTYPE, PET_AGE, WEIGHT) VALUES (pet_rec.PETID + 7000, pet_type_decoded, pet_rec.PET_AGE + 1, pet_rec.WEIGHT + 1);\nEND IF;\nEND IF;\nEND LOOP;\nCLOSE pet_cursor;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN sp(10, 5); END;",
      "BEGIN sp(15, 10); END;",
      "BEGIN sp(5, 2); END;",
      "BEGIN sp(20, 1); END;",
      "BEGIN sp(8, 7); END;"
    ],
    "summary": "Create a stored procedure named 'sp' to process pet records. Inputs: a weight limit and an age limit. For each pet linked to a student, decode its type. If the pet's weight exceeds the limit, check its age and the student's age. If both the pet's age exceeds the limit and the student is over 20, delete the pet link. If the student is 20 or under, insert a new pet with an adjusted ID. If the pet's age does not exceed the limit, check if the student exists. If they do and more than one student shares that age, delete the pet and its link. Otherwise, insert a new pet link with adjusted IDs. If the pet's weight does not exceed the limit, check its age. If the age is below the limit, delete the student and their pet links. Otherwise, insert a new pet with an adjusted ID, age, and weight.",
    "natural_language": "How can I create a stored procedure named 'sp' that processes pet records based on a given weight limit and age limit? For each pet associated with a student, it should decode the pet's type. If a pet's weight is above the limit, how should the procedure check the pet's age and the student's age? If the pet is older than the age limit and the student is over 20, should it delete the pet link? If the student is 20 or younger, should it insert a new pet with an adjusted ID? If the pet's age is not over the limit, how does it check for the student's existence? If the student exists and more than one student shares that age, should it delete the pet and its link? Otherwise, should it insert a new pet link with adjusted IDs? If the pet's weight is not over the limit, how does it check the pet's age? If the age is below the limit, should it delete the student and all their pet links? Otherwise, should it insert a new pet with an adjusted ID, age, and weight?",
    "id": 36,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that accepts two parameters: para_weight_limit of type NUMBER and para_age_limit of type NUMBER. The procedure begins by declaring a cursor named pet_cursor, which retrieves data from the PETS table joined with the HAS_PET table based on the PETID column, selecting PETID, PETTYPE, PET_AGE, WEIGHT, and STUID columns. It declares variables pet_rec of type pet_cursor%ROWTYPE, student_age of type NUMBER, pet_type_decoded of type VARCHAR2(50), and student_count of type NUMBER. The procedure opens the pet_cursor and enters a loop to fetch each record into pet_rec. It exits the loop when no more records are found. For each fetched record, it uses the DECODE function to translate the PETTYPE column value into 'canine' for 'dog', 'feline' for 'cat', or 'unknown' for other values, storing the result in pet_type_decoded. It attempts to select the AGE column from the STUDENT table where STUID matches pet_rec.STUID, storing the result in student_age, and handles the NO_DATA_FOUND exception by setting student_age to NULL. The procedure then evaluates several conditions based on pet_rec.WEIGHT, pet_rec.PET_AGE, and student_age. If pet_rec.WEIGHT exceeds para_weight_limit, it checks if pet_rec.PET_AGE exceeds para_age_limit and if student_age is greater than 20, deleting the record from HAS_PET where PETID matches pet_rec.PETID. If student_age is not greater than 20, it inserts a new record into PETS with PETID incremented by 5000, pet_type_decoded, pet_rec.PET_AGE, and pet_rec.WEIGHT. If pet_rec.PET_AGE does not exceed para_age_limit, it checks if student_age is not NULL, counts the number of students with the same age, and if student_count is greater than 1, deletes records from HAS_PET and PETS where PETID matches pet_rec.PETID. If student_count is not greater than 1, it inserts a new record into HAS_PET with STUID and PETID incremented by 6000. If student_age is NULL, it performs no operation. If pet_rec.WEIGHT does not exceed para_weight_limit, it checks if pet_rec.PET_AGE is less than para_age_limit, deleting records from HAS_PET and STUDENT where STUID matches pet_rec.STUID. If pet_rec.PET_AGE is not less than para_age_limit, it inserts a new record into PETS with PETID incremented by 7000, pet_type_decoded, pet_rec.PET_AGE incremented by 1, and pet_rec.WEIGHT incremented by 1. The procedure closes the pet_cursor after processing all records."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes a single input parameter, para_party_id of type NUMBER, and performs the following operations: First, it queries the PARTIES table to count the number of rows where the PARTY_ID column matches the value of para_party_id and stores the result in a local variable named party_exists. Then, it checks if the value of party_exists is greater than 0, indicating that a row with the specified PARTY_ID exists in the PARTIES table. If this condition is true, it deletes all rows from the PARTY_FORMS table where the PARTY_ID column matches the value of para_party_id. After that, it deletes the row from the PARTIES table where the PARTY_ID column matches the value of para_party_id. If the condition is not met (i.e., no matching row exists in the PARTIES table), no further action is taken.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_cleanup_parties(para_party_id NUMBER) IS\n  party_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO party_exists FROM PARTIES WHERE PARTY_ID = para_party_id;\n  IF party_exists > 0 THEN\n    DELETE FROM PARTY_FORMS WHERE PARTY_ID = para_party_id;\n    DELETE FROM PARTIES WHERE PARTY_ID = para_party_id;\n  END IF;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_cleanup_parties(1);\nEND;",
      "BEGIN\n  sp_cleanup_parties(2);\nEND;",
      "BEGIN\n  sp_cleanup_parties(3);\nEND;",
      "BEGIN\n  sp_cleanup_parties(15);\nEND;",
      "BEGIN\n  sp_cleanup_parties(8);\nEND;"
    ],
    "summary": "Create a stored procedure that accepts a party ID number. Check if the party exists. If it exists, first delete all forms associated with that party, then delete the party record itself.",
    "natural_language": "Delete a party and its forms by ID if the party exists.",
    "id": 37,
    "generated_ir": "Write an Oracle PL/SQL stored procedure that takes a single input parameter, para_party_id of type NUMBER, and performs the following operations: First, it queries the PARTIES table to count the number of rows where the PARTY_ID column matches the value of para_party_id and stores the result in a local variable named party_exists. Then, it checks if the value of party_exists is greater than 0, indicating that a row with the specified PARTY_ID exists in the PARTIES table. If this condition is true, it deletes all rows from the PARTY_FORMS table where the PARTY_ID column matches the value of para_party_id. After that, it deletes the row from the PARTIES table where the PARTY_ID column matches the value of para_party_id. If the condition is not met (i.e., no matching row exists in the PARTIES table), no further action is taken."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateStudentCourseCompletion that accepts two parameters: p_student_id of type NUMBER, representing the unique identifier of a student, and p_course_id of type NUMBER, representing the unique identifier of a course. The procedure first declares a local variable v_enrollment_exists of type NUMBER to store the count of enrollments for the specified student and course, and another local variable v_completion_date of type VARCHAR2(255) to store the date of enrollment. The procedure begins by executing a SELECT statement to count the number of records in the STUDENT_COURSE_ENROLMENT table where the STUDENT_ID column matches p_student_id and the COURSE_ID column matches p_course_id, storing the result in v_enrollment_exists. If v_enrollment_exists equals 0, indicating no enrollment exists for the given student and course, the procedure terminates immediately using the RETURN statement. If v_enrollment_exists is not 0, the procedure proceeds to execute another SELECT statement to retrieve the DATE_OF_ENROLMENT from the STUDENT_COURSE_ENROLMENT table for the specified student and course, storing the result in v_completion_date. Subsequently, the procedure performs an UPDATE operation on the STUDENT_COURSE_ENROLMENT table, setting the DATE_OF_COMPLETION column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function applied to SYSDATE, for the row where STUDENT_ID matches p_student_id and COURSE_ID matches p_course_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateStudentCourseCompletion(\n    p_student_id NUMBER,\n    p_course_id NUMBER\n) AS\n    v_enrollment_exists NUMBER;\n    v_completion_date VARCHAR2(255);\nBEGIN\n    SELECT COUNT(*) INTO v_enrollment_exists FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n\n    IF v_enrollment_exists = 0 THEN\n        RETURN;\n    ELSE\n        SELECT DATE_OF_ENROLMENT INTO v_completion_date FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n        UPDATE STUDENT_COURSE_ENROLMENT\n        SET DATE_OF_COMPLETION = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n        WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateStudentCourseCompletion(11, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateStudentCourseCompletion(15, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateStudentCourseCompletion(10, 8);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateStudentCourseCompletion(11, 4);\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateStudentCourseCompletion(15, 2);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `UpdateStudentCourseCompletion` that sets the completion date for a student's course enrollment. It accepts a student ID and a course ID. First, check if the enrollment exists. If not, exit. If it exists, retrieve the enrollment date and update the enrollment record to set the completion date to the current system timestamp.",
    "natural_language": "Hey, can you whip up a stored procedure called `UpdateStudentCourseCompletion`? It needs to set the \"done\" date for when a student finishes a course. You'll give it a student ID and a course ID. First off, check if that student is even enrolled in that course. If they're not, just bail out. If they are, grab the date they started, and then update their record to mark it as completed right now.",
    "id": 38,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateStudentCourseCompletion that accepts two parameters: p_student_id of type NUMBER, representing the unique identifier of a student, and p_course_id of type NUMBER, representing the unique identifier of a course. The procedure first declares a local variable v_enrollment_exists of type NUMBER to store the count of enrollments for the specified student and course, and another local variable v_completion_date of type VARCHAR2(255) to store the date of enrollment. The procedure begins by executing a SELECT statement to count the number of records in the STUDENT_COURSE_ENROLMENT table where the STUDENT_ID column matches p_student_id and the COURSE_ID column matches p_course_id, storing the result in v_enrollment_exists. If v_enrollment_exists equals 0, indicating no enrollment exists for the given student and course, the procedure terminates immediately using the RETURN statement. If v_enrollment_exists is not 0, the procedure proceeds to execute another SELECT statement to retrieve the DATE_OF_ENROLMENT from the STUDENT_COURSE_ENROLMENT table for the specified student and course, storing the result in v_completion_date. Subsequently, the procedure performs an UPDATE operation on the STUDENT_COURSE_ENROLMENT table, setting the DATE_OF_COMPLETION column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function applied to SYSDATE, for the row where STUDENT_ID matches p_student_id and COURSE_ID matches p_course_id."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_sync_order_items that accepts three parameters: p_order_id of type NUMBER, p_product_id of type NUMBER, and p_quantity of type VARCHAR2. The procedure first checks the ORDER_ITEMS table to determine if there is an existing record with the specified ORDER_ID matching p_order_id and PRODUCT_ID matching p_product_id by counting such records and storing the result in a local variable v_exists. If no such record exists (v_exists equals 0), the procedure inserts a new row into the ORDER_ITEMS table with ORDER_ITEM_ID set to one more than the current maximum ORDER_ITEM_ID in the table, or 1 if the table is empty, and assigns p_order_id to ORDER_ID, p_product_id to PRODUCT_ID, and p_quantity to ORDER_QUANTITY. If a record does exist (v_exists is not 0), the procedure deletes the existing record from the ORDER_ITEMS table where ORDER_ID equals p_order_id and PRODUCT_ID equals p_product_id, and then inserts a new row with the same logic for ORDER_ITEM_ID, assigning p_order_id to ORDER_ID, p_product_id to PRODUCT_ID, and p_quantity to ORDER_QUANTITY.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_sync_order_items(p_order_id IN NUMBER, p_product_id IN NUMBER, p_quantity IN VARCHAR2)\nIS\n   v_exists NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_exists FROM ORDER_ITEMS WHERE ORDER_ID = p_order_id AND PRODUCT_ID = p_product_id;\n   \n   IF v_exists = 0 THEN\n      INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n      VALUES ((SELECT NVL(MAX(ORDER_ITEM_ID),0) + 1 FROM ORDER_ITEMS), p_order_id, p_product_id, p_quantity);\n   ELSE\n      DELETE FROM ORDER_ITEMS WHERE ORDER_ID = p_order_id AND PRODUCT_ID = p_product_id;\n      INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID, ORDER_QUANTITY)\n      VALUES ((SELECT NVL(MAX(ORDER_ITEM_ID),0) + 1 FROM ORDER_ITEMS), p_order_id, p_product_id, p_quantity);\n   END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_sync_order_items(1, 13, '5');\n  commit;\nEND;",
      "BEGIN\n  proc_sync_order_items(2, 10, '3');\n  commit;\nEND;",
      "BEGIN\n  proc_sync_order_items(3, 11, '7');\n  commit;\nEND;",
      "BEGIN\n  proc_sync_order_items(1, 11, '2');\n  commit;\nEND;",
      "BEGIN\n  proc_sync_order_items(2, 13, '6');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named proc_sync_order_items that accepts an order_id number, a product_id number, and a quantity string. Check if an item with the given order_id and product_id exists. If it does not exist, insert it. If it does exist, delete the old record and insert a new one with the provided data.",
    "natural_language": "Create a stored procedure called proc_sync_order_items that takes an order_id number, a product_id number, and a quantity string. You need to see if there's already an item for that order and product. If you can't find one, just add it in. If you do find one, get rid of that old entry and put in a fresh one with the new details.",
    "id": 39,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named proc_sync_order_items that accepts three input parameters: p_order_id of type NUMBER, which represents the identifier of the order; p_product_id of type NUMBER, which represents the identifier of the product; and p_quantity of type VARCHAR2, which represents the quantity of the product to be synchronized. The procedure operates on the customers_and_orders database and uses the CUSTOMER_ORDERS and ORDER_ITEMS tables.\n\nThe procedure begins by declaring a variable v_count of type NUMBER to store the count of existing order items. It then performs a SELECT COUNT(*) operation into v_count from the ORDER_ITEMS table, where the order_id column matches the p_order_id parameter and the product_id column matches the p_product_id parameter. This query checks if an order item already exists for the given order and product combination.\n\nNext, the procedure uses conditional logic based on the value of v_count. If v_count equals 0, indicating no existing order item is found, the procedure executes an INSERT operation into the ORDER_ITEMS table. The inserted values are: order_item_id is set by selecting the maximum order_item_id from the ORDER_ITEMS table and incrementing it by 1 (if the table is empty, it defaults to 1 using NVL), order_id is set to p_order_id, product_id is set to p_product_id, and order_quantity is set to p_quantity.\n\nIf v_count is greater than 0, indicating an existing order item is found, the procedure first executes a DELETE operation on the ORDER_ITEMS table to remove the old entry, where the order_id column matches p_order_id and the product_id column matches p_product_id. After the deletion, it executes an INSERT operation into the ORDER_ITEMS table with the same logic as in the first case: order_item_id is set by selecting the maximum order_item_id from the ORDER_ITEMS table, incrementing it by 1 (with NVL handling empty tables), order_id is set to p_order_id, product_id is set to p_product_id, and order_quantity is set to p_quantity. This ensures a fresh entry with the new details replaces the old one.\n\nThe procedure does not return a value and includes no explicit exception handling or output parameters."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named validate_and_clean_records that accepts three input parameters: p_name_pattern of type VARCHAR2, p_founded_year of type NUMBER, and p_championship_limit of type NUMBER. The procedure begins by declaring two local variables, v_pattern_count and v_championship_exists, both of type NUMBER. It then performs a SELECT operation to count the number of rows in the INSTITUTION table where the NAME column contains the substring specified by p_name_pattern, using the LIKE operator with wildcard characters. The result of this count is stored in the v_pattern_count variable. If v_pattern_count is greater than zero, indicating that there are matching institutions, the procedure proceeds to perform another SELECT operation. This second query counts the number of rows in the CHAMPIONSHIP table, joined with the INSTITUTION table on the INSTITUTION_ID column, where the FOUNDED column in the INSTITUTION table matches the value of p_founded_year and the NUMBER_OF_CHAMPIONSHIPS column in the CHAMPIONSHIP table exceeds the value of p_championship_limit. The result of this count is stored in the v_championship_exists variable. If v_championship_exists is greater than zero, indicating that there are championships meeting the specified criteria, the procedure executes a DELETE operation on the CHAMPIONSHIP table to remove all rows where the INSTITUTION_ID matches any institution founded in the year specified by p_founded_year. The procedure concludes without any further actions or output.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_and_clean_records(\n    p_name_pattern IN VARCHAR2,\n    p_founded_year IN NUMBER,\n    p_championship_limit IN NUMBER\n)\nIS\n    v_pattern_count NUMBER;\n    v_championship_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_pattern_count FROM INSTITUTION WHERE NAME LIKE '%' || p_name_pattern || '%';\n    \n    IF v_pattern_count > 0 THEN\n        SELECT COUNT(*) INTO v_championship_exists FROM CHAMPIONSHIP c\n        JOIN INSTITUTION i ON c.INSTITUTION_ID = i.INSTITUTION_ID\n        WHERE i.FOUNDED = p_founded_year AND c.NUMBER_OF_CHAMPIONSHIPS > p_championship_limit;\n        \n        IF v_championship_exists > 0 THEN\n            DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID IN (\n                SELECT INSTITUTION_ID FROM INSTITUTION WHERE FOUNDED = p_founded_year\n            );\n        END IF;\n    END IF;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  validate_and_clean_records('University', 1908, 0);\n  commit;\nEND;",
      "BEGIN\n  validate_and_clean_records('Calgary', 1966, 1);\n  commit;\nEND;",
      "BEGIN\n  validate_and_clean_records('Alberta', 1908, 0);\n  commit;\nEND;",
      "BEGIN\n  validate_and_clean_records('British', 1966, 1);\n  commit;\nEND;",
      "BEGIN\n  validate_and_clean_records('Columbia', 1908, 0);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named validate_and_clean_records that accepts a name pattern, a founded year, and a championship limit. Count institutions whose name matches the pattern. If matches exist, count championships for institutions founded in that year exceeding the limit. If such championships exist, delete all championship records for institutions founded in that year.",
    "natural_language": "Develop a stored procedure called validate_and_clean_records which is designed to receive three distinct input parameters: a specific pattern for matching names, a particular year of founding, and a defined numerical limit for championships. The procedure should first meticulously count all academic institutions whose official names correspond precisely to the provided textual pattern. Should any such matching institutions be found, it must then proceed to calculate, with careful attention, the total number of championship titles held exclusively by those institutions that were established in the exact founding year supplied, but only for those cases where the championship count surpasses the stipulated limit. Finally, if and only if there are championship records meeting these stringent criteria, the procedure must comprehensively and permanently delete every single championship entry associated with all institutions founded in that very same year.",
    "id": 40,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named validate_and_clean_records that accepts three input parameters: p_name_pattern of type VARCHAR2, p_founded_year of type NUMBER, and p_championship_limit of type NUMBER. The procedure begins by declaring two local variables, v_pattern_count and v_championship_exists, both of type NUMBER. It then performs a SELECT operation to count the number of rows in the INSTITUTION table where the NAME column contains the substring specified by p_name_pattern, using the LIKE operator with wildcard characters. The result of this count is stored in the v_pattern_count variable. If v_pattern_count is greater than zero, indicating that there are matching institutions, the procedure proceeds to perform another SELECT operation. This second query counts the number of rows in the CHAMPIONSHIP table, joined with the INSTITUTION table on the INSTITUTION_ID column, where the FOUNDED column in the INSTITUTION table matches the value of p_founded_year and the NUMBER_OF_CHAMPIONSHIPS column in the CHAMPIONSHIP table exceeds the value of p_championship_limit. The result of this count is stored in the v_championship_exists variable. If v_championship_exists is greater than zero, indicating that there are championships meeting the specified criteria, the procedure executes a DELETE operation on the CHAMPIONSHIP table to remove all rows where the INSTITUTION_ID matches any institution founded in the year specified by p_founded_year. The procedure concludes without any further actions or output."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteStudent that accepts a single parameter p_student_id of type NUMBER, which represents the unique identifier of a student. The procedure begins by declaring a local variable v_student_exists of type NUMBER to store the count of students with the specified student ID. It executes a SELECT statement to count the number of records in the STUDENTS table where the STUDENT_ID column matches the value of p_student_id, storing the result in v_student_exists. The procedure then evaluates whether v_student_exists equals 0 using an IF statement. If v_student_exists is 0, indicating that no student with the given ID exists in the STUDENTS table, the procedure terminates immediately with a RETURN statement. If v_student_exists is not 0, meaning a student with the specified ID exists, the procedure proceeds to execute a DELETE statement on the STUDENT_COURSE_ENROLMENT table, removing all records where the STUDENT_ID column matches p_student_id. Following this, another DELETE statement is executed on the STUDENTS table to remove the record where the STUDENT_ID column matches p_student_id. The procedure concludes after these operations, having ensured that both the student and their course enrolments are deleted from the respective tables.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteStudent(\n    p_student_id NUMBER\n) AS\n    v_student_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_student_exists FROM STUDENTS WHERE STUDENT_ID = p_student_id;\n\n    IF v_student_exists = 0 THEN\n        RETURN;\n    ELSE\n        DELETE FROM STUDENT_COURSE_ENROLMENT WHERE STUDENT_ID = p_student_id;\n        DELETE FROM STUDENTS WHERE STUDENT_ID = p_student_id;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteStudent(1);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteStudent(2);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteStudent(3);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteStudent(11);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteStudent(15);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteStudent that accepts a student ID. Check if the student exists. If not, exit. If they exist, first delete their enrolments from STUDENT_COURSE_ENROLMENT, then delete the student from the STUDENTS table.",
    "natural_language": "Create a stored procedure called DeleteStudent that takes a student ID. See if that student is around. If you can't find them, just stop. If they are there, first get rid of any of their course sign-ups from the STUDENT_COURSE_ENROLMENT table, and then remove the student record from the STUDENTS table.",
    "id": 41,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DeleteStudent that accepts a single parameter p_student_id of type NUMBER, which represents the unique identifier of a student. The procedure begins by declaring a local variable v_student_exists of type NUMBER to store the count of students with the specified student ID. It executes a SELECT statement to count the number of records in the STUDENTS table where the STUDENT_ID column matches the value of p_student_id, storing the result in v_student_exists. The procedure then evaluates whether v_student_exists equals 0 using an IF statement. If v_student_exists is 0, indicating that no student with the given ID exists in the STUDENTS table, the procedure terminates immediately with a RETURN statement. If v_student_exists is not 0, meaning a student with the specified ID exists, the procedure proceeds to execute a DELETE statement on the STUDENT_COURSE_ENROLMENT table, removing all records where the STUDENT_ID column matches p_student_id. Following this, another DELETE statement is executed on the STUDENTS table to remove the record where the STUDENT_ID column matches p_student_id. The procedure concludes after these operations, having ensured that both the student and their course enrolments are deleted from the respective tables."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_customer_status_update` that accepts five parameters: an input parameter `p_customer_id` of type NUMBER to identify a customer, an input parameter `p_new_status` of type VARCHAR2 to specify a desired status, an input parameter `p_threshold` of type NUMBER to define a financial limit, an output parameter `p_updated_rows` of type NUMBER to return the count of rows modified, and an output parameter `p_message` of type VARCHAR2 to provide a descriptive result message. The procedure begins by selecting the `AMOUNT_OUTSTANDING` column value from the `CUSTOMERS` table for the row where the `CUSTOMER_ID` column matches the input `p_customer_id` and stores this value into a local variable `v_outstanding`. It then evaluates a conditional statement: if the retrieved `v_outstanding` value is greater than the input `p_threshold` value, it executes an update on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the literal string 'Bad Customer' for the row where `CUSTOMER_ID` equals `p_customer_id`, assigns the number of rows affected by this update (using `SQL%ROWCOUNT`) to the output parameter `p_updated_rows`, and sets the output parameter `p_message` to the string 'Status updated to Bad Customer due to high outstanding amount.'. If the condition is not met (i.e., `v_outstanding` is less than or equal to `p_threshold`), the procedure executes a different update on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the value of the input parameter `p_new_status` for the row where `CUSTOMER_ID` equals `p_customer_id`, assigns the row count from this update to `p_updated_rows`, and sets `p_message` to the string 'Status updated to specified value.'.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_customer_status_update(p_customer_id IN NUMBER, p_new_status IN VARCHAR2, p_threshold IN NUMBER, p_updated_rows OUT NUMBER, p_message OUT VARCHAR2)\nIS\n    v_outstanding NUMBER;\nBEGIN\n    SELECT AMOUNT_OUTSTANDING INTO v_outstanding FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    IF v_outstanding > p_threshold THEN\n        UPDATE CUSTOMERS SET CUSTOMER_STATUS_CODE = 'Bad Customer' WHERE CUSTOMER_ID = p_customer_id;\n        p_updated_rows := SQL%ROWCOUNT;\n        p_message := 'Status updated to Bad Customer due to high outstanding amount.';\n    ELSE\n        UPDATE CUSTOMERS SET CUSTOMER_STATUS_CODE = p_new_status WHERE CUSTOMER_ID = p_customer_id;\n        p_updated_rows := SQL%ROWCOUNT;\n        p_message := 'Status updated to specified value.';\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(1, 'Good Customer', 500, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(3, 'Regular Customer', 1000, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(4, 'VIP Customer', 2000, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(1, 'Preferred Customer', 300, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;",
      "DECLARE\n  v_updated_rows NUMBER;\n  v_message VARCHAR2(255);\nBEGIN\n  proc_customer_status_update(3, 'New Customer', 5000, v_updated_rows, v_message);\n  DBMS_OUTPUT.PUT_LINE(v_message);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_customer_status_update` that updates a customer's status in the `CUSTOMERS` table. It takes a customer ID, a new status, and a financial threshold as input. If the customer's outstanding amount exceeds the threshold, set their status to 'Bad Customer'. Otherwise, set it to the provided new status. Return the number of updated rows and a descriptive message.",
    "natural_language": "Write a stored procedure called `proc_customer_status_update` to update a customer's status in the `CUSTOMERS` table. Provide a customer ID, a new status, and a financial threshold. If the customer's outstanding amount is above the threshold, mark their status as 'Bad Customer'. If not, set it to the given new status. Return the count of updated rows along with a descriptive message.",
    "id": 42,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `proc_customer_status_update` that accepts five parameters: an input parameter `p_customer_id` of type NUMBER to identify a customer, an input parameter `p_new_status` of type VARCHAR2 to specify a desired status, an input parameter `p_threshold` of type NUMBER to define a financial limit, an output parameter `p_updated_rows` of type NUMBER to return the count of rows modified, and an output parameter `p_message` of type VARCHAR2 to provide a descriptive result message. The procedure begins by selecting the `AMOUNT_OUTSTANDING` column value from the `CUSTOMERS` table for the row where the `CUSTOMER_ID` column matches the input `p_customer_id` and stores this value into a local variable `v_outstanding`. It then evaluates a conditional statement: if the retrieved `v_outstanding` value is greater than the input `p_threshold` value, it executes an update on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the literal string 'Bad Customer' for the row where `CUSTOMER_ID` equals `p_customer_id`, assigns the number of rows affected by this update (using `SQL%ROWCOUNT`) to the output parameter `p_updated_rows`, and sets the output parameter `p_message` to the string 'Status updated to Bad Customer due to high outstanding amount.'. If the condition is not met (i.e., `v_outstanding` is less than or equal to `p_threshold`), the procedure executes a different update on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the value of the input parameter `p_new_status` for the row where `CUSTOMER_ID` equals `p_customer_id`, assigns the row count from this update to `p_updated_rows`, and sets `p_message` to the string 'Status updated to specified value.'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_device_quantity` that accepts two input parameters: `device_id_val` of data type `NUMBER` which represents the unique identifier of a device, and `new_quantity` of data type `NUMBER` which represents the new quantity to be assigned to the device. The procedure performs a single `UPDATE` operation on the `STOCK` table. This `UPDATE` operation sets the value of the `QUANTITY` column to the value provided by the `new_quantity` parameter. The `UPDATE` operation is conditional, applying only to those rows in the `STOCK` table where the value in the `DEVICE_ID` column exactly matches the value provided by the `device_id_val` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_device_quantity(device_id_val NUMBER, new_quantity NUMBER) IS\nBEGIN\n  UPDATE STOCK SET QUANTITY = new_quantity WHERE DEVICE_ID = device_id_val;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "BEGIN\n  update_device_quantity(1, 150);\nEND;",
      "BEGIN\n  update_device_quantity(2, 200);\nEND;",
      "BEGIN\n  update_device_quantity(3, 50);\nEND;",
      "BEGIN\n  update_device_quantity(6, 120);\nEND;",
      "BEGIN\n  update_device_quantity(1, 100);\nEND;"
    ],
    "summary": "Create a stored procedure named `update_device_quantity` that accepts a device ID and a new quantity. Update the stock table to set the quantity to the new value for the specified device.",
    "natural_language": "Hey, can you whip up a stored procedure called `update_device_quantity`? It should take a device ID and a new stock number. Then, just go into the stock table and update the quantity to that new number for the gadget with that specific ID.",
    "id": 43,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `update_device_quantity` that accepts two input parameters: `device_id_val` of data type `NUMBER` which represents the unique identifier of a device, and `new_quantity` of data type `NUMBER` which represents the new quantity to be assigned to the device. The procedure performs a single `UPDATE` operation on the `STOCK` table. This `UPDATE` operation sets the value of the `QUANTITY` column to the value provided by the `new_quantity` parameter. The `UPDATE` operation is conditional, applying only to those rows in the `STOCK` table where the value in the `DEVICE_ID` column exactly matches the value provided by the `device_id_val` parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named INSERT_COURSE_ARRANGEMENT that accepts three input parameters: a numeric parameter P_COURSE_ID representing a course identifier, a numeric parameter P_TEACHER_ID representing a teacher identifier, and a numeric parameter P_GRADE representing a grade level. The procedure performs a conditional insert operation into the COURSE_ARRANGE table, specifically into its COURSE_ID, TEACHER_ID, and GRADE columns. The logic uses a SELECT statement from the DUAL system table to provide the source values for the insert, which are the three input parameters. This insert is executed only when a WHERE NOT EXISTS condition is satisfied. The condition checks for the absence of an existing record in the COURSE_ARRANGE table by performing a subquery that selects the constant value 1 from the same table where the COURSE_ID column equals the input P_COURSE_ID, the TEACHER_ID column equals the input P_TEACHER_ID, and the GRADE column equals the input P_GRADE. Therefore, the procedure inserts a new row with the specified course, teacher, and grade combination only if an identical combination does not already exist in the table, thereby preventing duplicate entries based on these three fields.",
    "plsql": "CREATE OR REPLACE PROCEDURE INSERT_COURSE_ARRANGEMENT(\n  P_COURSE_ID IN NUMBER,\n  P_TEACHER_ID IN NUMBER,\n  P_GRADE IN NUMBER\n) AS\nBEGIN\n  INSERT INTO COURSE_ARRANGE (COURSE_ID, TEACHER_ID, GRADE)\n  SELECT P_COURSE_ID, P_TEACHER_ID, P_GRADE\n  FROM DUAL\n  WHERE NOT EXISTS (\n    SELECT 1\n    FROM COURSE_ARRANGE\n    WHERE COURSE_ID = P_COURSE_ID\n    AND TEACHER_ID = P_TEACHER_ID\n    AND GRADE = P_GRADE\n  );\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 1, P_TEACHER_ID => 1, P_GRADE => 1);\nEND;",
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 2, P_TEACHER_ID => 3, P_GRADE => 3);\nEND;",
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 3, P_TEACHER_ID => 5, P_GRADE => 1);\nEND;",
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 1, P_TEACHER_ID => 2, P_GRADE => 5);\nEND;",
      "BEGIN\n  INSERT_COURSE_ARRANGEMENT(P_COURSE_ID => 2, P_TEACHER_ID => 1, P_GRADE => 3);\nEND;"
    ],
    "summary": "Create a stored procedure named `INSERT_COURSE_ARRANGEMENT` that inserts a new course arrangement only if it does not already exist. It accepts a course ID, a teacher ID, and a grade as input. The procedure checks the `COURSE_ARRANGE` table for an existing record with the same course, teacher, and grade combination. If no such record is found, it inserts a new row with these values.",
    "natural_language": "Create procedure INSERT_COURSE_ARRANGEMENT to add a new course arrangement if missing. Inputs: course ID, teacher ID, grade. Check COURSE_ARRANGE for duplicate. Insert if none exists.",
    "id": 44,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named INSERT_COURSE_ARRANGEMENT that accepts three input parameters: a numeric parameter P_COURSE_ID representing a course identifier, a numeric parameter P_TEACHER_ID representing a teacher identifier, and a numeric parameter P_GRADE representing a grade level. The procedure performs a conditional insert operation into the COURSE_ARRANGE table, specifically into its COURSE_ID, TEACHER_ID, and GRADE columns. The logic uses a SELECT statement from the DUAL system table to provide the source values for the insert, which are the three input parameters. This insert is executed only when a WHERE NOT EXISTS condition is satisfied. The condition checks for the absence of an existing record in the COURSE_ARRANGE table by performing a subquery that selects the constant value 1 from the same table where the COURSE_ID column equals the input P_COURSE_ID, the TEACHER_ID column equals the input P_TEACHER_ID, and the GRADE column equals the input P_GRADE. Therefore, the procedure inserts a new row with the specified course, teacher, and grade combination only if an identical combination does not already exist in the table, thereby preventing duplicate entries based on these three fields."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named archive_historical_data that accepts three parameters: p_years_back of type NUMBER, p_department_filter of type NUMBER, and p_action_flag of type VARCHAR2. The procedure begins by declaring a local variable v_cutoff_date of type VARCHAR2(255) to store a date string, and a cursor named hist_cursor that selects employee_id and start_date from the job_history table where the department_id matches the p_department_filter parameter and the start_date is earlier than v_cutoff_date. Another local variable v_new_employee_id of type NUMBER is declared to hold a new employee ID. The procedure calculates v_cutoff_date by subtracting p_years_back years from the current local timestamp using the ADD_MONTHS function and formats it as 'YYYY-MM-DD'. If the p_action_flag parameter equals 'ARCHIVE', the procedure enters a loop over the hist_cursor, generating a new unique employee_id by selecting the maximum employee_id from the employees table and adding 1. It then inserts a new row into the employees table with the generated employee_id, static values for first_name, last_name, email, phone_number, and hire_date, and values from the job_history table for job_id and department_id, setting salary, commission_pct, and manager_id to 0. The procedure deletes the corresponding row from the job_history table using the employee_id and start_date from the cursor. If the p_action_flag parameter equals 'PURGE', the procedure deletes rows from the job_history table where the department_id matches p_department_filter and the start_date is earlier than v_cutoff_date.",
    "plsql": "CREATE OR REPLACE PROCEDURE archive_historical_data(p_years_back NUMBER, p_department_filter NUMBER, p_action_flag VARCHAR2)\nIS\n    v_cutoff_date VARCHAR2(255);\n    CURSOR hist_cursor IS SELECT employee_id, start_date FROM job_history WHERE department_id = p_department_filter AND start_date < v_cutoff_date;\n    v_new_employee_id NUMBER;\nBEGIN\n    v_cutoff_date := TO_CHAR(ADD_MONTHS(LOCALTIMESTAMP, -12 * p_years_back), 'YYYY-MM-DD');\n    IF p_action_flag = 'ARCHIVE' THEN\n        FOR rec IN hist_cursor LOOP\n            -- Generate a new unique employee_id\n            SELECT MAX(employee_id) + 1 INTO v_new_employee_id FROM employees;\n            INSERT INTO employees (employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary, commission_pct, manager_id, department_id)\n            SELECT v_new_employee_id, 'ARCHIVED', 'EMPLOYEE', 'ARCHIVE', '000-000-0000', jh.start_date, jh.job_id, 0, 0, 0, jh.department_id\n            FROM job_history jh\n            WHERE jh.employee_id = rec.employee_id AND jh.start_date = rec.start_date;\n            DELETE FROM job_history WHERE employee_id = rec.employee_id AND start_date = rec.start_date;\n        END LOOP;\n    ELSIF p_action_flag = 'PURGE' THEN\n        DELETE FROM job_history WHERE department_id = p_department_filter AND start_date < v_cutoff_date;\n    END IF;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY"
    ],
    "call_sqls": [
      "BEGIN\n  archive_historical_data(5, 10, 'ARCHIVE');\n  commit;\nEND;",
      "BEGIN\n  archive_historical_data(3, 20, 'PURGE');\n  commit;\nEND;",
      "BEGIN\n  archive_historical_data(2, 30, 'ARCHIVE');\n  commit;\nEND;",
      "BEGIN\n  archive_historical_data(4, 10, 'PURGE');\n  commit;\nEND;",
      "BEGIN\n  archive_historical_data(1, 20, 'ARCHIVE');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named archive_historical_data that archives or purges historical job data. It accepts parameters for years back, department filter, and action flag. For 'ARCHIVE' action: move qualifying job_history records to employees table with new IDs and static default values, then delete from job_history. For 'PURGE' action: directly delete qualifying job_history records. Qualification is based on department match and start date older than calculated cutoff.",
    "natural_language": "Create a stored procedure called archive_historical_data to archive or purge old job data. The procedure must take parameters for the number of years back, a department filter, and an action flag. If the action is 'ARCHIVE', move the qualifying job_history records to the employees table using new IDs and static default values, then delete those records from job_history. If the action is 'PURGE', directly delete the qualifying job_history records from job_history. Determine qualification by matching the department and checking if the start date is older than the calculated cutoff date.",
    "id": 45,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named archive_historical_data in the hr_1 database. The procedure accepts three input parameters: p_years_back of type NUMBER, which specifies the number of years in the past to consider; p_department_filter of type VARCHAR2, which provides a department identifier or name for filtering; and p_action_flag of type VARCHAR2, which indicates the action to perform, either 'ARCHIVE' or 'PURGE'. The procedure declares several local variables: v_cutoff_date of type VARCHAR2 to store the calculated cutoff date; v_department_id of type NUMBER to hold the department ID derived from the filter; v_new_employee_id of type NUMBER to generate a new employee ID for archiving; and a cursor named c_qualifying_records that fetches qualifying records from the JOB_HISTORY table.\n\nThe procedure first calculates the cutoff date by subtracting p_years_back years from the current system date (SYSDATE) and converting the result to a VARCHAR2 in 'YYYY-MM-DD' format using the TO_CHAR function. It then determines the department ID by querying the DEPARTMENTS table: if p_department_filter is numeric, it attempts to match DEPARTMENT_ID; otherwise, it attempts to match DEPARTMENT_NAME. The result is stored in v_department_id. If no matching department is found, the procedure raises an application error.\n\nNext, the procedure opens the cursor c_qualifying_records, which selects all columns from the JOB_HISTORY table where DEPARTMENT_ID equals v_department_id and the START_DATE (converted to DATE using TO_DATE with 'YYYY-MM-DD' format) is less than the cutoff date (also converted to DATE). For each record fetched by the cursor, the procedure checks the p_action_flag. If p_action_flag is 'ARCHIVE', it generates a new employee ID by selecting the maximum EMPLOYEE_ID from the EMPLOYEES table and adding 1, storing it in v_new_employee_id. It then inserts a new row into the EMPLOYEES table with the following values: EMPLOYEE_ID set to v_new_employee_id; FIRST_NAME set to the literal 'Archived'; LAST_NAME set to the literal 'Record'; EMAIL set to a concatenation of 'ARCHIVED_' and v_new_employee_id; PHONE_NUMBER set to the literal '000-000-0000'; HIRE_DATE set to the current system date in 'YYYY-MM-DD' format using TO_CHAR(SYSDATE); JOB_ID set to the JOB_ID from the cursor record; SALARY set to 0; COMMISSION_PCT set to 0; MANAGER_ID set to 0; and DEPARTMENT_ID set to the DEPARTMENT_ID from the cursor record. After the insertion, it deletes the current record from the JOB_HISTORY table where EMPLOYEE_ID and START_DATE match the cursor record's values. If p_action_flag is 'PURGE', it directly deletes the current record from the JOB_HISTORY table where EMPLOYEE_ID and START_DATE match the cursor record's values. After processing all cursor records, the procedure closes the cursor. If p_action_flag is neither 'ARCHIVE' nor 'PURGE', the procedure raises an application error. The procedure does not return a value but performs data movement or deletion based on the action flag."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateReviewerRatings that accepts three input parameters: p_old_rid of type NUMBER representing the original reviewer ID, p_new_rid of type NUMBER representing the new reviewer ID, and p_min_stars of type NUMBER representing a minimum star rating threshold. The procedure first declares two local variables: v_rating_count of type NUMBER and v_new_name of type VARCHAR2 with a length of 255 characters. It begins execution by querying the RATING table to count the number of rows where the RID column equals the input parameter p_old_rid and the STARS column is greater than or equal to the input parameter p_min_stars, storing the result in v_rating_count. If the value of v_rating_count is greater than zero, the procedure proceeds to query the REVIEWER table, selecting the NAME column for the row where the RID column equals the input parameter p_new_rid, and stores this value in v_new_name. Following this, the procedure deletes all rows from the RATING table where the RID column equals p_old_rid and the STARS column is greater than or equal to p_min_stars. Subsequently, it inserts new rows into the RATING table, specifying columns RID, MID, STARS, and RATINGDATE, by selecting data from the RATING table where the RID column equals p_old_rid and the STARS column is greater than or equal to p_min_stars, but for each selected row, it uses p_new_rid as the value for the RID column in the new insert, while the MID, STARS, and RATINGDATE values are copied directly from the selected rows.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateReviewerRatings(\n    p_old_rid IN NUMBER,\n    p_new_rid IN NUMBER,\n    p_min_stars IN NUMBER\n) AS\n    v_rating_count NUMBER;\n    v_new_name VARCHAR2(255);\nBEGIN\n    SELECT COUNT(*) INTO v_rating_count \n    FROM RATING \n    WHERE RID = p_old_rid AND STARS >= p_min_stars;\n    \n    IF v_rating_count > 0 THEN\n        SELECT NAME INTO v_new_name FROM REVIEWER WHERE RID = p_new_rid;\n        \n        DELETE FROM RATING \n        WHERE RID = p_old_rid AND STARS >= p_min_stars;\n        \n        INSERT INTO RATING (RID, MID, STARS, RATINGDATE)\n        SELECT p_new_rid, MID, STARS, RATINGDATE\n        FROM RATING \n        WHERE RID = p_old_rid AND STARS >= p_min_stars;\n    END IF;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateReviewerRatings(201, 202, 3);\nEND;",
      "BEGIN\n  UpdateReviewerRatings(203, 201, 4);\nEND;",
      "BEGIN\n  UpdateReviewerRatings(202, 203, 1);\nEND;",
      "BEGIN\n  UpdateReviewerRatings(201, 202, 5);\nEND;",
      "BEGIN\n  UpdateReviewerRatings(203, 201, 2);\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateReviewerRatings to transfer ratings from one reviewer (p_old_rid) to another (p_new_rid). It transfers only ratings with stars greater than or equal to p_min_stars. First, verify the new reviewer's name exists. Then, delete the qualifying ratings for the old reviewer and insert them with the new reviewer's ID.",
    "natural_language": "Create procedure UpdateReviewerRatings to move ratings from reviewer p_old_rid to p_new_rid for ratings with at least p_min_stars. Check new reviewer exists first, then delete old ratings and insert them under the new ID.",
    "id": 46,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateReviewerRatings that accepts three input parameters: p_old_rid of type NUMBER representing the original reviewer ID, p_new_rid of type NUMBER representing the new reviewer ID, and p_min_stars of type NUMBER representing a minimum star rating threshold. The procedure first declares two local variables: v_rating_count of type NUMBER and v_new_name of type VARCHAR2 with a length of 255 characters. It begins execution by querying the RATING table to count the number of rows where the RID column equals the input parameter p_old_rid and the STARS column is greater than or equal to the input parameter p_min_stars, storing the result in v_rating_count. If the value of v_rating_count is greater than zero, the procedure proceeds to query the REVIEWER table, selecting the NAME column for the row where the RID column equals the input parameter p_new_rid, and stores this value in v_new_name. Following this, the procedure deletes all rows from the RATING table where the RID column equals p_old_rid and the STARS column is greater than or equal to p_min_stars. Subsequently, it inserts new rows into the RATING table, specifying columns RID, MID, STARS, and RATINGDATE, by selecting data from the RATING table where the RID column equals p_old_rid and the STARS column is greater than or equal to p_min_stars, but for each selected row, it uses p_new_rid as the value for the RID column in the new insert, while the MID, STARS, and RATINGDATE values are copied directly from the selected rows."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_analyze_customer_orders` that accepts three input parameters: `p_customer_id` of type `NUMBER`, `p_status_filter` of type `VARCHAR2`, and `p_min_quantity` of type `VARCHAR2`. The purpose of this procedure is to analyze customer order data based on the provided filters and then insert a new record into the `CUSTOMER_ORDERS` table categorizing the customer's order volume.\n\nFirst, the procedure declares three local variables: `v_total_orders` of type `NUMBER` to store the count of distinct orders, `v_total_items` of type `NUMBER` to store the total count of order items, and `v_avg_quantity` of type `NUMBER` to store the average order quantity.\n\nNext, the procedure executes a `SELECT` statement to calculate these aggregate values. It counts the distinct `ORDER_ID` from the `CUSTOMER_ORDERS` table, counts the `ORDER_ITEM_ID` from the `ORDER_ITEMS` table, and calculates the average of the `ORDER_QUANTITY` column from the `ORDER_ITEMS` table after explicitly converting it to a `NUMBER` using `TO_NUMBER()`. These calculated values are then stored into the `v_total_orders`, `v_total_items`, and `v_avg_quantity` variables, respectively. The `SELECT` statement joins `CUSTOMER_ORDERS` (aliased as `co`) with `ORDER_ITEMS` (aliased as `oi`) using a `LEFT JOIN` on `co.ORDER_ID = oi.ORDER_ID`. The data is filtered by three conditions in the `WHERE` clause: `co.CUSTOMER_ID` must be equal to the input parameter `p_customer_id`, `co.ORDER_STATUS_CODE` must be equal to the input parameter `p_status_filter`, and `oi.ORDER_QUANTITY` must be greater than or equal to the input parameter `p_min_quantity`.\n\nFollowing the data retrieval, the procedure enters a conditional block (`IF-ELSIF-ELSE`) to determine the type of new order record to insert into the `CUSTOMER_ORDERS` table.\n\nThe first condition checks if `v_total_orders` is greater than 0 AND `v_avg_quantity` is greater than 5. If both conditions are true, a new row is inserted into the `CUSTOMER_ORDERS` table. The `ORDER_ID` for this new record is generated by selecting the maximum existing `ORDER_ID` from `CUSTOMER_ORDERS`, using `NVL(MAX(ORDER_ID),0)` to handle cases where no orders exist (defaulting to 0), and then adding 1 to it. The `CUSTOMER_ID` is set to the input parameter `p_customer_id`. The `ORDER_DATE` is set to the current timestamp using `CURRENT_TIMESTAMP`. The `ORDER_STATUS_CODE` is set to the literal string 'HIGH_VOLUME'.\n\nThe second condition, an `ELSIF`, is evaluated if the first condition is false. It checks if `v_total_orders` is greater than 0 AND `v_avg_quantity` is less than or equal to 5. If both these conditions are true, a new row is inserted into the `CUSTOMER_ORDERS` table. Similar to the previous `IF` block, the `ORDER_ID` is generated by `(SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS)`, the `CUSTOMER_ID` is set to `p_customer_id`, the `ORDER_DATE` is set to `CURRENT_TIMESTAMP`, and the `ORDER_STATUS_CODE` is set to the literal string 'LOW_VOLUME'.\n\nFinally, if neither of the above conditions is met (i.e., `v_total_orders` is not greater than 0), the `ELSE` block is executed. In this case, a new row is inserted into the `CUSTOMER_ORDERS` table. The `ORDER_ID` is generated by `(SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS)`, the `CUSTOMER_ID` is set to `p_customer_id`, the `ORDER_DATE` is set to `CURRENT_TIMESTAMP`, and the `ORDER_STATUS_CODE` is set to the literal string 'NO_DATA'.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_analyze_customer_orders(p_customer_id IN NUMBER, p_status_filter IN VARCHAR2, p_min_quantity IN VARCHAR2)\nIS\n   v_total_orders NUMBER;\n   v_total_items NUMBER;\n   v_avg_quantity NUMBER;\nBEGIN\n   SELECT COUNT(DISTINCT co.ORDER_ID), COUNT(oi.ORDER_ITEM_ID), AVG(TO_NUMBER(oi.ORDER_QUANTITY))\n   INTO v_total_orders, v_total_items, v_avg_quantity\n   FROM CUSTOMER_ORDERS co\n   LEFT JOIN ORDER_ITEMS oi ON co.ORDER_ID = oi.ORDER_ID\n   WHERE co.CUSTOMER_ID = p_customer_id\n   AND co.ORDER_STATUS_CODE = p_status_filter\n   AND oi.ORDER_QUANTITY >= p_min_quantity;\n   \n   IF v_total_orders > 0 AND v_avg_quantity > 5 THEN\n      INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n      VALUES ((SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS), p_customer_id, CURRENT_TIMESTAMP, 'HIGH_VOLUME');\n   ELSIF v_total_orders > 0 AND v_avg_quantity <= 5 THEN\n      INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n      VALUES ((SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS), p_customer_id, CURRENT_TIMESTAMP, 'LOW_VOLUME');\n   ELSE\n      INSERT INTO CUSTOMER_ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, ORDER_STATUS_CODE)\n      VALUES ((SELECT NVL(MAX(ORDER_ID),0) + 1 FROM CUSTOMER_ORDERS), p_customer_id, CURRENT_TIMESTAMP, 'NO_DATA');\n   END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 12, p_status_filter => 'Part', p_min_quantity => '1');\nEND;",
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 3, p_status_filter => 'Part', p_min_quantity => '5');\nEND;",
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 1, p_status_filter => 'Part', p_min_quantity => '1');\nEND;",
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 12, p_status_filter => 'Completed', p_min_quantity => '1');\nEND;",
      "BEGIN\n  proc_analyze_customer_orders(p_customer_id => 99, p_status_filter => 'Pending', p_min_quantity => '1');\nEND;"
    ],
    "summary": "Create a stored procedure named proc_analyze_customer_orders that accepts a customer_id number, a status_filter string, and a min_quantity string. Calculate the total distinct orders, total items, and average quantity for the customer filtered by status and minimum quantity. Based on the results: if there are orders and average quantity > 5, insert a 'HIGH_VOLUME' order record. Else if there are orders and average quantity <= 5, insert a 'LOW_VOLUME' order record. Otherwise, insert a 'NO_DATA' order record.",
    "natural_language": "Compose a stored procedure designated as `proc_analyze_customer_orders`. This procedure shall accept three parameters: a numeric `customer_id`, a string `status_filter`, and a string `min_quantity`. Its function is to compute the total count of distinct orders, the aggregate number of items, and the mean quantity per order for the specified customer, applying filters based on order status and a minimum quantity threshold. Subsequently, based on the computed results: if orders exist and the average quantity exceeds five, the procedure must insert an order record classified as 'HIGH_VOLUME'. Alternatively, if orders exist but the average quantity is five or less, it shall insert a record classified as 'LOW_VOLUME'. In all other cases, a record classified as 'NO_DATA' must be inserted.",
    "id": 47,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `proc_analyze_customer_orders` that accepts three input parameters: `customer_id` of type `NUMBER`, `status_filter` of type `VARCHAR2`, and `min_quantity` of type `VARCHAR2`. The procedure's primary function is to analyze order data for a specific customer from the `customers_and_orders` database, compute aggregated metrics, and then conditionally insert a summary record into the `CUSTOMER_ORDERS` table based on the results.\n\nThe procedure begins by declaring three local variables: `v_distinct_order_count` of type `NUMBER` to store the count of distinct orders, `v_total_items` of type `NUMBER` to store the total sum of items, and `v_avg_quantity` of type `NUMBER` to store the calculated average quantity per order.\n\nThe core operation is a single `SELECT` statement that retrieves aggregated data from the `CUSTOMER_ORDERS` table, aliased as `co`, and the `ORDER_ITEMS` table, aliased as `oi`. The tables are joined using an `INNER JOIN` on the condition that the `ORDER_ID` column in `CUSTOMER_ORDERS` is equal to the `ORDER_ID` column in `ORDER_ITEMS`. The `WHERE` clause filters the joined dataset with three conditions: first, the `CUSTOMER_ID` column in `CUSTOMER_ORDERS` must equal the input `customer_id` parameter; second, the `ORDER_STATUS_CODE` column in `CUSTOMER_ORDERS` must equal the input `status_filter` parameter; and third, the `ORDER_QUANTITY` column in `ORDER_ITEMS`, after being converted to a number using the `TO_NUMBER` function, must be greater than or equal to the input `min_quantity` parameter after it is also converted to a number using `TO_NUMBER`. From this filtered and joined result set, the `SELECT` statement calculates three aggregate values: the count of `DISTINCT` values from the `ORDER_ID` column in `CUSTOMER_ORDERS`, the sum of the `ORDER_QUANTITY` column from `ORDER_ITEMS` (converted to a number), and the average of the `ORDER_QUANTITY` column from `ORDER_ITEMS` (converted to a number). These three calculated values are then assigned to the local variables `v_distinct_order_count`, `v_total_items`, and `v_avg_quantity`, respectively.\n\nFollowing the data retrieval and aggregation, the procedure uses an `IF-ELSIF-ELSE` control structure to determine which record to insert into the `CUSTOMER_ORDERS` table.\n\n1.  **First Condition:** It checks if `v_distinct_order_count` is greater than `0` AND `v_avg_quantity` is greater than `5`.\n    *   If this condition is true, it executes an `INSERT` statement into the `CUSTOMER_ORDERS` table. The statement provides values for the `ORDER_ID`, `CUSTOMER_ID`, `ORDER_DATE`, and `ORDER_STATUS_CODE` columns. The `ORDER_ID` is generated using the `SEQ_ORDER_ID.NEXTVAL` sequence. The `CUSTOMER_ID` is set to the input `customer_id` parameter. The `ORDER_DATE` is set to the current system date and time using `SYSDATE`. The `ORDER_STATUS_CODE` is set to the string literal `'HIGH_VOLUME'`.\n\n2.  **Second Condition:** If the first condition is false, it then checks if `v_distinct_order_count` is greater than `0` AND `v_avg_quantity` is less than or equal to `5`.\n    *   If this condition is true, it executes an `INSERT` statement into the `CUSTOMER_ORDERS` table. The statement provides values for the `ORDER_ID`, `CUSTOMER_ID`, `ORDER_DATE`, and `ORDER_STATUS_CODE` columns. The `ORDER_ID` is generated using the `SEQ_ORDER_ID.NEXTVAL` sequence. The `CUSTOMER_ID` is set to the input `customer_id` parameter. The `ORDER_DATE` is set to the current system date and time using `SYSDATE`. The `ORDER_STATUS_CODE` is set to the string literal `'LOW_VOLUME'`.\n\n3.  **Else (Default) Condition:** If neither of the preceding conditions is met (meaning `v_distinct_order_count` is `0` or the previous checks failed), the procedure executes a default `INSERT` statement.\n    *   This statement inserts a record into the `CUSTOMER_ORDERS` table. The `ORDER_ID` is generated using the `SEQ_ORDER_ID.NEXTVAL` sequence. The `CUSTOMER_ID` is set to the input `customer_id` parameter. The `ORDER_DATE` is set to the current system date and time using `SYSDATE`. The `ORDER_STATUS_CODE` is set to the string literal `'NO_DATA'`.\n\nThe procedure does not have any explicit output parameters; its result is the conditional insertion of a record into the `CUSTOMER_ORDERS` table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_owner_email that accepts two input parameters: a numeric parameter p_owner_id which specifies the unique identifier of an owner record, and a string parameter p_new_email which provides the new email address text. The procedure executes a single SQL UPDATE operation targeting the OWNERS table. It modifies the EMAIL_ADDRESS column for the specific row where the OWNER_ID column value is exactly equal to the provided p_owner_id parameter. The new value assigned to the EMAIL_ADDRESS column is the result of applying the LOWER function to the p_new_email input parameter, which converts all alphabetical characters within the email string to their lowercase equivalents before the update is performed.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_owner_email(p_owner_id NUMBER, p_new_email VARCHAR2)\nIS\nBEGIN\n   UPDATE OWNERS SET EMAIL_ADDRESS = LOWER(p_new_email) WHERE OWNER_ID = p_owner_id;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "BEGIN\n  update_owner_email(1, 'NEW_EMAIL@EXAMPLE.COM');\n  COMMIT;\nEND;",
      "BEGIN\n  update_owner_email(3, 'jaclyn.new@example.org');\n  COMMIT;\nEND;",
      "BEGIN\n  update_owner_email(4, 'tre.hamill.updated@example.net');\n  COMMIT;\nEND;",
      "BEGIN\n  update_owner_email(11, 'owner11.newemail@domain.com');\n  COMMIT;\nEND;",
      "BEGIN\n  update_owner_email(15, 'test.user@test.org');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named update_owner_email that accepts an owner ID (NUMBER) and a new email (VARCHAR2). Update the OWNERS table to set the EMAIL_ADDRESS to the lowercase version of the provided new email for the row matching the owner ID.",
    "natural_language": "How can I create a stored procedure called update_owner_email that takes an owner ID (NUMBER) and a new email (VARCHAR2) as parameters, and then updates the OWNERS table to set the EMAIL_ADDRESS to the lowercase version of the provided new email for the specific owner ID?",
    "id": 48,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_owner_email that accepts two input parameters: p_owner_id of type NUMBER to specify the owner identifier, and p_new_email of type VARCHAR2 to provide the new email address. The procedure does not declare any local variables. The procedure executes a single SQL UPDATE operation on the OWNERS table. The UPDATE statement modifies the EMAIL_ADDRESS column for the row where the OWNER_ID column equals the input parameter p_owner_id. The new value for EMAIL_ADDRESS is set to the lowercase version of the input parameter p_new_email, achieved by applying the LOWER function to p_new_email. The procedure does not contain any explicit control flow logic such as conditional statements or loops. It performs the update directly. There is no return value as it is a procedure."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_insert_party_form that accepts three parameters: para_party_id of type NUMBER, para_form_id of type NUMBER, and para_status_code of type VARCHAR2. The procedure performs an insertion operation into the PARTY_FORMS table, specifically inserting a new row with the values provided by the parameters. The PARTY_ID column is set to the value of para_party_id, the FORM_ID column is set to the value of para_form_id, and the FORM_STATUS_CODE column is set to the value of para_status_code. There are no conditional statements, function calls, or special operations involved in this procedure; it simply inserts the provided values directly into the specified columns of the PARTY_FORMS table.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_insert_party_form(para_party_id NUMBER, para_form_id NUMBER, para_status_code VARCHAR2) IS\nBEGIN\nINSERT INTO PARTY_FORMS (PARTY_ID, FORM_ID, FORM_STATUS_CODE) VALUES (para_party_id, para_form_id, para_status_code);\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_insert_party_form(1, 1, 'Completed');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_party_form(2, 2, 'Partially Completed');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_party_form(3, 3, 'Completed');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_party_form(1, 2, 'Partially Completed');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_party_form(2, 3, 'Completed');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_insert_party_form that inserts a new row into the PARTY_FORMS table using the three input parameters for PARTY_ID, FORM_ID, and FORM_STATUS_CODE.",
    "natural_language": "Create procedure sp_insert_party_form to insert into PARTY_FORMS using PARTY_ID, FORM_ID, FORM_STATUS_CODE.",
    "id": 49,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_insert_party_form that accepts three parameters: para_party_id of type NUMBER, para_form_id of type NUMBER, and para_status_code of type VARCHAR2. The procedure performs an insertion operation into the PARTY_FORMS table, specifically inserting a new row with the values provided by the parameters. The PARTY_ID column is set to the value of para_party_id, the FORM_ID column is set to the value of para_form_id, and the FORM_STATUS_CODE column is set to the value of para_status_code. There are no conditional statements, function calls, or special operations involved in this procedure; it simply inserts the provided values directly into the specified columns of the PARTY_FORMS table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_adjust_review_rank that accepts two input parameters: para_review_id of type NUMBER to identify a specific review record, and para_new_rank of type NUMBER representing a new rank value. The procedure first declares a local variable v_rank_difference of type NUMBER. It begins execution by selecting the current RANK value from the REVIEW table for the row where the REVIEW_ID column equals the para_review_id parameter, subtracting para_new_rank from it, and storing the result into v_rank_difference. If v_rank_difference is greater than zero, meaning the current rank is higher than the new rank, the procedure updates the REVIEW table, setting the RANK column to para_new_rank for the row where REVIEW_ID equals para_review_id. If v_rank_difference is not greater than zero, the procedure deletes the row from the REVIEW table where both REVIEW_ID equals para_review_id and the current RANK column value is less than para_new_rank. Following this conditional logic, the procedure checks if para_new_rank is less than 10; if true, it updates the REVIEW table by incrementing the READERS_IN_MILLION column by one for the row where REVIEW_ID equals para_review_id and the current RANK column value is less than 10. Finally, the procedure checks if para_new_rank is greater than 50; if true, it deletes the row from the REVIEW table where both REVIEW_ID equals para_review_id and the current RANK column value is greater than 50.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_adjust_review_rank(para_review_id NUMBER, para_new_rank NUMBER) IS\n  v_rank_difference NUMBER;\nBEGIN\n  SELECT RANK - para_new_rank INTO v_rank_difference FROM REVIEW WHERE REVIEW_ID = para_review_id;\n  \n  IF v_rank_difference > 0 THEN\n    UPDATE REVIEW SET RANK = para_new_rank WHERE REVIEW_ID = para_review_id;\n  ELSE\n    DELETE FROM REVIEW WHERE REVIEW_ID = para_review_id AND RANK < para_new_rank;\n  END IF;\n  \n  IF para_new_rank < 10 THEN\n    UPDATE REVIEW SET READERS_IN_MILLION = READERS_IN_MILLION + 1 WHERE REVIEW_ID = para_review_id AND RANK < 10;\n  END IF;\n  \n  IF para_new_rank > 50 THEN\n    DELETE FROM REVIEW WHERE REVIEW_ID = para_review_id AND RANK > 50;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp_adjust_review_rank(1, 15);\n  commit;\nEND;",
      "BEGIN\n  sp_adjust_review_rank(2, 5);\n  commit;\nEND;",
      "BEGIN\n  sp_adjust_review_rank(3, 55);\n  commit;\nEND;",
      "BEGIN\n  sp_adjust_review_rank(1, 8);\n  commit;\nEND;",
      "BEGIN\n  sp_adjust_review_rank(2, 45);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_adjust_review_rank that accepts a review ID and a new rank. Calculate the difference between the current and new rank. If the current rank is higher, update to the new rank. Otherwise, delete the review if its current rank is lower than the new rank. If the new rank is below 10, increment the reader count for that review if its current rank is below 10. If the new rank is above 50, delete the review if its current rank is above 50.",
    "natural_language": "Develop a stored procedure, which should be named sp_adjust_review_rank, that is designed to accept two distinct input parameters: a specific review ID and a proposed new rank value. Within this procedure, first compute the precise numerical difference between the review's existing, current rank and the provided new rank. Should the evaluation determine that the current rank is definitively higher than the new rank, proceed to update the review's record to reflect the new, lower rank. Conversely, if the analysis reveals that the current rank is unfortunately lower than the new rank, then the procedure must execute a complete deletion of that particular review entry. Furthermore, incorporate an additional conditional check: if the newly specified rank falls demonstrably below the threshold of 10, then the reader count associated with that review must be carefully incremented, but only under the condition that the review's current rank is also already below 10. Finally, implement a separate rule stating that if the newly proposed rank is significantly above 50, the procedure should delete the review, but this action is contingent upon the review's current rank also being above 50.",
    "id": 50,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_adjust_review_rank that accepts two input parameters: para_review_id of type NUMBER to identify a specific review record, and para_new_rank of type NUMBER representing a new rank value. The procedure first declares a local variable v_rank_difference of type NUMBER. It begins execution by selecting the current RANK value from the REVIEW table for the row where the REVIEW_ID column equals the para_review_id parameter, subtracting para_new_rank from it, and storing the result into v_rank_difference. If v_rank_difference is greater than zero, meaning the current rank is higher than the new rank, the procedure updates the REVIEW table, setting the RANK column to para_new_rank for the row where REVIEW_ID equals para_review_id. If v_rank_difference is not greater than zero, the procedure deletes the row from the REVIEW table where both REVIEW_ID equals para_review_id and the current RANK column value is less than para_new_rank. Following this conditional logic, the procedure checks if para_new_rank is less than 10; if true, it updates the REVIEW table by incrementing the READERS_IN_MILLION column by one for the row where REVIEW_ID equals para_review_id and the current RANK column value is less than 10. Finally, the procedure checks if para_new_rank is greater than 50; if true, it deletes the row from the REVIEW table where both REVIEW_ID equals para_review_id and the current RANK column value is greater than 50."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `transform_architect_data` that accepts three input parameters: `p_transformation_mode` of type `NUMBER`, `p_nationality_filter` of type `VARCHAR2`, and `p_name_modifier` of type `VARCHAR2`.\n\nThe procedure begins by declaring four local variables: `v_architect_exists` of type `NUMBER`, `v_name_length_avg` of type `NUMBER`, `v_nationality_count` of type `NUMBER`, and `v_gender_distribution` of type `NUMBER`.\n\nNext, it performs four initial `SELECT` operations:\n1. It queries the `ARCHITECT` table to count the number of rows where the `NATIONALITY` column matches the value provided in `p_nationality_filter`. The result of this count is stored in the `v_architect_exists` variable.\n2. It calculates the average length of all `NAME` values in the `ARCHITECT` table using the `LENGTH()` function. This average length is stored in the `v_name_length_avg` variable.\n3. It counts the number of distinct `NATIONALITY` values present in the `ARCHITECT` table. This count is stored in the `v_nationality_count` variable.\n4. It counts the number of distinct `GENDER` values present in the `ARCHITECT` table. This count is stored in the `v_gender_distribution` variable.\n\nFollowing these initial data retrievals, the procedure enters a conditional block based on the value of `p_transformation_mode`:\n\n**If `p_transformation_mode` is equal to 1:**\n    * It checks if `v_architect_exists` is greater than 0.\n        * If true (meaning architects with the specified nationality exist), it updates the `ARCHITECT` table. For all rows where the `NATIONALITY` column matches `p_nationality_filter`, the `NAME` column is modified by prepending the value of `p_name_modifier` followed by a space to the existing `NAME`.\n        * If false (meaning no architects with the specified nationality exist), it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_1_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Transformed'. The `NATIONALITY` column is set to `p_nationality_filter`. The `GENDER` column is set to 'male'.\n\n**Else if `p_transformation_mode` is equal to 2:**\n    * It checks if `v_name_length_avg` is greater than 15.\n        * If true, it deletes rows from the `ARCHITECT` table where the length of the `NAME` column (calculated using `LENGTH(NAME)`) is greater than `v_name_length_avg` AND the `NATIONALITY` column matches `p_nationality_filter`.\n        * If false, it updates the `ARCHITECT` table. For all rows where the length of the `NAME` column (calculated using `LENGTH(NAME)`) is less than `v_name_length_avg`, the `NATIONALITY` column is modified by appending '_Extended' to its current value, which is `p_nationality_filter`.\n\n**Else if `p_transformation_mode` is equal to 3:**\n    * It checks if `v_nationality_count` is greater than 3.\n        * If true, it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_3_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Diverse'. The `NATIONALITY` column is set to 'Multinational'. The `GENDER` column is set to 'female'.\n        * If false, it deletes rows from the `ARCHITECT` table where the `NATIONALITY` column is NOT present in the set of the first two distinct nationalities found in the `ARCHITECT` table (determined by `SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2`).\n\n**Else if `p_transformation_mode` is equal to 4:**\n    * It checks if `v_gender_distribution` is equal to 2.\n        * If true, it updates the `ARCHITECT` table. For all rows where the `NATIONALITY` column matches `p_nationality_filter`, the `NAME` column is modified by converting its value to initial capital letters using the `INITCAP()` function.\n        * If false, it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_4_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Gender Balanced'. The `NATIONALITY` column is set to `p_nationality_filter`. The `GENDER` column is set to 'female'.\n\n**Else (if `p_transformation_mode` does not match any of the above values):**\n    * It deletes rows from the `ARCHITECT` table where the `ID` column is NOT present in the set of the first three `ID` values found in the `ARCHITECT` table (determined by `SELECT ID FROM ARCHITECT WHERE ROWNUM <= 3`).",
    "plsql": "CREATE OR REPLACE PROCEDURE transform_architect_data(\n    p_transformation_mode NUMBER,\n    p_nationality_filter VARCHAR2,\n    p_name_modifier VARCHAR2\n) IS\n    v_architect_exists NUMBER;\n    v_name_length_avg NUMBER;\n    v_nationality_count NUMBER;\n    v_gender_distribution NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_architect_exists FROM ARCHITECT WHERE NATIONALITY = p_nationality_filter;\n    SELECT AVG(LENGTH(NAME)) INTO v_name_length_avg FROM ARCHITECT;\n    SELECT COUNT(DISTINCT NATIONALITY) INTO v_nationality_count FROM ARCHITECT;\n    SELECT COUNT(DISTINCT GENDER) INTO v_gender_distribution FROM ARCHITECT;\n    \n    IF p_transformation_mode = 1 THEN\n        IF v_architect_exists > 0 THEN\n            UPDATE ARCHITECT SET NAME = p_name_modifier || ' ' || NAME WHERE NATIONALITY = p_nationality_filter;\n        ELSE\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('TRANS_1_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_modifier || ' Transformed', p_nationality_filter, 'male');\n        END IF;\n    ELSIF p_transformation_mode = 2 THEN\n        IF v_name_length_avg > 15 THEN\n            DELETE FROM ARCHITECT WHERE LENGTH(NAME) > v_name_length_avg AND NATIONALITY = p_nationality_filter;\n        ELSE\n            UPDATE ARCHITECT SET NATIONALITY = p_nationality_filter || '_Extended' WHERE LENGTH(NAME) < v_name_length_avg;\n        END IF;\n    ELSIF p_transformation_mode = 3 THEN\n        IF v_nationality_count > 3 THEN\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('TRANS_3_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_modifier || ' Diverse', 'Multinational', 'female');\n        ELSE\n            DELETE FROM ARCHITECT WHERE NATIONALITY NOT IN (SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2);\n        END IF;\n    ELSIF p_transformation_mode = 4 THEN\n        IF v_gender_distribution = 2 THEN\n            UPDATE ARCHITECT SET NAME = INITCAP(NAME) WHERE NATIONALITY = p_nationality_filter;\n        ELSE\n            INSERT INTO ARCHITECT (ID, NAME, NATIONALITY, GENDER) \n            VALUES ('TRANS_4_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS'), p_name_modifier || ' Gender Balanced', p_nationality_filter, 'female');\n        END IF;\n    ELSE\n        DELETE FROM ARCHITECT WHERE ID NOT IN (SELECT ID FROM ARCHITECT WHERE ROWNUM <= 3);\n    END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT"
    ],
    "call_sqls": [
      "BEGIN\n  transform_architect_data(1, 'American', 'Arch.');\n  COMMIT;\nEND;",
      "BEGIN\n  transform_architect_data(2, 'Canadian', 'TestName');\n  COMMIT;\nEND;",
      "BEGIN\n  transform_architect_data(3, 'Iraqi, British', 'Diverse');\n  COMMIT;\nEND;",
      "BEGIN\n  transform_architect_data(4, 'French', 'Balanced');\n  COMMIT;\nEND;",
      "BEGIN\n  transform_architect_data(5, 'German', 'Cleanup');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named transform_architect_data with parameters for transformation mode (p_transformation_mode), nationality filter (p_nationality_filter), and name modifier (p_name_modifier). It calculates initial statistics: count of architects by nationality, average name length, count of distinct nationalities, and count of distinct genders. Based on the mode: Mode 1: If architects with the filtered nationality exist, prepend the name modifier to their names; otherwise, insert a new 'Transformed' male architect. Mode 2: If average name length > 15, delete architects with long names matching the nationality; otherwise, append '_Extended' to the nationality for architects with short names. Mode 3: If distinct nationalities > 3, insert a new 'Diverse' female 'Multinational' architect; otherwise, delete architects whose nationality is not among the top two. Mode 4: If distinct genders = 2, apply INITCAP to names of architects matching the nationality; otherwise, insert a new 'Gender Balanced' female architect. For any other mode, delete all architects except the first three.",
    "natural_language": "Create procedure transform_architect_data with params p_transformation_mode, p_nationality_filter, p_name_modifier. Compute stats: architect count by nationality, average name length, distinct nationality count, distinct gender count. Mode 1: If filtered nationality exists, prepend modifier to names; else insert new 'Transformed' male architect. Mode 2: If avg name length > 15, delete long-name architects of that nationality; else append '_Extended' to nationality for short-name architects. Mode 3: If distinct nationalities > 3, insert new 'Diverse' female 'Multinational' architect; else delete architects not in top two nationalities. Mode 4: If distinct genders = 2, apply INITCAP to names of matching nationality; else insert new 'Gender Balanced' female architect. Any other mode: delete all except first three architects.",
    "id": 51,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `transform_architect_data` that accepts three input parameters: `p_transformation_mode` of type `NUMBER`, `p_nationality_filter` of type `VARCHAR2`, and `p_name_modifier` of type `VARCHAR2`.\n\nThe procedure begins by declaring four local variables: `v_architect_exists` of type `NUMBER`, `v_name_length_avg` of type `NUMBER`, `v_nationality_count` of type `NUMBER`, and `v_gender_distribution` of type `NUMBER`.\n\nNext, it performs four initial `SELECT` operations:\n1. It queries the `ARCHITECT` table to count the number of rows where the `NATIONALITY` column matches the value provided in `p_nationality_filter`. The result of this count is stored in the `v_architect_exists` variable.\n2. It calculates the average length of all `NAME` values in the `ARCHITECT` table using the `LENGTH()` function. This average length is stored in the `v_name_length_avg` variable.\n3. It counts the number of distinct `NATIONALITY` values present in the `ARCHITECT` table. This count is stored in the `v_nationality_count` variable.\n4. It counts the number of distinct `GENDER` values present in the `ARCHITECT` table. This count is stored in the `v_gender_distribution` variable.\n\nFollowing these initial data retrievals, the procedure enters a conditional block based on the value of `p_transformation_mode`:\n\n**If `p_transformation_mode` is equal to 1:**\n    * It checks if `v_architect_exists` is greater than 0.\n        * If true (meaning architects with the specified nationality exist), it updates the `ARCHITECT` table. For all rows where the `NATIONALITY` column matches `p_nationality_filter`, the `NAME` column is modified by prepending the value of `p_name_modifier` followed by a space to the existing `NAME`.\n        * If false (meaning no architects with the specified nationality exist), it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_1_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Transformed'. The `NATIONALITY` column is set to `p_nationality_filter`. The `GENDER` column is set to 'male'.\n\n**Else if `p_transformation_mode` is equal to 2:**\n    * It checks if `v_name_length_avg` is greater than 15.\n        * If true, it deletes rows from the `ARCHITECT` table where the length of the `NAME` column (calculated using `LENGTH(NAME)`) is greater than `v_name_length_avg` AND the `NATIONALITY` column matches `p_nationality_filter`.\n        * If false, it updates the `ARCHITECT` table. For all rows where the length of the `NAME` column (calculated using `LENGTH(NAME)`) is less than `v_name_length_avg`, the `NATIONALITY` column is modified by appending '_Extended' to its current value, which is `p_nationality_filter`.\n\n**Else if `p_transformation_mode` is equal to 3:**\n    * It checks if `v_nationality_count` is greater than 3.\n        * If true, it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_3_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Diverse'. The `NATIONALITY` column is set to 'Multinational'. The `GENDER` column is set to 'female'.\n        * If false, it deletes rows from the `ARCHITECT` table where the `NATIONALITY` column is NOT present in the set of the first two distinct nationalities found in the `ARCHITECT` table (determined by `SELECT DISTINCT NATIONALITY FROM ARCHITECT WHERE ROWNUM <= 2`).\n\n**Else if `p_transformation_mode` is equal to 4:**\n    * It checks if `v_gender_distribution` is equal to 2.\n        * If true, it updates the `ARCHITECT` table. For all rows where the `NATIONALITY` column matches `p_nationality_filter`, the `NAME` column is modified by converting its value to initial capital letters using the `INITCAP()` function.\n        * If false, it inserts a new row into the `ARCHITECT` table. The `ID` column is set to a concatenated string consisting of 'TRANS_4_', followed by the current system date and time formatted as 'YYYYMMDDHH24MISS' using `TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')`. The `NAME` column is set to the value of `p_name_modifier` concatenated with ' Gender Balanced'. The `NATIONALITY` column is set to `p_nationality_filter`. The `GENDER` column is set to 'female'.\n\n**Else (if `p_transformation_mode` does not match any of the above values):**\n    * It deletes rows from the `ARCHITECT` table where the `ID` column is NOT present in the set of the first three `ID` values found in the `ARCHITECT` table (determined by `SELECT ID FROM ARCHITECT WHERE ROWNUM <= 3`)."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_process_customer_data` that accepts three input parameters: a numeric `p_customer_id`, a string `p_new_name`, and a string `p_new_phone`. The procedure first declares local variables `v_current_name`, `v_current_phone`, and `v_truncated_phone`, each capable of holding up to 255 characters. It begins execution by using the `SUBSTRB` function to assign the first 255 bytes of the input parameter `p_new_phone` to the variable `v_truncated_phone`. It then performs a `SELECT` statement on the `CUSTOMERS` table to retrieve the existing `CUSTOMER_NAME` and `CUSTOMER_PHONE` columns for the row where the `CUSTOMER_ID` column matches the input parameter `p_customer_id`, storing these values into the local variables `v_current_name` and `v_current_phone`. The procedure uses a complex conditional `IF` statement to determine which, if any, columns to update. The condition checks for inequality between the current and new values while also handling `NULL` comparisons: it evaluates whether both the name and the truncated phone number are different from their current values (accounting for `NULL` states). If this compound condition is true, it executes an `UPDATE` statement on the `CUSTOMERS` table for the matching `CUSTOMER_ID`, setting both the `CUSTOMER_NAME` column to `p_new_name` and the `CUSTOMER_PHONE` column to `v_truncated_phone`. If only the name condition is met (the current name differs from `p_new_name` or one is `NULL` while the other is not), it executes an `UPDATE` statement that sets only the `CUSTOMER_NAME` column to `p_new_name` for the target customer. If only the phone condition is met (the current phone differs from `v_truncated_phone` or one is `NULL` while the other is not), it executes an `UPDATE` statement that sets only the `CUSTOMER_PHONE` column to `v_truncated_phone` for the target customer. The procedure includes an `EXCEPTION` handler that catches the `NO_DATA_FOUND` exception, which occurs if the initial `SELECT` statement finds no matching customer, and in that case, it uses `DBMS_OUTPUT.PUT_LINE` to display a message stating the customer ID was not found; for any other exceptions, it uses the `RAISE` statement to re-raise the error to the calling program.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_process_customer_data(p_customer_id IN NUMBER, p_new_name IN VARCHAR2, p_new_phone IN VARCHAR2)\nIS\n    v_current_name VARCHAR2(255);\n    v_current_phone VARCHAR2(255);\n    v_truncated_phone VARCHAR2(255);\nBEGIN\n    v_truncated_phone := SUBSTRB(p_new_phone, 1, 255);\n    \n    SELECT CUSTOMER_NAME, CUSTOMER_PHONE INTO v_current_name, v_current_phone\n    FROM CUSTOMERS WHERE CUSTOMER_ID = p_customer_id;\n    \n    IF (v_current_name != p_new_name OR (v_current_name IS NULL AND p_new_name IS NOT NULL) OR (v_current_name IS NOT NULL AND p_new_name IS NULL))\n       AND (v_current_phone != v_truncated_phone OR (v_current_phone IS NULL AND v_truncated_phone IS NOT NULL) OR (v_current_phone IS NOT NULL AND v_truncated_phone IS NULL)) THEN\n        UPDATE CUSTOMERS\n        SET CUSTOMER_NAME = p_new_name,\n            CUSTOMER_PHONE = v_truncated_phone\n        WHERE CUSTOMER_ID = p_customer_id;\n    ELSIF v_current_name != p_new_name OR (v_current_name IS NULL AND p_new_name IS NOT NULL) OR (v_current_name IS NOT NULL AND p_new_name IS NULL) THEN\n        UPDATE CUSTOMERS\n        SET CUSTOMER_NAME = p_new_name\n        WHERE CUSTOMER_ID = p_customer_id;\n    ELSIF v_current_phone != v_truncated_phone OR (v_current_phone IS NULL AND v_truncated_phone IS NOT NULL) OR (v_current_phone IS NOT NULL AND v_truncated_phone IS NULL) THEN\n        UPDATE CUSTOMERS\n        SET CUSTOMER_PHONE = v_truncated_phone\n        WHERE CUSTOMER_ID = p_customer_id;\n    END IF;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        DBMS_OUTPUT.PUT_LINE('Customer ID ' || p_customer_id || ' not found.');\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n    proc_process_customer_data(1, 'Jeromy Updated', '1-968-453-3485');\n    COMMIT;\nEND;",
      "BEGIN\n    proc_process_customer_data(4, 'Madelynn', '1-909-419-5704');\n    COMMIT;\nEND;",
      "BEGIN\n    proc_process_customer_data(5, 'Nya Newname', NULL);\n    COMMIT;\nEND;",
      "BEGIN\n    proc_process_customer_data(1, NULL, '555-123-4567');\n    COMMIT;\nEND;",
      "BEGIN\n    proc_process_customer_data(999, 'NonExistent', '000-000-0000');\n    COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `proc_process_customer_data` that accepts a customer ID, a new name, and a new phone number. It retrieves the customer's current name and phone. It then conditionally updates the CUSTOMERS table: updating both fields if both differ, or only the name or phone if only one differs. It handles NULL comparisons and outputs a message if the customer is not found.",
    "natural_language": "Make a stored procedure called `proc_process_customer_data` that takes a customer ID, a name, and a phone number. It should get the customer's current details. Then, if the new info is somewhat different from the old, update the CUSTOMERS table accordinglyâ€”maybe update both, or just one if only that part changed. Handle cases where things might be NULL. Also, if the customer isn't really found, show a message about it.",
    "id": 52,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `proc_process_customer_data` that accepts three input parameters: a numeric `p_customer_id`, a string `p_new_name`, and a string `p_new_phone`. The procedure first declares local variables `v_current_name`, `v_current_phone`, and `v_truncated_phone`, each capable of holding up to 255 characters. It begins execution by using the `SUBSTRB` function to assign the first 255 bytes of the input parameter `p_new_phone` to the variable `v_truncated_phone`. It then performs a `SELECT` statement on the `CUSTOMERS` table to retrieve the existing `CUSTOMER_NAME` and `CUSTOMER_PHONE` columns for the row where the `CUSTOMER_ID` column matches the input parameter `p_customer_id`, storing these values into the local variables `v_current_name` and `v_current_phone`. The procedure uses a complex conditional `IF` statement to determine which, if any, columns to update. The condition checks for inequality between the current and new values while also handling `NULL` comparisons: it evaluates whether both the name and the truncated phone number are different from their current values (accounting for `NULL` states). If this compound condition is true, it executes an `UPDATE` statement on the `CUSTOMERS` table for the matching `CUSTOMER_ID`, setting both the `CUSTOMER_NAME` column to `p_new_name` and the `CUSTOMER_PHONE` column to `v_truncated_phone`. If only the name condition is met (the current name differs from `p_new_name` or one is `NULL` while the other is not), it executes an `UPDATE` statement that sets only the `CUSTOMER_NAME` column to `p_new_name` for the target customer. If only the phone condition is met (the current phone differs from `v_truncated_phone` or one is `NULL` while the other is not), it executes an `UPDATE` statement that sets only the `CUSTOMER_PHONE` column to `v_truncated_phone` for the target customer. The procedure includes an `EXCEPTION` handler that catches the `NO_DATA_FOUND` exception, which occurs if the initial `SELECT` statement finds no matching customer, and in that case, it uses `DBMS_OUTPUT.PUT_LINE` to display a message stating the customer ID was not found; for any other exceptions, it uses the `RAISE` statement to re-raise the error to the calling program."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `calculate_treatment_costs` that accepts two input parameters: `p_dog_id` of data type `NUMBER`, representing the unique identifier of a dog, and `p_professional_id` of data type `NUMBER`, representing the unique identifier of a professional. The procedure begins by declaring a local variable `v_total_cost` of data type `NUMBER` and initializing it to `0`. The core logic of the procedure involves two main operations. First, it executes a `SELECT` statement to calculate the sum of `COST_OF_TREATMENT` from the `TREATMENTS` table. This sum is then stored into the `v_total_cost` variable. The `SELECT` statement includes a `WHERE` clause that filters the `TREATMENTS` table to include only those records where the `DOG_ID` column matches the value provided in the `p_dog_id` input parameter AND the `PROFESSIONAL_ID` column matches the value provided in the `p_professional_id` input parameter. After calculating the total cost, the procedure proceeds to `INSERT` a new record into the `CHARGES` table. For the `CHARGE_ID` column, it determines the value by executing a subquery that selects the maximum existing `CHARGE_ID` from the `CHARGES` table, uses the `NVL` function to treat a `NULL` result (meaning no existing `CHARGE_ID`s) as `0`, and then adds `1` to this result to generate a new, unique identifier. The `CHARGE_TYPE` column is populated with the literal string `'Treatment Cost'`. Finally, the `CHARGE_AMOUNT` column is populated with the value stored in the `v_total_cost` variable, which represents the sum of treatment costs calculated in the preceding `SELECT` statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_treatment_costs(p_dog_id NUMBER, p_professional_id NUMBER)\nIS\n   v_total_cost NUMBER := 0;\nBEGIN\n   SELECT SUM(COST_OF_TREATMENT) INTO v_total_cost FROM TREATMENTS WHERE DOG_ID = p_dog_id AND PROFESSIONAL_ID = p_professional_id;\n   INSERT INTO CHARGES (CHARGE_ID, CHARGE_TYPE, CHARGE_AMOUNT)\n   VALUES ((SELECT NVL(MAX(CHARGE_ID),0) + 1 FROM CHARGES), 'Treatment Cost', v_total_cost);\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "BREEDS",
      "CHARGES",
      "DOGS",
      "OWNERS",
      "PROFESSIONALS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 14, p_professional_id => 9);\nEND;",
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 4, p_professional_id => 10);\nEND;",
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 14, p_professional_id => 4);\nEND;",
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 4, p_professional_id => 9);\nEND;",
      "BEGIN\n  calculate_treatment_costs(p_dog_id => 14, p_professional_id => 10);\nEND;"
    ],
    "summary": "Create a stored procedure named calculate_treatment_costs that accepts a dog ID and a professional ID (both NUMBER). Calculate the total cost by summing COST_OF_TREATMENT from the TREATMENTS table for the matching dog and professional. Insert a new record into the CHARGES table with a new CHARGE_ID (max existing ID + 1), a CHARGE_TYPE of 'Treatment Cost', and the calculated total as CHARGE_AMOUNT.",
    "natural_language": "How can I create a stored procedure named calculate_treatment_costs that takes a dog ID and a professional ID as NUMBER inputs, sums the COST_OF_TREATMENT from the TREATMENTS table for that specific dog and professional, and then inserts a new record into the CHARGES table with a new CHARGE_ID (the maximum existing ID plus one), a CHARGE_TYPE of 'Treatment Cost', and the calculated total as the CHARGE_AMOUNT?",
    "id": 53,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `calculate_treatment_costs` that accepts two input parameters: `p_dog_id` of data type `NUMBER`, representing the unique identifier of a dog, and `p_professional_id` of data type `NUMBER`, representing the unique identifier of a professional. The procedure begins by declaring a local variable `v_total_cost` of data type `NUMBER` and initializing it to `0`. The core logic of the procedure involves two main operations. First, it executes a `SELECT` statement to calculate the sum of `COST_OF_TREATMENT` from the `TREATMENTS` table. This sum is then stored into the `v_total_cost` variable. The `SELECT` statement includes a `WHERE` clause that filters the `TREATMENTS` table to include only those records where the `DOG_ID` column matches the value provided in the `p_dog_id` input parameter AND the `PROFESSIONAL_ID` column matches the value provided in the `p_professional_id` input parameter. After calculating the total cost, the procedure proceeds to `INSERT` a new record into the `CHARGES` table. For the `CHARGE_ID` column, it determines the value by executing a subquery that selects the maximum existing `CHARGE_ID` from the `CHARGES` table, uses the `NVL` function to treat a `NULL` result (meaning no existing `CHARGE_ID`s) as `0`, and then adds `1` to this result to generate a new, unique identifier. The `CHARGE_TYPE` column is populated with the literal string `'Treatment Cost'`. Finally, the `CHARGE_AMOUNT` column is populated with the value stored in the `v_total_cost` variable, which represents the sum of treatment costs calculated in the preceding `SELECT` statement."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_department_ranking that accepts two input parameters: a numeric parameter named p_ranking_limit and a numeric parameter named p_department_id, and executes a DELETE operation on the DEPARTMENT table, specifically targeting and removing rows where the DEPARTMENT_ID column value is exactly equal to the provided p_department_id parameter and, simultaneously, the RANKING column value is less than the provided p_ranking_limit parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_department_ranking(p_ranking_limit NUMBER, p_department_id NUMBER) IS\nBEGIN\n  DELETE FROM DEPARTMENT WHERE DEPARTMENT_ID = p_department_id AND RANKING < p_ranking_limit;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 2, p_department_id => 1);\nEND;",
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 3, p_department_id => 2);\nEND;",
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 1, p_department_id => 3);\nEND;",
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 5, p_department_id => 1);\nEND;",
      "BEGIN\n  sp_update_department_ranking(p_ranking_limit => 0, p_department_id => 2);\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_department_ranking that deletes rows from the DEPARTMENT table where DEPARTMENT_ID equals the input p_department_id and RANKING is less than the input p_ranking_limit.",
    "natural_language": "Hey, can you whip up a stored procedure called sp_update_department_ranking? It should clean out any rows from the DEPARTMENT table where the DEPARTMENT_ID matches the given p_department_id and the RANKING is lower than the p_ranking_limit we provide.",
    "id": 54,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_department_ranking that accepts two input parameters: a numeric parameter named p_ranking_limit and a numeric parameter named p_department_id, and executes a DELETE operation on the DEPARTMENT table, specifically targeting and removing rows where the DEPARTMENT_ID column value is exactly equal to the provided p_department_id parameter and, simultaneously, the RANKING column value is less than the provided p_ranking_limit parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes five input parameters: p_company_id (a NUMBER representing the ID of a company), p_assets_threshold (a NUMBER specifying a threshold for the assets of companies in billions), p_rank (a NUMBER indicating the rank of the company for the year), p_market_value (a NUMBER representing the market value threshold for companies), and p_station_id (a NUMBER identifying a station). The procedure performs the following operations: First, it calculates the maximum value of the SALES_BILLION column from the COMPANY table for rows where the ASSETS_BILLION column exceeds the value of p_assets_threshold and stores this maximum value in a local variable v_max_sales. Next, it deletes rows from the COMPANY table where the COMPANY_ID column matches the value of p_company_id and the MARKET_VALUE column is less than p_market_value. Then, it performs a MERGE operation on the STATION_COMPANY table using a source dataset created with the SELECT statement from the dual table, which includes the values of p_station_id as station_id, p_company_id as company_id, and p_rank as rank_of_the_year. The MERGE operation checks if a match exists between the STATION_ID and COMPANY_ID columns in the STATION_COMPANY table and the corresponding values in the source dataset. If a match is found, it updates the RANK_OF_THE_YEAR column in the STATION_COMPANY table to the value of rank_of_the_year from the source dataset. If no match is found, it inserts a new row into the STATION_COMPANY table with the values of station_id, company_id, and rank_of_the_year from the source dataset.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_company_id NUMBER, p_assets_threshold NUMBER, p_rank NUMBER, p_market_value NUMBER, p_station_id NUMBER) IS\n  v_max_sales NUMBER;\nBEGIN\n  SELECT MAX(SALES_BILLION) INTO v_max_sales FROM COMPANY WHERE ASSETS_BILLION > p_assets_threshold;\n  DELETE FROM COMPANY WHERE COMPANY_ID = p_company_id AND MARKET_VALUE < p_market_value;\n  \n  MERGE INTO STATION_COMPANY sc\n  USING (SELECT p_station_id AS station_id, p_company_id AS company_id, p_rank AS rank_of_the_year FROM dual) src\n  ON (sc.STATION_ID = src.station_id AND sc.COMPANY_ID = src.company_id)\n  WHEN MATCHED THEN\n    UPDATE SET sc.RANK_OF_THE_YEAR = src.rank_of_the_year\n  WHEN NOT MATCHED THEN\n    INSERT (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR)\n    VALUES (src.station_id, src.company_id, src.rank_of_the_year);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1, 300.0, 5, 400.0, 11);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2, 500.0, 3, 200.0, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(3, 200.0, 8, 250.0, 6);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(4, 100.0, 12, 150.0, 11);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(5, 600.0, 1, 500.0, 1);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure that accepts a company ID, assets threshold, rank, market value threshold, and station ID. It calculates the maximum sales from the COMPANY table where assets exceed the threshold. It then deletes company records where the ID matches and the market value is below the threshold. Finally, it merges data into the STATION_COMPANY table, updating the rank if a matching station-company pair exists, or inserting a new record otherwise.",
    "natural_language": "Can you create a stored procedure that takes a company ID, an assets threshold, a rank, a market value threshold, and a station ID? It should first determine the maximum sales from the COMPANY table for entries where assets are above the given threshold. Then, it must delete any company records where the company ID matches the input and the market value is below the specified threshold. Finally, can it merge data into the STATION_COMPANY table so that it updates the rank for an existing station-company pair or inserts a new record if no match is found?",
    "id": 55,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that accepts five input parameters: a company ID of type NUMBER, an assets threshold of type NUMBER, a rank of type NUMBER, a market value threshold of type NUMBER, and a station ID of type NUMBER. The procedure operates on the gas_company database and involves three main operations.\n\nFirst, the procedure declares a local variable max_sales of type NUMBER to store the result of a SELECT query. It executes a SELECT statement that retrieves the maximum value from the SALES_BILLION column in the COMPANY table, considering only rows where the ASSETS_BILLION column is greater than the input assets threshold parameter.\n\nSecond, the procedure performs a DELETE operation on the COMPANY table. It deletes rows where the COMPANY_ID column exactly matches the input company ID parameter and the MARKET_VALUE column is less than the input market value threshold parameter.\n\nThird, the procedure executes a MERGE operation on the STATION_COMPANY table. The MERGE uses the input station ID and company ID parameters as the matching keys. Specifically, it attempts to match rows where the STATION_ID column equals the input station ID and the COMPANY_ID column equals the input company ID. If a matching row is found, the MERGE performs an UPDATE, setting the RANK_OF_THE_YEAR column to the input rank parameter. If no matching row is found, the MERGE performs an INSERT, creating a new record with the input station ID for the STATION_ID column, the input company ID for the COMPANY_ID column, and the input rank for the RANK_OF_THE_YEAR column.\n\nThe procedure does not return any value."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `adjust_employee_count` that accepts two input parameters: `p_dept_id` of data type `NUMBER`, which represents the unique identifier for a department, and `p_factor` of data type `NUMBER`, which represents a multiplicative factor to be applied to the current number of employees. The procedure begins by declaring a local variable `v_current_employees` of data type `NUMBER` to temporarily store the retrieved employee count. It then executes a `SELECT` statement to retrieve the value from the `NUM_EMPLOYEES` column of the `DEPARTMENT` table. This retrieved value is stored into the `v_current_employees` variable. The selection is constrained by a `WHERE` clause, ensuring that only the row where the `DEPARTMENT_ID` column matches the value provided in the `p_dept_id` input parameter is considered. Following this, the procedure performs an `UPDATE` operation on the `DEPARTMENT` table. In this update, the `NUM_EMPLOYEES` column is set to a new value. This new value is calculated by multiplying the `v_current_employees` variable (which holds the original number of employees for the specified department) by the `p_factor` input parameter, and then rounding the result to the nearest whole number using the `ROUND` function. This update is also constrained by a `WHERE` clause, ensuring that only the row where the `DEPARTMENT_ID` column matches the value provided in the `p_dept_id` input parameter is modified.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_employee_count(p_dept_id NUMBER, p_factor NUMBER)\nIS\n    v_current_employees NUMBER;\nBEGIN\n    SELECT NUM_EMPLOYEES INTO v_current_employees\n    FROM DEPARTMENT\n    WHERE DEPARTMENT_ID = p_dept_id;\n    \n    UPDATE DEPARTMENT\n    SET NUM_EMPLOYEES = ROUND(v_current_employees * p_factor)\n    WHERE DEPARTMENT_ID = p_dept_id;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_employee_count(1, 1.1);\nEND;",
      "BEGIN\n  adjust_employee_count(2, 0.9);\nEND;",
      "BEGIN\n  adjust_employee_count(3, 1.05);\nEND;",
      "BEGIN\n  adjust_employee_count(1, 0.8);\nEND;",
      "BEGIN\n  adjust_employee_count(2, 1.2);\nEND;"
    ],
    "summary": "Create a stored procedure named adjust_employee_count that takes a department ID and a factor as input. It retrieves the current employee count for that department, multiplies it by the factor, rounds the result, and updates the NUM_EMPLOYEES column with the new value.",
    "natural_language": "Create procedure adjust_employee_count to update NUM_EMPLOYEES by multiplying current count by a factor for a given department.",
    "id": 56,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `adjust_employee_count` that accepts two input parameters: `p_dept_id` of data type `NUMBER`, which represents the unique identifier for a department, and `p_factor` of data type `NUMBER`, which represents a multiplicative factor to be applied to the current number of employees. The procedure begins by declaring a local variable `v_current_employees` of data type `NUMBER` to temporarily store the retrieved employee count. It then executes a `SELECT` statement to retrieve the value from the `NUM_EMPLOYEES` column of the `DEPARTMENT` table. This retrieved value is stored into the `v_current_employees` variable. The selection is constrained by a `WHERE` clause, ensuring that only the row where the `DEPARTMENT_ID` column matches the value provided in the `p_dept_id` input parameter is considered. Following this, the procedure performs an `UPDATE` operation on the `DEPARTMENT` table. In this update, the `NUM_EMPLOYEES` column is set to a new value. This new value is calculated by multiplying the `v_current_employees` variable (which holds the original number of employees for the specified department) by the `p_factor` input parameter, and then rounding the result to the nearest whole number using the `ROUND` function. This update is also constrained by a `WHERE` clause, ensuring that only the row where the `DEPARTMENT_ID` column matches the value provided in the `p_dept_id` input parameter is modified."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_director_birth_year that accepts two input parameters: para_did of type NUMBER, which represents a director's identifier, and para_year of type NUMBER, which represents a birth year value. The procedure performs conditional logic on the DIRECTOR table based on the value of para_year. First, it checks if para_year is divisible by 4 using the MOD function; if MOD(para_year, 4) equals 0, it executes an UPDATE statement on the DIRECTOR table, setting the BIRTH_YEAR column to the value of para_year for the specific row where the DID column matches the input parameter para_did. If the first condition is false, it checks if para_year is divisible by 5 using the MOD function; if MOD(para_year, 5) equals 0, it executes a DELETE statement on the DIRECTOR table, removing the row where the DID column matches para_did. If neither condition is true, it executes an INSERT statement into the DIRECTOR table, specifying values for the DID, NAME, and BIRTH_YEAR columns: it inserts the value of para_did into DID, the literal string 'Unknown' into NAME, and the value of para_year into BIRTH_YEAR.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_director_birth_year(para_did NUMBER, para_year NUMBER) IS\nBEGIN\n  IF MOD(para_year, 4) = 0 THEN\n    UPDATE DIRECTOR SET BIRTH_YEAR = para_year WHERE DID = para_did;\n  ELSIF MOD(para_year, 5) = 0 THEN\n    DELETE FROM DIRECTOR WHERE DID = para_did;\n  ELSE\n    INSERT INTO DIRECTOR (DID, NAME, BIRTH_YEAR) VALUES (para_did, 'Unknown', para_year);\n  END IF;\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "MOVIE",
      "TV_SERIES",
      "DIRECTOR",
      "WRITER"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_director_birth_year(1, 2000);\n  commit;\nEND;",
      "BEGIN\n  sp_update_director_birth_year(2, 2005);\n  commit;\nEND;",
      "BEGIN\n  sp_update_director_birth_year(3, 2001);\n  commit;\nEND;",
      "BEGIN\n  sp_update_director_birth_year(4, 2004);\n  commit;\nEND;",
      "BEGIN\n  sp_update_director_birth_year(5, 2003);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_director_birth_year with parameters para_did NUMBER and para_year NUMBER. If para_year is divisible by 4, update DIRECTOR set BIRTH_YEAR=para_year where DID=para_did. Else if para_year is divisible by 5, delete from DIRECTOR where DID=para_did. Otherwise, insert into DIRECTOR (DID, NAME, BIRTH_YEAR) values (para_did, 'Unknown', para_year).",
    "natural_language": "How can I create a stored procedure called sp_update_director_birth_year that takes para_did NUMBER and para_year NUMBER as parameters, so that it updates the DIRECTOR's BIRTH_YEAR to para_year for a given DID if para_year is divisible by 4, deletes the director record if para_year is divisible by 5, or otherwise inserts a new record with the given DID, 'Unknown' for NAME, and the provided para_year?",
    "id": 57,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_director_birth_year that accepts two input parameters: para_did of type NUMBER to specify a director identifier, and para_year of type NUMBER to specify a birth year value. The procedure performs conditional operations on the DIRECTOR table based on the para_year parameter. First, it checks if para_year is divisible by 4 by evaluating the condition MOD(para_year, 4) = 0. If true, it executes an UPDATE operation on the DIRECTOR table, setting the BIRTH_YEAR column to the value of para_year for the row where the DID column equals para_did. Second, if the first condition is false, it checks if para_year is divisible by 5 by evaluating the condition MOD(para_year, 5) = 0. If true, it executes a DELETE operation on the DIRECTOR table, removing the row where the DID column equals para_did. Third, if neither condition is true (i.e., para_year is not divisible by 4 or 5), it executes an INSERT operation into the DIRECTOR table. The INSERT operation adds a new row with the following column values: for the DID column, it uses the value of para_did; for the NAME column, it uses the string literal 'Unknown'; for the BIRTH_YEAR column, it uses the value of para_year; for the GENDER, NATIONALITY, and BIRTH_CITY columns, it does not specify values, which will result in NULL being inserted for these columns if the table allows NULLs, or an error if they have NOT NULL constraints without defaults. The procedure does not include explicit validation for the existence of the director record before the UPDATE or DELETE operations, so these operations will proceed regardless of whether a matching row exists, potentially affecting zero rows. The procedure concludes after executing the appropriate operation based on the conditions."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_update_form_description` that accepts three input parameters: `para_form_type` of data type `VARCHAR2`, intended to represent the type code of a form; `para_form_name` of data type `VARCHAR2`, intended to represent the name of a form; and `para_new_description` of data type `VARCHAR2`, intended to represent the new description to be assigned to a form. The procedure performs a single `UPDATE` operation on the `FORMS` table. Specifically, it sets the value of the `FORM_DESCRIPTION` column to the value provided in the `para_new_description` parameter. This update is conditionally applied only to those rows in the `FORMS` table where the value in the `FORM_TYPE_CODE` column exactly matches the value provided in the `para_form_type` parameter AND the value in the `FORM_NAME` column exactly matches the value provided in the `para_form_name` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_form_description(para_form_type VARCHAR2, para_form_name VARCHAR2, para_new_description VARCHAR2) IS\nBEGIN\nUPDATE FORMS SET FORM_DESCRIPTION = para_new_description WHERE FORM_TYPE_CODE = para_form_type AND FORM_NAME = para_form_name;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_form_description('Basic', 'SSN Application', 'Updated description for SSN Application form');\nEND;",
      "BEGIN\n  sp_update_form_description('Complex', 'Marriage Certificate', 'New detailed description for Marriage Certificate');\nEND;",
      "BEGIN\n  sp_update_form_description('Basic', 'Divorce Certificate', 'Revised description for Divorce Certificate form');\nEND;",
      "BEGIN\n  sp_update_form_description('Complex', 'SSN Application', 'Complex version SSN form description update');\nEND;",
      "BEGIN\n  sp_update_form_description('Basic', 'Marriage Certificate', 'Basic marriage certificate form description');\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_form_description that updates the FORM_DESCRIPTION column in the FORMS table to a new value, but only for rows where FORM_TYPE_CODE and FORM_NAME match the input parameters.",
    "natural_language": "Please construct a stored procedure designated as sp_update_form_description. Its function is to modify the FORM_DESCRIPTION column within the FORMS table, assigning a new specified value. This update shall be applied exclusively to those records for which the FORM_TYPE_CODE and FORM_NAME correspond precisely to the provided input parameters.",
    "id": 58,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_form_description that operates within the e_government database. The procedure accepts three input parameters: p_form_type_code of type VARCHAR2, p_form_name of type VARCHAR2, and p_new_form_description of type VARCHAR2. The procedure performs a single UPDATE operation on the FORMS table. The UPDATE statement modifies the FORM_DESCRIPTION column, setting its value to the input parameter p_new_form_description. This update is applied conditionally, using a WHERE clause that specifies two criteria: the FORM_TYPE_CODE column in the FORMS table must exactly match the input parameter p_form_type_code, and the FORM_NAME column in the FORMS table must exactly match the input parameter p_form_name. The procedure's logic is to update the description of forms only for those records where both the form type code and the form name match the provided input values, thereby changing the FORM_DESCRIPTION to the new specified value for all matching rows."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_church_and_people that accepts four input parameters: a numeric parameter p_church_id, a numeric parameter p_people_id, a string parameter p_new_name, and a string parameter p_new_country. The procedure first declares three local numeric variables: v_church_exists, v_person_exists, and v_church_open_date. It then checks for the existence of a church by selecting the count of rows from the CHURCH table where the CHURCH_ID column equals the input parameter p_church_id, storing the result in v_church_exists. It also checks for the existence of a person by selecting the count of rows from the PEOPLE table where the PEOPLE_ID column equals the input parameter p_people_id, storing the result in v_person_exists. If the v_church_exists count is greater than zero, indicating the church exists, it proceeds to select the OPEN_DATE column value from the CHURCH table for that specific CHURCH_ID into the variable v_church_open_date. It then evaluates a condition on this date: if v_church_open_date is less than 2000, it updates the NAME column in the CHURCH table for that row, setting it to the concatenation of the input parameter p_new_name with the appended string ' (Historic)'; otherwise, if the date is 2000 or later, it updates the NAME column to just p_new_name. Following the church logic, the procedure then checks if the v_person_exists count is greater than zero. If a person exists, it updates the COUNTRY column in the PEOPLE table for the row with the matching PEOPLE_ID to the value of the input parameter p_new_country. If the person does not exist (v_person_exists is zero), it performs an insert into the PEOPLE table, specifying values for the columns PEOPLE_ID (using p_people_id), NAME (using the literal string 'New Person'), COUNTRY (using p_new_country), IS_MALE (using the literal string 'T'), and AGE (using the literal number 30).",
    "plsql": "CREATE OR REPLACE PROCEDURE update_church_and_people(\n    p_church_id NUMBER,\n    p_people_id NUMBER,\n    p_new_name VARCHAR2,\n    p_new_country VARCHAR2\n) IS\n    v_church_exists NUMBER := 0;\n    v_person_exists NUMBER := 0;\n    v_church_open_date NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_church_exists FROM CHURCH WHERE CHURCH_ID = p_church_id;\n    SELECT COUNT(*) INTO v_person_exists FROM PEOPLE WHERE PEOPLE_ID = p_people_id;\n\n    IF v_church_exists > 0 THEN\n        SELECT OPEN_DATE INTO v_church_open_date FROM CHURCH WHERE CHURCH_ID = p_church_id;\n        IF v_church_open_date < 2000 THEN\n            UPDATE CHURCH SET NAME = p_new_name || ' (Historic)' WHERE CHURCH_ID = p_church_id;\n        ELSE\n            UPDATE CHURCH SET NAME = p_new_name WHERE CHURCH_ID = p_church_id;\n        END IF;\n    END IF;\n\n    IF v_person_exists > 0 THEN\n        UPDATE PEOPLE SET COUNTRY = p_new_country WHERE PEOPLE_ID = p_people_id;\n    ELSE\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES (p_people_id, 'New Person', p_new_country, 'T', 30);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  update_church_and_people(p_church_id => 1, p_people_id => 1, p_new_name => 'New Pure Church', p_new_country => 'Canada');\nEND;",
      "BEGIN\n  update_church_and_people(p_church_id => 2, p_people_id => 2, p_new_name => 'Modern Independent Church', p_new_country => 'Sweden');\nEND;",
      "BEGIN\n  update_church_and_people(p_church_id => 3, p_people_id => 3, p_new_name => 'Reformed Church of Christ', p_new_country => 'United States');\nEND;",
      "BEGIN\n  update_church_and_people(p_church_id => 1, p_people_id => 10, p_new_name => 'Historic Pure Church', p_new_country => 'Germany');\nEND;",
      "BEGIN\n  update_church_and_people(p_church_id => 99, p_people_id => 11, p_new_name => 'Non-existent Church', p_new_country => 'France');\nEND;"
    ],
    "summary": "Create a stored procedure named update_church_and_people that accepts church_id, people_id, new_name, and new_country as parameters. Check if the specified church exists. If it exists, update its name: append ' (Historic)' if its open date is before 2000, otherwise use the new name as-is. Then, check if the specified person exists. If the person exists, update their country. If the person does not exist, insert a new person record with the provided ID, a default name of 'New Person', the provided country, a default gender of 'T', and a default age of 30.",
    "natural_language": "Alright, so we need a stored procedure called update_church_and_people. It's gonna take church_id, people_id, new_name, and new_country as its inputs. First off, you gotta see if that church ID actually points to a real church. If it does, then update its name: but here's the catchâ€”if the church opened before the year 2000, tack on ' (Historic)' to the new name; otherwise, just slap the new name on there as given. Next, check if the person with that people_id exists. If they're in the system, just update their country to the new one. If they're not there at all, go ahead and add a new person record. For that new entry, use the provided ID, set the name to 'New Person' by default, use the given country, and just throw in 'T' for gender and 30 for age as the defaults.",
    "id": 59,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_church_and_people that accepts four input parameters: p_church_id of type NUMBER, p_people_id of type NUMBER, p_new_name of type VARCHAR2, and p_new_country of type VARCHAR2. The procedure first declares two local variables: v_church_exists of type NUMBER to store the count of churches matching the provided church ID, and v_people_exists of type NUMBER to store the count of people matching the provided people ID.\n\nThe procedure begins by querying the CHURCH table to count how many rows exist where the CHURCH_ID column equals the p_church_id parameter, storing this count in v_church_exists. If v_church_exists is greater than 0 (meaning the church exists), the procedure then executes a conditional UPDATE on the CHURCH table. It updates the NAME column for the row where CHURCH_ID equals p_church_id. The new value for NAME is determined by a CASE expression: if the OPEN_DATE column of that church is less than 2000, the new name is set to p_new_name concatenated with the string ' (Historic)'; otherwise, the new name is set to p_new_name directly.\n\nNext, the procedure queries the PEOPLE table to count how many rows exist where the PEOPLE_ID column equals the p_people_id parameter, storing this count in v_people_exists. If v_people_exists is greater than 0 (meaning the person exists), the procedure executes an UPDATE on the PEOPLE table, setting the COUNTRY column to p_new_country for the row where PEOPLE_ID equals p_people_id.\n\nIf v_people_exists is 0 (meaning the person does not exist), the procedure executes an INSERT into the PEOPLE table, creating a new row with the following values: PEOPLE_ID set to p_people_id, NAME set to the hardcoded string 'New Person', COUNTRY set to p_new_country, IS_MALE set to the hardcoded string 'T', and AGE set to the hardcoded number 30."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `validate_department_creation` that accepts two input parameters: `p_year_threshold` of type `VARCHAR2` and `p_min_employees` of type `NUMBER`. The purpose of this procedure is to identify and subsequently manage departments that meet specific criteria related to their creation year and number of employees.\n\nThe procedure begins by declaring a local variable `v_count` of type `NUMBER`, which will be used to store the count of departments matching the specified conditions.\n\nThe first operation performed is a `SELECT` statement. This statement queries the `DEPARTMENT` table to count the number of records that satisfy two conditions. The first condition checks if the `CREATION` column, after being explicitly converted to a `NUMBER` using the `TO_NUMBER()` function, is strictly less than the value of the `p_year_threshold` parameter, which is also explicitly converted to a `NUMBER` using `TO_NUMBER()`. The second condition checks if the `NUM_EMPLOYEES` column is strictly less than the value of the `p_min_employees` parameter. The result of this count is then stored into the `v_count` variable.\n\nFollowing this `SELECT` operation, a conditional block (`IF v_count > 0 THEN ... END IF;`) is executed. This block checks if the value stored in `v_count` is greater than zero. If `v_count` is indeed greater than zero, indicating that at least one department met the specified criteria, then a `DELETE` operation is performed.\n\nThe `DELETE` statement targets the `MANAGEMENT` table. Rows are deleted from the `MANAGEMENT` table where the `DEPARTMENT_ID` column matches any `DEPARTMENT_ID` found in a subquery. This subquery selects `DEPARTMENT_ID` from the `DEPARTMENT` table, applying the exact same two conditions as the initial `SELECT` statement: `TO_NUMBER(CREATION) < TO_NUMBER(p_year_threshold)` and `NUM_EMPLOYEES < p_min_employees`. This effectively deletes all management records associated with departments that were created before the `p_year_threshold` and have fewer than `p_min_employees`.",
    "plsql": "CREATE OR REPLACE PROCEDURE validate_department_creation(p_year_threshold VARCHAR2, p_min_employees NUMBER)\nIS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM DEPARTMENT\n    WHERE TO_NUMBER(CREATION) < TO_NUMBER(p_year_threshold)\n    AND NUM_EMPLOYEES < p_min_employees;\n    \n    IF v_count > 0 THEN\n        DELETE FROM MANAGEMENT\n        WHERE DEPARTMENT_ID IN (\n            SELECT DEPARTMENT_ID\n            FROM DEPARTMENT\n            WHERE TO_NUMBER(CREATION) < TO_NUMBER(p_year_threshold)\n            AND NUM_EMPLOYEES < p_min_employees\n        );\n    END IF;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "BEGIN\n  validate_department_creation('1900', 1000);\nEND;",
      "BEGIN\n  validate_department_creation('1950', 50000);\nEND;",
      "BEGIN\n  validate_department_creation('1800', 100);\nEND;",
      "BEGIN\n  validate_department_creation('2000', 200000);\nEND;",
      "BEGIN\n  validate_department_creation('1850', 5000);\nEND;"
    ],
    "summary": "Create a stored procedure named validate_department_creation that takes a year threshold and a minimum employee count as input. It counts departments created before the threshold with fewer than the minimum employees. If any are found, it deletes their associated records from the MANAGEMENT table.",
    "natural_language": "Create a stored procedure called validate_department_creation that uses a somewhat older year and a not-too-high employee number as parameters. It should figure out roughly how many departments were set up a while back, specifically those that don't have very many people working in them. If it finds a few such departments, it needs to clean up their related entries in the MANAGEMENT table.",
    "id": 60,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `validate_department_creation` that accepts two input parameters: `p_year_threshold` of type `VARCHAR2` and `p_min_employees` of type `NUMBER`. The purpose of this procedure is to identify and subsequently manage departments that meet specific criteria related to their creation year and number of employees.\n\nThe procedure begins by declaring a local variable `v_count` of type `NUMBER`, which will be used to store the count of departments matching the specified conditions.\n\nThe first operation performed is a `SELECT` statement. This statement queries the `DEPARTMENT` table to count the number of records that satisfy two conditions. The first condition checks if the `CREATION` column, after being explicitly converted to a `NUMBER` using the `TO_NUMBER()` function, is strictly less than the value of the `p_year_threshold` parameter, which is also explicitly converted to a `NUMBER` using `TO_NUMBER()`. The second condition checks if the `NUM_EMPLOYEES` column is strictly less than the value of the `p_min_employees` parameter. The result of this count is then stored into the `v_count` variable.\n\nFollowing this `SELECT` operation, a conditional block (`IF v_count > 0 THEN ... END IF;`) is executed. This block checks if the value stored in `v_count` is greater than zero. If `v_count` is indeed greater than zero, indicating that at least one department met the specified criteria, then a `DELETE` operation is performed.\n\nThe `DELETE` statement targets the `MANAGEMENT` table. Rows are deleted from the `MANAGEMENT` table where the `DEPARTMENT_ID` column matches any `DEPARTMENT_ID` found in a subquery. This subquery selects `DEPARTMENT_ID` from the `DEPARTMENT` table, applying the exact same two conditions as the initial `SELECT` statement: `TO_NUMBER(CREATION) < TO_NUMBER(p_year_threshold)` and `NUM_EMPLOYEES < p_min_employees`. This effectively deletes all management records associated with departments that were created before the `p_year_threshold` and have fewer than `p_min_employees`."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `process_country_data` that accepts three input parameters: `p_country` of type `VARCHAR2`, `p_age_min` of type `NUMBER`, and `p_gender_flag` of type `VARCHAR2`. The `p_country` parameter is intended to specify a particular country for data processing. The `p_age_min` parameter represents a minimum age threshold. The `p_gender_flag` parameter is used to indicate a specific gender, typically 'T' for true (male) or 'F' for false (female).\n\nThe procedure begins by declaring three local variables: `v_avg_age` of type `NUMBER` to store the average age, `v_max_age` of type `NUMBER` to store the maximum age, and `v_count` of type `NUMBER` to store the count of records.\n\nNext, it executes a `SELECT` statement to retrieve aggregated data from the `PEOPLE` table. This `SELECT` statement calculates the average of the `AGE` column, the maximum value of the `AGE` column, and the total count of rows. These calculated values are then stored into the `v_avg_age`, `v_max_age`, and `v_count` local variables, respectively. The selection of rows for this aggregation is filtered by two conditions: the `COUNTRY` column must match the value provided in the `p_country` input parameter, and the `IS_MALE` column must match the value provided in the `p_gender_flag` input parameter.\n\nFollowing this, the procedure enters a conditional block (`IF v_count > 0 THEN`). This block checks if the `v_count` variable, which holds the number of records found in the previous `SELECT` operation, is greater than zero.\n\nIf `v_count` is greater than zero (meaning records matching the `p_country` and `p_gender_flag` criteria were found), the procedure performs two operations:\n1. It executes an `INSERT` statement into the `PEOPLE` table. A new row is inserted with the following values:\n    - `PEOPLE_ID`: This is determined by a subquery `(SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE)`, which finds the current maximum `PEOPLE_ID` in the `PEOPLE` table and increments it by one to generate a new unique ID.\n    - `NAME`: Set to the literal string 'Average Age Person'.\n    - `COUNTRY`: Set to the value of the `p_country` input parameter.\n    - `IS_MALE`: Set to the value of the `p_gender_flag` input parameter.\n    - `AGE`: Set to the rounded value of `v_avg_age` using the `ROUND()` function.\n2. It executes a `DELETE` statement on the `WEDDING` table. Rows are deleted from `WEDDING` where either of the following conditions is met:\n    - The `MALE_ID` column is present in a subquery result. This subquery selects `PEOPLE_ID` from the `PEOPLE` table where the `COUNTRY` column matches `p_country`, the `IS_MALE` column is 'T' (indicating male), and the `AGE` column is less than the `p_age_min` input parameter.\n    - The `FEMALE_ID` column is present in another subquery result. This subquery selects `PEOPLE_ID` from the `PEOPLE` table where the `COUNTRY` column matches `p_country`, the `IS_MALE` column is 'F' (indicating female), and the `AGE` column is less than the `p_age_min` input parameter.\n\nIf `v_count` is not greater than zero (meaning no records matching the `p_country` and `p_gender_flag` criteria were found), the procedure executes the `ELSE` block. In this block, it performs a single `INSERT` statement into the `PEOPLE` table. A new row is inserted with the following values:\n- `PEOPLE_ID`: This is determined by a subquery `(SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE)`, which finds the current maximum `PEOPLE_ID` in the `PEOPLE` table and increments it by one to generate a new unique ID.\n- `NAME`: Set to the literal string 'Default Person'.\n- `COUNTRY`: Set to the value of the `p_country` input parameter.\n- `IS_MALE`: Set to the value of the `p_gender_flag` input parameter.\n- `AGE`: Set to the value of the `p_age_min` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_country_data(p_country VARCHAR2, p_age_min NUMBER, p_gender_flag VARCHAR2)\nIS\n    v_avg_age NUMBER;\n    v_max_age NUMBER;\n    v_count NUMBER;\nBEGIN\n    SELECT AVG(AGE), MAX(AGE), COUNT(*) INTO v_avg_age, v_max_age, v_count\n    FROM PEOPLE\n    WHERE COUNTRY = p_country AND IS_MALE = p_gender_flag;\n    \n    IF v_count > 0 THEN\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES ((SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE), 'Average Age Person', p_country, p_gender_flag, ROUND(v_avg_age));\n        \n        DELETE FROM WEDDING\n        WHERE MALE_ID IN (SELECT PEOPLE_ID FROM PEOPLE WHERE COUNTRY = p_country AND IS_MALE = 'T' AND AGE < p_age_min)\n        OR FEMALE_ID IN (SELECT PEOPLE_ID FROM PEOPLE WHERE COUNTRY = p_country AND IS_MALE = 'F' AND AGE < p_age_min);\n    ELSE\n        INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE)\n        VALUES ((SELECT MAX(PEOPLE_ID) + 1 FROM PEOPLE), 'Default Person', p_country, p_gender_flag, p_age_min);\n    END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  process_country_data('United States', 18, 'T');\n  COMMIT;\nEND;",
      "BEGIN\n  process_country_data('Canada', 21, 'F');\n  COMMIT;\nEND;",
      "BEGIN\n  process_country_data('Sweden', 25, 'T');\n  COMMIT;\nEND;",
      "BEGIN\n  process_country_data('United States', 30, 'F');\n  COMMIT;\nEND;",
      "BEGIN\n  process_country_data('Germany', 20, 'T');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named process_country_data that accepts p_country VARCHAR2, p_age_min NUMBER, and p_gender_flag VARCHAR2. Calculate the average age, maximum age, and record count from the PEOPLE table for the given country and gender. If records exist, insert a new person named 'Average Age Person' with the rounded average age, then delete from the WEDDING table where MALE_ID or FEMALE_ID corresponds to people from that country and gender whose age is below p_age_min. If no records exist, insert a 'Default Person' with age p_age_min.",
    "natural_language": "Write a stored procedure called process_country_data that takes p_country VARCHAR2, p_age_min NUMBER, and p_gender_flag VARCHAR2. For the specified country and gender, compute the average age, maximum age, and total record count from the PEOPLE table. If records are found, insert a new person named 'Average Age Person' using the rounded average age, and then remove entries from the WEDDING table where either MALE_ID or FEMALE_ID matches people from that country and gender who are younger than p_age_min. If no records are found, insert a 'Default Person' with the age set to p_age_min.",
    "id": 61,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named process_country_data that accepts three input parameters: p_country of type VARCHAR2, p_age_min of type NUMBER, and p_gender_flag of type VARCHAR2. The procedure begins by declaring several local variables: v_avg_age of type NUMBER, v_max_age of type NUMBER, v_total_count of type NUMBER, v_new_people_id of type NUMBER, and v_gender_condition of type VARCHAR2. The v_gender_condition variable is derived from the input parameter p_gender_flag: if p_gender_flag is 'M', then v_gender_condition is set to 'T'; if p_gender_flag is 'F', then v_gender_condition is set to 'F'; otherwise, v_gender_condition is set to NULL.\n\nThe procedure then executes a SELECT statement on the PEOPLE table to compute the average age, maximum age, and total count of records. It filters the records where the COUNTRY column matches the input parameter p_country and the IS_MALE column matches the derived v_gender_condition. The results are stored into the variables v_avg_age, v_max_age, and v_total_count using an aggregate query with the AVG, MAX, and COUNT functions.\n\nFollowing this, the procedure checks if v_total_count is greater than 0. If records are found, it performs a sequence of operations. First, it generates a new PEOPLE_ID by selecting the maximum existing PEOPLE_ID from the PEOPLE table, using the NVL function to handle nulls by defaulting to 0, and incrementing by 1, storing the result in v_new_people_id. Then, it inserts a new record into the PEOPLE table with the following values: v_new_people_id into PEOPLE_ID, the string 'Average Age Person' into NAME, the input parameter p_country into COUNTRY, the derived v_gender_condition into IS_MALE, and the rounded value of v_avg_age using the ROUND function into AGE. Next, it performs a DELETE operation on the WEDDING table where either the MALE_ID or FEMALE_ID matches any PEOPLE_ID from the PEOPLE table that satisfies the conditions: COUNTRY equals p_country, IS_MALE equals v_gender_condition, and AGE is less than the input parameter p_age_min. This is achieved using a subquery to identify the relevant PEOPLE_ID values.\n\nIf no records are found (i.e., v_total_count is 0), the procedure performs an alternative operation. It generates a new PEOPLE_ID in the same manner as before, by selecting the maximum existing PEOPLE_ID from the PEOPLE table, using NVL to default to 0, and incrementing by 1, storing it in v_new_people_id. Then, it inserts a new record into the PEOPLE table with the following values: v_new_people_id into PEOPLE_ID, the string 'Default Person' into NAME, the input parameter p_country into COUNTRY, the derived v_gender_condition into IS_MALE, and the input parameter p_age_min into AGE.\n\nThe procedure does not return any value and operates within the wedding database."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that accepts four parameters: p_start_year and p_end_year, both of type NUMBER, representing the range of years to filter gas stations by their OPEN_YEAR; p_months_buffer, also of type NUMBER, which is used to create an interval but is not directly utilized in the procedure's logic; and p_company_filter, a NUMBER that specifies a company ID to exclude from deletion. The procedure defines a cursor named station_cursor that selects the STATION_ID from the GAS_STATION table where the OPEN_YEAR is between p_start_year and p_end_year, inclusive. It initializes an interval variable v_year_interval using the NUMTOYMINTERVAL function with p_months_buffer and 'MONTH' as arguments, although this interval is not used further in the procedure. The procedure opens the station_cursor and enters a loop to fetch each STATION_ID into the variable v_station_id. For each fetched STATION_ID, it executes a DELETE operation on the STATION_COMPANY table, removing rows where the STATION_ID matches v_station_id and the COMPANY_ID is not equal to p_company_filter. The loop continues until all records from the cursor are processed, at which point the cursor is closed.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_start_year NUMBER, p_end_year NUMBER, p_months_buffer NUMBER, p_company_filter NUMBER) IS\n   v_year_interval INTERVAL YEAR TO MONTH;\n   v_station_id NUMBER;\n   CURSOR station_cursor IS \n      SELECT STATION_ID FROM GAS_STATION WHERE OPEN_YEAR BETWEEN p_start_year AND p_end_year;\nBEGIN\n   v_year_interval := NUMTOYMINTERVAL(p_months_buffer, 'MONTH');\n   OPEN station_cursor;\n   LOOP\n      FETCH station_cursor INTO v_station_id;\n      EXIT WHEN station_cursor%NOTFOUND;\n      DELETE FROM STATION_COMPANY WHERE STATION_ID = v_station_id AND COMPANY_ID != p_company_filter;\n   END LOOP;\n   CLOSE station_cursor;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "BEGIN\n  sp(1990, 2000, 6, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2000, 2010, 12, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1995, 2005, 3, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(1980, 1990, 24, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(2010, 2020, 0, 3);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure that deletes records from the STATION_COMPANY table for all gas stations opened within a specified year range, excluding those linked to a specific company ID. The procedure accepts parameters for start year, end year, a months buffer (unused), and the company ID to exclude.",
    "natural_language": "Develop a stored procedure that meticulously removes entries from the STATION_COMPANY table, specifically targeting all gas stations whose opening dates fall entirely within a clearly defined span of years, while carefully ensuring that any stations associated with a particular, designated company identifier are preserved and excluded from this deletion. This procedure must formally accept input parameters for the inclusive starting year, the inclusive ending year, an optional buffer period in months which remains unused, and the precise company ID that should be exempted.",
    "id": 62,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that accepts four input parameters: p_start_year of type NUMBER representing the inclusive starting year for the opening date range, p_end_year of type NUMBER representing the inclusive ending year for the opening date range, p_buffer_months of type NUMBER representing an optional buffer period in months which is declared but not used in the procedure's logic, and p_company_id of type NUMBER representing the specific company identifier whose associated stations should be exempted from deletion. The procedure declares no local variables.\n\nThe procedure performs a DELETE operation on the STATION_COMPANY table. The deletion targets all records in the STATION_COMPANY table where the associated gas station's opening year falls within the specified inclusive range of years, and where the station is not associated with the specified exempt company.\n\nTo achieve this, the procedure uses a subquery to identify the STATION_ID values that meet the criteria for deletion. It selects STATION_ID from the GAS_STATION table where the OPEN_YEAR column is greater than or equal to p_start_year and less than or equal to p_end_year. This set of station IDs represents all stations opened within the defined year span.\n\nThe procedure then deletes from the STATION_COMPANY table where the STATION_ID is in the result set from the subquery (i.e., the station was opened within the year range) AND the COMPANY_ID is not equal to the input parameter p_company_id. This ensures that any record linking a station (opened within the range) to the specified exempt company is preserved and not deleted. The procedure does not include any explicit exception handling or commit/rollback statements."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_conference_location that accepts two input parameters: a numeric parameter named p_conference_id and a string parameter named p_location of type VARCHAR2, and executes a single SQL UPDATE operation on the database table named CONFERENCE, specifically modifying the value in the LOCATION column for the row where the CONFERENCE_ID column value exactly matches the value provided in the p_conference_id parameter, setting that LOCATION column to the new string value supplied in the p_location parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_conference_location(p_conference_id NUMBER, p_location VARCHAR2) IS\nBEGIN\n  UPDATE CONFERENCE\n     SET LOCATION = p_location\n   WHERE CONFERENCE_ID = p_conference_id;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_conference_location(1, 'Singapore');\n  commit;\nEND;",
      "BEGIN\n  sp_update_conference_location(2, 'Thailand');\n  commit;\nEND;",
      "BEGIN\n  sp_update_conference_location(3, 'Australia');\n  commit;\nEND;",
      "BEGIN\n  sp_update_conference_location(1, 'Malaysia');\n  commit;\nEND;",
      "BEGIN\n  sp_update_conference_location(2, 'South Korea');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_conference_location that accepts a conference ID (NUMBER) and a location (VARCHAR2). It updates the CONFERENCE table, setting the LOCATION to the provided value for the row matching the given conference ID.",
    "natural_language": "Update conference location by ID.",
    "id": 63,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_conference_location. The procedure accepts two input parameters: p_conference_id of type NUMBER, which represents the unique identifier of the conference record to be updated, and p_new_location of type VARCHAR2, which represents the new location value to be assigned to the conference.\n\nThe procedure begins execution by performing an UPDATE operation on the CONFERENCE table. The UPDATE statement modifies the LOCATION column for a specific row. It uses a WHERE clause to target the row where the CONFERENCE_ID column exactly matches the value provided in the p_conference_id input parameter. The LOCATION column for that row is set to the value provided in the p_new_location input parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_manage_actor_cast` that accepts two input parameters: `para_aid` of data type `NUMBER` and `para_role` of data type `NUMBER`. The procedure's primary function is to manage records within the `CAST` table based on the value of the `para_role` parameter. It first evaluates a conditional statement: if the remainder of `para_role` divided by 2 is equal to 0 (i.e., `para_role` is an even number), the procedure executes an `INSERT` operation into the `CAST` table. This `INSERT` statement populates the `ID` column with the value of `para_aid`, the `MSID` column with `NULL`, the `AID` column with the value of `para_aid`, and the `ROLE` column with the value of `para_role`. If the first condition is false, the procedure then evaluates a second conditional statement: if the remainder of `para_role` divided by 3 is equal to 0 (i.e., `para_role` is a multiple of 3), the procedure performs a `DELETE` operation from the `CAST` table. This `DELETE` operation removes all rows where the `AID` column matches the value of `para_aid`. If both the first and second conditions are false, the procedure executes a default `INSERT` operation into the `CAST` table. This `INSERT` statement populates the `ID` column with the value of `para_aid`, the `MSID` column with `NULL`, the `AID` column with the value of `para_aid`, and the `ROLE` column with the value of `para_role` incremented by 1.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_actor_cast(para_aid NUMBER, para_role NUMBER) IS\nBEGIN\n  IF MOD(para_role, 2) = 0 THEN\n    INSERT INTO CAST (ID, MSID, AID, ROLE) VALUES (para_aid, NULL, para_aid, para_role);\n  ELSIF MOD(para_role, 3) = 0 THEN\n    DELETE FROM CAST WHERE AID = para_aid;\n  ELSE\n    INSERT INTO CAST (ID, MSID, AID, ROLE) VALUES (para_aid, NULL, para_aid, para_role + 1);\n  END IF;\nEND;",
    "database_name": "imdb",
    "tables": [
      "ACTOR",
      "CAST",
      "MOVIE",
      "TV_SERIES",
      "DIRECTOR",
      "WRITER"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_actor_cast(101, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_actor_cast(102, 6);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_actor_cast(103, 9);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_actor_cast(104, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_manage_actor_cast(105, 7);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_manage_actor_cast with parameters para_aid NUMBER and para_role NUMBER. If para_role is even, insert a record into the CAST table with ID=para_aid, MSID=NULL, AID=para_aid, ROLE=para_role. Else if para_role is divisible by 3, delete from CAST where AID=para_aid. Otherwise, insert a record with ID=para_aid, MSID=NULL, AID=para_aid, ROLE=para_role+1.",
    "natural_language": "Please construct a stored procedure designated as sp_manage_actor_cast, which accepts two numerical parameters: para_aid and para_role. The procedure's logic is as follows: Should the value of para_role be an even number, insert a new entry into the CAST table, specifying the ID as para_aid, MSID as NULL, AID as para_aid, and ROLE as para_role. Alternatively, if para_role is divisible by three, execute a deletion from the CAST table for all records where the AID matches the provided para_aid. In all other cases, insert a record with ID set to para_aid, MSID to NULL, AID to para_aid, and ROLE to the value of para_role incremented by one.",
    "id": 64,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_manage_actor_cast that accepts two numeric input parameters: para_aid and para_role. The procedure performs conditional logic based on the value of para_role to determine whether to insert or delete records in the CAST table. Specifically, it uses a conditional IF-ELSIF-ELSE block to evaluate para_role. If para_role is an even number, determined by checking if MOD(para_role, 2) equals 0, the procedure executes an INSERT operation into the CAST table, inserting a single row with the ID column set to the value of para_aid, the MSID column set to NULL, the AID column set to the value of para_aid, and the ROLE column set to the value of para_role. If para_role is divisible by three, determined by checking if MOD(para_role, 3) equals 0, the procedure executes a DELETE operation on the CAST table, deleting all rows where the AID column value equals the value of para_aid. In all other cases, meaning para_role is neither even nor divisible by three, the procedure executes an INSERT operation into the CAST table, inserting a single row with the ID column set to the value of para_aid, the MSID column set to NULL, the AID column set to the value of para_aid, and the ROLE column set to the value of para_role plus one. The procedure does not return any value and operates within the imdb database."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named relocate_boxes that accepts two parameters: p_source_warehouse and p_target_warehouse, both of which are of type NUMBER. The procedure is designed to move boxes from one warehouse to another. It begins by deleting rows from the BOXES table where the WAREHOUSE column matches the value of p_source_warehouse, but only if there exists at least one row in the WAREHOUSES table where the CODE column matches the value of p_target_warehouse. This ensures that the target warehouse is valid before proceeding with the deletion. After the deletion, the procedure inserts new rows into the BOXES table. These new rows are selected from the BOXES table where the WAREHOUSE column equals p_source_warehouse, and for each selected row, the CODE, CONTENTS, and VALUE columns are copied directly, while the WAREHOUSE column is set to the value of p_target_warehouse. This operation effectively relocates the boxes from the source warehouse to the target warehouse by first removing them from the source and then inserting them with the updated warehouse information.",
    "plsql": "CREATE OR REPLACE PROCEDURE relocate_boxes(p_source_warehouse NUMBER, p_target_warehouse NUMBER)\nIS\nBEGIN\n    DELETE FROM BOXES \n    WHERE WAREHOUSE = p_source_warehouse \n    AND EXISTS (SELECT 1 FROM WAREHOUSES WHERE CODE = p_target_warehouse);\n    \n    INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE)\n    SELECT CODE, CONTENTS, VALUE, p_target_warehouse\n    FROM BOXES\n    WHERE WAREHOUSE = p_source_warehouse;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "BEGIN\n  relocate_boxes(1, 2);\nEND;",
      "BEGIN\n  relocate_boxes(3, 1);\nEND;",
      "BEGIN\n  relocate_boxes(4, 3);\nEND;",
      "BEGIN\n  relocate_boxes(2, 4);\nEND;",
      "BEGIN\n  relocate_boxes(1, 3);\nEND;"
    ],
    "summary": "Create a stored procedure named 'relocate_boxes' to move all boxes from a source warehouse to a target warehouse. Inputs: source and target warehouse codes. First, delete boxes from the source warehouse, but only if the target warehouse exists. Then, insert those boxes into the BOXES table with their warehouse code updated to the target.",
    "natural_language": "Please construct a stored procedure designated as 'relocate_boxes'. The procedure's objective is to transfer all boxes from a specified source warehouse to a designated target warehouse. The required input parameters are the source and target warehouse codes. The procedure must first verify the existence of the target warehouse. Subsequently, it should delete the relevant box records from the source warehouse. Following this deletion, it must insert those same records into the BOXES table, updating the warehouse code to that of the target.",
    "id": 65,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named relocate_boxes that accepts two input parameters: p_source_warehouse of type NUMBER representing the code of the source warehouse from which boxes will be moved, and p_target_warehouse of type NUMBER representing the code of the target warehouse to which boxes will be relocated. The procedure begins by declaring a local variable v_target_exists of type NUMBER to verify the existence of the target warehouse. Within the main execution block, a SELECT statement is executed to check if the target warehouse exists by counting the number of rows in the WAREHOUSES table where the CODE column equals p_target_warehouse, storing the result in v_target_exists. If v_target_exists equals 0, indicating the target warehouse does not exist, the procedure raises a user-defined exception with an error message stating that the target warehouse is invalid. If v_target_exists equals 1, the procedure proceeds to delete all records from the BOXES table where the WAREHOUSE column equals p_source_warehouse, capturing the deleted rows using a RETURNING clause that stores the CODE, CONTENTS, VALUE, and WAREHOUSE values into a collection variable. Following the deletion, an INSERT statement is executed to insert the captured box records into the BOXES table, setting the WAREHOUSE column to p_target_warehouse while retaining the original CODE, CONTENTS, and VALUE from the source warehouse. The procedure includes exception handling to catch any errors during the deletion or insertion operations, rolling back the transaction and raising an appropriate error message. The procedure does not return a value but commits the transaction upon successful completion."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `handle_product_orders` that accepts a single input parameter, `p_product_name`, of type `VARCHAR2`. This procedure is designed to process product orders based on the provided product name. It declares three local variables: `v_product_id` of type `NUMBER` to store a product's identifier, `v_order_id` of type `NUMBER` to store an order's identifier, and `v_product_price` of type `NUMBER` to store a product's price. The procedure begins by iterating through a result set obtained from selecting the `PRODUCT_ID` and `PRODUCT_PRICE` columns from the `PRODUCTS` table. This selection is filtered by a condition where the `PRODUCT_NAME` column matches the value passed in the `p_product_name` input parameter. For each record (`prod_rec`) retrieved in this outer loop, the `PRODUCT_ID` is assigned to `v_product_id`, and the `PRODUCT_PRICE` is assigned to `v_product_price`. Subsequently, an inner loop is initiated. This inner loop iterates through a result set obtained from selecting the `ACTUAL_ORDER_ID` column from the `ACTUAL_ORDER_PRODUCTS` table. This selection is filtered by a condition where the `PRODUCT_ID` column matches the `v_product_id` obtained from the current iteration of the outer loop. For each record (`order_rec`) retrieved in this inner loop, the `ACTUAL_ORDER_ID` is assigned to `v_order_id`. Following this assignment, a conditional block is executed. If the `v_product_price` is greater than `1000`, then a `DELETE` operation is performed on the `ACTUAL_ORDERS` table, removing the row where the `ACTUAL_ORDER_ID` column matches the `v_order_id`. If the `v_product_price` is not greater than `1000` but is less than or equal to `1000`, then an `INSERT` operation is performed on the `CUSTOMERS` table. A new row is inserted with the `CUSTOMER_ID` set to the value of `v_order_id` plus `6000`, `PAYMENT_METHOD` set to the string literal 'New', `CUSTOMER_NAME` set to the string literal 'Generated Customer', `CUSTOMER_PHONE` set to the string literal '000-000-0000', `CUSTOMER_EMAIL` set to the string literal 'gen@example.com', and `DATE_BECAME_CUSTOMER` set to the string literal '2023-01-01 00:00:00'. If neither of the preceding conditions is met (i.e., `v_product_price` is not greater than `1000` and not less than or equal to `1000`), then an `UPDATE` operation is performed on the `PRODUCTS` table, setting the `PRODUCT_DESCRIPTION` column to the string literal 'special update' for the row where the `PRODUCT_ID` column matches the `v_product_id`. The inner loop continues until all relevant orders for the current product have been processed. The outer loop then continues until all products matching the `p_product_name` have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE handle_product_orders(p_product_name VARCHAR2)\nIS\n    v_product_id NUMBER;\n    v_order_id NUMBER;\n    v_product_price NUMBER;\nBEGIN\n    FOR prod_rec IN (SELECT PRODUCT_ID, PRODUCT_PRICE FROM PRODUCTS WHERE PRODUCT_NAME = p_product_name) LOOP\n        v_product_id := prod_rec.PRODUCT_ID;\n        v_product_price := prod_rec.PRODUCT_PRICE;\n        \n        FOR order_rec IN (SELECT ACTUAL_ORDER_ID FROM ACTUAL_ORDER_PRODUCTS WHERE PRODUCT_ID = v_product_id) LOOP\n            v_order_id := order_rec.ACTUAL_ORDER_ID;\n            \n            IF v_product_price > 1000 THEN\n                DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = v_order_id;\n            ELSIF v_product_price <= 1000 THEN\n                INSERT INTO CUSTOMERS (CUSTOMER_ID, PAYMENT_METHOD, CUSTOMER_NAME, CUSTOMER_PHONE, CUSTOMER_EMAIL, DATE_BECAME_CUSTOMER)\n                VALUES (v_order_id + 6000, 'New', 'Generated Customer', '000-000-0000', 'gen@example.com', '2023-01-01 00:00:00');\n            ELSE\n                UPDATE PRODUCTS SET PRODUCT_DESCRIPTION = 'special update' WHERE PRODUCT_ID = v_product_id;\n            END IF;\n        END LOOP;\n    END LOOP;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS",
      "REGULAR_ORDERS",
      "CUSTOMERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "BEGIN\n  handle_product_orders('dvds');\nEND;",
      "BEGIN\n  handle_product_orders('cloth');\nEND;",
      "BEGIN\n  handle_product_orders('electronics');\nEND;",
      "BEGIN\n  handle_product_orders('laptop');\nEND;",
      "BEGIN\n  handle_product_orders('book');\nEND;"
    ],
    "summary": "Create a stored procedure named `handle_product_orders` that accepts a product name. For each product with that name, process its related orders. If the product price is over 1000, delete the associated order. If the price is 1000 or less, insert a new customer record. Otherwise, update the product's description.",
    "natural_language": "Create a stored procedure called `handle_product_orders` that takes a product name. For items matching that name, work through their linked orders. If a product's cost is significantly high, remove the related order. If the price is more or less reasonable, add a new customer entry. In other cases, just adjust the product's details.",
    "id": 66,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `handle_product_orders` that accepts a single input parameter, `p_product_name`, of type `VARCHAR2`. This procedure is designed to process product orders based on the provided product name. It declares three local variables: `v_product_id` of type `NUMBER` to store a product's identifier, `v_order_id` of type `NUMBER` to store an order's identifier, and `v_product_price` of type `NUMBER` to store a product's price. The procedure begins by iterating through a result set obtained from selecting the `PRODUCT_ID` and `PRODUCT_PRICE` columns from the `PRODUCTS` table. This selection is filtered by a condition where the `PRODUCT_NAME` column matches the value passed in the `p_product_name` input parameter. For each record (`prod_rec`) retrieved in this outer loop, the `PRODUCT_ID` is assigned to `v_product_id`, and the `PRODUCT_PRICE` is assigned to `v_product_price`. Subsequently, an inner loop is initiated. This inner loop iterates through a result set obtained from selecting the `ACTUAL_ORDER_ID` column from the `ACTUAL_ORDER_PRODUCTS` table. This selection is filtered by a condition where the `PRODUCT_ID` column matches the `v_product_id` obtained from the current iteration of the outer loop. For each record (`order_rec`) retrieved in this inner loop, the `ACTUAL_ORDER_ID` is assigned to `v_order_id`. Following this assignment, a conditional block is executed. If the `v_product_price` is greater than `1000`, then a `DELETE` operation is performed on the `ACTUAL_ORDERS` table, removing the row where the `ACTUAL_ORDER_ID` column matches the `v_order_id`. If the `v_product_price` is not greater than `1000` but is less than or equal to `1000`, then an `INSERT` operation is performed on the `CUSTOMERS` table. A new row is inserted with the `CUSTOMER_ID` set to the value of `v_order_id` plus `6000`, `PAYMENT_METHOD` set to the string literal 'New', `CUSTOMER_NAME` set to the string literal 'Generated Customer', `CUSTOMER_PHONE` set to the string literal '000-000-0000', `CUSTOMER_EMAIL` set to the string literal 'gen@example.com', and `DATE_BECAME_CUSTOMER` set to the string literal '2023-01-01 00:00:00'. If neither of the preceding conditions is met (i.e., `v_product_price` is not greater than `1000` and not less than or equal to `1000`), then an `UPDATE` operation is performed on the `PRODUCTS` table, setting the `PRODUCT_DESCRIPTION` column to the string literal 'special update' for the row where the `PRODUCT_ID` column matches the `v_product_id`. The inner loop continues until all relevant orders for the current product have been processed. The outer loop then continues until all products matching the `p_product_name` have been processed."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_city_data that accepts three parameters: p_city_code of type VARCHAR2, p_distance_threshold of type NUMBER, and p_operation_mode of type NUMBER. The procedure begins by checking if a city with the code p_city_code exists in the CITY table by counting the rows where CITY_CODE matches p_city_code and storing the result in the variable v_city_exists. If no such city exists (v_city_exists equals 0), it inserts a new row into the CITY table with CITY_CODE set to p_city_code, CITY_NAME set to 'New City', STATE set to 'XX', COUNTRY set to 'USA', and both LATITUDE and LONGITUDE set to 0. If the city exists and p_operation_mode equals 1, it counts the number of rows in the DIRECT_DISTANCE table where either CITY1_CODE or CITY2_CODE matches p_city_code and stores the count in v_distance_count. If p_operation_mode equals 2, it deletes rows from the DIRECT_DISTANCE table where either CITY1_CODE or CITY2_CODE matches p_city_code and the DISTANCE is greater than p_distance_threshold. If p_operation_mode equals 3, it inserts new rows into the DIRECT_DISTANCE table with CITY1_CODE set to p_city_code, CITY2_CODE set to CITY_CODE from the CITY table where CITY_CODE does not equal p_city_code, and DISTANCE set to p_distance_threshold, limiting the insertion to 3 rows using ROWNUM. If p_operation_mode equals 4, it counts the number of students in the STUDENT table where CITY_CODE matches p_city_code and stores the count in v_student_count. If p_operation_mode equals 5, it deletes students from the STUDENT table where CITY_CODE matches p_city_code and AGE is greater than 25. If none of the specified operation modes match, it inserts a new row into the STUDENT table with STUID set to 9999, LNAME set to 'Generated', FNAME set to 'Student', AGE set to 20, SEX set to 'M', MAJOR set to 700, ADVISOR set to 8000, and CITY_CODE set to p_city_code. After executing the operation based on p_operation_mode, the procedure checks if p_operation_mode is even using the MOD function. If it is even, it updates the CITY table by increasing the LATITUDE by 0.1 for the city with CITY_CODE matching p_city_code. If p_operation_mode is odd, it deletes a city from the CITY table where CITY_CODE is not present in the STUDENT table and not present as CITY1_CODE in the DIRECT_DISTANCE table, limiting the deletion to one row using ROWNUM.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_city_data(\n    p_city_code VARCHAR2,\n    p_distance_threshold NUMBER,\n    p_operation_mode NUMBER\n) IS\n    v_city_exists NUMBER;\n    v_distance_count NUMBER;\n    v_student_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_city_exists\n    FROM CITY\n    WHERE CITY_CODE = p_city_code;\n    \n    IF v_city_exists = 0 THEN\n        INSERT INTO CITY (CITY_CODE, CITY_NAME, STATE, COUNTRY, LATITUDE, LONGITUDE)\n        VALUES (p_city_code, 'New City', 'XX', 'USA', 0, 0);\n    ELSIF p_operation_mode = 1 THEN\n        SELECT COUNT(*) INTO v_distance_count\n        FROM DIRECT_DISTANCE\n        WHERE CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code;\n    ELSIF p_operation_mode = 2 THEN\n        DELETE FROM DIRECT_DISTANCE\n        WHERE (CITY1_CODE = p_city_code OR CITY2_CODE = p_city_code)\n        AND DISTANCE > p_distance_threshold;\n    ELSIF p_operation_mode = 3 THEN\n        INSERT INTO DIRECT_DISTANCE (CITY1_CODE, CITY2_CODE, DISTANCE)\n        SELECT p_city_code, CITY_CODE, p_distance_threshold\n        FROM CITY\n        WHERE CITY_CODE != p_city_code AND ROWNUM <= 3;\n    ELSIF p_operation_mode = 4 THEN\n        SELECT COUNT(*) INTO v_student_count\n        FROM STUDENT\n        WHERE CITY_CODE = p_city_code;\n    ELSIF p_operation_mode = 5 THEN\n        DELETE FROM STUDENT\n        WHERE CITY_CODE = p_city_code AND AGE > 25;\n    ELSE\n        INSERT INTO STUDENT (STUID, LNAME, FNAME, AGE, SEX, MAJOR, ADVISOR, CITY_CODE)\n        VALUES (9999, 'Generated', 'Student', 20, 'M', 700, 8000, p_city_code);\n    END IF;\n    \n    IF MOD(p_operation_mode, 2) = 0 THEN\n        UPDATE CITY\n        SET LATITUDE = LATITUDE + 0.1\n        WHERE CITY_CODE = p_city_code;\n    ELSE\n        DELETE FROM CITY\n        WHERE CITY_CODE NOT IN (SELECT DISTINCT CITY_CODE FROM STUDENT)\n        AND CITY_CODE NOT IN (SELECT DISTINCT CITY1_CODE FROM DIRECT_DISTANCE)\n        AND ROWNUM = 1;\n    END IF;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "BEGIN\n  manage_city_data('NYC', 100, 0);\nEND;",
      "BEGIN\n  manage_city_data('BAL', 500, 1);\nEND;",
      "BEGIN\n  manage_city_data('PIT', 200, 2);\nEND;",
      "BEGIN\n  manage_city_data('PHL', 150, 3);\nEND;",
      "BEGIN\n  manage_city_data('WAS', 300, 5);\nEND;"
    ],
    "summary": "Create a stored procedure named manage_city_data that performs different operations based on an operation mode: insert a new city if it doesn't exist; for mode 1, count related distances; mode 2, delete distances above a threshold; mode 3, insert up to 3 new distance records; mode 4, count students; mode 5, delete students over age 25; default mode, insert a generated student. Finally, update latitude for even modes or delete an unused city for odd modes.",
    "natural_language": "Hey, can you whip up a stored procedure called manage_city_data? It should do different stuff depending on what mode you give it. Basically, first off, it should add a new city if that city isn't already there. Then, if the mode is 1, count up all the related distances. For mode 2, get rid of any distances that are above a certain limit. Mode 3 is for popping in up to three new distance records. If it's mode 4, count how many students there are. Mode 5 means deleting any students who are over 25 years old. And if it's any other mode (the default), just insert a new, made-up student. Oh, and one last thing: for even-numbered modes, update the latitude, and for odd-numbered modes, delete a city that's just sitting there unused.",
    "id": 67,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named manage_city_data that accepts two input parameters: p_mode of type NUMBER, which determines the operation mode, and p_city_code of type VARCHAR2(255), which identifies a specific city. The procedure begins by declaring several local variables: v_city_exists of type NUMBER, v_distance_count of type NUMBER, v_student_count of type NUMBER, v_latitude_new of type NUMBER, v_city_to_delete of type VARCHAR2(255), and v_student_id_new of type NUMBER.\n\nFirst, the procedure checks if the city specified by p_city_code exists in the CITY table by executing a SELECT statement that counts rows where the CITY_CODE column equals p_city_code, storing the result in v_city_exists. If v_city_exists is zero, the procedure inserts a new row into the CITY table with CITY_CODE set to p_city_code, CITY_NAME set to 'New City', STATE set to 'Unknown', COUNTRY set to 'Unknown', LATITUDE set to 0, and LONGITUDE set to 0.\n\nNext, the procedure evaluates the p_mode parameter to determine which operation to perform. For mode 1, it executes a SELECT statement to count all rows in the DIRECT_DISTANCE table where either CITY1_CODE equals p_city_code or CITY2_CODE equals p_city_code, storing the count in v_distance_count, then uses DBMS_OUTPUT.PUT_LINE to output a message concatenating the literal string 'Total distances for city ' with p_city_code, the literal string ': ', and v_distance_count.\n\nFor mode 2, the procedure executes a DELETE statement on the DIRECT_DISTANCE table where DISTANCE is greater than 1000 and either CITY1_CODE equals p_city_code or CITY2_CODE equals p_city_code.\n\nFor mode 3, the procedure inserts up to three new rows into the DIRECT_DISTANCE table. It inserts a row with CITY1_CODE set to p_city_code, CITY2_CODE set to 'AAA', and DISTANCE set to 100; another row with CITY1_CODE set to p_city_code, CITY2_CODE set to 'BBB', and DISTANCE set to 200; and a third row with CITY1_CODE set to p_city_code, CITY2_CODE set to 'CCC', and DISTANCE set to 300.\n\nFor mode 4, the procedure executes a SELECT statement to count all rows in the STUDENT table where CITY_CODE equals p_city_code, storing the count in v_student_count, then uses DBMS_OUTPUT.PUT_LINE to output a message concatenating the literal string 'Total students in city ' with p_city_code, the literal string ': ', and v_student_count.\n\nFor mode 5, the procedure executes a DELETE statement on the STUDENT table where AGE is greater than 25 and CITY_CODE equals p_city_code.\n\nFor any other mode value (the default case), the procedure calculates a new student ID by selecting the maximum STUID from the STUDENT table, adding 1, and storing it in v_student_id_new (or setting it to 1001 if no records exist), then inserts a new row into the STUDENT table with STUID set to v_student_id_new, LNAME set to 'Doe', FNAME set to 'John', AGE set to 20, SEX set to 'M', MAJOR set to 999, ADVISOR set to 9999, and CITY_CODE set to p_city_code.\n\nAfter performing the mode-specific operation, the procedure handles additional logic based on whether p_mode is even or odd. If p_mode is even (i.e., p_mode modulo 2 equals 0), it updates the LATITUDE column in the CITY table for the row where CITY_CODE equals p_city_code by setting LATITUDE to the current LATITUDE value plus 0.5. If p_mode is odd (i.e., p_mode modulo 2 equals 1), it identifies a city to delete by selecting a CITY_CODE from the CITY table where there are no matching rows in the STUDENT table (i.e., the city is unused) and no matching rows in the DIRECT_DISTANCE table where either CITY1_CODE or CITY2_CODE equals that CITY_CODE, ordering by CITY_CODE and limiting to one row using ROWNUM = 1, storing the result in v_city_to_delete. If v_city_to_delete is not null, it executes a DELETE statement on the CITY table where CITY_CODE equals v_city_to_delete."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_member_nationality` that accepts two input parameters: `p_member_id` of type `NUMBER`, representing the unique identifier of a member, and `p_new_nationality` of type `VARCHAR2`, representing the new nationality to be assigned to the member. The procedure begins by declaring two local variables: `v_current_age` of type `NUMBER` to store the member's age, and `v_name_length` of type `NUMBER` to store the length of the member's name. It then executes a `SELECT` statement to retrieve the `AGE` and the `LENGTH` of the `NAME` column from the `MEMBER` table. These retrieved values are stored into the `v_current_age` and `v_name_length` variables, respectively. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `MEMBER_ID` column matches the input parameter `p_member_id` is considered. Following this data retrieval, the procedure enters a conditional block. The first condition checks if `v_current_age` is less than 20 AND `v_name_length` is greater than 10. If this condition is true, an `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the uppercase version of the `p_new_nationality` input parameter, achieved by using the `UPPER()` function. This update is applied only to the row where the `MEMBER_ID` column matches `p_member_id`. If the first condition is false, the procedure proceeds to an `ELSIF` condition. This condition checks if `v_current_age` is greater than or equal to 20 AND `v_current_age` is less than or equal to 30. If this `ELSIF` condition is true, another `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the lowercase version of the `p_new_nationality` input parameter, achieved by using the `LOWER()` function. This update is also applied only to the row where the `MEMBER_ID` column matches `p_member_id`. If both the initial `IF` and the `ELSIF` conditions are false, the procedure executes the `ELSE` block. Within this `ELSE` block, a final `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the title-cased version of the `p_new_nationality` input parameter, where the first letter of each word is capitalized and the rest are lowercase, achieved by using the `INITCAP()` function. This update is applied only to the row where the `MEMBER_ID` column matches `p_member_id`. After the conditional updates to the `MEMBER` table, the procedure executes a `DELETE` statement. This `DELETE` statement removes rows from the `CLUB_LEADER` table where the `MEMBER_ID` column matches the input parameter `p_member_id` AND the `YEAR_JOIN` column is less than the string literal '2016'.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_member_nationality(p_member_id NUMBER, p_new_nationality VARCHAR2)\nIS\n   v_current_age NUMBER;\n   v_name_length NUMBER;\nBEGIN\n   SELECT AGE, LENGTH(NAME)\n   INTO v_current_age, v_name_length\n   FROM MEMBER\n   WHERE MEMBER_ID = p_member_id;\n   \n   IF v_current_age < 20 AND v_name_length > 10 THEN\n      UPDATE MEMBER \n      SET NATIONALITY = UPPER(p_new_nationality)\n      WHERE MEMBER_ID = p_member_id;\n   ELSIF v_current_age >= 20 AND v_current_age <= 30 THEN\n      UPDATE MEMBER \n      SET NATIONALITY = LOWER(p_new_nationality)\n      WHERE MEMBER_ID = p_member_id;\n   ELSE\n      UPDATE MEMBER \n      SET NATIONALITY = INITCAP(p_new_nationality)\n      WHERE MEMBER_ID = p_member_id;\n   END IF;\n   \n   DELETE FROM CLUB_LEADER \n   WHERE MEMBER_ID = p_member_id \n   AND YEAR_JOIN < '2016';\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "BEGIN\n  update_member_nationality(1984, 'American');\n  commit;\nEND;",
      "BEGIN\n  update_member_nationality(1985, 'Canadian');\n  commit;\nEND;",
      "BEGIN\n  update_member_nationality(1986, 'British');\n  commit;\nEND;",
      "BEGIN\n  update_member_nationality(1988, 'Australian');\n  commit;\nEND;",
      "BEGIN\n  update_member_nationality(1989, 'Indian');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named `update_member_nationality` that updates a member's nationality based on their age and name length. It takes a member ID and a new nationality as input. First, retrieve the member's age and name length. If the member is under 20 and their name length is greater than 10, update their nationality to the uppercase version of the input. If the member is between 20 and 30 (inclusive), update their nationality to the lowercase version. Otherwise, update it to the title-cased version. Finally, delete any records for this member from the `CLUB_LEADER` table where they joined before '2016'.",
    "natural_language": "Write a stored procedure called `update_member_nationality` to update a member's nationality using their age and name length. The procedure should accept a member ID and a new nationality. Fetch the member's age and name length. For members under 20 with a name longer than 10 characters, set the nationality to the uppercase input. For those aged 20 to 30, set it to the lowercase input. For all others, use the title-cased input. Then, remove any entries for this member from the `CLUB_LEADER` table where the join date is earlier than '2016'.",
    "id": 68,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `update_member_nationality` that accepts two input parameters: `p_member_id` of type `NUMBER`, representing the unique identifier of a member, and `p_new_nationality` of type `VARCHAR2`, representing the new nationality to be assigned to the member. The procedure begins by declaring two local variables: `v_current_age` of type `NUMBER` to store the member's age, and `v_name_length` of type `NUMBER` to store the length of the member's name. It then executes a `SELECT` statement to retrieve the `AGE` and the `LENGTH` of the `NAME` column from the `MEMBER` table. These retrieved values are stored into the `v_current_age` and `v_name_length` variables, respectively. The selection is filtered by a `WHERE` clause, ensuring that only the row where the `MEMBER_ID` column matches the input parameter `p_member_id` is considered. Following this data retrieval, the procedure enters a conditional block. The first condition checks if `v_current_age` is less than 20 AND `v_name_length` is greater than 10. If this condition is true, an `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the uppercase version of the `p_new_nationality` input parameter, achieved by using the `UPPER()` function. This update is applied only to the row where the `MEMBER_ID` column matches `p_member_id`. If the first condition is false, the procedure proceeds to an `ELSIF` condition. This condition checks if `v_current_age` is greater than or equal to 20 AND `v_current_age` is less than or equal to 30. If this `ELSIF` condition is true, another `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the lowercase version of the `p_new_nationality` input parameter, achieved by using the `LOWER()` function. This update is also applied only to the row where the `MEMBER_ID` column matches `p_member_id`. If both the initial `IF` and the `ELSIF` conditions are false, the procedure executes the `ELSE` block. Within this `ELSE` block, a final `UPDATE` statement is executed on the `MEMBER` table. This `UPDATE` statement sets the `NATIONALITY` column to the title-cased version of the `p_new_nationality` input parameter, where the first letter of each word is capitalized and the rest are lowercase, achieved by using the `INITCAP()` function. This update is applied only to the row where the `MEMBER_ID` column matches `p_member_id`. After the conditional updates to the `MEMBER` table, the procedure executes a `DELETE` statement. This `DELETE` statement removes rows from the `CLUB_LEADER` table where the `MEMBER_ID` column matches the input parameter `p_member_id` AND the `YEAR_JOIN` column is less than the string literal '2016'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_new_gymnast that accepts two input parameters: p_name of type VARCHAR2, which represents the name of the new gymnast, and p_age of type NUMBER, which represents the age of the new gymnast. The procedure first declares a local variable v_people_id of type NUMBER. It then executes a SELECT statement on the PEOPLE table to calculate a new unique identifier by finding the current maximum value in the PEOPLE_ID column, using the NVL function to return 0 if the column is null, and adding 1 to that result; this calculated value is stored into the local variable v_people_id. Following this, the procedure performs an INSERT operation into the PEOPLE table, creating a new row with the PEOPLE_ID column set to the value of v_people_id, the NAME column set to the input parameter p_name, and the AGE column set to the input parameter p_age. Subsequently, the procedure performs a second INSERT operation into the GYMNAST table, creating a new row where the GYMNAST_ID column is set to the same v_people_id value, and initializing the score columns FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, and TOTAL_POINTS all to the value 0.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_gymnast(p_name IN VARCHAR2, p_age IN NUMBER)\nIS\n    v_people_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(PEOPLE_ID), 0) + 1 INTO v_people_id FROM PEOPLE;\n\n    INSERT INTO PEOPLE (PEOPLE_ID, NAME, AGE)\n    VALUES (v_people_id, p_name, p_age);\n\n    INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS)\n    VALUES (v_people_id, 0, 0, 0, 0, 0, 0, 0);\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_gymnast('John Doe', 22);\n  commit;\nEND;",
      "BEGIN\n  insert_new_gymnast('Jane Smith', 19);\n  commit;\nEND;",
      "BEGIN\n  insert_new_gymnast('Michael Johnson', 25);\n  commit;\nEND;",
      "BEGIN\n  insert_new_gymnast('Emily Davis', 20);\n  commit;\nEND;",
      "BEGIN\n  insert_new_gymnast('Chris Brown', 23);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named insert_new_gymnast that adds a new gymnast. It generates a new unique ID for the PEOPLE table, inserts the person's name and age, and then inserts a corresponding record into the GYMNAST table with all scores initialized to zero.",
    "natural_language": "Please construct a stored procedure designated as 'insert_new_gymnast' to facilitate the addition of a new gymnast. The procedure must generate a novel, unique identifier for insertion into the PEOPLE table, subsequently inserting the individual's name and age. Following this, it shall insert a corresponding entry into the GYMNAST table, initializing all performance scores to a value of zero.",
    "id": 69,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named insert_new_gymnast that is designed to insert a new gymnast record into the database by first adding a person to the PEOPLE table and then adding corresponding gymnast performance data to the GYMNAST table. The procedure accepts two input parameters: p_name (IN VARCHAR2) which holds the full name of the new gymnast, and p_age (IN NUMBER) which holds the age of the new gymnast.\n\nThe procedure declares two local variables: v_new_id of type NUMBER to store the newly generated unique identifier for the person/gymnast, and v_existing_id of type NUMBER to check for potential ID conflicts.\n\nThe procedure's logic begins by generating a new unique identifier. It does this by querying the PEOPLE table to find the maximum existing value in the PEOPLE_ID column and then adding 1 to that maximum value. This calculated value is assigned to v_new_id. To ensure this new ID does not already exist in the GYMNAST table (which shares the same ID value via the foreign key relationship GYMNAST.GYMNAST_ID = PEOPLE.PEOPLE_ID), the procedure performs a second check. It executes a SELECT statement on the GYMNAST table, counting the number of records where the GYMNAST_ID equals the newly generated v_new_id. This count is stored in v_existing_id. If v_existing_id is greater than 0, indicating a conflict, the procedure raises a user-defined application error with the message 'Generated ID already exists in GYMNAST table'.\n\nIf no conflict is found, the procedure proceeds with the data insertion. First, it executes an INSERT operation on the PEOPLE table. The INSERT statement specifies the columns PEOPLE_ID, NAME, and AGE. The values inserted are: v_new_id for PEOPLE_ID, the input parameter p_name for NAME, and the input parameter p_age for AGE. The columns HEIGHT and HOMETOWN are not included in this INSERT and will therefore be set to NULL in the new record.\n\nImmediately following the insertion into the PEOPLE table, the procedure executes a second INSERT operation on the GYMNAST table. This INSERT statement specifies all columns of the GYMNAST table: GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, and TOTAL_POINTS. The value for GYMNAST_ID is set to the same v_new_id generated earlier, establishing the link between the two tables. All performance score columns (FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS) are explicitly initialized to the numeric value 0. The TOTAL_POINTS column is also initialized to 0, representing the sum of all individual event scores, which are all zero at insertion.\n\nThe procedure concludes by committing both insert operations to the database with a COMMIT statement, making the changes permanent. The procedure does not have any OUT parameters; its purpose is solely to perform the insertions."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `CalculateOrderDelivery` that accepts three input parameters: `p_order_id` of type `NUMBER`, representing the unique identifier of an order; `p_employee_id` of type `NUMBER`, representing the unique identifier of an employee who is a driver; and `p_truck_id` of type `NUMBER`, representing the unique identifier of a truck. The procedure begins by declaring a local variable `v_order_count` of type `NUMBER` to store the count of existing order deliveries. It then executes a `SELECT` statement to count the number of rows in the `ORDER_DELIVERIES` table. This count is stored in the `v_order_count` variable. The `SELECT` statement includes a `WHERE` clause that filters the rows based on two conditions: `ACTUAL_ORDER_ID` must be equal to the value provided in the `p_order_id` input parameter, and `DRIVER_EMPLOYEE_ID` must be equal to the value provided in the `p_employee_id` input parameter. Following this, an `IF` conditional statement checks if the value of `v_order_count` is equal to `0`. If this condition is true, indicating that no existing order delivery record matches the specified order ID and driver employee ID, then an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `ORDER_DELIVERIES` table. The values inserted into the columns are as follows: the `LOCATION_CODE` column receives the literal string 'New Location'; the `ACTUAL_ORDER_ID` column receives the value from the `p_order_id` input parameter; the `DELIVERY_STATUS_CODE` column receives the literal string 'Pending'; the `DRIVER_EMPLOYEE_ID` column receives the value from the `p_employee_id` input parameter; the `TRUCK_ID` column receives the value from the `p_truck_id` input parameter; and the `DELIVERY_DATE` column receives a formatted string representation of the current system date and time. The `TO_CHAR` function is used to convert the `SYSDATE` (current system date and time) into a string with the format 'YYYY-MM-DD HH24:MI:SS'.",
    "plsql": "CREATE OR REPLACE PROCEDURE CalculateOrderDelivery(\n  p_order_id IN NUMBER,\n  p_employee_id IN NUMBER,\n  p_truck_id IN NUMBER\n) AS\nBEGIN\n  DECLARE\n    v_order_count NUMBER;\n  BEGIN\n    SELECT COUNT(*)\n    INTO v_order_count\n    FROM ORDER_DELIVERIES\n    WHERE ACTUAL_ORDER_ID = p_order_id AND DRIVER_EMPLOYEE_ID = p_employee_id;\n\n    IF v_order_count = 0 THEN\n      INSERT INTO ORDER_DELIVERIES (LOCATION_CODE, ACTUAL_ORDER_ID, DELIVERY_STATUS_CODE, DRIVER_EMPLOYEE_ID, TRUCK_ID, DELIVERY_DATE)\n      VALUES ('New Location', p_order_id, 'Pending', p_employee_id, p_truck_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n    END IF;\n  END;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ORDER_DELIVERIES",
      "CUSTOMERS",
      "CUSTOMER_ADDRESSES",
      "ADDRESSES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "BEGIN\n  CalculateOrderDelivery(1, 6, 11);\n  COMMIT;\nEND;",
      "BEGIN\n  CalculateOrderDelivery(2, 4, 10);\n  COMMIT;\nEND;",
      "BEGIN\n  CalculateOrderDelivery(3, 1, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  CalculateOrderDelivery(4, 8, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  CalculateOrderDelivery(5, 3, 7);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named CalculateOrderDelivery that accepts an order ID, an employee ID, and a truck ID (all NUMBER). It checks if an order delivery record already exists for the given order and driver. If not, it inserts a new record into ORDER_DELIVERIES with the provided IDs, a status of 'Pending', a location of 'New Location', and the current date/time formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "How can I create a stored procedure named CalculateOrderDelivery that takes an order ID, an employee ID, and a truck ID (all as NUMBER) to check for an existing order delivery record for that order and driver, and if none exists, inserts a new record into ORDER_DELIVERIES with those IDs, a 'Pending' status, a 'New Location' location, and the current date and time formatted as 'YYYY-MM-DD HH24:MI:SS'?",
    "id": 70,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `CalculateOrderDelivery` that accepts three input parameters: `p_order_id` of type `NUMBER`, representing the unique identifier of an order; `p_employee_id` of type `NUMBER`, representing the unique identifier of an employee who is a driver; and `p_truck_id` of type `NUMBER`, representing the unique identifier of a truck. The procedure begins by declaring a local variable `v_order_count` of type `NUMBER` to store the count of existing order deliveries. It then executes a `SELECT` statement to count the number of rows in the `ORDER_DELIVERIES` table. This count is stored in the `v_order_count` variable. The `SELECT` statement includes a `WHERE` clause that filters the rows based on two conditions: `ACTUAL_ORDER_ID` must be equal to the value provided in the `p_order_id` input parameter, and `DRIVER_EMPLOYEE_ID` must be equal to the value provided in the `p_employee_id` input parameter. Following this, an `IF` conditional statement checks if the value of `v_order_count` is equal to `0`. If this condition is true, indicating that no existing order delivery record matches the specified order ID and driver employee ID, then an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `ORDER_DELIVERIES` table. The values inserted into the columns are as follows: the `LOCATION_CODE` column receives the literal string 'New Location'; the `ACTUAL_ORDER_ID` column receives the value from the `p_order_id` input parameter; the `DELIVERY_STATUS_CODE` column receives the literal string 'Pending'; the `DRIVER_EMPLOYEE_ID` column receives the value from the `p_employee_id` input parameter; the `TRUCK_ID` column receives the value from the `p_truck_id` input parameter; and the `DELIVERY_DATE` column receives a formatted string representation of the current system date and time. The `TO_CHAR` function is used to convert the `SYSDATE` (current system date and time) into a string with the format 'YYYY-MM-DD HH24:MI:SS'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ADD_NEW_CUSTOMER that accepts five input parameters: a first name as a variable-length string (P_FIRST_NAME), a last name as a variable-length string (P_LAST_NAME), an email address as a variable-length string (P_EMAIL), a phone number as a variable-length string (P_PHONE), and an outstanding monetary amount as a number (P_AMOUNT_OUTSTANDING). The procedure first declares a local variable V_NEW_CUSTOMER_ID of type NUMBER. It begins execution by querying the CUSTOMERS table to find the maximum existing value in the CUSTOMER_ID column, increments that maximum value by one, and stores the result into the local variable V_NEW_CUSTOMER_ID. It then performs an INSERT operation into the CUSTOMERS table, creating a new row with the following column values: the generated V_NEW_CUSTOMER_ID for CUSTOMER_ID, the input parameter P_FIRST_NAME for FIRST_NAME, P_LAST_NAME for LAST_NAME, P_EMAIL for EMAIL_ADDRESS, P_PHONE for PHONE_NUMBER, and P_AMOUNT_OUTSTANDING for AMOUNT_OUTSTANDING. Following this, the procedure executes a second INSERT into the ADDRESSES table using a subquery in the VALUES clause; the subquery selects the maximum existing ADDRESS_ID from the ADDRESSES table, increments it by one, and uses this calculated value for the ADDRESS_ID column, while the remaining columns are populated with literal string values: 'Default Address' for LINE_1_NUMBER_BUILDING, 'Default City' for CITY, '00000' for ZIP_POSTCODE, 'Default State' for STATE_PROVINCE_COUNTY, and 'USA' for COUNTRY. Finally, the procedure executes a DELETE operation on the CUSTOMER_PAYMENTS table, removing any and all rows where the CUSTOMER_ID column matches the newly generated V_NEW_CUSTOMER_ID value.",
    "plsql": "CREATE OR REPLACE PROCEDURE add_new_customer(\n    p_first_name IN VARCHAR2,\n    p_last_name IN VARCHAR2,\n    p_email IN VARCHAR2,\n    p_phone IN VARCHAR2,\n    p_amount_outstanding IN NUMBER\n)\nIS\n    v_new_customer_id NUMBER;\nBEGIN\n    SELECT MAX(CUSTOMER_ID) + 1 INTO v_new_customer_id FROM CUSTOMERS;\n    \n    INSERT INTO CUSTOMERS (CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL_ADDRESS, PHONE_NUMBER, AMOUNT_OUTSTANDING)\n    VALUES (v_new_customer_id, p_first_name, p_last_name, p_email, p_phone, p_amount_outstanding);\n    \n    INSERT INTO ADDRESSES (ADDRESS_ID, LINE_1_NUMBER_BUILDING, CITY, ZIP_POSTCODE, STATE_PROVINCE_COUNTY, COUNTRY)\n    SELECT MAX(ADDRESS_ID) + 1, 'Default Address', 'Default City', '00000', 'Default State', 'USA' FROM ADDRESSES;\n    \n    DELETE FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = v_new_customer_id;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "ADDRESSES"
    ],
    "call_sqls": [
      "BEGIN\n  add_new_customer('John', 'Doe', 'john.doe@example.com', '123-456-7890', 500);\n  commit;\nEND;",
      "BEGIN\n  add_new_customer('Jane', 'Smith', 'jane.smith@example.com', '098-765-4321', 1000);\n  commit;\nEND;",
      "BEGIN\n  add_new_customer('Alice', 'Johnson', 'alice.johnson@example.com', '555-123-4567', 750);\n  commit;\nEND;",
      "BEGIN\n  add_new_customer('Bob', 'Brown', 'bob.brown@example.com', '444-555-6666', 250);\n  commit;\nEND;",
      "BEGIN\n  add_new_customer('Charlie', 'Davis', 'charlie.davis@example.com', '333-222-1111', 1250);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ADD_NEW_CUSTOMER that adds a new customer. It accepts first name, last name, email, phone, and outstanding amount. The procedure generates a new customer ID, inserts the customer into the CUSTOMERS table, inserts a default address into the ADDRESSES table with a generated ID, and deletes any existing payment records for the new customer ID.",
    "natural_language": "Hey, can you whip up a stored procedure called ADD_NEW_CUSTOMER to add a new customer? It should take in their first name, last name, email, phone number, and any money they owe. The procedure needs to cook up a new customer ID, drop their info into the CUSTOMERS table, also pop a default address with a fresh ID into the ADDRESSES table, and get rid of any old payment records tied to that new customer ID.",
    "id": 71,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named ADD_NEW_CUSTOMER that accepts five input parameters: a first name as a variable-length string (P_FIRST_NAME), a last name as a variable-length string (P_LAST_NAME), an email address as a variable-length string (P_EMAIL), a phone number as a variable-length string (P_PHONE), and an outstanding monetary amount as a number (P_AMOUNT_OUTSTANDING). The procedure first declares a local variable V_NEW_CUSTOMER_ID of type NUMBER. It begins execution by querying the CUSTOMERS table to find the maximum existing value in the CUSTOMER_ID column, increments that maximum value by one, and stores the result into the local variable V_NEW_CUSTOMER_ID. It then performs an INSERT operation into the CUSTOMERS table, creating a new row with the following column values: the generated V_NEW_CUSTOMER_ID for CUSTOMER_ID, the input parameter P_FIRST_NAME for FIRST_NAME, P_LAST_NAME for LAST_NAME, P_EMAIL for EMAIL_ADDRESS, P_PHONE for PHONE_NUMBER, and P_AMOUNT_OUTSTANDING for AMOUNT_OUTSTANDING. Following this, the procedure executes a second INSERT into the ADDRESSES table using a subquery in the VALUES clause; the subquery selects the maximum existing ADDRESS_ID from the ADDRESSES table, increments it by one, and uses this calculated value for the ADDRESS_ID column, while the remaining columns are populated with literal string values: 'Default Address' for LINE_1_NUMBER_BUILDING, 'Default City' for CITY, '00000' for ZIP_POSTCODE, 'Default State' for STATE_PROVINCE_COUNTY, and 'USA' for COUNTRY. Finally, the procedure executes a DELETE operation on the CUSTOMER_PAYMENTS table, removing any and all rows where the CUSTOMER_ID column matches the newly generated V_NEW_CUSTOMER_ID value."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `DeleteSchoolDetails` that is designed to remove records from a database table. This procedure accepts one input parameter: `p_school_id`, which is of the `NUMBER` data type. The purpose of this parameter is to specify the unique identifier of the school whose details are to be deleted. The procedure performs a `DELETE` operation on the `SCHOOL_DETAILS` table. The deletion is conditional, meaning only specific rows will be affected. The condition for deletion is `SCHOOL_ID = p_school_id`, which means that any row in the `SCHOOL_DETAILS` table where the value in the `SCHOOL_ID` column exactly matches the value provided in the `p_school_id` input parameter will be targeted for removal.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteSchoolDetails (\n    p_school_id IN NUMBER\n) AS\nBEGIN\n    DELETE FROM SCHOOL_DETAILS\n    WHERE SCHOOL_ID = p_school_id;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteSchoolDetails(1);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteSchoolDetails(2);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteSchoolDetails(3);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteSchoolDetails(4);\n  COMMIT;\nEND;",
      "BEGIN\n  DeleteSchoolDetails(5);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteSchoolDetails that accepts a school ID parameter and deletes all records from the SCHOOL_DETAILS table where the SCHOOL_ID matches the provided parameter.",
    "natural_language": "Construct a stored procedure called DeleteSchoolDetails that is designed to take a school ID as its input parameter and meticulously remove every single associated record from the SCHOOL_DETAILS table, specifically targeting those entries where the SCHOOL_ID column perfectly corresponds to the provided identifier.",
    "id": 72,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DeleteSchoolDetails that accepts one input parameter: p_school_id of type NUMBER which specifies the school identifier to be deleted; the procedure is designed to delete all rows from the SCHOOL_DETAILS table where the SCHOOL_ID column value exactly matches the provided p_school_id parameter; the procedure performs a single DELETE operation on the SCHOOL_DETAILS table with a WHERE clause condition that checks for equality between the SCHOOL_ID column and the input parameter p_school_id; no explicit return value is specified, as the procedure's purpose is to perform a deletion operation, and it does not include any output parameters or result sets; the procedure operates within the school_player database and targets the SCHOOL_DETAILS table exclusively, without involving any other tables or performing additional business logic, calculations, or conditional control flow beyond the deletion itself."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateCourseDetails that accepts three parameters: p_course_id of type NUMBER, p_course_name of type VARCHAR2, and p_course_description of type VARCHAR2. The procedure first declares a local variable v_course_exists of type NUMBER. It then executes a SELECT statement to count the number of rows in the COURSES table where the COURSE_ID column matches the value of the p_course_id parameter, storing the result in the v_course_exists variable. The procedure checks if v_course_exists equals 0, indicating that no course with the specified COURSE_ID exists in the COURSES table. If this condition is true, the procedure terminates immediately using the RETURN statement. If the condition is false, meaning a course with the specified COURSE_ID does exist, the procedure proceeds to execute an UPDATE statement on the COURSES table. This UPDATE statement sets the COURSE_NAME column to the value of the p_course_name parameter and the COURSE_DESCRIPTION column to the value of the p_course_description parameter for the row where the COURSE_ID column matches the value of the p_course_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateCourseDetails(\n    p_course_id NUMBER,\n    p_course_name VARCHAR2,\n    p_course_description VARCHAR2\n) AS\n    v_course_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_course_exists FROM COURSES WHERE COURSE_ID = p_course_id;\n\n    IF v_course_exists = 0 THEN\n        RETURN;\n    ELSE\n        UPDATE COURSES\n        SET COURSE_NAME = p_course_name, COURSE_DESCRIPTION = p_course_description\n        WHERE COURSE_ID = p_course_id;\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "COURSES"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateCourseDetails(1, 'Database Fundamentals', 'Introduction to database concepts and SQL');\nEND;",
      "BEGIN\n  UpdateCourseDetails(2, 'Advanced Database Systems', 'Deep dive into database optimization and administration');\nEND;",
      "BEGIN\n  UpdateCourseDetails(3, 'Operating Systems Internals', 'Core concepts of operating system design and implementation');\nEND;",
      "BEGIN\n  UpdateCourseDetails(1, 'Database Management 101', 'Updated course covering basic to intermediate database topics');\nEND;",
      "BEGIN\n  UpdateCourseDetails(999, 'Non-existent Course', 'This should not update anything');\nEND;"
    ],
    "summary": "Create a stored procedure named `UpdateCourseDetails` that updates the name and description of a course. It accepts a course ID, a new course name, and a new description. First, check if a course with the given ID exists. If not, exit. If it exists, update the COURSE_NAME and COURSE_DESCRIPTION columns for that course.",
    "natural_language": "Create procedure UpdateCourseDetails to update a course's name and description. Check if the course ID exists first. If not, exit. If yes, update COURSE_NAME and COURSE_DESCRIPTION for that ID.",
    "id": 73,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateCourseDetails that accepts three input parameters: p_course_id of type NUMBER which specifies the unique identifier of the course to be updated, p_course_name of type VARCHAR2 which provides the new name for the course, and p_course_description of type VARCHAR2 which provides the new description for the course. The procedure first declares a local variable v_count of type NUMBER to store the result of a validation query. It then performs a SELECT statement that queries the COURSES table, using the COUNT aggregate function to count the number of records where the COURSE_ID column equals the input parameter p_course_id, and assigns this count value to the variable v_count. Following this, the procedure implements a conditional control flow using an IF statement to check if v_count equals 0, indicating that the specified course ID does not exist in the COURSES table. If this condition is true, the procedure exits without performing any update. If the condition is false (meaning v_count is greater than 0, confirming the course ID exists), the procedure executes an UPDATE operation on the COURSES table, setting the COURSE_NAME column to the value of the input parameter p_course_name and the COURSE_DESCRIPTION column to the value of the input parameter p_course_description for the specific record where the COURSE_ID column matches the input parameter p_course_id."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `Delete_Expensive_Products` that is designed to remove records from a database table. This procedure accepts one input parameter and provides one output parameter. The input parameter, `p_price_threshold`, is of data type `NUMBER` and serves the purpose of defining the minimum price value for products to be considered \"expensive\" and thus eligible for deletion. The output parameter, `p_deleted_count`, is also of data type `NUMBER` and is used to return the total number of rows that were successfully deleted by the procedure. Upon execution, the procedure performs a `DELETE` operation on the `PRODUCTS` table. This `DELETE` operation is conditional, targeting only those rows where the value in the `PRICE` column is strictly greater than the value provided in the `p_price_threshold` input parameter. After the `DELETE` statement completes its execution, the procedure then assigns the number of rows affected by the preceding `DELETE` statement to the `p_deleted_count` output parameter. This count is obtained using the `SQL%ROWCOUNT` SQL attribute, which specifically returns the number of rows processed by the most recently executed SQL statement in the current session.",
    "plsql": "CREATE OR REPLACE PROCEDURE Delete_Expensive_Products(\n    p_price_threshold IN NUMBER,\n    p_deleted_count OUT NUMBER\n)\nAS\nBEGIN\n    DELETE FROM PRODUCTS\n    WHERE PRICE > p_price_threshold;\n    \n    p_deleted_count := SQL%ROWCOUNT;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "PRODUCTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(200, v_deleted_count);\n  COMMIT;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(150, v_deleted_count);\n  COMMIT;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(100, v_deleted_count);\n  COMMIT;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(250, v_deleted_count);\n  COMMIT;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  Delete_Expensive_Products(300, v_deleted_count);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named Delete_Expensive_Products that deletes rows from the PRODUCTS table where PRICE exceeds a provided threshold. It returns the number of deleted rows via an output parameter using SQL%ROWCOUNT.",
    "natural_language": "Hey, can you whip up a stored procedure called Delete_Expensive_Products? It should clean out stuff from the PRODUCTS table where the PRICE is just too highâ€”like, over a number we give it. Oh, and we wanna know how many got the axe, so have it spit back that count using SQL%ROWCOUNT.",
    "id": 74,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `Delete_Expensive_Products` that is designed to remove records from a database table. This procedure accepts one input parameter and provides one output parameter. The input parameter, `p_price_threshold`, is of data type `NUMBER` and serves the purpose of defining the minimum price value for products to be considered \"expensive\" and thus eligible for deletion. The output parameter, `p_deleted_count`, is also of data type `NUMBER` and is used to return the total number of rows that were successfully deleted by the procedure. Upon execution, the procedure performs a `DELETE` operation on the `PRODUCTS` table. This `DELETE` operation is conditional, targeting only those rows where the value in the `PRICE` column is strictly greater than the value provided in the `p_price_threshold` input parameter. After the `DELETE` statement completes its execution, the procedure then assigns the number of rows affected by the preceding `DELETE` statement to the `p_deleted_count` output parameter. This count is obtained using the `SQL%ROWCOUNT` SQL attribute, which specifically returns the number of rows processed by the most recently executed SQL statement in the current session."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_complaint_assignments that accepts six parameters: p_complaint_type, p_status_filter, p_product_category, p_customer_type, p_staff_gender, and p_output. The first five parameters are input parameters of type VARCHAR2, and the last one, p_output, is an output parameter of type CLOB. The procedure begins by declaring four local variables of type NUMBER to store counts related to complaints, products, customers, and staff, and a CLOB variable to store JSON results. It then performs a series of SELECT COUNT(*) operations to determine the number of complaints with a specific complaint type code, the number of products with a specific product category code, the number of customers with a specific customer type code, and the number of staff with a specific gender. Based on these counts, the procedure executes different operations: if the complaint count exceeds 10, it constructs a JSON object containing complaint IDs for the specified complaint type and assigns it to p_output; if the product count exceeds 5, it inserts three new complaint records into the COMPLAINTS table with specific values for complaint outcome, status, type, and staff ID, and sets p_output to indicate complaints were created for products; if the customer count exceeds 3, it updates the COMPLAINTS table to set the complaint status code to the provided status filter for complaints associated with the specified customer type, and sets p_output to indicate customer complaints were updated; if the staff count exceeds 2, it deletes closed complaints from the COMPLAINTS table for staff members of the specified gender, and sets p_output to indicate closed complaints were deleted for staff; otherwise, it increases the price of products in the PRODUCTS table by 10% for the specified product category and sets p_output to indicate product prices were increased.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_complaint_assignments(\n    p_complaint_type IN VARCHAR2,\n    p_status_filter IN VARCHAR2,\n    p_product_category IN VARCHAR2,\n    p_customer_type IN VARCHAR2,\n    p_staff_gender IN VARCHAR2,\n    p_output OUT CLOB\n) IS\n    v_complaint_count NUMBER;\n    v_product_count NUMBER;\n    v_customer_count NUMBER;\n    v_staff_count NUMBER;\n    v_json_result CLOB;\nBEGIN\n    SELECT COUNT(*) INTO v_complaint_count FROM COMPLAINTS WHERE COMPLAINT_TYPE_CODE = p_complaint_type;\n    SELECT COUNT(*) INTO v_product_count FROM PRODUCTS WHERE PRODUCT_CATEGORY_CODE = p_product_category;\n    SELECT COUNT(*) INTO v_customer_count FROM CUSTOMERS WHERE CUSTOMER_TYPE_CODE = p_customer_type;\n    SELECT COUNT(*) INTO v_staff_count FROM STAFF WHERE GENDER = p_staff_gender;\n    \n    IF v_complaint_count > 10 THEN\n        SELECT JSON_OBJECTAGG('complaint_id' VALUE c.COMPLAINT_ID RETURNING CLOB)\n        INTO v_json_result\n        FROM COMPLAINTS c\n        WHERE c.COMPLAINT_TYPE_CODE = p_complaint_type;\n        p_output := v_json_result;\n    ELSIF v_product_count > 5 THEN\n        INSERT INTO COMPLAINTS (COMPLAINT_ID, PRODUCT_ID, CUSTOMER_ID, COMPLAINT_OUTCOME_CODE, COMPLAINT_STATUS_CODE, COMPLAINT_TYPE_CODE, STAFF_ID)\n        SELECT ROWNUM + 1000, p.PRODUCT_ID, c.CUSTOMER_ID, 'PENDING', 'New', p_complaint_type, s.STAFF_ID\n        FROM PRODUCTS p, CUSTOMERS c, STAFF s\n        WHERE p.PRODUCT_CATEGORY_CODE = p_product_category\n        AND c.CUSTOMER_TYPE_CODE = p_customer_type\n        AND s.GENDER = p_staff_gender\n        AND ROWNUM <= 3;\n        p_output := 'Complaints created for products';\n    ELSIF v_customer_count > 3 THEN\n        UPDATE COMPLAINTS \n        SET COMPLAINT_STATUS_CODE = p_status_filter\n        WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM CUSTOMERS WHERE CUSTOMER_TYPE_CODE = p_customer_type);\n        p_output := 'Customer complaints updated';\n    ELSIF v_staff_count > 2 THEN\n        DELETE FROM COMPLAINTS \n        WHERE STAFF_ID IN (SELECT STAFF_ID FROM STAFF WHERE GENDER = p_staff_gender)\n        AND COMPLAINT_STATUS_CODE = 'Closed';\n        p_output := 'Closed complaints deleted for staff';\n    ELSE\n        UPDATE PRODUCTS \n        SET PRODUCT_PRICE = PRODUCT_PRICE * 1.1\n        WHERE PRODUCT_CATEGORY_CODE = p_product_category;\n        p_output := 'Product prices increased';\n    END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Failure',\n        p_status_filter => 'Resolved',\n        p_product_category => 'Food',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '1',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;",
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Unusable',\n        p_status_filter => 'Pending',\n        p_product_category => 'Book',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '0',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;",
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Failure',\n        p_status_filter => 'New',\n        p_product_category => 'Hardware',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '1',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;",
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Unusable',\n        p_status_filter => 'Closed',\n        p_product_category => 'Food',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '0',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;",
      "DECLARE\n    v_output CLOB;\nBEGIN\n    process_complaint_assignments(\n        p_complaint_type => 'Product Failure',\n        p_status_filter => 'In Progress',\n        p_product_category => 'Book',\n        p_customer_type => 'Good Credit Rating',\n        p_staff_gender => '1',\n        p_output => v_output\n    );\n    DBMS_OUTPUT.PUT_LINE(v_output);\nEND;"
    ],
    "summary": "Create a stored procedure named process_complaint_assignments. It takes five VARCHAR2 input parameters (complaint type, status filter, product category, customer type, staff gender) and one CLOB output parameter. It counts complaints, products, customers, and staff based on the input parameters. Based on these counts, it performs different actions: if complaint count > 10, output a JSON of complaint IDs; if product count > 5, insert three new complaints and output a message; if customer count > 3, update complaint statuses and output a message; if staff count > 2, delete closed complaints and output a message; otherwise, increase product prices by 10% and output a message.",
    "natural_language": "Hey, so I need you to whip up a stored procedure called 'process_complaint_assignments'. It's gotta take in five VARCHAR2 inputsâ€”think stuff like the type of complaint, a status filter, product category, what kind of customer, and the staff's genderâ€”and spit out one CLOB. What it does is count up complaints, products, customers, and staff based on those inputs you give it. Then, depending on what those counts are, it does different things: if there are more than 10 complaints, it should give back a JSON list of the complaint IDs. If we've got over 5 products, it'll add three new complaint records and tell us it's done. If there are more than 3 customers, it updates the statuses on some complaints and lets us know. If there are more than 2 staff members, it cleans out the old, closed complaints and shoots us a message. And if none of those hit, just bump up all the product prices by 10% and send a confirmation.",
    "id": 75,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named process_complaint_assignments that accepts five input parameters, all of data type VARCHAR2: p_complaint_type, p_status_filter, p_product_category, p_customer_type, and p_staff_gender. The procedure returns a single output parameter of data type CLOB, which will contain a JSON list or a status message.\n\nThe procedure begins by declaring several local variables: v_complaint_count, v_product_count, v_customer_count, and v_staff_count, all of type NUMBER, to store the counts of complaints, products, customers, and staff respectively. It also declares v_output_clob of type CLOB to hold the final output, and v_complaint_ids of type VARCHAR2(4000) to accumulate complaint IDs for JSON formatting.\n\nFirst, the procedure calculates v_complaint_count by performing a SELECT COUNT(*) query on the COMPLAINTS table. This query joins with the PRODUCTS table on PRODUCT_ID to filter by PRODUCT_CATEGORY_CODE matching p_product_category, joins with the CUSTOMERS table on CUSTOMER_ID to filter by CUSTOMER_TYPE_CODE matching p_customer_type, and joins with the STAFF table on STAFF_ID to filter by GENDER matching p_staff_gender. Additionally, it filters the COMPLAINTS table directly where COMPLAINT_TYPE_CODE equals p_complaint_type and COMPLAINT_STATUS_CODE equals p_status_filter.\n\nSecond, the procedure calculates v_product_count by performing a SELECT COUNT(*) query on the PRODUCTS table, filtering where PRODUCT_CATEGORY_CODE equals p_product_category.\n\nThird, the procedure calculates v_customer_count by performing a SELECT COUNT(*) query on the CUSTOMERS table, filtering where CUSTOMER_TYPE_CODE equals p_customer_type.\n\nFourth, the procedure calculates v_staff_count by performing a SELECT COUNT(*) query on the STAFF table, filtering where GENDER equals p_staff_gender.\n\nAfter obtaining these counts, the procedure uses conditional logic to determine the next steps based on the values.\n\nIf v_complaint_count is greater than 10, the procedure constructs a JSON array of complaint IDs. It does this by executing a SELECT LISTAGG query on the COMPLAINTS table to concatenate all COMPLAINT_ID values that meet the same join and filter conditions used for the complaint count, formatted as a JSON array string (e.g., '[1,2,3]'). This string is assigned to v_output_clob.\n\nIf v_product_count is greater than 5, the procedure performs an INSERT operation into the COMPLAINTS table. It inserts three new complaint records with hardcoded values: COMPLAINT_ID values of 9991, 9992, and 9993; PRODUCT_ID of 100; CUSTOMER_ID of 200; COMPLAINT_OUTCOME_CODE of 'Pending'; COMPLAINT_STATUS_CODE of 'New'; COMPLAINT_TYPE_CODE equal to p_complaint_type; DATE_COMPLAINT_RAISED as the current timestamp; DATE_COMPLAINT_CLOSED as NULL; and STAFF_ID of 300. After the insert, it sets v_output_clob to the string 'Three new complaint records added.'\n\nIf v_customer_count is greater than 3, the procedure performs an UPDATE operation on the COMPLAINTS table. It updates the COMPLAINT_STATUS_CODE to 'In Progress' for all complaints where the CUSTOMER_ID exists in a subquery selecting CUSTOMER_ID from the CUSTOMERS table filtered by CUSTOMER_TYPE_CODE equal to p_customer_type. After the update, it sets v_output_clob to the string 'Complaint statuses updated for customer type.'\n\nIf v_staff_count is greater than 2, the procedure performs a DELETE operation on the COMPLAINTS table. It deletes all complaints where COMPLAINT_STATUS_CODE equals 'Closed' and DATE_COMPLAINT_CLOSED is not NULL, and where the STAFF_ID exists in a subquery selecting STAFF_ID from the STAFF table filtered by GENDER equal to p_staff_gender. After the delete, it sets v_output_clob to the string 'Old closed complaints cleaned up.'\n\nIf none of the above conditions are met (i.e., all counts are at or below their thresholds), the procedure performs an UPDATE operation on the PRODUCTS table. It increases the PRODUCT_PRICE by 10% for all products where PRODUCT_CATEGORY_CODE equals p_product_category. After the update, it sets v_output_clob to the string 'Product prices increased by 10%.'\n\nFinally, the procedure returns the value stored in v_output_clob as the output CLOB."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_delete_completed_forms that accepts three input parameters: para_date_started of type VARCHAR2, which represents a date and time string for the start date threshold; para_date_completed of type VARCHAR2, which represents a date and time string for the completion date threshold; and para_status_code of type VARCHAR2, which represents a specific form status code. The procedure performs a DELETE operation on the PARTY_FORMS table. It deletes all rows from the PARTY_FORMS table where the following three conditions are simultaneously met: first, the DATE_COMPLETION_STARTED column, after being converted from a string to a DATE data type using the TO_DATE function with the format model 'YYYY-MM-DD HH24:MI:SS', yields a date that is earlier than the date derived by converting the para_date_started parameter string to a DATE using the same TO_DATE function and format model; second, the DATE_FULLY_COMPLETED column, after being converted from a string to a DATE data type using the TO_DATE function with the format model 'YYYY-MM-DD HH24:MI:SS', yields a date that is earlier than the date derived by converting the para_date_completed parameter string to a DATE using the same TO_DATE function and format model; and third, the FORM_STATUS_CODE column value is exactly equal to the value provided in the para_status_code parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_delete_completed_forms(para_date_started VARCHAR2, para_date_completed VARCHAR2, para_status_code VARCHAR2) IS\nBEGIN\n  DELETE FROM PARTY_FORMS\n  WHERE TO_DATE(DATE_COMPLETION_STARTED, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(para_date_started, 'YYYY-MM-DD HH24:MI:SS')\n    AND TO_DATE(DATE_FULLY_COMPLETED, 'YYYY-MM-DD HH24:MI:SS') < TO_DATE(para_date_completed, 'YYYY-MM-DD HH24:MI:SS')\n    AND FORM_STATUS_CODE = para_status_code;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "FORMS",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_delete_completed_forms('2017-12-10 00:00:00', '2018-02-01 00:00:00', 'Completed');\nEND;",
      "BEGIN\n  sp_delete_completed_forms('2017-12-15 12:00:00', '2018-02-10 10:00:00', 'Partially Completed');\nEND;",
      "BEGIN\n  sp_delete_completed_forms('2017-12-01 00:00:00', '2018-01-01 00:00:00', 'Completed');\nEND;",
      "BEGIN\n  sp_delete_completed_forms('2017-11-01 00:00:00', '2018-03-01 00:00:00', 'Completed');\nEND;",
      "BEGIN\n  sp_delete_completed_forms('2017-12-20 00:00:00', '2018-02-20 00:00:00', 'Partially Completed');\nEND;"
    ],
    "summary": "Create a stored procedure named sp_delete_completed_forms that deletes records from the PARTY_FORMS table where DATE_COMPLETION_STARTED and DATE_FULLY_COMPLETED (converted from strings using format 'YYYY-MM-DD HH24:MI:SS') are earlier than their respective input date thresholds, and FORM_STATUS_CODE matches the input parameter.",
    "natural_language": "Write a stored procedure called sp_delete_completed_forms to remove records from the PARTY_FORMS table where the converted DATE_COMPLETION_STARTED and DATE_FULLY_COMPLETED dates (using the format 'YYYY-MM-DD HH24:MI:SS') are before their given input date thresholds and the FORM_STATUS_CODE equals the provided input parameter.",
    "id": 76,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_delete_completed_forms that accepts three input parameters: a string parameter para_start_date_threshold to specify the threshold date for the DATE_COMPLETION_STARTED column, a string parameter para_completed_date_threshold to specify the threshold date for the DATE_FULLY_COMPLETED column, and a string parameter para_form_status_code to specify the target form status code. The procedure is designed to delete records from the PARTY_FORMS table based on conditions involving date comparisons and a status match.\n\nThe procedure begins by performing a single DELETE operation on the PARTY_FORMS table. The deletion condition involves three criteria that must all be satisfied. First, the DATE_COMPLETION_STARTED column, which is stored as a string in the format 'YYYY-MM-DD HH24:MI:SS', is converted to a DATE data type using the TO_DATE function with the exact format model 'YYYY-MM-DD HH24:MI:SS'. This converted date is then compared to be strictly less than the input parameter para_start_date_threshold, which is also converted from a string to a DATE using the same TO_DATE function and format model. Second, the DATE_FULLY_COMPLETED column, also stored as a string in the format 'YYYY-MM-DD HH24:MI:SS', is similarly converted to a DATE using the TO_DATE function with the format model 'YYYY-MM-DD HH24:MI:SS'. This converted date is then compared to be strictly less than the input parameter para_completed_date_threshold, which is likewise converted from a string to a DATE using the TO_DATE function with the same format model. Third, the FORM_STATUS_CODE column is compared for exact equality with the input string parameter para_form_status_code. Only rows in the PARTY_FORMS table where all three conditions are true are deleted by this operation. The procedure does not return any value and does not include any explicit commit or rollback statements, leaving transaction control to the caller."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateVolumeIssueDate that accepts two input parameters: a numeric parameter named p_volume_id and a string parameter named p_new_issue_date of type VARCHAR2, and executes an UPDATE operation on the database table named VOLUME, specifically modifying the value in the column named ISSUE_DATE to the value provided in the p_new_issue_date parameter, but only for the single row in the VOLUME table where the value in the column named VOLUME_ID is exactly equal to the numeric value provided in the p_volume_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateVolumeIssueDate(\n    p_volume_id IN NUMBER,\n    p_new_issue_date IN VARCHAR2\n) AS\nBEGIN\n    UPDATE VOLUME\n    SET ISSUE_DATE = p_new_issue_date\n    WHERE VOLUME_ID = p_volume_id;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateVolumeIssueDate(1, '15 January 2024');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateVolumeIssueDate(2, '22 January 2024');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateVolumeIssueDate(3, '29 January 2024');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateVolumeIssueDate(1, '5 February 2024');\n  COMMIT;\nEND;",
      "BEGIN\n  UpdateVolumeIssueDate(2, '12 February 2024');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateVolumeIssueDate that updates the ISSUE_DATE column in the VOLUME table for the row where VOLUME_ID matches the provided numeric input parameter.",
    "natural_language": "How can I create a stored procedure called UpdateVolumeIssueDate to update the ISSUE_DATE in the VOLUME table for the row with a specific VOLUME_ID?",
    "id": 77,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateVolumeIssueDate that accepts two parameters: p_volume_id, which is of type NUMBER and serves as the identifier for the volume record to be updated, and p_new_issue_date, which is of type VARCHAR2 and provides the new issue date value to set. The procedure performs an UPDATE operation on the VOLUME table, specifically targeting the ISSUE_DATE column for the row where the VOLUME_ID column matches the value provided in the p_volume_id parameter. The procedure sets the ISSUE_DATE column to the value of the p_new_issue_date parameter for that matching row. After attempting the update, the procedure checks the SQL%ROWCOUNT implicit cursor attribute to determine the number of rows affected by the UPDATE statement. If SQL%ROWCOUNT equals zero, indicating that no rows were updated because no matching VOLUME_ID was found, the procedure raises an application error with code -20001 and the message 'No volume found with the provided ID'. Conversely, if one or more rows were successfully updated, the procedure commits the transaction to make the change permanent in the database. The procedure does not perform any other operations, such as inserts, deletes, or selects, and does not involve any function calls or special operations like UPPER() or LOWER(). The logic flow consists of a single conditional statement that evaluates the outcome of the UPDATE operation based on the SQL%ROWCOUNT value, either raising an error or committing the transaction."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_delete_customer_event_notes that accepts three parameters: p_event_id of type NUMBER, p_service_type of type VARCHAR2, and p_deleted_count of type OUT NUMBER. The procedure performs a delete operation on the CUSTOMER_EVENT_NOTES table, specifically targeting rows where the CUSTOMER_EVENT_ID column matches the value of the p_event_id parameter and the SERVICE_TYPE_CODE column matches the value of the p_service_type parameter. After executing the delete operation, the procedure assigns the number of rows deleted to the p_deleted_count parameter using the SQL%ROWCOUNT attribute, which provides the count of rows affected by the most recent SQL statement executed within the session.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_delete_customer_event_notes(\n    p_event_id IN NUMBER,\n    p_service_type IN VARCHAR2,\n    p_deleted_count OUT NUMBER\n)\nIS\nBEGIN\n    DELETE FROM CUSTOMER_EVENT_NOTES\n    WHERE CUSTOMER_EVENT_ID = p_event_id\n    AND SERVICE_TYPE_CODE = p_service_type;\n    p_deleted_count := SQL%ROWCOUNT;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "SERVICES",
      "RESIDENTS_SERVICES",
      "THINGS"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(70, 'Cleanning', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(160, 'Check', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(166, 'Moving Out', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(428, 'Cleanning', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  proc_delete_customer_event_notes(70, 'Check', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_deleted_count);\nEND;"
    ],
    "summary": "Create a stored procedure named proc_delete_customer_event_notes that accepts p_event_id NUMBER, p_service_type VARCHAR2, and an OUT parameter p_deleted_count NUMBER. Delete rows from CUSTOMER_EVENT_NOTES where CUSTOMER_EVENT_ID equals p_event_id and SERVICE_TYPE_CODE equals p_service_type. Return the number of deleted rows in p_deleted_count.",
    "natural_language": "Please construct a stored procedure designated as `proc_delete_customer_event_notes`. This procedure shall accept two input parameters: `p_event_id` of type NUMBER and `p_service_type` of type VARCHAR2. Additionally, it must include an OUT parameter named `p_deleted_count` of type NUMBER. The procedure's function is to remove all records from the `CUSTOMER_EVENT_NOTES` table where the `CUSTOMER_EVENT_ID` column matches the provided `p_event_id` and the `SERVICE_TYPE_CODE` column matches the provided `p_service_type`. Upon completion, the procedure must assign the total count of rows deleted to the `p_deleted_count` parameter.",
    "id": 78,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named proc_delete_customer_event_notes that accepts three parameters: p_event_id as an input NUMBER parameter representing the customer event identifier, p_service_type as an input VARCHAR2 parameter representing the service type code, and p_deleted_count as an output NUMBER parameter that will return the count of rows deleted. The procedure executes a DELETE statement on the CUSTOMER_EVENT_NOTES table with a WHERE clause that filters rows based on two conditions: the CUSTOMER_EVENT_ID column must equal the input parameter p_event_id, and the SERVICE_TYPE_CODE column must equal the input parameter p_service_type. After the DELETE operation, the procedure uses the SQL%ROWCOUNT attribute to capture the number of rows affected by the delete statement and assigns this value to the output parameter p_deleted_count."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named adjust_student_grades that accepts a single input parameter p_student_id of type NUMBER, which represents the unique identifier of a student. The procedure begins by declaring two local variables: v_grade and v_friend_count, both of type NUMBER. It then retrieves the current grade of the student with the specified ID from the HIGHSCHOOLER table and stores it in the v_grade variable. Next, it calculates the number of friends associated with the student by counting the entries in the FRIEND table where the STUDENT_ID matches the provided p_student_id, storing this count in the v_friend_count variable. The procedure then evaluates the student's grade using conditional logic. If the student's grade is greater than 8, it checks the number of friends. If the student has more than 10 friends, it increases the student's grade by 1 in the HIGHSCHOOLER table. If the student has 10 or fewer friends, it deletes all entries from the FRIEND table where STUDENT_ID matches p_student_id. If the student's grade is 8 or less, the procedure checks the number of friends again. If the student has fewer than 5 friends, it decreases the student's grade by 1 in the HIGHSCHOOLER table. If the student has 5 or more friends, it deletes all entries from the LIKES table where STUDENT_ID matches p_student_id. If the grade does not meet any of the specified conditions, the procedure inserts a new row into the HIGHSCHOOLER table with a randomly generated ID between 1000 and 2000, a name 'NewStudent', and a grade of 9.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_student_grades(\n    p_student_id IN NUMBER\n) IS\n    v_grade NUMBER;\n    v_friend_count NUMBER;\nBEGIN\n    SELECT GRADE INTO v_grade FROM HIGHSCHOOLER WHERE ID = p_student_id;\n\n    SELECT COUNT(*) INTO v_friend_count\n    FROM FRIEND\n    WHERE STUDENT_ID = p_student_id;\n\n    IF v_grade > 8 THEN\n        IF v_friend_count > 10 THEN\n            UPDATE HIGHSCHOOLER SET GRADE = v_grade + 1 WHERE ID = p_student_id;\n        ELSE\n            DELETE FROM FRIEND WHERE STUDENT_ID = p_student_id;\n        END IF;\n    ELSIF v_grade <= 8 THEN\n        IF v_friend_count < 5 THEN\n            UPDATE HIGHSCHOOLER SET GRADE = v_grade - 1 WHERE ID = p_student_id;\n        ELSE\n            DELETE FROM LIKES WHERE STUDENT_ID = p_student_id;\n        END IF;\n    ELSE\n        INSERT INTO HIGHSCHOOLER (ID, NAME, GRADE) VALUES (FLOOR(DBMS_RANDOM.VALUE(1000, 2000)), 'NewStudent', 9);\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_student_grades(1510);\nEND;",
      "BEGIN\n  adjust_student_grades(1689);\nEND;",
      "BEGIN\n  adjust_student_grades(1381);\nEND;",
      "BEGIN\n  adjust_student_grades(1101);\nEND;",
      "BEGIN\n  adjust_student_grades(1247);\nEND;"
    ],
    "summary": "Create a stored procedure named adjust_student_grades that adjusts a student's status based on their grade and friend count. For grades >8: if friends >10, increase grade by 1; otherwise, delete all friends. For grades <=8: if friends <5, decrease grade by 1; otherwise, delete all likes given. If no conditions match, insert a new default student.",
    "natural_language": "Formulate a stored procedure designated as `adjust_student_grades` to modify a student's standing contingent upon their academic grade and quantity of associates. For scholars with a grade exceeding eight: should their associate count surpass ten, increment the grade by one; if not, expunge all associated records. For scholars with a grade of eight or below: should their associate count be fewer than five, decrement the grade by one; otherwise, remove all records of likes issued. In the event that none of the stipulated conditions are satisfied, insert a new student record with default parameters.",
    "id": 79,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named adjust_student_grades that accepts a single input parameter p_student_id of type NUMBER, which represents the unique identifier of a student. The procedure begins by declaring two local variables: v_grade and v_friend_count, both of type NUMBER. It then retrieves the current grade of the student with the specified ID from the HIGHSCHOOLER table and stores it in the v_grade variable. Next, it calculates the number of friends associated with the student by counting the entries in the FRIEND table where the STUDENT_ID matches the provided p_student_id, storing this count in the v_friend_count variable. The procedure then evaluates the student's grade using conditional logic. If the student's grade is greater than 8, it checks the number of friends. If the student has more than 10 friends, it increases the student's grade by 1 in the HIGHSCHOOLER table. If the student has 10 or fewer friends, it deletes all entries from the FRIEND table where STUDENT_ID matches p_student_id. If the student's grade is 8 or less, the procedure checks the number of friends again. If the student has fewer than 5 friends, it decreases the student's grade by 1 in the HIGHSCHOOLER table. If the student has 5 or more friends, it deletes all entries from the LIKES table where STUDENT_ID matches p_student_id. If the grade does not meet any of the specified conditions, the procedure inserts a new row into the HIGHSCHOOLER table with a randomly generated ID between 1000 and 2000, a name 'NewStudent', and a grade of 9."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `delete_gymnast` that accepts two input parameters: `p_gymnast_id` of data type `NUMBER` and `p_people_id` of data type `NUMBER`. The purpose of this procedure is to remove specific records from two distinct tables. The procedure first executes a `DELETE` operation on the `GYMNAST` table. This deletion targets rows where the value in the `GYMNAST_ID` column precisely matches the value provided in the `p_gymnast_id` input parameter. Following this, the procedure performs a second `DELETE` operation, this time on the `PEOPLE` table. This subsequent deletion targets rows within the `PEOPLE` table where the value in the `PEOPLE_ID` column exactly corresponds to the value supplied in the `p_people_id` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_gymnast(p_gymnast_id IN NUMBER, p_people_id IN NUMBER)\nIS\nBEGIN\n    DELETE FROM GYMNAST WHERE GYMNAST_ID = p_gymnast_id;\n    DELETE FROM PEOPLE WHERE PEOPLE_ID = p_people_id;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "BEGIN\n  delete_gymnast(1, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_gymnast(2, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_gymnast(4, 3);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_gymnast(5, 5);\n  COMMIT;\nEND;",
      "BEGIN\n  delete_gymnast(10, 10);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named `delete_gymnast` that deletes a record from the GYMNAST table where GYMNAST_ID matches the input parameter `p_gymnast_id`, and then deletes a record from the PEOPLE table where PEOPLE_ID matches the input parameter `p_people_id`.",
    "natural_language": "Please construct a stored procedure designated as `delete_gymnast`. This procedure shall perform the deletion of a record from the GYMNAST table, specifically where the GYMNAST_ID column corresponds to the provided input parameter `p_gymnast_id`. Subsequently, it shall delete a record from the PEOPLE table where the PEOPLE_ID column matches the supplied input parameter `p_people_id`.",
    "id": 80,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named delete_gymnast that accepts two input parameters. The first parameter, p_gymnast_id, is of data type NUMBER and represents the unique identifier for a gymnast record to be deleted from the GYMNAST table. The second parameter, p_people_id, is also of data type NUMBER and represents the unique identifier for a person record to be deleted from the PEOPLE table. The procedure performs two DELETE operations sequentially. The first DELETE operation targets the GYMNAST table, removing the row where the GYMNAST_ID column exactly matches the value provided by the p_gymnast_id input parameter. The second DELETE operation targets the PEOPLE table, removing the row where the PEOPLE_ID column exactly matches the value provided by the p_people_id input parameter. The procedure executes these deletions in the specified order: first from the GYMNAST table, then from the PEOPLE table. There is no explicit return value or output, as the procedure's purpose is to perform deletions based on the provided identifiers."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_review_statistics` that accepts a single input parameter, `para_book_id`, of data type `NUMBER`. This procedure first declares two local variables: `v_avg_rating` of data type `NUMBER` and `v_total_readers` of data type `NUMBER`. The procedure then proceeds to execute two separate `SELECT` statements. The first `SELECT` statement calculates the average value of the `RATING` column from the `REVIEW` table, specifically for rows where the `BOOK_ID` column matches the value provided in `para_book_id`, and stores this calculated average into the `v_avg_rating` variable. The second `SELECT` statement calculates the sum of the `READERS_IN_MILLION` column from the `REVIEW` table, again only for rows where the `BOOK_ID` column matches the value of `para_book_id`, and stores this sum into the `v_total_readers` variable. Following these selections, the procedure enters a conditional block. If the value of `v_avg_rating` is strictly greater than 7, an `UPDATE` operation is performed on the `REVIEW` table. This `UPDATE` statement decrements the value in the `RANK` column by 1 for all rows where the `BOOK_ID` column matches `para_book_id` and the `RATING` column is strictly greater than 7. Otherwise (if `v_avg_rating` is not strictly greater than 7), a `DELETE` operation is executed on the `REVIEW` table. This `DELETE` statement removes all rows where the `BOOK_ID` column matches `para_book_id` and the `RATING` column is strictly less than 4. After this first conditional block, the procedure enters a second, independent conditional block. If the value of `v_total_readers` is strictly greater than 10, an `UPDATE` operation is performed on the `REVIEW` table. This `UPDATE` statement increments the value in the `READERS_IN_MILLION` column by 1 for all rows where the `BOOK_ID` column matches `para_book_id` and the `READERS_IN_MILLION` column is strictly greater than 10. Finally, the procedure enters a third, independent conditional block. If the value of `v_total_readers` is strictly less than 5, a `DELETE` operation is executed on the `REVIEW` table. This `DELETE` statement removes all rows where the `BOOK_ID` column matches `para_book_id` and the `READERS_IN_MILLION` column is strictly less than 5.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_review_statistics(para_book_id NUMBER) IS\n  v_avg_rating NUMBER;\n  v_total_readers NUMBER;\nBEGIN\n  SELECT AVG(RATING) INTO v_avg_rating FROM REVIEW WHERE BOOK_ID = para_book_id;\n  SELECT SUM(READERS_IN_MILLION) INTO v_total_readers FROM REVIEW WHERE BOOK_ID = para_book_id;\n  \n  IF v_avg_rating > 7 THEN\n    UPDATE REVIEW SET RANK = RANK - 1 WHERE BOOK_ID = para_book_id AND RATING > 7;\n  ELSE\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND RATING < 4;\n  END IF;\n  \n  IF v_total_readers > 10 THEN\n    UPDATE REVIEW SET READERS_IN_MILLION = READERS_IN_MILLION + 1 WHERE BOOK_ID = para_book_id AND READERS_IN_MILLION > 10;\n  END IF;\n  \n  IF v_total_readers < 5 THEN\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND READERS_IN_MILLION < 5;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp_review_statistics(1);\nEND;",
      "BEGIN\n  sp_review_statistics(2);\nEND;",
      "BEGIN\n  sp_review_statistics(3);\nEND;",
      "BEGIN\n  sp_review_statistics(4);\nEND;",
      "BEGIN\n  sp_review_statistics(5);\nEND;"
    ],
    "summary": "Create a stored procedure named sp_review_statistics that accepts a book ID. Calculate the average rating and total readers for that book. If the average rating exceeds 7, decrement the rank by one for all reviews of that book with a rating above 7. Otherwise, delete all reviews for that book with a rating below 4. If the total readers exceed 10, increment the reader count by one for all reviews of that book where the reader count exceeds 10. If the total readers are below 5, delete all reviews for that book where the reader count is below 5.",
    "natural_language": "What stored procedure logic should be implemented for a given book ID to calculate its average rating and total readers, then conditionally decrement the rank for high-rated reviews if the average is above 7, delete low-rated reviews if the average is 7 or below, increment the reader count for popular reviews if total readers exceed 10, and delete reviews with low reader counts if total readers are below 5?",
    "id": 81,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp_review_statistics` that accepts a single input parameter, `para_book_id`, of data type `NUMBER`. This procedure first declares two local variables: `v_avg_rating` of data type `NUMBER` and `v_total_readers` of data type `NUMBER`. The procedure then proceeds to execute two separate `SELECT` statements. The first `SELECT` statement calculates the average value of the `RATING` column from the `REVIEW` table, specifically for rows where the `BOOK_ID` column matches the value provided in `para_book_id`, and stores this calculated average into the `v_avg_rating` variable. The second `SELECT` statement calculates the sum of the `READERS_IN_MILLION` column from the `REVIEW` table, again only for rows where the `BOOK_ID` column matches the value of `para_book_id`, and stores this sum into the `v_total_readers` variable. Following these selections, the procedure enters a conditional block. If the value of `v_avg_rating` is strictly greater than 7, an `UPDATE` operation is performed on the `REVIEW` table. This `UPDATE` statement decrements the value in the `RANK` column by 1 for all rows where the `BOOK_ID` column matches `para_book_id` and the `RATING` column is strictly greater than 7. Otherwise (if `v_avg_rating` is not strictly greater than 7), a `DELETE` operation is executed on the `REVIEW` table. This `DELETE` statement removes all rows where the `BOOK_ID` column matches `para_book_id` and the `RATING` column is strictly less than 4. After this first conditional block, the procedure enters a second, independent conditional block. If the value of `v_total_readers` is strictly greater than 10, an `UPDATE` operation is performed on the `REVIEW` table. This `UPDATE` statement increments the value in the `READERS_IN_MILLION` column by 1 for all rows where the `BOOK_ID` column matches `para_book_id` and the `READERS_IN_MILLION` column is strictly greater than 10. Finally, the procedure enters a third, independent conditional block. If the value of `v_total_readers` is strictly less than 5, a `DELETE` operation is executed on the `REVIEW` table. This `DELETE` statement removes all rows where the `BOOK_ID` column matches `para_book_id` and the `READERS_IN_MILLION` column is strictly less than 5."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `delete_old_weddings` that accepts one input parameter, `p_year`, which is of `NUMBER` data type and represents a specific year. The purpose of this procedure is to identify and delete wedding records from the `WEDDING` table that occurred before the year specified by `p_year`.\n\nThe procedure begins by declaring three local variables: `v_church_id` of `NUMBER` type, `v_male_id` of `NUMBER` type, and `v_female_id` of `NUMBER` type. These variables are used to temporarily store the `CHURCH_ID`, `MALE_ID`, and `FEMALE_ID` values, respectively, for each wedding record being processed.\n\nThe core logic of the procedure involves iterating through a result set obtained from a `SELECT` statement. This `SELECT` statement retrieves the `CHURCH_ID`, `MALE_ID`, and `FEMALE_ID` columns from the `WEDDING` table for all rows where the `YEAR` column's value is strictly less than the value provided in the `p_year` parameter.\n\nFor each record (`rec`) returned by this `SELECT` statement, the procedure performs the following actions:\n1. The value of `rec.CHURCH_ID` is assigned to the local variable `v_church_id`.\n2. The value of `rec.MALE_ID` is assigned to the local variable `v_male_id`.\n3. The value of `rec.FEMALE_ID` is assigned to the local variable `v_female_id`.\n\nFollowing these assignments, a conditional `IF-ELSIF-ELSE` block is executed to determine how to delete the current wedding record from the `WEDDING` table. The deletion strategy depends on the nullability of the `v_church_id` and `v_male_id` variables:\n\n- **IF `v_church_id` IS NOT NULL**: If the `CHURCH_ID` for the current wedding record is not null, a `DELETE` statement is executed. This `DELETE` statement removes rows from the `WEDDING` table where the `CHURCH_ID` column matches the value of `v_church_id`, the `MALE_ID` column matches the value of `v_male_id`, and the `FEMALE_ID` column matches the value of `v_female_id`. This condition implies that the `CHURCH_ID` is a significant part of the unique identifier for the wedding.\n\n- **ELSIF `v_male_id` IS NOT NULL**: If the `CHURCH_ID` is null, but the `MALE_ID` for the current wedding record is not null, a different `DELETE` statement is executed. This `DELETE` statement removes rows from the `WEDDING` table where the `MALE_ID` column matches the value of `v_male_id` and the `FEMALE_ID` column matches the value of `v_female_id`. This condition suggests that `MALE_ID` and `FEMALE_ID` together form a unique identifier when `CHURCH_ID` is absent.\n\n- **ELSE**: If both `v_church_id` and `v_male_id` are null, the final `DELETE` statement is executed. This `DELETE` statement removes rows from the `WEDDING` table where the `FEMALE_ID` column matches the value of `v_female_id`. This implies that `FEMALE_ID` alone is used as the identifier for deletion when both `CHURCH_ID` and `MALE_ID` are null.\n\nThis loop continues until all wedding records with a `YEAR` less than `p_year` have been processed and potentially deleted based on the described conditional logic.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_weddings(p_year NUMBER) IS\n    v_church_id NUMBER;\n    v_male_id NUMBER;\n    v_female_id NUMBER;\nBEGIN\n    FOR rec IN (SELECT CHURCH_ID, MALE_ID, FEMALE_ID FROM WEDDING WHERE YEAR < p_year) LOOP\n        v_church_id := rec.CHURCH_ID;\n        v_male_id := rec.MALE_ID;\n        v_female_id := rec.FEMALE_ID;\n\n        IF v_church_id IS NOT NULL THEN\n            DELETE FROM WEDDING WHERE CHURCH_ID = v_church_id AND MALE_ID = v_male_id AND FEMALE_ID = v_female_id;\n        ELSIF v_male_id IS NOT NULL THEN\n            DELETE FROM WEDDING WHERE MALE_ID = v_male_id AND FEMALE_ID = v_female_id;\n        ELSE\n            DELETE FROM WEDDING WHERE FEMALE_ID = v_female_id;\n        END IF;\n    END LOOP;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "BEGIN\n  delete_old_weddings(2010);\n  commit;\nEND;",
      "BEGIN\n  delete_old_weddings(2012);\n  commit;\nEND;",
      "BEGIN\n  delete_old_weddings(2014);\n  commit;\nEND;",
      "BEGIN\n  delete_old_weddings(2015);\n  commit;\nEND;",
      "BEGIN\n  delete_old_weddings(2016);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named delete_old_weddings that accepts a year parameter. For each wedding record with a year less than the provided year, retrieve its church, male, and female IDs. If the church ID is not null, delete the wedding using all three IDs. Else, if the male ID is not null, delete using the male and female IDs. Otherwise, delete using only the female ID.",
    "natural_language": "Create a stored procedure to delete some older wedding records. It should take a year as input. For weddings from before that general time period, get the associated church, groom, and bride details. If there's a church linked to the wedding, use that along with the other IDs to remove it. If not, but there is a groom listed, use those two IDs. If neither applies, just use the bride's ID to delete whatever records might be there.",
    "id": 82,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named delete_old_weddings that accepts one input parameter p_year of type NUMBER, which is used as a cutoff year to identify older wedding records for deletion. The procedure declares three local variables: v_church_id of type NUMBER, v_male_id of type NUMBER, and v_female_id of type NUMBER, all initialized to NULL. The procedure begins by executing a SELECT statement that retrieves the CHURCH_ID, MALE_ID, and FEMALE_ID columns from the WEDDING table for a specific row where the YEAR column is less than the input p_year parameter, storing these values into the corresponding local variables v_church_id, v_male_id, and v_female_id. If no such row is found, the procedure does nothing further. Following this, the procedure uses a conditional logic block: first, it checks if the v_church_id variable is not NULL; if true, it executes a DELETE statement on the WEDDING table where the CHURCH_ID column equals the v_church_id variable, the MALE_ID column equals the v_male_id variable, and the FEMALE_ID column equals the v_female_id variable. If the v_church_id is NULL, the procedure then checks if the v_male_id variable is not NULL; if true, it executes a DELETE statement on the WEDDING table where the MALE_ID column equals the v_male_id variable and the FEMALE_ID column equals the v_female_id variable. If both v_church_id and v_male_id are NULL, the procedure checks if the v_female_id variable is not NULL; if true, it executes a DELETE statement on the WEDDING table where the FEMALE_ID column equals the v_female_id variable. The procedure does not return any value and operates within the wedding database."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_insert_friend_if_not_exists that accepts four parameters: p_student_id of type NUMBER, p_friend_id of type NUMBER, p_output_status of type OUT VARCHAR2, and p_output_affected of type OUT NUMBER, along with p_output_grade of type OUT NUMBER. The procedure begins by declaring a local variable v_exists of type NUMBER. It then performs a SELECT operation to count the number of rows in the FRIEND table where the STUDENT_ID column matches the value of p_student_id and the FRIEND_ID column matches the value of p_friend_id, storing the result in v_exists. The procedure uses an IF conditional statement to check if v_exists equals 0, indicating that no such friendship record exists. If true, it executes an INSERT operation to add a new row to the FRIEND table with STUDENT_ID set to p_student_id and FRIEND_ID set to p_friend_id, then sets p_output_affected to 1 and p_output_status to 'FRIEND ADDED'. If v_exists is not 0, meaning the friendship already exists, it sets p_output_affected to 0 and p_output_status to 'FRIEND EXISTS'. Regardless of the conditional outcome, the procedure assigns a value of 0 to p_output_grade, which serves as a placeholder since grade information is not relevant to the procedure's operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_insert_friend_if_not_exists(\n    p_student_id IN NUMBER,\n    p_friend_id IN NUMBER,\n    p_output_status OUT VARCHAR2,\n    p_output_affected OUT NUMBER,\n    p_output_grade OUT NUMBER\n)\nIS\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_exists FROM FRIEND WHERE STUDENT_ID = p_student_id AND FRIEND_ID = p_friend_id;\n    IF v_exists = 0 THEN\n        INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) VALUES (p_student_id, p_friend_id);\n        p_output_affected := 1;\n        p_output_status := 'FRIEND ADDED';\n    ELSE\n        p_output_affected := 0;\n        p_output_status := 'FRIEND EXISTS';\n    END IF;\n\n    p_output_grade := 0; -- Placeholder as grade is not relevant here\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1101, 1641, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1247, 1501, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1101, 1911, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1381, 1510, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;",
      "DECLARE\n  v_status VARCHAR2(20);\n  v_affected NUMBER;\n  v_grade NUMBER;\nBEGIN\n  proc_insert_friend_if_not_exists(1247, 1641, v_status, v_affected, v_grade);\n  DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);\nEND;"
    ],
    "summary": "Create a stored procedure named proc_insert_friend_if_not_exists. It accepts parameters for student ID and friend ID. Check if the friendship already exists. If not, insert it. Return a status message, the number of affected rows (0 or 1), and a placeholder grade value via OUT parameters.",
    "natural_language": "Hey, can you whip up a stored procedure called proc_insert_friend_if_not_exists? It needs to take a student ID and a friend ID. First, check if these two are already buddies. If they're not, go ahead and add the friendship. Then, spit back a status message, tell us if you added anyone (like 0 or 1 row), and also toss out a dummy grade value using those OUT parameters.",
    "id": 83,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named proc_insert_friend_if_not_exists that accepts four parameters: p_student_id of type NUMBER, p_friend_id of type NUMBER, p_output_status of type OUT VARCHAR2, and p_output_affected of type OUT NUMBER, along with p_output_grade of type OUT NUMBER. The procedure begins by declaring a local variable v_exists of type NUMBER. It then performs a SELECT operation to count the number of rows in the FRIEND table where the STUDENT_ID column matches the value of p_student_id and the FRIEND_ID column matches the value of p_friend_id, storing the result in v_exists. The procedure uses an IF conditional statement to check if v_exists equals 0, indicating that no such friendship record exists. If true, it executes an INSERT operation to add a new row to the FRIEND table with STUDENT_ID set to p_student_id and FRIEND_ID set to p_friend_id, then sets p_output_affected to 1 and p_output_status to 'FRIEND ADDED'. If v_exists is not 0, meaning the friendship already exists, it sets p_output_affected to 0 and p_output_status to 'FRIEND EXISTS'. Regardless of the conditional outcome, the procedure assigns a value of 0 to p_output_grade, which serves as a placeholder since grade information is not relevant to the procedure's operations."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named synchronize_lens_mountains that accepts four parameters: p_country_name of type VARCHAR2, p_focal_min and p_focal_max of type NUMBER, and p_batch_size of type NUMBER. The procedure begins by initializing a local variable v_counter to zero, which will be used to count the number of insert operations performed. It then calculates the total number of mountains located in the specified country by executing a SELECT COUNT(*) query on the MOUNTAIN table where the COUNTRY column matches the p_country_name parameter, storing the result in the v_total_mountains variable. Similarly, it calculates the total number of camera lenses with focal lengths between p_focal_min and p_focal_max by executing a SELECT COUNT(*) query on the CAMERA_LENS table, storing the result in the v_total_lenses variable. The procedure retrieves the maximum ID value from the PHOTOS table using a SELECT NVL(MAX(ID), 0) query, storing the result in the v_max_id variable. The procedure then enters a nested loop structure, first iterating over camera lenses with focal lengths between p_focal_min and p_focal_max, ordered by ID, using a cursor named lens_rec. For each lens, it enters a second loop to iterate over mountains in the specified country whose ID modulo 3 matches the lens ID modulo 3, using a cursor named mountain_rec. Within the inner loop, the procedure increments v_counter by one and inserts a new row into the PHOTOS table with the following values: a unique ID calculated as v_max_id plus v_counter, the current lens ID, the current mountain ID, a COLOR value determined by the lens's focal length (WIDE for less than 30, TELE for greater than 100, NORMAL otherwise), and a NAME value concatenating the lens brand and mountain name. If v_counter reaches or exceeds p_batch_size, the procedure exits immediately using a RETURN statement. If the procedure completes the loops without reaching the batch size, it enters another loop to insert additional rows into the PHOTOS table until the batch size is met. In this loop, it inserts rows with a unique ID calculated as v_max_id plus v_counter plus the loop index, the minimum ID from the CAMERA_LENS table, the minimum ID from the MOUNTAIN table for the specified country, a COLOR value of 'DEFAULT', and a NAME value formatted as 'fallback_' followed by the current timestamp and loop index.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_lens_mountains(\n    p_country_name IN VARCHAR2,\n    p_focal_min IN NUMBER,\n    p_focal_max IN NUMBER,\n    p_batch_size IN NUMBER\n) IS\n    v_counter NUMBER := 0;\n    v_total_mountains NUMBER;\n    v_total_lenses NUMBER;\n    v_max_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_mountains\n    FROM MOUNTAIN\n    WHERE COUNTRY = p_country_name;\n    \n    SELECT COUNT(*) INTO v_total_lenses\n    FROM CAMERA_LENS\n    WHERE FOCAL_LENGTH_MM BETWEEN p_focal_min AND p_focal_max;\n    \n    SELECT NVL(MAX(ID), 0) INTO v_max_id FROM PHOTOS;\n    \n    FOR lens_rec IN (\n        SELECT ID, BRAND, NAME, FOCAL_LENGTH_MM\n        FROM CAMERA_LENS\n        WHERE FOCAL_LENGTH_MM BETWEEN p_focal_min AND p_focal_max\n        ORDER BY ID\n    ) LOOP\n        FOR mountain_rec IN (\n            SELECT ID, NAME\n            FROM MOUNTAIN\n            WHERE COUNTRY = p_country_name\n            AND MOD(ID, 3) = MOD(lens_rec.ID, 3)\n        ) LOOP\n            v_counter := v_counter + 1;\n            \n            INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME)\n            VALUES (\n                v_max_id + v_counter,\n                lens_rec.ID,\n                mountain_rec.ID,\n                CASE \n                    WHEN lens_rec.FOCAL_LENGTH_MM < 30 THEN 'WIDE'\n                    WHEN lens_rec.FOCAL_LENGTH_MM > 100 THEN 'TELE'\n                    ELSE 'NORMAL'\n                END,\n                lens_rec.BRAND || '_' || mountain_rec.NAME\n            );\n            \n            IF v_counter >= p_batch_size THEN\n                RETURN;\n            END IF;\n        END LOOP;\n    END LOOP;\n    \n    IF v_counter < p_batch_size THEN\n        FOR i IN 1..(p_batch_size - v_counter) LOOP\n            INSERT INTO PHOTOS (ID, CAMERA_LENS_ID, MOUNTAIN_ID, COLOR, NAME)\n            VALUES (\n                v_max_id + v_counter + i,\n                (SELECT MIN(ID) FROM CAMERA_LENS),\n                (SELECT MIN(ID) FROM MOUNTAIN WHERE COUNTRY = p_country_name),\n                'DEFAULT',\n                'fallback_' || TO_CHAR(CURRENT_TIMESTAMP, 'HH24MISS') || '_' || i\n            );\n        END LOOP;\n    END IF;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "BEGIN\n  synchronize_lens_mountains('Ethiopia', 10, 50, 100);\n  COMMIT;\nEND;",
      "BEGIN\n  synchronize_lens_mountains('Morocco', 20, 200, 50);\n  COMMIT;\nEND;",
      "BEGIN\n  synchronize_lens_mountains('Rwanda Uganda', 30, 300, 200);\n  COMMIT;\nEND;",
      "BEGIN\n  synchronize_lens_mountains('Ethiopia', 1, 500, 10);\n  COMMIT;\nEND;",
      "BEGIN\n  synchronize_lens_mountains('Morocco', 100, 400, 1000);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named synchronize_lens_mountains. It accepts parameters for country name, focal length range, and batch size. For lenses within the focal range and mountains in the specified country where their IDs modulo 3 match, insert new photos with a color based on focal length. Stop and return when the number of inserts reaches the batch size. If the batch size is not met, insert fallback photo records until it is.",
    "natural_language": "Create a stored procedure called synchronize_lens_mountains that takes a country name, a focal length range, and a batch size as parameters. For each matching lens and mountain where the lens focal length is within the range, the mountain is in the specified country, and their IDs modulo 3 are equal, insert a new photo with a color determined by the focal length. Halt and return once the number of inserted photos reaches the batch size. If the batch size is not met, insert fallback photo records until the batch size is fulfilled.",
    "id": 84,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named synchronize_lens_mountains that accepts four parameters: p_country_name of type VARCHAR2, p_focal_min and p_focal_max of type NUMBER, and p_batch_size of type NUMBER. The procedure begins by initializing a local variable v_counter to zero, which will be used to count the number of insert operations performed. It then calculates the total number of mountains located in the specified country by executing a SELECT COUNT(*) query on the MOUNTAIN table where the COUNTRY column matches the p_country_name parameter, storing the result in the v_total_mountains variable. Similarly, it calculates the total number of camera lenses with focal lengths between p_focal_min and p_focal_max by executing a SELECT COUNT(*) query on the CAMERA_LENS table, storing the result in the v_total_lenses variable. The procedure retrieves the maximum ID value from the PHOTOS table using a SELECT NVL(MAX(ID), 0) query, storing the result in the v_max_id variable. The procedure then enters a nested loop structure, first iterating over camera lenses with focal lengths between p_focal_min and p_focal_max, ordered by ID, using a cursor named lens_rec. For each lens, it enters a second loop to iterate over mountains in the specified country whose ID modulo 3 matches the lens ID modulo 3, using a cursor named mountain_rec. Within the inner loop, the procedure increments v_counter by one and inserts a new row into the PHOTOS table with the following values: a unique ID calculated as v_max_id plus v_counter, the current lens ID, the current mountain ID, a COLOR value determined by the lens's focal length (WIDE for less than 30, TELE for greater than 100, NORMAL otherwise), and a NAME value concatenating the lens brand and mountain name. If v_counter reaches or exceeds p_batch_size, the procedure exits immediately using a RETURN statement. If the procedure completes the loops without reaching the batch size, it enters another loop to insert additional rows into the PHOTOS table until the batch size is met. In this loop, it inserts rows with a unique ID calculated as v_max_id plus v_counter plus the loop index, the minimum ID from the CAMERA_LENS table, the minimum ID from the MOUNTAIN table for the specified country, a COLOR value of 'DEFAULT', and a NAME value formatted as 'fallback_' followed by the current timestamp and loop index."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ManageChampionships that accepts a single input parameter p_year of type NUMBER, which represents a specific year. The procedure begins by declaring a local variable v_count of type NUMBER to store count results and a local variable v_institution_id of type NUMBER to hold institution identifiers. It then declares and opens a cursor named c_institutions, which selects the INSTITUTION_ID column from the INSTITUTION table for every row where the FOUNDED column exactly equals the provided p_year parameter. The procedure enters a loop to process each row from this cursor result set: it fetches a single INSTITUTION_ID value into the v_institution_id variable, and exits the loop when no more rows are found. For each fetched institution ID, it performs a SELECT COUNT(*) query on the CHAMPIONSHIP table into the v_count variable, counting all rows where the INSTITUTION_ID column matches the current v_institution_id. It then evaluates a conditional IF statement: if v_count is greater than zero, meaning at least one championship record exists for that institution, it executes a DELETE operation on the CHAMPIONSHIP table, removing all rows where INSTITUTION_ID equals v_institution_id. If v_count is zero, meaning no championship records exist, it executes an INSERT operation into the CHAMPIONSHIP table, specifying values for four columns: it sets INSTITUTION_ID to the current v_institution_id, sets NICKNAME to the literal string 'NewTeam', sets JOINED to the input parameter p_year, and sets NUMBER_OF_CHAMPIONSHIPS to the literal number 1. After the loop completes, the procedure closes the c_institutions cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageChampionships(p_year NUMBER) IS\n  v_count NUMBER;\n  v_institution_id NUMBER;\n  CURSOR c_institutions IS\n    SELECT INSTITUTION_ID FROM INSTITUTION WHERE FOUNDED = p_year;\nBEGIN\n  OPEN c_institutions;\n  LOOP\n    FETCH c_institutions INTO v_institution_id;\n    EXIT WHEN c_institutions%NOTFOUND;\n    \n    SELECT COUNT(*) INTO v_count FROM CHAMPIONSHIP WHERE INSTITUTION_ID = v_institution_id;\n    \n    IF v_count > 0 THEN\n      DELETE FROM CHAMPIONSHIP WHERE INSTITUTION_ID = v_institution_id;\n    ELSE\n      INSERT INTO CHAMPIONSHIP (INSTITUTION_ID, NICKNAME, JOINED, NUMBER_OF_CHAMPIONSHIPS)\n      VALUES (v_institution_id, 'NewTeam', p_year, 1);\n    END IF;\n  END LOOP;\n  CLOSE c_institutions;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "BEGIN\n  ManageChampionships(1908);\n  commit;\nEND;",
      "BEGIN\n  ManageChampionships(1966);\n  commit;\nEND;",
      "BEGIN\n  ManageChampionships(1993);\n  commit;\nEND;",
      "BEGIN\n  ManageChampionships(1994);\n  commit;\nEND;",
      "BEGIN\n  ManageChampionships(1995);\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named ManageChampionships that processes institutions founded in a given year. For each institution founded in that year, check if it has any championship records. If it does, delete all its championship records. If it does not, insert a new championship record for it with a nickname of 'NewTeam', the given year as the joined date, and 1 championship.",
    "natural_language": "Compose a stored procedure designated as ManageChampionships to process institutions established within a specified year. For every institution founded in that particular year, verify the existence of associated championship records. Should such records exist, proceed to delete all championship entries for that institution. Conversely, if no championship records are present, insert a new championship record for the institution, assigning 'NewTeam' as the nickname, the provided year as the joined date, and a championship count of one.",
    "id": 85,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named ManageChampionships that accepts a single input parameter p_year of type NUMBER, which represents a specific year. The procedure begins by declaring a local variable v_count of type NUMBER to store count results and a local variable v_institution_id of type NUMBER to hold institution identifiers. It then declares and opens a cursor named c_institutions, which selects the INSTITUTION_ID column from the INSTITUTION table for every row where the FOUNDED column exactly equals the provided p_year parameter. The procedure enters a loop to process each row from this cursor result set: it fetches a single INSTITUTION_ID value into the v_institution_id variable, and exits the loop when no more rows are found. For each fetched institution ID, it performs a SELECT COUNT(*) query on the CHAMPIONSHIP table into the v_count variable, counting all rows where the INSTITUTION_ID column matches the current v_institution_id. It then evaluates a conditional IF statement: if v_count is greater than zero, meaning at least one championship record exists for that institution, it executes a DELETE operation on the CHAMPIONSHIP table, removing all rows where INSTITUTION_ID equals v_institution_id. If v_count is zero, meaning no championship records exist, it executes an INSERT operation into the CHAMPIONSHIP table, specifying values for four columns: it sets INSTITUTION_ID to the current v_institution_id, sets NICKNAME to the literal string 'NewTeam', sets JOINED to the input parameter p_year, and sets NUMBER_OF_CHAMPIONSHIPS to the literal number 1. After the loop completes, the procedure closes the c_institutions cursor."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteUniversityByEnrollment that accepts four input parameters: a numeric parameter p_min_enrollment representing the lower bound of an enrollment range, a numeric parameter p_max_enrollment representing the upper bound of an enrollment range, a string parameter p_city representing a city name, and a string parameter p_state representing a state name, and executes a DELETE operation on the UNIVERSITY table, removing all rows where the ENROLLMENT column value falls inclusively between the p_min_enrollment and p_max_enrollment parameters, and simultaneously the CITY column value exactly matches the p_city parameter, and simultaneously the STATE column value exactly matches the p_state parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteUniversityByEnrollment(\n    p_min_enrollment IN NUMBER,\n    p_max_enrollment IN NUMBER,\n    p_city IN VARCHAR2,\n    p_state IN VARCHAR2\n) AS\nBEGIN\n    DELETE FROM UNIVERSITY\n    WHERE ENROLLMENT BETWEEN p_min_enrollment AND p_max_enrollment\n    AND CITY = p_city\n    AND STATE = p_state;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteUniversityByEnrollment(1000, 3000, 'Rock Island', 'Illinois');\n  commit;\nEND;",
      "BEGIN\n  DeleteUniversityByEnrollment(2000, 5000, 'Aurora', 'Illinois');\n  commit;\nEND;",
      "BEGIN\n  DeleteUniversityByEnrollment(500, 1500, 'Beloit', 'Wisconsin');\n  commit;\nEND;",
      "BEGIN\n  DeleteUniversityByEnrollment(2500, 4500, 'Aurora', 'Wisconsin');\n  commit;\nEND;",
      "BEGIN\n  DeleteUniversityByEnrollment(1000, 2000, 'Rock Island', 'Wisconsin');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteUniversityByEnrollment that accepts minimum enrollment, maximum enrollment, city, and state parameters. Delete all universities where the enrollment is within the specified range and the city and state match the provided values.",
    "natural_language": "Develop a stored procedure called DeleteUniversityByEnrollment that is designed to accept four input parameters: a minimum enrollment figure, a maximum enrollment figure, a city name, and a state abbreviation. This procedure should thoroughly identify and permanently remove all university records for which the student enrollment count falls inclusively between the provided minimum and maximum values, and where both the city and the state precisely correspond to the given parameter values.",
    "id": 86,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DeleteUniversityByEnrollment that is designed to delete university records from the university_rank database based on enrollment range and location criteria. The procedure accepts four input parameters: p_min_enrollment of type NUMBER, which specifies the lower bound of the enrollment range; p_max_enrollment of type NUMBER, which specifies the upper bound of the enrollment range; p_city of type VARCHAR2, which specifies the exact city name for filtering; and p_state of type VARCHAR2, which specifies the exact state abbreviation for filtering. The procedure does not declare any local variables. Upon execution, it performs a DELETE operation on the UNIVERSITY table. The deletion targets all rows where the ENROLLMENT column value is greater than or equal to the p_min_enrollment parameter and less than or equal to the p_max_enrollment parameter, inclusively. Additionally, the CITY column value must exactly match the p_city parameter, and the STATE column value must exactly match the p_state parameter. The procedure does not involve any SELECT, INSERT, or UPDATE operations, nor does it include any explicit function calls, complex calculations, or control flow logic beyond this conditional deletion. The procedure does not return any value; it solely performs the deletion based on the specified criteria."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp3` that accepts three input parameters: `para_book_id` of data type `NUMBER`, `para_title` of data type `VARCHAR2`, and `para_readers` of data type `NUMBER`. The procedure implements a conditional logic based on the value of the `para_readers` parameter. Specifically, if the value of `para_readers` is strictly greater than 3, the procedure executes an `INSERT` operation. This `INSERT` operation adds a new row into the `REVIEW` table. The values for the columns in the new row are determined as follows: for the `REVIEW_ID` column, it calculates the maximum existing `REVIEW_ID` in the `REVIEW` table using a subquery `(SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW)`. The `NVL` function ensures that if `MAX(REVIEW_ID)` returns `NULL` (meaning the table is empty), it defaults to 0 before adding 1, effectively generating a sequential ID. For the `BOOK_ID` column, it uses the value provided by the `para_book_id` input parameter. For the `RATING` column, it inserts a fixed literal value of `7.0`. For the `READERS_IN_MILLION` column, it uses the value provided by the `para_readers` input parameter. For the `RANK` column, it inserts a fixed literal value of `15`. Conversely, if the value of `para_readers` is not strictly greater than 3 (i.e., it is less than or equal to 3), the procedure executes a `DELETE` operation. This `DELETE` operation removes rows from the `REVIEW` table where two conditions are met simultaneously: the value in the `BOOK_ID` column matches the value provided by the `para_book_id` input parameter, AND the value in the `READERS_IN_MILLION` column is strictly less than the value provided by the `para_readers` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp3(para_book_id NUMBER, para_title VARCHAR2, para_readers NUMBER) IS\nBEGIN\n  IF para_readers > 3 THEN\n    INSERT INTO REVIEW (REVIEW_ID, BOOK_ID, RATING, READERS_IN_MILLION, RANK) VALUES (\n      (SELECT NVL(MAX(REVIEW_ID), 0) + 1 FROM REVIEW),\n      para_book_id,\n      7.0,\n      para_readers,\n      15\n    );\n  ELSE\n    DELETE FROM REVIEW WHERE BOOK_ID = para_book_id AND READERS_IN_MILLION < para_readers;\n  END IF;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "BEGIN\n  sp3(1, 'A Game of Thrones', 5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp3(2, 'A Clash of Kings', 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp3(3, 'A Storm of Swords', 4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp3(4, 'A Feast for Crows', 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp3(5, 'A Dance with Dragons', 6);\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp3 with parameters para_book_id (NUMBER), para_title (VARCHAR2), and para_readers (NUMBER). If para_readers > 3, insert a new row into the REVIEW table. Generate a new REVIEW_ID as the maximum existing ID plus one (defaulting to 1 if the table is empty). Set BOOK_ID to para_book_id, RATING to 7.0, READERS_IN_MILLION to para_readers, and RANK to 15. Otherwise (if para_readers <= 3), delete rows from REVIEW where BOOK_ID equals para_book_id and READERS_IN_MILLION is less than para_readers.",
    "natural_language": "Create a stored procedure called sp3 that takes a book ID, a title, and a reader count. If the reader count seems pretty high, like more than a few, then add a new review entry. For the new review's ID, just take whatever the biggest current ID is and add one to it, or start at 1 if there aren't any yet. Use the provided book ID, set the rating to a decent score, set the readers to the given number, and assign a middling rank. On the other hand, if the reader count is on the lower side, say about three or fewer, then go ahead and remove any existing reviews for that book where the reader count is even lower than the number provided.",
    "id": 87,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp3 that accepts three input parameters: p_book_id of type NUMBER, p_title of type VARCHAR2, and p_reader_count of type NUMBER. The procedure operates on the book_review database and involves conditional logic based on the value of p_reader_count.\n\nFirst, the procedure declares a local variable v_max_review_id of type NUMBER to store the maximum existing REVIEW_ID from the REVIEW table.\n\nThe procedure begins by checking if p_reader_count is greater than 3. If this condition is true, it performs an insertion into the REVIEW table. To generate a new REVIEW_ID, it executes a SELECT statement to retrieve the maximum REVIEW_ID from the REVIEW table, using the NVL function to handle cases where the table is empty by returning 0. It then adds 1 to this value and stores it in v_max_review_id. Next, it inserts a new record into the REVIEW table with the following column values: REVIEW_ID set to v_max_review_id, BOOK_ID set to p_book_id, RATING set to 5.5, READERS_IN_MILLION set to p_reader_count, and RANK set to 15.\n\nIf the condition p_reader_count > 3 is false, the procedure then checks if p_reader_count is less than or equal to 3. If this second condition is true, it performs a deletion from the REVIEW table. Specifically, it deletes all rows from the REVIEW table where the BOOK_ID matches p_book_id and the READERS_IN_MILLION column is less than p_reader_count.\n\nThe procedure does not return any value; it executes the insertion or deletion based on the conditional logic."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_catalog that accepts three input parameters: a numeric parameter p_catalog_level, a numeric parameter p_price_threshold, and a string parameter p_new_name. The procedure begins by declaring a cursor named cur_catalog that selects the CATALOG_ENTRY_ID and PRICE_IN_DOLLARS columns from the CATALOG_CONTENTS table for all rows where the CATALOG_LEVEL_NUMBER column equals the input p_catalog_level, with the FOR UPDATE clause to lock the selected rows. It also declares local numeric variables v_entry_id, v_price, and v_attr_exists. The procedure opens the cursor and enters a loop, fetching each row's CATALOG_ENTRY_ID into v_entry_id and PRICE_IN_DOLLARS into v_price. The loop exits when no more rows are found. For each fetched row, if the v_price is greater than the input p_price_threshold, it updates the current row in the CATALOG_CONTENTS table, setting the CATALOG_ENTRY_NAME column to the input p_new_name using the WHERE CURRENT OF clause. It then queries the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table, counting the number of rows where the CATALOG_ENTRY_ID equals the current v_entry_id and stores the result in v_attr_exists. If v_attr_exists is greater than zero, it updates the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table, setting the ATTRIBUTE_VALUE column to '1' for the row where CATALOG_ENTRY_ID equals v_entry_id. If v_attr_exists is zero, it inserts a new row into CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES with columns CATALOG_ENTRY_ID set to v_entry_id, CATALOG_LEVEL_NUMBER set to p_catalog_level, ATTRIBUTE_ID set to 1, and ATTRIBUTE_VALUE set to '0'. If the v_price is less than the input p_price_threshold, it deletes from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table any row where the CATALOG_ENTRY_ID equals the current v_entry_id. If the v_price is neither greater than nor less than p_price_threshold (i.e., it is equal), it updates the current row in the CATALOG_CONTENTS table, setting the PRICE_IN_EUROS column to its current value multiplied by 1.1 using the WHERE CURRENT OF clause. After processing all rows, the procedure closes the cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_catalog(p_catalog_level NUMBER, p_price_threshold NUMBER, p_new_name VARCHAR2) IS\n  CURSOR cur_catalog IS SELECT CATALOG_ENTRY_ID, PRICE_IN_DOLLARS FROM CATALOG_CONTENTS WHERE CATALOG_LEVEL_NUMBER = p_catalog_level FOR UPDATE;\n  v_entry_id NUMBER;\n  v_price NUMBER;\n  v_attr_exists NUMBER;\nBEGIN\n  OPEN cur_catalog;\n  LOOP\n    FETCH cur_catalog INTO v_entry_id, v_price;\n    EXIT WHEN cur_catalog%NOTFOUND;\n    IF v_price > p_price_threshold THEN\n      UPDATE CATALOG_CONTENTS SET CATALOG_ENTRY_NAME = p_new_name WHERE CURRENT OF cur_catalog;\n      SELECT COUNT(*) INTO v_attr_exists FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = v_entry_id;\n      IF v_attr_exists > 0 THEN\n        UPDATE CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES SET ATTRIBUTE_VALUE = '1' WHERE CATALOG_ENTRY_ID = v_entry_id;\n      ELSE\n        INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE) VALUES (v_entry_id, p_catalog_level, 1, '0');\n      END IF;\n    ELSIF v_price < p_price_threshold THEN\n      DELETE FROM CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES WHERE CATALOG_ENTRY_ID = v_entry_id;\n    ELSE\n      UPDATE CATALOG_CONTENTS SET PRICE_IN_EUROS = PRICE_IN_EUROS * 1.1 WHERE CURRENT OF cur_catalog;\n    END IF;\n  END LOOP;\n  CLOSE cur_catalog;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_catalog(1, 100, 'Premium Item');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_catalog(8, 500, 'High Value Product');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_catalog(1, 50, 'Updated Name');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_catalog(5, 1000, 'Luxury Edition');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_catalog(2, 250, 'Mid-Range Product');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named sp_update_catalog that uses a cursor to process catalog entries at a specified level. For each entry: if its price exceeds a threshold, update its name and set a related attribute to '1' (inserting a default row if needed); if the price is below the threshold, delete related attributes; if equal, increase its euro price by 10%. Use row locking during processing.",
    "natural_language": "Create a stored procedure called sp_update_catalog. Use a cursor to go through catalog entries at a given level. For each entry, lock the row. If the price is above a threshold, update the entry's name and set a related attribute to '1', inserting a default row first if it doesn't exist. If the price is below the threshold, delete any related attributes. If the price equals the threshold, increase its euro price by 10 percent.",
    "id": 88,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_catalog in the product_catalog database. The procedure uses a cursor to iterate through catalog entries at a specified level. It accepts two input parameters: p_catalog_level_number of type NUMBER to specify the catalog level to process, and p_price_threshold of type NUMBER to define the price threshold for comparisons.\n\nThe procedure declares a cursor named cur_catalog that selects the CATALOG_ENTRY_ID, CATALOG_ENTRY_NAME, PRICE_IN_DOLLARS, and PRICE_IN_EUROS columns from the CATALOG_CONTENTS table where the CATALOG_LEVEL_NUMBER matches the input parameter p_catalog_level_number. For each row fetched by the cursor, the procedure performs a SELECT FOR UPDATE statement to lock the row in the CATALOG_CONTENTS table based on the current CATALOG_ENTRY_ID, ensuring no other session can modify it concurrently.\n\nWithin the loop, the procedure evaluates the PRICE_IN_DOLLARS value against the p_price_threshold. If PRICE_IN_DOLLARS is greater than p_price_threshold, it first checks if a corresponding row exists in the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table for the current CATALOG_ENTRY_ID and the same CATALOG_LEVEL_NUMBER. If no such row exists, it inserts a default row into CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES with the current CATALOG_ENTRY_ID, the CATALOG_LEVEL_NUMBER from the cursor row, an ATTRIBUTE_ID set to 1, and an ATTRIBUTE_VALUE set to '0'. After ensuring the row exists, it updates the CATALOG_CONTENTS table by appending the string '_updated' to the CATALOG_ENTRY_NAME for the current CATALOG_ENTRY_ID. It also updates the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table, setting the ATTRIBUTE_VALUE to '1' for the row where CATALOG_ENTRY_ID matches the current entry and ATTRIBUTE_ID is 1.\n\nIf PRICE_IN_DOLLARS is less than p_price_threshold, the procedure deletes all rows from the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table where the CATALOG_ENTRY_ID matches the current entry.\n\nIf PRICE_IN_DOLLARS is equal to p_price_threshold, the procedure updates the CATALOG_CONTENTS table by increasing the PRICE_IN_EUROS value by 10 percent for the current CATALOG_ENTRY_ID. This is calculated as PRICE_IN_EUROS multiplied by 1.10.\n\nThe procedure includes exception handling to manage any errors during execution, such as locking conflicts or data integrity issues, and performs a commit after processing all rows to save the changes."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateBoxValue that accepts three parameters: p_box_code of type VARCHAR2, p_new_value of type NUMBER, and p_old_value of type OUT NUMBER, along with a fourth parameter p_updated of type OUT VARCHAR2. The procedure begins by selecting the VALUE column from the BOXES table where the CODE column matches the input parameter p_box_code, and assigns this selected VALUE to the output parameter p_old_value. It then updates the VALUE column in the BOXES table to the value provided in the p_new_value parameter for the row where the CODE column equals p_box_code. After successfully updating, it sets the output parameter p_updated to 'YES'. If no row is found with the specified CODE, the NO_DATA_FOUND exception is triggered, and the procedure sets the p_updated parameter to 'NO'.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateBoxValue(\n    p_box_code IN VARCHAR2,\n    p_new_value IN NUMBER,\n    p_old_value OUT NUMBER,\n    p_updated OUT VARCHAR2\n) AS\nBEGIN\n    SELECT VALUE INTO p_old_value FROM BOXES WHERE CODE = p_box_code;\n    UPDATE BOXES SET VALUE = p_new_value WHERE CODE = p_box_code;\n    p_updated := 'YES';\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        p_updated := 'NO';\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('0MN7', 200, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('4H8P', 300, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('4RT3', 220, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('0MN7', 250, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_old_value NUMBER;\n  v_updated VARCHAR2(3);\nBEGIN\n  UpdateBoxValue('4H8P', 180, v_old_value, v_updated);\n  DBMS_OUTPUT.PUT_LINE('Old Value: ' || v_old_value || ', Updated: ' || v_updated);\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateBoxValue that retrieves the current VALUE from the BOXES table for a given CODE, updates it to a new value, and returns the old value and a 'YES'/'NO' success flag via OUT parameters.",
    "natural_language": "Please construct a stored procedure designated as 'UpdateBoxValue'. This procedure shall retrieve the existing VALUE entry from the BOXES table corresponding to a specified CODE. It must subsequently update this entry to a new provided value. The procedure is required to output the previous value along with a success indicator of 'YES' or 'NO' through designated OUT parameters.",
    "id": 89,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateBoxValue that accepts three parameters: p_box_code of type VARCHAR2, p_new_value of type NUMBER, and p_old_value of type OUT NUMBER, along with a fourth parameter p_updated of type OUT VARCHAR2. The procedure begins by selecting the VALUE column from the BOXES table where the CODE column matches the input parameter p_box_code, and assigns this selected VALUE to the output parameter p_old_value. It then updates the VALUE column in the BOXES table to the value provided in the p_new_value parameter for the row where the CODE column equals p_box_code. After successfully updating, it sets the output parameter p_updated to 'YES'. If no row is found with the specified CODE, the NO_DATA_FOUND exception is triggered, and the procedure sets the p_updated parameter to 'NO'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_cleanup_orders that accepts three parameters: p_customer_id of type NUMBER, p_status_code of type VARCHAR2, and p_date_threshold of type VARCHAR2. The procedure begins by declaring two local variables, v_item_count and v_order_count, both of type NUMBER. It performs a SELECT operation to count the number of rows in the CUSTOMER_ORDERS table where the CUSTOMER_ID matches p_customer_id, the ORDER_STATUS_CODE matches p_status_code, and the ORDER_DATE is earlier than p_date_threshold, storing the result in v_order_count. If v_order_count is greater than zero, indicating that there are orders meeting the criteria, the procedure proceeds to count the number of rows in the ORDER_ITEMS table where the ORDER_ID corresponds to any order in the CUSTOMER_ORDERS table that matches the same conditions, storing this count in v_item_count. If v_item_count is greater than zero, the procedure deletes rows from the ORDER_ITEMS table where the ORDER_ID matches any order in the CUSTOMER_ORDERS table that meets the specified conditions. Following this, the procedure deletes rows from the CUSTOMER_ORDERS table where the CUSTOMER_ID matches p_customer_id, the ORDER_STATUS_CODE matches p_status_code, and the ORDER_DATE is earlier than p_date_threshold.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_cleanup_orders(p_customer_id IN NUMBER, p_status_code IN VARCHAR2, p_date_threshold IN VARCHAR2)\nIS\n   v_item_count NUMBER;\n   v_order_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_order_count FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_status_code AND ORDER_DATE < p_date_threshold;\n   \n   IF v_order_count > 0 THEN\n      SELECT COUNT(*) INTO v_item_count FROM ORDER_ITEMS oi WHERE EXISTS (SELECT 1 FROM CUSTOMER_ORDERS co WHERE co.ORDER_ID = oi.ORDER_ID AND co.CUSTOMER_ID = p_customer_id AND co.ORDER_STATUS_CODE = p_status_code AND co.ORDER_DATE < p_date_threshold);\n      \n      IF v_item_count > 0 THEN\n         DELETE FROM ORDER_ITEMS WHERE ORDER_ID IN (SELECT ORDER_ID FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_status_code AND ORDER_DATE < p_date_threshold);\n      END IF;\n      \n      DELETE FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_status_code AND ORDER_DATE < p_date_threshold;\n   END IF;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_cleanup_orders(12, 'Part', '2015-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  proc_cleanup_orders(3, 'Part', '1995-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  proc_cleanup_orders(12, 'Complete', '2020-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  proc_cleanup_orders(25, 'Cancelled', '2022-06-01');\n  COMMIT;\nEND;",
      "BEGIN\n  proc_cleanup_orders(100, 'Pending', '2000-12-31');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named proc_cleanup_orders that accepts a customer_id number, a status_code string, and a date_threshold string. Count orders for the customer with the given status older than the threshold. If such orders exist, count their related items. If items exist, delete them. Then, delete the qualifying orders.",
    "natural_language": "Develop a stored procedure, to be named proc_cleanup_orders, which is designed to accept three distinct parameters: a numeric customer identifier, a textual status code, and a specific date threshold provided as a string. This procedure should meticulously calculate the total number of orders associated with the specified customer that possess the indicated status and were placed prior to the provided cutoff date. Should any such qualifying orders be found, it must then proceed to carefully tally all inventory items that are linked to those particular orders. In the event that related items are indeed present, the procedure must systematically and securely remove each of those item records. Subsequently, after ensuring the related items are handled, it must finally and completely delete all of the identified qualifying orders from the database.",
    "id": 90,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `proc_cleanup_orders` that accepts three input parameters: `p_customer_id` of type `NUMBER`, `p_status_code` of type `VARCHAR2`, and `p_cutoff_date` of type `VARCHAR2`. This procedure is designed to identify and delete orders for a specific customer that have a given status and were placed before a specified date, after first deleting any related order items.\n\nFirst, the procedure declares two local variables: `v_order_count` of type `NUMBER` to store the number of qualifying orders, and `v_item_count` of type `NUMBER` to store the number of related order items.\n\nThe procedure begins by executing a `SELECT` statement with a `COUNT(*)` aggregation. It queries the `CUSTOMER_ORDERS` table to count all rows where the `CUSTOMER_ID` column matches the input parameter `p_customer_id`, the `ORDER_STATUS_CODE` column matches the input parameter `p_status_code`, and the `ORDER_DATE` column is less than the input parameter `p_cutoff_date`. The result of this count is stored in the `v_order_count` variable.\n\nNext, the procedure uses an `IF` statement to check if the value of `v_order_count` is greater than zero. If this condition is true, the procedure proceeds to the next step.\n\nInside the `IF` block, the procedure executes another `SELECT` statement with a `COUNT(*)` aggregation. It queries the `ORDER_ITEMS` table to count all rows where the `ORDER_ID` column matches any `ORDER_ID` from the `CUSTOMER_ORDERS` table that satisfies the same criteria used in the first query: `CUSTOMER_ID` equals `p_customer_id`, `ORDER_STATUS_CODE` equals `p_status_code`, and `ORDER_DATE` is less than `p_cutoff_date`. This is achieved using a subquery in the `WHERE` clause: `WHERE ORDER_ID IN (SELECT ORDER_ID FROM CUSTOMER_ORDERS WHERE CUSTOMER_ID = p_customer_id AND ORDER_STATUS_CODE = p_status_code AND ORDER_DATE < p_cutoff_date)`. The result of this count is stored in the `v_item_count` variable.\n\nThe procedure then uses a nested `IF` statement to check if the value of `v_item_count` is greater than zero. If this condition is true, the procedure executes a `DELETE` operation. This `DELETE` statement removes rows from the `ORDER_ITEMS` table where the `ORDER_ID` column matches any `ORDER_ID` from the `CUSTOMER_ORDERS` table that satisfies the same customer, status, and date criteria. The `WHERE` clause for this `DELETE` is identical to the subquery used in the second `SELECT` statement.\n\nFollowing the nested `IF` block (whether items were deleted or not), the procedure executes another `DELETE` operation. This `DELETE` statement removes rows from the `CUSTOMER_ORDERS` table where the `CUSTOMER_ID` column matches `p_customer_id`, the `ORDER_STATUS_CODE` column matches `p_status_code`, and the `ORDER_DATE` column is less than `p_cutoff_date`.\n\nIf the initial `IF` condition is false (meaning `v_order_count` is zero), the procedure takes no further action and completes without performing any deletions.\n\nThe procedure does not have a return value; it performs its operations and then ends."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_teacher_info` that accepts three input parameters: `p_teacher_id` of type `NUMBER`, `p_new_name` of type `VARCHAR2`, and `p_new_hometown` of type `VARCHAR2`. The purpose of this procedure is to update information for a specific teacher identified by `p_teacher_id` in the `TEACHER` table.\n\nThe procedure begins by declaring two local variables: `v_current_age` of type `VARCHAR2(255)` and `v_formatted_name` of type `VARCHAR2(255)`.\n\nFirst, it executes a `SELECT` statement to retrieve the `AGE` column value from the `TEACHER` table for the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`. The retrieved `AGE` value is then stored into the local variable `v_current_age`.\n\nNext, it processes the `p_new_name` input parameter to create a formatted name. It constructs `v_formatted_name` by taking the first character of `p_new_name` using `SUBSTR(p_new_name, 1, 1)`, converting it to uppercase using the `UPPER()` function, and concatenating it with the rest of `p_new_name` starting from the second character using `SUBSTR(p_new_name, 2)`, which is converted to lowercase using the `LOWER()` function. This effectively capitalizes the first letter of the new name and makes the rest lowercase.\n\nSubsequently, an `UPDATE` statement is executed on the `TEACHER` table. This statement sets the `NAME` column to the value stored in `v_formatted_name` and the `HOMETOWN` column to the value of the input parameter `p_new_hometown`. This update is applied only to the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`.\n\nFollowing this, a conditional block is introduced using an `IF` statement. The condition checks if the value stored in `v_current_age`, after being explicitly cast to a `NUMBER` using `CAST(v_current_age AS NUMBER)`, is less than `65`.\n\nIf this condition evaluates to `TRUE`, another `UPDATE` statement is executed on the `TEACHER` table. This update sets the `AGE` column to a new value. The new `AGE` value is calculated by first casting `v_current_age` to a `NUMBER` using `CAST(v_current_age AS NUMBER)`, adding `1` to it, and then converting the result back to a `VARCHAR2` using the `TO_CHAR()` function. This update is also applied only to the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`.\n\nThe procedure then concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_teacher_info(\n    p_teacher_id IN NUMBER,\n    p_new_name IN VARCHAR2,\n    p_new_hometown IN VARCHAR2\n) IS\n    v_current_age VARCHAR2(255);\n    v_formatted_name VARCHAR2(255);\nBEGIN\n    SELECT AGE INTO v_current_age FROM TEACHER WHERE TEACHER_ID = p_teacher_id;\n    v_formatted_name := UPPER(SUBSTR(p_new_name, 1, 1)) || LOWER(SUBSTR(p_new_name, 2));\n    \n    UPDATE TEACHER \n    SET NAME = v_formatted_name, HOMETOWN = p_new_hometown\n    WHERE TEACHER_ID = p_teacher_id;\n    \n    IF CAST(v_current_age AS NUMBER) < 65 THEN\n        UPDATE TEACHER \n        SET AGE = TO_CHAR(CAST(v_current_age AS NUMBER) + 1)\n        WHERE TEACHER_ID = p_teacher_id;\n    END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  update_teacher_info(1, 'Joseph Huts', 'Blackrod Urban District');\n  COMMIT;\nEND;",
      "BEGIN\n  update_teacher_info(2, 'Gustaaf Deloor', 'Manchester');\n  COMMIT;\nEND;",
      "BEGIN\n  update_teacher_info(3, 'Vicente Carretero', 'Farnworth Municipal Borough');\n  COMMIT;\nEND;",
      "BEGIN\n  update_teacher_info(1, 'John Smith', 'London');\n  COMMIT;\nEND;",
      "BEGIN\n  update_teacher_info(2, 'Alice Johnson', 'Bolton County Borough');\n  COMMIT;\nEND;"
    ],
    "summary": "Create a stored procedure named update_teacher_info that accepts a teacher ID, a new name, and a new hometown. It retrieves the teacher's current age. It formats the new name to have the first letter uppercase and the rest lowercase. It updates the teacher's NAME and HOMETOWN. If the current age (cast to a number) is less than 65, it increments the age by one and updates the AGE column.",
    "natural_language": "Create procedure update_teacher_info to update a teacher's name and hometown using their ID. Format the new name properly. Get the teacher's current age. If under 65, increase age by one and update it.",
    "id": 91,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `update_teacher_info` that accepts three input parameters: `p_teacher_id` of type `NUMBER`, `p_new_name` of type `VARCHAR2`, and `p_new_hometown` of type `VARCHAR2`. The purpose of this procedure is to update information for a specific teacher identified by `p_teacher_id` in the `TEACHER` table.\n\nThe procedure begins by declaring two local variables: `v_current_age` of type `VARCHAR2(255)` and `v_formatted_name` of type `VARCHAR2(255)`.\n\nFirst, it executes a `SELECT` statement to retrieve the `AGE` column value from the `TEACHER` table for the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`. The retrieved `AGE` value is then stored into the local variable `v_current_age`.\n\nNext, it processes the `p_new_name` input parameter to create a formatted name. It constructs `v_formatted_name` by taking the first character of `p_new_name` using `SUBSTR(p_new_name, 1, 1)`, converting it to uppercase using the `UPPER()` function, and concatenating it with the rest of `p_new_name` starting from the second character using `SUBSTR(p_new_name, 2)`, which is converted to lowercase using the `LOWER()` function. This effectively capitalizes the first letter of the new name and makes the rest lowercase.\n\nSubsequently, an `UPDATE` statement is executed on the `TEACHER` table. This statement sets the `NAME` column to the value stored in `v_formatted_name` and the `HOMETOWN` column to the value of the input parameter `p_new_hometown`. This update is applied only to the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`.\n\nFollowing this, a conditional block is introduced using an `IF` statement. The condition checks if the value stored in `v_current_age`, after being explicitly cast to a `NUMBER` using `CAST(v_current_age AS NUMBER)`, is less than `65`.\n\nIf this condition evaluates to `TRUE`, another `UPDATE` statement is executed on the `TEACHER` table. This update sets the `AGE` column to a new value. The new `AGE` value is calculated by first casting `v_current_age` to a `NUMBER` using `CAST(v_current_age AS NUMBER)`, adding `1` to it, and then converting the result back to a `VARCHAR2` using the `TO_CHAR()` function. This update is also applied only to the row where the `TEACHER_ID` column matches the input parameter `p_teacher_id`.\n\nThe procedure then concludes."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named consolidate_customer_records that accepts three parameters: an input number parameter p_old_id, an input number parameter p_new_id, and an output number parameter p_result. The procedure first checks if p_old_id and p_new_id are equal and, if they are, sets p_result to -1 and stops execution. If the IDs are different, it then checks for the existence of p_new_id in the CMI_CROSS_REFERENCES table by selecting the value 1 into a local variable v_dummy from the row where the CMI_CROSS_REF_ID column equals p_new_id; if no row is found, it sets p_result to -2 and stops, and if more than one row is found, it sets p_result to -4 and stops. Next, it performs an identical existence check for p_old_id in the CMI_CROSS_REFERENCES table, setting p_result to -3 if the old ID is not found, or to -4 if multiple rows for the old ID are found, and stopping execution in either case. If both IDs exist uniquely, the procedure proceeds to update the BENEFITS_OVERPAYMENTS table, changing the CMI_CROSS_REF_ID column value from p_old_id to p_new_id for all rows where CMI_CROSS_REF_ID equals p_old_id, and stores the number of rows updated from this operation into p_result. It then updates the RENT_ARREARS table, similarly changing the CMI_CROSS_REF_ID column value from p_old_id to p_new_id for all rows where CMI_CROSS_REF_ID equals p_old_id, and adds the number of rows updated from this second operation to the existing value of p_result.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_customer_records(\n    p_old_id  IN  NUMBER,\n    p_new_id  IN  NUMBER,\n    p_result  OUT NUMBER\n) IS\n    v_dummy NUMBER;\nBEGIN\n    -- Check if old ID and new ID are the same\n    IF p_old_id = p_new_id THEN\n        p_result := -1;\n        RETURN;\n    END IF;\n\n    -- Check if the new ID exists in CMI_CROSS_REFERENCES\n    BEGIN\n        SELECT 1 INTO v_dummy FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = p_new_id;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            p_result := -2;\n            RETURN;\n        WHEN TOO_MANY_ROWS THEN\n            p_result := -4; -- Unexpected case: multiple rows for the same ID\n            RETURN;\n    END;\n\n    -- Check if the old ID exists in CMI_CROSS_REFERENCES\n    BEGIN\n        SELECT 1 INTO v_dummy FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = p_old_id;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            p_result := -3;\n            RETURN;\n        WHEN TOO_MANY_ROWS THEN\n            p_result := -4; -- Unexpected case: multiple rows for the same ID\n            RETURN;\n    END;\n\n    -- Update BENEFITS_OVERPAYMENTS\n    UPDATE BENEFITS_OVERPAYMENTS\n       SET CMI_CROSS_REF_ID = p_new_id\n     WHERE CMI_CROSS_REF_ID = p_old_id;\n    p_result := SQL%ROWCOUNT;\n\n    -- Update RENT_ARREARS\n    UPDATE RENT_ARREARS\n       SET CMI_CROSS_REF_ID = p_new_id\n     WHERE CMI_CROSS_REF_ID = p_old_id;\n    p_result := p_result + SQL%ROWCOUNT;\n\n    COMMIT;\nEXCEPTION\n    WHEN OTHERS THEN\n        ROLLBACK;\n        RAISE;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS",
      "PARKING_FINES"
    ],
    "call_sqls": [
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(2, 4, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(8, 2, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(4, 8, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(65, 41, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  consolidate_customer_records(83, 65, v_result);\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;"
    ],
    "summary": "Create a stored procedure named consolidate_customer_records that merges records from an old customer ID to a new one. It validates that both IDs exist uniquely in a reference table. If validation passes, it updates all references to the old ID in the BENEFITS_OVERPAYMENTS and RENT_ARREARS tables to the new ID and returns the total number of rows updated.",
    "natural_language": "Create procedure consolidate_customer_records to merge an old customer ID into a new one. Validate both IDs exist uniquely, then update BENEFITS_OVERPAYMENTS and RENT_ARREARS. Return total rows updated.",
    "id": 92,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named consolidate_customer_records that accepts three parameters: an input number parameter p_old_id, an input number parameter p_new_id, and an output number parameter p_result. The procedure first checks if p_old_id and p_new_id are equal and, if they are, sets p_result to -1 and stops execution. If the IDs are different, it then checks for the existence of p_new_id in the CMI_CROSS_REFERENCES table by selecting the value 1 into a local variable v_dummy from the row where the CMI_CROSS_REF_ID column equals p_new_id; if no row is found, it sets p_result to -2 and stops, and if more than one row is found, it sets p_result to -4 and stops. Next, it performs an identical existence check for p_old_id in the CMI_CROSS_REFERENCES table, setting p_result to -3 if the old ID is not found, or to -4 if multiple rows for the old ID are found, and stopping execution in either case. If both IDs exist uniquely, the procedure proceeds to update the BENEFITS_OVERPAYMENTS table, changing the CMI_CROSS_REF_ID column value from p_old_id to p_new_id for all rows where CMI_CROSS_REF_ID equals p_old_id, and stores the number of rows updated from this operation into p_result. It then updates the RENT_ARREARS table, similarly changing the CMI_CROSS_REF_ID column value from p_old_id to p_new_id for all rows where CMI_CROSS_REF_ID equals p_old_id, and adds the number of rows updated from this second operation to the existing value of p_result."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdateClaimSettlement` that is designed to modify a specific claim record within the `CLAIMS` table. This procedure accepts three parameters: `p_claim_id`, an `IN` parameter of type `NUMBER`, which represents the unique identifier of the claim to be updated; `p_new_amount_settled`, an `IN` parameter of type `NUMBER`, which specifies the new settlement amount to be assigned to the identified claim; and `p_success`, an `OUT` parameter of type `VARCHAR2`, which will communicate the outcome of the update operation.\n\nUpon execution, the procedure first performs an `UPDATE` operation on the `CLAIMS` table. This `UPDATE` statement sets the value of the `AMOUNT_SETTLED` column to the value provided by the `p_new_amount_settled` parameter. The `UPDATE` operation is conditionally applied, targeting only those rows where the value in the `CLAIM_ID` column matches the value supplied by the `p_claim_id` parameter.\n\nFollowing the `UPDATE` operation, the procedure evaluates the `SQL%ROWCOUNT` attribute. `SQL%ROWCOUNT` is a SQL pseudo-column that indicates the number of rows affected by the most recently executed SQL statement. If the value of `SQL%ROWCOUNT` is greater than `0`, meaning that at least one row in the `CLAIMS` table was successfully updated, the procedure assigns the string literal `'SUCCESS'` to the `p_success` `OUT` parameter. Conversely, if `SQL%ROWCOUNT` is not greater than `0` (i.e., it is `0`), indicating that no rows were updated (either because no claim with the specified `p_claim_id` was found or the update had no effect), the procedure assigns the string literal `'FAILURE'` to the `p_success` `OUT` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateClaimSettlement(\n  p_claim_id IN NUMBER,\n  p_new_amount_settled IN NUMBER,\n  p_success OUT VARCHAR2\n) AS\nBEGIN\n  UPDATE CLAIMS\n  SET AMOUNT_SETTLED = p_new_amount_settled\n  WHERE CLAIM_ID = p_claim_id;\n  \n  IF SQL%ROWCOUNT > 0 THEN\n    p_success := 'SUCCESS';\n  ELSE\n    p_success := 'FAILURE';\n  END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 143, p_new_amount_settled => 1500, p_success => v_success);\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;",
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 423, p_new_amount_settled => 2000, p_success => v_success);\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;",
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 442, p_new_amount_settled => 1200, p_success => v_success);\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;",
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 999, p_new_amount_settled => 500, p_success => v_success); -- Non-existent CLAIM_ID\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;",
      "DECLARE\n  v_success VARCHAR2(10);\nBEGIN\n  UpdateClaimSettlement(p_claim_id => 143, p_new_amount_settled => 1000, p_success => v_success);\n  DBMS_OUTPUT.PUT_LINE('Update Status: ' || v_success);\nEND;"
    ],
    "summary": "Create a stored procedure named UpdateClaimSettlement that updates a claim's settled amount. It takes a claim ID and a new amount as IN parameters and a success flag as an OUT parameter. Update the claim with the given ID. Set the success flag to 'SUCCESS' if a row was updated, otherwise set it to 'FAILURE'.",
    "natural_language": "Please construct a stored procedure designated as UpdateClaimSettlement. This procedure shall modify the settled amount for a specified claim. It must accept a claim identifier and a new monetary amount as input parameters, and it shall return a success indicator as an output parameter. The procedure is to update the claim record corresponding to the provided identifier. Subsequently, the success indicator should be assigned the value 'SUCCESS' if an update operation affects a database row; otherwise, it should be assigned the value 'FAILURE'.",
    "id": 93,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `UpdateClaimSettlement` that is designed to modify a specific claim record within the `CLAIMS` table. This procedure accepts three parameters: `p_claim_id`, an `IN` parameter of type `NUMBER`, which represents the unique identifier of the claim to be updated; `p_new_amount_settled`, an `IN` parameter of type `NUMBER`, which specifies the new settlement amount to be assigned to the identified claim; and `p_success`, an `OUT` parameter of type `VARCHAR2`, which will communicate the outcome of the update operation.\n\nUpon execution, the procedure first performs an `UPDATE` operation on the `CLAIMS` table. This `UPDATE` statement sets the value of the `AMOUNT_SETTLED` column to the value provided by the `p_new_amount_settled` parameter. The `UPDATE` operation is conditionally applied, targeting only those rows where the value in the `CLAIM_ID` column matches the value supplied by the `p_claim_id` parameter.\n\nFollowing the `UPDATE` operation, the procedure evaluates the `SQL%ROWCOUNT` attribute. `SQL%ROWCOUNT` is a SQL pseudo-column that indicates the number of rows affected by the most recently executed SQL statement. If the value of `SQL%ROWCOUNT` is greater than `0`, meaning that at least one row in the `CLAIMS` table was successfully updated, the procedure assigns the string literal `'SUCCESS'` to the `p_success` `OUT` parameter. Conversely, if `SQL%ROWCOUNT` is not greater than `0` (i.e., it is `0`), indicating that no rows were updated (either because no claim with the specified `p_claim_id` was found or the update had no effect), the procedure assigns the string literal `'FAILURE'` to the `p_success` `OUT` parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DELETE_OLD_ORDERS that accepts three parameters: an input parameter P_CUSTOMER_ID of type NUMBER to identify a specific customer, an input parameter P_DAYS_OLD of type NUMBER to specify an age threshold in days, and an output parameter P_DELETED_COUNT of type NUMBER to return the number of rows affected. The procedure performs a DELETE operation on the CUSTOMER_ORDERS table, targeting rows where the CUSTOMER_ID column matches the provided P_CUSTOMER_ID parameter and where the ORDER_DATE column, after being explicitly converted from a string to a DATE type using the TO_DATE function with the exact format model 'YYYY-MM-DD HH24:MI:SS', represents a date and time earlier than the current system date and time (SYSDATE) minus the number of days specified by P_DAYS_OLD. Following the deletion, the procedure assigns the number of rows deleted, obtained from the SQL%ROWCOUNT cursor attribute, to the output parameter P_DELETED_COUNT.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_orders(p_customer_id NUMBER, p_days_old NUMBER, p_deleted_count OUT NUMBER) IS\nBEGIN\n    DELETE FROM CUSTOMER_ORDERS \n    WHERE CUSTOMER_ID = p_customer_id \n    AND TO_DATE(ORDER_DATE, 'YYYY-MM-DD HH24:MI:SS') < SYSDATE - p_days_old;\n    \n    p_deleted_count := SQL%ROWCOUNT;\nEND;",
    "database_name": "customers_and_orders",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(1, 30, v_deleted_count);\n  commit;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(4, 60, v_deleted_count);\n  commit;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(5, 90, v_deleted_count);\n  commit;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(1, 120, v_deleted_count);\n  commit;\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  delete_old_orders(4, 180, v_deleted_count);\n  commit;\nEND;"
    ],
    "summary": "Create a PL/SQL procedure named DELETE_OLD_ORDERS that deletes a customer's orders older than a specified number of days and returns the count of deleted rows.",
    "natural_language": "Make a DELETE_OLD_ORDERS procedure to remove a customer's old orders and return the deletion count.",
    "id": 94,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `DELETE_OLD_ORDERS` that is designed to remove old orders for a specific customer and return the total number of deleted records. The procedure accepts one input parameter, `P_CUSTOMER_ID`, of type `NUMBER`, which identifies the customer whose old orders are to be deleted.\n\nUpon execution, the procedure declares a local variable, `V_DELETION_COUNT`, of type `NUMBER`, initialized to `0`. This variable will accumulate the total number of rows deleted from the `CUSTOMER_ORDERS` table.\n\nThe procedure first performs a `DELETE` operation on the `ORDER_ITEMS` table. It deletes all rows where the `ORDER_ID` column matches any `ORDER_ID` from a subquery. The subquery selects the `ORDER_ID` from the `CUSTOMER_ORDERS` table where the `CUSTOMER_ID` column equals the input parameter `P_CUSTOMER_ID` and the `ORDER_DATE` column is older than one year from the current system date. The age condition is determined by converting the `ORDER_DATE` string to a `DATE` using the `TO_DATE` function with the format model `'YYYY-MM-DD HH24:MI:SS'` and checking if this date is less than the current date (`SYSDATE`) minus 365 days.\n\nImmediately after this `DELETE`, the procedure uses the `SQL%ROWCOUNT` attribute to capture the number of rows deleted from the `ORDER_ITEMS` table and adds this count to the `V_DELETION_COUNT` variable.\n\nNext, the procedure performs a `DELETE` operation on the `CUSTOMER_ORDERS` table itself. It deletes all rows where the `CUSTOMER_ID` column equals the input parameter `P_CUSTOMER_ID` and the `ORDER_DATE` column, after conversion to a `DATE` using `TO_DATE` with the same format model, is older than one year from the current system date.\n\nAfter this second `DELETE`, the procedure again uses `SQL%ROWCOUNT` to capture the number of rows deleted from the `CUSTOMER_ORDERS` table and adds this count to the `V_DELETION_COUNT` variable.\n\nFinally, the procedure outputs the total deletion count by using the `DBMS_OUTPUT.PUT_LINE` procedure to print a message containing the value of `V_DELETION_COUNT`."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `DeleteArtistWorks` that accepts two parameters: an input parameter `p_artist_id` of data type `NUMBER`, which represents the unique identifier of an artist whose works are to be deleted, and an output parameter `p_deleted_count` of data type `NUMBER`, which will store the total number of records deleted by the procedure. The procedure begins by executing a `DELETE` statement on the `PAINTINGS` table. This `DELETE` operation removes all rows from the `PAINTINGS` table where the value in the `PAINTERID` column matches the value provided in the `p_artist_id` input parameter. Immediately following this deletion, the `p_deleted_count` output parameter is assigned the value of `SQL%ROWCOUNT`, which is a built-in SQL attribute that returns the number of rows affected by the most recently executed SQL statement (in this case, the `DELETE` from `PAINTINGS`). Subsequently, the procedure executes another `DELETE` statement, this time targeting the `SCULPTURES` table. This `DELETE` operation removes all rows from the `SCULPTURES` table where the value in the `SCULPTORID` column matches the value provided in the `p_artist_id` input parameter. After this second deletion, the `p_deleted_count` output parameter is updated by adding the value of `SQL%ROWCOUNT` (representing the number of rows deleted from `SCULPTURES`) to its current value, effectively accumulating the total count of deleted records from both tables.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteArtistWorks(\n    p_artist_id IN NUMBER,\n    p_deleted_count OUT NUMBER\n) AS\nBEGIN\n    DELETE FROM PAINTINGS WHERE PAINTERID = p_artist_id;\n    p_deleted_count := SQL%ROWCOUNT;\n    DELETE FROM SCULPTURES WHERE SCULPTORID = p_artist_id;\n    p_deleted_count := p_deleted_count + SQL%ROWCOUNT;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 111, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 222, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 333, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 555, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DeleteArtistWorks(p_artist_id => 999, p_deleted_count => v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted count: ' || v_deleted_count);\nEND;"
    ],
    "summary": "Create a stored procedure named DeleteArtistWorks that accepts an artist ID as input and returns the total number of deleted records. It deletes all rows from the PAINTINGS table where PAINTERID matches the input, and all rows from the SCULPTURES table where SCULPTORID matches the input, accumulating the count of deleted rows from both operations.",
    "natural_language": "What is the total number of records deleted by the stored procedure DeleteArtistWorks when it is given an artist ID, after it removes all matching entries from both the PAINTINGS and SCULPTURES tables?",
    "id": 95,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `DeleteArtistWorks` that accepts two parameters: an input parameter `p_artist_id` of data type `NUMBER`, which represents the unique identifier of an artist whose works are to be deleted, and an output parameter `p_deleted_count` of data type `NUMBER`, which will store the total number of records deleted by the procedure. The procedure begins by executing a `DELETE` statement on the `PAINTINGS` table. This `DELETE` operation removes all rows from the `PAINTINGS` table where the value in the `PAINTERID` column matches the value provided in the `p_artist_id` input parameter. Immediately following this deletion, the `p_deleted_count` output parameter is assigned the value of `SQL%ROWCOUNT`, which is a built-in SQL attribute that returns the number of rows affected by the most recently executed SQL statement (in this case, the `DELETE` from `PAINTINGS`). Subsequently, the procedure executes another `DELETE` statement, this time targeting the `SCULPTURES` table. This `DELETE` operation removes all rows from the `SCULPTURES` table where the value in the `SCULPTORID` column matches the value provided in the `p_artist_id` input parameter. After this second deletion, the `p_deleted_count` output parameter is updated by adding the value of `SQL%ROWCOUNT` (representing the number of rows deleted from `SCULPTURES`) to its current value, effectively accumulating the total count of deleted records from both tables."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_manage_catalog` that accepts three input parameters: `p_parent_id` of type `NUMBER`, `p_capacity` of type `VARCHAR2`, and `p_attribute_id` of type `NUMBER`. The procedure begins by declaring several local variables: `v_max_id` of type `NUMBER`, `v_new_id` of type `NUMBER`, `v_level` of type `NUMBER`, `v_name` of type `VARCHAR2(255)`, and `v_stock` of type `VARCHAR2(255)`.\n\nThe procedure first executes a `SELECT` statement to retrieve the maximum value from the `CATALOG_ENTRY_ID` column in the `CATALOG_CONTENTS` table and stores this value into the `v_max_id` variable. Subsequently, it calculates a new ID by adding 1 to `v_max_id` and assigns this result to the `v_new_id` variable.\n\nNext, it performs another `SELECT` statement on the `CATALOG_CONTENTS` table. This query retrieves the value of the `CATALOG_LEVEL_NUMBER` column, increments it by 1, and stores the result in the `v_level` variable. It also concatenates the string '_child' to the value of the `CATALOG_ENTRY_NAME` column and stores this new string in the `v_name` variable. Additionally, it retrieves the value of the `PRODUCT_STOCK_NUMBER` column and stores it in the `v_stock` variable. This `SELECT` operation is filtered by a `WHERE` clause, ensuring that only the row where the `CATALOG_ENTRY_ID` column matches the input parameter `p_parent_id` is considered.\n\nFollowing these selections, the procedure executes an `INSERT` statement to add a new row into the `CATALOG_CONTENTS` table. The values inserted are: `v_new_id` for `CATALOG_ENTRY_ID`, `v_level` for `CATALOG_LEVEL_NUMBER`, `p_parent_id` for `PARENT_ENTRY_ID`, `v_name` for `CATALOG_ENTRY_NAME`, `v_stock` for `PRODUCT_STOCK_NUMBER`, and `p_capacity` for `CAPACITY`.\n\nImmediately after, another `INSERT` statement is executed, this time adding a new row into the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. The values inserted are: `v_new_id` for `CATALOG_ENTRY_ID`, `v_level` for `CATALOG_LEVEL_NUMBER`, `p_attribute_id` for `ATTRIBUTE_ID`, and the literal string '1' for `ATTRIBUTE_VALUE`.\n\nSubsequently, an `UPDATE` statement is performed on the `CATALOG_CONTENTS` table. This statement sets the `NEXT_ENTRY_ID` column to the value of `v_new_id` for the row where the `CATALOG_ENTRY_ID` column matches the input parameter `p_parent_id`.\n\nFinally, the procedure executes a `DELETE` statement to remove rows from the `CATALOG_CONTENTS` table. This deletion is conditional, targeting rows where the value of the `CAPACITY` column is less than the input parameter `p_capacity` AND the value of the `CATALOG_LEVEL_NUMBER` column is equal to the `v_level` variable.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_catalog(p_parent_id NUMBER, p_capacity VARCHAR2, p_attribute_id NUMBER) IS\n  v_max_id NUMBER;\n  v_new_id NUMBER;\n  v_level NUMBER;\n  v_name VARCHAR2(255);\n  v_stock VARCHAR2(255);\nBEGIN\n  SELECT MAX(CATALOG_ENTRY_ID) INTO v_max_id FROM CATALOG_CONTENTS;\n  v_new_id := v_max_id + 1;\n  SELECT CATALOG_LEVEL_NUMBER + 1, CATALOG_ENTRY_NAME || '_child', PRODUCT_STOCK_NUMBER INTO v_level, v_name, v_stock FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_parent_id;\n  INSERT INTO CATALOG_CONTENTS (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, PARENT_ENTRY_ID, CATALOG_ENTRY_NAME, PRODUCT_STOCK_NUMBER, CAPACITY) VALUES (v_new_id, v_level, p_parent_id, v_name, v_stock, p_capacity);\n  INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE) VALUES (v_new_id, v_level, p_attribute_id, '1');\n  UPDATE CATALOG_CONTENTS SET NEXT_ENTRY_ID = v_new_id WHERE CATALOG_ENTRY_ID = p_parent_id;\n  DELETE FROM CATALOG_CONTENTS WHERE CAPACITY < p_capacity AND CATALOG_LEVEL_NUMBER = v_level;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_catalog(p_parent_id => 1, p_capacity => '2', p_attribute_id => 4);\nEND;",
      "BEGIN\n  sp_manage_catalog(p_parent_id => 2, p_capacity => '5', p_attribute_id => 3);\nEND;",
      "BEGIN\n  sp_manage_catalog(p_parent_id => 3, p_capacity => '1', p_attribute_id => 2);\nEND;",
      "BEGIN\n  sp_manage_catalog(p_parent_id => 1, p_capacity => '8', p_attribute_id => 4);\nEND;",
      "BEGIN\n  sp_manage_catalog(p_parent_id => 2, p_capacity => '3', p_attribute_id => 3);\nEND;"
    ],
    "summary": "Create a stored procedure named `sp_manage_catalog` that inserts a new child catalog entry based on a parent ID, copies and modifies data from the parent (level+1, name+'_child'), inserts a corresponding attribute record, updates the parent's next entry pointer, and deletes entries at the new level where capacity is below a provided threshold.",
    "natural_language": "Create a comprehensive stored procedure, to be named `sp_manage_catalog`, which performs a detailed sequence of operations. This procedure should first insert a new child catalog entry by referencing a specified parent ID. It must then meticulously copy and subsequently modify the parent's data, specifically incrementing the level by one and appending the suffix '_child' to the name. Following this, the procedure is required to insert a corresponding attribute record linked to the new child entry. Subsequently, it must update the parent catalog entry's pointer to correctly reference this new child as the next entry. Finally, the procedure should conclude by thoroughly deleting any existing catalog entries at the newly created child level where their recorded capacity falls beneath a provided, specific threshold value.",
    "id": 96,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp_manage_catalog` that performs a series of operations on the `product_catalog` database. The procedure first declares several local variables: `v_parent_entry_id` of type `NUMBER` to store the parent catalog entry ID, `v_child_entry_id` of type `NUMBER` to store the newly generated child catalog entry ID, `v_parent_level` of type `NUMBER` to store the catalog level number of the parent, `v_parent_name` of type `VARCHAR2(255)` to store the catalog entry name of the parent, `v_parent_stock_number` of type `VARCHAR2(255)` to store the product stock number of the parent, `v_parent_price_dollars` of type `NUMBER` to store the price in dollars of the parent, `v_parent_price_euros` of type `NUMBER` to store the price in euros of the parent, `v_parent_price_pounds` of type `NUMBER` to store the price in pounds of the parent, `v_parent_capacity` of type `VARCHAR2(255)` to store the capacity of the parent, `v_parent_length` of type `VARCHAR2(255)` to store the length of the parent, `v_parent_height` of type `VARCHAR2(255)` to store the height of the parent, `v_parent_width` of type `VARCHAR2(255)` to store the width of the parent, and `v_threshold` of type `VARCHAR2(255)` to store the capacity threshold value for deletion.\n\nThe procedure begins by retrieving the parent catalog entry's data from the `CATALOG_CONTENTS` table. It executes a `SELECT` statement to fetch `CATALOG_LEVEL_NUMBER`, `CATALOG_ENTRY_NAME`, `PRODUCT_STOCK_NUMBER`, `PRICE_IN_DOLLARS`, `PRICE_IN_EUROS`, `PRICE_IN_POUNDS`, `CAPACITY`, `LENGTH`, `HEIGHT`, and `WIDTH` for the row where `CATALOG_ENTRY_ID` equals the input parameter `p_parent_id`. The retrieved values are stored into the corresponding local variables `v_parent_level`, `v_parent_name`, `v_parent_stock_number`, `v_parent_price_dollars`, `v_parent_price_euros`, `v_parent_price_pounds`, `v_parent_capacity`, `v_parent_length`, `v_parent_height`, and `v_parent_width`.\n\nNext, the procedure inserts a new child catalog entry into the `CATALOG_CONTENTS` table. It performs an `INSERT` operation, specifying values for all columns. For `CATALOG_ENTRY_ID`, it uses a subquery `(SELECT NVL(MAX(CATALOG_ENTRY_ID), 0) + 1 FROM CATALOG_CONTENTS)` to generate a new unique ID by taking the maximum existing `CATALOG_ENTRY_ID` and adding 1, handling nulls with `NVL`. For `CATALOG_LEVEL_NUMBER`, it uses `v_parent_level + 1` to increment the parent's level by one. For `PARENT_ENTRY_ID`, it uses the input parameter `p_parent_id`. For `PREVIOUS_ENTRY_ID`, it uses `NULL`. For `NEXT_ENTRY_ID`, it uses `NULL`. For `CATALOG_ENTRY_NAME`, it concatenates `v_parent_name` with the literal string `'_child'`. For `PRODUCT_STOCK_NUMBER`, it uses `v_parent_stock_number`. For `PRICE_IN_DOLLARS`, it uses `v_parent_price_dollars`. For `PRICE_IN_EUROS`, it uses `v_parent_price_euros`. For `PRICE_IN_POUNDS`, it uses `v_parent_price_pounds`. For `CAPACITY`, it uses `v_parent_capacity`. For `LENGTH`, it uses `v_parent_length`. For `HEIGHT`, it uses `v_parent_height`. For `WIDTH`, it uses `v_parent_width`. After the insert, the procedure retrieves the newly generated `CATALOG_ENTRY_ID` by selecting `CATALOG_ENTRY_ID` from `CATALOG_CONTENTS` where `CATALOG_ENTRY_ID` equals the value just inserted (using the same subquery logic), storing it in `v_child_entry_id`.\n\nThen, the procedure inserts a corresponding attribute record into the `CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES` table. It performs an `INSERT` operation, specifying values for all columns. For `CATALOG_ENTRY_ID`, it uses `v_child_entry_id`. For `CATALOG_LEVEL_NUMBER`, it uses `v_parent_level + 1`. For `ATTRIBUTE_ID`, it uses the input parameter `p_attribute_id`. For `ATTRIBUTE_VALUE`, it uses the input parameter `p_attribute_value`.\n\nFollowing this, the procedure updates the parent catalog entry in the `CATALOG_CONTENTS` table to set its `NEXT_ENTRY_ID` pointer to reference the new child entry. It executes an `UPDATE` statement on the `CATALOG_CONTENTS` table, setting `NEXT_ENTRY_ID` to `v_child_entry_id` where `CATALOG_ENTRY_ID` equals the input parameter `p_parent_id`.\n\nFinally, the procedure deletes any existing catalog entries at the newly created child level where their recorded capacity falls below a provided threshold. It executes a `DELETE` statement on the `CATALOG_CONTENTS` table, removing rows where `CATALOG_LEVEL_NUMBER` equals `v_parent_level + 1` and `CAPACITY` is less than the input parameter `p_capacity_threshold`. The procedure does not return any value; it performs the operations and commits the changes implicitly or explicitly as per the transaction handling."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named delete_student_pet that accepts three parameters: p_stuid of type NUMBER, p_petid of type NUMBER, and p_pettype of type VARCHAR2. The procedure performs two delete operations. First, it deletes rows from the has_pet table where the stuid column matches the value of p_stuid and the petid column matches the value of p_petid. Second, it deletes rows from the pets table where the petid column matches the value of p_petid and the pettype column matches the value of p_pettype.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_student_pet(p_stuid IN NUMBER, p_petid IN NUMBER, p_pettype IN VARCHAR2)\nIS\nBEGIN\n    DELETE FROM has_pet WHERE stuid = p_stuid AND petid = p_petid;\n    DELETE FROM pets WHERE petid = p_petid AND pettype = p_pettype;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS"
    ],
    "call_sqls": [
      "BEGIN\n  delete_student_pet(1001, 2001, 'cat');\n  commit;\nEND;",
      "BEGIN\n  delete_student_pet(1002, 2002, 'dog');\n  commit;\nEND;",
      "BEGIN\n  delete_student_pet(1001, 2003, 'cat');\n  commit;\nEND;",
      "BEGIN\n  delete_student_pet(1002, 2001, 'dog');\n  commit;\nEND;",
      "BEGIN\n  delete_student_pet(1001, 2002, 'cat');\n  commit;\nEND;"
    ],
    "summary": "Create a stored procedure named DELETE_STUDENT_PET that accepts parameters p_stuid (NUMBER), p_petid (NUMBER), and p_pettype (VARCHAR2). Delete from the HAS_PET table where STUID matches p_stuid and PETID matches p_petid. Then delete from the PETS table where PETID matches p_petid and PETTYPE matches p_pettype.",
    "natural_language": "How can I create a stored procedure named DELETE_STUDENT_PET that takes p_stuid (NUMBER), p_petid (NUMBER), and p_pettype (VARCHAR2) as parameters, so that it first deletes records from the HAS_PET table where STUID equals p_stuid and PETID equals p_petid, and then deletes from the PETS table where PETID equals p_petid and PETTYPE equals p_pettype?",
    "id": 97,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DELETE_STUDENT_PET that takes three parameters: a NUMBER parameter p_stuid, a NUMBER parameter p_petid, and a VARCHAR2 parameter p_pettype. The procedure performs two DELETE operations sequentially. First, it deletes rows from the HAS_PET table where the STUID column equals the input parameter p_stuid and the PETID column equals the input parameter p_petid. Second, it deletes rows from the PETS table where the PETID column equals the input parameter p_petid and the PETTYPE column equals the input parameter p_pettype. The procedure does not return a value."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertNewUniversity that accepts four input parameters: p_university_name of type VARCHAR2, p_city of type VARCHAR2, p_state of type VARCHAR2, and p_enrollment of type NUMBER. The procedure performs an insertion operation into the UNIVERSITY table, which consists of five columns: UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, and ENROLLMENT. The UNIVERSITY_ID column is assigned a value derived from a subquery that selects the maximum value of UNIVERSITY_ID from the UNIVERSITY table, applies the NVL function to handle null cases by defaulting to 0, and then increments this value by 1 to generate a new unique identifier for the university being inserted. The UNIVERSITY_NAME column is populated with the value provided in the p_university_name parameter, the CITY column is populated with the value from the p_city parameter, the STATE column is populated with the value from the p_state parameter, and the ENROLLMENT column is populated with the value from the p_enrollment parameter. The procedure does not include any conditional logic or additional operations beyond the insertion into the table.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertNewUniversity(\n    p_university_name IN VARCHAR2,\n    p_city IN VARCHAR2,\n    p_state IN VARCHAR2,\n    p_enrollment IN NUMBER\n) AS\nBEGIN\n    INSERT INTO UNIVERSITY (UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, ENROLLMENT)\n    VALUES ((SELECT NVL(MAX(UNIVERSITY_ID), 0) + 1 FROM UNIVERSITY), p_university_name, p_city, p_state, p_enrollment);\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "BEGIN\n  InsertNewUniversity('University of Chicago', 'Chicago', 'Illinois', 17000);\nEND;",
      "BEGIN\n  InsertNewUniversity('Northwestern University', 'Evanston', 'Illinois', 22000);\nEND;",
      "BEGIN\n  InsertNewUniversity('University of Wisconsin-Madison', 'Madison', 'Wisconsin', 45000);\nEND;",
      "BEGIN\n  InsertNewUniversity('Marquette University', 'Milwaukee', 'Wisconsin', 11000);\nEND;",
      "BEGIN\n  InsertNewUniversity('DePaul University', 'Chicago', 'Illinois', 22000);\nEND;"
    ],
    "summary": "Create a stored procedure named InsertNewUniversity that accepts university name, city, state, and enrollment as parameters. Insert a new record into the UNIVERSITY table, generating a new UNIVERSITY_ID by taking the maximum existing ID (or 0 if none) and adding 1.",
    "natural_language": "How can I create a stored procedure called InsertNewUniversity that takes university name, city, state, and enrollment as parameters to insert a new record into the UNIVERSITY table, generating a new UNIVERSITY_ID by adding 1 to the maximum existing ID or using 1 if no records exist?",
    "id": 98,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named InsertNewUniversity that accepts four input parameters: p_university_name of type VARCHAR2, p_city of type VARCHAR2, p_state of type VARCHAR2, and p_enrollment of type NUMBER. The procedure performs an insertion operation into the UNIVERSITY table, which consists of five columns: UNIVERSITY_ID, UNIVERSITY_NAME, CITY, STATE, and ENROLLMENT. The UNIVERSITY_ID column is assigned a value derived from a subquery that selects the maximum value of UNIVERSITY_ID from the UNIVERSITY table, applies the NVL function to handle null cases by defaulting to 0, and then increments this value by 1 to generate a new unique identifier for the university being inserted. The UNIVERSITY_NAME column is populated with the value provided in the p_university_name parameter, the CITY column is populated with the value from the p_city parameter, the STATE column is populated with the value from the p_state parameter, and the ENROLLMENT column is populated with the value from the p_enrollment parameter. The procedure does not include any conditional logic or additional operations beyond the insertion into the table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp2` that accepts three input parameters: `para_Course_ID` of type `NUMBER`, `para_Starting_Date` of type `VARCHAR2`, and `para_Course` of type `VARCHAR2`. The procedure first declares a local variable `v_MaxGrade` of type `NUMBER`. It then executes a `SELECT` statement to retrieve the maximum value from the `GRADE` column in the `COURSE_ARRANGE` table, specifically for rows where the `COURSE_ID` column matches the value provided in the `para_Course_ID` input parameter. This retrieved maximum grade value is then stored into the `v_MaxGrade` local variable. Following this, the procedure evaluates a conditional `IF` statement: if the value of `v_MaxGrade` is greater than `3`, it proceeds to execute a `MERGE` statement. This `MERGE` statement targets the `COURSE` table, using a source derived from the `DUAL` table which effectively creates a single row containing the values from `para_Course_ID` aliased as `COURSE_ID`, `para_Starting_Date` aliased as `STARING_DATE`, and `para_Course` aliased as `COURSE`. The `MERGE` operation attempts to match rows in the `COURSE` table with this source row based on the condition where the `COURSE_ID` column in the `COURSE` table equals the `COURSE_ID` from the source. If a match is found (`WHEN MATCHED`), the `STARING_DATE` column in the `COURSE` table is updated with the `STARING_DATE` value from the source, and the `COURSE` column in the `COURSE` table is updated with the `COURSE` value from the source. If no match is found (`WHEN NOT MATCHED`), a new row is inserted into the `COURSE` table with values for `COURSE_ID`, `STARING_DATE`, and `COURSE` taken from the corresponding columns in the source. If the initial `IF` condition evaluates to false (i.e., `v_MaxGrade` is not greater than `3`), the procedure executes a `DELETE` statement that removes all rows from the `COURSE` table where the `COURSE_ID` column matches the value provided in the `para_Course_ID` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp2(para_Course_ID NUMBER, para_Starting_Date VARCHAR2, para_Course VARCHAR2) IS\n  v_MaxGrade NUMBER;\nBEGIN\n  SELECT MAX(GRADE) INTO v_MaxGrade FROM COURSE_ARRANGE WHERE COURSE_ID = para_Course_ID;\n\n  IF v_MaxGrade > 3 THEN\n    MERGE INTO COURSE c\n    USING (SELECT para_Course_ID AS COURSE_ID, para_Starting_Date AS STARING_DATE, para_Course AS COURSE FROM DUAL) src\n    ON (c.COURSE_ID = src.COURSE_ID)\n    WHEN MATCHED THEN\n      UPDATE SET c.STARING_DATE = src.STARING_DATE,\n                 c.COURSE = src.COURSE\n    WHEN NOT MATCHED THEN\n      INSERT (COURSE_ID, STARING_DATE, COURSE)\n      VALUES (src.COURSE_ID, src.STARING_DATE, src.COURSE);\n  ELSE\n    DELETE FROM COURSE WHERE COURSE_ID = para_Course_ID;\n  END IF;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "BEGIN\n  sp2(2, '10 May', 'History');\nEND;",
      "BEGIN\n  sp2(3, '11 May', 'Art');\nEND;",
      "BEGIN\n  sp2(1, '12 May', 'Music');\nEND;",
      "BEGIN\n  sp2(2, '13 May', 'Geography');\nEND;",
      "BEGIN\n  sp2(3, '14 May', 'Physics');\nEND;"
    ],
    "summary": "Create a stored procedure named sp2 that takes a course ID (number), starting date (string), and course name (string). Find the maximum grade for that course ID from the COURSE_ARRANGE table. If the maximum grade is greater than 3, merge the data into the COURSE table, updating the existing record or inserting a new one. Otherwise, delete all records for that course ID from the COURSE table.",
    "natural_language": "Develop a stored procedure called sp2 that accepts three input parameters: a numeric course identifier, a starting date expressed as a string, and a string representing the course's name. The procedure should first determine the highest grade associated with the provided course ID by querying the COURSE_ARRANGE table. In the event that this maximum grade exceeds the value of 3, the procedure must perform a merge operation into the COURSE table, which will either update the current entry for that course or insert a completely new record if one does not already exist. Conversely, if the maximum grade is found to be 3 or lower, the procedure should proceed to remove every single record corresponding to that specific course ID from the COURSE table.",
    "id": 99,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp2 that accepts three input parameters: p_course_id of type NUMBER representing the unique identifier of a course, p_starting_date of type VARCHAR2 representing the starting date of the course, and p_course of type VARCHAR2 representing the name of the course. The procedure declares one local variable: v_max_grade of type NUMBER to store the highest grade value retrieved from the COURSE_ARRANGE table.\n\nThe procedure begins by executing a SELECT statement to calculate the maximum value of the GRADE column from the COURSE_ARRANGE table. The query includes a WHERE clause to filter rows where the COURSE_ID column matches the input parameter p_course_id. The result of the MAX aggregate function is stored into the local variable v_max_grade using the INTO clause.\n\nFollowing the retrieval of the maximum grade, the procedure implements conditional logic using an IF statement. It checks if the value of v_max_grade is greater than 3. If this condition is true, the procedure executes a MERGE operation targeting the COURSE table. The MERGE statement uses the input parameter p_course_id to match against the COURSE_ID column in the COURSE table. When a match is found (i.e., WHEN MATCHED THEN), it performs an UPDATE operation setting the COURSE table's STARING_DATE column to the value of the input parameter p_starting_date and the COURSE column to the value of the input parameter p_course. When no match is found (i.e., WHEN NOT MATCHED THEN), it performs an INSERT operation, creating a new record with values for COURSE_ID, STARING_DATE, and COURSE columns taken from the input parameters p_course_id, p_starting_date, and p_course, respectively.\n\nIf the initial condition is false, meaning v_max_grade is less than or equal to 3, the procedure executes a DELETE operation on the COURSE table. The DELETE statement includes a WHERE clause to remove all rows where the COURSE_ID column matches the input parameter p_course_id.\n\nThe procedure does not have an explicit exception handling block and does not return a value, as it is designed to perform data manipulation operations based on the conditional logic."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DELETE_TEACHER_COURSES that accepts three parameters: an input parameter P_TEACHER_ID of type NUMBER to identify a specific teacher, an input parameter P_AGE_LIMIT of type VARCHAR2 representing a textual age threshold, and an output parameter P_DELETED_COUNT of type NUMBER to return the number of rows affected. The procedure performs a DELETE operation on the COURSE_ARRANGE table, using the alias CA. It deletes rows from COURSE_ARRANGE where the TEACHER_ID column matches the provided P_TEACHER_ID value, but only if a correlated subquery condition is also satisfied. The subquery checks the TEACHER table, aliased as T, for the existence of a teacher record where the TEACHER_ID matches the TEACHER_ID from the outer COURSE_ARRANGE row. For that matching teacher record, it converts the AGE column from the TEACHER table and the P_AGE_LIMIT input parameter from VARCHAR2 to NUMBER using the TO_NUMBER function, and then verifies that the teacher's numerical age is less than the numerical value of the provided P_AGE_LIMIT. After the DELETE operation completes, the procedure assigns the number of rows deleted, obtained from the SQL%ROWCOUNT attribute, to the output parameter P_DELETED_COUNT.",
    "plsql": "CREATE OR REPLACE PROCEDURE DELETE_TEACHER_COURSES(\n  P_TEACHER_ID IN NUMBER,\n  P_AGE_LIMIT IN VARCHAR2,\n  P_DELETED_COUNT OUT NUMBER\n) AS\nBEGIN\n  DELETE FROM COURSE_ARRANGE CA\n  WHERE CA.TEACHER_ID = P_TEACHER_ID\n  AND EXISTS (\n    SELECT 1\n    FROM TEACHER T\n    WHERE T.TEACHER_ID = CA.TEACHER_ID\n    AND TO_NUMBER(T.AGE) < TO_NUMBER(P_AGE_LIMIT)\n  );\n  P_DELETED_COUNT := SQL%ROWCOUNT;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(1, '30', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(2, '28', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(3, '35', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(5, '25', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;",
      "DECLARE\n  v_deleted_count NUMBER;\nBEGIN\n  DELETE_TEACHER_COURSES(2, '40', v_deleted_count);\n  DBMS_OUTPUT.PUT_LINE('Deleted Count: ' || v_deleted_count);\nEND;"
    ],
    "summary": "Create a stored procedure named `DELETE_TEACHER_COURSES` that deletes course arrangements for a specific teacher whose age is below a given limit. It accepts a teacher ID and an age limit (as text) as input, and returns the count of deleted rows as an output parameter. The procedure deletes rows from `COURSE_ARRANGE` for the specified teacher, but only if the teacher's age (converted to a number) is less than the provided age limit (also converted to a number).",
    "natural_language": "Please construct a stored procedure designated as `DELETE_TEACHER_COURSES`. This procedure is to remove course arrangements for a specified educator, contingent upon the educator's age being beneath a stipulated threshold. It shall accept two input parameters: a teacher identifier and an age limit, the latter provided as textual data. The procedure must return the quantity of deleted records via an output parameter. The deletion operation is to be performed on the `COURSE_ARRANGE` table, targeting entries associated with the provided teacher ID. This action is to be executed only if the numerical representation of the teacher's age is determined to be less than the numerical value derived from the supplied age limit parameter.",
    "id": 100,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DELETE_TEACHER_COURSES that accepts three parameters: an input parameter p_teacher_id of type NUMBER to specify the teacher identifier, an input parameter p_age_limit of type VARCHAR2 to provide the age threshold as textual data, and an output parameter p_deleted_count of type NUMBER to return the quantity of deleted records. The procedure is designed to remove course arrangements for a specified teacher from the COURSE_ARRANGE table, but only if the teacher's age is below the given age limit.\n\nThe procedure first declares a local variable v_teacher_age of type NUMBER to store the numerical representation of the teacher's age. It then retrieves the age of the teacher by performing a SELECT statement on the TEACHER table, selecting the AGE column where the TEACHER_ID matches the input p_teacher_id. Since the AGE column is stored as VARCHAR2, the procedure converts this value to a NUMBER using the TO_NUMBER function and stores it in v_teacher_age.\n\nNext, the procedure checks if the retrieved teacher age (v_teacher_age) is less than the numerical value derived from the input age limit parameter (p_age_limit). To do this, it converts p_age_limit from VARCHAR2 to NUMBER using the TO_NUMBER function for comparison. If the condition v_teacher_age < TO_NUMBER(p_age_limit) is true, the procedure proceeds to delete records from the COURSE_ARRANGE table. The deletion targets entries where the TEACHER_ID column equals the input p_teacher_id. The procedure uses the SQL DELETE statement with a WHERE clause specifying TEACHER_ID = p_teacher_id. After the deletion, it retrieves the number of rows affected by using the SQL%ROWCOUNT attribute and assigns this value to the output parameter p_deleted_count.\n\nIf the teacher's age is not less than the age limit (i.e., the condition is false), the procedure sets the output parameter p_deleted_count to 0, indicating that no records were deleted. The procedure includes error handling to manage potential exceptions, such as conversion errors if the age values are not valid numbers, but the natural language description does not specify explicit error handling, so it is implied that standard PL/SQL exception handling may be used if needed. The procedure operates within the course_teach database and interacts with the TEACHER and COURSE_ARRANGE tables, using the TEACHER_ID column to link the teacher's age check with the deletion operation."
  }
]