[
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_default_brand` that checks if a `brand_id` from the `NEW` record exists in the `brands` table using a `SELECT 1` query within an `IF NOT EXISTS` condition. If the `brand_id` does not exist, the function inserts a new row into the `brands` table with the `NEW.brand_id`, the brand_name set to `'Unknown'`, and is_active set to `1`. The function then returns the `NEW` record.\nSecond, define the trigger `trg_insert_default_brand` on table `products` that fires `BEFORE` `INSERT` for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_default_brand() RETURNS TRIGGER AS $$\nBEGIN\n  IF NOT EXISTS (SELECT 1 FROM brands WHERE brand_id = NEW.brand_id) THEN\n    INSERT INTO brands (brand_id, brand_name, is_active) VALUES (NEW.brand_id, 'Unknown', 1);\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_default_brand\nBEFORE INSERT ON products\nFOR EACH ROW EXECUTE FUNCTION insert_default_brand();",
    "database_name": "apparel_size_and_fit_management",
    "tables": [
      "products",
      "brands",
      "product_sizes"
    ],
    "call_sqls": [
      "INSERT INTO products (product_id, product_name, category_id, brand_id, color, material, gender, fit_type, created_at, updated_at) VALUES (1, 'Product A', 101, 1001, 'Red', 'Cotton', 'Unisex', 'Regular', '2023-10-01', '2023-10-01');",
      "INSERT INTO products (product_id, product_name, category_id, brand_id, color, material, gender, fit_type, created_at, updated_at) VALUES (2, 'Product B', 102, 1002, 'Blue', 'Polyester', 'Male', 'Slim', '2023-10-02', '2023-10-02');",
      "INSERT INTO products (product_id, product_name, category_id, brand_id, color, material, gender, fit_type, created_at, updated_at) VALUES (3, 'Product C', 103, 1003, 'Green', 'Wool', 'Female', 'Loose', '2023-10-03', '2023-10-03');",
      "INSERT INTO products (product_id, product_name, category_id, brand_id, color, material, gender, fit_type, created_at, updated_at) VALUES (4, 'Product D', 104, 1004, 'Yellow', 'Silk', 'Unisex', 'Regular', '2023-10-04', '2023-10-04');",
      "INSERT INTO products (product_id, product_name, category_id, brand_id, color, material, gender, fit_type, created_at, updated_at) VALUES (5, 'Product E', 105, 1005, 'Black', 'Leather', 'Male', 'Slim', '2023-10-05', '2023-10-05');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `trg_insert_default_brand` that fires BEFORE INSERT on the `products` table for each row, ensuring that any `brand_id` referenced in the new product exists in the `brands` table; if the `brand_id` does not already exist in `brands`, automatically insert a new record into the `brands` table with that `brand_id`, setting `brand_name` to 'Unknown' and `is_active` to 1, and then proceed with the product insertion.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named `insert_default_brand` that activates BEFORE INSERT on the `products` table for each row, checks if a matching `brand_id` already exists in the `brands` table, and if not, inserts a new row into `brands` with that `brand_id`, setting `brand_name` to 'Unknown' and `is_active` to 1, then returns the NEW row.",
    "id": 1,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `insert_default_brand` that is designed to be executed in response to data manipulation events on a table. This function takes no explicit input parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the row before and after the triggering event, respectively. The function is declared to return a `TRIGGER` type, which is standard for PL/pgSQL trigger functions. The function declares a variable `brand_exists` of type `boolean` to store the result of a check for the existence of a brand. The core logic begins with a `SELECT` statement that queries the `brands` table. It uses the `EXISTS` clause to check if there is any row in the `brands` table where the `brand_id` column equals the value of `NEW.brand_id` from the row being inserted into the `products` table. The result of this existence check is stored in the `brand_exists` variable. Next, an `IF` control flow statement evaluates the condition `NOT brand_exists`. If this condition is true, meaning no matching `brand_id` exists in the `brands` table, the function executes an `INSERT` statement. This `INSERT` statement adds a new row into the `brands` table. The values inserted are: `brand_id` set to `NEW.brand_id`, `brand_name` set to the literal string 'Unknown', and `is_active` set to the integer 1. The other columns in the `brands` table (`country_of_origin`, `website`, `founded_year`) are not specified in this `INSERT` statement and will therefore be set to their default values, which are `NULL` unless otherwise defined by the table schema. After performing this conditional insertion, the function returns the `NEW` record. Second, define the trigger named `insert_default_brand` on the `products` table. This trigger is defined to activate `BEFORE INSERT` operations on the `products` table. The `FOR EACH ROW` clause specifies that the trigger function `insert_default_brand` will be executed once for each row that is being inserted into the `products` table. The `EXECUTE FUNCTION insert_default_brand()` clause explicitly calls the previously defined trigger function to perform its logic. Therefore, whenever a new row is inserted into the `products` table, this trigger will automatically execute the `insert_default_brand` function, which checks for the existence of the referenced `brand_id` in the `brands` table and, if missing, creates a default brand entry before allowing the product insertion to proceed.",
    "original_ir": "Write a PL/pgSQL trigger function named `insert_default_brand` that is designed to be executed before an `INSERT` operation on the `products` table, for each row being inserted. This function takes no explicit parameters but implicitly receives the `NEW` record, which represents the row about to be inserted into the `products` table. The primary purpose of this function is to ensure that a corresponding entry exists in the `brands` table for the `brand_id` specified in the new `products` record. Inside the function, a conditional block (`IF NOT EXISTS ... THEN ... END IF;`) is executed. This condition first performs a `SELECT` operation to check for the existence of a record in the `brands` table. Specifically, it attempts to select a constant value `1` from the `brands` table where the `brand_id` column matches the value of `NEW.brand_id` (the `brand_id` from the row currently being inserted into the `products` table). If this `SELECT` query returns no rows (meaning `NOT EXISTS` is true), indicating that no brand with the `brand_id` from the new product record currently exists in the `brands` table, then an `INSERT` operation is performed. This `INSERT` operation adds a new row into the `brands` table. The `brand_id` column of this new row is populated with the value from `NEW.brand_id`. The `brand_name` column is set to the literal string value `'Unknown'`. The `is_active` column is set to the integer literal value `1`. After this conditional logic, regardless of whether an `INSERT` into `brands` occurred, the function returns the `NEW` record. This returned `NEW` record represents the row that will ultimately be inserted into the `products` table, potentially modified by other trigger functions, but in this specific case, it is returned unchanged.\n\nFollowing the definition of the trigger function, a database trigger named `trg_insert_default_brand` is created. This trigger is configured to execute `BEFORE INSERT` operations on the `products` table. It is specified to run `FOR EACH ROW`, meaning the `insert_default_brand` function will be invoked once for every row that is being inserted into the `products` table. The trigger explicitly `EXECUTE FUNCTION insert_default_brand()`, thereby linking the trigger event to the execution of the previously defined trigger function.",
    "original_summary": "Create a PostgreSQL trigger function named `insert_default_brand` that fires BEFORE INSERT on the `products` table for each row. Check if a record with `brand_id = NEW.brand_id` exists in the `brands` table. If it does not exist, insert a new row into the `brands` table with that `brand_id`, `brand_name` set to 'Unknown', and `is_active` set to 1. Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a PostgreSQL trigger function, which should be named `insert_default_brand`, designed to activate BEFORE any INSERT operation occurs on the `products` table for each individual row. This function must first perform a careful check to see if a corresponding record, specifically one where the `brand_id` matches the incoming `NEW.brand_id`, already exists within the `brands` table. In the event that this crucial record is found to be missing, the function should then proceed to gracefully insert a completely new row into the `brands` table. This new entry will utilize the provided `brand_id`, thoughtfully set the `brand_name` column to the descriptive value 'Unknown', and ensure the `is_active` status is confidently initialized to 1. Finally, the function must reliably return the NEW row for further processing."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `trigger_insert_version_on_experiment_complete` that, when the `status` column of the `experiments` table is updated to 'completed', inserts a new row into the `experiment_versions` table using `NEW.experiment_id` and `NEW.ended_at`, sets `version_number` to 'v1.0', `description` to 'Experiment completed version', and `version_type` to 'major', generates `version_id` with `nextval('experiment_versions_version_id_seq')`, and includes an `ON CONFLICT (version_id) DO NOTHING` clause. Second, define the trigger `insert_version_on_experiment_complete` on table `experiments` that fires `AFTER UPDATE OF status` and executes the function for each row where `NEW.status = 'completed'`.",
    "plsql": "CREATE SEQUENCE IF NOT EXISTS experiment_versions_version_id_seq START WITH 2;\n\nCREATE OR REPLACE FUNCTION trigger_insert_version_on_experiment_complete() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO experiment_versions (version_id, experiment_id, version_number, created_at, description, version_type) \n  VALUES (nextval('experiment_versions_version_id_seq'), NEW.experiment_id, 'v1.0', NEW.ended_at, 'Experiment completed version', 'major')\n  ON CONFLICT (version_id) DO NOTHING;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_version_on_experiment_complete\nAFTER UPDATE OF status ON experiments\nFOR EACH ROW WHEN (NEW.status = 'completed') EXECUTE FUNCTION trigger_insert_version_on_experiment_complete();",
    "database_name": "machine_learning_model_performance_tracking_6768",
    "tables": [
      "experiments",
      "experiment_versions",
      "perplexity_metrics"
    ],
    "call_sqls": [
      "UPDATE experiments SET status = 'completed', ended_at = '2023-01-03 10:00:00' WHERE experiment_id = 0;",
      "UPDATE experiments SET status = 'completed', ended_at = '2023-02-03 11:30:00' WHERE experiment_id = 1;",
      "INSERT INTO experiments (experiment_id, model_id, experiment_name, started_at, ended_at, status, description, experiment_type, evaluation_metric) VALUES (2, 1, 'Exp3', '2023-03-01 09:00:00', '2023-03-02 14:00:00', 'completed', 'Third experiment', 'hyperparameter tuning', 'accuracy');",
      "UPDATE experiments SET status = 'completed', ended_at = '2023-04-05 16:00:00' WHERE experiment_id = 2;",
      "UPDATE experiments SET status = 'running', ended_at = NULL WHERE experiment_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trigger_insert_version_on_experiment_complete that, after an update to the status column on the experiments table where the new status is 'completed', inserts a new row into the experiment_versions table with a version_id from a sequence, the experiment_id and ended_at from the updated row, version_number as 'v1.0', description as 'Experiment completed version', and version_type as 'major', ignoring any conflicts on version_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trigger_insert_version_on_experiment_complete that fires after an update to the status column on the experiments table, specifically when the status changes to 'completed'. This trigger should insert a new record into the experiment_versions table with a version_id from a sequence, using the experiment_id and ended_at from the updated row, setting version_number to 'v1.0', description to 'Experiment completed version', and version_type to 'major', while ignoring any conflicts on version_id.",
    "id": 2,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named trigger_insert_version_on_experiment_complete. This function is designed to be executed after an update operation on the experiments table, specifically when the status column changes to 'completed'. The function checks if the status column has been updated to 'completed' by comparing the NEW.status value to 'completed' and verifying that the OLD.status is not equal to 'completed'. If this condition is met, the function proceeds to insert a new record into the experiment_versions table. The function uses a sequence to generate a unique version_id for the new record. It retrieves the next value from the sequence, which is typically named experiment_versions_version_id_seq, to assign to the version_id column. The experiment_id is taken from the NEW.experiment_id of the updated row in the experiments table. The version_number is hardcoded to 'v1.0'. The created_at column is set to the ended_at value from the NEW row of the experiments table, which represents the timestamp when the experiment was completed. The description is hardcoded to 'Experiment completed version'. The version_type is hardcoded to 'major'. The insert operation includes an ON CONFLICT clause on the version_id column to ignore any conflicts, meaning that if a duplicate version_id is encountered (which is unlikely due to the sequence), the insert is skipped without raising an error. After performing the insert, the function returns NEW, allowing the original update operation on the experiments table to proceed. Second, define the trigger named trigger_insert_version_on_experiment_complete on the experiments table. This trigger is set to execute the function after each row is updated on the experiments table, ensuring that the function runs only when the status column is updated to 'completed'.",
    "original_ir": "Write a PLpgSQL trigger function that automatically inserts a new record into the experiment_versions table whenever an experiment's status is updated to 'completed'. The function, named trigger_insert_version_on_experiment_complete, is executed after an update operation on the status column of the experiments table. It checks if the new status of the experiment is 'completed' and, if so, inserts a new row into the experiment_versions table. This insertion includes the following values: a unique version_id generated by the nextval function from the sequence experiment_versions_version_id_seq, the experiment_id from the updated row in the experiments table, a fixed version_number set to 'v1.0', the ended_at timestamp from the updated row as the created_at value, a description stating 'Experiment completed version', and a version_type labeled as 'major'. The insertion operation is protected by an ON CONFLICT clause on the version_id column, which ensures that if a conflict occurs, no action is taken, thereby preventing duplicate entries. The trigger, named insert_version_on_experiment_complete, is defined to execute this function for each row that meets the condition of having its status updated to 'completed'.",
    "original_summary": "Create an AFTER UPDATE trigger function named trigger_insert_version_on_experiment_complete. When an experiment's status changes to 'completed', insert a new row into experiment_versions. The new row uses a sequence for version_id, takes the experiment_id and ended_at from the updated row, sets version_number to 'v1.0', description to 'Experiment completed version', and version_type to 'major'. Use ON CONFLICT on version_id to do nothing on conflict.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, can you set up a trigger that fires after an update? Name it trigger_insert_version_on_experiment_complete. Basically, whenever an experiment's status gets switched to 'completed', we wanna pop a new record into the experiment_versions table. For that new row, grab the version_id from a sequence, use the experiment_id and ended_at from the row that just got updated, set the version_number to 'v1.0', the description to 'Experiment completed version', and the version_type to 'major'. Oh, and if there's a clash on version_id, just skip itâ€”don't do anything."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `archive_old_update` that deletes rows from the `incident_updates` table where the `incident_id` matches `OLD.incident_id` and the `update_date` is less than the literal date '2020-01-01', then returns the `OLD` record.\nSecond, define the trigger `trg_after_incident_delete` on table `incidents` that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_old_update() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM incident_updates WHERE incident_id = OLD.incident_id AND update_date < '2020-01-01';\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_after_incident_delete\nAFTER DELETE ON incidents\nFOR EACH ROW EXECUTE FUNCTION archive_old_update();",
    "database_name": "crime_incident_reporting_and_analysis_893763",
    "tables": [
      "incidents",
      "incident_reports",
      "incident_updates",
      "offense_categories",
      "offense_types",
      "districts"
    ],
    "call_sqls": [
      "DELETE FROM incidents WHERE incident_id = 0;",
      "DELETE FROM incidents WHERE incident_id = 1;",
      "DELETE FROM incidents WHERE incident_id = 2;",
      "DELETE FROM incidents WHERE incident_id = 3;",
      "DELETE FROM incidents WHERE incident_id = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_after_incident_delete that executes after each row is deleted from the incidents table, calling a function to delete all related records from the incident_updates table where the incident_id matches the deleted incident's ID and the update_date is before January 1, 2020, then returns the deleted row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_after_incident_delete that, after a row is deleted from the incidents table, calls the archive_old_update function to delete any rows from the incident_updates table where the incident_id matches the deleted incident's incident_id and the update_date is before '2020-01-01', and then returns the OLD record.",
    "id": 3,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `archive_old_update` that deletes rows from the `incident_updates` table where the `incident_id` matches `OLD.incident_id` and the `update_date` is less than the literal date '2020-01-01', then returns the `OLD` record.\nSecond, define the trigger `trg_after_incident_delete` on table `incidents` that fires AFTER DELETE and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `archive_old_update` that is designed to be executed in response to a specific database event. This function takes no explicit input parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the state of the row before and after the triggering event, respectively. The primary purpose of this function is to perform a data cleanup operation on the `incident_updates` table. Specifically, it executes a `DELETE` statement targeting rows within the `incident_updates` table. The deletion criteria are twofold: first, it identifies rows where the `incident_id` column matches the `incident_id` value from the `OLD` record of the row that triggered the event. This `OLD.incident_id` refers to the `incident_id` of the row that was just deleted from the `incidents` table. Second, among those rows, it further filters for records where the `update_date` column is strictly less than the literal date value '2020-01-01'. After attempting this deletion, the function returns the `OLD` record.\n\nThis `archive_old_update` function is then associated with a trigger named `trg_after_incident_delete`. This trigger is configured to activate `AFTER DELETE` operations on the `incidents` table. The `FOR EACH ROW` clause specifies that the trigger function `archive_old_update()` will be executed once for each individual row that is deleted from the `incidents` table. Therefore, whenever a row is removed from the `incidents` table, this trigger will automatically invoke the `archive_old_update` function, which will then proceed to delete corresponding old update records from the `incident_updates` table based on the `incident_id` of the deleted incident and an `update_date` older than '2020-01-01'.",
    "original_summary": "Create an AFTER DELETE row-level trigger named trg_after_incident_delete on the incidents table. The trigger calls a PL/pgSQL function archive_old_update that deletes rows from the incident_updates table where the incident_id matches OLD.incident_id and update_date is before '2020-01-01', then returns OLD.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How do you create an AFTER DELETE row-level trigger named trg_after_incident_delete on the incidents table that calls a PL/pgSQL function archive_old_update to delete rows from the incident_updates table where the incident_id matches OLD.incident_id and the update_date is before '2020-01-01', and then returns OLD?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function validate_demographic_year that extracts the year from the NEW.last_updated column, casts it to a TIMESTAMP, uses EXTRACT(YEAR FROM ...) to get the year as an integer, casts that integer to TEXT, and assigns the result to NEW.year. Second, define the trigger trg_validate_demographic_year on table demographic_data that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_demographic_year() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.year := CAST(EXTRACT(YEAR FROM CAST(NEW.last_updated AS TIMESTAMP)) AS TEXT);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_demographic_year\nBEFORE INSERT ON demographic_data\nFOR EACH ROW EXECUTE FUNCTION validate_demographic_year();",
    "database_name": "demographic_data_collection_and_analysis_426928",
    "tables": [
      "demographic_data",
      "regions",
      "sexes",
      "years"
    ],
    "call_sqls": [
      "INSERT INTO demographic_data (data_id, region_id, sex, age_group, value, source_id, confidence_level, notes, last_updated) VALUES (2, 0, '0', '0', 100, 1, 'high', 'No issues with data collection', '2023-10-01 12:00:00');",
      "INSERT INTO demographic_data (data_id, region_id, sex, age_group, value, source_id, confidence_level, notes, last_updated) VALUES (3, 1, '1', '0', 50, 0, 'high', 'Data verified', '2023-10-01 12:00:00');",
      "INSERT INTO demographic_data (data_id, region_id, sex, age_group, value, source_id, confidence_level, notes, last_updated) VALUES (4, 0, '0', '0', 75, 1, 'medium', 'No issues', '2023-10-01 12:00:00');",
      "INSERT INTO demographic_data (data_id, region_id, sex, age_group, value, source_id, confidence_level, notes, last_updated) VALUES (5, 1, '1', '0', 60, 0, 'low', 'Data needs review', '2023-10-01 12:00:00');",
      "INSERT INTO demographic_data (data_id, region_id, sex, age_group, value, source_id, confidence_level, notes, last_updated) VALUES (6, 0, '0', '0', 80, 1, 'high', 'Data accurate', '2023-10-01 12:00:00');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_validate_demographic_year that fires BEFORE INSERT on the demographic_data table, setting the year column to the year extracted as text from the last_updated timestamp column for each new row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_validate_demographic_year that runs before inserting into the demographic_data table, extracting the year from the last_updated timestamp and storing it as text in the year field for each new row.",
    "id": 4,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function validate_demographic_year that extracts the year from the NEW.last_updated column, casts it to a TIMESTAMP, uses EXTRACT(YEAR FROM ...) to get the year as an integer, casts that integer to TEXT, and assigns the result to NEW.year. Second, define the trigger trg_validate_demographic_year on table demographic_data that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `validate_demographic_year` that is designed to be executed before an `INSERT` operation on the `demographic_data` table. This function does not accept any explicit input parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. Its primary purpose is to automatically populate or update the `year` column of the new row being inserted. Specifically, it accesses the `last_updated` column from the `NEW` record, which represents the row currently being inserted. It then casts the value of `NEW.last_updated` to a `TIMESTAMP` data type. From this `TIMESTAMP` value, it extracts the year component using the `EXTRACT(YEAR FROM ...)` function. The extracted year, which is an integer, is then explicitly cast to a `TEXT` data type. Finally, this resulting `TEXT` representation of the year is assigned to the `year` column of the `NEW` record (`NEW.year`). After performing this assignment, the function returns the modified `NEW` record, allowing the `INSERT` operation to proceed with the updated `year` value.\n\nConcurrently, a PostgreSQL trigger named `trg_validate_demographic_year` is defined. This trigger is configured to activate `BEFORE INSERT` operations on the `demographic_data` table. It is specified to execute `FOR EACH ROW`, meaning that the associated trigger function will be invoked once for every row that is being inserted into the `demographic_data` table. The trigger executes the `validate_demographic_year()` function, which, as described above, modifies the `year` column of the row being inserted based on the `last_updated` column before the actual insertion takes place.",
    "original_summary": "Create a BEFORE INSERT trigger on the demographic_data table. For each new row, set the year column to the year extracted (as text) from the last_updated timestamp column.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the demographic_data table so that before any new entries go in, it takes the last_updated timestamp and pulls out something like the year part, putting that text into the year field for the row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function update_portfolio_name that modifies the NEW.portfolio_name column by applying the LOWER function to it before returning the NEW record. Second, define the trigger lowercase_portfolio_name on table portfolio that fires BEFORE INSERT OR UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_portfolio_name() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.portfolio_name := LOWER(NEW.portfolio_name);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER lowercase_portfolio_name\nBEFORE INSERT OR UPDATE ON portfolio\nFOR EACH ROW EXECUTE FUNCTION update_portfolio_name();",
    "database_name": "financial_market_data_analysis_404480",
    "tables": [
      "users",
      "portfolio",
      "portfolio_positions",
      "instruments",
      "market_data",
      "alerts"
    ],
    "call_sqls": [
      "INSERT INTO portfolio (portfolio_id, user_id, portfolio_name, creation_date) VALUES (2, 0, 'My New Portfolio', '2023-01-01');",
      "INSERT INTO portfolio (portfolio_id, user_id, portfolio_name, creation_date) VALUES (3, 1, 'INVESTMENT PORTFOLIO', '2023-02-15');",
      "UPDATE portfolio SET portfolio_name = 'Updated Portfolio Name' WHERE portfolio_id = 0;",
      "INSERT INTO portfolio (portfolio_id, user_id, portfolio_name, creation_date) VALUES (4, 0, 'Retirement Savings', '2023-03-10');",
      "UPDATE portfolio SET portfolio_name = 'LONG TERM HOLDINGS' WHERE portfolio_id = 1;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named lowercase_portfolio_name that fires BEFORE INSERT or UPDATE on the portfolio table for each row, converting the portfolio_name to lowercase before saving.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called update_portfolio_name that runs before inserting or updating rows in the portfolio table, ensuring the portfolio_name is converted to lowercase, and returns the updated row.",
    "id": 5,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function update_portfolio_name that modifies the NEW.portfolio_name column by applying the LOWER function to it before returning the NEW record. Second, define the trigger lowercase_portfolio_name on table portfolio that fires BEFORE INSERT OR UPDATE and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that automatically converts the portfolio_name column to lowercase for any new or updated row in the portfolio table. The function, named update_portfolio_name, is defined to return a trigger and is written in the PLpgSQL language. It operates by taking the NEW record, which represents the row being inserted or updated, and modifies the portfolio_name field by applying the LOWER() function, which transforms all characters in the string to their lowercase equivalents. The function then returns the modified NEW record. This function is associated with a trigger named lowercase_portfolio_name, which is set to activate before any INSERT or UPDATE operation on the portfolio table. The trigger is defined to execute the update_portfolio_name function for each row that is being inserted or updated, ensuring that the portfolio_name is consistently stored in lowercase format regardless of the input case.",
    "original_summary": "Create a trigger function named update_portfolio_name that fires BEFORE INSERT or UPDATE on the portfolio table for each row. Set NEW.portfolio_name to LOWER(NEW.portfolio_name). Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger function called update_portfolio_name that runs before adding or changing entries in the portfolio table. Make it so the portfolio name gets changed to a lowercase version somehow. Just have it give back the updated row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_forecasting_model_accuracy` that updates the `forecasting_models` table by setting the `accuracy_score` column for the row where `model_id` matches `NEW.model_id` to the result of a scalar subquery that calculates the average value of the `temperature` column from the `weather_data` table for all rows where `model_id` equals `NEW.model_id`.\nSecond, define the trigger `trg_update_forecasting_model_accuracy` on table `weather_data` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_forecasting_model_accuracy() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE forecasting_models SET accuracy_score = (SELECT AVG(temperature) FROM weather_data WHERE model_id = NEW.model_id) WHERE model_id = NEW.model_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_forecasting_model_accuracy\n    AFTER INSERT ON weather_data\n    FOR EACH ROW\n    EXECUTE FUNCTION update_forecasting_model_accuracy();",
    "database_name": "meteorological_data_collection_and_analysis_823099",
    "tables": [
      "access_logs",
      "forecasting_models",
      "monitoring_points",
      "users",
      "weather_data"
    ],
    "call_sqls": [
      "INSERT INTO weather_data (point_id, available_date, prediction_date, wind_speed_100m, wind_direction_100m, temperature, air_density, pressure, precipitation, wind_gust, radiation, wind_speed, wind_direction, humidity, cloud_cover, visibility, dew_point, model_id, data_source) VALUES (0, '2023-01-01', '2023-01-01 12:00:00', 5.0, 180.0, 10.0, 1.2, 1000.0, 0.0, 10.0, 0.0, 4.0, 170.0, 70.0, 20.0, 10000.0, 5.0, 0, 'sensor');",
      "INSERT INTO weather_data (point_id, available_date, prediction_date, wind_speed_100m, wind_direction_100m, temperature, air_density, pressure, precipitation, wind_gust, radiation, wind_speed, wind_direction, humidity, cloud_cover, visibility, dew_point, model_id, data_source) VALUES (1, '2023-01-02', '2023-01-02 13:00:00', 6.0, 190.0, 12.0, 1.1, 990.0, 0.1, 11.0, 10.0, 5.0, 180.0, 75.0, 30.0, 9000.0, 6.0, 1, 'sensor');",
      "INSERT INTO weather_data (point_id, available_date, prediction_date, wind_speed_100m, wind_direction_100m, temperature, air_density, pressure, precipitation, wind_gust, radiation, wind_speed, wind_direction, humidity, cloud_cover, visibility, dew_point, model_id, data_source) VALUES (0, '2023-01-03', '2023-01-03 14:00:00', 7.0, 200.0, 15.0, 1.3, 1010.0, 0.0, 12.0, 20.0, 6.0, 190.0, 80.0, 40.0, 8000.0, 7.0, 0, 'sensor');",
      "INSERT INTO weather_data (point_id, available_date, prediction_date, wind_speed_100m, wind_direction_100m, temperature, air_density, pressure, precipitation, wind_gust, radiation, wind_speed, wind_direction, humidity, cloud_cover, visibility, dew_point, model_id, data_source) VALUES (1, '2023-01-04', '2023-01-04 15:00:00', 8.0, 210.0, 18.0, 1.0, 980.0, 0.2, 13.0, 30.0, 7.0, 200.0, 85.0, 50.0, 7000.0, 8.0, 1, 'sensor');",
      "INSERT INTO weather_data (point_id, available_date, prediction_date, wind_speed_100m, wind_direction_100m, temperature, air_density, pressure, precipitation, wind_gust, radiation, wind_speed, wind_direction, humidity, cloud_cover, visibility, dew_point, model_id, data_source) VALUES (0, '2023-01-05', '2023-01-05 16:00:00', 9.0, 220.0, 20.0, 1.25, 1005.0, 0.0, 14.0, 40.0, 8.0, 210.0, 90.0, 60.0, 6000.0, 9.0, 0, 'sensor');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_forecasting_model_accuracy that fires AFTER INSERT on the weather_data table for each new row, updating the forecasting_models table by setting the accuracy_score to the average temperature from the weather_data table for all rows with the same model_id as the newly inserted row, specifically for the forecasting model row where model_id matches the NEW.model_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_update_forecasting_model_accuracy that runs after each new row is inserted into the weather_data table, invoking the update_forecasting_model_accuracy function to update the forecasting_models table by setting the accuracy_score to the average temperature from the weather_data table for records matching the inserted row's model_id, specifically updating the row in forecasting_models where model_id equals the new model_id from the insert.",
    "id": 6,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_forecasting_model_accuracy` that updates the `forecasting_models` table by setting the `accuracy_score` column for the row where `model_id` matches `NEW.model_id` to the result of a scalar subquery that calculates the average value of the `temperature` column from the `weather_data` table for all rows where `model_id` equals `NEW.model_id`.\nSecond, define the trigger `trg_update_forecasting_model_accuracy` on table `weather_data` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_forecasting_model_accuracy that is executed automatically after every INSERT operation on the weather_data table for each new row, which takes no explicit parameters but has access to the special NEW record variable representing the newly inserted row, and within its body performs an UPDATE operation on the forecasting_models table, specifically setting the accuracy_score column for the row where the model_id matches the NEW.model_id value from the trigger context to the result of a scalar subquery that calculates the average value of the temperature column from the weather_data table by selecting all rows where the model_id column equals the same NEW.model_id value, thereby recalculating and updating the average temperature as the accuracy score for the corresponding forecasting model each time a new weather data record is added.",
    "original_summary": "Create an AFTER INSERT trigger on the `weather_data` table that runs FOR EACH ROW. It calls a trigger function `update_forecasting_model_accuracy` that updates the `forecasting_models` table. It sets `accuracy_score` to the average `temperature` from `weather_data` for rows where `model_id` equals NEW.model_id, but only for the forecasting model row where `model_id` matches NEW.model_id.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER INSERT trigger to be applied to the `weather_data` table, which shall execute FOR EACH ROW. This trigger must invoke the function `update_forecasting_model_accuracy`. The function's operation is to update the `forecasting_models` table by setting the `accuracy_score` column to the computed average `temperature` from the `weather_data` table, specifically for those records where the `model_id` corresponds to the NEW.model_id value. This update is to be performed exclusively on the row within the `forecasting_models` table whose `model_id` matches the NEW.model_id from the triggering insert operation."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `create_initial_performance` that inserts a row into the `performances` table using values from the `NEW` record of the `versions` table. The inserted values are: `performance_id` as `NEW.version_id + 2000`, `model_id` as `NEW.model_id`, `version_id` as `NEW.version_id`, `cost` as `1.0`, `rmse` as `1.0`, and `evaluation_date` as `NEW.version_date`. The function must then return `NEW`.\nSecond, define the trigger `trg_create_initial_performance` on table `versions` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION create_initial_performance() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO performances (performance_id, model_id, version_id, cost, rmse, evaluation_date) VALUES (NEW.version_id + 2000, NEW.model_id, NEW.version_id, 1.0, 1.0, NEW.version_date);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_create_initial_performance\n    AFTER INSERT ON versions\n    FOR EACH ROW\n    EXECUTE FUNCTION create_initial_performance();",
    "database_name": "machine_learning_model_performance_metrics_773034",
    "tables": [
      "models",
      "versions",
      "metric_values",
      "performances"
    ],
    "call_sqls": [
      "INSERT INTO versions (version_id, model_id, version_number, version_date, version_status, version_description, created_by, last_updated_by) VALUES (100, 5, 1, '2024-05-01', 'draft', 'Initial test version', 1, 1);",
      "INSERT INTO versions (version_id, model_id, version_number, version_date, version_status, version_description, created_by, last_updated_by) VALUES (101, 5, 2, '2024-05-02', 'released', 'Updated model', 1, 1);",
      "INSERT INTO versions (version_id, model_id, version_number, version_date, version_status, version_description, created_by, last_updated_by) VALUES (102, 6, 1, '2024-05-03', 'draft', 'New model version', 2, 2);",
      "INSERT INTO versions (version_id, model_id, version_number, version_date, version_status, version_description, created_by, last_updated_by) VALUES (103, 7, 1, '2024-05-04', 'released', 'Production release', 3, 3);",
      "INSERT INTO versions (version_id, model_id, version_number, version_date, version_status, version_description, created_by, last_updated_by) VALUES (104, 8, 3, '2024-05-05', 'draft', 'Bug fix version', 1, 1);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named create_initial_performance that, after each new row is inserted into the versions table, automatically adds a corresponding record to the performances table, setting performance_id to the new version_id plus 2000, using the new model_id and version_id, assigning default values of 1.0 for both cost and rmse, and setting evaluation_date to the new version_date.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called create_initial_performance that runs after each row is inserted into the versions table, inserting a new row into the performances table where performance_id is set to the NEW.version_id plus 2000, model_id and version_id are taken from the NEW record, cost and rmse are both set to 1.0, and evaluation_date is set to NEW.version_date, then returning NEW.",
    "id": 7,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named `create_initial_performance` in the `machine_learning_model_performance_metrics_773034` database. This function is defined to return a `TRIGGER` type and is executed after each row insertion into the `versions` table. The function declares no explicit variables; it uses the implicit `NEW` record variable representing the newly inserted row in the `versions` table. The core operation is an `INSERT` statement into the `performances` table. The `INSERT` statement populates specific columns in the `performances` table with values derived from the `NEW` row and constant values. The `performance_id` column is set to the value of `NEW.version_id` plus the integer `2000`. The `model_id` column is set directly to the value of `NEW.model_id`. The `version_id` column is set directly to the value of `NEW.version_id`. The `cost` column is set to the constant real value `1.0`. The `rmse` column is set to the constant real value `1.0`. The `evaluation_date` column is set to the value of `NEW.version_date`. All other columns in the `performances` table (`penalty`, `kappa`, `rho`, `v0`, `vbar`, `xi`, `lambda`, `mu_y`, `sigma_y`, `notes`) are not specified in the `INSERT` statement and will therefore be set to their default values (likely `NULL` if no default is defined). After performing the `INSERT`, the function returns the `NEW` row to allow the original `INSERT` operation on the `versions` table to proceed. Second, define a trigger named `create_initial_performance` on the `versions` table. This trigger is configured to fire `AFTER INSERT` on the `versions` table `FOR EACH ROW`. The trigger executes the function `create_initial_performance()`.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `create_initial_performance` that is designed to be executed automatically after an `INSERT` operation on the `versions` table. This function does not accept any explicit input parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. Upon execution, the function performs a single `INSERT` operation into the `performances` table. The `performance_id` column in the `performances` table is populated with a value derived by adding the integer `2000` to the `version_id` column from the `NEW` record of the `versions` table (i.e., `NEW.version_id + 2000`). The `model_id` column in the `performances` table is populated directly with the value from the `model_id` column of the `NEW` record from the `versions` table (i.e., `NEW.model_id`). The `version_id` column in the `performances` table is populated directly with the value from the `version_id` column of the `NEW` record from the `versions` table (i.e., `NEW.version_id`). The `cost` column in the `performances` table is populated with the static numeric value `1.0`. The `rmse` column in the `performances` table is populated with the static numeric value `1.0`. The `evaluation_date` column in the `performances` table is populated directly with the value from the `version_date` column of the `NEW` record from the `versions` table (i.e., `NEW.version_date`). After the `INSERT` operation is completed, the function returns the `NEW` record, which represents the newly inserted row in the `versions` table, allowing the original `INSERT` operation on `versions` to proceed normally. This trigger function is associated with a trigger named `trg_create_initial_performance`, which is configured to activate `AFTER INSERT` operations on the `versions` table, executing `FOR EACH ROW` that is inserted, and invoking the `create_initial_performance()` function.",
    "original_summary": "Create an AFTER INSERT row-level trigger function named create_initial_performance for the versions table. It inserts a row into the performances table using values from the NEW record (performance_id as NEW.version_id + 2000, model_id, version_id, cost=1.0, rmse=1.0, evaluation_date as NEW.version_date), then returns NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create an AFTER INSERT row-level trigger function called create_initial_performance for the versions table. This function should insert a row into the performances table, setting performance_id to NEW.version_id + 2000, using the NEW record's model_id and version_id, setting cost and rmse to 1.0, and setting evaluation_date to NEW.version_date. Finally, the function must return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `log_rating_activity` that declares a variable `next_activity_id` of type bigint, uses `COALESCE(MAX(activity_id), 0) + 1` from the `user_activity` table to determine its value, and inserts a new row into the `user_activity` table using `NEW.user_id`, `NEW.show_id`, `NEW.rating_date`, the literal 'rate', and 0.0. Second, define the trigger `log_rating_activity_trigger` on table `ratings` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_rating_activity() RETURNS TRIGGER AS $$\nDECLARE\n  next_activity_id bigint;\nBEGIN\n  -- Get the next activity_id safely\n  SELECT COALESCE(MAX(activity_id), 0) + 1 INTO next_activity_id FROM user_activity;\n  \n  -- Insert the activity record\n  INSERT INTO user_activity (activity_id, user_id, show_id, activity_date, activity_type, watch_time) \n  VALUES (next_activity_id, NEW.user_id, NEW.show_id, NEW.rating_date, 'rate', 0.0);\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_rating_activity_trigger\nAFTER INSERT ON ratings\nFOR EACH ROW EXECUTE FUNCTION log_rating_activity();",
    "database_name": "media_content_management_and_tracking",
    "tables": [
      "shows",
      "ratings",
      "users",
      "user_activity"
    ],
    "call_sqls": [
      "INSERT INTO ratings (rating_id, user_id, show_id, rating_date, rating_value, review) VALUES (100, 1, 0, '2024-01-15', 4.5, 'Very good movie.');",
      "INSERT INTO ratings (rating_id, user_id, show_id, rating_date, rating_value, review) VALUES (101, 0, 1, '2024-01-16', 5.0, 'Masterpiece!');",
      "INSERT INTO ratings (rating_id, user_id, show_id, rating_date, rating_value) VALUES (102, 1, 1, '2024-01-17', 3.0);",
      "INSERT INTO ratings (rating_id, user_id, show_id, rating_date, rating_value, review) VALUES (103, 0, 0, '2024-01-18', 4.0, 'Classic film.');",
      "INSERT INTO ratings (rating_id, user_id, show_id, rating_date, rating_value, review) VALUES (104, 1, 0, '2024-01-19', 2.5, 'Not my favorite.');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named log_rating_activity_trigger that fires AFTER INSERT on the ratings table, and for each new rating, inserts a corresponding activity record into the user_activity table. The activity_id should be set to one more than the highest existing activity_id in user_activity, using the new rating's user_id, show_id, and rating_date for the user_id, show_id, and activity_date respectively, setting activity_type to 'rate' and watch_time to 0.0.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called log_rating_activity_trigger that runs AFTER INSERT on the ratings table, and for each new row, inserts a corresponding record into the user_activity table, setting activity_id to the maximum existing activity_id plus one, populating user_id, show_id, and activity_date from the new rating, with activity_type as 'rate' and watch_time as 0.0, and returns the NEW row.",
    "id": 8,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `log_rating_activity` that declares a variable `next_activity_id` of type bigint, uses `COALESCE(MAX(activity_id), 0) + 1` from the `user_activity` table to determine its value, and inserts a new row into the `user_activity` table using `NEW.user_id`, `NEW.show_id`, `NEW.rating_date`, the literal 'rate', and 0.0. Second, define the trigger `log_rating_activity_trigger` on table `ratings` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL function named log_rating_activity that is designed to be executed as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to be triggered after an insert operation on the ratings table. The function begins by declaring a variable named next_activity_id of type bigint, which will be used to store the next available activity identifier. The function then performs a SELECT operation using the COALESCE function to safely determine the maximum value of the activity_id column from the user_activity table, defaulting to 0 if no records exist, and increments this value by 1 to generate the next_activity_id. Subsequently, the function executes an INSERT operation into the user_activity table, populating the activity_id column with the calculated next_activity_id, the user_id column with the NEW.user_id value from the inserted row in the ratings table, the show_id column with the NEW.show_id value, the activity_date column with the NEW.rating_date value, the activity_type column with the string 'rate', and the watch_time column with the value 0.0. Finally, the function returns the NEW record, which represents the row that was inserted into the ratings table. The function is associated with a trigger named log_rating_activity_trigger, which is defined to execute this function after each row is inserted into the ratings table.",
    "original_summary": "Create an AFTER INSERT trigger function for the ratings table. For each new row, insert a corresponding record into the user_activity table. The activity_id should be the maximum existing id plus one. Populate user_id, show_id, activity_date from the new rating, set activity_type to 'rate', and watch_time to 0.0. Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER INSERT trigger function for the ratings table that, for each new row, inserts a corresponding record into the user_activity table? The activity_id should be set to the maximum existing id plus one. The user_id, show_id, and activity_date should be populated from the new rating, with activity_type set to 'rate' and watch_time set to 0.0. The function should return the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_maintenance_status_on_insert` that, for each new row, compares its `next_maintenance_date` column to the current date string formatted as 'YYYY-MM-DD' using `TO_CHAR(NOW(), 'YYYY-MM-DD')`. If the `next_maintenance_date` is less than or equal to this current date string, the function sets the new row's `maintenance_status` column to the string 'Due'. The function must then return the `NEW` row record.\nSecond, define the trigger `maintenance_status_trigger` on table `bikes` that fires `BEFORE` `INSERT` for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_maintenance_status_on_insert() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.next_maintenance_date <= TO_CHAR(NOW(), 'YYYY-MM-DD') THEN\n    NEW.maintenance_status := 'Due';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER maintenance_status_trigger\nBEFORE INSERT ON bikes\nFOR EACH ROW\nEXECUTE FUNCTION update_maintenance_status_on_insert();",
    "database_name": "bike_sharing_service_and_user_trip_data_management",
    "tables": [
      "bikes",
      "stations"
    ],
    "call_sqls": [
      "INSERT INTO bikes (bike_id, bike_number, station_id, availability, last_maintenance_date, next_maintenance_date, maintenance_status) VALUES (2, 700, 0, 1, '2023-08-10', '2023-09-01', 'Good');",
      "INSERT INTO bikes (bike_id, bike_number, station_id, availability, last_maintenance_date, next_maintenance_date, maintenance_status) VALUES (3, 701, 0, 1, '2023-08-15', '2023-09-10', 'Good');",
      "INSERT INTO bikes (bike_id, bike_number, station_id, availability, last_maintenance_date, next_maintenance_date, maintenance_status) VALUES (4, 702, 0, 1, '2023-08-20', '2023-09-05', 'Good');",
      "INSERT INTO bikes (bike_id, bike_number, station_id, availability, last_maintenance_date, next_maintenance_date, maintenance_status) VALUES (5, 703, 0, 1, '2023-08-25', '2023-09-20', 'Good');",
      "INSERT INTO bikes (bike_id, bike_number, station_id, availability, last_maintenance_date, next_maintenance_date, maintenance_status) VALUES (6, 704, 0, 1, '2023-08-30', '2023-09-25', 'Good');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named maintenance_status_trigger that runs BEFORE INSERT on the bikes table and, for each new row, checks if the next_maintenance_date is on or before today's date; if so, sets the maintenance_status to 'Due'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called maintenance_status_trigger that, before inserting a record into the bikes table, sets the maintenance_status to 'Due' if the inserted next_maintenance_date is on or before the current date.",
    "id": 9,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_maintenance_status_on_insert`. This function is designed to be executed as a `BEFORE INSERT` trigger on the `bikes` table. It does not accept any explicit parameters but implicitly receives the special `NEW` record, which contains the values of the row that is about to be inserted. The function's purpose is to conditionally set the `maintenance_status` field of the new row based on a comparison between the `next_maintenance_date` value being inserted and the current system date.\n\nInside the function, a conditional check is performed using an `IF` statement. The condition evaluates whether the `NEW.next_maintenance_date` (which is a text column) is less than or equal to the current date. Since `next_maintenance_date` is stored as text, the comparison requires a type conversion. The expression `NEW.next_maintenance_date::date <= CURRENT_DATE` is used. This converts the text value in `NEW.next_maintenance_date` to a `date` data type and compares it to the system's current date (`CURRENT_DATE`). If this condition is true, meaning the provided `next_maintenance_date` is today or in the past, then the `maintenance_status` field of the `NEW` record is set to the string literal `'Due'`. This assignment modifies the row data before it is written to the `bikes` table. If the condition is false (i.e., the `next_maintenance_date` is in the future), no action is taken, and the `maintenance_status` retains whatever value was originally provided in the `INSERT` statement. The function concludes by returning the modified `NEW` record. This return is mandatory for `BEFORE` triggers to pass the potentially altered row data to the actual `INSERT` operation.\n\nSecond, define the trigger `maintenance_status_trigger` on the `bikes` table. This trigger is configured to fire `BEFORE INSERT` on the `bikes` table. It is specified to execute `FOR EACH ROW`, meaning the `update_maintenance_status_on_insert()` function will be invoked once for every individual row that is inserted. The trigger is linked to the function via the clause `EXECUTE FUNCTION update_maintenance_status_on_insert()`.",
    "original_ir": "Write a PostgreSQL trigger function named update_maintenance_status_on_insert that returns a trigger and is executed automatically by a trigger named maintenance_status_trigger before each row is inserted into the bikes table; this function compares the value of the new row's next_maintenance_date column to the current date, obtained by calling the NOW() function and formatting its result to a 'YYYY-MM-DD' string using the TO_CHAR() function, and if the next_maintenance_date is less than or equal to the current date string, the function sets the new row's maintenance_status column to the string literal 'Due'; the function then returns the modified NEW row record to the database engine for the subsequent insert operation.",
    "original_summary": "Create a BEFORE INSERT trigger function for the bikes table. If the new row's next_maintenance_date is on or before today's date, set its maintenance_status to 'Due'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Define a BEFORE INSERT trigger on the bikes table that sets the maintenance_status to 'Due' whenever the inserted next_maintenance_date is on or before the current date."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_user_last_updated` that assigns the current timestamp, cast to text, to the `last_updated` column of the `NEW` row variable. Second, define the trigger `trg_update_user_last_updated` on table `users` that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_user_last_updated() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.last_updated = CURRENT_TIMESTAMP::text;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_user_last_updated\n    BEFORE UPDATE ON users\n    FOR EACH ROW\n    EXECUTE FUNCTION update_user_last_updated();",
    "database_name": "demographic_and_socioeconomic_data_analysis_428440",
    "tables": [
      "data_sets",
      "data_sources",
      "data_versions",
      "individuals",
      "research_teams",
      "users",
      "user_roles"
    ],
    "call_sqls": [
      "UPDATE users SET username = 'researcher_updated' WHERE user_id = 0;",
      "UPDATE users SET email = 'new_email@example.com' WHERE user_id = 1;",
      "UPDATE users SET password = 'new_password' WHERE username = 'researcher1';",
      "UPDATE users SET role_id = 0 WHERE user_id = 0;",
      "UPDATE users SET username = 'data_analyst_updated', email = 'data_analyst_new@example.com' WHERE user_id = 1;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_user_last_updated that, before updating any row in the users table, automatically sets the NEW.last_updated column to the current timestamp as text and returns the modified NEW record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_update_user_last_updated that runs before updates on the users table, updating the last_updated field to the current date and time formatted as text for any changed rows, and returns the entire updated record.",
    "id": 10,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_user_last_updated` that assigns the current timestamp, cast to text, to the `last_updated` column of the `NEW` row variable. Second, define the trigger `trg_update_user_last_updated` on table `users` that fires BEFORE UPDATE and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_user_last_updated that returns a trigger and is invoked by a trigger named trg_update_user_last_updated, which is defined to execute before any update operation on the users table for each individual row being modified; the function's logic assigns the current date and time, obtained by calling the CURRENT_TIMESTAMP function and explicitly casting its result to the text data type, to the last_updated column of the NEW row variable representing the incoming row data, and then returns this modified NEW row record to the triggering update statement.",
    "original_summary": "Create a BEFORE UPDATE trigger function named update_user_last_updated for the users table. For each updated row, set the NEW.last_updated column to CURRENT_TIMESTAMP::text. Return the modified NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger that runs before updates on the users table, maybe call it something like update_user_last_updated. For any rows that get changed, it should kind of update the last_updated field to be the current date and time, formatted as text. Make sure the whole new record is sent back afterward."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_freedom_score` that declares a local variable `avg_trust` of type REAL, calculates the average of the `trust_in_government` column from the `freedom_data` table for rows matching the NEW record's `country_id` and `year` but excluding the current record by `freedom_id`, uses the COALESCE function to default the result to 0, and then adds this `avg_trust` value to the NEW record's `freedom_score`.\nSecond, define the trigger `trg_update_freedom_score` on table `freedom_data` that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_freedom_score() RETURNS TRIGGER AS $$\nDECLARE\n  avg_trust REAL;\nBEGIN\n  -- Calculate average trust in government for the same country and year, excluding current record\n  SELECT COALESCE(AVG(trust_in_government), 0) INTO avg_trust\n  FROM freedom_data \n  WHERE country_id = NEW.country_id \n    AND year = NEW.year\n    AND freedom_id != NEW.freedom_id;\n  \n  -- Modify the freedom_score directly in the NEW record\n  NEW.freedom_score = NEW.freedom_score + avg_trust;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_freedom_score\nBEFORE UPDATE ON freedom_data\nFOR EACH ROW EXECUTE FUNCTION update_freedom_score();",
    "database_name": "global_happiness_and_economic_data_analysis",
    "tables": [
      "countries",
      "economic_data",
      "freedom_data",
      "generosity_data",
      "happiness_data",
      "health_data",
      "social_data",
      "data_sources",
      "data_versions"
    ],
    "call_sqls": [
      "UPDATE freedom_data SET freedom_score = 0.7, trust_in_government = 0.5 WHERE freedom_id = 0;",
      "UPDATE freedom_data SET freedom_score = 0.8, trust_in_government = 0.6 WHERE freedom_id = 1;",
      "UPDATE freedom_data SET trust_in_government = 0.45 WHERE freedom_id = 0;",
      "UPDATE freedom_data SET freedom_score = 0.75 WHERE freedom_id = 1;",
      "UPDATE freedom_data SET freedom_score = 0.68, trust_in_government = 0.55 WHERE freedom_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `update_freedom_score` that fires BEFORE UPDATE on the `freedom_data` table for each row, adding to the NEW `freedom_score` the average `trust_in_government` from other rows in the same `country_id` and `year` (excluding the current row), treating any NULL average as 0, and returning the modified NEW record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called `update_freedom_score` that runs BEFORE UPDATE on the `freedom_data` table for each row, calculating the average `trust_in_government` from other rows with the same `country_id` and `year` (excluding the current row), treating any NULL average as 0, adding this average to the NEW `freedom_score`, and returning the updated NEW record.",
    "id": 11,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named update_freedom_score that is designed to be executed as a trigger function. This function is triggered before an update operation on the freedom_data table for each row. The function takes no explicit parameters but operates on the NEW and OLD pseudo-records, which represent the row being updated after and before the update, respectively. The NEW pseudo-record contains at least the columns freedom_score, country_id, year, and trust_in_government, all of which are of appropriate data types as defined in the schema. The OLD pseudo-record contains the same columns representing the row's state before the update.\n\nThe function declares a local variable named avg_trust of type real to store the calculated average trust_in_government value. The function performs a SELECT operation on the freedom_data table to compute the average of the trust_in_government column. This SELECT uses an aggregate AVG function applied to trust_in_government, filtering rows where the country_id matches the NEW.country_id and the year matches the NEW.year, and excluding the current row being updated by ensuring the freedom_id does not equal the OLD.freedom_id. The result of this SELECT is assigned to the avg_trust variable using an INTO clause.\n\nThe function includes business logic to handle cases where the average calculation returns NULL, such as when no other rows exist for the same country_id and year. This is done using a COALESCE function, which substitutes any NULL value in avg_trust with 0. After obtaining the average (or 0 if NULL), the function updates the NEW.freedom_score by adding this avg_trust value to the existing NEW.freedom_score value. This operation modifies the NEW pseudo-record in-place, specifically setting NEW.freedom_score to NEW.freedom_score + avg_trust.\n\nThe function concludes by returning the modified NEW pseudo-record, which is standard practice for BEFORE trigger functions to allow the update operation to proceed with the adjusted data. Second, define the trigger named update_freedom_score on the freedom_data table. This trigger is set to execute the update_freedom_score function before each row update on the freedom_data table, ensuring that the freedom_score is recalculated based on the average trust_in_government from other rows with the same country_id and year before the update is applied to the database.",
    "original_ir": "Write a PostgreSQL trigger function named update_freedom_score that is executed automatically by a trigger named trg_update_freedom_score before any update operation on the freedom_data table for each individual row being updated; this function declares a local variable avg_trust of type REAL; within the function, it first performs a SELECT query on the freedom_data table to compute the average value of the trust_in_government column for all rows where the country_id column matches the NEW.country_id value from the incoming update, the year column matches the NEW.year value, and the freedom_id column does not equal the NEW.freedom_id value (thereby excluding the current record being updated from the average calculation), and it uses the COALESCE function to return 0 if the average calculation results in NULL, storing this result into the avg_trust variable; then, the function modifies the freedom_score column of the NEW record (the in-memory row data for the update) by adding the calculated avg_trust value to the existing NEW.freedom_score value; finally, the function returns the modified NEW record.",
    "original_summary": "Create a PostgreSQL trigger function named `update_freedom_score` that fires BEFORE UPDATE on the `freedom_data` table FOR EACH ROW. Calculate the average `trust_in_government` from other rows in the same `country_id` and `year`, excluding the current row. If the average is NULL, treat it as 0. Add this average to the NEW `freedom_score`. Return the modified NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a PostgreSQL trigger function called `update_freedom_score` that executes BEFORE UPDATE on the `freedom_data` table FOR EACH ROW? It should calculate the average `trust_in_government` from other rows sharing the same `country_id` and `year`, excluding the current row. If this average is NULL, it should be treated as 0. This calculated average must then be added to the NEW `freedom_score`. Finally, how do I return the modified NEW record?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_game_outcome` that checks if `NEW.stat_id` is NULL and, if so, assigns a new value using `COALESCE(MAX(stat_id), 0) + 1` from the `player_game_stats` table. It then updates the `game_outcome` column in the `games` table to 'Win' if `NEW.team_score` > `NEW.opponent_score` or to 'Loss' otherwise, where `game_id` matches `NEW.game_id`.\nSecond, define the trigger `trg_update_game_outcome` on table `player_game_stats` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_game_outcome() RETURNS TRIGGER AS $$\nBEGIN\n  -- Ensure stat_id is not NULL for the player_game_stats insert\n  IF NEW.stat_id IS NULL THEN\n    SELECT COALESCE(MAX(stat_id), 0) + 1 INTO NEW.stat_id FROM player_game_stats;\n  END IF;\n  \n  -- Update game outcome in games table\n  IF NEW.team_score > NEW.opponent_score THEN\n    UPDATE games SET game_outcome = 'Win' WHERE game_id = NEW.game_id;\n  ELSE\n    UPDATE games SET game_outcome = 'Loss' WHERE game_id = NEW.game_id;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_game_outcome\nBEFORE INSERT ON player_game_stats\nFOR EACH ROW EXECUTE FUNCTION update_game_outcome();",
    "database_name": "basketball_player_performance_and_team_statistics_758396",
    "tables": [
      "games",
      "player_game_stats",
      "players",
      "teams",
      "team_season_stats"
    ],
    "call_sqls": [
      "INSERT INTO player_game_stats (game_id, player_id, team_score, opponent_score, mp, pts, reb, ast) VALUES (1, '0', 105, 95, 32.5, 25, 8, 6);",
      "INSERT INTO player_game_stats (game_id, player_id, team_score, opponent_score, fgm, fga, fg3m, fg3a) VALUES (2, '1', 98, 102, 8, 15, 2, 5);",
      "INSERT INTO player_game_stats (game_id, player_id, team_score, opponent_score, stl, blk, tov, pf) VALUES (1, '1', 105, 95, 2, 1, 3, 4);",
      "INSERT INTO player_game_stats (game_id, player_id, team_score, opponent_score, plus_minus, ts_pct, efg_pct) VALUES (2, '0', 98, 102, -4.0, 0.55, 0.52);",
      "INSERT INTO player_game_stats (game_id, player_id, team_score, opponent_score, stat_id, off_rtg, def_rtg, bpm) VALUES (3, '0', 110, 107, 100, 115.2, 108.5, 5.7);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_game_outcome that runs before each insert into the player_game_stats table to automatically assign a stat_id if it is missing by taking the next available number from existing records, and updates the games table by setting the game_outcome to 'Win' when the inserted team_score is greater than opponent_score, or 'Loss' otherwise, based on the matching game_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called update_game_outcome that runs before each insert into the player_game_stats table. If the inserted stat_id is missing, assign it by taking the highest existing stat_id from player_game_stats (or 0 if none exist) and adding 1. Then, update the games table by setting game_outcome to 'Win' if the new team_score is greater than opponent_score, otherwise set it to 'Loss', but only for the row where game_id matches the inserted game_id. Finally, return the new record.",
    "id": 12,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_game_outcome` that checks if `NEW.stat_id` is NULL and, if so, assigns a new value using `COALESCE(MAX(stat_id), 0) + 1` from the `player_game_stats` table. It then updates the `game_outcome` column in the `games` table to 'Win' if `NEW.team_score` > `NEW.opponent_score` or to 'Loss' otherwise, where `game_id` matches `NEW.game_id`.\nSecond, define the trigger `trg_update_game_outcome` on table `player_game_stats` that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PL/pgSQL function named `update_game_outcome` that is designed to be executed as a trigger. This function takes no explicit parameters but operates on the `NEW` pseudo-record, which represents the new row being inserted into the `player_game_stats` table. The function first checks if the `stat_id` column in the `NEW` record is `NULL`. If `NEW.stat_id` is `NULL`, it calculates a new `stat_id` by selecting the maximum value of `stat_id` from the `player_game_stats` table, using `COALESCE` to treat a `NULL` result (meaning no existing `stat_id`s) as `0`, and then adding `1` to this result. This newly calculated value is then assigned to `NEW.stat_id`. Following this, the function proceeds to update the `game_outcome` column in the `games` table. It evaluates a conditional statement: if the value of `NEW.team_score` is greater than the value of `NEW.opponent_score`, it updates the `game_outcome` column to the string literal 'Win' for the row in the `games` table where the `game_id` column matches the value of `NEW.game_id`. Otherwise, if `NEW.team_score` is not greater than `NEW.opponent_score`, it updates the `game_outcome` column to the string literal 'Loss' for the row in the `games` table where the `game_id` column matches the value of `NEW.game_id`. Finally, the function returns the `NEW` record, which includes any modifications made to `NEW.stat_id`. This function is associated with a trigger named `trg_update_game_outcome`, which is configured to execute `BEFORE INSERT` operations on the `player_game_stats` table `FOR EACH ROW`.",
    "original_summary": "Create a BEFORE INSERT trigger function named update_game_outcome for the player_game_stats table. If NEW.stat_id is NULL, set it to COALESCE(MAX(stat_id), 0) + 1 from player_game_stats. Then, update the games table: set game_outcome to 'Win' if NEW.team_score > NEW.opponent_score, else 'Loss', where game_id matches NEW.game_id. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a BEFORE INSERT trigger function, meticulously named update_game_outcome, which will be applied to the player_game_stats table. In a detailed and careful process, if the incoming NEW.stat_id value is found to be NULL, the function must dynamically assign it by calculating the COALESCE of the maximum existing stat_id from the player_game_stats table and 0, then incrementing that result by 1. Subsequently, the function must proceed to update the games table in an elaborate manner: it should set the game_outcome field to the precise value of 'Win' only if the newly inserted NEW.team_score definitively exceeds the NEW.opponent_score; otherwise, it must be set to 'Loss'. This update must be scrupulously applied specifically where the game_id in the games table perfectly matches the NEW.game_id from the triggering insert. Finally, the function must return the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_user_last_login` that updates the `last_login_date` column to `CURRENT_DATE` in the `users` table for the row where the `user_id` matches the `NEW.user_id`.\nSecond, define the trigger `trg_users_after_update` on table `users` that fires `AFTER UPDATE OF email` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_user_last_login() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE users SET last_login_date = CURRENT_DATE WHERE user_id = NEW.user_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_users_after_update\nAFTER UPDATE OF email ON users\nFOR EACH ROW EXECUTE FUNCTION update_user_last_login();",
    "database_name": "climate_change_impact_analysis_and_emissions_tracking",
    "tables": [
      "climate_models",
      "emissions_data",
      "emissions_data_sources",
      "emissions_metrics",
      "gas_concentrations",
      "research_publications",
      "users"
    ],
    "call_sqls": [
      "UPDATE users SET email = 'alice.new@example.com' WHERE user_id = 1;",
      "UPDATE users SET email = 'bob.updated@example.org' WHERE user_id = 2;",
      "UPDATE users SET email = 'admin@climate.org' WHERE user_id = 3;",
      "UPDATE users SET email = 'researcher@institute.edu' WHERE user_id = 4;",
      "UPDATE users SET email = 'user5@domain.com' WHERE user_id = 5;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_users_after_update that fires AFTER UPDATE of the email column on the users table, updating the users table by setting the last_login_date to the current date for the row where user_id equals the NEW.user_id from the updated row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_users_after_update that, after an UPDATE operation on the email column in the users table, assigns the current date to the last_login_date field for the record where the user_id matches NEW.user_id.",
    "id": 13,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named `update_user_last_login` that is designed to be executed after an `UPDATE` operation on the `users` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the row being updated. In this specific case, since it's an `AFTER UPDATE` trigger, `NEW` refers to the updated row in the `users` table, and `OLD` refers to the row before the update. The function's primary purpose is to conditionally update the `last_login_date` column in the `users` table. Specifically, it performs an `UPDATE` operation on the `users` table. For each row in the `users` table, it sets the `last_login_date` column to the current date, obtained by calling the `CURRENT_DATE` function, which returns the current date as a text string in the format 'YYYY-MM-DD'. This update is conditional, applying only to rows where the `user_id` column in the `users` table matches the `user_id` value from the `NEW` record (i.e., the `user_id` of the row just updated in the `users` table). Additionally, the trigger function includes a condition to ensure that the update to `last_login_date` only occurs if the `email` column was actually changed during the `UPDATE` operation. This is implemented by checking if the `NEW.email` value is different from the `OLD.email` value. If the `email` column was not modified, the function does nothing and simply returns the `NEW` record. After performing this conditional update, the function returns the `NEW` record, which is standard practice for `AFTER` row-level triggers in PostgreSQL. This trigger function is then associated with the `users` table via a trigger named `trg_users_after_update`. This trigger is configured to execute `AFTER UPDATE` operations on the `users` table, and it is a `FOR EACH ROW` trigger, meaning the `update_user_last_login` function will be invoked once for every row that is updated in the `users` table. The trigger is further refined to fire only when the `email` column is updated, which is specified using a `WHEN` condition that checks if the `NEW.email` is distinct from the `OLD.email`.",
    "original_ir": "Write a PLpgSQL function that updates the last_login_date column in the users table to the current date for the row where the user_id matches the user_id of the newly updated row, and a trigger that activates this function after any update to the email column in the users table, executing the function for each row affected by the update.",
    "original_summary": "Create a PLpgSQL trigger function that updates the users table, setting last_login_date to the current date for the row where user_id equals NEW.user_id. Create a trigger that fires AFTER UPDATE of the email column on the users table to execute this function for each updated row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a PL/pgSQL trigger function designed to modify the users table by assigning the current date to the last_login_date field for the record whose user_id matches NEW.user_id. Subsequently, establish a trigger that is activated subsequent to an UPDATE operation on the email column within the users table, thereby invoking the aforementioned function for each row that has been altered."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `validate_user_access` that checks the `users` table for the `is_active` column value where the `user_id` matches the `NEW.user_id` from the `access_logs` table and, if that value is 0, sets the `NEW.access_type` column to 'denied'. Second, define the trigger `trg_validate_user_access` on table `access_logs` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_user_access() RETURNS TRIGGER AS $$\nBEGIN\n    IF (SELECT is_active FROM users WHERE user_id = NEW.user_id) = 0 THEN\n        NEW.access_type = 'denied';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_user_access\n    BEFORE INSERT ON access_logs\n    FOR EACH ROW\n    EXECUTE FUNCTION validate_user_access();",
    "database_name": "meteorological_data_collection_and_analysis_823099",
    "tables": [
      "access_logs",
      "forecasting_models",
      "monitoring_points",
      "users",
      "weather_data"
    ],
    "call_sqls": [
      "INSERT INTO access_logs (log_id, user_id, point_id, access_time, access_type, ip_address, user_agent, session_id, data_accessed) VALUES (100, 0, 1, '2024-01-15 14:30:00', 'view', '192.168.1.100', 'Mozilla/5.0', 'sess_abc123', 'temperature');",
      "INSERT INTO access_logs (log_id, user_id, point_id, access_time, access_type, ip_address, user_agent, session_id, data_accessed) VALUES (101, 1, 0, '2024-01-15 15:00:00', 'download', '192.168.1.101', 'Chrome/120.0', 'sess_def456', 'all_data');",
      "INSERT INTO access_logs (log_id, user_id, point_id, access_time, ip_address, user_agent, session_id, data_accessed) VALUES (102, 0, 1, '2024-01-16 09:15:00', '10.0.0.5', 'Safari/17.0', 'sess_ghi789', 'wind_speed');",
      "INSERT INTO access_logs (user_id, point_id, access_time, access_type, ip_address, user_agent, session_id, data_accessed) VALUES (1, 1, '2024-01-16 10:45:00', 'view', '192.168.2.50', 'Edge/120.0', 'sess_jkl012', 'humidity, pressure');",
      "INSERT INTO access_logs (log_id, user_id, point_id, access_time, access_type, ip_address, user_agent, session_id, data_accessed) VALUES (103, (SELECT user_id FROM users WHERE username='alice_j'), 0, '2024-01-16 11:30:00', 'view', '192.168.3.10', 'Firefox/122.0', 'sess_mno345', 'radiation');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_validate_user_access that executes BEFORE INSERT on the access_logs table for each row, which validates user access by checking if the user is active in the users table using the user_id; if the user is not active (is_active = 0), it sets the access_type in the new row to 'denied' and returns the modified NEW row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_validate_user_access that runs BEFORE INSERT on the access_logs table, and for each new row, checks if the user is active in the users table by calling the validate_user_access function; if the user is not active (where is_active = 0), it sets the access_type in the new row to 'denied' before returning the modified NEW row.",
    "id": 14,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `validate_user_access` that checks the `users` table for the `is_active` column value where the `user_id` matches the `NEW.user_id` from the `access_logs` table and, if that value is 0, sets the `NEW.access_type` column to 'denied'. Second, define the trigger `trg_validate_user_access` on table `access_logs` that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PL/pgSQL trigger that, before an insertion operation is performed on the `access_logs` table, executes a function named `validate_user_access` for each row being inserted. The `validate_user_access` function is defined to return a `TRIGGER` type and operates as follows: it first performs a `SELECT` operation on the `users` table to retrieve the value of the `is_active` column. This `SELECT` operation is conditioned by matching the `user_id` column in the `users` table with the `user_id` column of the `NEW` record (which represents the row currently being inserted into the `access_logs` table). If the retrieved `is_active` value is equal to `0`, then the `access_type` column of the `NEW` record is set to the string literal `'denied'`. Finally, the function returns the `NEW` record, potentially with its `access_type` modified, allowing the insertion into the `access_logs` table to proceed with the (possibly) altered row.",
    "original_summary": "Create a BEFORE INSERT trigger on the `access_logs` table that calls the `validate_user_access` function for each row. The function checks if the user is active in the `users` table. If the user is not active (`is_active = 0`), set the `access_type` in the new row to 'denied'. Return the modified NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a BEFORE INSERT trigger on the `access_logs` table that, for each new row, calls the `validate_user_access` function to check if the user is active in the `users` table, and if the user is not active (where `is_active = 0`), sets the `access_type` in the new row to 'denied' before returning the modified NEW row?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `archive_completed_order` that checks if the `NEW.status` is 'Completed' and, if true, deletes rows from the `order_items` table where `order_id` matches `NEW.order_id`.\nSecond, define the trigger `trg_archive_completed_order` on table `orders` that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_completed_order() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM order_items WHERE order_id = NEW.order_id AND NEW.status = 'Completed';\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_archive_completed_order\nAFTER UPDATE ON orders\nFOR EACH ROW EXECUTE FUNCTION archive_completed_order();",
    "database_name": "clothing_size_specifications_and_inventory_management_736487",
    "tables": [
      "clothing_items",
      "inventory",
      "order_items",
      "orders",
      "sizes"
    ],
    "call_sqls": [
      "UPDATE orders SET status = 'Completed' WHERE order_id = 1;",
      "UPDATE orders SET status = 'Completed', total_amount = '129.97' WHERE order_id = 2;",
      "UPDATE orders SET status = 'Completed' WHERE customer_id = 5 AND status = 'Shipped';",
      "UPDATE orders SET status = 'Completed' WHERE order_date < '2023-10-15';",
      "UPDATE orders SET status = 'Completed' WHERE order_id = 10 AND payment_method = 'Credit Card';"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named archive_completed_order that fires AFTER UPDATE on the ORDERS table for each row, and when the NEW.status is 'Completed', it deletes all related records from the ORDER_ITEMS table where order_id matches NEW.order_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called archive_completed_order that executes AFTER UPDATE on each row of the orders table. When the NEW.status is 'Completed', remove the corresponding entries from the order_items table where order_id matches NEW.order_id, and ensure the function returns NEW.",
    "id": 15,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named archive_completed_order with no explicit parameters, returning a trigger. The function operates on the implicit NEW record representing the updated row in the orders table. The function declares no local variables. The function's logic begins by checking if the NEW.status column value is exactly equal to the string 'Completed'. If this condition is true, the function performs a DELETE operation on the order_items table, targeting all rows where the order_id column matches the NEW.order_id value from the updated orders row. This operation removes all associated order items for that specific order. After the DELETE, the function proceeds to return the NEW record unchanged. If the condition is false (i.e., NEW.status is not 'Completed'), the function skips the DELETE and directly returns the NEW record. The function is defined to be executed after any UPDATE operation on the orders table for each row. Second, define the trigger named archive_completed_order on the orders table, specifying that it should execute the function archive_completed_order after each row is updated.",
    "original_ir": "Write a PLpgSQL trigger function that is invoked after an update operation on the orders table. This function, named archive_completed_order, is designed to execute for each row affected by the update. It takes no explicit parameters but operates on the implicit NEW record, which represents the current state of the row after the update. The function checks if the status column of the NEW record is set to 'Completed'. If this condition is met, it performs a delete operation on the order_items table, removing all rows where the order_id column matches the order_id of the NEW record. This effectively archives the order items associated with orders that have been marked as completed. The function then returns the NEW record, allowing the update operation on the orders table to proceed. The trigger associated with this function is named trg_archive_completed_order and is defined to execute the archive_completed_order function after any update on the orders table, ensuring that the archiving logic is applied to each updated row individually.",
    "original_summary": "Create a PLpgSQL trigger function named archive_completed_order that fires AFTER UPDATE on the orders table for each row. If the NEW.status is 'Completed', delete from the order_items table where order_id equals NEW.order_id. The function must return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Write a PLpgSQL trigger function called archive_completed_order that executes AFTER UPDATE on each row of the orders table. When the NEW.status is 'Completed', remove the corresponding entries from the order_items table where order_id matches NEW.order_id. Ensure the function returns NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function insert_widget_log that inserts a row into the widget_logs table, using NEW.widget_id for the widget_id column, the literal string 'INSERT' for the action column, and CURRENT_TIMESTAMP for the timestamp column, and returns the NEW record. Second, define the trigger trg_insert_widget_log on table dashboard_widgets that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE TABLE IF NOT EXISTS widget_logs (\n    log_id BIGSERIAL PRIMARY KEY,\n    widget_id BIGINT NOT NULL,\n    action TEXT NOT NULL,\n    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE OR REPLACE FUNCTION insert_widget_log() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO widget_logs (widget_id, action, timestamp) VALUES (NEW.widget_id, 'INSERT', CURRENT_TIMESTAMP);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_widget_log\n    AFTER INSERT ON dashboard_widgets\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_widget_log();",
    "database_name": "system_performance_monitoring_and_analysis_481541",
    "tables": [
      "dashboards",
      "dashboard_widgets"
    ],
    "call_sqls": [
      "INSERT INTO dashboard_widgets (widget_id, dashboard_id, widget_name, widget_type, widget_size, widget_position, widget_data_source) VALUES (100, 1, 'Network Traffic Chart', 'chart', 'large', 'top-center', 'network stats');",
      "INSERT INTO dashboard_widgets (widget_id, dashboard_id, widget_name, widget_type, widget_size, widget_position, widget_data_source) VALUES (101, 2, 'Error Log Table', 'table', 'medium', 'bottom-left', 'application logs');",
      "INSERT INTO dashboard_widgets (widget_id, dashboard_id, widget_name, widget_type, widget_size, widget_position, widget_data_source) VALUES (102, 1, 'Disk I/O Gauge', 'gauge', 'small', 'top-right', 'disk metrics');",
      "INSERT INTO dashboard_widgets (widget_id, dashboard_id, widget_name, widget_type, widget_size, widget_position, widget_data_source) VALUES (103, 3, 'User Activity Heatmap', 'chart', 'large', 'center', 'user events');",
      "INSERT INTO dashboard_widgets (widget_id, dashboard_id, widget_name, widget_type, widget_size, widget_position, widget_data_source) VALUES (104, 2, 'API Response Times', 'line_chart', 'medium', 'middle-right', 'api monitoring');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_insert_widget_log that, after each new row is inserted into the dashboard_widgets table, automatically logs the insertion by adding a record to the widget_logs table, capturing the widget_id from the new row, setting the action to 'INSERT', and recording the current timestamp.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_insert_widget_log that, after a new record is inserted into the dashboard_widgets table, automatically logs an entry into the widget_logs table. The log entry should include the widget's widget_id, mark the action as 'INSERT', and record the current timestamp. The trigger should return the new record.",
    "id": 16,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named insert_widget_log that is designed to be executed as a trigger function. This function does not take any explicit parameters but operates using the implicit NEW record variable provided by the trigger context, which contains the values of the row that was just inserted into the dashboard_widgets table. The function performs an INSERT operation into the widget_logs table, which is not listed in the schema but is implied to exist for logging purposes. The inserted row includes three columns: the widget_id column is populated with the value from NEW.widget_id, the action column is set to the literal string 'INSERT', and the timestamp column is set to the current timestamp obtained via the CURRENT_TIMESTAMP function. After performing the INSERT, the function returns the NEW record to allow further processing of the inserted row in the dashboard_widgets table. The function is written in the PL/pgSQL language. Second, define a trigger named trg_insert_widget_log on the dashboard_widgets table. This trigger is configured to fire AFTER each INSERT operation on the table and executes once for each row, ensuring that the insert_widget_log function is called individually for every new row inserted into the dashboard_widgets table, thereby logging the insertion event into the widget_logs table.",
    "original_ir": "Write a PostgreSQL database schema definition that first creates a table named widget_logs if it does not already exist, with a primary key column log_id of type BIGSERIAL, a non-nullable column widget_id of type BIGINT, a non-nullable column action of type TEXT, and a column timestamp of type TIMESTAMP WITH TIME ZONE that defaults to the CURRENT_TIMESTAMP value, then creates or replaces a PL/pgSQL function named insert_widget_log that takes no parameters and returns a TRIGGER type, whose body performs a single INSERT operation into the widget_logs table, specifying values for the widget_id column taken from the NEW record's widget_id field, a literal string 'INSERT' for the action column, and the CURRENT_TIMESTAMP value for the timestamp column, and returns the NEW record, and finally creates a trigger named trg_insert_widget_log that is configured to fire AFTER INSERT operations on the dashboard_widgets table, for each row affected by the INSERT, and executes the insert_widget_log function.",
    "original_summary": "Create a table widget_logs with columns log_id (BIGSERIAL PRIMARY KEY), widget_id (BIGINT NOT NULL), action (TEXT NOT NULL), and timestamp (TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP). Then create an AFTER INSERT trigger function insert_widget_log that logs inserts into dashboard_widgets by inserting a row into widget_logs with widget_id from NEW, action 'INSERT', and current timestamp. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a table for widget logs with the usual columns like a log id, widget id, action, and a timestamp. Then set up a trigger that, after something new is added to the dashboard widgets, puts a note in that log table. The note should have the widget's id, mark the action as an insert, and stamp it with the current time. Just have it return the new record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `trg_validate_data_source_active` that checks if a corresponding active record exists in the `data_sources` table. The function must use a `NOT EXISTS` condition with a subquery that selects `1` from `data_sources` where `data_source_id` matches `NEW.data_source_id` and where `data_collection_end_date` cast to `date` is greater than or equal to `CURRENT_DATE`. If no active source is found, the function must delete the row from the `demographic_data` table where `demographic_data_id` equals `NEW.demographic_data_id`. The function must end by returning `NEW`. Second, define the trigger `validate_data_source_active` on table `demographic_data` that fires `BEFORE INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_data_source_active() RETURNS TRIGGER AS $$\nBEGIN\nIF NOT EXISTS (SELECT 1 FROM data_sources WHERE data_source_id = NEW.data_source_id AND data_collection_end_date::date >= CURRENT_DATE) THEN\nDELETE FROM demographic_data WHERE demographic_data_id = NEW.demographic_data_id;\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_data_source_active\nBEFORE INSERT ON demographic_data\nFOR EACH ROW EXECUTE FUNCTION trg_validate_data_source_active();",
    "database_name": "demographic_and_socioeconomic_data_analysis_233179",
    "tables": [
      "demographics",
      "education",
      "employment",
      "data_sources",
      "demographic_data",
      "education_data",
      "employment_data"
    ],
    "call_sqls": [
      "INSERT INTO demographic_data (demographic_data_id, demographic_id, data_source_id, data, data_version, data_collection_date) VALUES (100, 1, 1, '30,Male,Bachelors', 'v1', '2023-10-15');",
      "INSERT INTO demographic_data (demographic_data_id, demographic_id, data_source_id, data, data_version, data_collection_date) VALUES (101, 2, 0, '28,Female,Masters', 'v1', '2023-10-15');",
      "INSERT INTO demographic_data (demographic_data_id, demographic_id, data_source_id, data, data_version, data_collection_date) VALUES (102, 3, 2, '45,Female,PhD', 'v1', '2023-10-15');",
      "INSERT INTO demographic_data (demographic_data_id, demographic_id, data_source_id, data, data_version, data_collection_date) VALUES (103, 4, 1, '22,Male,Associate', 'v2', '2023-10-16');",
      "INSERT INTO demographic_data (demographic_data_id, demographic_id, data_source_id, data, data_version, data_collection_date) VALUES (104, 5, 0, '35,Male,High-school', 'v2', '2023-10-16');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `trg_validate_data_source_active` that runs before each row is inserted into the `demographic_data` table, ensuring that the `data_source_id` being inserted corresponds to an active data source in the `data_sources` table, where `data_collection_end_date` is on or after the current date; if no such active source exists, the trigger removes the new row from `demographic_data` based on matching `demographic_data_id`.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called `trg_validate_data_source_active` that runs before each row is inserted into the `demographic_data` table. It checks if the new row's `data_source_id` corresponds to an active data source in the `data_sources` table, where active means the `data_collection_end_date` is on or after the current date. If no active source is found, it deletes the new row from `demographic_data` based on matching `demographic_data_id`. The trigger then returns the NEW row.",
    "id": 17,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `trg_validate_data_source_active` that checks if a corresponding active record exists in the `data_sources` table. The function must use a `NOT EXISTS` condition with a subquery that selects `1` from `data_sources` where `data_source_id` matches `NEW.data_source_id` and where `data_collection_end_date` cast to `date` is greater than or equal to `CURRENT_DATE`. If no active source is found, the function must delete the row from the `demographic_data` table where `demographic_data_id` equals `NEW.demographic_data_id`. The function must end by returning `NEW`. Second, define the trigger `validate_data_source_active` on table `demographic_data` that fires `BEFORE INSERT` and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_validate_data_source_active` that is designed to be executed `BEFORE INSERT` operations on the `demographic_data` table, `FOR EACH ROW`. This trigger function takes no explicit parameters but implicitly receives the `NEW` and `OLD` pseudo-row variables, representing the new and old row data respectively. Upon activation, the function first performs a conditional check. It queries the `data_sources` table to determine if a record exists where the `data_source_id` column matches the `data_source_id` value from the `NEW` row being inserted into `demographic_data`, AND where the `data_collection_end_date` column, after being explicitly cast to a `date` data type using `::date`, is greater than or equal to the `CURRENT_DATE`. The `SELECT 1` statement is used for efficiency, as only the existence of a matching row is required, not its actual data. If this `NOT EXISTS` condition evaluates to `TRUE`, meaning no active data source (based on the `data_collection_end_date`) is found for the `data_source_id` associated with the new `demographic_data` record, then the function proceeds to execute a `DELETE` operation. This `DELETE` operation targets the `demographic_data` table itself, removing the row where the `demographic_data_id` column matches the `demographic_data_id` value from the `NEW` row that was just attempted to be inserted. After this conditional logic, regardless of whether a deletion occurred or not, the function returns the `NEW` pseudo-row. This return value is crucial for `BEFORE` triggers, as it represents the row that will ultimately be inserted into the `demographic_data` table (potentially modified by other `BEFORE` triggers, though not in this specific function). The associated trigger, named `validate_data_source_active`, is configured to fire `BEFORE INSERT` on the `demographic_data` table for every row being inserted, executing the `trg_validate_data_source_active` function.",
    "original_summary": "Create a trigger function named `trg_validate_data_source_active` that runs before an insert on the `demographic_data` table for each row. Check if an active data source (where `data_collection_end_date` >= current date) exists in the `data_sources` table for the new row's `data_source_id`. If no active source exists, delete the new row from `demographic_data` where `demographic_data_id` matches. Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a trigger function designated as `trg_validate_data_source_active`. This function is to be executed prior to each insertion operation on the `demographic_data` table, operating on a per-row basis. Its logic must verify the existence of an active data source within the `data_sources` table corresponding to the new row's `data_source_id`, where an active source is defined by a `data_collection_end_date` that is greater than or equal to the current date. Should such an active source not be identified, the function must proceed to delete the newly inserted row from the `demographic_data` table where the `demographic_data_id` values correspond. The function is then required to return the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_lifestyle_factors_summary` that checks if the `NEW.lifestyle_id` is NULL and, if so, sets it to the result of `COALESCE((SELECT MAX(lifestyle_id) FROM lifestyle_factors), 0) + 1`. Then, it uses `COALESCE` to ensure `NEW.calcium_0` and `NEW.calcium_1` are not NULL by setting them to 0 if they are.\nSecond, define the trigger `lifestyle_factors_summary_trigger` on table `lifestyle_factors` that fires BEFORE INSERT OR UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_lifestyle_factors_summary() RETURNS TRIGGER AS $$\nBEGIN\n  -- Ensure lifestyle_id is set if not provided\n  IF NEW.lifestyle_id IS NULL THEN\n    NEW.lifestyle_id := COALESCE((SELECT MAX(lifestyle_id) FROM lifestyle_factors), 0) + 1;\n  END IF;\n  \n  -- Update calcium totals in the same record\n  NEW.calcium_0 := COALESCE(NEW.calcium_0, 0);\n  NEW.calcium_1 := COALESCE(NEW.calcium_1, 0);\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER lifestyle_factors_summary_trigger\nBEFORE INSERT OR UPDATE ON lifestyle_factors\nFOR EACH ROW EXECUTE FUNCTION update_lifestyle_factors_summary();",
    "database_name": "medical_research_and_patient_data_management",
    "tables": [
      "genetic_markers",
      "lifestyle_factors",
      "neuroimaging"
    ],
    "call_sqls": [
      "INSERT INTO lifestyle_factors (patient_id, calcium_0, calcium_1, any_bt_0, any_bt_1, vitamin_d_0, vitamin_d_1, any_chol_0, any_chol_1, diet, exercise_frequency, stress_levels, sleep_quality, social_activity, notes) VALUES (1, 1, 0, 1, 0, 1, 0, 1, 0, 'Balanced diet with fruits and vegetables', 'Daily', 'Low', 'Good', 'Moderate', 'Patient is generally active and healthy.');",
      "INSERT INTO lifestyle_factors (patient_id, calcium_0, calcium_1, any_bt_0, any_bt_1, vitamin_d_0, vitamin_d_1, any_chol_0, any_chol_1, diet, exercise_frequency, stress_levels, sleep_quality, social_activity, notes) VALUES (2, NULL, NULL, 0, 1, 0, 1, 0, 1, 'Balanced diet with occasional treats', 'Weekly', 'Medium', 'Fair', 'Moderate', 'Patient is moderately active and healthy.');",
      "UPDATE lifestyle_factors SET calcium_0 = 2, calcium_1 = 1 WHERE lifestyle_id = 0;",
      "INSERT INTO lifestyle_factors (patient_id, any_bt_0, any_bt_1, vitamin_d_0, vitamin_d_1, any_chol_0, any_chol_1, diet, exercise_frequency, stress_levels, sleep_quality, social_activity, notes) VALUES (3, 1, 0, 1, 0, 1, 0, 'Vegetarian diet', 'Daily', 'Low', 'Excellent', 'High', 'New patient with good lifestyle habits.');",
      "UPDATE lifestyle_factors SET calcium_0 = NULL, calcium_1 = NULL, diet = 'Vegan diet' WHERE lifestyle_id = 1;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named lifestyle_factors_summary_trigger that fires BEFORE INSERT OR UPDATE on the lifestyle_factors table for each row, ensuring that if the lifestyle_id is not provided, it is automatically assigned by taking the highest existing lifestyle_id (or starting from 0) and adding 1, and also guarantees that the calcium_0 and calcium_1 fields are never NULL by setting them to 0 if they are, then returns the updated record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_lifestyle_factors_summary that runs BEFORE INSERT or UPDATE on each row of the lifestyle_factors table. If the lifestyle_id is missing, assign a new one by taking the highest existing lifestyle_id (or 0 if none exist) and adding 1. Also, ensure the calcium_0 and calcium_1 fields are never left empty by setting them to 0 if they are NULL. Return the updated row.",
    "id": 18,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `update_lifestyle_factors_summary` that returns a TRIGGER type and is designed to be executed BEFORE INSERT or UPDATE operations on the `lifestyle_factors` table, FOR EACH ROW affected by the operation. The function takes no explicit parameters but operates on the NEW pseudo-record provided by the trigger mechanism.\n\nUpon execution, the function first declares a local variable `v_max_lifestyle_id` of type `bigint` to store the maximum existing lifestyle_id value.\n\nThe function then performs a conditional check: IF NEW.lifestyle_id IS NULL THEN. If this condition is true, meaning the `lifestyle_id` column in the NEW row is missing or null, the function executes a SELECT statement to retrieve the maximum value of the `lifestyle_id` column from the `lifestyle_factors` table. This SELECT statement uses the `COALESCE` function to handle the case where no rows exist in the table; if the maximum value is NULL (i.e., the table is empty), `COALESCE` returns 0. The result of this SELECT is stored into the `v_max_lifestyle_id` variable. After obtaining the maximum value, the function sets the `NEW.lifestyle_id` column to the value of `v_max_lifestyle_id` plus 1, effectively assigning a new sequential identifier.\n\nNext, the function ensures the `calcium_0` and `calcium_1` fields are never left empty. It performs two separate conditional checks. First, IF NEW.calcium_0 IS NULL THEN, which checks if the `calcium_0` column in the NEW row is null. If this condition is true, the function sets `NEW.calcium_0` to the integer value 0. Second, IF NEW.calcium_1 IS NULL THEN, which checks if the `calcium_1` column in the NEW row is null. If this condition is true, the function sets `NEW.calcium_1` to the integer value 0.\n\nAfter these operations, the function returns the modified NEW row, which includes the potentially assigned `lifestyle_id` and the defaulted `calcium_0` and `calcium_1` values.\n\nSecond, define the trigger `update_lifestyle_factors_summary_trigger` on the `lifestyle_factors` table. This trigger is set to execute the `update_lifestyle_factors_summary` function BEFORE each INSERT or UPDATE operation on the table, FOR EACH ROW. This ensures that before any new row is inserted or any existing row is updated in the `lifestyle_factors` table, the function automatically assigns a `lifestyle_id` if missing and sets default values for `calcium_0` and `calcium_1` if they are null, thereby maintaining data integrity.",
    "original_ir": "Write a PL/pgSQL function named `update_lifestyle_factors_summary` that is designed to be executed as a `BEFORE INSERT OR UPDATE` trigger on the `lifestyle_factors` table, operating `FOR EACH ROW`. This function takes no explicit parameters but implicitly receives the `NEW` record, which represents the row being inserted or updated. The primary purpose of this function is to ensure data integrity and consistency for new or modified `lifestyle_factors` records.\n\nUpon execution, the function first checks if the `lifestyle_id` column of the `NEW` record is `NULL`. This is achieved by evaluating the conditional statement `IF NEW.lifestyle_id IS NULL THEN`. If `NEW.lifestyle_id` is indeed `NULL`, the function proceeds to assign a value to it. The assigned value is determined by querying the `lifestyle_factors` table to find the maximum existing `lifestyle_id`. Specifically, it executes `SELECT MAX(lifestyle_id) FROM lifestyle_factors`. The result of this `MAX` aggregation is then passed to the `COALESCE` function, which handles the case where `MAX(lifestyle_id)` might return `NULL` (e.g., if the table is empty). If `MAX(lifestyle_id)` is `NULL`, `COALESCE` returns `0`; otherwise, it returns the actual maximum `lifestyle_id`. This result (either the maximum `lifestyle_id` or `0`) is then incremented by `1` (`+ 1`) to generate a new, unique `lifestyle_id`. This newly generated `lifestyle_id` is then assigned to `NEW.lifestyle_id`.\n\nFollowing the `lifestyle_id` handling, the function then ensures that the `calcium_0` and `calcium_1` columns of the `NEW` record have non-`NULL` values. For `NEW.calcium_0`, it uses `COALESCE(NEW.calcium_0, 0)`. This means if `NEW.calcium_0` is `NULL`, it will be set to `0`; otherwise, it retains its original value. Similarly, for `NEW.calcium_1`, it uses `COALESCE(NEW.calcium_1, 0)`, setting it to `0` if it's `NULL` and keeping its original value otherwise.\n\nFinally, the function concludes by returning the `NEW` record. This `NEW` record, potentially modified with a generated `lifestyle_id` and non-`NULL` `calcium_0` and `calcium_1` values, is then used by the database system for the actual `INSERT` or `UPDATE` operation on the `lifestyle_factors` table.",
    "original_summary": "Create a PL/pgSQL trigger function named update_lifestyle_factors_summary that fires BEFORE INSERT OR UPDATE on the lifestyle_factors table FOR EACH ROW. If NEW.lifestyle_id is NULL, it assigns a new ID by taking the maximum existing lifestyle_id (or 0) and adding 1. It also ensures NEW.calcium_0 and NEW.calcium_1 are not NULL by setting them to 0 if they are. The function returns the modified NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a PL/pgSQL trigger function, which should be named update_lifestyle_factors_summary, designed to execute BEFORE either an INSERT or an UPDATE operation on the lifestyle_factors table, specifically for each individual row. In the event that the NEW.lifestyle_id value is found to be NULL, the function must thoughtfully assign a fresh identifier by first determining the maximum existing lifestyle_id, defaulting gracefully to 0 if none are present, and then meticulously adding 1 to that value. Furthermore, it must carefully ensure that the NEW.calcium_0 and NEW.calcium_1 fields are never left as NULL by considerately setting them to a default value of 0 whenever they are encountered in such a state. Finally, the function should properly return the thoughtfully modified NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_category_hierarchy_trigger` that checks if the `NEW.parent_category_id` is not NULL and if a row with a matching `category_id` does not exist in the `categories` table using a subquery `SELECT 1`. If both conditions are true, it raises a notice 'Parent category % does not exist, setting parent_category_id to NULL' with the invalid ID and then sets `NEW.parent_category_id` to NULL.\nSecond, define the trigger `update_category_hierarchy` on table `categories` that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_category_hierarchy_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.parent_category_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM categories WHERE category_id = NEW.parent_category_id) THEN\n        RAISE NOTICE 'Parent category % does not exist, setting parent_category_id to NULL', NEW.parent_category_id;\n        NEW.parent_category_id := NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_category_hierarchy\n    BEFORE INSERT OR UPDATE ON categories\n    FOR EACH ROW\n    EXECUTE FUNCTION update_category_hierarchy_trigger();",
    "database_name": "apparel_sizing_and_inventory_management_730443",
    "tables": [
      "products",
      "categories",
      "sales",
      "users",
      "suppliers"
    ],
    "call_sqls": [
      "INSERT INTO categories (category_id, category_name, description, parent_category_id, created_at, updated_at) VALUES (1, 'Electronics', 'Electronic gadgets', NULL, '2023-01-01', '2023-01-01');",
      "INSERT INTO categories (category_id, category_name, description, parent_category_id, created_at, updated_at) VALUES (2, 'Smartphones', 'Mobile phones', 1, '2023-01-02', '2023-01-02');",
      "INSERT INTO categories (category_id, category_name, description, parent_category_id, created_at, updated_at) VALUES (3, 'Laptops', 'Portable computers', 1, '2023-01-03', '2023-01-03');",
      "INSERT INTO categories (category_id, category_name, description, parent_category_id, created_at, updated_at) VALUES (4, 'NonExistentParent', 'Category with non-existent parent', 999, '2023-01-04', '2023-01-04');",
      "UPDATE categories SET parent_category_id = 998 WHERE category_id = 3;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_category_hierarchy that fires BEFORE INSERT OR UPDATE on the categories table for each row, ensuring that if the new parent_category_id is not null but does not correspond to an existing category_id in the categories table, it logs a notice stating the parent category does not exist, sets the parent_category_id to null, and returns the modified row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_category_hierarchy that runs before inserting or updating a row in the categories table. It should check if a new parent_category_id is being set and verify whether this parent exists in the categories table. If the parent category does not exist, log a notice indicating it was not found, set the parent_category_id to NULL, and then return the updated row.",
    "id": 19,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named update_category_hierarchy_trigger that returns a trigger. This function is executed automatically by a trigger named update_category_hierarchy, which is defined to fire BEFORE an INSERT or UPDATE operation occurs on the categories table, and for each individual row that is modified.\n\nThe function declares a variable parent_exists of type boolean to store the result of a check. It performs a SELECT operation on the categories table to check if a row exists where the category_id column matches the new value of the parent_category_id column from the row being inserted or updated (referenced as NEW.parent_category_id). The result is stored into the parent_exists variable using a SELECT INTO statement with a COUNT aggregate: if the count is greater than 0, parent_exists is set to TRUE; otherwise, it is set to FALSE.\n\nThe function then uses an IF control flow statement to evaluate two conditions: first, if NEW.parent_category_id is not NULL, and second, if parent_exists is FALSE. If both conditions are true, it executes a RAISE NOTICE statement to log a message indicating that the parent category with the specified ID was not found. Following this, it sets the NEW.parent_category_id to NULL. After the IF block, the function returns the NEW row record to the trigger mechanism, which may have been modified by setting parent_category_id to NULL.\n\nSecond, define the trigger update_category_hierarchy on the categories table to execute the function update_category_hierarchy_trigger BEFORE INSERT OR UPDATE for each row.",
    "original_ir": "Write a PostgreSQL trigger function named update_category_hierarchy_trigger that returns a trigger and is executed by a trigger named update_category_hierarchy, which is defined to fire before any insert or update operation on the categories table for each affected row, where the function's logic begins by checking if the new row's parent_category_id column value is not null and if a row with a category_id equal to that parent_category_id value does not exist in the categories table, using a subquery that selects the constant 1, and if both conditions are true, the function raises a notice with the text 'Parent category % does not exist, setting parent_category_id to NULL' where the percent sign is replaced by the invalid NEW.parent_category_id value, then sets the NEW.parent_category_id value to null, and finally returns the modified NEW row record.",
    "original_summary": "Create a PostgreSQL trigger function named update_category_hierarchy_trigger that fires BEFORE INSERT OR UPDATE on the categories table FOR EACH ROW. If the new parent_category_id is not null and the referenced parent category does not exist in the categories table, raise a notice 'Parent category % does not exist, setting parent_category_id to NULL' and set NEW.parent_category_id to null. Return the modified NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a trigger function for the categories table that runs before adding or changing a row. It should check if a new parent category is being set. If that parent doesn't seem to be in the table already, just log a message about it not being found and clear the parent reference. Then send back the updated row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_new_user` that performs an INSERT into the `user_roles` table, setting the `user_id` column to `NEW.user_id` and the `role_id` column to the static integer `1`, then returns `NEW`.\nSecond, define the trigger `trg_log_new_user` on table `users` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_new_user() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO user_roles (user_id, role_id) VALUES (NEW.user_id, 1);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_new_user\n    AFTER INSERT ON users\n    FOR EACH ROW\n    EXECUTE FUNCTION log_new_user();",
    "database_name": "machine_learning_model_evaluation_and_hyperparameter_tuning",
    "tables": [
      "datasets",
      "model_runs",
      "models",
      "roles",
      "user_roles",
      "users"
    ],
    "call_sqls": [
      "INSERT INTO users (user_id, username, email, password_hash) VALUES (1, 'john_doe', 'john.doe@example.com', 'hashed_password_1');",
      "INSERT INTO users (user_id, username, email, password_hash) VALUES (2, 'jane_smith', 'jane.smith@example.com', 'hashed_password_2');",
      "INSERT INTO users (user_id, username, email, password_hash) VALUES (3, 'alice_jones', 'alice.jones@example.com', 'hashed_password_3');",
      "INSERT INTO users (user_id, username, email, password_hash) VALUES (4, 'bob_white', 'bob.white@example.com', 'hashed_password_4');",
      "INSERT INTO users (user_id, username, email, password_hash) VALUES (5, 'charlie_brown', 'charlie.brown@example.com', 'hashed_password_5');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_log_new_user that runs after each insert on the users table, inserting a new row into the user_roles table with the NEW.user_id and assigning a static role_id of 1, and returns the NEW row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_log_new_user that executes after each insert on the users table to automatically insert a new row into the user_roles table with the inserted user's user_id from the NEW record and assign a static role_id of 1, ensuring the function returns the NEW row.",
    "id": 20,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_new_user` that performs an INSERT into the `user_roles` table, setting the `user_id` column to `NEW.user_id` and the `role_id` column to the static integer `1`, then returns `NEW`.\nSecond, define the trigger `trg_log_new_user` on table `users` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger that automatically assigns a default role to a newly created user. This is achieved by defining a function named `log_new_user` which returns a `TRIGGER` type. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables like `NEW` and `OLD`. Inside the `log_new_user` function, an `INSERT` operation is performed on the `user_roles` table. This `INSERT` statement populates two columns: `user_id` and `role_id`. The value for the `user_id` column is taken from `NEW.user_id`, which represents the `user_id` column of the row that was just inserted into the `users` table. The value for the `role_id` column is a static integer `1`. After the `INSERT` operation, the function returns `NEW`, which signifies that the row that triggered this function should be inserted as is. This `log_new_user` function is then associated with a trigger named `trg_log_new_user`. This trigger is configured to execute `AFTER INSERT` operations on the `users` table. The `FOR EACH ROW` clause specifies that the trigger function `log_new_user` should be executed once for each row that is inserted into the `users` table. The `EXECUTE FUNCTION log_new_user()` clause explicitly calls the previously defined function `log_new_user` when the trigger conditions are met.",
    "original_summary": "Create a PL/pgSQL trigger function that runs after an insert on the users table. The function should insert a new row into the user_roles table, assigning the NEW.user_id and a static role_id of 1. The function must return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a PL/pgSQL trigger function that executes after an insert on the users table to insert a new row into the user_roles table with the NEW.user_id and a static role_id of 1, and ensure the function returns the NEW row?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_zone_population_on_insert` that checks if a zone with `NEW.zone_id` exists in the `zones` table and, if not, inserts a new row into `zones` with the provided `zone_id`, a concatenated `zone_name` ('Zone ' || NEW.zone_id), a `zone_description` of 'Auto-created zone', a `zone_population` of 0, and a `zone_area` of 0.0. Then, it updates the `zones` table by incrementing the `zone_population` by 1 for the matching `zone_id`.\nSecond, define the trigger `trg_properties_insert_zone_pop` on table `properties` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_zone_population_on_insert() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if zone exists, if not create it with default values\n  IF NOT EXISTS (SELECT 1 FROM zones WHERE zone_id = NEW.zone_id) THEN\n    INSERT INTO zones (zone_id, zone_name, zone_description, zone_population, zone_area)\n    VALUES (NEW.zone_id, 'Zone ' || NEW.zone_id, 'Auto-created zone', 0, 0.0);\n  END IF;\n  \n  -- Update zone population\n  UPDATE zones SET zone_population = zone_population + 1 WHERE zone_id = NEW.zone_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_properties_insert_zone_pop\nBEFORE INSERT ON properties\nFOR EACH ROW EXECUTE FUNCTION update_zone_population_on_insert();",
    "database_name": "real_estate_and_urban_development_analysis_73520",
    "tables": [
      "properties",
      "zones",
      "environmental_factors",
      "income_statistics",
      "property_amenities",
      "tax_rates"
    ],
    "call_sqls": [
      "INSERT INTO properties (property_id, crime_rate, zone_id, industrial_proximity, char_river, nitrogen_oxide, num_rooms, property_age, distance_to_amenities, radial, tax_rate, student_teacher_ratio, low_income_stat, median_value, categorical_median_value, property_type, listing_status, sale_date, sale_price) VALUES (1, 0.05, 101, 0.1, 'No', 0.05, 6, 30, 2.5, 5, 350, 15, 5, 300000, 'High', 'House', 'Active', '2023-01-15', 320000);",
      "INSERT INTO properties (property_id, crime_rate, zone_id, industrial_proximity, char_river, nitrogen_oxide, num_rooms, property_age, distance_to_amenities, radial, tax_rate, student_teacher_ratio, low_income_stat, median_value, categorical_median_value, property_type, listing_status, sale_date, sale_price) VALUES (2, 0.1, 102, 0.2, 'Yes', 0.08, 7, 20, 1.0, 4, 400, 12, 8, 450000, 'Very High', 'Apartment', 'Sold', '2023-02-20', 460000);",
      "INSERT INTO properties (property_id, crime_rate, zone_id, industrial_proximity, char_river, nitrogen_oxide, num_rooms, property_age, distance_to_amenities, radial, tax_rate, student_teacher_ratio, low_income_stat, median_value, categorical_median_value, property_type, listing_status, sale_date, sale_price) VALUES (3, 0.03, 101, 0.05, 'No', 0.03, 5, 40, 3.0, 6, 300, 18, 3, 250000, 'Medium', 'Condo', 'Active', '2023-03-10', 260000);",
      "INSERT INTO properties (property_id, crime_rate, zone_id, industrial_proximity, char_river, nitrogen_oxide, num_rooms, property_age, distance_to_amenities, radial, tax_rate, student_teacher_ratio, low_income_stat, median_value, categorical_median_value, property_type, listing_status, sale_date, sale_price) VALUES (4, 0.07, 103, 0.15, 'No', 0.06, 8, 15, 0.5, 3, 450, 10, 6, 500000, 'Very High', 'House', 'Pending', '2023-04-01', 510000);",
      "INSERT INTO properties (property_id, crime_rate, zone_id, industrial_proximity, char_river, nitrogen_oxide, num_rooms, property_age, distance_to_amenities, radial, tax_rate, student_teacher_ratio, low_income_stat, median_value, categorical_median_value, property_type, listing_status, sale_date, sale_price) VALUES (5, 0.02, 102, 0.08, 'Yes', 0.04, 6, 25, 1.2, 5, 380, 14, 4, 380000, 'High', 'Townhouse', 'Sold', '2023-05-05', 390000);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_zone_population_on_insert that, before inserting a row into the properties table, ensures the zone_id from the new property exists in the zones table by creating a new zone with that ID, a name of 'Zone ' plus the ID, a description of 'Auto-created zone', a population of 0, and an area of 0.0 if it does not already exist, then increments the zone_population by 1 for that zone_id in the zones table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called 'update_zone_population_on_insert' that runs BEFORE INSERT on the 'properties' table for each row, ensuring that if a zone with the NEW.zone_id does not exist in the 'zones' table, it creates a new zone record with that ID, a name like 'Zone ' plus the ID, a description 'Auto-created zone', a population of 0, and an area of 0.0, then increments the zone_population by 1 in the 'zones' table for that zone_id, and returns the NEW row, and also create a trigger named 'trg_properties_insert_zone_pop' to execute this function as a BEFORE INSERT trigger on the 'properties' table.",
    "id": 21,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_zone_population_on_insert` that is executed as a `BEFORE INSERT` trigger on the `properties` table for each row. This function takes no explicit parameters but operates on the `NEW` record, which represents the row being inserted into the `properties` table. The function first checks if a zone with the `zone_id` equal to `NEW.zone_id` exists in the `zones` table by performing a `SELECT` query on the `zones` table to count the number of rows where `zone_id` matches `NEW.zone_id`. If the count is `0`, indicating the zone does not exist, the function inserts a new row into the `zones` table with the following values: `zone_id` set to `NEW.zone_id`, `zone_name` set to the concatenation of the string literal `'Zone '` and the `NEW.zone_id` value cast to text, `zone_description` set to the string literal `'Auto-created zone'`, `zone_population` set to `0`, and `zone_area` set to `0.0`. After this insertion, or if the zone already existed, the function then updates the `zones` table by incrementing the `zone_population` column by `1` for the row where `zone_id` equals `NEW.zone_id`. Finally, the function returns the `NEW` record, allowing the insertion into the `properties` table to proceed. Second, define the trigger `trg_properties_insert_zone_pop` on the `properties` table to execute the `update_zone_population_on_insert` function `BEFORE INSERT` for each row.",
    "original_ir": "Write a PLpgSQL trigger function named `update_zone_population_on_insert` that is designed to be executed before an `INSERT` operation on the `properties` table, for each row being inserted. This function takes no explicit parameters but implicitly receives the `NEW` record, which represents the row about to be inserted into the `properties` table. The primary purpose of this function is to ensure that a corresponding zone exists for the `zone_id` specified in the new `properties` record and to increment the population count for that zone.\n\nThe function begins by executing a conditional check: it performs a `SELECT` operation to determine if a record exists in the `zones` table where the `zone_id` column matches the `zone_id` value from the `NEW` record (i.e., `NEW.zone_id`). If this `SELECT` query returns no rows, indicating that a zone with the specified `zone_id` does not yet exist in the `zones` table, then the function proceeds to execute an `INSERT` operation. This `INSERT` statement adds a new row into the `zones` table, populating the `zone_id` column with the value from `NEW.zone_id`, the `zone_name` column with a concatenated string 'Zone ' followed by the `NEW.zone_id` value, the `zone_description` column with the literal string 'Auto-created zone', the `zone_population` column with the default integer value `0`, and the `zone_area` column with the default numeric value `0.0`.\n\nFollowing this conditional creation of a zone (or immediately if the zone already existed), the function then executes an `UPDATE` operation on the `zones` table. This `UPDATE` statement modifies the `zone_population` column by incrementing its current value by `1` for the row where the `zone_id` column matches the `zone_id` value from the `NEW` record (i.e., `NEW.zone_id`). After performing these operations, the function concludes by returning the `NEW` record, which allows the original `INSERT` operation on the `properties` table to proceed with the row as it was provided.\n\nThe `trg_properties_insert_zone_pop` trigger is defined to execute the `update_zone_population_on_insert()` function. This trigger is activated `BEFORE INSERT` operations on the `properties` table and is configured to run `FOR EACH ROW` that is being inserted. This means that for every new row added to the `properties` table, the `update_zone_population_on_insert` function will be invoked, ensuring that the associated zone's population is correctly managed and updated based on the `zone_id` of the newly inserted property.",
    "original_summary": "Create a PL/pgSQL trigger function named 'update_zone_population_on_insert' that returns TRIGGER. It should execute BEFORE INSERT on the 'properties' table for each row. The function must check if a zone with 'NEW.zone_id' exists in the 'zones' table. If not, insert a new zone with that ID, a name of 'Zone ' concatenated with the ID, a description of 'Auto-created zone', a population of 0, and an area of 0.0. Then, update the 'zones' table by incrementing the 'zone_population' by 1 for the row matching 'NEW.zone_id'. The function should return the NEW row. Create a trigger named 'trg_properties_insert_zone_pop' that is a BEFORE INSERT FOR EACH ROW trigger on the 'properties' table to execute this function.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a PL/pgSQL trigger function, which should be named 'update_zone_population_on_insert' and must be defined to return a TRIGGER. This comprehensive function is designed to execute automatically BEFORE any INSERT operation occurs on the 'properties' table, specifically for each individual row. Within its detailed logic, the function must first perform a careful check to ascertain whether a zone corresponding to the 'NEW.zone_id' value already exists within the 'zones' table. If, upon thorough inspection, such a zone is found to be absent, the function must then proceed to insert a completely new zone record. This new record will use the provided ID, assign a name by concatenating the string 'Zone ' with the ID, set the description to the predefined text 'Auto-created zone', initialize the population to a starting value of 0, and set the area to an initial 0.0. Following this conditional insertion step, the function must then meticulously update the 'zones' table by incrementing the 'zone_population' column by exactly 1 for the specific row whose zone_id matches the 'NEW.zone_id'. Finally, the function should conclusively return the NEW row. Subsequently, you must also create an associated trigger named 'trg_properties_insert_zone_pop'; this trigger should be configured as a BEFORE INSERT FOR EACH ROW trigger on the 'properties' table, with the sole purpose of executing the aforementioned function."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_emissions_source_on_publication` that inserts a new record into the `emissions_data_sources` table using values from the `NEW` record of the `research_publications` table. The function must set the `source_id` to the maximum current `source_id` from `emissions_data_sources` plus one, set `source_name` to 'Research Publication', and set the `description`, `year`, and `url` columns to `NEW.title`, `NEW.year`, and `NEW.url` respectively. The function must then return `NEW`.\nSecond, define the trigger `trg_research_publication_insert` on table `research_publications` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_emissions_source_on_publication() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO emissions_data_sources (source_id, source_name, description, year, url) VALUES ((SELECT MAX(source_id) + 1 FROM emissions_data_sources), 'Research Publication', NEW.title, NEW.year, NEW.url);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_research_publication_insert\nAFTER INSERT ON research_publications\nFOR EACH ROW EXECUTE FUNCTION insert_emissions_source_on_publication();",
    "database_name": "climate_change_impact_analysis_and_emissions_tracking",
    "tables": [
      "climate_models",
      "emissions_data",
      "emissions_data_sources",
      "emissions_metrics",
      "gas_concentrations",
      "research_publications",
      "users"
    ],
    "call_sqls": [
      "INSERT INTO research_publications (publication_id, title, authors, journal, year, url) VALUES (100, 'Global Methane Emissions Trends 2023', 'Dr. Emma Wilson, Prof. James Lee', 'Nature Climate Change', 2023, 'https://example.com/methane2023');",
      "INSERT INTO research_publications (publication_id, title, authors, journal, year, url) VALUES (101, 'Ocean Acidification Projections for 2100', 'Marine Science Team', 'Science Advances', 2024, 'https://example.com/ocean-acid');",
      "INSERT INTO research_publications (publication_id, title, authors, journal, year, url) VALUES (102, 'Arctic Permafrost Carbon Feedback', 'Polar Research Group', 'PNAS', 2022, 'https://example.com/permafrost-carbon');",
      "INSERT INTO research_publications (publication_id, title, authors, journal, year, url) VALUES (103, 'CO2 Removal Technologies Assessment', 'Climate Engineering Consortium', 'Joule', 2025, 'https://example.com/cdr-tech');",
      "INSERT INTO research_publications (publication_id, title, authors, journal, year, url) VALUES (104, 'Sea Level Rise and Coastal Cities', 'Urban Climate Adaptation Network', 'Climate Risk Management', 2021, 'https://example.com/sea-level-cities');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_research_publication_insert that fires AFTER INSERT on the research_publications table, and for each new row, it automatically adds a corresponding entry to the emissions_data_sources table by setting the source_id to the next sequential number (the current maximum source_id plus one), source_name to 'Research Publication', description to the new publication's title, year to the new publication's year, and url to the new publication's url.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_research_publication_insert that fires AFTER INSERT on the research_publications table to insert a row into the emissions_data_sources table, setting source_id to the current maximum source_id plus 1, source_name to 'Research Publication', description to the new title, year to the new year, and url to the new url, and then returns the new row.",
    "id": 22,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_emissions_source_on_publication` that inserts a new record into the `emissions_data_sources` table using values from the `NEW` record of the `research_publications` table. The function must set the `source_id` to the maximum current `source_id` from `emissions_data_sources` plus one, set `source_name` to 'Research Publication', and set the `description`, `year`, and `url` columns to `NEW.title`, `NEW.year`, and `NEW.url` respectively. The function must then return `NEW`.\nSecond, define the trigger `trg_research_publication_insert` on table `research_publications` that fires `AFTER` `INSERT` and executes the function.",
    "original_ir": "Write a PLpgSQL function that is designed to be executed as a trigger function, which automatically inserts a new record into the emissions_data_sources table whenever a new row is inserted into the research_publications table. The function does not take any parameters directly but operates on the NEW record, which represents the row being inserted into the research_publications table. The function performs an INSERT operation into the emissions_data_sources table, setting the source_id column to the maximum current source_id value in the emissions_data_sources table plus one, ensuring a unique identifier for the new source. The source_name column is set to the string 'Research Publication', the description column is set to the title of the new research publication (NEW.title), the year column is set to the year of the new research publication (NEW.year), and the url column is set to the URL of the new research publication (NEW.url). The function then returns the NEW record, which is a standard practice in trigger functions to allow the triggering operation to proceed. The function is associated with a trigger named trg_research_publication_insert, which is defined to fire after an INSERT operation on the research_publications table, ensuring that the function is executed for each new row inserted into this table.",
    "original_summary": "Create a PLpgSQL trigger function that fires AFTER INSERT on the research_publications table via trigger trg_research_publication_insert. It inserts a row into the emissions_data_sources table, setting source_id to the current maximum source_id + 1, source_name to 'Research Publication', description to NEW.title, year to NEW.year, and url to NEW.url. The function returns NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a PLpgSQL trigger function that fires AFTER INSERT on the research_publications table via trigger trg_research_publication_insert to insert a row into the emissions_data_sources table, setting source_id to the current maximum source_id + 1, source_name to 'Research Publication', description to NEW.title, year to NEW.year, and url to NEW.url, and then returns NEW?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_total_deaths_trigger that updates the demographics table by incrementing its total_deaths column by the value from the NEW.number_of_deaths column, specifically for the row where demographics.country_id matches NEW.country_id and demographics.year matches NEW.year.\nSecond, define the trigger update_total_deaths_after_insert on table country_cause_of_death_data that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_total_deaths_trigger() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE demographics\n  SET total_deaths = total_deaths + NEW.number_of_deaths\n  WHERE country_id = NEW.country_id AND year = NEW.year;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_total_deaths_after_insert\nAFTER INSERT ON country_cause_of_death_data\nFOR EACH ROW EXECUTE FUNCTION update_total_deaths_trigger();",
    "database_name": "global_health_statistics_and_trends",
    "tables": [
      "countries",
      "country_cause_of_death_data",
      "causes_of_death",
      "country_disease_data",
      "country_injury_data",
      "demographics"
    ],
    "call_sqls": [
      "INSERT INTO country_cause_of_death_data (country_cause_of_death_id, country_id, cause_of_death_id, year, number_of_deaths) VALUES (1000, 0, 1, 2023, 5000);",
      "INSERT INTO country_cause_of_death_data (country_cause_of_death_id, country_id, cause_of_death_id, year, number_of_deaths, incidence_rate) VALUES (1001, 1, 0, 2023, 7500, 0.0001);",
      "INSERT INTO country_cause_of_death_data (country_cause_of_death_id, country_id, cause_of_death_id, year, number_of_deaths, prevalence_rate) VALUES (1002, 0, 2, 2024, 3000, 0.00005);",
      "INSERT INTO country_cause_of_death_data (country_cause_of_death_id, country_id, cause_of_death_id, year, number_of_deaths, case_fatality_rate) VALUES (1003, 1, 1, 2024, 4200, 0.07);",
      "INSERT INTO country_cause_of_death_data (country_cause_of_death_id, country_id, cause_of_death_id, year, number_of_deaths, incidence_rate, prevalence_rate) VALUES (1004, 2, 0, 2023, 12000, 0.0003, 0.0004);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_total_deaths_trigger that, after each insert into the country_cause_of_death_data table, updates the demographics table by adding the NEW.number_of_deaths to the total_deaths column where the country_id matches NEW.country_id and the year matches NEW.year.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_total_deaths_trigger that, after inserting a record into the country_cause_of_death_data table, updates the demographics table by adding the NEW.number_of_deaths to the total_deaths column where the country_id matches NEW.country_id and the year matches NEW.year, and then returns NEW.",
    "id": 23,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named `update_total_deaths_trigger` that returns a trigger type and is designed to execute after insert operations on the `country_cause_of_death_data` table. This function updates the `demographics` table by adding the `number_of_deaths` value from the newly inserted row (referenced as `NEW.number_of_deaths`) to the existing `total_deaths` column in the `demographics` table. The update is performed only for rows in the `demographics` table where the `country_id` matches `NEW.country_id` and the `year` matches `NEW.year`. The function then returns the `NEW` row to allow the triggering insert operation to proceed. Second, define the trigger `trg_update_total_deaths` on the `country_cause_of_death_data` table to fire after each row insert, executing the `update_total_deaths_trigger` function.",
    "original_ir": "Write a PostgreSQL trigger function named update_total_deaths_trigger that returns a trigger and is executed automatically after each new row is inserted into the country_cause_of_death_data table, where the function performs an update on the demographics table, specifically incrementing the total_deaths column by the value from the NEW record's number_of_deaths column, but only for the row in the demographics table where the country_id column matches the NEW record's country_id column and the year column matches the NEW record's year column, and the trigger function concludes by returning the NEW row record to the calling trigger mechanism.",
    "original_summary": "Create a trigger function named update_total_deaths_trigger that returns TRIGGER. After an insert into the country_cause_of_death_data table, update the demographics table. Increment the total_deaths column by NEW.number_of_deaths where country_id matches NEW.country_id and year matches NEW.year. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a trigger function named update_total_deaths_trigger that returns TRIGGER, which, after an insert into the country_cause_of_death_data table, updates the demographics table by incrementing the total_deaths column by NEW.number_of_deaths where the country_id matches NEW.country_id and the year matches NEW.year, and then returns NEW?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function create_owner_record that checks if NEW.buyer_id is NULL and, if so, assigns a new value by selecting the maximum existing buyer_id from the buyers table using COALESCE(MAX(buyer_id), 0) + 1. It then inserts a new record into the owners table, generating a new owner_id by selecting the maximum existing owner_id from the owners table using COALESCE(MAX(owner_id), 0) + 1. The owners record populates columns owner_name, contact_email, contact_phone, address, owner_type, tax_id, registration_date, and status from the corresponding NEW row values, and sets last_updated_date to the current date converted to text.\nSecond, define the trigger trg_create_owner_record on table buyers that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION create_owner_record() RETURNS TRIGGER AS $$\nBEGIN\n  -- Ensure buyer_id is not NULL before the INSERT into the buyers table proceeds.\n  -- This addresses the \"null value in column \"buyer_id\" violates not-null constraint\" error.\n  IF NEW.buyer_id IS NULL THEN\n    SELECT COALESCE(MAX(buyer_id), 0) + 1 INTO NEW.buyer_id FROM buyers;\n  END IF;\n\n  -- Insert into the owners table, generating a new owner_id independently.\n  INSERT INTO owners (owner_id, owner_name, contact_email, contact_phone, address, owner_type, tax_id, registration_date, last_updated_date, status)\n  VALUES (\n    (SELECT COALESCE(MAX(owner_id), 0) + 1 FROM owners),\n    NEW.buyer_name,\n    NEW.contact_email,\n    NEW.contact_phone,\n    NEW.address,\n    NEW.buyer_type,\n    NEW.tax_id,\n    NEW.registration_date,\n    CURRENT_DATE::text,\n    NEW.status\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Change the trigger to BEFORE INSERT so it can modify NEW.buyer_id before the insert into buyers completes.\nCREATE TRIGGER trg_create_owner_record\nBEFORE INSERT ON buyers\nFOR EACH ROW EXECUTE FUNCTION create_owner_record();",
    "database_name": "real_estate_and_property_management_58871",
    "tables": [
      "properties",
      "owners",
      "property_sales",
      "buyers",
      "sellers",
      "property_units"
    ],
    "call_sqls": [
      "INSERT INTO buyers (buyer_name, contact_email, contact_phone, address, buyer_type, tax_id, registration_date, status) VALUES ('John Doe', 'john@example.com', '555-1234', '123 Main St', 'individual', '111-22-3333', '2024-01-15', 'active');",
      "INSERT INTO buyers (buyer_id, buyer_name, contact_email, contact_phone, address, buyer_type, tax_id, registration_date, status) VALUES (NULL, 'Jane Smith', 'jane@example.com', '555-5678', '456 Oak Ave', 'individual', '444-55-6666', '2024-01-16', 'active');",
      "INSERT INTO buyers (buyer_name, contact_email, contact_phone, address, buyer_type, tax_id, registration_date, status) VALUES ('Acme Corp', 'acme@example.com', '555-9012', '789 Business Blvd', 'corporation', '777-88-9999', '2024-01-17', 'pending');",
      "INSERT INTO buyers (buyer_id, buyer_name, contact_email, contact_phone, address, buyer_type, tax_id, registration_date, status) VALUES (100, 'Test Buyer', 'test@example.com', '555-0000', '999 Test Lane', 'individual', '000-00-0000', '2024-01-18', 'active');",
      "INSERT INTO buyers (buyer_name, contact_email, contact_phone, address, buyer_type, tax_id, registration_date, status) VALUES ('Another Buyer', 'another@example.com', '555-1111', '111 Another Road', 'individual', '123-99-8888', '2024-01-19', 'inactive');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_create_owner_record that executes before each row is inserted into the buyers table to assign a sequential buyer_id if it is null and then creates a corresponding record in the owners table with a new sequential owner_id, populating owner_name, contact_email, contact_phone, address, owner_type, tax_id, registration_date, last_updated_date, and status from the new buyer data, and returns the NEW record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_create_owner_record that fires before a new row is inserted into the buyers table. If the incoming buyer_id is empty, assign it the next sequential number from existing buyer IDs. Then, automatically insert a corresponding record into the owners table, generating a new sequential owner_id and copying the buyer's details like name, contact info, address, type, tax ID, registration date, and status, while setting the last updated date to today. Finally, return the NEW record.",
    "id": 24,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function create_owner_record that checks if NEW.buyer_id is NULL and, if so, assigns a new value by selecting the maximum existing buyer_id from the buyers table using COALESCE(MAX(buyer_id), 0) + 1. It then inserts a new record into the owners table, generating a new owner_id by selecting the maximum existing owner_id from the owners table using COALESCE(MAX(owner_id), 0) + 1. The owners record populates columns owner_name, contact_email, contact_phone, address, owner_type, tax_id, registration_date, and status from the corresponding NEW row values, and sets last_updated_date to the current date converted to text.\nSecond, define the trigger trg_create_owner_record on table buyers that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL function that is designed to be used as a trigger function, which is executed before an insert operation on the buyers table. This function ensures that the buyer_id column in the new row being inserted is not null by checking if NEW.buyer_id is null; if it is, the function assigns a new buyer_id by selecting the maximum existing buyer_id from the buyers table and adding one to it. The function then inserts a new record into the owners table with a newly generated owner_id, which is determined by selecting the maximum existing owner_id from the owners table and adding one to it. The other columns in the owners table are populated with values from the NEW row being inserted into the buyers table, including owner_name, contact_email, contact_phone, address, owner_type, tax_id, registration_date, and status. The last_updated_date column in the owners table is set to the current date, converted to text format. The function returns the NEW row, allowing the insert operation on the buyers table to proceed with the modified buyer_id. A trigger named trg_create_owner_record is created to execute this function before each row is inserted into the buyers table, ensuring the buyer_id is set and a corresponding record is created in the owners table.",
    "original_summary": "Create a PostgreSQL trigger function that runs before each row is inserted into the `buyers` table. If the new row's `buyer_id` is NULL, the function assigns it the next sequential ID. It then inserts a corresponding record into the `owners` table with a new sequential `owner_id`, populating other columns from the new buyer data, and returns the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, can you whip up a PostgreSQL trigger that kicks in right before a new row gets slapped into the `buyers` table? If the incoming `buyer_id` is empty, the trigger should just grab the next number in line for it. Then, it's gotta also add a matching entry into the `owners` table, giving it a fresh sequential `owner_id` and copying over the other deets from the new buyer. In the end, it should hand back that NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `remove_related_records` that deletes rows from the `finals`, `attendance`, and `class_tests` tables where the `enrollment_id` column matches the `enrollment_id` from the `OLD` record and then returns `OLD`.\nSecond, define the trigger `trg_remove_related_records` on table `student_courses` that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_related_records() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM finals WHERE enrollment_id = OLD.enrollment_id;\n    DELETE FROM attendance WHERE enrollment_id = OLD.enrollment_id;\n    -- Add deletion for class_tests as identified by the error feedback\n    DELETE FROM class_tests WHERE enrollment_id = OLD.enrollment_id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_remove_related_records\n    BEFORE DELETE ON student_courses\n    FOR EACH ROW\n    EXECUTE FUNCTION remove_related_records();",
    "database_name": "student_academic_performance_tracking",
    "tables": [
      "student_courses",
      "students",
      "courses",
      "attendance",
      "finals"
    ],
    "call_sqls": [
      "DELETE FROM student_courses WHERE enrollment_id = '0';",
      "DELETE FROM student_courses WHERE enrollment_id = '1';",
      "DELETE FROM student_courses WHERE student_id = '0';",
      "DELETE FROM student_courses WHERE course_id = '0';",
      "DELETE FROM student_courses WHERE semester_id = '0';"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named remove_related_records that, before a row is deleted from the student_courses table, automatically deletes all related records from the finals, attendance, and class_tests tables where the enrollment_id matches the enrollment_id of the row being deleted.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named remove_related_records that, before deleting a row from the student_courses table, automatically deletes any related rows in the finals, attendance, and class_tests tables that share the same enrollment_id, and then returns the OLD record.",
    "id": 25,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named remove_related_records that is executed before a row is deleted from the student_courses table. The function returns the OLD record. Within the function, for the enrollment_id of the row being deleted from student_courses, delete all rows in the finals table where the enrollment_id matches. Then, delete all rows in the attendance table where the enrollment_id matches. Also, delete all rows in the class_tests table where the enrollment_id matches. After performing these deletions, the function returns the OLD record, which represents the row that was deleted from student_courses. Second, define the trigger remove_related_records on the student_courses table to execute the function before each row deletion, ensuring that related records in finals, attendance, and class_tests are automatically removed when a student_courses record is deleted.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `remove_related_records` that is designed to be executed automatically in response to a specific database event. This function does not accept any explicit input parameters in its signature, but it operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the row before and after the triggering event, respectively. The function is declared to return a `TRIGGER` type, which is standard for PostgreSQL trigger functions. Upon execution, the function performs a series of data deletion operations. Specifically, it first executes a `DELETE` statement on the `finals` table. This deletion targets all rows in the `finals` table where the value in the `enrollment_id` column matches the value of the `enrollment_id` column from the `OLD` record. The `OLD` record represents the row that is being deleted from the table on which the trigger is defined. Following this, the function executes another `DELETE` statement, this time on the `attendance` table. This deletion operation removes all rows from the `attendance` table where the value in the `enrollment_id` column is equal to the value of the `enrollment_id` column from the `OLD` record. Subsequently, the function executes a third `DELETE` statement, targeting the `class_tests` table. This deletion removes all rows from the `class_tests` table where the value in the `enrollment_id` column matches the value of the `enrollment_id` column from the `OLD` record. After completing all deletion operations, the function returns the `OLD` record.\n\nThis `remove_related_records` function is then associated with a trigger named `trg_remove_related_records`. This trigger is configured to activate `BEFORE DELETE` operations on the `student_courses` table. The `FOR EACH ROW` clause specifies that the trigger function will be executed once for each row that is deleted from the `student_courses` table. The `EXECUTE FUNCTION remove_related_records()` clause indicates that the `remove_related_records` function should be invoked when the trigger fires. Therefore, whenever a row is deleted from the `student_courses` table, this trigger will automatically execute the `remove_related_records` function, which in turn will delete related records from the `finals`, `attendance`, and `class_tests` tables based on the `enrollment_id` of the row being deleted from `student_courses`.",
    "original_summary": "Create a BEFORE DELETE trigger function named remove_related_records that deletes related rows from the finals, attendance, and class_tests tables where enrollment_id matches the deleted student_courses row. Return OLD.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, can you whip up a BEFORE DELETE trigger function called remove_related_records? Basically, when a student_courses row gets axed, this trigger should also clean out any linked rows in the finals, attendance, and class_tests tables that have the same enrollment_id. Just make sure it spits back the OLD record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_individual_on_employment_insert` that inserts a new row into the `individuals` table using values from the `NEW` record of the `employment` table, specifically mapping `NEW.\"id\"` to `individuals.\"id\"`, `NEW.\"employed\"` to `individuals.\"employed\"`, `NEW.\"wage\"` to `individuals.\"wage\"`, `NEW.\"collgrad\"` to `individuals.\"collgrad\"`, `NEW.\"employment_sector\"` to `individuals.\"employment_sector\"`, `NEW.\"employment_start_date\"` to `individuals.\"employment_start_date\"`, `NEW.\"employment_end_date\"` to `individuals.\"employment_end_date\"`, `NEW.\"income_source\"` to `individuals.\"income_source\"`, and `NEW.\"health_insurance\"` to `individuals.\"health_insurance\"`, and then returns `NEW`.\nSecond, define the trigger `trg_insert_individual_on_employment_insert` on table `employment` that fires `AFTER` `INSERT` for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_individual_on_employment_insert() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"individuals\" (\"id\", \"employed\", \"wage\", \"collgrad\", \"employment_sector\", \"employment_start_date\", \"employment_end_date\", \"income_source\", \"health_insurance\") \n    VALUES (NEW.\"id\", NEW.\"employed\", NEW.\"wage\", NEW.\"collgrad\", NEW.\"employment_sector\", NEW.\"employment_start_date\", NEW.\"employment_end_date\", NEW.\"income_source\", NEW.\"health_insurance\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trg_insert_individual_on_employment_insert\"\n    AFTER INSERT ON \"employment\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_individual_on_employment_insert();",
    "database_name": "demographic_and_employment_data_analysis_192071",
    "tables": [
      "individuals",
      "demographics",
      "employment"
    ],
    "call_sqls": [
      "INSERT INTO employment (id, employed, wage, collgrad, employment_sector, employment_start_date, employment_end_date, job_title, employer_name, income_source, health_insurance) VALUES (0, 1, 25.50, 1, 'Technology', '2022-01-15', NULL, 'Software Engineer', 'Tech Solutions Inc.', 'Wage', 1);",
      "INSERT INTO employment (id, employed, wage, collgrad, employment_sector, employment_start_date, employment_end_date, job_title, employer_name, income_source, health_insurance) VALUES (1, 0, 0.00, 0, NULL, NULL, NULL, NULL, NULL, 'Unemployed', 0);",
      "INSERT INTO employment (id, employed, wage, collgrad, employment_sector, employment_start_date, employment_end_date, job_title, employer_name, income_source, health_insurance) VALUES (2, 1, 15.75, 0, 'Retail', '2021-03-01', '2023-06-30', 'Sales Associate', 'Fashion Outlet', 'Wage', 1);",
      "INSERT INTO employment (id, employed, wage, collgrad, employment_sector, employment_start_date, employment_end_date, job_title, employer_name, income_source, health_insurance) VALUES (3, 1, 45.00, 1, 'Healthcare', '2019-09-01', NULL, 'Doctor', 'City Hospital', 'Wage', 1);",
      "INSERT INTO employment (id, employed, wage, collgrad, employment_sector, employment_start_date, employment_end_date, job_title, employer_name, income_source, health_insurance) VALUES (4, 0, 0.00, 0, NULL, NULL, NULL, NULL, NULL, 'Disability', 1);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named insert_individual_on_employment_insert that, after a new row is inserted into the employment table, automatically creates a corresponding record in the individuals table by copying the id, employed, wage, collgrad, employment_sector, employment_start_date, employment_end_date, income_source, and health_insurance values from the newly inserted employment row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called insert_individual_on_employment_insert that, after a new row is inserted into the employment table, automatically adds a corresponding row to the individuals table using the new record's id, employed status, wage, collgrad status, employment_sector, employment_start_date, employment_end_date, income_source, and health_insurance.",
    "id": 26,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_individual_on_employment_insert` that inserts a new row into the `individuals` table using values from the `NEW` record of the `employment` table, specifically mapping `NEW.\"id\"` to `individuals.\"id\"`, `NEW.\"employed\"` to `individuals.\"employed\"`, `NEW.\"wage\"` to `individuals.\"wage\"`, `NEW.\"collgrad\"` to `individuals.\"collgrad\"`, `NEW.\"employment_sector\"` to `individuals.\"employment_sector\"`, `NEW.\"employment_start_date\"` to `individuals.\"employment_start_date\"`, `NEW.\"employment_end_date\"` to `individuals.\"employment_end_date\"`, `NEW.\"income_source\"` to `individuals.\"income_source\"`, and `NEW.\"health_insurance\"` to `individuals.\"health_insurance\"`, and then returns `NEW`.\nSecond, define the trigger `trg_insert_individual_on_employment_insert` on table `employment` that fires `AFTER` `INSERT` for each row and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `insert_individual_on_employment_insert` that is designed to be executed automatically after an `INSERT` operation occurs on the `employment` table. This function does not accept any explicit input parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the row being inserted, updated, or deleted. In this specific case, since it's an `AFTER INSERT` trigger, the `NEW` record contains the data of the newly inserted row in the `employment` table. The function's primary operation is to perform an `INSERT` statement into the `individuals` table. The `INSERT` statement populates the following columns in the `individuals` table: `\"id\"`, `\"employed\"`, `\"wage\"`, `\"collgrad\"`, `\"employment_sector\"`, `\"employment_start_date\"`, `\"employment_end_date\"`, `\"income_source\"`, and `\"health_insurance\"`. The values for these columns are directly sourced from the corresponding columns of the `NEW` record, which represents the row just inserted into the `employment` table. Specifically, `NEW.\"id\"` provides the value for `individuals.\"id\"`, `NEW.\"employed\"` for `individuals.\"employed\"`, `NEW.\"wage\"` for `individuals.\"wage\"`, `NEW.\"collgrad\"` for `individuals.\"collgrad\"`, `NEW.\"employment_sector\"` for `individuals.\"employment_sector\"`, `NEW.\"employment_start_date\"` for `individuals.\"employment_start_date\"`, `NEW.\"employment_end_date\"` for `individuals.\"employment_end_date\"`, `NEW.\"income_source\"` for `individuals.\"income_source\"`, and `NEW.\"health_insurance\"` for `individuals.\"health_insurance\"`. After successfully executing this `INSERT` operation, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the original `INSERT` operation on the `employment` table should proceed as normal.\n\nThis trigger function is then associated with a trigger named `trg_insert_individual_on_employment_insert`. This trigger is configured to activate `AFTER INSERT` operations on the `employment` table. It is a `FOR EACH ROW` trigger, meaning the `insert_individual_on_employment_insert` function will be executed once for every single row that is inserted into the `employment` table. The trigger explicitly `EXECUTE FUNCTION insert_individual_on_employment_insert()`, thereby invoking the logic described above for each newly inserted row in the `employment` table.",
    "original_summary": "Create an AFTER INSERT trigger function named insert_individual_on_employment_insert. After a row is inserted into the employment table, insert a corresponding row into the individuals table. Copy the values for id, employed, wage, collgrad, employment_sector, employment_start_date, employment_end_date, income_source, and health_insurance from the NEW record to the individuals table. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create AFTER INSERT trigger insert_individual_on_employment_insert. On employment insert, add a row to individuals using NEW's id, employed, wage, collgrad, employment_sector, employment_start_date, employment_end_date, income_source, and health_insurance. Return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_order_status_on_user_deactivation` that updates the `orders` table by setting the `status` column to `'cancelled'` for all rows where the `user_id` matches the `NEW.user_id` and the current `status` is `'pending'`, then returns `NEW`. Second, define the trigger `trg_update_order_status` on table `users` that fires AFTER UPDATE OF the `is_active` column and executes the function, with a trigger condition specified using `WHEN (OLD.is_active = 1 AND NEW.is_active = 0)`.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_status_on_user_deactivation() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE orders SET status = 'cancelled' WHERE user_id = NEW.user_id AND status = 'pending';\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_status\nAFTER UPDATE OF is_active ON users\nFOR EACH ROW WHEN (OLD.is_active = 1 AND NEW.is_active = 0) EXECUTE FUNCTION update_order_status_on_user_deactivation();",
    "database_name": "fashion_size_conversion_and_measurement_tracking",
    "tables": [
      "brands",
      "order_items",
      "orders",
      "product_sizes",
      "products",
      "size_conversions",
      "size_measurements",
      "users"
    ],
    "call_sqls": [
      "UPDATE users SET is_active = 0 WHERE user_id = 1 AND is_active = 1;",
      "UPDATE users SET is_active = 0, updated_at = CURRENT_TIMESTAMP WHERE user_id = 5 AND is_active = 1;",
      "UPDATE users SET is_active = 0 WHERE user_id = 3;",
      "UPDATE users SET is_active = 0, last_login = '2024-01-15 10:30:00' WHERE user_id = 7 AND is_active = 1;",
      "UPDATE users SET is_active = 0 WHERE email = 'alice.johnson@example.com' AND is_active = 1;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_order_status that fires AFTER UPDATE on the users table when the is_active column changes from 1 to 0, and updates the orders table by setting the status to 'cancelled' for all orders where the user_id matches the deactivated user and the current status is 'pending'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_update_order_status that runs after an update to the is_active column on the users table, specifically when a user's is_active status changes from 1 (active) to 0 (inactive), to automatically update all pending orders in the orders table for that user to cancelled, and then returns the NEW record.",
    "id": 27,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_order_status_on_user_deactivation` that updates the `orders` table by setting the `status` column to `'cancelled'` for all rows where the `user_id` matches the `NEW.user_id` and the current `status` is `'pending'`, then returns `NEW`. Second, define the trigger `trg_update_order_status` on table `users` that fires AFTER UPDATE OF the `is_active` column and executes the function, with a trigger condition specified using `WHEN (OLD.is_active = 1 AND NEW.is_active = 0)`.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger that is activated after an update operation on the `users` table. This trigger specifically fires when the `is_active` column of a `users` record is changed from a value of `1` (representing an active user) to a value of `0` (representing a deactivated user). Upon activation, the trigger executes a function named `update_order_status_on_user_deactivation`. This function performs an `UPDATE` operation on the `orders` table. It sets the `status` column to the string literal `'cancelled'` for all rows in the `orders` table where two conditions are met: first, the `user_id` column matches the `user_id` of the `NEW` row (the row in the `users` table after the update that triggered the function), and second, the current value of the `status` column is equal to the string literal `'pending'`. After this update, the function returns the `NEW` row, which is the updated row from the `users` table that caused the trigger to fire.",
    "original_summary": "Create an AFTER UPDATE trigger on the users table that fires when is_active changes from 1 to 0. The trigger function should update the orders table, setting the status to 'cancelled' for all orders where the user_id matches the deactivated user and the current status is 'pending'. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that kicks in after someone updates the users table. Specifically, when a user's 'is_active' flag gets switched from 1 (active) to 0 (inactive). When that happens, the trigger's job is to go into the orders table and mark any 'pending' orders belonging to that now-deactivated user as 'cancelled'. Oh, and don't forget, the trigger should spit back the NEW record at the end."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_individual_last_updated` that sets the `last_updated` column of the NEW record to the current timestamp cast to text using `CURRENT_TIMESTAMP::text` and then returns the modified NEW record.\nSecond, define the trigger `trg_update_individual_last_updated` on table `individuals` that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_individual_last_updated() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.last_updated = CURRENT_TIMESTAMP::text;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_individual_last_updated\n    BEFORE UPDATE ON individuals\n    FOR EACH ROW\n    EXECUTE FUNCTION update_individual_last_updated();",
    "database_name": "demographic_and_socioeconomic_data_analysis_428440",
    "tables": [
      "data_sets",
      "data_sources",
      "data_versions",
      "individuals",
      "research_teams",
      "users",
      "user_roles"
    ],
    "call_sqls": [
      "UPDATE individuals SET age = 40 WHERE individual_id = 1;",
      "UPDATE individuals SET occupation = 'Manager' WHERE individual_id = 2;",
      "UPDATE individuals SET education = 'Masters', hours_per_week = 45 WHERE individual_id = 3;",
      "UPDATE individuals SET marital_status = 'Married' WHERE age > 30;",
      "UPDATE individuals SET capital_gain = 5000, last_updated = '2023-01-01' WHERE individual_id = 5;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_individual_last_updated that, before any update on the individuals table, automatically sets the last_updated column to the current timestamp for each row being updated.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_update_individual_last_updated that fires BEFORE UPDATE on the individuals table, setting the NEW.last_updated column to the current timestamp as text and then returning NEW.",
    "id": 28,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `update_individual_last_updated`. This function is designed to be executed as a trigger on the `individuals` table. The function takes no explicit parameters but operates on the `NEW` pseudo-record, which represents the row being updated. The function's primary purpose is to automatically update the `last_updated` column of the `individuals` table for the row that is about to be updated. Specifically, it sets the value of `NEW.last_updated` to the current timestamp, converted to a text string. This is achieved by calling the PostgreSQL function `CURRENT_TIMESTAMP`, which returns a timestamp with time zone, and then implicitly or explicitly casting it to text to match the column's data type. The function then returns the `NEW` record, which now includes the updated `last_updated` value, allowing the `UPDATE` operation to proceed with this modified row. This ensures that every time a row in the `individuals` table is updated, its `last_updated` column is automatically refreshed to reflect the time of the update.\n\nSecond, define the trigger `trg_update_individual_last_updated` on the `individuals` table. This trigger is configured to activate `BEFORE` any `UPDATE` operation on the `individuals` table. The `FOR EACH ROW` clause specifies that the trigger function `update_individual_last_updated()` will be executed once for every row affected by the `UPDATE` statement. The `EXECUTE FUNCTION update_individual_last_updated()` clause explicitly calls the previously defined `update_individual_last_updated` function to perform the timestamp update logic for each row. The trigger ensures that the `last_updated` column is consistently maintained without requiring manual input during `UPDATE` operations.",
    "original_ir": "Write a PLpgSQL function named update_individual_last_updated that is designed to be used as a trigger function. This function does not take any parameters directly but operates on the NEW record, which represents the row being updated in the individuals table. The function sets the last_updated column of the NEW record to the current timestamp, converted to text format using the PostgreSQL type casting syntax CURRENT_TIMESTAMP::text. The function then returns the modified NEW record. Additionally, create a trigger named trg_update_individual_last_updated that is associated with the individuals table. This trigger is set to fire before any update operation on each row of the individuals table. When an update occurs, the trigger executes the update_individual_last_updated function, ensuring that the last_updated column of the affected row is updated to reflect the current timestamp at the time of the update.",
    "original_summary": "Create a BEFORE UPDATE trigger function named update_individual_last_updated for the individuals table. For each updated row, set the NEW.last_updated column to CURRENT_TIMESTAMP::text. Return the modified NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create BEFORE UPDATE trigger update_individual_last_updated on individuals to set NEW.last_updated to CURRENT_TIMESTAMP::text. Return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function adjust_player_weight_on_blocks that updates the players table by setting the weight column to its current value plus twice the NEW.blocks value, specifically for the row where player_id matches NEW.player_id, and then returns NEW.\nSecond, define the trigger trg_adjust_player_weight_on_blocks on table player_performance that fires AFTER UPDATE OF blocks and executes the function adjust_player_weight_on_blocks.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_player_weight_on_blocks() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE players SET weight = weight + (NEW.blocks * 2) WHERE player_id = NEW.player_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_adjust_player_weight_on_blocks\nAFTER UPDATE OF blocks ON player_performance\nFOR EACH ROW EXECUTE FUNCTION adjust_player_weight_on_blocks();",
    "database_name": "sports_team_performance_analysis_891414",
    "tables": [
      "player_performance",
      "players"
    ],
    "call_sqls": [
      "UPDATE player_performance SET blocks = 3 WHERE performance_id = 0;",
      "UPDATE player_performance SET blocks = 4 WHERE performance_id = 1;",
      "UPDATE player_performance SET blocks = 5 WHERE performance_id = 0;",
      "UPDATE player_performance SET blocks = 6 WHERE performance_id = 1;",
      "UPDATE player_performance SET blocks = 7 WHERE performance_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_adjust_player_weight_on_blocks that fires AFTER an UPDATE of the blocks column on the player_performance table for each row, and updates the players table by increasing the weight by twice the new blocks value for the corresponding player_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_adjust_player_weight_on_blocks that fires after the blocks column is updated in the player_performance table for each modified row, and updates the players table by increasing the player's weight by twice the new blocks value based on the matching player_id, then returns the NEW row.",
    "id": 29,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function adjust_player_weight_on_blocks that updates the players table by setting the weight column to its current value plus twice the NEW.blocks value, specifically for the row where player_id matches NEW.player_id, and then returns NEW.\nSecond, define the trigger trg_adjust_player_weight_on_blocks on table player_performance that fires AFTER UPDATE OF blocks and executes the function adjust_player_weight_on_blocks.",
    "original_ir": "Write a PLpgSQL trigger function that updates the players table by increasing the weight column by twice the value of the blocks column from the newly updated row in the player_performance table, specifically for the row where the player_id matches the player_id of the newly updated row. This function is executed by a trigger named trg_adjust_player_weight_on_blocks, which is set to activate after any update operation on the blocks column of the player_performance table. The trigger ensures that for each row affected by the update, the corresponding player's weight is adjusted accordingly in the players table. The function returns the new row data after performing the update operation.",
    "original_summary": "Create a trigger function named trg_adjust_player_weight_on_blocks that fires AFTER UPDATE OF blocks ON player_performance FOR EACH ROW. It updates the players table, setting weight = weight + (2 * NEW.blocks) where player_id = NEW.player_id, and returns NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger function called trg_adjust_player_weight_on_blocks. It should kick in right after the 'blocks' field gets updated in the player_performance table, for each row that's changed. What it does is pretty straightforward: it goes to the players table and bumps up the player's weight by adding twice the new blocks value. It just finds the right player using the player_id from the new data. Oh, and at the end, it should just return the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function update_server_info that updates the server_info table by setting the last_sync_ts column to the current timestamp cast to text format, using the condition WHERE server_id = NEW.server_id, and returns the NEW row. Second, define the trigger update_server_trigger on table user_server_sync that fires AFTER INSERT and executes the function update_server_info.",
    "plsql": "CREATE OR REPLACE FUNCTION update_server_info() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE server_info SET last_sync_ts = CURRENT_TIMESTAMP::text WHERE server_id = NEW.server_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_server_trigger\nAFTER INSERT ON user_server_sync\nFOR EACH ROW EXECUTE FUNCTION update_server_info();",
    "database_name": "user_activity_and_status_tracking",
    "tables": [
      "server_info",
      "user_activity",
      "user_server_sync",
      "user_status"
    ],
    "call_sqls": [
      "INSERT INTO user_server_sync (sync_id, user_id, server_id, sync_ts) VALUES (100, '@testuser:example.com', 1, '1570040279284');",
      "INSERT INTO user_server_sync (sync_id, user_id, server_id, sync_ts) VALUES (101, '@anotheruser:example.com', 2, '1570040284126');",
      "INSERT INTO user_server_sync (sync_id, user_id, server_id, sync_ts) VALUES (102, '@user3:example.com', 1, '1570040290000');",
      "INSERT INTO user_server_sync (sync_id, user_id, server_id, sync_ts) VALUES (103, '@user4:example.com', 3, '1570040300000');",
      "INSERT INTO user_server_sync (sync_id, user_id, server_id, sync_ts) VALUES (104, '@user5:example.com', 2, '1570040310000');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_server_trigger that fires AFTER INSERT on the user_server_sync table, and for each new row, updates the server_info table by setting the last_sync_ts column to the current timestamp as text where the server_id matches the inserted row's server_id, then returns the NEW row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_server_trigger that, after each new row is inserted into the user_server_sync table, updates the last_sync_ts field in the server_info table to the current timestamp as text where the server_id matches, and then returns the NEW row.",
    "id": 30,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named update_server_info that is designed to be executed as a trigger. This function does not accept any explicit parameters but operates within the context of a trigger event, implicitly receiving special NEW and OLD records. The function is intended to run after an INSERT operation on the user_server_sync table, for each row that is inserted. In this context, the NEW record contains the data of the newly inserted row in the user_server_sync table, including columns such as sync_id, user_id, server_id, and sync_ts. The OLD record is not applicable since the trigger fires after INSERT.\n\nThe function's primary purpose is to update the last_sync_ts column in the server_info table. Specifically, it sets the last_sync_ts value to the current timestamp, formatted as text, for the row in the server_info table where the server_id matches the server_id from the newly inserted row in the user_server_sync table. The current timestamp is obtained using the PostgreSQL function EXTRACT(EPOCH FROM NOW()) * 1000, which returns the current Unix epoch time in milliseconds as a numeric value. This numeric value is then cast to text using the ::text cast to match the text data type of the last_sync_ts column. The update is performed via an UPDATE statement on the server_info table, with a WHERE clause that filters rows where server_id equals NEW.server_id. This ensures that only the server_info row corresponding to the server_id from the new user_server_sync entry is updated.\n\nAfter executing the UPDATE statement, the function returns the NEW record, which is the newly inserted row from the user_server_sync table. Returning NEW is standard practice for AFTER triggers in PostgreSQL and does not affect the original INSERT operation.\n\nSecond, define a trigger named update_server_trigger on the user_server_sync table. This trigger is configured to activate AFTER INSERT operations on the user_server_sync table. It is specified to execute FOR EACH ROW, meaning the update_server_info() function will be invoked once for every row inserted into user_server_sync. The trigger explicitly EXECUTE FUNCTION update_server_info(), thereby linking the trigger event to the execution of the described PL/pgSQL function.",
    "original_ir": "Write a PLpgSQL trigger function that updates the server_info table by setting the last_sync_ts column to the current timestamp, converted to text format, for the row where the server_id matches the server_id of the newly inserted row in the user_server_sync table. This function is executed by a trigger named update_server_trigger, which is defined to fire after an insert operation on the user_server_sync table, and it operates on each row that is inserted. The function returns the newly inserted row after performing the update operation.",
    "original_summary": "Create an AFTER INSERT trigger function on user_server_sync table. For each new row, update the server_info table: set last_sync_ts to current timestamp as text, where server_id matches. Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "For each new row inserted into the user_server_sync table, update the last_sync_ts field in the server_info table to the current timestamp as text where the server_id matches, and then return the NEW row. Implement this as an AFTER INSERT trigger function."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `sync_buyer_registration` that calculates the next `buyer_id` by selecting `COALESCE(MAX(buyer_id), 0) + 1` from the `buyers` table, then inserts a new row into the `buyers` table using values from the `NEW` record, applying `LOWER` and `COALESCE` functions to `seller_name` (defaulting to 'Unknown'), `seller_type` (defaulting to 'individual'), and `status` (defaulting to 'active'), while setting `registration_date` and `last_updated_date` to `CURRENT_DATE` cast as text.\nSecond, define the trigger `trg_sync_buyer_registration` on table `sellers` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION sync_buyer_registration() RETURNS TRIGGER AS $$\nDECLARE\n    next_buyer_id bigint;\nBEGIN\n    SELECT COALESCE(MAX(buyer_id), 0) + 1 INTO next_buyer_id FROM buyers;\n    \n    INSERT INTO buyers (\n        buyer_id, \n        buyer_name, \n        contact_email, \n        contact_phone, \n        address, \n        buyer_type, \n        tax_id, \n        registration_date, \n        last_updated_date, \n        status\n    ) VALUES (\n        next_buyer_id,\n        LOWER(COALESCE(NEW.seller_name, 'Unknown')),\n        NEW.contact_email,\n        NEW.contact_phone,\n        NEW.address,\n        COALESCE(NEW.seller_type, 'individual'),\n        NEW.tax_id,\n        CURRENT_DATE::text,\n        CURRENT_DATE::text,\n        COALESCE(NEW.status, 'active')\n    );\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_sync_buyer_registration\nAFTER INSERT ON sellers\nFOR EACH ROW EXECUTE FUNCTION sync_buyer_registration();",
    "database_name": "real_estate_and_property_management_58871",
    "tables": [
      "properties",
      "owners",
      "property_sales",
      "buyers",
      "sellers",
      "property_units"
    ],
    "call_sqls": [
      "INSERT INTO sellers (seller_id, seller_name, contact_email, contact_phone, address, seller_type, tax_id, registration_date, last_updated_date, status) VALUES (2, 'New Seller Corp', 'newseller@example.com', '987-654-3210', '456 Seller Ave, 10001', 'corporation', '999-88-7777', '2023-01-01', '2023-01-01', 'active');",
      "INSERT INTO sellers (seller_id, seller_name, contact_email, contact_phone, address, seller_type, tax_id, registration_date, last_updated_date, status) VALUES (3, 'Individual Seller', 'indivseller@example.com', '111-222-3333', '789 Main St, 10002', 'individual', '111-22-3333', '2023-02-01', '2023-02-01', 'active');",
      "INSERT INTO sellers (seller_id, seller_name, contact_email, contact_phone, address, seller_type, tax_id, registration_date, last_updated_date, status) VALUES (4, 'Another Corp', 'anothercorp@example.com', '444-555-6666', '101 Business Rd, 10003', 'corporation', '444-55-6666', '2023-03-01', '2023-03-01', 'inactive');",
      "INSERT INTO sellers (seller_id, seller_name, contact_email, contact_phone, address, seller_type, tax_id, registration_date, last_updated_date, status) VALUES (5, 'Test Seller', 'test@example.com', '777-888-9999', '202 Test Lane, 10004', 'individual', '777-88-9999', '2023-04-01', '2023-04-01', 'active');",
      "INSERT INTO sellers (seller_id, seller_name, contact_email, contact_phone, address, seller_type, tax_id, registration_date, last_updated_date, status) VALUES (6, 'Final Seller LLC', 'final@example.com', '000-111-2222', '303 Final Blvd, 10005', 'corporation', '000-11-2222', '2023-05-01', '2023-05-01', 'active');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `sync_buyer_registration` that executes after each row is inserted into the `sellers` table. It automatically registers a corresponding buyer by inserting a new row into the `buyers` table. The trigger calculates the next `buyer_id` as one more than the highest existing `buyer_id` in the `buyers` table (starting at 1 if none exist). It uses data from the new seller row: the `seller_name` (converted to lowercase, defaulting to 'Unknown' if NULL) becomes `buyer_name`, while `contact_email`, `contact_phone`, `address`, and `tax_id` are copied directly. It sets `buyer_type` to the seller's `seller_type` (defaulting to 'individual' if NULL), `status` to the seller's `status` (defaulting to 'active' if NULL), and both `registration_date` and `last_updated_date` to the current date. The trigger then returns the NEW record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named `trg_sync_buyer_registration` that, after each new row is inserted into the `sellers` table, automatically creates a corresponding record in the `buyers` table. For the new buyer, set the `buyer_id` to one more than the highest existing `buyer_id`, starting from 0 if the table is empty. Populate the buyer's details using the new seller's data: use the `seller_name` (converted to lowercase, defaulting to 'Unknown' if NULL) for `buyer_name`, copy `contact_email`, `contact_phone`, `address`, and `tax_id` directly, set `buyer_type` to the `seller_type` (defaulting to 'individual' if NULL), set both `registration_date` and `last_updated_date` to today's date, and set `status` to the seller's `status` (defaulting to 'active' if NULL). Return the new seller row.",
    "id": 31,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named `sync_buyer_registration` that returns a trigger and is executed as an `AFTER INSERT` trigger on the `sellers` table for each row. The function implicitly receives the special variable `NEW`, which represents the newly inserted row in the `sellers` table. The function declares a variable `max_buyer_id` of type `bigint` to store the highest existing `buyer_id` from the `buyers` table. It performs a `SELECT` operation to retrieve the maximum value of the `buyer_id` column from the `buyers` table. If the `buyers` table is empty, the `max_buyer_id` is set to `-1` to handle the case where no rows exist. The function then performs an `INSERT` operation into the `buyers` table. The `buyer_id` for the new row is calculated as `max_buyer_id + 1`, ensuring it starts from `0` if the table was empty. The `buyer_name` is populated by taking the `seller_name` from the `NEW` row, converting it to lowercase using the `LOWER` function, and defaulting to the string `'Unknown'` if the `seller_name` is `NULL`. The `contact_email`, `contact_phone`, `address`, and `tax_id` are copied directly from the corresponding columns in the `NEW` row. The `buyer_type` is set to the `seller_type` from the `NEW` row, defaulting to the string `'individual'` if `seller_type` is `NULL`. Both `registration_date` and `last_updated_date` are set to the current date using the `CURRENT_DATE` function. The `status` is set to the `status` from the `NEW` row, defaulting to the string `'active'` if `status` is `NULL`. After the `INSERT` operation, the function returns the `NEW` row from the `sellers` table. Second, define the trigger `trg_sync_buyer_registration` on the `sellers` table. The trigger is configured to activate `AFTER INSERT` operations on the `sellers` table. It is specified to execute `FOR EACH ROW`, meaning that for every row inserted into the `sellers` table, the `sync_buyer_registration()` function will be invoked. The `EXECUTE FUNCTION sync_buyer_registration()` clause specifies that the `sync_buyer_registration` function should be executed when the trigger fires.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `sync_buyer_registration` that is designed to be executed as a trigger. This function does not accept any explicit input parameters but operates on the `NEW` pseudo-record provided by the trigger context. It returns a `TRIGGER` type, indicating its role as a trigger function. The function begins by declaring a local variable named `next_buyer_id` of type `bigint`. Inside the function's `BEGIN` block, the first operation is a `SELECT` statement that calculates the next available `buyer_id`. This is achieved by querying the `buyers` table, specifically selecting the maximum value of the `buyer_id` column. The `COALESCE` function is used to handle cases where the `buyers` table might be empty, in which case `MAX(buyer_id)` would return `NULL`; `COALESCE` replaces this `NULL` with `0`. This result is then incremented by `1` to determine the `next_buyer_id`, which is subsequently stored in the `next_buyer_id` local variable. Following this, an `INSERT` statement is executed to add a new row into the `buyers` table. The columns being populated in the `buyers` table are `buyer_id`, `buyer_name`, `contact_email`, `contact_phone`, `address`, `buyer_type`, `tax_id`, `registration_date`, `last_updated_date`, and `status`. The values for these columns are derived as follows: `buyer_id` is set to the previously calculated `next_buyer_id`. `buyer_name` is set to the lowercase version of the `seller_name` from the `NEW` pseudo-record, using the `LOWER` function. If `NEW.seller_name` is `NULL`, `COALESCE` ensures that 'Unknown' is used instead. `contact_email` is directly taken from `NEW.contact_email`. `contact_phone` is directly taken from `NEW.contact_phone`. `address` is directly taken from `NEW.address`. `buyer_type` is taken from `NEW.seller_type`, but if `NEW.seller_type` is `NULL`, `COALESCE` ensures that 'individual' is used instead. `tax_id` is directly taken from `NEW.tax_id`. `registration_date` is set to the current date, obtained using `CURRENT_DATE` and then explicitly cast to `text`. `last_updated_date` is also set to the current date, obtained using `CURRENT_DATE` and then explicitly cast to `text`. `status` is taken from `NEW.status`, but if `NEW.status` is `NULL`, `COALESCE` ensures that 'active' is used instead. After the `INSERT` operation, the function concludes by returning the `NEW` pseudo-record, which is a standard requirement for `AFTER` triggers.\n\nA trigger named `trg_sync_buyer_registration` is created to automatically execute the `sync_buyer_registration()` function. This trigger is configured to activate `AFTER INSERT` operations on the `sellers` table. It is specified to execute `FOR EACH ROW`, meaning that for every row inserted into the `sellers` table, the `sync_buyer_registration()` function will be invoked. The `EXECUTE FUNCTION sync_buyer_registration()` clause specifies the function to be called when the trigger fires.",
    "original_summary": "Create a PostgreSQL trigger function named `sync_buyer_registration` that runs after each row is inserted into the `sellers` table. The function calculates the next `buyer_id` by taking the maximum existing ID from the `buyers` table (or 0 if empty) and adding 1. It then inserts a new row into the `buyers` table using values from the new seller row, applying default values where source data is NULL, and returns the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create trigger `sync_buyer_registration` after insert on `sellers`. For each row, insert into `buyers` using new seller data with defaults for NULLs. Set `buyer_id` to max existing ID plus one, starting at 0 if empty. Return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_device_access` that inserts a new record into the `device_access_logs` table, using `COALESCE` to default the maximum `access_id` to -1 if the table is empty and then adding 1 to generate a sequential ID, populating `device_id` and `user_id` from the `NEW` record, setting `access_date` from `NEW.review_date`, and using the static strings 'review' for `access_type` and 'User reviewed the device' for `notes`.\nSecond, define the trigger `trg_log_device_access` on table `device_reviews` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_device_access() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO device_access_logs (access_id, device_id, user_id, access_date, access_type, notes)\n    VALUES (COALESCE((SELECT MAX(access_id) FROM device_access_logs), -1) + 1, \n            NEW.device_id, NEW.user_id, NEW.review_date, 'review', 'User reviewed the device');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_device_access\nAFTER INSERT ON device_reviews\nFOR EACH ROW EXECUTE FUNCTION log_device_access();",
    "database_name": "mobile_device_specifications_and_analytics",
    "tables": [
      "users",
      "user_roles",
      "device_access_logs",
      "device_reviews",
      "device_comparisons"
    ],
    "call_sqls": [
      "INSERT INTO device_reviews (review_id, device_id, user_id, rating, review_text, review_date) VALUES (2, 1, 1, 5, 'Excellent device for gaming', '2023-01-03');",
      "INSERT INTO device_reviews (review_id, device_id, user_id, rating, review_text, review_date) VALUES (3, 2, 0, 4, 'Good battery life', '2023-01-04');",
      "INSERT INTO device_reviews (review_id, device_id, user_id, rating, review_text, review_date) VALUES (4, 1, 1, 3, 'Average performance', '2023-01-05');",
      "INSERT INTO device_reviews (review_id, device_id, user_id, rating, review_text, review_date) VALUES (5, 2, 0, 5, 'Highly recommend', '2023-01-06');",
      "INSERT INTO device_reviews (review_id, device_id, user_id, rating, review_text, review_date) VALUES (6, 1, 1, 4, 'Good value for money', '2023-01-07');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_log_device_access that, after each INSERT on the device_reviews table, logs the access by inserting a record into the device_access_logs table. The trigger should generate a new access_id as one more than the highest existing access_id in device_access_logs, starting from 0 if none exist, and populate device_id and user_id from the inserted row, set access_date from the inserted review_date, set access_type to 'review', and set notes to 'User reviewed the device'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called log_device_access that, after a new row is inserted into the device_reviews table, logs an entry in the device_access_logs table. For each new review, it should generate a new access_id by incrementing the highest existing access_id by one, or start at 0 if no logs exist yet. It takes the device_id and user_id from the new row, uses the review_date as the access_date, sets the access_type to 'review', and adds a note indicating the user reviewed the device. The trigger should return the new row.",
    "id": 32,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_device_access` that inserts a new record into the `device_access_logs` table, using `COALESCE` to default the maximum `access_id` to -1 if the table is empty and then adding 1 to generate a sequential ID, populating `device_id` and `user_id` from the `NEW` record, setting `access_date` from `NEW.review_date`, and using the static strings 'review' for `access_type` and 'User reviewed the device' for `notes`.\nSecond, define the trigger `trg_log_device_access` on table `device_reviews` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PL/pgSQL function named `log_device_access` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the row being inserted, updated, or deleted. The function is declared to return `TRIGGER`, indicating its role as a trigger function. The core operation of this function is to insert a new record into the `device_access_logs` table. The values for the columns in `device_access_logs` are determined as follows: for the `access_id` column, it calculates a new ID by first selecting the maximum `access_id` from the `device_access_logs` table. If no records exist in `device_access_logs` (i.e., `MAX(access_id)` returns `NULL`), it defaults to `-1` using the `COALESCE` function, and then adds `1` to this value to generate a unique, sequential ID. For the `device_id` column, it uses the value from the `device_id` column of the `NEW` record, which represents the row that just triggered this function. For the `user_id` column, it uses the value from the `user_id` column of the `NEW` record. For the `access_date` column, it uses the value from the `review_date` column of the `NEW` record. For the `access_type` column, it inserts the static string literal `'review'`. For the `notes` column, it inserts the static string literal `'User reviewed the device'`. After performing this insertion, the function returns the `NEW` record, which is standard behavior for `BEFORE` or `AFTER` row-level triggers that do not modify the `NEW` record.\n\nAdditionally, a trigger named `trg_log_device_access` is created. This trigger is configured to execute `AFTER INSERT` operations on the `device_reviews` table. It is a `FOR EACH ROW` trigger, meaning it will execute the associated function once for every row that is inserted into the `device_reviews` table. The function executed by this trigger is `log_device_access()`. Therefore, whenever a new row is successfully inserted into the `device_reviews` table, the `log_device_access` function will be invoked to record this event in the `device_access_logs` table.",
    "original_summary": "Create a PostgreSQL trigger function named log_device_access that returns TRIGGER. The function should insert a record into device_access_logs after an INSERT on device_reviews. The access_id should be calculated as MAX(access_id) + 1 from device_access_logs, defaulting to 0 if NULL. Populate device_id and user_id from NEW, set access_date from NEW.review_date, access_type to 'review', and notes to 'User reviewed the device'. Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a trigger function for PostgreSQL called log_device_access that gives back a TRIGGER. After a new entry goes into device_reviews, it should add a log to device_access_logs. For the access_id, figure it out by taking the biggest existing access_id and adding one to it, or just start at 0 if there's nothing there yet. Grab the device_id and user_id from the new row, use the review_date from that new row for the access_date, mark the access_type as something like 'review', and maybe put a note saying the user looked at the device. Just hand back the new row at the end."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_review_metrics` that validates the incoming `commit_id` from the `NEW` row by checking for its existence in the `commits` table and raises an exception with the message 'commit_id [value] does not exist in commits table' if not found; if valid, it proceeds to insert a new record into the `reviewer_metrics` table, populating the columns `reviewer_id`, `developer_id`, `review_date`, `review_status`, `review_comments`, `review_duration`, and `number_of_findings` with the corresponding values from the `NEW` row's `review_id`, `developer_id`, `review_date`, `review_status`, `review_comments`, `review_duration`, and `number_of_findings` columns, and includes an `ON CONFLICT (reviewer_id) DO NOTHING` clause. Second, define the trigger `trg_update_review_metrics` on table `code_reviews` that fires `BEFORE` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_review_metrics() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if commit_id exists in commits table\n  IF NOT EXISTS (SELECT 1 FROM commits WHERE commit_id = NEW.commit_id) THEN\n    RAISE EXCEPTION 'commit_id % does not exist in commits table', NEW.commit_id;\n  END IF;\n  \n  INSERT INTO reviewer_metrics (reviewer_id, developer_id, review_date, review_status, review_comments, review_duration, number_of_findings)\n  VALUES (\n    NEW.review_id,\n    NEW.developer_id,\n    NEW.review_date,\n    NEW.review_status,\n    NEW.review_comments,\n    NEW.review_duration,\n    NEW.number_of_findings\n  )\n  ON CONFLICT (reviewer_id) DO NOTHING;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_review_metrics\nBEFORE INSERT ON code_reviews\nFOR EACH ROW EXECUTE FUNCTION update_review_metrics();",
    "database_name": "software_development_and_collaboration_metrics",
    "tables": [
      "developers",
      "projects",
      "repositories",
      "commits",
      "issues",
      "code_reviews",
      "bug_ownership",
      "resolution_times",
      "repository_changes",
      "reviewer_metrics"
    ],
    "call_sqls": [
      "INSERT INTO code_reviews (review_id, commit_id, developer_id, review_date, review_status, review_comments, review_duration, number_of_findings) VALUES (100, 1, 0, '2023-05-15', 'approved', 'All changes look good.', 2.5, 0);",
      "INSERT INTO code_reviews (review_id, commit_id, developer_id, review_date, review_status, review_comments, review_duration, number_of_findings) VALUES (101, 2, 1, '2023-05-16', 'rejected', 'Please fix the syntax errors.', 1.8, 3);",
      "INSERT INTO code_reviews (review_id, commit_id, developer_id, review_date, review_status, review_comments, review_duration, number_of_findings) VALUES (102, 0, 0, '2023-05-17', 'approved', 'Minor improvements suggested.', 3.2, 1);",
      "INSERT INTO code_reviews (review_id, commit_id, developer_id, review_date, review_status, review_comments, review_duration, number_of_findings) VALUES (103, 1, 1, '2023-05-18', 'approved', 'Ready to merge.', 0.9, 0);",
      "INSERT INTO code_reviews (review_id, commit_id, developer_id, review_date, review_status, review_comments, review_duration, number_of_findings) VALUES (104, 0, 1, '2023-05-19', 'rejected', 'Needs more unit tests.', 4.1, 5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_review_metrics that, before inserting a row into the code_reviews table, validates that the new commit_id exists in the commits table, raising an error if it does not; if valid, it inserts corresponding data from the new row into the reviewer_metrics table, ignoring any conflict on reviewer_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_review_metrics that, before inserting a row into the code_reviews table, validates that the new commit_id exists in the commits table, raising an error if it does not; if valid, it inserts corresponding data into the reviewer_metrics table, ignoring any conflict on reviewer_id, and returns the new row.",
    "id": 33,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `update_review_metrics` in the `software_development_and_collaboration_metrics` database. This function is designed to be executed before an `INSERT` operation on the `code_reviews` table, for each row. The function implicitly receives the special `NEW` record variable representing the row to be inserted. The function's purpose is to enforce referential integrity for the `commit_id` column and to propagate data into the `reviewer_metrics` table.\n\nUpon execution, the function first performs a validation check. It uses a `SELECT` statement with the `EXISTS` operator to verify that a row exists in the `commits` table where the `commit_id` column matches the value of `NEW.commit_id` (the `commit_id` from the row being inserted into `code_reviews`). If the `EXISTS` condition returns `FALSE`, meaning no matching `commit_id` is found in the `commits` table, the function raises an exception with the error message 'Invalid commit_id'. This prevents the `INSERT` operation on `code_reviews` from proceeding.\n\nIf the validation passes (i.e., the `EXISTS` condition returns `TRUE`), the function proceeds to insert a corresponding row into the `reviewer_metrics` table. The insertion uses an `INSERT INTO ... ON CONFLICT DO NOTHING` statement. The data for the insertion is derived from the `NEW` record and a sequence. Specifically, the `reviewer_id` column is populated by retrieving the next value from a sequence named `reviewer_metrics_reviewer_id_seq` using the `nextval()` function. The `developer_id` column is set to the value of `NEW.developer_id`. The `review_date` column is set to the value of `NEW.review_date`. The `review_status` column is set to the value of `NEW.review_status`. The `review_comments` column is set to the value of `NEW.review_comments`. The `review_duration` column is set to the value of `NEW.review_duration`. The `number_of_findings` column is set to the value of `NEW.number_of_findings`. The `ON CONFLICT DO NOTHING` clause specifies that if a conflict occurs on the `reviewer_id` column (which is the primary key), the insertion should be silently skipped without raising an error.\n\nAfter performing the insertion attempt into `reviewer_metrics`, the function returns the `NEW` row record. This allows the original `INSERT` operation on the `code_reviews` table to proceed normally.\n\nSecond, define the trigger named `trg_update_review_metrics` on the `code_reviews` table. This trigger is configured to fire `BEFORE INSERT` on the `code_reviews` table, `FOR EACH ROW`, and it executes the `update_review_metrics()` function.",
    "original_ir": "Write a PostgreSQL trigger function named update_review_metrics that is executed automatically by a trigger named trg_update_review_metrics before each new row is inserted into the code_reviews table, and this function first validates the incoming data by checking if the new commit_id value from the inserted row exists in the commits table using a SELECT statement on the commits table with the condition WHERE commit_id = NEW.commit_id, and if no matching row is found, it raises an exception with the message 'commit_id [value] does not exist in commits table', halting the insert; if the validation passes, the function proceeds to insert a new record into the reviewer_metrics table, populating the columns reviewer_id, developer_id, review_date, review_status, review_comments, review_duration, and number_of_findings with the corresponding values from the NEW row's review_id, developer_id, review_date, review_status, review_comments, review_duration, and number_of_findings columns respectively, and this insert operation includes an ON CONFLICT clause specifying that if a conflict arises on the reviewer_id column, which is presumably a unique or primary key constraint, the insert should do nothing and not raise an error; finally, the function returns the NEW row record to allow the triggering INSERT operation on code_reviews to proceed.",
    "original_summary": "Create a BEFORE INSERT trigger function named update_review_metrics that validates the new commit_id exists in the commits table. If not found, raise an exception. If valid, insert corresponding data into reviewer_metrics with an ON CONFLICT (reviewer_id) DO NOTHING clause. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a BEFORE INSERT trigger function called update_review_metrics that checks if the new commit_id is present in the commits table, raises an exception if it is not, inserts data into reviewer_metrics with an ON CONFLICT (reviewer_id) DO NOTHING clause if it is valid, and returns NEW?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_order_status` that checks if the `NEW.actual_delivery_date` is NOT NULL and if the `NEW.status` is DISTINCT FROM the string 'completed', then sets `NEW.status` to 'completed'. Second, define the trigger `trg_update_order_status` on table `orders` that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_status() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.actual_delivery_date IS NOT NULL AND NEW.status IS DISTINCT FROM 'completed' THEN\n    NEW.status = 'completed';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_status\nBEFORE UPDATE ON orders\nFOR EACH ROW EXECUTE FUNCTION update_order_status();",
    "database_name": "supply_chain_management_and_supplier_warehouse_tracking",
    "tables": [
      "orders"
    ],
    "call_sqls": [
      "UPDATE orders SET actual_delivery_date = '2023-05-12' WHERE order_id = 0;",
      "UPDATE orders SET actual_delivery_date = '2023-05-13' WHERE order_id = 1;",
      "UPDATE orders SET actual_delivery_date = '2023-05-14' WHERE order_id = 0;",
      "UPDATE orders SET actual_delivery_date = '2023-05-15' WHERE order_id = 1;",
      "UPDATE orders SET actual_delivery_date = '2023-05-16' WHERE order_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_order_status that, before updating a row in the ORDERS table, checks if the new ACTUAL_DELIVERY_DATE is not NULL and the new STATUS is different from 'completed'; if both conditions are met, it automatically sets the STATUS to 'completed' for that row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_order_status that, before updating any row in the orders table, checks if the new actual_delivery_date is provided and the status is not 'completed', and if so, changes the status to 'completed', then returns the updated NEW row.",
    "id": 34,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named update_order_status that is designed to execute before an update operation on any row in the orders table within the supply_chain_management_and_supplier_warehouse_tracking database. The function uses the NEW record to access the updated row's values. It checks two conditions: whether the new actual_delivery_date is not null (i.e., provided) and whether the current status from the NEW record is not equal to the string 'completed'. If both conditions are true, the function modifies the status field of the NEW record to 'completed'. This change ensures that when an actual delivery date is set and the order is not already marked as completed, the status is automatically updated to completed. The function then returns the NEW row, which includes any modifications made to the status, allowing the update operation to proceed with the adjusted values. Second, define the trigger trg_update_order_status on the orders table, specifying that it should fire before each row update, executing the update_order_status function for every affected row to enforce the business logic automatically.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger that, before an update operation is performed on any row in the `orders` table, executes a function named `update_order_status`. This function is defined to return a `TRIGGER` type, indicating its use within a trigger context. The function operates on the `NEW` record, which represents the row's state *after* the update but *before* it is committed to the database. Inside the function, a conditional statement checks two conditions: first, if the `actual_delivery_date` column of the `NEW` record is not `NULL`, and second, if the `status` column of the `NEW` record is distinct from the literal string value `'completed'`. The `IS DISTINCT FROM` operator is used for this comparison, which handles `NULL` values differently than the standard `!=` or `<>` operators (e.g., `NULL IS DISTINCT FROM 'completed'` is true, while `NULL != 'completed'` is unknown). If both of these conditions are true, meaning an `actual_delivery_date` has been provided and the order's status is not already 'completed', then the `status` column of the `NEW` record is updated to the literal string value `'completed'`. Finally, the function returns the `NEW` record, which contains the potentially modified `status` value, allowing the update operation on the `orders` table to proceed with these changes. The trigger `trg_update_order_status` is configured to fire `BEFORE` any `UPDATE` operation on the `orders` table, and it executes `FOR EACH ROW`, meaning the `update_order_status` function will be invoked once for every row that is being updated.",
    "original_summary": "Create a trigger function named update_order_status that returns a trigger. Before updating a row in the orders table, if the new row's actual_delivery_date is not NULL and its status is distinct from 'completed', set the new row's status to 'completed'. Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Define a trigger function called update_order_status that returns a trigger. Before any row update in the orders table, if the new row's actual_delivery_date is provided and the status is not 'completed', change the status to 'completed'. Then, return the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_genomic_feature_version` that updates the `genomic_features` table by setting the `version` column to a new value. The new value is constructed by taking the existing `version` string, using `split_part` to isolate the part after 'v', applying `regexp_replace` to remove any sub-version (e.g., '.0'), casting the result to an integer, incrementing it by one, casting it back to text, and prepending 'v'. The update should target rows where `feature_id` matches the `NEW.feature_id` from the trigger context, and the function must return `NEW`.\nSecond, define the trigger `trg_update_genomic_feature_version` on table `study_features` that fires `AFTER UPDATE` of the `value` column and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_genomic_feature_version() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE genomic_features \n    SET version = 'v' || (regexp_replace(split_part(version, 'v', 2), '\\..*$', '')::integer + 1)::text \n    WHERE feature_id = NEW.feature_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_genomic_feature_version\n    AFTER UPDATE OF value ON study_features\n    FOR EACH ROW\n    EXECUTE FUNCTION update_genomic_feature_version();",
    "database_name": "genomic_feature_analysis_and_statistics",
    "tables": [
      "feature_values",
      "genomic_features",
      "decision_trees",
      "statistical_values",
      "study_features"
    ],
    "call_sqls": [
      "UPDATE study_features SET value = 1.5 WHERE study_feature_id = 0;",
      "UPDATE study_features SET value = 2.0 WHERE study_feature_id = 1;",
      "UPDATE study_features SET value = 3.0 WHERE feature_id = 0 AND study_id = 0;",
      "UPDATE study_features SET value = 4.0 WHERE feature_id = 1 AND study_id = 0;",
      "UPDATE study_features SET value = 5.0, source = 'New Data' WHERE study_feature_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_genomic_feature_version that fires AFTER UPDATE on the value column of the study_features table for each row, and when triggered, updates the genomic_features table by incrementing the major version number (the integer part after the 'v' prefix) for all rows where the feature_id matches the updated row's feature_id, then returns the NEW row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_update_genomic_feature_version that fires AFTER UPDATE of the value column on the study_features table, so that for each updated row, the genomic_features table is updated by incrementing the major version number for rows with a matching feature_id, and then returns the NEW row.",
    "id": 35,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_genomic_feature_version`. This function is defined to return a `TRIGGER` type and is executed automatically in response to specific database events. It does not accept any explicit input parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. The function is designed to operate on the `genomic_feature_analysis_and_statistics` database.\n\nWithin the function, a variable named `current_version` of type `text` is declared to temporarily store the existing version string from the `genomic_features` table. The core logic begins with a `SELECT` operation that retrieves the `version` column from the `genomic_features` table for the row where the `feature_id` matches `NEW.feature_id`. `NEW.feature_id` refers to the value of the `feature_id` column from the updated row in the `study_features` table that activated the trigger. The retrieved version string is stored in the `current_version` variable.\n\nFollowing this, an `UPDATE` operation is performed on the `genomic_features` table. This operation modifies the `version` column. The new version value is calculated by incrementing the major version number of the `current_version` string. The major version number is defined as the numeric part preceding the first dot ('.') in a version string formatted as 'vX.Y' (e.g., 'v1.0'). The calculation involves extracting the substring from the second character (to skip the leading 'v') up to the first dot, converting this substring to an integer, incrementing it by one, and then reconstructing the version string by concatenating 'v' with the incremented integer and '.0'. For example, if `current_version` is 'v1.0', it becomes 'v2.0'. This `UPDATE` is conditionally applied only to the row in the `genomic_features` table where the `feature_id` column matches `NEW.feature_id`.\n\nAfter performing the update, the function returns `NEW`, which is a standard practice for `AFTER` row-level triggers in PostgreSQL, indicating that the modified new row should be used.\n\nSecond, define the trigger `trg_update_genomic_feature_version` on table `study_features`. This trigger is configured to activate `AFTER UPDATE` operations on the `study_features` table, but only when the update modifies the `value` column. The `FOR EACH ROW` clause specifies that the trigger function `update_genomic_feature_version()` should be executed once for every row that is updated in the `study_features` table where the `value` column changes. The `EXECUTE FUNCTION update_genomic_feature_version()` clause explicitly calls the previously defined trigger function to perform its logic.\n\nIn summary, this setup ensures that whenever a row in the `study_features` table is updated and its `value` column is changed, the corresponding row in the `genomic_features` table with a matching `feature_id` has its `version` column updated by incrementing the major version number (e.g., from 'v1.0' to 'v2.0').",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_genomic_feature_version` that is designed to automatically increment the version number of a genomic feature whenever a related `study_features` record is updated. This function is executed as an `AFTER UPDATE` trigger on the `study_features` table, specifically when the `value` column of a `study_features` record is modified. The trigger is configured to fire `FOR EACH ROW` that is affected by the update operation.\n\nUpon activation, the `update_genomic_feature_version` function performs a single `UPDATE` operation on the `genomic_features` table. The target rows for this update are identified by matching the `feature_id` column in the `genomic_features` table with the `feature_id` of the `NEW` record (the updated row) from the `study_features` table.\n\nFor each matching row in the `genomic_features` table, the `version` column is updated. The new `version` value is constructed by first extracting the numeric part of the existing `version` string, incrementing it by one, and then prepending 'v' to the result. This extraction and increment process involves several steps:\n1. The `split_part` function is used to split the existing `version` string (e.g., 'v1.0', 'v2') by the delimiter 'v' and retrieve the second part. This effectively isolates the version number and any subsequent sub-version information (e.g., '1.0', '2').\n2. The `regexp_replace` function is then applied to this extracted part. It replaces any sequence starting with a period ('.') followed by any characters (`\\..*$`) with an empty string. This effectively removes any sub-version information, leaving only the major version number (e.g., '1', '2').\n3. The resulting string (e.g., '1', '2') is then explicitly cast to an `integer` data type using `::integer`.\n4. This integer value is incremented by `1`.\n5. The incremented integer is then explicitly cast back to a `text` data type using `::text`.\n6. Finally, the character 'v' is concatenated (`||`) with this new text representation of the incremented version number to form the complete new `version` string (e.g., 'v2', 'v3').\n\nAfter the `UPDATE` operation is completed, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL. The trigger itself, named `trg_update_genomic_feature_version`, is defined to execute the `update_genomic_feature_version` function.",
    "original_summary": "Create an AFTER UPDATE trigger function on the study_features table that fires when the value column changes. For each updated row, update the genomic_features table. Increment the major version number (the integer part after 'v') for rows where the feature_id matches the NEW row's feature_id. Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER UPDATE trigger function on the study_features table that fires when the value column changes, so that for each updated row, the genomic_features table is updated by incrementing the major version number for rows with a matching feature_id, and then returns the NEW row?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `adjust_zestimate_on_sale` that updates the `zestimate` column in the `properties` table to the value of the `NEW.sale_price` column, using a subquery to find the matching `property_id` from the `property_listings` table based on the `NEW.listing_id`.\nSecond, define the trigger `trigger_adjust_zestimate_on_sale` on table `sales` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_zestimate_on_sale() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE properties SET zestimate = NEW.sale_price WHERE property_id = (SELECT property_id FROM property_listings WHERE listing_id = NEW.listing_id);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_adjust_zestimate_on_sale\nAFTER INSERT ON sales\nFOR EACH ROW EXECUTE FUNCTION adjust_zestimate_on_sale();",
    "database_name": "real_estate_property_management_and_valuation",
    "tables": [
      "properties",
      "property_listings",
      "agents",
      "property_images",
      "open_houses",
      "sales"
    ],
    "call_sqls": [
      "INSERT INTO sales (sale_id, listing_id, sale_date, sale_price, buyer_name, buyer_contact, closing_date, closing_costs, financing_type) VALUES (2, 1, '2024-05-15', 625000.0, 'Charlie Brown', 'charlie.brown@example.com', '2024-06-15', 11000.0, 'mortgage');",
      "INSERT INTO sales (sale_id, listing_id, sale_date, sale_price, buyer_name, buyer_contact, closing_date, closing_costs, financing_type) VALUES (3, 0, '2024-05-16', 710000.0, 'Diana Prince', 'diana.prince@example.com', '2024-06-16', 12500.0, 'cash');",
      "INSERT INTO sales (sale_id, listing_id, sale_date, sale_price, buyer_name, buyer_contact, closing_date, closing_costs, financing_type) VALUES (4, 1, '2024-05-17', 640000.0, 'Evan Wright', 'evan.wright@example.com', '2024-06-17', 10500.0, 'mortgage');",
      "INSERT INTO sales (sale_id, listing_id, sale_date, sale_price, buyer_name, buyer_contact, closing_date, closing_costs, financing_type) VALUES (5, 0, '2024-05-18', 695000.0, 'Fiona Green', 'fiona.green@example.com', '2024-06-18', 11500.0, 'cash');",
      "INSERT INTO sales (sale_id, listing_id, sale_date, sale_price, buyer_name, buyer_contact, closing_date, closing_costs, financing_type) VALUES (6, 1, '2024-05-19', 630000.0, 'George King', 'george.king@example.com', '2024-06-19', 10000.0, 'mortgage');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trigger_adjust_zestimate_on_sale that, after a new row is inserted into the sales table, updates the properties table by setting the zestimate column to the sale_price from the new sale for the property whose property_id matches the property_id from the property_listings table corresponding to the listing_id of the new sale.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named 'adjust_zestimate_on_sale' that, after inserting a row into the 'sales' table, updates the 'zestimate' column in the 'properties' table by setting it to the 'NEW.sale_price' value for the property whose 'property_id' matches the one found in the 'property_listings' table for the listing with a 'listing_id' equal to 'NEW.listing_id', and then returns the NEW row; then create an AFTER INSERT FOR EACH ROW trigger called 'trigger_adjust_zestimate_on_sale' on the 'sales' table to execute this function.",
    "id": 36,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `adjust_zestimate_on_sale` that updates the `zestimate` column in the `properties` table to the value of the `NEW.sale_price` column, using a subquery to find the matching `property_id` from the `property_listings` table based on the `NEW.listing_id`.\nSecond, define the trigger `trigger_adjust_zestimate_on_sale` on table `sales` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL function named adjust_zestimate_on_sale that is designed to be executed as a trigger function. This function does not take any parameters directly but operates on the NEW record available in the context of a trigger. The function updates the zestimate column in the properties table to the value of the sale_price column from the NEW record, which represents the newly inserted row in the sales table. The update operation is performed for the row in the properties table where the property_id matches the property_id obtained from the property_listings table, which is selected using the listing_id from the NEW record. The function then returns the NEW record, allowing the trigger to proceed with the insertion operation. The function is associated with a trigger named trigger_adjust_zestimate_on_sale, which is defined to execute after an insert operation on the sales table. This trigger is set to execute the adjust_zestimate_on_sale function for each row that is inserted into the sales table, ensuring that the zestimate value in the properties table is adjusted whenever a new sale record is added.",
    "original_summary": "Create a PL/pgSQL trigger function named 'adjust_zestimate_on_sale' that returns TRIGGER. After a row is inserted into the 'sales' table, update the 'properties' table. Set the 'zestimate' column to the value of 'NEW.sale_price' for the property where the 'property_id' matches the 'property_id' from the 'property_listings' table for the listing with 'listing_id' equal to 'NEW.listing_id'. The function should return the NEW row. Create an AFTER INSERT FOR EACH ROW trigger named 'trigger_adjust_zestimate_on_sale' on the 'sales' table to execute this function.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Write a PL/pgSQL trigger function called 'adjust_zestimate_on_sale' that returns TRIGGER. After inserting a row into the 'sales' table, update the 'zestimate' column in the 'properties' table. Set it to the 'NEW.sale_price' value for the property whose 'property_id' matches the one found in the 'property_listings' table for the listing with a 'listing_id' equal to 'NEW.listing_id'. The function must return the NEW row. Then, create an AFTER INSERT FOR EACH ROW trigger named 'trigger_adjust_zestimate_on_sale' on the 'sales' table to run this function."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function add_income_tag that checks if the NEW.income_id is NULL and, if true, assigns it a value by selecting the maximum income_id from the income_data table, using COALESCE to substitute 0 if the maximum is NULL, and adding 1; then, the function inserts a row into the dataset_tags table with values for tag_id (derived by selecting the maximum tag_id from dataset_tags, using COALESCE to substitute 0 and adding 1), dataset_id (taken from NEW.dataset_id), tag_name ('Income Analysis'), and tag_description ('Data related to income distribution'); finally, the function returns the NEW row.\nSecond, define the trigger trg_add_income_tag on table income_data that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION add_income_tag() RETURNS TRIGGER AS $$\nBEGIN\n    -- Ensure NEW.income_id has a value if it's NULL\n    IF NEW.income_id IS NULL THEN\n        NEW.income_id := (SELECT COALESCE(MAX(income_id), 0) + 1 FROM income_data);\n    END IF;\n    \n    INSERT INTO dataset_tags (tag_id, dataset_id, tag_name, tag_description) \n    VALUES ((SELECT COALESCE(MAX(tag_id), 0) + 1 FROM dataset_tags), NEW.dataset_id, 'Income Analysis', 'Data related to income distribution');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_add_income_tag\n    BEFORE INSERT ON income_data\n    FOR EACH ROW\n    EXECUTE FUNCTION add_income_tag();",
    "database_name": "geographic_and_demographic_data_analysis_941845",
    "tables": [
      "datasets",
      "access_logs",
      "data_files",
      "dataset_categories",
      "dataset_tags",
      "housing_data",
      "income_data",
      "population_data",
      "regions"
    ],
    "call_sqls": [
      "INSERT INTO income_data (dataset_id, median_income, income_distribution, median_household_income, poverty_rate) VALUES (1, 3.5, '0-20k: 12%, 20-50k: 32%, 50-100k: 40%, 100k+: 16%', 62000.0, 0.11);",
      "INSERT INTO income_data (dataset_id, median_household_income, poverty_rate) VALUES (2, 75000.0, 0.08);",
      "INSERT INTO income_data (income_id, dataset_id, median_income) VALUES (100, 3, 2.8);",
      "INSERT INTO income_data (dataset_id, income_distribution, median_household_income) VALUES (1, '0-20k: 8%, 20-50k: 28%, 50-100k: 45%, 100k+: 19%', 85000.0);",
      "INSERT INTO income_data (dataset_id, median_income, poverty_rate) VALUES (4, 4.5, 0.15);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_add_income_tag that, before inserting a row into the income_data table, ensures the income_id is set to the next sequential value if it is null, and then automatically adds a corresponding tag entry to the dataset_tags table with the dataset_id from the new row, a tag_name of 'Income Analysis', and a tag_description of 'Data related to income distribution', generating a new sequential tag_id for it.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_add_income_tag that runs before inserting into the income_data table to assign a new income_id if missing by incrementing the highest existing one, and to automatically add a corresponding tag in the dataset_tags table with a new tag_id, using the new entry's dataset_id and preset tag details for income analysis.",
    "id": 37,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function add_income_tag that checks if the NEW.income_id is NULL and, if true, assigns it a value by selecting the maximum income_id from the income_data table, using COALESCE to substitute 0 if the maximum is NULL, and adding 1; then, the function inserts a row into the dataset_tags table with values for tag_id (derived by selecting the maximum tag_id from dataset_tags, using COALESCE to substitute 0 and adding 1), dataset_id (taken from NEW.dataset_id), tag_name ('Income Analysis'), and tag_description ('Data related to income distribution'); finally, the function returns the NEW row.\nSecond, define the trigger trg_add_income_tag on table income_data that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named add_income_tag that is executed automatically by a trigger named trg_add_income_tag before each new row is inserted into the income_data table; this function first checks if the incoming new row's income_id column value is NULL, and if this condition is true, it assigns a new value to NEW.income_id by selecting from the income_data table the maximum existing value in the income_id column, using the COALESCE function to substitute 0 if the maximum is NULL, and then adding 1 to that result; after this potential assignment, the function performs an INSERT operation into the dataset_tags table, specifying values for the columns tag_id, dataset_id, tag_name, and tag_description, where the value for tag_id is derived by selecting from the dataset_tags table the maximum existing value in the tag_id column, using COALESCE to substitute 0 if the maximum is NULL, and adding 1, the value for dataset_id is taken directly from the NEW.dataset_id value of the row being inserted into income_data, the value for tag_name is the literal string 'Income Analysis', and the value for tag_description is the literal string 'Data related to income distribution'; finally, the function returns the modified NEW row record to the triggering INSERT operation on income_data.",
    "original_summary": "Create a BEFORE INSERT trigger function named add_income_tag for the income_data table. If NEW.income_id is NULL, set it to the maximum existing income_id plus one (defaulting to 1). Then insert a new row into the dataset_tags table. Generate the new tag_id as the maximum existing tag_id plus one (defaulting to 1). Use NEW.dataset_id, a tag_name of 'Income Analysis', and a tag_description of 'Data related to income distribution'. Finally, return the modified NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger to run before adding entries to the income_data table. If the new entry's income ID isn't provided, figure out a new one by taking the highest current ID and adding to it, starting from 1 if there's nothing there. Also, make sure to add a corresponding label in the dataset_tags table. For that label, come up with a new ID in a similar way, and use the new entry's dataset ID, with a tag name and description that are roughly about analyzing income information. Then just pass the updated new entry along."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_categorical_median_value` that validates the existence of a matching `property_id` in the `properties` table for the `NEW` row and, if it exists, updates the `categorical_median_value` column in the `properties` table using a `CASE` expression on `NEW.median_value` to set it to 'PREMIUM' if greater than 350000, 'STANDARD' if greater than 250000, or 'ECONOMY' otherwise; if the property does not exist or any other error occurs, the function must raise a warning and abort the operation by returning `NULL`.\nSecond, define the trigger `trg_update_categorical_median_value` on table `property_values` that fires `BEFORE` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_categorical_median_value() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if the property exists before allowing the insert\n  IF NOT EXISTS (SELECT 1 FROM properties WHERE property_id = NEW.property_id) THEN\n    RAISE WARNING 'Property with property_id % does not exist. Insert aborted.', NEW.property_id;\n    RETURN NULL; -- Abort the INSERT\n  END IF;\n  \n  -- Update the categorical value in properties table\n  UPDATE properties \n  SET categorical_median_value = \n    CASE \n      WHEN NEW.median_value > 350000 THEN 'PREMIUM' \n      WHEN NEW.median_value > 250000 THEN 'STANDARD' \n      ELSE 'ECONOMY' \n    END \n  WHERE property_id = NEW.property_id;\n  \n  RETURN NEW;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE WARNING 'Error in trigger for property_id %: %', NEW.property_id, SQLERRM;\n    RETURN NULL; -- Abort the INSERT on any error\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_categorical_median_value\nBEFORE INSERT ON property_values\nFOR EACH ROW EXECUTE FUNCTION update_categorical_median_value();",
    "database_name": "real_estate_and_urban_development_analysis_73520",
    "tables": [
      "properties",
      "predictions",
      "property_amenities",
      "property_values",
      "zones"
    ],
    "call_sqls": [
      "INSERT INTO property_values (value_id, property_id, median_value, appraisal_date) VALUES (1, 101, 400000, '2023-01-15');",
      "INSERT INTO property_values (value_id, property_id, median_value, appraisal_date) VALUES (2, 102, 300000, '2023-02-20');",
      "INSERT INTO property_values (value_id, property_id, median_value, appraisal_date) VALUES (3, 103, 200000, '2023-03-10');",
      "INSERT INTO property_values (value_id, property_id, median_value, appraisal_date) VALUES (4, 104, 500000, '2023-04-05');",
      "INSERT INTO property_values (value_id, property_id, median_value, appraisal_date) VALUES (5, 999, 320000, '2023-05-22');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_categorical_median_value that fires BEFORE INSERT on the property_values table for each row, which validates that the NEW.property_id exists in the properties table, and if it does not, aborts the insert with a warning; if valid, it updates the categorical_median_value column in the properties table for that property_id by setting it to 'PREMIUM' if NEW.median_value is greater than 350000, 'STANDARD' if greater than 250000, otherwise 'ECONOMY', and aborts the insert with a warning on any error.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called update_categorical_median_value that executes BEFORE INSERT on each row of the property_values table, which first validates if the NEW.property_id exists in the properties table, raising a warning and canceling the insert if it does not; if valid, it updates the categorical_median_value column in the properties table for that property_id, setting it to 'PREMIUM' when NEW.median_value exceeds 350000, to 'STANDARD' when it exceeds 250000, and to 'ECONOMY' otherwise, then returns NEW to proceed with the insert, and includes an exception handler to raise a warning and cancel the insert on any error.",
    "id": 38,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_categorical_median_value` that validates the existence of a matching `property_id` in the `properties` table for the `NEW` row and, if it exists, updates the `categorical_median_value` column in the `properties` table using a `CASE` expression on `NEW.median_value` to set it to 'PREMIUM' if greater than 350000, 'STANDARD' if greater than 250000, or 'ECONOMY' otherwise; if the property does not exist or any other error occurs, the function must raise a warning and abort the operation by returning `NULL`.\nSecond, define the trigger `trg_update_categorical_median_value` on table `property_values` that fires `BEFORE` `INSERT` and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_categorical_median_value that is executed automatically by a trigger named trg_update_categorical_median_value before each row insertion into the property_values table, which takes the new row data (NEW) as an implicit parameter containing columns like property_id and median_value, and first performs a validation check by selecting from the properties table to ensure a row exists where the property_id column matches NEW.property_id, and if no such row exists, raises a warning message and aborts the insert by returning NULL; if the property exists, it then updates the properties table by setting the categorical_median_value column for the row where property_id equals NEW.property_id to a string value determined by a CASE expression that evaluates NEW.median_value: if NEW.median_value is greater than 350000, the string is 'PREMIUM'; if greater than 250000, the string is 'STANDARD'; otherwise, the string is 'ECONOMY'; after the update, the function returns the NEW row to allow the insert to proceed; if any other error occurs during execution, the exception handler catches it, raises a warning with the error message from SQLERRM, and aborts the insert by returning NULL.",
    "original_summary": "Create a PostgreSQL trigger function named update_categorical_median_value that fires BEFORE INSERT on the property_values table for each row. It must validate that the NEW.property_id exists in the properties table. If not, raise a warning and return NULL to abort. If valid, update the properties table's categorical_median_value column for that property_id based on NEW.median_value: set to 'PREMIUM' if > 350000, 'STANDARD' if > 250000, else 'ECONOMY'. Return NEW to proceed. Include an exception handler to raise a warning and return NULL on any error.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a PostgreSQL trigger function called update_categorical_median_value that executes BEFORE INSERT on each row of the property_values table? The function should first check if the NEW.property_id exists in the properties table. If it does not exist, how should it raise a warning and return NULL to cancel the operation? If the ID is valid, how does it update the categorical_median_value column in the properties table for that specific property_id? The update should set the value to 'PREMIUM' if NEW.median_value is greater than 350000, to 'STANDARD' if it is greater than 250000, and to 'ECONOMY' otherwise. Finally, how does the function return NEW to allow the insert to proceed, and how is an exception handler implemented to raise a warning and return NULL if any error occurs?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_recoveries_on_patient_delete` that deletes rows from the `notifications`, `access_logs`, `patient_treatments`, and `recoveries` tables where the `patient_id` column matches the `patient_id` value from the `OLD` record and returns the `OLD` record.\nSecond, define the trigger `trg_delete_recoveries_on_patient_delete` on table `patients` that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_recoveries_on_patient_delete() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM notifications WHERE patient_id = OLD.patient_id;\n    DELETE FROM access_logs WHERE patient_id = OLD.patient_id;\n    DELETE FROM patient_treatments WHERE patient_id = OLD.patient_id;\n    DELETE FROM recoveries WHERE patient_id = OLD.patient_id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_recoveries_on_patient_delete\n    BEFORE DELETE ON patients\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_recoveries_on_patient_delete();",
    "database_name": "covid_19_patient_tracking_and_recovery_monitoring",
    "tables": [
      "patients",
      "patient_treatments",
      "treatments",
      "recoveries"
    ],
    "call_sqls": [
      "DELETE FROM patients WHERE patient_id = 0;",
      "DELETE FROM patients WHERE patient_id = 1;",
      "DELETE FROM patients WHERE patient_id = 2;",
      "DELETE FROM patients WHERE patient_id = 3;",
      "DELETE FROM patients WHERE patient_id = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_delete_recoveries_on_patient_delete that executes BEFORE DELETE on the patients table to, for each deleted patient, remove all associated records from the notifications, access_logs, patient_treatments, and recoveries tables where the patient_id matches the deleted patient's ID, and then returns the deleted patient record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_delete_recoveries_on_patient_delete that, before deleting a row from the patients table, deletes all related records from the notifications, access_logs, patient_treatments, and recoveries tables where their patient_id matches the deleted patient's patient_id and returns the OLD record.",
    "id": 39,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named delete_recoveries_on_patient_delete that returns a trigger. This function is designed to be executed by a trigger named trg_delete_recoveries_on_patient_delete before a delete operation on the patients table for each row being deleted. The function's logic is to perform a series of delete operations on four related tablesâ€”notifications, access_logs, patient_treatments, and recoveriesâ€”to maintain referential integrity by removing all dependent records associated with the patient being deleted. Specifically, for each table, it executes a delete statement where the patient_id column in that table matches the patient_id value from the OLD record, which represents the row being deleted from the patients table. The deletions occur in a sequential manner, though the order is not specified, ensuring that all foreign key constraints are satisfied by removing child records before the parent record in patients is deleted. After completing these deletions, the function returns the OLD row record to the trigger execution context, allowing the delete operation on the patients table to proceed. Second, define the trigger trg_delete_recoveries_on_patient_delete on the patients table, specifying that it fires before delete on the patients table for each row, and executes the delete_recoveries_on_patient_delete function. The trigger ensures cascading deletion across the related tables without using foreign key cascade options, handling it programmatically within the trigger function.",
    "original_ir": "Write a PostgreSQL trigger function named `delete_recoveries_on_patient_delete` that is designed to be executed automatically in response to a specific database event. This function does not accept any explicit input parameters in its definition, but it operates within the context of a trigger, meaning it implicitly receives special variables representing the old and new states of the row being affected by the triggering event. Specifically, it accesses the `OLD` record, which represents the row's state *before* the triggering `DELETE` operation. The function performs a series of `DELETE` operations on multiple tables. First, it deletes rows from the `notifications` table where the `patient_id` column matches the `patient_id` value from the `OLD` record (i.e., the patient being deleted). Second, it deletes rows from the `access_logs` table where the `patient_id` column matches the `patient_id` value from the `OLD` record. Third, it deletes rows from the `patient_treatments` table where the `patient_id` column matches the `patient_id` value from the `OLD` record. Fourth, it deletes rows from the `recoveries` table where the `patient_id` column matches the `patient_id` value from the `OLD` record. After performing these deletion operations, the function returns the `OLD` record, which is a standard requirement for `BEFORE` triggers in PostgreSQL.\n\nThis trigger function is then associated with a trigger named `trg_delete_recoveries_on_patient_delete`. This trigger is configured to activate `BEFORE DELETE` operations on the `patients` table. The `FOR EACH ROW` clause specifies that the trigger function `delete_recoveries_on_patient_delete` will be executed once for each individual row that is being deleted from the `patients` table. The `EXECUTE FUNCTION delete_recoveries_on_patient_delete()` clause indicates that the previously defined function will be invoked when the trigger fires. The overall purpose of this trigger and its associated function is to ensure referential integrity and data cleanup by automatically removing related records from `notifications`, `access_logs`, `patient_treatments`, and `recoveries` tables whenever a patient record is deleted from the `patients` table, based on the `patient_id` column.",
    "original_summary": "Create a PostgreSQL BEFORE DELETE trigger function on the patients table. For each deleted patient row, delete related records from the notifications, access_logs, patient_treatments, and recoveries tables where their patient_id matches the OLD.patient_id. Return the OLD record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a PostgreSQL BEFORE DELETE trigger function for the patients table that, for each deleted patient row, deletes related records from the notifications, access_logs, patient_treatments, and recoveries tables where their patient_id matches the OLD.patient_id and returns the OLD record?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function check_indicator_exists that uses a CASE expression to return the NEW row or NULL based on the existence of a matching record. The function must check if a row exists in the indicators table where its indicator_id column matches NEW.indicator_id by using the EXISTS condition with a subquery SELECT 1 FROM indicators WHERE indicator_id = NEW.indicator_id. If a match exists, return NEW; otherwise, return NULL.\nSecond, define the trigger trg_check_indicator_exists on table indicator_values that fires BEFORE INSERT for each row and executes the function check_indicator_exists.",
    "plsql": "CREATE OR REPLACE FUNCTION check_indicator_exists() RETURNS TRIGGER AS $$\nBEGIN\n    RETURN CASE WHEN EXISTS(SELECT 1 FROM indicators WHERE indicator_id = NEW.indicator_id) THEN NEW ELSE NULL END;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_indicator_exists\n    BEFORE INSERT ON indicator_values\n    FOR EACH ROW\n    EXECUTE FUNCTION check_indicator_exists();",
    "database_name": "global_health_and_development_indicators",
    "tables": [
      "indicators",
      "indicator_values",
      "regions"
    ],
    "call_sqls": [
      "INSERT INTO indicator_values (indicator_value_id, region_id, indicator_id, year, value, confidence_interval_lower, confidence_interval_upper, data_reliability, notes) VALUES (0, 0, 0, 2015, 61.5583, 60.5, 62.5, 'high', 'Based on recent survey data');",
      "INSERT INTO indicator_values (indicator_value_id, region_id, indicator_id, year, value, confidence_interval_lower, confidence_interval_upper, data_reliability, notes) VALUES (1, 0, 1, 2016, 60.85, 59.8, 61.8, 'medium', 'Based on administrative data');",
      "INSERT INTO indicator_values (indicator_value_id, region_id, indicator_id, year, value, confidence_interval_lower, confidence_interval_upper, data_reliability, notes) VALUES (2, 1, 0, 2017, 70.1, 69.5, 70.7, 'high', 'New data available');",
      "INSERT INTO indicator_values (indicator_value_id, region_id, indicator_id, year, value, confidence_interval_lower, confidence_interval_upper, data_reliability, notes) VALUES (3, 1, 1, 2018, 55.2, 54.0, 56.4, 'low', 'Estimated data');",
      "INSERT INTO indicator_values (indicator_value_id, region_id, indicator_id, year, value, confidence_interval_lower, confidence_interval_upper, data_reliability, notes) VALUES (4, 0, 999, 2019, 10.0, 9.0, 11.0, 'high', 'Test data for non-existent indicator');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_check_indicator_exists that fires BEFORE INSERT on the indicator_values table for each row, ensuring that the NEW.indicator_id exists in the indicators table; if it exists, allow the insert to proceed, otherwise cancel it.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named check_indicator_exists that runs BEFORE INSERT on the indicator_values table for each row, verifying if the NEW.indicator_id exists in the indicators table; if it exists, allow the insertion by returning NEW, otherwise prevent it by returning NULL.",
    "id": 40,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function check_indicator_exists that uses a CASE expression to return the NEW row or NULL based on the existence of a matching record. The function must check if a row exists in the indicators table where its indicator_id column matches NEW.indicator_id by using the EXISTS condition with a subquery SELECT 1 FROM indicators WHERE indicator_id = NEW.indicator_id. If a match exists, return NEW; otherwise, return NULL.\nSecond, define the trigger trg_check_indicator_exists on table indicator_values that fires BEFORE INSERT for each row and executes the function check_indicator_exists.",
    "original_ir": "Write a PostgreSQL trigger function named check_indicator_exists that returns a trigger, which is executed by a trigger named trg_check_indicator_exists defined to fire BEFORE INSERT on the indicator_values table for each new row, where the function's logic is to conditionally return the new row data or null by evaluating a CASE expression that checks for the existence of a record in the indicators table where the indicator_id column value matches the NEW.indicator_id value from the incoming insert operation on indicator_values, specifically by performing a SELECT statement that returns a constant value of 1 from the indicators table whenever a row with a matching indicator_id is found, and if such a matching row exists, the CASE expression returns the NEW row record, thereby allowing the insert operation on indicator_values to proceed with the original data, but if no matching row is found in the indicators table, the SELECT returns no rows and the EXISTS condition evaluates to false, causing the CASE expression to return NULL, which consequently cancels the insert operation for that specific row into the indicator_values table.",
    "original_summary": "Create a trigger function named check_indicator_exists that fires BEFORE INSERT on the indicator_values table for each row. It must check if the NEW.indicator_id exists in the indicators table. If it exists, return NEW to allow the insert. If it does not exist, return NULL to cancel the insert.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a trigger function designated as 'check_indicator_exists'. This function is to be executed BEFORE INSERT operations on the 'indicator_values' table for each individual row. Its primary function is to verify the existence of the NEW.indicator_id value within the 'indicators' table. Should the identifier be present, the function must return NEW to permit the insertion. Conversely, if the identifier is not found, the function must return NULL to prevent the insertion from proceeding."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_confidence_level that assigns a value to the NEW.confidence_level column using a CASE expression on the NEW.value column: set to 'high' if NEW.value >= 1000, to 'medium' if NEW.value >= 100, and to 'low' otherwise, then returns the modified NEW record.\nSecond, define the trigger trg_update_confidence_level on table demographic_data that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_confidence_level() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.confidence_level := CASE WHEN NEW.value >= 1000 THEN 'high' WHEN NEW.value >= 100 THEN 'medium' ELSE 'low' END;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_confidence_level\nBEFORE INSERT ON demographic_data\nFOR EACH ROW EXECUTE FUNCTION update_confidence_level();",
    "database_name": "demographic_data_collection_and_analysis_426928",
    "tables": [
      "demographic_data",
      "regions",
      "sexes",
      "years"
    ],
    "call_sqls": [
      "INSERT INTO demographic_data (data_id, year, region_id, sex, age_group, value, source_id, notes, last_updated) VALUES (2, '2023', 0, '0', '0', 1500, 1, 'Test data for high confidence', '2023-11-01 10:00:00');",
      "INSERT INTO demographic_data (data_id, year, region_id, sex, age_group, value, source_id, notes, last_updated) VALUES (3, '2022', 1, '1', '0', 500, 0, 'Test data for medium confidence', '2023-11-01 10:05:00');",
      "INSERT INTO demographic_data (data_id, year, region_id, sex, age_group, value, source_id, notes, last_updated) VALUES (4, '2021', 0, '0', '0', 50, 1, 'Test data for low confidence', '2023-11-01 10:10:00');",
      "INSERT INTO demographic_data (data_id, year, region_id, sex, age_group, value, source_id, notes, last_updated) VALUES (5, '2023', 1, '1', '0', 1000, 0, 'Boundary case for high confidence', '2023-11-01 10:15:00');",
      "INSERT INTO demographic_data (data_id, year, region_id, sex, age_group, value, source_id, notes, last_updated) VALUES (6, '2022', 0, '0', '0', 99, 1, 'Boundary case for low confidence', '2023-11-01 10:20:00');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_confidence_level that executes BEFORE INSERT on the demographic_data table, setting the NEW.confidence_level column to 'high' if the NEW.value is 1000 or greater, to 'medium' if NEW.value is 100 or greater but less than 1000, or to 'low' otherwise, and then returns the updated NEW row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_confidence_level that, before inserting a row into the demographic_data table, sets the NEW.confidence_level to 'high' if NEW.value is at least 1000, 'medium' if NEW.value is at least 100, or 'low' otherwise, and then returns NEW.",
    "id": 41,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named update_confidence_level that returns a trigger and is executed by a trigger named update_confidence_level_trigger, where the trigger is defined to fire automatically before any INSERT operation on the demographic_data table for each individual row being inserted. The function's logic, upon execution, examines the value of the NEW.value column from the triggering insert row. If NEW.value is greater than or equal to 1000, it sets the NEW.confidence_level column to the string literal 'high'. If NEW.value is less than 1000 but greater than or equal to 100, it sets NEW.confidence_level to 'medium'. If NEW.value is less than 100, it sets NEW.confidence_level to 'low'. After this conditional assignment, the function returns the modified NEW row record to the trigger execution environment.",
    "original_ir": "Write a PostgreSQL trigger function named update_confidence_level that is executed automatically by a trigger named trg_update_confidence_level before any new row is inserted into the demographic_data table; this function takes no explicit parameters but operates on the special NEW record variable representing the row to be inserted, and its sole operation is to assign a new value to the confidence_level column of this NEW row based on a conditional CASE expression evaluated against the value in the NEW row's value column: if the NEW.value is greater than or equal to 1000, the confidence_level is set to the string literal 'high'; if the NEW.value is less than 1000 but greater than or equal to 100, the confidence_level is set to 'medium'; for all other cases where NEW.value is less than 100, the confidence_level is set to 'low'; the function then returns the modified NEW record, thereby allowing the trigger to pass this updated row to the subsequent INSERT operation on the demographic_data table.",
    "original_summary": "Create a PostgreSQL BEFORE INSERT trigger function named update_confidence_level for the demographic_data table. The function sets the NEW.confidence_level column to 'high' if NEW.value >= 1000, 'medium' if NEW.value >= 100, or 'low' otherwise. It then returns the modified NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a BEFORE INSERT trigger for demographic_data called update_confidence_level. Set NEW.confidence_level to 'high' if NEW.value >= 1000, 'medium' if >= 100, else 'low'. Return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_emissions_from_metrics` that inserts a row into the `emissions_data` table using values from the `NEW` record. The insert includes columns `year`, `total_forcing_wm2`, `n2o_forcing_wm2`, `ch4_forcing_wm2`, `co2_forcing_wm2`, `global_temperature_change`, `sea_level_rise`, and `ocean_acidification`. Calculate `total_forcing_wm2` as the sum of `NEW.n2o_emissions_tg * 0.01`, `NEW.ch4_emissions_tg * 0.002`, and `NEW.c_emissions_pg * 0.2`. Set `n2o_forcing_wm2` to `NEW.n2o_emissions_tg * 0.01`, `ch4_forcing_wm2` to `NEW.ch4_emissions_tg * 0.002`, `co2_forcing_wm2` to `NEW.c_emissions_pg * 0.2`, `global_temperature_change` to `NEW.c_emissions_pg * 0.05`, `sea_level_rise` to `NEW.c_emissions_pg * 0.25`, and `ocean_acidification` to `NEW.c_emissions_pg * 0.006`. Use a `WHERE NOT EXISTS` clause to prevent insertion if a row with the same `year` as `NEW.year` already exists in `emissions_data`. The function must return `NEW`.\nSecond, define the trigger `trg_update_emissions_from_metrics` on table `emissions_metrics` that fires `AFTER INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_emissions_from_metrics() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO emissions_data (year, total_forcing_wm2, n2o_forcing_wm2, ch4_forcing_wm2, co2_forcing_wm2, global_temperature_change, sea_level_rise, ocean_acidification)\n    SELECT NEW.year,\n           (NEW.n2o_emissions_tg * 0.01 + NEW.ch4_emissions_tg * 0.002 + NEW.c_emissions_pg * 0.2),\n           NEW.n2o_emissions_tg * 0.01,\n           NEW.ch4_emissions_tg * 0.002,\n           NEW.c_emissions_pg * 0.2,\n           NEW.c_emissions_pg * 0.05,\n           NEW.c_emissions_pg * 0.25,\n           NEW.c_emissions_pg * 0.006\n    WHERE NOT EXISTS (SELECT 1 FROM emissions_data WHERE year = NEW.year);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_emissions_from_metrics\n    AFTER INSERT ON emissions_metrics\n    FOR EACH ROW\n    EXECUTE FUNCTION update_emissions_from_metrics();",
    "database_name": "climate_change_impact_analysis_and_emissions_tracking",
    "tables": [
      "emissions_data",
      "emissions_metrics",
      "climate_models"
    ],
    "call_sqls": [
      "INSERT INTO emissions_metrics (year, n2o_emissions_tg, ch4_emissions_tg, c_emissions_pg, hfc_emissions_tg, pcf_emissions_tg, sf6_emissions_tg) VALUES (2023, 12.0, 310.0, 8.5, 155.0, 53.0, 3.5);",
      "INSERT INTO emissions_metrics (year, n2o_emissions_tg, ch4_emissions_tg, c_emissions_pg, hfc_emissions_tg, pcf_emissions_tg, sf6_emissions_tg) VALUES (2024, 12.5, 315.0, 9.0, 160.0, 54.0, 3.6);",
      "INSERT INTO emissions_metrics (year, n2o_emissions_tg, ch4_emissions_tg, c_emissions_pg, hfc_emissions_tg, pcf_emissions_tg, sf6_emissions_tg) VALUES (2025, 13.0, 320.0, 9.5, 165.0, 55.0, 3.7);",
      "INSERT INTO emissions_metrics (year, n2o_emissions_tg, ch4_emissions_tg, c_emissions_pg, hfc_emissions_tg, pcf_emissions_tg, sf6_emissions_tg) VALUES (2026, 13.5, 325.0, 10.0, 170.0, 56.0, 3.8);",
      "INSERT INTO emissions_metrics (year, n2o_emissions_tg, ch4_emissions_tg, c_emissions_pg, hfc_emissions_tg, pcf_emissions_tg, sf6_emissions_tg) VALUES (2027, 14.0, 330.0, 10.5, 175.0, 57.0, 3.9);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_emissions_from_metrics that executes after each new row is inserted into the emissions_metrics table, and for each insertion, if a record with the same year does not already exist in the emissions_data table, it inserts a new record into emissions_data using the NEW.year and calculates the following values from the new row: total_forcing_wm2 as the sum of (NEW.n2o_emissions_tg multiplied by 0.01), (NEW.ch4_emissions_tg multiplied by 0.002), and (NEW.c_emissions_pg multiplied by 0.2); n2o_forcing_wm2 as NEW.n2o_emissions_tg multiplied by 0.01; ch4_forcing_wm2 as NEW.ch4_emissions_tg multiplied by 0.002; co2_forcing_wm2 as NEW.c_emissions_pg multiplied by 0.2; global_temperature_change as NEW.c_emissions_pg multiplied by 0.05; sea_level_rise as NEW.c_emissions_pg multiplied by 0.25; and ocean_acidification as NEW.c_emissions_pg multiplied by 0.006.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_update_emissions_from_metrics that runs after each new row is inserted into the emissions_metrics table. For each new entry, if the emissions_data table does not already have a record for that year, insert a new row into emissions_data using the year from the new data. Calculate the following values: total_forcing_wm2 by combining the n2o_emissions_tg, ch4_emissions_tg, and c_emissions_pg with specific multipliers; n2o_forcing_wm2 from n2o_emissions_tg; ch4_forcing_wm2 from ch4_emissions_tg; co2_forcing_wm2 from c_emissions_pg. Also compute global_temperature_change, sea_level_rise, and ocean_acidification based primarily on c_emissions_pg. Finally, return the new record.",
    "id": 42,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_emissions_from_metrics` that inserts a row into the `emissions_data` table using values from the `NEW` record. The insert includes columns `year`, `total_forcing_wm2`, `n2o_forcing_wm2`, `ch4_forcing_wm2`, `co2_forcing_wm2`, `global_temperature_change`, `sea_level_rise`, and `ocean_acidification`. Calculate `total_forcing_wm2` as the sum of `NEW.n2o_emissions_tg * 0.01`, `NEW.ch4_emissions_tg * 0.002`, and `NEW.c_emissions_pg * 0.2`. Set `n2o_forcing_wm2` to `NEW.n2o_emissions_tg * 0.01`, `ch4_forcing_wm2` to `NEW.ch4_emissions_tg * 0.002`, `co2_forcing_wm2` to `NEW.c_emissions_pg * 0.2`, `global_temperature_change` to `NEW.c_emissions_pg * 0.05`, `sea_level_rise` to `NEW.c_emissions_pg * 0.25`, and `ocean_acidification` to `NEW.c_emissions_pg * 0.006`. Use a `WHERE NOT EXISTS` clause to prevent insertion if a row with the same `year` as `NEW.year` already exists in `emissions_data`. The function must return `NEW`.\nSecond, define the trigger `trg_update_emissions_from_metrics` on table `emissions_metrics` that fires `AFTER INSERT` and executes the function.",
    "original_ir": "Write a PLpgSQL function named update_emissions_from_metrics that is designed to be executed as a trigger function. This function is triggered after an insert operation on the emissions_metrics table. It takes no parameters directly but operates on the NEW record, which represents the row just inserted into emissions_metrics. The function performs an insert operation into the emissions_data table, which has columns year, total_forcing_wm2, n2o_forcing_wm2, ch4_forcing_wm2, co2_forcing_wm2, global_temperature_change, sea_level_rise, and ocean_acidification. The values inserted into these columns are derived from the NEW record's fields: year, n2o_emissions_tg, ch4_emissions_tg, and c_emissions_pg. Specifically, the total_forcing_wm2 is calculated as the sum of NEW.n2o_emissions_tg multiplied by 0.01, NEW.ch4_emissions_tg multiplied by 0.002, and NEW.c_emissions_pg multiplied by 0.2. The n2o_forcing_wm2 is NEW.n2o_emissions_tg multiplied by 0.01, ch4_forcing_wm2 is NEW.ch4_emissions_tg multiplied by 0.002, and co2_forcing_wm2 is NEW.c_emissions_pg multiplied by 0.2. The global_temperature_change is NEW.c_emissions_pg multiplied by 0.05, sea_level_rise is NEW.c_emissions_pg multiplied by 0.25, and ocean_acidification is NEW.c_emissions_pg multiplied by 0.006. The insert operation is conditioned on the non-existence of a row in emissions_data with the same year as NEW.year, ensuring that duplicate years are not inserted. The function returns the NEW record, allowing the trigger to complete its operation. The trigger named trg_update_emissions_from_metrics is defined to execute this function after each row is inserted into the emissions_metrics table.",
    "original_summary": "Create an AFTER INSERT trigger function on the emissions_metrics table. For each new row, insert a corresponding record into the emissions_data table if a record with the same year does not already exist. Calculate the values: total_forcing_wm2 as (NEW.n2o_emissions_tg * 0.01) + (NEW.ch4_emissions_tg * 0.002) + (NEW.c_emissions_pg * 0.2); n2o_forcing_wm2 as NEW.n2o_emissions_tg * 0.01; ch4_forcing_wm2 as NEW.ch4_emissions_tg * 0.002; co2_forcing_wm2 as NEW.c_emissions_pg * 0.2; global_temperature_change as NEW.c_emissions_pg * 0.05; sea_level_rise as NEW.c_emissions_pg * 0.25; ocean_acidification as NEW.c_emissions_pg * 0.006. Use NEW.year for the year column. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger on the emissions_metrics table that runs after new entries are added. For each fresh piece of data, if there isn't already a record for that particular year in the emissions_data table, go ahead and add one. You'll need to figure out a few calculated values: total_forcing_wm2 by combining the n2o, ch4, and c emissions with some small multipliers; n2o_forcing_wm2 from the n2o emissions; ch4_forcing_wm2 from the ch4 emissions; co2_forcing_wm2 from the c emissions. Also, work out some numbers for global temperature change, sea level rise, and ocean acidification based mainly on the c emissions. Use the year from the new data. Finally, just return the new record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `normalize_user_email` that uses the `LOWER()` function to convert the value of the `email` column in the `NEW` pseudo-record to lowercase and then returns `NEW`.\nSecond, define the trigger `normalize_user_email_trigger` on table `users` that fires `BEFORE` `INSERT OR UPDATE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION normalize_user_email() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.email = LOWER(NEW.email);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER normalize_user_email_trigger\nBEFORE INSERT OR UPDATE ON users\nFOR EACH ROW EXECUTE FUNCTION normalize_user_email();",
    "database_name": "media_content_management_and_tracking",
    "tables": [
      "shows",
      "ratings",
      "users",
      "user_activity"
    ],
    "call_sqls": [
      "INSERT INTO users (user_id, user_name, email, role, password_hash) VALUES (2, 'Charlie Brown', 'CHARLIE.BROWN@EXAMPLE.COM', 'user', 'password_hash');",
      "INSERT INTO users (user_id, user_name, email, role, password_hash) VALUES (3, 'David Smith', 'DAVID.SMITH@EXAMPLE.COM', 'user', 'password_hash');",
      "UPDATE users SET email = 'ALICE.JOHNSON@EXAMPLE.COM' WHERE user_id = 0;",
      "UPDATE users SET email = 'BOB.WILLIAMS@EXAMPLE.COM' WHERE user_id = 1;",
      "INSERT INTO users (user_id, user_name, email, role, password_hash) VALUES (4, 'Eve Adams', 'EVE.ADAMS@EXAMPLE.COM', 'user', 'password_hash');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named normalize_user_email_trigger that executes BEFORE INSERT OR UPDATE on the users table, ensuring that for each row, the NEW.email value is converted to lowercase before being saved.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called normalize_user_email_trigger that, before any insert or update operation on the users table, automatically converts the NEW.email value to lowercase and then returns the modified NEW record.",
    "id": 43,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `normalize_user_email` that is designed to be executed as a trigger. This function does not take any parameters directly but operates in the context of a trigger event. It performs a single operation: it modifies the `email` field of the `NEW` record, which represents the row being inserted or updated in the `users` table. Specifically, it converts the value of `NEW.email` to lowercase using the `LOWER` function, ensuring that the email address is stored in a normalized, case-insensitive format. The function then returns the modified `NEW` record, allowing the trigger to proceed with the insert or update operation using the normalized email value. Second, define the trigger `normalize_user_email_trigger` on the `users` table. This trigger is configured to execute the `normalize_user_email` function before each row is inserted or updated, ensuring that the email normalization occurs automatically for all data modifications on the `users` table.",
    "original_ir": "Write a PLpgSQL trigger function that automatically modifies the email column in the users table to its lowercase version whenever a new row is inserted or an existing row is updated. The function, named normalize_user_email, is designed to be executed for each row affected by an INSERT or UPDATE operation on the users table. It takes no parameters and operates on the NEW pseudo-record, which represents the row currently being inserted or updated. The function uses the LOWER() function to convert the value of the email column in the NEW record to lowercase, ensuring consistent email formatting. After modifying the email field, the function returns the NEW record, which contains the updated email value. The trigger, named normalize_user_email_trigger, is defined to execute this function before any INSERT or UPDATE operation on the users table, ensuring that the email normalization occurs prior to the row being committed to the table.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE trigger function for the users table. For each row, set the NEW.email column to its lowercase version using LOWER(). Return the modified NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make trigger for users table. Before insert or update, lowercase NEW.email. Return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_training_session_end` that checks for the existence of a user in the `users` table where `user_id` matches the new `trained_by` value from the updated `training_sessions` row; if the user exists, it inserts a row into the `access_logs` table, populating `access_id` by calculating `COALESCE(MAX(access_id), 0) + 1` from `access_logs`, `user_id` with `NEW.trained_by`, `model_id` with `NEW.model_id`, `access_time` with `NEW.end_time`, `access_type` with the string 'end_session', `accessed_at` with `NEW.end_time`, `action` with the string 'end_session', and `accessed_by` with `NEW.trained_by`.\nSecond, define the trigger `training_session_end_logger` on table `training_sessions` that fires AFTER UPDATE for each row when the new `status` equals 'completed' and the new `end_time` is not null, and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_training_session_end() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if the trained_by user exists in the users table\n    IF EXISTS (SELECT 1 FROM users WHERE user_id = NEW.trained_by) THEN\n        INSERT INTO access_logs (access_id, user_id, model_id, access_time, access_type, accessed_at, action, accessed_by)\n        VALUES (\n            (SELECT COALESCE(MAX(access_id), 0) + 1 FROM access_logs),\n            NEW.trained_by,\n            NEW.model_id,\n            NEW.end_time,\n            'end_session',\n            NEW.end_time,\n            'end_session',\n            NEW.trained_by\n        );\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER training_session_end_logger\n    AFTER UPDATE ON training_sessions\n    FOR EACH ROW\n    WHEN (NEW.status = 'completed' AND NEW.end_time IS NOT NULL)\n    EXECUTE FUNCTION log_training_session_end();",
    "database_name": "machine_learning_model_training_and_evaluation_720211",
    "tables": [
      "access_logs",
      "bad_epochs",
      "evaluation_metrics",
      "model_versions",
      "models",
      "training_sessions",
      "users"
    ],
    "call_sqls": [
      "INSERT INTO users (user_id, user_name, email, role, created_at, updated_at, password, access_level) VALUES (100, 'Test User', 'test@example.com', 'developer', '2023-01-01 00:00:00', '2023-01-01 00:00:00', 'password', 'admin');",
      "INSERT INTO training_sessions (session_id, model_id, start_time, end_time, learning_rate, training_loss, status, trained_by, training_config, gpu_usage, cpu_usage) VALUES (10, 1, '2023-01-01 10:00:00', NULL, 0.01, 0.5, 'running', 100, '{}', 0.5, 0.5);",
      "UPDATE training_sessions SET status = 'completed', end_time = '2023-01-01 11:00:00' WHERE session_id = 10;",
      "INSERT INTO training_sessions (session_id, model_id, start_time, end_time, learning_rate, training_loss, status, trained_by, training_config, gpu_usage, cpu_usage) VALUES (11, 0, '2023-01-02 10:00:00', NULL, 0.02, 0.6, 'running', 100, '{}', 0.6, 0.6);",
      "UPDATE training_sessions SET status = 'completed', end_time = '2023-01-02 12:00:00' WHERE session_id = 11;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named training_session_end_logger that fires AFTER UPDATE on the training_sessions table for each row only when the NEW.status is 'completed' and NEW.end_time is not NULL. If the user in NEW.trained_by exists in the users table, insert a log entry into the access_logs table with access_id set to the next sequential value (the current maximum access_id plus one, or 1 if none exist), user_id and accessed_by set to NEW.trained_by, model_id set to NEW.model_id, access_time and accessed_at set to NEW.end_time, and access_type and action set to 'end_session'. Return the NEW row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named log_training_session_end that, after updating a row in the training_sessions table, fires only when the NEW.status is 'completed' and NEW.end_time is not NULL, and if the user (NEW.trained_by) exists in the users table, inserts a log into the access_logs table. The log should set access_id to the current maximum access_id plus 1 (or 1 if it is NULL), user_id and accessed_by to NEW.trained_by, model_id to NEW.model_id, access_time and accessed_at to NEW.end_time, and access_type and action to 'end_session', and then return NEW.",
    "id": 44,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_training_session_end` that checks for the existence of a user in the `users` table where `user_id` matches the new `trained_by` value from the updated `training_sessions` row; if the user exists, it inserts a row into the `access_logs` table, populating `access_id` by calculating `COALESCE(MAX(access_id), 0) + 1` from `access_logs`, `user_id` with `NEW.trained_by`, `model_id` with `NEW.model_id`, `access_time` with `NEW.end_time`, `access_type` with the string 'end_session', `accessed_at` with `NEW.end_time`, `action` with the string 'end_session', and `accessed_by` with `NEW.trained_by`.\nSecond, define the trigger `training_session_end_logger` on table `training_sessions` that fires AFTER UPDATE for each row when the new `status` equals 'completed' and the new `end_time` is not null, and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named log_training_session_end that is executed automatically by a trigger named training_session_end_logger, which is defined to fire after an update operation on the training_sessions table for each modified row, but only when the updated row's status column equals the string 'completed' and its end_time column is not null; this function first checks for the existence of a user in the users table by selecting a constant value of 1 where the user_id column matches the new value of the trained_by column from the updated training_sessions row, and if such a user exists, it performs an insert into the access_logs table, populating the columns access_id, user_id, model_id, access_time, access_type, accessed_at, action, and accessed_by with values derived as follows: the access_id is calculated by selecting the maximum current value from the access_id column in the access_logs table, applying the COALESCE function to substitute 0 if the maximum is null, and then adding 1 to that result; the user_id is set to the new trained_by value; the model_id is set to the new model_id value; the access_time is set to the new end_time value; the access_type is set to the string literal 'end_session'; the accessed_at is also set to the new end_time value; the action is set to the string literal 'end_session'; and the accessed_by is set to the new trained_by value; after this conditional insert, the function returns the new row record.",
    "original_summary": "Create an AFTER UPDATE row-level trigger function named log_training_session_end for the training_sessions table. It fires only when NEW.status is 'completed' and NEW.end_time is not NULL. If the user (NEW.trained_by) exists in the users table, insert a log into access_logs. Set access_id to the current max access_id + 1 (or 1 if NULL), user_id and accessed_by to NEW.trained_by, model_id to NEW.model_id, access_time and accessed_at to NEW.end_time, and access_type and action to 'end_session'. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How do you create an AFTER UPDATE row-level trigger function named log_training_session_end for the training_sessions table that fires only when NEW.status is 'completed' and NEW.end_time is not NULL, and if the user (NEW.trained_by) exists in the users table, inserts a log into access_logs? The log should set access_id to the current max access_id plus 1 (or 1 if NULL), user_id and accessed_by to NEW.trained_by, model_id to NEW.model_id, access_time and accessed_at to NEW.end_time, and access_type and action to 'end_session', and then return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `trg_log_permission_changes` that inserts a new row into the `audit_logs` table using values from the `NEW` record of the `user_permissions` table, specifically setting `audit_log_id` to the result of `COALESCE(MAX(audit_logs.audit_log_id), 0) + 1` from the `audit_logs` table, `user_id` to `NEW.user_id`, `action_type` to 'Permission Modified', `action_date` to `CURRENT_DATE::text`, `ip_address` to '127.0.0.1', and `user_agent` to 'System Trigger'. Second, define the trigger `log_permission_changes` on table `user_permissions` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_log_permission_changes() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO audit_logs (audit_log_id, user_id, action_type, action_date, ip_address, user_agent) VALUES ((SELECT COALESCE(MAX(audit_logs.audit_log_id), 0) + 1 FROM audit_logs), NEW.user_id, 'Permission Modified', CURRENT_DATE::text, '127.0.0.1', 'System Trigger');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_permission_changes\nAFTER INSERT ON user_permissions\nFOR EACH ROW EXECUTE FUNCTION trg_log_permission_changes();",
    "database_name": "human_resource_management_and_employee_information_system",
    "tables": [
      "users",
      "employees",
      "job_titles",
      "locations",
      "permissions",
      "user_permissions",
      "audit_logs"
    ],
    "call_sqls": [
      "INSERT INTO user_permissions (user_permission_id, user_id, permission_id) VALUES (2, 0, 1);",
      "INSERT INTO user_permissions (user_permission_id, user_id, permission_id) VALUES (3, 1, 0);",
      "INSERT INTO user_permissions (user_permission_id, user_id, permission_id) VALUES (4, 0, 0);",
      "INSERT INTO user_permissions (user_permission_id, user_id, permission_id) VALUES (5, 1, 1);",
      "INSERT INTO user_permissions (user_permission_id, user_id, permission_id) VALUES (6, 0, 1);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_log_permission_changes that, after each new row is inserted into the user_permissions table, logs an audit entry into the audit_logs table with an auto-incremented audit_log_id, captures the new user_id from the inserted row, records the action as 'Permission Modified', sets the action_date to the current date, and includes hardcoded system details for ip_address and user_agent.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_log_permission_changes that, after each new row is inserted into the user_permissions table, automatically logs an audit entry into the audit_logs table, capturing the new user_id, marking the action as 'Permission Modified', recording today's date, and including fixed system details like the IP address and user agent.",
    "id": 45,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `trg_log_permission_changes`. Second, define the trigger `trg_log_permission_changes` on table `user_permissions`.\n\nThe trigger function `trg_log_permission_changes` is defined to return a `TRIGGER` type and is executed `AFTER INSERT` on the `user_permissions` table, `FOR EACH ROW`. The function takes no explicit parameters but implicitly receives the `NEW` record representing the newly inserted row in the `user_permissions` table.\n\nInside the function, an `INSERT` operation is performed into the `audit_logs` table. The `INSERT` statement populates the following columns:\n- `audit_log_id`: This column is not explicitly set in the `INSERT` statement. It is assumed to be populated automatically, likely via a `SERIAL` or `BIGSERIAL` sequence or a `GENERATED BY DEFAULT AS IDENTITY` clause, as it is the primary key.\n- `user_id`: Set to the value of `NEW.user_id` from the newly inserted row in the `user_permissions` table.\n- `action_type`: Set to the string literal `'Permission Modified'`.\n- `action_date`: Set to the result of the `CURRENT_DATE` function, which returns the current date as a `date` type. This value is implicitly cast to `text` to match the column's data type.\n- `ip_address`: Set to the string literal `'192.168.1.100'`, representing a fixed system IP address.\n- `user_agent`: Set to the string literal `'System Trigger'`, representing a fixed system user agent.\n\nThe function then returns `NEW`, which is standard for `AFTER` row-level triggers in PostgreSQL.\n\nThe trigger named `trg_log_permission_changes` is created on the `user_permissions` table. It is configured to execute `AFTER INSERT` on the `user_permissions` table. The `FOR EACH ROW` clause specifies that the trigger function `trg_log_permission_changes()` is invoked once for each row inserted into the `user_permissions` table. The `EXECUTE FUNCTION trg_log_permission_changes()` clause binds the function to the trigger.",
    "original_ir": "Write a PLpgSQL trigger function that is executed after an insert operation on the user_permissions table. This function, named trg_log_permission_changes, inserts a new record into the audit_logs table. The inserted record includes the following values: audit_log_id, which is determined by selecting the maximum current audit_log_id from the audit_logs table and adding one to it, defaulting to 1 if no records exist; user_id, which is taken from the NEW record being inserted into the user_permissions table; action_type, which is set to the string 'Permission Modified'; action_date, which is set to the current date cast to text; ip_address, which is hardcoded as '127.0.0.1'; and user_agent, which is set to 'System Trigger'. The trigger, named log_permission_changes, is defined to execute this function for each row after an insert operation on the user_permissions table.",
    "original_summary": "Create an AFTER INSERT FOR EACH ROW trigger function named trg_log_permission_changes. It inserts a log into the audit_logs table with an auto-incremented ID, the NEW user_id, a 'Permission Modified' action, the current date as text, and hardcoded system details.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER INSERT FOR EACH ROW trigger function designated as trg_log_permission_changes. This function shall insert a record into the audit_logs table, comprising an auto-incremented identifier, the NEW user_id value, an action description of 'Permission Modified', the current date expressed as text, and predefined system details."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `create_readme_on_dataset_insert` that checks if the NEW row's `publication_status` equals 'published' and, if true, inserts a record into the `readme_files` table. The insert should use `(SELECT COALESCE(MAX(readme_id), 0) + 1 FROM readme_files)` for the `readme_id`, `NEW.dataset_id` for `dataset_id`, a concatenated string `'readme/' || NEW.dataset_id || '.txt'` for `file_path`, `0.5` for `file_size`, `CURRENT_DATE::text` for `upload_date`, `'TXT'` for `file_type`, and `'Auto-generated readme'` for `file_description`. The function must return NEW.\nSecond, define the trigger `trg_create_readme_on_dataset_insert` on table `datasets` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION create_readme_on_dataset_insert() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.publication_status = 'published' THEN\n    INSERT INTO readme_files (readme_id, dataset_id, file_path, file_size, upload_date, file_type, file_description)\n    VALUES ((SELECT COALESCE(MAX(readme_id), 0) + 1 FROM readme_files), NEW.dataset_id, 'readme/' || NEW.dataset_id || '.txt', 0.5, CURRENT_DATE::text, 'TXT', 'Auto-generated readme');\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_create_readme_on_dataset_insert\nAFTER INSERT ON datasets\nFOR EACH ROW EXECUTE FUNCTION create_readme_on_dataset_insert();",
    "database_name": "biomedical_research_and_data_management",
    "tables": [
      "datasets",
      "data_files",
      "data_analysis",
      "readme_files",
      "access_logs"
    ],
    "call_sqls": [
      "INSERT INTO datasets (dataset_id, dataset_name, publication_status) VALUES ('100', 'Test Dataset 1', 'published');",
      "INSERT INTO datasets (dataset_id, dataset_name, publication_status) VALUES ('101', 'Test Dataset 2', 'draft');",
      "INSERT INTO datasets (dataset_id, dataset_name, publication_status, source, description) VALUES ('102', 'Genomics Data', 'published', 'Internal Lab', 'Single-cell RNA-seq data');",
      "INSERT INTO datasets (dataset_id, dataset_name, publication_status, upload_date) VALUES ('103', 'Proteomics Study', 'published', '2024-01-15');",
      "INSERT INTO datasets (dataset_id, dataset_name, publication_status, version) VALUES ('104', 'Clinical Trial Data', 'published', '2.1');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_create_readme_on_dataset_insert that fires after each insert on the datasets table, and when the new row's publication_status is 'published', automatically creates a corresponding record in the readme_files table with a readme_id set to one more than the highest existing readme_id (or 1 if none exist), using the new dataset_id, a file_path constructed as 'readme/' followed by the dataset_id and '.txt', a file_size of 0.5, the current date as upload_date, 'TXT' as file_type, and 'Auto-generated readme' as file_description.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_create_readme_on_dataset_insert that runs AFTER INSERT on the datasets table, so that whenever a new row is inserted and its publication_status column is 'published', it automatically creates and inserts a corresponding record into the readme_files table. The trigger should generate a new readme_id by incrementing the current maximum readme_id from readme_files by 1, defaulting to 0 if none exist, then populate the readme_files columns: set dataset_id to the new dataset_id, form file_path as 'readme/' concatenated with the new dataset_id and '.txt', set file_size to 0.5, set upload_date to today's date as text, set file_type to 'TXT', and set file_description to 'Auto-generated readme'. The trigger should return the NEW row.",
    "id": 46,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `create_readme_on_dataset_insert` that checks if the NEW row's `publication_status` equals 'published' and, if true, inserts a record into the `readme_files` table. The insert should use `(SELECT COALESCE(MAX(readme_id), 0) + 1 FROM readme_files)` for the `readme_id`, `NEW.dataset_id` for `dataset_id`, a concatenated string `'readme/' || NEW.dataset_id || '.txt'` for `file_path`, `0.5` for `file_size`, `CURRENT_DATE::text` for `upload_date`, `'TXT'` for `file_type`, and `'Auto-generated readme'` for `file_description`. The function must return NEW.\nSecond, define the trigger `trg_create_readme_on_dataset_insert` on table `datasets` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named create_readme_on_dataset_insert that is executed automatically as an AFTER INSERT trigger on the datasets table for each new row inserted, where the function's logic is to conditionally insert a new record into the readme_files table only if the newly inserted row's publication_status column has the exact string value 'published'; within this conditional block, the function performs a SELECT query on the readme_files table to calculate the COALESCE of the maximum existing readme_id value and 0, then adds 1 to this result to generate a new unique readme_id; it then executes an INSERT operation into the readme_files table, populating the columns readme_id with the calculated value, dataset_id with the NEW.dataset_id value from the trigger, file_path with a concatenated string formed by the literal 'readme/', followed by the NEW.dataset_id value, followed by the literal '.txt', file_size with the numeric value 0.5, upload_date with the current date converted to text via CURRENT_DATE::text, file_type with the literal string 'TXT', and file_description with the literal string 'Auto-generated readme'; after the conditional block, the function returns the NEW row record to the trigger mechanism.",
    "original_summary": "Create an AFTER INSERT trigger function on the datasets table. If the new row's publication_status is 'published', insert a new record into the readme_files table. Generate the new readme_id by adding 1 to the current maximum readme_id (or 0 if none). Populate the columns: readme_id with the generated value, dataset_id with NEW.dataset_id, file_path as 'readme/' || NEW.dataset_id || '.txt', file_size as 0.5, upload_date as CURRENT_DATE::text, file_type as 'TXT', and file_description as 'Auto-generated readme'. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER INSERT trigger function that will be applied to the datasets table. Whenever a new row is inserted, if its publication_status column is specifically set to the value 'published', then you must meticulously create and insert a corresponding new record into the readme_files table. To generate the new readme_id, carefully calculate it by taking the current maximum readme_id value from the readme_files table and adding 1 to it; if no records exist yet, gracefully default this starting value to 0. You should then thoroughly populate all the necessary columns: assign the generated sequential number to readme_id, set dataset_id to the NEW.dataset_id from the triggering insert, form the file_path by concatenating the string 'readme/' with the NEW.dataset_id and the extension '.txt', explicitly set file_size to 0.5, set upload_date to the text representation of today's CURRENT_DATE, designate file_type as 'TXT', and finally, provide a file_description stating 'Auto-generated readme'. The function must conclusively return the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_customer_status_on_order` that checks if `NEW.customer_id` is not NULL and, if true, updates the `customers` table by setting `customer_status` to 'active' where `customer_id` matches `NEW.customer_id`. Second, define the trigger `trg_update_customer_status` on table `orders` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_customer_status_on_order() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.customer_id IS NOT NULL THEN\n        UPDATE customers\n        SET customer_status = 'active'\n        WHERE customer_id = NEW.customer_id;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_customer_status\nAFTER INSERT ON orders\nFOR EACH ROW EXECUTE FUNCTION update_customer_status_on_order();",
    "database_name": "customer_relationship_management_and_data_tracking_130963",
    "tables": [
      "customers",
      "orders",
      "order_items"
    ],
    "call_sqls": [
      "INSERT INTO orders (order_id, customer_id, order_date, total_cost, status) VALUES (1, 0, '2023-01-01', '100.00', 'pending');",
      "INSERT INTO orders (order_id, customer_id, order_date, total_cost, status) VALUES (2, 1, '2023-01-02', '250.50', 'completed');",
      "INSERT INTO orders (order_id, customer_id, order_date, total_cost, status) VALUES (3, 0, '2023-01-03', '75.20', 'shipped');",
      "INSERT INTO orders (order_id, customer_id, order_date, total_cost, status) VALUES (4, 1, '2023-01-04', '120.00', 'pending');",
      "INSERT INTO orders (order_id, customer_id, order_date, total_cost, status) VALUES (5, 0, '2023-01-05', '300.00', 'completed');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_customer_status that fires after each row is inserted into the ORDERS table, and when the new row's CUSTOMER_ID is not null, it updates the CUSTOMERS table by setting CUSTOMER_STATUS to 'active' for the matching CUSTOMER_ID.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named `update_customer_status_on_order` that, after a new row is inserted into the `orders` table, updates the `customer_status` to 'active' in the `customers` table for the matching `customer_id` if it is not empty, and returns the new record.",
    "id": 47,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_customer_status_on_order` that checks if `NEW.customer_id` is not NULL and, if true, updates the `customers` table by setting `customer_status` to 'active' where `customer_id` matches `NEW.customer_id`. Second, define the trigger `trg_update_customer_status` on table `orders` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger that, after a new row is successfully inserted into the `orders` table, executes a function named `update_customer_status_on_order` for each individual row that was inserted. The `update_customer_status_on_order` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. Upon execution, this function first checks a conditional statement: it evaluates whether the `customer_id` column of the newly inserted row (referred to as `NEW.customer_id`) is not null. If this condition is true, meaning a valid customer ID is present in the new order, the function then performs an `UPDATE` operation on the `customers` table. Specifically, it sets the `customer_status` column to the string literal value `'active'` for all rows in the `customers` table where the `customer_id` column matches the value of `NEW.customer_id` (the customer ID from the newly inserted order). After this potential update, the function concludes by returning the `NEW` record, which represents the newly inserted row in the `orders` table, allowing the `INSERT` operation to complete successfully.",
    "original_summary": "Create a trigger function `update_customer_status_on_order` and a trigger that fires after each row insert into the `orders` table. If the new row's `customer_id` is not null, the function updates the `customers` table, setting `customer_status` to 'active' where `customer_id` matches. The function returns the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger function, let's call it `update_customer_status_on_order`. Then, we gotta set up a trigger that goes off every time a new row is popped into the `orders` table. The function's job is this: if the new order's `customer_id` isn't empty, it should go and flip the `customer_status` to 'active' in the `customers` table for that matching customer ID. Oh, and the function needs to spit back the NEW record at the end."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `log_product_access` that inserts a new record into the `access_logs` table, using `nextval('access_logs_log_id_seq')` for `log_id`, `0` for `user_id`, `NEW.ndc_code` for `ndc_code`, `NOW()::text` for `access_time`, `'product_created'` for `action`, `'127.0.0.1'` for `ip_address`, `'System'` for `user_agent`, and `'0 seconds'` for `duration`, and includes an `ON CONFLICT (log_id) DO NOTHING` clause before returning `NEW`. Second, define the trigger `products_log_creation_trigger` on table `products` that fires `AFTER` `INSERT` and executes the function `log_product_access()`.",
    "plsql": "CREATE SEQUENCE IF NOT EXISTS access_logs_log_id_seq OWNED BY access_logs.log_id;\nSELECT setval('access_logs_log_id_seq', COALESCE((SELECT MAX(log_id) FROM access_logs), 0) + 1, false);\n\nCREATE OR REPLACE FUNCTION log_product_access() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO access_logs (log_id, user_id, ndc_code, access_time, action, ip_address, user_agent, duration) \n  VALUES (nextval('access_logs_log_id_seq'), 0, NEW.ndc_code, NOW()::text, 'product_created', '127.0.0.1', 'System', '0 seconds')\n  ON CONFLICT (log_id) DO NOTHING;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER products_log_creation_trigger\nAFTER INSERT ON products\nFOR EACH ROW EXECUTE FUNCTION log_product_access();",
    "database_name": "pharmaceutical_product_management_and_tracking_414516",
    "tables": [
      "access_logs",
      "adverse_events",
      "companies",
      "product_approvals",
      "product_recalls",
      "products",
      "users"
    ],
    "call_sqls": [
      "INSERT INTO products (ndc_code, proprietary_name, non_proprietary_name, dosage_form, route_name, company_id, product_type, strength, formulation_date, distribution_channel, regulatory_status, packaging_info) VALUES ('0001-0001', 'New Drug A', 'Generic A', 'Tablet', 'Oral', 0, 'Human Prescription Drug', '10mg', '2023-01-01', 'retail', 'FDA approved', 'bottle');",
      "INSERT INTO products (ndc_code, proprietary_name, non_proprietary_name, dosage_form, route_name, company_id, product_type, strength, formulation_date, distribution_channel, regulatory_status, packaging_info) VALUES ('0002-0002', 'New Drug B', 'Generic B', 'Capsule', 'Oral', 1, 'Human Prescription Drug', '25mg', '2023-02-01', 'hospital', 'FDA approved', 'blister pack');",
      "INSERT INTO products (ndc_code, proprietary_name, non_proprietary_name, dosage_form, route_name, company_id, product_type, strength, formulation_date, distribution_channel, regulatory_status, packaging_info) VALUES ('0003-0003', 'New Drug C', 'Generic C', 'Injection', 'Intravenous', 0, 'Human Prescription Drug', '100mg/mL', '2023-03-01', 'retail', 'FDA approved', 'vial');",
      "INSERT INTO products (ndc_code, proprietary_name, non_proprietary_name, dosage_form, route_name, company_id, product_type, strength, formulation_date, distribution_channel, regulatory_status, packaging_info) VALUES ('0004-0004', 'New Drug D', 'Generic D', 'Cream', 'Topical', 1, 'Human Prescription Drug', '0.5%', '2023-04-01', 'retail', 'FDA approved', 'tube');",
      "INSERT INTO products (ndc_code, proprietary_name, non_proprietary_name, dosage_form, route_name, company_id, product_type, strength, formulation_date, distribution_channel, regulatory_status, packaging_info) VALUES ('0005-0005', 'New Drug E', 'Generic E', 'Syrup', 'Oral', 0, 'Human Prescription Drug', '50mg/5mL', '2023-05-01', 'hospital', 'FDA approved', 'bottle');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `products_log_creation_trigger` that executes after each INSERT on the `products` table to automatically log product creation events into the `access_logs` table. The trigger should insert a new record in `access_logs` with the `log_id` generated from the `access_logs_log_id_seq` sequence, set `user_id` to 0, populate `ndc_code` from the newly inserted product's `ndc_code`, record `access_time` as the current timestamp, set `action` to 'product_created', `ip_address` to '127.0.0.1', `user_agent` to 'System', and `duration` to '0 seconds', while ignoring any conflicts on `log_id`.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named `products_log_creation_trigger` that executes after each INSERT on the `products` table, calling the function `log_product_access` to insert a record into the `access_logs` table. The function should populate the `log_id` using a sequence `access_logs_log_id_seq` linked to the `log_id` column, starting at one more than the current maximum `log_id` or at 1 if the table is empty. For each new product, set `user_id` to 0, `ndc_code` from `NEW.ndc_code`, `access_time` as the current timestamp in text, `action` as 'product_created', `ip_address` as '127.0.0.1', `user_agent` as 'System', and `duration` as '0 seconds', ignoring any conflict on `log_id`, and return the `NEW` record.",
    "id": 48,
    "generated_ir": "Write a PostgreSQL PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named log_product_access that returns a trigger, which is executed by a trigger named products_log_creation_trigger configured to fire AFTER INSERT on the products table FOR EACH ROW. The function's logic begins by declaring a variable max_log_id of type bigint to store the maximum existing log_id value from the access_logs table. It then performs a SELECT operation on the access_logs table to retrieve the maximum value of the log_id column, storing the result into the max_log_id variable; if the table is empty, this SELECT returns NULL. Next, it uses a conditional check: if max_log_id is NULL, it sets the next value from the sequence access_logs_log_id_seq to 1 by using the setval function to initialize the sequence; otherwise, it sets the sequence to start at max_log_id + 1 using setval. Following this, it performs an INSERT operation into the access_logs table with the following column values: log_id is populated by calling nextval on the access_logs_log_id_seq sequence to generate the next sequential value, user_id is set to the integer 0, ndc_code is set to the NEW.ndc_code value from the inserted row in the products table, access_time is set to the current timestamp converted to text format using the now() function, action is set to the string 'product_created', ip_address is set to the string '127.0.0.1', user_agent is set to the string 'System', and duration is set to the string '0 seconds'. This INSERT operation includes an ON CONFLICT clause on the log_id column to do nothing if a conflict occurs, effectively ignoring any duplicate log_id values. Finally, the function returns the NEW row record to the trigger execution context. Second, define the trigger products_log_creation_trigger on the products table to execute the log_product_access function AFTER INSERT for each row.",
    "original_ir": "Write a PL/pgSQL script that first ensures the existence of a sequence named `access_logs_log_id_seq` and associates it with the `log_id` column of the `access_logs` table, then initializes this sequence by setting its next value to one greater than the maximum `log_id` currently present in the `access_logs` table, or to 1 if the `access_logs` table is empty, and then defines a trigger function named `log_product_access` that returns a `TRIGGER` type. This function, when executed, inserts a new record into the `access_logs` table. The `log_id` column of this new record is populated by the next value from the `access_logs_log_id_seq` sequence. The `user_id` column is set to the integer value `0`. The `ndc_code` column is populated with the value of the `ndc_code` column from the newly inserted row in the `products` table (referred to as `NEW.ndc_code`). The `access_time` column is set to the current timestamp converted to a text string. The `action` column is set to the string literal `'product_created'`. The `ip_address` column is set to the string literal `'127.0.0.1'`. The `user_agent` column is set to the string literal `'System'`. The `duration` column is set to the string literal `'0 seconds'`. If an insertion attempt results in a conflict on the `log_id` primary key or unique constraint, no action is taken for that specific record. After the insertion attempt, the function returns the `NEW` row, which represents the row that caused the trigger to fire. Finally, the script creates a trigger named `products_log_creation_trigger` that is activated `AFTER INSERT` operations on the `products` table. This trigger is configured to execute `FOR EACH ROW` that is inserted into the `products` table, and it invokes the `log_product_access()` function for each such row.",
    "original_summary": "Create a sequence `access_logs_log_id_seq` linked to `access_logs.log_id`, set its next value to one greater than the max `log_id` (or 1 if empty). Create a trigger function `log_product_access` that, after INSERT on `products`, inserts a record into `access_logs`. Populate `log_id` from the sequence, `user_id` as 0, `ndc_code` from `NEW.ndc_code`, `access_time` as current timestamp text, `action` as 'product_created', `ip_address` as '127.0.0.1', `user_agent` as 'System', `duration` as '0 seconds'. On `log_id` conflict, do nothing. Return `NEW`. Create an AFTER INSERT trigger `products_log_creation_trigger` on `products` FOR EACH ROW executing this function.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a sequence named `access_logs_log_id_seq` that is explicitly linked to the `log_id` column within the `access_logs` table. Carefully initialize this sequence so that its next value is set to one greater than the current maximum `log_id` found in the table; however, if the table is empty, you should thoughtfully set this starting value to 1. Following this, you must create a detailed and comprehensive trigger function called `log_product_access`. This function should be designed to automatically execute after any INSERT operation on the `products` table. Its primary purpose is to gracefully insert a new, descriptive record into the `access_logs` table. For this new record, you should meticulously populate the `log_id` by fetching the next value from the newly created sequence, set the `user_id` to a default value of 0, extract the `ndc_code` directly from the `NEW.ndc_code` value, capture the precise `access_time` as the current timestamp formatted as text, define the `action` specifically as 'product_created', assign the `ip_address` as '127.0.0.1', specify the `user_agent` as 'System', and finally, record the `duration` as '0 seconds'. Importantly, if a conflict arises on the `log_id`, the function should quietly do nothing. It must then thoughtfully return the `NEW` record. Finally, establish an AFTER INSERT trigger named `products_log_creation_trigger` on the `products` table, which will dutifully execute the aforementioned function FOR EACH ROW that is inserted."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_insert_treatment_on_genetic` that calculates the next `outcome_id` for the `treatment_outcomes` table by selecting the maximum existing `outcome_id`, using `COALESCE` to default to 0 if the table is empty, and adding 1. It then inserts a new row into `treatment_outcomes` with this ID, using `NEW.patient_id` and `NEW.test_date` from the `genetic_markers` table, setting `treatment_type` to 'Genetic-Based Intervention', `response` to 'Pending', and `progression` to 'Stable'. The insert must include an `ON CONFLICT` clause on the `outcome_id` column to update the existing row's `patient_id`, `treatment_type`, `treatment_start_date`, `response`, and `progression` with the values from `EXCLUDED`. The function must return `NEW`.\nSecond, define the trigger `insert_treatment_on_genetic` on table `genetic_markers` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_insert_treatment_on_genetic() RETURNS TRIGGER AS $$\nDECLARE\n    next_outcome_id bigint;\nBEGIN\n    -- Get the next outcome_id safely\n    SELECT COALESCE(MAX(outcome_id), 0) + 1 INTO next_outcome_id FROM treatment_outcomes;\n    \n    -- Insert with explicit handling for potential duplicate key\n    INSERT INTO treatment_outcomes (outcome_id, patient_id, treatment_type, treatment_start_date, response, progression)\n    VALUES (next_outcome_id, NEW.patient_id, 'Genetic-Based Intervention', NEW.test_date, 'Pending', 'Stable')\n    ON CONFLICT (outcome_id) DO UPDATE SET\n        patient_id = EXCLUDED.patient_id,\n        treatment_type = EXCLUDED.treatment_type,\n        treatment_start_date = EXCLUDED.treatment_start_date,\n        response = EXCLUDED.response,\n        progression = EXCLUDED.progression;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_treatment_on_genetic\nAFTER INSERT ON genetic_markers\nFOR EACH ROW EXECUTE FUNCTION trg_insert_treatment_on_genetic();",
    "database_name": "medical_research_and_patient_data_management",
    "tables": [
      "genetic_markers",
      "lifestyle_factors",
      "neuroimaging",
      "treatment_outcomes"
    ],
    "call_sqls": [
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (2, 3, 1, 0, 0, '2023-03-15', 'City Clinic', 'Dr. Carol', 'New patient, initial genetic screening.');",
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (3, 4, 0, 1, 0, '2023-04-01', 'Research Lab', 'Dr. David', 'Follow-up test for APOE4 status.');",
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (4, 5, 0, 0, 1, '2023-05-10', 'Main Hospital', 'Dr. Alice', 'Patient with strong family history.');",
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (5, 6, 1, 0, 0, '2023-06-20', 'City Clinic', 'Dr. Bob', 'Routine genetic check-up.');",
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (6, 7, 0, 1, 0, '2023-07-05', 'Research Lab', 'Dr. Carol', 'Genetic test for specific research study.');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_insert_treatment_on_genetic that fires AFTER INSERT on the genetic_markers table for each new row, and for each new marker, it generates the next outcome_id for the treatment_outcomes table by taking the maximum existing outcome_id (or 0 if none) and adding 1, then inserts a new treatment outcome with this ID, using the new row's patient_id and test_date as treatment_start_date, setting treatment_type to 'Genetic-Based Intervention', response to 'Pending', and progression to 'Stable', and if a row with the same outcome_id already exists, it updates that existing row with the new values.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_insert_treatment_on_genetic that, after each new row is inserted into the genetic_markers table, automatically generates the next outcome_id for the treatment_outcomes table by taking the highest existing outcome_id (or starting at 1 if none exist), then inserts a corresponding treatment outcome record using the new marker's patient_id and test_date, with treatment_type set to 'Genetic-Based Intervention', response to 'Pending', and progression to 'Stable', and if an outcome_id already exists, updates that existing row with these new values instead, while ensuring the trigger returns the NEW row.",
    "id": 49,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_insert_treatment_on_genetic` that calculates the next `outcome_id` for the `treatment_outcomes` table by selecting the maximum existing `outcome_id`, using `COALESCE` to default to 0 if the table is empty, and adding 1. It then inserts a new row into `treatment_outcomes` with this ID, using `NEW.patient_id` and `NEW.test_date` from the `genetic_markers` table, setting `treatment_type` to 'Genetic-Based Intervention', `response` to 'Pending', and `progression` to 'Stable'. The insert must include an `ON CONFLICT` clause on the `outcome_id` column to update the existing row's `patient_id`, `treatment_type`, `treatment_start_date`, `response`, and `progression` with the values from `EXCLUDED`. The function must return `NEW`.\nSecond, define the trigger `insert_treatment_on_genetic` on table `genetic_markers` that fires `AFTER` `INSERT` and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that is executed after an insert operation on the genetic_markers table. This function, named trg_insert_treatment_on_genetic, does not take any parameters directly but operates on the data from the newly inserted row, referred to as NEW. The function begins by declaring a variable next_outcome_id of type bigint, which is used to store the next available outcome_id for insertion into the treatment_outcomes table. It then performs a SELECT query on the treatment_outcomes table to determine the maximum value of the outcome_id column, using the COALESCE function to handle cases where the table might be empty by defaulting to 0. The result of this query, incremented by 1, is stored in the next_outcome_id variable. Following this, the function attempts to insert a new row into the treatment_outcomes table with the following values: next_outcome_id for the outcome_id column, NEW.patient_id for the patient_id column, the string 'Genetic-Based Intervention' for the treatment_type column, NEW.test_date for the treatment_start_date column, the string 'Pending' for the response column, and the string 'Stable' for the progression column. The insertion is performed with an ON CONFLICT clause on the outcome_id column, which specifies that if a conflict occurs (i.e., if a row with the same outcome_id already exists), the existing row should be updated with the values from the attempted insertion using the special table EXCLUDED, which holds the values that would have been inserted. Specifically, the patient_id, treatment_type, treatment_start_date, response, and progression columns of the existing row are updated to the corresponding values from EXCLUDED. Finally, the function returns the NEW row, allowing the trigger to complete its operation. The trigger itself, named insert_treatment_on_genetic, is defined to execute this function after each row is inserted into the genetic_markers table.",
    "original_summary": "Create an AFTER INSERT trigger function named trg_insert_treatment_on_genetic for the genetic_markers table. For each new marker, generate the next outcome_id for treatment_outcomes by calculating (COALESCE(MAX(outcome_id), 0) + 1). Insert a new treatment outcome with this ID, using the new row's patient_id and test_date, setting treatment_type to 'Genetic-Based Intervention', response to 'Pending', and progression to 'Stable'. Use ON CONFLICT on outcome_id to update the existing row with the new values. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER INSERT trigger function called trg_insert_treatment_on_genetic for the genetic_markers table that, for each new marker, generates the next outcome_id for treatment_outcomes by calculating (COALESCE(MAX(outcome_id), 0) + 1), inserts a new treatment outcome with this ID using the new row's patient_id and test_date, sets treatment_type to 'Genetic-Based Intervention', response to 'Pending', and progression to 'Stable', and uses ON CONFLICT on outcome_id to update the existing row with the new values, while returning NEW?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `check_apoe4_high_risk` that checks if the sum of the `NEW.apoe4_0`, `NEW.apoe4_1`, and `NEW.apoe4_2` columns is greater than or equal to 2 and, if true, inserts a new row into the `high_risk_patients` table with the `NEW.patient_id`, the literal string `'APOE4_HIGH'` as the risk_factor, and the `CURRENT_DATE` as the detected_date, then returns the `NEW` record.\nSecond, define the trigger `genetic_markers_high_risk_trigger` on table `genetic_markers` that fires `AFTER` `INSERT` and executes the function `check_apoe4_high_risk()`.",
    "plsql": "CREATE TABLE IF NOT EXISTS high_risk_patients (\n    patient_id BIGINT,\n    risk_factor TEXT,\n    detected_date DATE\n);\n\nCREATE OR REPLACE FUNCTION check_apoe4_high_risk() RETURNS TRIGGER AS $$\nBEGIN\n  IF (NEW.apoe4_0 + NEW.apoe4_1 + NEW.apoe4_2) >= 2 THEN\n    INSERT INTO high_risk_patients (patient_id, risk_factor, detected_date)\n    VALUES (NEW.patient_id, 'APOE4_HIGH', CURRENT_DATE);\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER genetic_markers_high_risk_trigger\nAFTER INSERT ON genetic_markers\nFOR EACH ROW EXECUTE FUNCTION check_apoe4_high_risk();",
    "database_name": "medical_research_and_patient_data_management",
    "tables": [
      "genetic_markers",
      "lifestyle_factors",
      "neuroimaging"
    ],
    "call_sqls": [
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (1, 1, 1, 1, 0, '2023-01-01', 'Main Hospital', 'Dr. Alice', 'Sample quality was high.');",
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (2, 2, 0, 1, 1, '2023-01-02', 'Main Hospital', 'Dr. Bob', 'Sample quality was good.');",
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (3, 1, 1, 0, 1, '2023-01-03', 'Main Hospital', 'Dr. Alice', 'Sample quality was high.');",
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (4, 2, 1, 1, 1, '2023-01-04', 'Main Hospital', 'Dr. Bob', 'Sample quality was good.');",
      "INSERT INTO genetic_markers (genetic_id, patient_id, apoe4_0, apoe4_1, apoe4_2, test_date, test_location, test_conducted_by, notes) VALUES (5, 1, 0, 0, 2, '2023-01-05', 'Main Hospital', 'Dr. Alice', 'Sample quality was high.');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named genetic_markers_high_risk_trigger that fires AFTER INSERT on the genetic_markers table for each row, where if the sum of the NEW.apoe4_0, NEW.apoe4_1, and NEW.apoe4_2 values is greater than or equal to 2, it inserts a record into the high_risk_patients table with the patient_id from the new row, 'APOE4_HIGH' as the risk_factor, and the current date as the detected_date.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger that first ensures a table named high_risk_patients exists with columns patient_id, risk_factor, and detected_date, then creates a trigger function named check_apoe4_high_risk that activates AFTER INSERT on the genetic_markers table for each new row, checks if the sum of the NEW.apoe4_0, NEW.apoe4_1, and NEW.apoe4_2 values is at least 2, and if so, inserts a record into high_risk_patients with the patient_id, 'APOE4_HIGH' as the risk factor, and the current date, before returning NEW, and finally creates a trigger named genetic_markers_high_risk_trigger to execute this function.",
    "id": 50,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, ensure the existence of a table named high_risk_patients with columns patient_id (bigint), risk_factor (text), and detected_date (date). If the table does not exist, create it. Second, create a trigger function named check_apoe4_high_risk that is executed after a new row is inserted into the genetic_markers table. This function operates on a row-level basis. It calculates the sum of the values from the NEW.apoe4_0, NEW.apoe4_1, and NEW.apoe4_2 columns of the newly inserted row. If this sum is greater than or equal to 2, the function performs an insert operation into the high_risk_patients table. The inserted record includes the patient_id from the NEW row, the constant string 'APOE4_HIGH' as the risk_factor, and the current system date (obtained via the CURRENT_DATE function) as the detected_date. After this conditional insertion, the function returns the NEW row, allowing the original insert operation on the genetic_markers table to complete. Finally, define a trigger named genetic_markers_high_risk_trigger on the genetic_markers table. This trigger is configured to execute the check_apoe4_high_risk function after each row is inserted into the genetic_markers table.",
    "original_ir": "Write a PL/pgSQL script that first creates a table named `high_risk_patients` if it does not already exist. This table is designed to store information about patients identified as high-risk. It contains three columns: `patient_id` of type `BIGINT` to uniquely identify the patient, `risk_factor` of type `TEXT` to describe the specific risk identified, and `detected_date` of type `DATE` to record when the risk was detected. Following the table creation, the script defines a PL/pgSQL function named `check_apoe4_high_risk`. This function is designed to operate as a trigger and therefore returns a `TRIGGER` type. It does not accept any explicit parameters but implicitly receives `NEW` and `OLD` records when invoked by a trigger. Inside the function, a conditional statement (`IF`) evaluates a specific genetic marker condition. It checks if the sum of the values in the `apoe4_0`, `apoe4_1`, and `apoe4_2` columns of the `NEW` record (representing the newly inserted or updated row) is greater than or equal to `2`. If this condition is met, indicating a high-risk genetic profile, an `INSERT` operation is performed. This operation adds a new row into the `high_risk_patients` table. The `patient_id` for this new row is taken from the `patient_id` column of the `NEW` record. The `risk_factor` column is set to the literal string `'APOE4_HIGH'`, and the `detected_date` column is populated with the `CURRENT_DATE`, representing the date and time when the trigger fired. After the conditional check and potential insertion, the function always returns the `NEW` record, which is standard behavior for `BEFORE` or `AFTER` row-level triggers that do not modify the `NEW` record. Finally, the script creates a trigger named `genetic_markers_high_risk_trigger`. This trigger is configured to execute `AFTER INSERT` operations on the `genetic_markers` table. It is a `FOR EACH ROW` trigger, meaning it will execute the associated function once for every row inserted into the `genetic_markers` table. The function executed by this trigger is `check_apoe4_high_risk()`.",
    "original_summary": "Create a PL/pgSQL script that first creates a table named high_risk_patients with columns patient_id (BIGINT), risk_factor (TEXT), and detected_date (DATE) if it does not exist. Then, create a trigger function named check_apoe4_high_risk that fires AFTER INSERT on the genetic_markers table FOR EACH ROW. If the sum of NEW.apoe4_0, NEW.apoe4_1, and NEW.apoe4_2 is >= 2, it inserts a new record into high_risk_patients with the patient_id, 'APOE4_HIGH' as risk_factor, and CURRENT_DATE. The function returns NEW. Finally, create a trigger named genetic_markers_high_risk_trigger to execute this function.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a PL/pgSQL script that first ensures a table named high_risk_patients exists with columns for patient_id (BIGINT), risk_factor (TEXT), and detected_date (DATE)? Then, how do I create a trigger function named check_apoe4_high_risk that activates AFTER INSERT on the genetic_markers table for each new row? This function should check if the sum of the NEW.apoe4_0, NEW.apoe4_1, and NEW.apoe4_2 values is at least 2, and if so, insert a record into high_risk_patients with the patient_id, 'APOE4_HIGH' as the risk factor, and the current date, before returning NEW. Finally, how is the trigger named genetic_markers_high_risk_trigger created to execute this function?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_insert_imaging_on_outcome` that inserts a new record into the `neuroimaging` table using values from the `NEW` record of the `treatment_outcomes` table. The function must populate the `neuroimaging` columns as follows: set `image_id` to the result of `COALESCE(MAX(image_id), 0) + 1` from the `neuroimaging` table; set `patient_id` to `NEW.patient_id`; set `image_date` to `NEW.treatment_start_date`; set `image_location` to the literal string `'Follow-up Clinic'`; set `image_conducted_by` to `'System'`; set `image_quality` to `'Standard'`; and set `notes` to `'Triggered by treatment outcome.'`. The function must end by returning `NEW`.\nSecond, define the trigger `insert_imaging_on_outcome` on table `treatment_outcomes` that fires `AFTER` `INSERT` for each row and executes the function `trg_insert_imaging_on_outcome`.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_insert_imaging_on_outcome() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO neuroimaging (image_id, patient_id, image_date, image_location, image_conducted_by, image_quality, notes)\n    VALUES ((SELECT COALESCE(MAX(image_id), 0) + 1 FROM neuroimaging), NEW.patient_id, NEW.treatment_start_date, 'Follow-up Clinic', 'System', 'Standard', 'Triggered by treatment outcome.');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_imaging_on_outcome\nAFTER INSERT ON treatment_outcomes\nFOR EACH ROW EXECUTE FUNCTION trg_insert_imaging_on_outcome();",
    "database_name": "medical_research_and_patient_data_management",
    "tables": [
      "genetic_markers",
      "lifestyle_factors",
      "neuroimaging",
      "treatment_outcomes"
    ],
    "call_sqls": [
      "INSERT INTO treatment_outcomes (outcome_id, patient_id, treatment_type, treatment_start_date, response) VALUES (1, 1, 'Medication A', '2024-01-15', 'Positive');",
      "INSERT INTO treatment_outcomes (outcome_id, patient_id, treatment_type, treatment_start_date, treatment_end_date, progression) VALUES (2, 2, 'Therapy B', '2024-02-01', '2024-05-01', 'Stable');",
      "INSERT INTO treatment_outcomes (outcome_id, patient_id, treatment_type, treatment_start_date, adverse_events) VALUES (3, 3, 'Drug C', '2024-03-10', 'Mild nausea');",
      "INSERT INTO treatment_outcomes (outcome_id, patient_id, treatment_type, treatment_start_date, follow_up_notes) VALUES (4, 1, 'Medication A', '2024-04-20', 'Patient reported improvement');",
      "INSERT INTO treatment_outcomes (outcome_id, patient_id, treatment_type, treatment_start_date, treatment_dosage, treatment_frequency) VALUES (5, 4, 'Treatment D', '2024-05-05', '50mg', 'Daily');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_insert_imaging_on_outcome that, after each new row is inserted into the treatment_outcomes table, automatically adds a corresponding record to the neuroimaging table. For each new outcome, generate a unique image_id by taking the highest existing image_id from neuroimaging (or starting at 1 if none exist), use the new row's patient_id and treatment_start_date for patient_id and image_date respectively, set image_location to 'Follow-up Clinic', image_conducted_by to 'System', image_quality to 'Standard', and notes to 'Triggered by treatment outcome.'",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named 'trg_insert_imaging_on_outcome' that, after each new record is inserted into the 'treatment_outcomes' table, automatically creates a corresponding entry in the 'neuroimaging' table. The new 'image_id' should be generated by taking the highest existing 'image_id' from the 'neuroimaging' table (or starting at zero if none exist) and adding one to it. Use the 'patient_id' and 'treatment_start_date' from the newly inserted outcome record for the 'patient_id' and 'image_date' fields, respectively. Set the 'image_location' to 'Follow-up Clinic', 'image_conducted_by' to 'System', 'image_quality' to 'Standard', and include the note 'Triggered by treatment outcome.' in the 'notes' field. The trigger should return the NEW record.",
    "id": 51,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_insert_imaging_on_outcome` that inserts a new record into the `neuroimaging` table using values from the `NEW` record of the `treatment_outcomes` table. The function must populate the `neuroimaging` columns as follows: set `image_id` to the result of `COALESCE(MAX(image_id), 0) + 1` from the `neuroimaging` table; set `patient_id` to `NEW.patient_id`; set `image_date` to `NEW.treatment_start_date`; set `image_location` to the literal string `'Follow-up Clinic'`; set `image_conducted_by` to `'System'`; set `image_quality` to `'Standard'`; and set `notes` to `'Triggered by treatment outcome.'`. The function must end by returning `NEW`.\nSecond, define the trigger `insert_imaging_on_outcome` on table `treatment_outcomes` that fires `AFTER` `INSERT` for each row and executes the function `trg_insert_imaging_on_outcome`.",
    "original_ir": "Write a PL/pgSQL trigger function named `trg_insert_imaging_on_outcome` that is designed to be executed after an `INSERT` operation on the `treatment_outcomes` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the data before and after the triggering event. Specifically, it utilizes the `NEW` record, which contains the newly inserted row's data from the `treatment_outcomes` table. The primary action of this function is to insert a new record into the `neuroimaging` table. The values for the columns of this new `neuroimaging` record are determined as follows: the `image_id` column is populated by first selecting the maximum existing `image_id` from the `neuroimaging` table, using `COALESCE` to default to `0` if no records exist (i.e., `MAX(image_id)` returns `NULL`), and then adding `1` to this value, effectively generating a new sequential identifier. The `patient_id` column is populated with the value from the `patient_id` column of the `NEW` record (the newly inserted row in `treatment_outcomes`). The `image_date` column is populated with the value from the `treatment_start_date` column of the `NEW` record. The `image_location` column is set to the literal string `'Follow-up Clinic'`. The `image_conducted_by` column is set to the literal string `'System'`. The `image_quality` column is set to the literal string `'Standard'`. The `notes` column is set to the literal string `'Triggered by treatment outcome.'`. After performing this insertion, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the original `INSERT` operation on `treatment_outcomes` should proceed with the newly inserted row.\n\nThis trigger function is then associated with a trigger named `insert_imaging_on_outcome`. This trigger is configured to activate `AFTER INSERT` operations on the `treatment_outcomes` table. It is a `FOR EACH ROW` trigger, meaning that the `trg_insert_imaging_on_outcome` function will be executed once for every row that is inserted into the `treatment_outcomes` table. The `EXECUTE FUNCTION trg_insert_imaging_on_outcome()` clause specifies that the `trg_insert_imaging_on_outcome` function should be invoked when the trigger fires.",
    "original_summary": "Create an AFTER INSERT trigger function named trg_insert_imaging_on_outcome for the treatment_outcomes table. For each new outcome, insert a row into the neuroimaging table. Generate a new image_id as (COALESCE(MAX(image_id), 0) + 1). Use the new row's patient_id for patient_id and treatment_start_date for image_date. Set image_location to 'Follow-up Clinic', image_conducted_by to 'System', image_quality to 'Standard', and notes to 'Triggered by treatment outcome.'. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER INSERT trigger function designated as 'trg_insert_imaging_on_outcome' for the 'treatment_outcomes' table. Upon the insertion of each new outcome record, it is required to insert a corresponding entry into the 'neuroimaging' table. The new 'image_id' shall be derived by calculating the maximum existing 'image_id', defaulting to zero if none are present, and incrementing that value by one. The 'patient_id' and 'treatment_start_date' from the newly inserted outcome row are to be utilized for the 'patient_id' and 'image_date' fields, respectively. Furthermore, the 'image_location' field should be assigned the value 'Follow-up Clinic', 'image_conducted_by' should be set to 'System', 'image_quality' to 'Standard', and the 'notes' field should contain the text 'Triggered by treatment outcome.'. The function must conclude by returning the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_team_stadium_capacity that updates the teams table by setting the stadium_capacity column to its current value plus 1000 for the row where team_id matches the NEW.team_id from the games table, and then returns NEW.\nSecond, define the trigger stadium_capacity_update_trigger on table games that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_team_stadium_capacity() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE teams SET stadium_capacity = stadium_capacity + 1000 WHERE team_id = NEW.team_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER stadium_capacity_update_trigger\nAFTER INSERT ON games\nFOR EACH ROW EXECUTE FUNCTION update_team_stadium_capacity();",
    "database_name": "sports_data_analysis_and_visualization",
    "tables": [
      "games",
      "player_contracts",
      "player_games",
      "player_stats",
      "players",
      "teams"
    ],
    "call_sqls": [
      "INSERT INTO games (game_id, season, team_id, opponent_id, game_date, game_time, home_team_score, away_team_score, location, attendance, referee, weather_conditions) VALUES (2, 2018, 0, 1, '2018-03-24', '19:00:00', 3, 2, 'Yankee Stadium', 26000, 'Mark Geiger', 'sunny');",
      "INSERT INTO games (game_id, season, team_id, opponent_id, game_date, game_time, home_team_score, away_team_score, location, attendance, referee, weather_conditions) VALUES (3, 2018, 1, 0, '2018-03-31', '19:00:00', 1, 1, \"Children's Mercy Park\", 18000, 'Ted Unkel', 'cloudy');",
      "INSERT INTO games (game_id, season, team_id, opponent_id, game_date, game_time, home_team_score, away_team_score, location, attendance, referee, weather_conditions) VALUES (4, 2018, 0, 1, '2018-04-07', '19:00:00', 2, 0, 'Yankee Stadium', 27000, 'Mark Geiger', 'rainy');",
      "INSERT INTO games (game_id, season, team_id, opponent_id, game_date, game_time, home_team_score, away_team_score, location, attendance, referee, weather_conditions) VALUES (5, 2018, 1, 0, '2018-04-14', '19:00:00', 0, 1, \"Children's Mercy Park\", 19000, 'Ted Unkel', 'sunny');",
      "INSERT INTO games (game_id, season, team_id, opponent_id, game_date, game_time, home_team_score, away_team_score, location, attendance, referee, weather_conditions) VALUES (6, 2018, 0, 1, '2018-04-21', '19:00:00', 4, 3, 'Yankee Stadium', 28000, 'Mark Geiger', 'cloudy');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named stadium_capacity_update_trigger that fires AFTER INSERT on the games table, and for each new game record, updates the teams table by increasing the stadium_capacity by 1000 for the team corresponding to the team_id from the new game.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called stadium_capacity_update_trigger that fires after each new row is inserted into the games table, and for each insertion, it increases the stadium_capacity by 1000 in the teams table for the team whose team_id matches the newly inserted team_id, then returns the new row.",
    "id": 52,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_team_stadium_capacity that updates the teams table by setting the stadium_capacity column to its current value plus 1000 for the row where team_id matches the NEW.team_id from the games table, and then returns NEW.\nSecond, define the trigger stadium_capacity_update_trigger on table games that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that, upon the insertion of a new row into the games table, automatically updates the teams table by increasing the stadium_capacity column by 1000 for the row where the team_id matches the team_id of the newly inserted row in the games table. The trigger, named stadium_capacity_update_trigger, is set to execute this function after each row is inserted into the games table, ensuring that the stadium capacity is incremented accordingly for the relevant team. The function returns the newly inserted row, maintaining the integrity of the trigger operation.",
    "original_summary": "Create an AFTER INSERT trigger function on games named stadium_capacity_update_trigger. For each new row, update teams set stadium_capacity = stadium_capacity + 1000 where team_id = NEW.team_id. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER INSERT trigger function designated as 'stadium_capacity_update_trigger' on the 'games' table. The function's logic must be as follows: for each newly inserted row, increment the 'stadium_capacity' field by 1000 within the 'teams' table, specifically for the record where the 'team_id' matches the NEW.team_id value. The function should conclude by returning the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `normalize_employee_email` that modifies the `NEW.email` column by removing any trailing period characters using the `rtrim(NEW.email, '.')` function and then returns the `NEW` record. Second, define the trigger `trg_normalize_employee_email` on table `employees` that fires `BEFORE` `UPDATE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION normalize_employee_email() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.email := rtrim(NEW.email, '.');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_normalize_employee_email\nBEFORE UPDATE ON employees\nFOR EACH ROW EXECUTE FUNCTION normalize_employee_email();",
    "database_name": "human_resource_management_and_employee_tracking",
    "tables": [
      "departments",
      "employees",
      "job_titles"
    ],
    "call_sqls": [
      "UPDATE employees SET email = 'new.email.address.' WHERE employee_id = 0;",
      "UPDATE employees SET email = 'another.email.address...' WHERE employee_id = 1;",
      "UPDATE employees SET email = 'test.email.com.' WHERE employee_id = 0;",
      "UPDATE employees SET email = 'email.with.many.dots....' WHERE employee_id = 1;",
      "UPDATE employees SET email = 'no.trailing.dot' WHERE employee_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_normalize_employee_email that fires BEFORE UPDATE on the employees table for each row, which removes any trailing periods from the NEW.email value before the update is applied.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_normalize_employee_email that runs before an update on the employees table, and it should clean up the email in the new record by trimming any trailing periods from the email.",
    "id": 53,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `normalize_employee_email` that modifies the `NEW.email` column by removing any trailing period characters using the `rtrim(NEW.email, '.')` function and then returns the `NEW` record. Second, define the trigger `trg_normalize_employee_email` on table `employees` that fires `BEFORE` `UPDATE` and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `normalize_employee_email` that is designed to be executed before an `UPDATE` operation on the `employees` table, for each row being updated. This function does not accept any explicit input parameters beyond the standard trigger context variables. Its primary purpose is to modify the `email` column of the `NEW` record (representing the row's state after the update but before it's committed to the table). Specifically, it performs a string manipulation operation on the `email` column: it removes any trailing period characters (`.`) from the `NEW.email` value using the `rtrim()` function. The modified `NEW.email` value then replaces the original `NEW.email` value. After this modification, the function returns the `NEW` record, allowing the `UPDATE` operation to proceed with the normalized email address. This trigger function is then associated with a trigger named `trg_normalize_employee_email`. This trigger is configured to activate `BEFORE UPDATE` operations on the `employees` table. It is set to execute `FOR EACH ROW`, meaning the `normalize_employee_email` function will be invoked once for every row that is part of an `UPDATE` statement on the `employees` table. The trigger's action is to `EXECUTE FUNCTION normalize_employee_email()`, thereby ensuring that the email address in the `email` column of each updated row in the `employees` table is automatically normalized by removing any trailing periods before the update is finalized.",
    "original_summary": "Create a PostgreSQL trigger function named normalize_employee_email that fires BEFORE UPDATE on the employees table for each row. It removes any trailing periods from the NEW.email value using rtrim. The function returns the modified NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a trigger function for the employees table that runs before an update. It should kind of clean up the email in the new record, maybe by trimming off any periods that are at the end. Name it something like normalize_employee_email."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_health_expectancy` that declares two REAL variables `avg_life_exp` and `new_value`. It calculates the average of the `life_expectancy` column from the `health_data` table for rows where `country_id` equals `NEW.country_id`, `year` equals `NEW.year`, and `health_id` does not equal `NEW.health_id`, storing the result into `avg_life_exp`. It uses `COALESCE` to replace a NULL average with 0. It then calculates `new_value` as the sum of `NEW.life_expectancy` and `avg_life_exp`. If `new_value` is between 0 and 10 inclusive, it updates the `health_data` table, setting `life_expectancy` to `new_value` where `health_id` matches `NEW.health_id`. The function must return `NEW`.\nSecond, define the trigger `trg_update_health_expectancy` on table `health_data` that fires AFTER UPDATE and executes the function `update_health_expectancy` FOR EACH ROW.",
    "plsql": "CREATE OR REPLACE FUNCTION update_health_expectancy() RETURNS TRIGGER AS $$\nDECLARE\n  avg_life_exp REAL;\n  new_value REAL;\nBEGIN\n  -- Calculate average excluding the current row to avoid self-reference\n  SELECT AVG(life_expectancy) INTO avg_life_exp\n  FROM health_data \n  WHERE country_id = NEW.country_id \n    AND year = NEW.year \n    AND health_id != NEW.health_id;\n  \n  -- Handle case where no other rows exist or avg is NULL\n  avg_life_exp := COALESCE(avg_life_exp, 0);\n  \n  -- Calculate new value and check for reasonable bounds\n  new_value := NEW.life_expectancy + avg_life_exp;\n  \n  -- Only update if the new value is within reasonable bounds (0 to 10 for life expectancy scores)\n  IF new_value >= 0 AND new_value <= 10 THEN\n    UPDATE health_data\n    SET life_expectancy = new_value\n    WHERE health_id = NEW.health_id;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_health_expectancy\nAFTER UPDATE ON health_data\nFOR EACH ROW EXECUTE FUNCTION update_health_expectancy();",
    "database_name": "global_happiness_and_economic_data_analysis",
    "tables": [
      "countries",
      "economic_data",
      "freedom_data",
      "generosity_data",
      "happiness_data",
      "health_data",
      "social_data",
      "data_sources",
      "data_versions"
    ],
    "call_sqls": [
      "UPDATE health_data SET life_expectancy = 0.9 WHERE health_id = 1;",
      "UPDATE health_data SET healthcare_spending = 5500.0 WHERE health_id = 2;",
      "UPDATE health_data SET year = 2023 WHERE health_id = 3;",
      "UPDATE health_data SET life_expectancy = 0.85, year = 2022 WHERE health_id = 4;",
      "UPDATE health_data SET country_id = 5 WHERE health_id = 6;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `update_health_expectancy` that fires AFTER UPDATE on the `health_data` table for each row. For the updated row, calculate the average `life_expectancy` from other rows in the same `country_id` and `year`, excluding the current row, treating a NULL average as 0. Add this average to the NEW `life_expectancy`, and if the resulting sum is between 0 and 10 inclusive, update the current row's `life_expectancy` to this new value. Return the NEW record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called `update_health_expectancy` that runs AFTER UPDATE on the `health_data` table for each row. For the updated row, calculate the average `life_expectancy` from other rows in `health_data` with the same `country_id` and `year`, excluding the current row, treating any NULL average as 0. Add this average to the NEW `life_expectancy`. If the resulting total is between 0 and 10 inclusive, update the current row's `life_expectancy` to this new total, and return the NEW record.",
    "id": 54,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_health_expectancy` that is designed to be executed as a trigger. This function does not accept any explicit input parameters but operates within the context of a trigger, meaning it has access to special variables like `NEW` (representing the new row for `INSERT`/`UPDATE` operations) and `OLD` (representing the old row for `UPDATE`/`DELETE` operations). The function is declared to return `TRIGGER`, indicating its purpose as a trigger function.\n\nInside the function's `BEGIN...END` block, a variable named `avg_expectancy` of type `REAL` is declared to store the calculated average. The function then executes a `SELECT` statement to compute the average `life_expectancy` from the `health_data` table. This `SELECT` statement uses the `AVG` aggregate function on the `life_expectancy` column. The `WHERE` clause filters the rows considered for the average: it includes only rows where the `country_id` column matches the `country_id` value from the `NEW` record (the row that triggered the update), and where the `year` column matches the `year` value from the `NEW` record. Crucially, it excludes the current row itself by specifying `health_id != NEW.health_id`. The result of this `SELECT` statement is assigned to the `avg_expectancy` variable using the `INTO` clause.\n\nFollowing this, the function uses a `COALESCE` function to handle potential `NULL` values. If `avg_expectancy` is `NULL` (which would occur if no other rows exist for the same `country_id` and `year`), the `COALESCE` function substitutes it with `0`. The function then performs an arithmetic addition: it adds this `avg_expectancy` value (or `0` if `NULL`) to the `life_expectancy` value from the `NEW` record. This sum is not stored in a separate variable but is used directly in a subsequent conditional check.\n\nThe function then evaluates a conditional statement: `IF (NEW.life_expectancy + COALESCE(avg_expectancy, 0)) BETWEEN 0 AND 10 THEN`. This condition checks if the calculated total (the sum of the new `life_expectancy` and the average from other rows) is greater than or equal to `0` and less than or equal to `10`.\n\nIf this condition evaluates to `TRUE`, the function proceeds to execute an `UPDATE` statement. This `UPDATE` statement targets the `health_data` table itself. It sets the `life_expectancy` column for a specific row. The row to be updated is identified by a `WHERE` clause: `WHERE health_id = NEW.health_id`. This ensures that only the row that originally triggered the update (the current row) is modified. The new value for `life_expectancy` is set to the calculated total: `NEW.life_expectancy + COALESCE(avg_expectancy, 0)`. After this `UPDATE` statement executes, the `NEW` record's `life_expectancy` field is implicitly updated to reflect this new value for the remainder of the trigger's execution context.\n\nAfter the conditional block (whether the `UPDATE` statement was executed or not), the function concludes by returning the `NEW` record: `RETURN NEW;`. This is a standard requirement for `AFTER` row-level triggers in PostgreSQL.\n\nFollowing the function definition, a trigger named `trigger_update_health_expectancy` is created. This trigger is configured to activate `AFTER UPDATE` operations on the `health_data` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is updated in the `health_data` table. When activated, this trigger will `EXECUTE FUNCTION update_health_expectancy()`, thereby invoking the previously defined PL/pgSQL function. The overall effect is that whenever a row in the `health_data` table is updated, the `update_health_expectancy` function will be called. It calculates the average `life_expectancy` from other rows for the same country and year, adds this average to the new `life_expectancy` value, and if the result is between 0 and 10 inclusive, it updates the current row's `life_expectancy` to this new total.",
    "original_ir": "Write a PostgreSQL trigger function named update_health_expectancy that is executed automatically after each row update operation on the health_data table. The function declares two local REAL variables: avg_life_exp to store an average calculation and new_value to store a computed result. For each updated row, identified by the NEW implicit record containing the new column values, the function performs a SELECT query on the health_data table to calculate the average value of the life_expectancy column, but only for rows where the country_id equals NEW.country_id, the year equals NEW.year, and the health_id does not equal NEW.health_id, thereby excluding the current row from the average. The result of this AVG aggregation is stored into the avg_life_exp variable. The function then uses the COALESCE function to handle cases where the average calculation returns NULL, replacing any NULL value with 0 and assigning the result back to avg_life_exp. Subsequently, the function calculates a new_value by adding the NEW.life_expectancy from the triggering update to the calculated avg_life_exp. A conditional IF statement then checks if this new_value is within the inclusive numeric range of 0 to 10. If this condition is true, the function executes an UPDATE statement on the health_data table, setting the life_expectancy column to the calculated new_value specifically for the row where the health_id column matches NEW.health_id. Finally, the function returns the NEW record to the trigger mechanism. A trigger named trg_update_health_expectancy is defined to fire AFTER UPDATE on the health_data table, configured to execute the update_health_expectancy function once FOR EACH ROW that is updated.",
    "original_summary": "Create a PostgreSQL trigger function named `update_health_expectancy` that fires AFTER UPDATE on the `health_data` table FOR EACH ROW. For the updated row, calculate the average `life_expectancy` from other rows in the same `country_id` and `year`, excluding the current row. If the average is NULL, treat it as 0. Add this average to the NEW `life_expectancy`. If the resulting sum is between 0 and 10 (inclusive), update the current row's `life_expectancy` to this new value. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Write a PostgreSQL trigger function called `update_health_expectancy` that executes AFTER UPDATE on the `health_data` table FOR EACH ROW. For the updated row, compute the average `life_expectancy` from other rows sharing the same `country_id` and `year`, but exclude the current row. Treat any NULL average as 0. Add this average to the NEW `life_expectancy`. If the total falls between 0 and 10 inclusive, then set the current row's `life_expectancy` to this new total. Finally, return the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `maintain_climate_model_consistency` that deletes rows from the `climate_models` table where the `year` column matches the `year` value from the `OLD` record of the deleted row and then returns the `OLD` record.\nSecond, define the trigger `trg_maintain_climate_model_consistency` on table `emissions_data` that fires `AFTER` `DELETE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION maintain_climate_model_consistency() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM climate_models WHERE year = OLD.year;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_maintain_climate_model_consistency\n    AFTER DELETE ON emissions_data\n    FOR EACH ROW\n    EXECUTE FUNCTION maintain_climate_model_consistency();",
    "database_name": "climate_change_impact_analysis_and_emissions_tracking",
    "tables": [
      "emissions_data",
      "emissions_metrics",
      "climate_models"
    ],
    "call_sqls": [
      "DELETE FROM emissions_data WHERE year = 0;",
      "DELETE FROM emissions_data WHERE year = 1;",
      "DELETE FROM emissions_data WHERE year = 2;",
      "DELETE FROM emissions_data WHERE year = 3;",
      "DELETE FROM emissions_data WHERE year = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_maintain_climate_model_consistency that runs after each row is deleted from the emissions_data table, and for each deleted row, it deletes all rows from the climate_models table where the year matches the year of the deleted row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_maintain_climate_model_consistency that, after each row is deleted from the emissions_data table, deletes all matching rows from the climate_models table where the year equals the deleted row's year, and then returns the deleted row.",
    "id": 55,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `maintain_climate_model_consistency` that deletes rows from the `climate_models` table where the `year` column matches the `year` value from the `OLD` record of the deleted row and then returns the `OLD` record.\nSecond, define the trigger `trg_maintain_climate_model_consistency` on table `emissions_data` that fires `AFTER` `DELETE` and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that is invoked after a row is deleted from the emissions_data table. This function, named maintain_climate_model_consistency, is designed to ensure data consistency between the emissions_data and climate_models tables. The function does not take any parameters directly, but operates on the OLD record, which represents the row that was just deleted from emissions_data. Within the function, a DELETE operation is performed on the climate_models table, specifically targeting rows where the year column matches the year value from the OLD record of the emissions_data table. This operation effectively removes any climate model data associated with the year of the deleted emissions data, maintaining consistency between the two tables. The function then returns the OLD record, which is standard practice for trigger functions that do not modify the data being passed through them. The trigger, named trg_maintain_climate_model_consistency, is defined to execute this function after a DELETE operation on the emissions_data table, ensuring that the consistency maintenance logic is applied automatically whenever a row is removed from emissions_data.",
    "original_summary": "Create an AFTER DELETE trigger function on the emissions_data table. For each deleted row, delete all rows from the climate_models table where the year matches the OLD.year value. Return OLD.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "For each row deleted from the emissions_data table, delete all matching rows from the climate_models table where the year equals the deleted row's year, and then return the deleted row. Implement this as an AFTER DELETE trigger function."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_notes_based_on_gapfilled that checks the NEW.gapfilled value and, if it equals 1, sets NEW.notes to 'Data gap filled using interpolation'; otherwise, sets NEW.notes to 'Original data without gap filling'.\nSecond, define the trigger trg_update_notes_based_on_gapfilled on table data_points that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_notes_based_on_gapfilled() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.gapfilled = 1 THEN\n    NEW.notes := 'Data gap filled using interpolation';\n  ELSE\n    NEW.notes := 'Original data without gap filling';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_notes_based_on_gapfilled\nBEFORE INSERT OR UPDATE ON data_points\nFOR EACH ROW EXECUTE FUNCTION update_notes_based_on_gapfilled();",
    "database_name": "marine_ecosystem_monitoring_and_analysis",
    "tables": [
      "data_points"
    ],
    "call_sqls": [
      "INSERT INTO data_points (data_id, region_id, product_id, year, value, gapfilled, method_id, created_at, updated_at, season, sampling_method, sampling_frequency, data_quality, confidence_level, notes) VALUES (1001, 5, 10, 2023, 12.5, 1, 3, '2024-01-01 00:00:00', '2024-01-01 00:00:00', 'winter', 'remote sensing', 'weekly', 'high', 0.99, NULL);",
      "INSERT INTO data_points (data_id, region_id, product_id, year, value, gapfilled, method_id, created_at, updated_at, season, sampling_method, sampling_frequency, data_quality, confidence_level, notes) VALUES (1002, 5, 10, 2023, 15.2, 0, 1, '2024-01-02 00:00:00', '2024-01-02 00:00:00', 'spring', 'visual survey', 'monthly', 'medium', 0.85, NULL);",
      "UPDATE data_points SET gapfilled = 1, value = 18.7 WHERE data_id = 1002;",
      "INSERT INTO data_points (data_id, region_id, product_id, year, value, gapfilled, method_id, created_at, updated_at, season, sampling_method, sampling_frequency, data_quality, confidence_level, notes) VALUES (1003, 7, 12, 2024, 22.1, 1, 2, '2024-02-01 00:00:00', '2024-02-01 00:00:00', 'summer', 'automated sensor', 'daily', 'high', 0.98, 'Pre-existing note');",
      "UPDATE data_points SET gapfilled = 0 WHERE data_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_notes_based_on_gapfilled that fires BEFORE INSERT OR UPDATE on the data_points table, setting the notes column to 'Data gap filled using interpolation' when the gapfilled column equals 1, and to 'Original data without gap filling' otherwise, for each row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_update_notes_based_on_gapfilled that runs BEFORE INSERT OR UPDATE on the data_points table, setting the notes column to 'Data gap filled using interpolation' if the gapfilled column equals 1, or to 'Original data without gap filling' otherwise, and then returns the updated NEW row.",
    "id": 56,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_notes_based_on_gapfilled that checks the NEW.gapfilled value and, if it equals 1, sets NEW.notes to 'Data gap filled using interpolation'; otherwise, sets NEW.notes to 'Original data without gap filling'.\nSecond, define the trigger trg_update_notes_based_on_gapfilled on table data_points that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "original_ir": "Write a PLpgSQL function that is triggered before any insert or update operation on the data_points table, which checks the value of the gapfilled column in the row being inserted or updated. If the gapfilled column is set to 1, indicating that the data has been gap-filled using interpolation, the function updates the notes column of the same row to the string 'Data gap filled using interpolation'. If the gapfilled column is not set to 1, meaning the data is original and has not undergone gap filling, the function updates the notes column to the string 'Original data without gap filling'. The function returns the modified row, ensuring that the notes column reflects the status of the gapfilled column. The trigger named trg_update_notes_based_on_gapfilled is associated with this function and is set to execute for each row before any insert or update operation on the data_points table, thereby ensuring that the notes column is appropriately updated based on the gapfilled status for every row that is inserted or updated in the table.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE trigger function for the data_points table. For each row, if gapfilled = 1, set notes to 'Data gap filled using interpolation'. Otherwise, set notes to 'Original data without gap filling'. Return the modified NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How do you create a BEFORE INSERT OR UPDATE trigger function for the data_points table that, for each row, sets notes to 'Data gap filled using interpolation' if gapfilled = 1, and to 'Original data without gap filling' otherwise, and then returns the modified NEW row?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_inventory_timestamp` that uses the `NEW` record to set the `updated_at` column to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' using the `TO_CHAR` and `CURRENT_TIMESTAMP` functions.\nSecond, define the trigger `inventory_timestamp_trigger` on table `inventory` that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_inventory_timestamp() RETURNS TRIGGER AS $$\nBEGIN\nNEW.updated_at := TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER inventory_timestamp_trigger\nBEFORE UPDATE ON inventory\nFOR EACH ROW EXECUTE FUNCTION update_inventory_timestamp();",
    "database_name": "e_commerce_sales_and_inventory_management_292568",
    "tables": [
      "products",
      "product_types",
      "suppliers",
      "inventory",
      "low_stock_alerts",
      "reorders",
      "sales",
      "regions"
    ],
    "call_sqls": [
      "UPDATE inventory SET quantity_on_hand = 900 WHERE inventory_id = 0;",
      "UPDATE inventory SET quantity_on_hand = 450 WHERE inventory_id = 1;",
      "UPDATE inventory SET reorder_point = 600 WHERE inventory_id = 0;",
      "UPDATE inventory SET reorder_quantity = 75 WHERE inventory_id = 1;",
      "UPDATE inventory SET quantity_on_hand = 950 WHERE inventory_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named inventory_timestamp_trigger that, before updating each row in the inventory table, sets the NEW.updated_at column to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called inventory_timestamp_trigger that, before each update on the inventory table, automatically sets the updated_at column to the current timestamp in 'YYYY-MM-DD HH24:MI:SS' format.",
    "id": 57,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_inventory_timestamp` that uses the `NEW` record to set the `updated_at` column to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' using the `TO_CHAR` and `CURRENT_TIMESTAMP` functions.\nSecond, define the trigger `inventory_timestamp_trigger` on table `inventory` that fires BEFORE UPDATE and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that automatically updates the updated_at column in the inventory table to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' whenever a row in the inventory table is updated. This function, named update_inventory_timestamp, does not take any parameters and returns a trigger type. It uses the NEW record, which represents the row being modified, to set the updated_at column to the current timestamp. The function is associated with a trigger named inventory_timestamp_trigger, which is defined to execute before any update operation on each row of the inventory table. The trigger ensures that every time a row in the inventory table is updated, the updated_at column is automatically refreshed to reflect the exact time of the update, formatted as a string.",
    "original_summary": "Create a trigger function named update_inventory_timestamp that returns a trigger. Before updating each row in the inventory table, set the NEW.updated_at column to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'. Create a trigger named inventory_timestamp_trigger to execute this function.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a trigger function update_inventory_timestamp that returns a trigger. Before each inventory update, set NEW.updated_at to the current timestamp in 'YYYY-MM-DD HH24:MI:SS' format. Then create the trigger inventory_timestamp_trigger to run it."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `remove_venue_reference` that returns the OLD record and uses conditional logic with two NOT EXISTS subqueries: one to check the `games` table for any other row where `venue_id` matches OLD.venue_id and `game_id` is different from OLD.game_id, and another to check the `teams` table for any row where `home_venue_id` matches OLD.venue_id. If both conditions are true, it performs a DELETE on the `venues` table where `venue_id` equals OLD.venue_id.\nSecond, define the trigger `trg_remove_venue_reference` on table `games` that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_venue_reference() RETURNS TRIGGER AS $$\nBEGIN\n  -- Only delete the venue if no other games reference it and no team has it as home_venue_id\n  IF NOT EXISTS (\n    SELECT 1 FROM games \n    WHERE venue_id = OLD.venue_id \n    AND game_id != OLD.game_id\n  ) AND NOT EXISTS (\n    SELECT 1 FROM teams \n    WHERE home_venue_id = OLD.venue_id\n  ) THEN\n    DELETE FROM venues WHERE venue_id = OLD.venue_id;\n  END IF;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_remove_venue_reference\nAFTER DELETE ON games\nFOR EACH ROW EXECUTE FUNCTION remove_venue_reference();",
    "database_name": "sports_team_performance_and_statistics_506836",
    "tables": [
      "games",
      "teams",
      "venues",
      "player_stats",
      "team_standings",
      "sports"
    ],
    "call_sqls": [
      "DELETE FROM games WHERE game_id = 1;",
      "DELETE FROM games WHERE venue_id = 5;",
      "DELETE FROM games WHERE game_date = '2023-08-01';",
      "DELETE FROM games WHERE home_team_id = 10 AND away_team_id = 15;",
      "DELETE FROM games WHERE game_status = 'completed' AND attendance < 10000;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `trg_remove_venue_reference` that runs after a delete on the `games` table for each row, using the function `remove_venue_reference`. After a game is deleted, check if the associated `venue_id` from the deleted row is no longer referenced by any other row in the `games` table (excluding the deleted game) and is not used as the `home_venue_id` in any row of the `teams` table. If both conditions are true, delete the corresponding venue from the `venues` table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named `remove_venue_reference` that, after a row is deleted from the `games` table, checks if the deleted game's `venue_id` is still referenced by any other row in the `games` table (excluding the deleted one) or by any row in the `teams` table as `home_venue_id`; if not, it deletes the corresponding row from the `venues` table, and returns the OLD record. Set up an AFTER DELETE trigger called `trg_remove_venue_reference` on the `games` table to execute this function for each row.",
    "id": 58,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `remove_venue_reference` that returns the OLD record and uses conditional logic with two NOT EXISTS subqueries: one to check the `games` table for any other row where `venue_id` matches OLD.venue_id and `game_id` is different from OLD.game_id, and another to check the `teams` table for any row where `home_venue_id` matches OLD.venue_id. If both conditions are true, it performs a DELETE on the `venues` table where `venue_id` equals OLD.venue_id.\nSecond, define the trigger `trg_remove_venue_reference` on table `games` that fires AFTER DELETE and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named remove_venue_reference that is executed automatically by a trigger named trg_remove_venue_reference after each row is deleted from the games table, with the function returning the OLD record; the function's logic is to conditionally delete a venue record from the venues table only if that specific venue, identified by the OLD.venue_id value from the recently deleted games row, is no longer referenced by any other records in the database, specifically checking two conditions: first, by using a SELECT statement to verify that no other row exists in the games table where the venue_id column matches OLD.venue_id and the game_id column is different from the OLD.game_id of the deleted row, and second, by using another SELECT statement to verify that no row exists in the teams table where the home_venue_id column matches OLD.venue_id; if both these NOT EXISTS subqueries return true, meaning no other game references the venue and no team has it as a home venue, then a DELETE operation is performed on the venues table where the venue_id column equals OLD.venue_id.",
    "original_summary": "Create a PostgreSQL trigger function named `remove_venue_reference` that runs after a delete on the `games` table. For each deleted row, check if the `venue_id` (from OLD) is no longer referenced: ensure no other row in the `games` table has the same `venue_id` (excluding the deleted game), and ensure no row in the `teams` table has that `venue_id` as its `home_venue_id`. If both conditions are true, delete the corresponding row from the `venues` table. Return the OLD record. Create an AFTER DELETE trigger named `trg_remove_venue_reference` on the `games` table to execute this function for each row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger function for PostgreSQL, call it `remove_venue_reference`. It should kick in right after we delete something from the `games` table. For each game that gets axed, we gotta check its old `venue_id`. We need to make sure no other game is still using that same venue ID (obviously, besides the one we just deleted). Also, we need to peek at the `teams` table and see if any team has that ID listed as their `home_venue_id`. If both checks come back clearâ€”meaning the venue isn't being used anywhere elseâ€”then we should go ahead and delete that venue's record from the `venues` table. The function should hand back the OLD record. Finally, set up an AFTER DELETE trigger on the `games` table, name it `trg_remove_venue_reference`, to run this function for each row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `archive_old_sample_data` that deletes rows from the `alerts` table where `sample_id` equals `OLD.sample_id` and then deletes rows from the `sample_details` table where `sample_id` equals `OLD.sample_id`, before returning `OLD`.\nSecond, define the trigger `trg_archive_old_sample_data` on table `samples` that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_old_sample_data() RETURNS TRIGGER AS $$\nDECLARE\n    sample_count INTEGER; -- This variable is no longer used after simplifying the logic.\nBEGIN\n    -- Delete referencing records from 'alerts' table first to satisfy foreign key constraint.\n    -- Assuming 'alerts' table has a 'sample_id' column referencing 'samples.sample_id'.\n    -- This line is crucial for resolving the foreign key violation reported in the feedback.\n    DELETE FROM alerts WHERE sample_id = OLD.sample_id;\n\n    -- Delete referencing records from 'sample_details' table.\n    -- This ensures that child records in 'sample_details' are removed before the parent 'samples' record.\n    DELETE FROM sample_details WHERE sample_id = OLD.sample_id;\n\n    -- The original CASE statement's logic for conditional deletion of sample_details\n    -- or just assigning to sample_count is removed. If the intent was to conditionally\n    -- prevent the deletion of the 'samples' row, the trigger should RETURN NULL.\n    -- Since it RETURNS OLD, the 'samples' row deletion proceeds, and thus all\n    -- dependent child records must be handled.\n    -- The original CASE logic was:\n    -- CASE\n    --     WHEN EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM OLD.sampling_date::date) > 5 THEN\n    --         DELETE FROM sample_details WHERE sample_id = OLD.sample_id;\n    --     WHEN LENGTH(OLD.sampling_method) > 10 THEN\n    --         sample_count := (SELECT COUNT(*) FROM samples WHERE station_id = OLD.station_id);\n    --     WHEN OLD.quality_flag = 'invalid' THEN\n    --         DELETE FROM sample_details WHERE sample_id = OLD.sample_id AND notes LIKE '%invalid%';\n    --     ELSE\n    --         sample_count := 1;\n    -- END CASE;\n\n    RETURN OLD; -- Allow the DELETE operation on the 'samples' table to proceed.\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_archive_old_sample_data\n    BEFORE DELETE ON samples\n    FOR EACH ROW\n    EXECUTE FUNCTION archive_old_sample_data();",
    "database_name": "air_quality_monitoring_and_analysis_918261",
    "tables": [
      "samples",
      "sample_details"
    ],
    "call_sqls": [
      "DELETE FROM samples WHERE sample_id = 0;",
      "DELETE FROM samples WHERE sample_id = 1;",
      "DELETE FROM samples WHERE sample_id = 2;",
      "DELETE FROM samples WHERE sample_id = 3;",
      "DELETE FROM samples WHERE sample_id = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `archive_old_sample_data` that fires BEFORE DELETE on the `samples` table for each row to delete all related records from the `alerts` table and the `sample_details` table where the `sample_id` matches the deleted sample's `sample_id`, ensuring referential integrity before allowing the deletion to proceed.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called `archive_old_sample_data` that runs BEFORE DELETE on each row of the `samples` table to remove any associated records from the `alerts` table and the `sample_details` table where the `sample_id` matches the deleted row's `sample_id`, then returns the OLD row to allow the deletion to proceed.",
    "id": 59,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `archive_old_sample_data` with a return type of `TRIGGER`. This function is executed `BEFORE DELETE` on the `samples` table for `EACH ROW`. The function performs two deletion operations to remove associated records from related tables before the main deletion from `samples` occurs. It first deletes rows from the `alerts` table where the `sample_id` column matches the `sample_id` of the row being deleted from `samples`, accessed via `OLD.sample_id`. It then deletes rows from the `sample_details` table where the `sample_id` column also matches `OLD.sample_id`. After these deletions, the function returns `OLD`, which is the row from `samples` that is about to be deleted, allowing the deletion to proceed. The function does not declare any variables, as it directly uses the `OLD` record. Second, define the trigger `archive_old_sample_data` on the `samples` table, specifying that it fires `BEFORE DELETE` for `EACH ROW` and executes the function `archive_old_sample_data()`. This ensures that whenever a row is deleted from `samples`, all related records in `alerts` and `sample_details` are automatically removed first, maintaining referential integrity.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `archive_old_sample_data` that is designed to be executed `BEFORE DELETE` operations on the `samples` table, `FOR EACH ROW` being deleted. This function does not accept any explicit input parameters beyond the standard trigger context variables (`OLD`, `NEW`). It declares a local variable `sample_count` of type `INTEGER`, though this variable is explicitly noted as no longer being used in the current simplified logic. Upon execution, the function first performs a `DELETE` operation on the `alerts` table. This deletion targets rows in the `alerts` table where the `sample_id` column matches the `sample_id` value of the row currently being deleted from the `samples` table (referenced as `OLD.sample_id`). This step is crucial for maintaining referential integrity and preventing foreign key constraint violations, assuming a foreign key relationship exists where `alerts.sample_id` references `samples.sample_id`. Following this, the function executes another `DELETE` operation, this time on the `sample_details` table. This deletion targets rows in the `sample_details` table where the `sample_id` column matches the `sample_id` value of the `samples` row being deleted (`OLD.sample_id`). This action ensures that all child records in `sample_details` associated with the parent `samples` record are removed before the parent record itself is deleted. The function explicitly notes that previous conditional logic involving a `CASE` statement, which might have conditionally deleted `sample_details` records or assigned values to `sample_count` based on conditions like the age of `sampling_date`, the length of `sampling_method`, or the `quality_flag` of the `samples` row, has been removed. The current design ensures that all dependent child records are handled unconditionally. Finally, the function concludes by returning `OLD`, which signifies to the PostgreSQL database system that the original `DELETE` operation on the `samples` table should proceed as intended, allowing the `samples` row that initiated the trigger to be successfully deleted after its dependent records in `alerts` and `sample_details` have been removed.",
    "original_summary": "Create a PostgreSQL trigger function named `archive_old_sample_data` that fires BEFORE DELETE on the `samples` table for each row. The function must delete related records from the `alerts` table where `sample_id` equals `OLD.sample_id`, then delete related records from the `sample_details` table where `sample_id` equals `OLD.sample_id`. Finally, return the OLD row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Write a PostgreSQL trigger function called `archive_old_sample_data` that executes BEFORE DELETE on each row of the `samples` table. First, remove any associated records from the `alerts` table where the `sample_id` matches `OLD.sample_id`. Next, remove any associated records from the `sample_details` table where the `sample_id` matches `OLD.sample_id`. Finally, return the OLD row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function insert_server_sync that inserts a row into the user_server_sync table, setting the sync_id to one more than the current maximum sync_id from that table (using COALESCE to default to 0 if the table is empty), the user_id to 'system_server_sync_user', the server_id to the NEW.server_id from the server_info table, and the sync_ts to the current timestamp cast to text.\nSecond, define the trigger insert_sync_trigger on table server_info that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_server_sync() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO user_server_sync (sync_id, user_id, server_id, sync_ts)\n  VALUES (\n    COALESCE((SELECT MAX(sync_id) FROM user_server_sync), 0) + 1,\n    'system_server_sync_user', \n    NEW.server_id, \n    CURRENT_TIMESTAMP::text\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER insert_sync_trigger\nAFTER INSERT ON server_info\nFOR EACH ROW EXECUTE FUNCTION insert_server_sync();",
    "database_name": "user_activity_and_status_tracking",
    "tables": [
      "server_info",
      "user_activity",
      "user_server_sync",
      "user_status"
    ],
    "call_sqls": [
      "INSERT INTO server_info (server_id, server_name, server_type, last_sync_ts) VALUES (0, 'Server 1', 'messaging', '1570040279284');",
      "INSERT INTO server_info (server_id, server_name, server_type, last_sync_ts) VALUES (1, 'Server 2', 'file sharing', '1570040284126');",
      "INSERT INTO server_info (server_id, server_name, server_type, last_sync_ts) VALUES (2, 'Server 3', 'messaging', '1570040290000');",
      "INSERT INTO server_info (server_id, server_name, server_type, last_sync_ts) VALUES (3, 'Server 4', 'file sharing', '1570040300000');",
      "INSERT INTO server_info (server_id, server_name, server_type, last_sync_ts) VALUES (4, 'Server 5', 'messaging', '1570040310000');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named insert_sync_trigger that fires AFTER INSERT on the server_info table for each new row, which inserts a record into the user_server_sync table by setting sync_id to the next available maximum value from user_server_sync (or starting at 1 if the table is empty), user_id to 'system_server_sync_user', server_id to the newly inserted server_id from server_info, and sync_ts to the current timestamp as text.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called insert_sync_trigger that fires after each new row is inserted into the server_info table, and for every such insertion, it automatically adds a matching record to the user_server_sync table, setting the sync_id to the next highest existing sync_id plus one (or to 1 if there are no records yet), the user_id to 'system_server_sync_user', the server_id to the server_id from the newly inserted server_info row, and the sync_ts to the current timestamp as text.",
    "id": 60,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function insert_server_sync that inserts a row into the user_server_sync table, setting the sync_id to one more than the current maximum sync_id from that table (using COALESCE to default to 0 if the table is empty), the user_id to 'system_server_sync_user', the server_id to the NEW.server_id from the server_info table, and the sync_ts to the current timestamp cast to text.\nSecond, define the trigger insert_sync_trigger on table server_info that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that, upon the insertion of a new row into the server_info table, automatically inserts a new row into the user_server_sync table. This new row will have the sync_id column set to one more than the current maximum sync_id in the user_server_sync table, defaulting to 1 if the table is empty. The user_id column is set to the string 'system_server_sync_user', the server_id column is set to the server_id value from the newly inserted row in the server_info table, and the sync_ts column is set to the current timestamp converted to text. The trigger, named insert_sync_trigger, is defined to execute this function after each row is inserted into the server_info table.",
    "original_summary": "Create an AFTER INSERT trigger function on server_info table. For each new row, insert into user_server_sync table: set sync_id to the next maximum value (or 1 if empty), user_id to 'system_server_sync_user', server_id to the new server_id, and sync_ts to current timestamp as text.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please implement an AFTER INSERT trigger function for the server_info table. For every newly inserted row, it is required to insert a corresponding record into the user_server_sync table. The values should be assigned as follows: the sync_id must be set to the next maximum value from the existing sequence, or to 1 if the sequence is presently empty; the user_id must be set to 'system_server_sync_user'; the server_id must be set to the server_id value from the new row; and the sync_ts must be set to the current timestamp, formatted as text."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_last_login that uses the NEW record to set the last_login_time column to the current timestamp formatted as a string using TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI:SS') and returns NEW.\nSecond, define the trigger trg_update_last_login on table employees that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_last_login() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.last_login_time := TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI:SS');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_last_login\nBEFORE UPDATE ON employees\nFOR EACH ROW EXECUTE FUNCTION update_last_login();",
    "database_name": "employee_management_and_compensation_tracking",
    "tables": [
      "employees"
    ],
    "call_sqls": [
      "UPDATE employees SET last_login_time = '00:00:00' WHERE employee_id = 1;",
      "UPDATE employees SET salary = 100000 WHERE employee_id = 2;",
      "UPDATE employees SET email = 'new.email@example.com' WHERE employee_id = 0;",
      "UPDATE employees SET team_id = 5 WHERE is_senior_management = 1;",
      "UPDATE employees SET employee_status = 'active' WHERE employee_status = 'inactive';"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_last_login that, before updating any row in the EMPLOYEES table, automatically sets the LAST_LOGIN_TIME column to the current time in 'HH24:MI:SS' format and then returns the updated record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_update_last_login that, before updating any row in the employees table, sets the last_login_time column to the current time in HH24:MI:SS format and returns the updated row.",
    "id": 61,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_last_login that uses the NEW record to set the last_login_time column to the current timestamp formatted as a string using TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI:SS') and returns NEW.\nSecond, define the trigger trg_update_last_login on table employees that fires BEFORE UPDATE and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that automatically updates the last_login_time column in the employees table to the current time in 'HH24:MI:SS' format whenever a row in the table is updated. The function, named update_last_login, does not take any parameters and returns a trigger type. It uses the NEW record, which represents the row being modified, to set the last_login_time column to the current timestamp converted to a string format of hours, minutes, and seconds using the TO_CHAR function. The trigger, named trg_update_last_login, is defined to execute this function before any update operation on each row of the employees table, ensuring that the last_login_time is refreshed to the current time whenever an update occurs on any row in the table.",
    "original_summary": "Create a BEFORE UPDATE trigger function on the employees table that sets last_login_time to the current time in 'HH24:MI:SS' format, then returns the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Before updating employees, set last_login_time to current time as HH24:MI:SS and return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_individual_on_demographics_update` that updates the `individuals` table by setting the columns `female`, `black`, `latin`, `white`, `age`, `parent_college`, `numkids`, `address`, `marital_status`, `date_of_birth`, `ethnicity`, `disability_status`, and `military_service` to the corresponding values from the `NEW` record where the `id` matches the `NEW`.`id`. Second, define the trigger `trg_update_individual_on_demographics_update` on table `demographics` that fires `AFTER UPDATE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_individual_on_demographics_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"individuals\" SET \"female\" = NEW.\"female\", \"black\" = NEW.\"black\", \"latin\" = NEW.\"latin\", \"white\" = NEW.\"white\", \"age\" = NEW.\"age\", \"parent_college\" = NEW.\"parent_college\", \"numkids\" = NEW.\"numkids\", \"address\" = NEW.\"address\", \"marital_status\" = NEW.\"marital_status\", \"date_of_birth\" = NEW.\"date_of_birth\", \"ethnicity\" = NEW.\"ethnicity\", \"disability_status\" = NEW.\"disability_status\", \"military_service\" = NEW.\"military_service\" WHERE \"id\" = NEW.\"id\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trg_update_individual_on_demographics_update\"\n    AFTER UPDATE ON \"demographics\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_individual_on_demographics_update();",
    "database_name": "demographic_and_employment_data_analysis_192071",
    "tables": [
      "individuals",
      "demographics",
      "employment"
    ],
    "call_sqls": [
      "UPDATE \"demographics\" SET \"female\" = 0, \"age\" = 37 WHERE \"id\" = 0;",
      "UPDATE \"demographics\" SET \"marital_status\" = 'Divorced', \"numkids\" = 3 WHERE \"id\" = 1;",
      "UPDATE \"demographics\" SET \"black\" = 1, \"white\" = 0, \"latin\" = 0 WHERE \"id\" = 0;",
      "UPDATE \"demographics\" SET \"address\" = '789 Oak Ave', \"date_of_birth\" = '1990-01-01' WHERE \"id\" = 1;",
      "UPDATE \"demographics\" SET \"disability_status\" = 1, \"military_service\" = 1 WHERE \"id\" = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_individual_on_demographics_update that, after a row is updated in the demographics table, updates the matching row in the individuals table where individuals.id equals the updated demographics row's id, setting the individuals columns female, black, latin, white, age, parent_college, numkids, address, marital_status, date_of_birth, ethnicity, disability_status, and military_service to the corresponding values from the updated demographics row, and returns the updated demographics row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_update_individual_on_demographics_update that runs AFTER UPDATE on the demographics table to sync matching data to the individuals table using NEW.id, updating the female, black, latin, white, age, parent_college, numkids, address, marital_status, date_of_birth, ethnicity, disability_status, and military_service columns from NEW, and then returns NEW.",
    "id": 62,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_individual_on_demographics_update`. This function is a PostgreSQL PL/pgSQL trigger function designed to be executed in response to an `UPDATE` operation on the `demographics` table. The function does not accept any explicit parameters but operates within the context of a trigger, receiving the special `NEW` and `OLD` records. The `NEW` record represents the updated row in the `demographics` table after the `UPDATE` operation, while the `OLD` record represents the row before the update. The function is declared to return a `TRIGGER` type, indicating its role as a trigger function.\n\nThe function performs a single `UPDATE` operation on the `individuals` table. The `UPDATE` statement modifies the `individuals` table by setting specific columns to the corresponding values from the `NEW` record of the `demographics` table. The columns updated in the `individuals` table are: `female`, `black`, `latin`, `white`, `age`, `parent_college`, `numkids`, `address`, `marital_status`, `date_of_birth`, `ethnicity`, `disability_status`, and `military_service`. Each of these columns is set to the value from the `NEW` record's column of the same name in the `demographics` table. For example, the `female` column in the `individuals` table is set to `NEW.female`, the `black` column is set to `NEW.black`, and so on for all specified columns.\n\nThe `UPDATE` operation is conditionally applied only to rows in the `individuals` table where the `id` column matches the value of the `id` column from the `NEW` record of the `demographics` table. This ensures that the synchronization occurs only for the individual whose demographic data has been updated. After performing this update, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL.\n\nSecond, define the trigger `trg_update_individual_on_demographics_update` on the `demographics` table. This trigger is configured to activate `AFTER UPDATE` operations on the `demographics` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is updated in the `demographics` table. When activated, this trigger `EXECUTE`s the `update_individual_on_demographics_update()` function. Therefore, whenever a row in the `demographics` table is updated, this trigger will fire, and the `update_individual_on_demographics_update` function will execute, updating the corresponding row in the `individuals` table by syncing the specified columns from the updated demographic data.",
    "original_ir": "Write a PLpgSQL trigger function that updates the individuals table by setting the columns female, black, latin, white, age, parent_college, numkids, address, marital_status, date_of_birth, ethnicity, disability_status, and military_service to the corresponding values from the NEW record whenever a row in the demographics table is updated, ensuring that the update is applied to the row in the individuals table where the id matches the id of the NEW record from the demographics table, and returns the NEW record.",
    "original_summary": "Create an AFTER UPDATE trigger function. After a row is updated in the demographics table, update the matching row in the individuals table where individuals.id equals NEW.id. Set the individuals columns female, black, latin, white, age, parent_college, numkids, address, marital_status, date_of_birth, ethnicity, disability_status, and military_service to the corresponding values from the NEW record. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create an AFTER UPDATE trigger on demographics. When a row updates, sync matching data to the individuals table using NEW.id. Update female, black, latin, white, age, parent_college, numkids, address, marital_status, date_of_birth, ethnicity, disability_status, and military_service from NEW. Return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `create_backup_agency` that checks if the `NEW.agency_id` is less than 1000 and, if true, inserts a backup row into the `police_agencies` table. The backup row should use `NEW.agency_id + 1000` for `agency_id`, concatenate `NEW.agency_name` with `'_BACKUP'` for `agency_name`, and copy the values from `NEW` for the columns `agency_type`, `contact_number`, `jurisdiction`, `number_of_officers`, `response_time`, and `equipment`. Wrap the `INSERT` in a block with an exception handler to catch any error using `WHEN OTHERS THEN` and log a notice with `RAISE NOTICE` and `SQLERRM` without affecting the original insert. The function must return `NEW`.\nSecond, define the trigger `trg_create_backup_agency` on table `police_agencies` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION create_backup_agency() RETURNS TRIGGER AS $$\nBEGIN\n    -- Only create backup if this is not already a backup record\n    IF NEW.agency_id < 1000 THEN\n        BEGIN\n            INSERT INTO police_agencies (agency_id, agency_name, agency_type, contact_number, jurisdiction, number_of_officers, response_time, equipment) \n            VALUES (NEW.agency_id + 1000, NEW.agency_name || '_BACKUP', NEW.agency_type, NEW.contact_number, NEW.jurisdiction, NEW.number_of_officers, NEW.response_time, NEW.equipment);\n        EXCEPTION\n            WHEN OTHERS THEN\n                -- Log error but don't fail the original insert\n                RAISE NOTICE 'Failed to create backup agency: %', SQLERRM;\n        END;\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_create_backup_agency\n    AFTER INSERT ON police_agencies\n    FOR EACH ROW\n    EXECUTE FUNCTION create_backup_agency();",
    "database_name": "traffic_incident_reporting_and_analysis_624460",
    "tables": [
      "cities",
      "police_agencies",
      "roadways",
      "severity_levels",
      "traffic_incidents"
    ],
    "call_sqls": [
      "INSERT INTO police_agencies (agency_id, agency_name, agency_type, contact_number, jurisdiction, number_of_officers, response_time, equipment) VALUES (10, 'Local police', 'Local', '555-1234', 'WORCESTER', 100, 15.2, 'Patrol cars, motorcycles');",
      "INSERT INTO police_agencies (agency_id, agency_name, agency_type, contact_number, jurisdiction, number_of_officers, response_time, equipment) VALUES (20, 'State police', 'State', '555-5678', 'Massachusetts', 500, 20.5, 'Patrol cars, helicopters');",
      "INSERT INTO police_agencies (agency_id, agency_name, agency_type, contact_number, jurisdiction, number_of_officers, response_time, equipment) VALUES (30, 'County police', 'County', '555-6789', 'BOSTON', 200, 18.0, 'Patrol cars, bikes');",
      "INSERT INTO police_agencies (agency_id, agency_name, agency_type, contact_number, jurisdiction, number_of_officers, response_time, equipment) VALUES (40, 'City police', 'City', '555-9876', 'WORCESTER', 150, 16.5, 'Patrol cars, drones');",
      "INSERT INTO police_agencies (agency_id, agency_name, agency_type, contact_number, jurisdiction, number_of_officers, response_time, equipment) VALUES (50, 'Regional police', 'Regional', '555-4321', 'Massachusetts', 300, 19.0, 'Patrol cars, boats');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_create_backup_agency that fires after INSERT on the police_agencies table, and for each new row where the agency_id is less than 1000, it creates a backup row in the same table by setting the backup agency_id to the original agency_id plus 1000, appending '_BACKUP' to the agency_name, and copying all other column values from the new row, while logging any insertion errors as a notice without failing the original insert.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named create_backup_agency that automatically runs after each INSERT on the police_agencies table, and for every new row where the agency_id is below 1000, it creates a backup entry in the same table by setting agency_id to the original agency_id plus 1000, appending '_BACKUP' to the agency_name, and copying all other column values from the new record, while gracefully handling any insertion errors by issuing a notice without failing the operation, and finally returns the NEW row.",
    "id": 63,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named create_backup_agency that is automatically executed by a trigger named trigger_create_backup_agency after every row insert operation on the police_agencies table. The function declares a variable to capture any potential exception during the backup insertion. For each newly inserted row, the function checks if the agency_id value from the NEW record is less than 1000. If this condition is true, the function attempts to insert a new row into the police_agencies table. This new row uses an agency_id calculated as the original NEW.agency_id plus 1000. It sets the agency_name to the concatenation of the original NEW.agency_name and the string '_BACKUP'. For all other columnsâ€”agency_type, contact_number, jurisdiction, number_of_officers, response_time, and equipmentâ€”the function copies the values directly from the corresponding columns in the NEW record. The insertion is wrapped in a BEGIN...EXCEPTION block to handle any errors, such as duplicate key violations. If an exception occurs, the function issues a NOTICE with a descriptive message (e.g., 'Backup insertion failed for agency_id: [value]') using the RAISE NOTICE statement, ensuring the original insert operation is not interrupted. After the conditional logic and error handling, the function returns the NEW row to complete the trigger execution. Second, define the trigger trigger_create_backup_agency on the police_agencies table to fire AFTER INSERT for each row, executing the create_backup_agency function.",
    "original_ir": "Write a PLpgSQL function that is designed to be executed as a trigger function, which is invoked after an insert operation on the police_agencies table. This function, named create_backup_agency, does not take any parameters directly but operates on the NEW record, which represents the row being inserted into the police_agencies table. The function first checks if the agency_id of the NEW record is less than 1000. If this condition is true, it proceeds to create a backup record in the same police_agencies table. The backup record is created by inserting a new row with the same values as the NEW record, except for the agency_id and agency_name. The agency_id for the backup record is set to the original agency_id plus 1000, and the agency_name is appended with the string '_BACKUP'. The other columnsâ€”agency_type, contact_number, jurisdiction, number_of_officers, response_time, and equipmentâ€”are copied directly from the NEW record. If any error occurs during the insertion of the backup record, the function catches the exception and logs a notice with the error message using RAISE NOTICE, ensuring that the original insert operation is not affected by the failure to create a backup. The function concludes by returning the NEW record, allowing the original insert operation to complete. This function is associated with a trigger named trg_create_backup_agency, which is set to execute the function after each row is inserted into the police_agencies table.",
    "original_summary": "Create a PostgreSQL trigger function named create_backup_agency that fires after INSERT on police_agencies. For each new row where NEW.agency_id < 1000, insert a backup row into the same table. Set backup agency_id to NEW.agency_id + 1000, agency_name to NEW.agency_name || '_BACKUP', and copy all other columns from NEW. Handle any insertion error with a NOTICE. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a PostgreSQL trigger function, which should be named create_backup_agency, designed to execute automatically after any INSERT operation is performed on the police_agencies table. This function must, for every freshly inserted row where the value in the NEW.agency_id column is less than 1000, meticulously insert a corresponding backup row into the very same table. In this backup row, you must carefully set the agency_id to the original NEW.agency_id increased by 1000, and the agency_name should be derived by appending the literal string '_BACKUP' to the original NEW.agency_name. Furthermore, all remaining column values from the NEW record should be faithfully copied over. It is essential that the function gracefully handles any potential insertion errors by issuing a friendly NOTICE, ensuring the operation does not fail abruptly. Finally, the function must conclusively return the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_course_max_students` that checks if the `NEW.max_students` field is NULL and, if true, assigns the value 30 to it, then returns the `NEW` row.\nSecond, define the trigger `trg_update_max_students` on table `courses` that fires BEFORE UPDATE for each row when `(NEW.max_students IS NULL)` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_course_max_students() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.max_students IS NULL THEN\n    NEW.max_students = 30; -- Directly modify the NEW record\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_max_students\nBEFORE UPDATE ON courses\nFOR EACH ROW\nWHEN (NEW.max_students IS NULL) -- This WHEN clause is still useful to only fire the trigger when necessary\nEXECUTE FUNCTION update_course_max_students();",
    "database_name": "university_course_management_and_syllabus_approval",
    "tables": [
      "course_proposals",
      "courses",
      "syllabi",
      "users"
    ],
    "call_sqls": [
      "UPDATE courses SET course_title = 'Updated Title' WHERE course_id = 0 AND max_students IS NULL;",
      "UPDATE courses SET max_students = NULL WHERE course_id = 1;",
      "UPDATE courses SET course_description = 'New description' WHERE course_id = 0 AND max_students IS NULL;",
      "UPDATE courses SET prerequisites = 'New Prereq' WHERE course_id = 1 AND max_students IS NULL;",
      "UPDATE courses SET semester_offered = 'Fall' WHERE course_id = 0 AND max_students IS NULL;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_max_students that fires BEFORE UPDATE on the courses table for each row when NEW.max_students is NULL, setting NEW.max_students to 30 and returning NEW.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_update_max_students that, before updating a record in the courses table, ensures the NEW.max_students is set to 30 if it is null.",
    "id": 64,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_course_max_students` that checks if the `NEW.max_students` field is NULL and, if true, assigns the value 30 to it, then returns the `NEW` row.\nSecond, define the trigger `trg_update_max_students` on table `courses` that fires BEFORE UPDATE for each row when `(NEW.max_students IS NULL)` and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_course_max_students that returns a trigger, which is then bound to a trigger named trg_update_max_students on the courses table, where the trigger is configured to fire BEFORE UPDATE for each individual row, but only when the condition in the WHEN clauseâ€”specifically that the NEW.max_students value is NULLâ€”is true, and upon firing, the trigger executes the function which contains a block of PL/pgSQL code that begins by checking if the NEW.max_students field is NULL, and if this condition is met, the function directly assigns the value 30 to the NEW.max_students field within the trigger's context, thereby modifying the incoming row data before it is written to the table, and finally, the function returns the modified NEW row record to the database engine for the update operation to proceed.",
    "original_summary": "Create a BEFORE UPDATE trigger function named update_course_max_students on the courses table. The trigger should fire only when NEW.max_students is NULL. The function should set NEW.max_students to 30 and return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a BEFORE UPDATE trigger on courses. If NEW.max_students is null, set it to 30."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `track_merge_activity` that checks if the `NEW.change_type` is 'merge' and, if true, calculates a unique `next_commit_id` by selecting `COALESCE(MAX(commit_id), 0) + 1` from the `commits` table, then inserts a new row into the `commits` table using this ID, `NEW.repository_id`, `NEW.developer_id`, `NEW.change_date`, the fixed message 'Automated merge tracking', `NEW.change_type`, and the values 0 for `commit_size` and `files_changed`, with an `ON CONFLICT (commit_id) DO NOTHING` clause.\nSecond, define the trigger `trigger_track_merge_activity` on table `repository_changes` that fires `AFTER INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION track_merge_activity() RETURNS TRIGGER AS $$\nDECLARE\n  next_commit_id bigint;\nBEGIN\n  -- Only process merge activities\n  IF NEW.change_type = 'merge' THEN\n    -- Generate a unique commit_id that doesn't conflict with existing commit_ids\n    SELECT COALESCE(MAX(commit_id), 0) + 1 INTO next_commit_id FROM commits;\n    \n    INSERT INTO commits (commit_id, repository_id, developer_id, commit_date, commit_message, commit_type, commit_size, files_changed)\n    VALUES (next_commit_id, NEW.repository_id, NEW.developer_id, NEW.change_date, 'Automated merge tracking', NEW.change_type, 0, 0)\n    ON CONFLICT (commit_id) DO NOTHING;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_track_merge_activity\nAFTER INSERT ON repository_changes\nFOR EACH ROW EXECUTE FUNCTION track_merge_activity();",
    "database_name": "software_development_and_collaboration_metrics",
    "tables": [
      "projects",
      "repositories",
      "commits",
      "issues",
      "repository_changes"
    ],
    "call_sqls": [
      "INSERT INTO repository_changes (change_id, repository_id, developer_id, change_date, change_type) VALUES (2, 1, 1, '2023-01-01', 'merge');",
      "INSERT INTO repository_changes (change_id, repository_id, developer_id, change_date, change_type) VALUES (3, 0, 0, '2023-01-02', 'merge');",
      "INSERT INTO repository_changes (change_id, repository_id, developer_id, change_date, change_type) VALUES (4, 1, 0, '2023-01-03', 'merge');",
      "INSERT INTO repository_changes (change_id, repository_id, developer_id, change_date, change_type) VALUES (5, 0, 1, '2023-01-04', 'merge');",
      "INSERT INTO repository_changes (change_id, repository_id, developer_id, change_date, change_type) VALUES (6, 1, 1, '2023-01-05', 'merge');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trigger_track_merge_activity that fires AFTER INSERT on the repository_changes table. When a new row is inserted with a change_type of 'merge', it should generate a new commit_id by taking the maximum existing commit_id from the commits table and adding 1, then insert a corresponding row into the commits table using the new commit_id, along with the repository_id, developer_id, and change_date from the new row as commit_date, set the commit_message to 'Automated merge tracking', use the change_type as commit_type, and set commit_size and files_changed to 0. If there is a conflict on commit_id, the insertion should be skipped without error.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trigger_track_merge_activity that runs AFTER INSERT on the repository_changes table. When a new row is inserted with a change_type of 'merge', insert a corresponding record into the commits table, generating a new commit_id as one greater than the current maximum commit_id in commits, and using the new row's repository_id, developer_id, and change_date, along with a fixed commit_message of 'Automated merge tracking', the change_type as commit_type, and zeros for commit_size and files_changed. If there is a conflict on commit_id, skip the insertion.",
    "id": 65,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `track_merge_activity` that checks if the `NEW.change_type` is 'merge' and, if true, calculates a unique `next_commit_id` by selecting `COALESCE(MAX(commit_id), 0) + 1` from the `commits` table, then inserts a new row into the `commits` table using this ID, `NEW.repository_id`, `NEW.developer_id`, `NEW.change_date`, the fixed message 'Automated merge tracking', `NEW.change_type`, and the values 0 for `commit_size` and `files_changed`, with an `ON CONFLICT (commit_id) DO NOTHING` clause.\nSecond, define the trigger `trigger_track_merge_activity` on table `repository_changes` that fires `AFTER INSERT` and executes the function.",
    "original_ir": "Write a PLpgSQL function named track_merge_activity that is designed to be executed as a trigger after an insert operation on the repository_changes table. This function does not take any parameters directly but operates on the NEW record, which represents the row being inserted into the repository_changes table. The function begins by declaring a local variable next_commit_id of type bigint, which will be used to store the next available commit_id. The function then checks if the change_type column of the NEW record is equal to 'merge', indicating that the inserted row represents a merge activity. If this condition is true, the function proceeds to generate a unique commit_id by selecting the maximum commit_id from the commits table, using the COALESCE function to handle cases where there are no existing commit_ids, defaulting to 0, and then adding 1 to this maximum value. This calculated next_commit_id is stored in the next_commit_id variable. Subsequently, the function inserts a new row into the commits table with the following values: next_commit_id for the commit_id column, NEW.repository_id for the repository_id column, NEW.developer_id for the developer_id column, NEW.change_date for the commit_date column, a fixed string 'Automated merge tracking' for the commit_message column, NEW.change_type for the commit_type column, and 0 for both the commit_size and files_changed columns. The insertion operation includes an ON CONFLICT clause that specifies DO NOTHING, ensuring that if a row with the same commit_id already exists, the insertion is skipped. Finally, the function returns the NEW record, allowing the trigger to complete its operation. The trigger named trigger_track_merge_activity is created to execute this function after each row is inserted into the repository_changes table, ensuring that merge activities are tracked automatically in the commits table.",
    "original_summary": "Create an AFTER INSERT trigger on the repository_changes table. If the new change_type is 'merge', generate a new commit_id (max existing +1), and insert a row into the commits table with the new id, repository_id, developer_id, change_date as commit_date, 'Automated merge tracking' as commit_message, change_type as commit_type, and 0 for commit_size and files_changed. Skip insertion on conflict.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create an AFTER INSERT trigger for repository_changes. On 'merge' change_type, insert into commits using max(commit_id)+1, pulling data from the new row. Skip on conflict."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_claim_changes_trigger` that checks if a `claim_id` from the `OLD` row is referenced in the `payments` table by counting rows with `SELECT COUNT(*) INTO ref_count`. If the count is greater than 0, it raises a notice with the `claim_id` and returns NULL to prevent deletion; otherwise, it returns OLD to allow deletion.\nSecond, define the trigger `trg_log_claim_changes` on table `claims` that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_claim_changes_trigger() RETURNS TRIGGER AS $$\nDECLARE\n    ref_count INTEGER;\nBEGIN\n    -- Check if the claim_id is referenced in the payments table\n    SELECT COUNT(*) INTO ref_count FROM payments WHERE claim_id = OLD.claim_id;\n\n    IF ref_count > 0 THEN\n        -- Log the attempt to delete a referenced claim\n        RAISE NOTICE 'Attempt to delete claim_id % which is still referenced in payments.', OLD.claim_id;\n        RETURN NULL; -- Prevent deletion\n    ELSE\n        RETURN OLD; -- Allow deletion\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_claim_changes\n    BEFORE DELETE ON claims\n    FOR EACH ROW\n    EXECUTE FUNCTION log_claim_changes_trigger();",
    "database_name": "insurance_claim_and_reserve_management",
    "tables": [
      "claims"
    ],
    "call_sqls": [
      "DELETE FROM claims WHERE claim_id = 0;",
      "DELETE FROM claims WHERE claim_id = 1;",
      "DELETE FROM claims WHERE claim_id = 2;",
      "DELETE FROM claims WHERE claim_id = 3;",
      "DELETE FROM claims WHERE claim_id = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_log_claim_changes that fires BEFORE DELETE on the claims table for each row, which checks if the OLD.claim_id is referenced in the payments table, and if any such payments exist, it raises a notice and cancels the delete; otherwise, it allows the delete to proceed.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_log_claim_changes that runs before a delete on the claims table, checks if the claim_id being deleted exists in the payments table, and if it does, raises a notice and cancels the delete; otherwise, it allows the deletion.",
    "id": 66,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named log_claim_changes_trigger that is executed automatically by a trigger named trg_log_claim_changes before any row is deleted from the claims table in the insurance_claim_and_reserve_management database. This function performs a validation check to prevent deletion of claims that have associated payment records. Specifically, it declares a variable, such as payment_exists, of type boolean to store the result of a query. It then executes a SELECT statement that queries the payments table, using a WHERE clause to check if there is at least one row where the claim_id column matches the OLD.claim_id value from the row being deleted from the claims table. The query uses an EXISTS subquery or a COUNT aggregation to determine if any such payment records exist. If the query returns a true result, indicating that at least one payment record is linked to the claim, the function raises a NOTICE with a descriptive message, such as 'Cannot delete claim with associated payments', and then returns NULL to cancel the delete operation. If the query returns a false result, indicating no associated payments exist, the function returns the OLD row record to allow the original delete operation on the claims table to proceed. Second, define the trigger trg_log_claim_changes on the claims table, specifying that it fires BEFORE DELETE for each row and calls the log_claim_changes_trigger function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `log_claim_changes_trigger` that is designed to be executed as a trigger. This function takes no explicit input parameters but operates within the context of a trigger, meaning it has access to special variables like `OLD` and `NEW` representing the row before and after the triggering event, respectively. The function is declared to return a `TRIGGER` type, which is standard for PostgreSQL trigger functions.\n\nInside the function, a local variable named `ref_count` of type `INTEGER` is declared to store a count. The function's execution begins by performing a `SELECT` operation to count the number of rows in the `payments` table. This count is stored in the `ref_count` variable. The `SELECT` statement includes a `WHERE` clause that filters rows in the `payments` table where the `claim_id` column matches the `claim_id` value from the `OLD` row. The `OLD` row represents the state of the row in the `claims` table *before* the `DELETE` operation that activated this trigger.\n\nFollowing the `SELECT` statement, a conditional `IF` statement evaluates the value of `ref_count`.\nIf `ref_count` is greater than `0`, indicating that the `claim_id` from the `claims` table (which is being targeted for deletion) is still referenced by one or more rows in the `payments` table, the following actions are taken:\n1. A `RAISE NOTICE` statement is executed. This statement generates a notice message that will be displayed to the client application or logged. The message indicates an \"Attempt to delete claim_id % which is still referenced in payments.\", where `%` is replaced by the actual `claim_id` value from the `OLD` row.\n2. The function then `RETURN NULL;`. In the context of a `BEFORE` trigger for a `DELETE` operation, returning `NULL` prevents the actual `DELETE` operation on the `claims` table from proceeding.\n\nIf `ref_count` is not greater than `0` (i.e., it is `0`), meaning the `claim_id` from the `claims` table is not referenced by any rows in the `payments` table, the `ELSE` block is executed:\n1. The function `RETURN OLD;`. In the context of a `BEFORE` trigger for a `DELETE` operation, returning `OLD` allows the actual `DELETE` operation on the `claims` table to proceed as normal, deleting the row represented by `OLD`.\n\nAfter the function definition, a `CREATE TRIGGER` statement defines a trigger named `trg_log_claim_changes`. This trigger is configured to execute `BEFORE DELETE` operations on the `claims` table. It is specified as `FOR EACH ROW`, meaning the trigger function will be executed once for every row that is targeted for deletion. The trigger is set to `EXECUTE FUNCTION log_claim_changes_trigger()`, which means the previously defined `log_claim_changes_trigger` function will be invoked whenever the trigger conditions are met.",
    "original_summary": "Create a PostgreSQL trigger function named log_claim_changes_trigger that fires BEFORE DELETE on the claims table for each row. It checks if the OLD.claim_id exists in the payments table. If referenced payments exist, it raises a notice and returns NULL to cancel the delete. If no references exist, it returns OLD to allow the delete.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create trigger log_claim_changes_trigger before delete on claims. If claim_id exists in payments, raise notice and cancel delete. Otherwise, allow it."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_system_status_on_cpu_load` that declares a boolean variable `time_exists`, uses a SELECT EXISTS query on the `time_measurements` table to check if the `NEW.time_id` exists, raises an exception with the message 'time_id % does not exist in time_measurements table' if the check is false, and then updates the `system_status` column to 'inactive' in the `systems` table where `system_id` matches `NEW.system_id` and `NEW.load_value` is greater than 90.\nSecond, define the trigger `trg_update_system_status_on_cpu_load` on table `cpu_loads` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_system_status_on_cpu_load() RETURNS TRIGGER AS $$\nDECLARE\n  time_exists boolean;\nBEGIN\n  -- Check if the time_id exists in time_measurements table\n  SELECT EXISTS(SELECT 1 FROM time_measurements WHERE time_id = NEW.time_id) INTO time_exists;\n  \n  -- If time_id doesn't exist, prevent the insert\n  IF NOT time_exists THEN\n    RAISE EXCEPTION 'time_id % does not exist in time_measurements table', NEW.time_id;\n  END IF;\n  \n  -- Update system status if load value exceeds threshold\n  UPDATE systems SET system_status = 'inactive' WHERE system_id = NEW.system_id AND NEW.load_value > 90;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_system_status_on_cpu_load\nBEFORE INSERT ON cpu_loads\nFOR EACH ROW EXECUTE FUNCTION update_system_status_on_cpu_load();",
    "database_name": "system_performance_monitoring_and_analysis_481541",
    "tables": [
      "systems",
      "access_logs",
      "users",
      "battery_powers",
      "cpu_loads",
      "memory_usages",
      "time_measurements"
    ],
    "call_sqls": [
      "INSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (100, 0, 85, 1, 0, 'medium');",
      "INSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (101, 1, 95, 0, 1, 'high');",
      "INSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (102, 0, 91, 1, 1, 'high');",
      "INSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (103, 1, 50, 0, 0, 'low');",
      "INSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (104, 0, 100, 1, 1, 'critical');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_system_status_on_cpu_load that runs before inserting a row into the cpu_loads table. For each new row, first ensure the time_id exists in the time_measurements table; if it does not, prevent the insertion with an error. If the time_id exists and the new load_value is greater than 90, update the systems table to set the system_status to 'inactive' for the matching system_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_system_status_on_cpu_load that fires before each new row is inserted into the cpu_loads table. For each new entry, first verify that its time_id exists in the time_measurements table; if not, raise an error to prevent the insert. If the time_id exists and the new load_value exceeds 90, then update the systems table by setting the system_status to 'inactive' for the matching system_id. Finally, return the NEW row.",
    "id": 67,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_system_status_on_cpu_load` that declares a boolean variable `time_exists`, uses a SELECT EXISTS query on the `time_measurements` table to check if the `NEW.time_id` exists, raises an exception with the message 'time_id % does not exist in time_measurements table' if the check is false, and then updates the `system_status` column to 'inactive' in the `systems` table where `system_id` matches `NEW.system_id` and `NEW.load_value` is greater than 90.\nSecond, define the trigger `trg_update_system_status_on_cpu_load` on table `cpu_loads` that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_system_status_on_cpu_load` that is executed `BEFORE INSERT` on the `cpu_loads` table for `EACH ROW`. This function first declares a local boolean variable named `time_exists`. It then performs a `SELECT` operation to check for the existence of a record in the `time_measurements` table. Specifically, it queries `time_measurements` to determine if any row has a `time_id` column value that is equal to the `time_id` column value of the `NEW` row being inserted into the `cpu_loads` table. The result of this existence check (true or false) is stored in the `time_exists` boolean variable. Following this, a conditional `IF` statement evaluates the `time_exists` variable. If `time_exists` is `FALSE` (meaning the `time_id` from the `NEW` `cpu_loads` row does not exist in the `time_measurements` table), the function `RAISE`s an `EXCEPTION` with the message 'time_id % does not exist in time_measurements table', where '%' is replaced by the specific `time_id` value from the `NEW` `cpu_loads` row, thereby preventing the `INSERT` operation on `cpu_loads`. If `time_exists` is `TRUE`, the function proceeds to an `UPDATE` operation on the `systems` table. This `UPDATE` sets the `system_status` column to the string literal 'inactive' for any row in the `systems` table where the `system_id` column value matches the `system_id` column value of the `NEW` row being inserted into `cpu_loads`, AND where the `load_value` column value of the `NEW` row being inserted into `cpu_loads` is strictly greater than the integer literal `90`. Finally, the function `RETURN`s the `NEW` row, allowing the `INSERT` operation on `cpu_loads` to proceed if no exception was raised.",
    "original_summary": "Create a BEFORE INSERT trigger function named update_system_status_on_cpu_load on the cpu_loads table. For each row, first verify the time_id exists in the time_measurements table. If not, raise an exception. If it exists and the new load_value is greater than 90, update the systems table to set system_status to 'inactive' for the matching system_id. Then return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that fires before any new row goes into the cpu_loads table. Call it update_system_status_on_cpu_load. For each new entry, first check if its time_id actually exists over in the time_measurements table. If it's not there, we gotta throw an error. If it does exist and the new load_value is crazy highâ€”like over 90â€”then we should go update the systems table. Find the matching system_id and set its system_status to 'inactive'. Finally, just hand back the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function validate_manufacturer_currency that checks if the NEW.manufacturer_currency value is NOT IN the list ('USD', 'EUR', 'JPY') and, if true, sets it to 'USD'. Second, define the trigger trg_validate_manufacturer_currency on table manufacturers that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_manufacturer_currency() RETURNS TRIGGER AS $$\nBEGIN\nIF NEW.manufacturer_currency NOT IN ('USD', 'EUR', 'JPY') THEN\n    NEW.manufacturer_currency := 'USD';\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_manufacturer_currency\nBEFORE INSERT ON manufacturers\nFOR EACH ROW EXECUTE FUNCTION validate_manufacturer_currency();",
    "database_name": "automobile_performance_and_specification_database",
    "tables": [
      "vehicles",
      "manufacturers",
      "transmissions",
      "vehicle_features",
      "vehicle_models",
      "vehicle_sales"
    ],
    "call_sqls": [
      "INSERT INTO manufacturers (manufacturer_id, manufacturer_name, headquarters, contact_email, manufacturer_website, manufacturer_phone, manufacturer_founded_year, manufacturer_logo_url, manufacturer_currency, manufacturer_language) VALUES (1, 'Manufacturer A', 'USA', 'contact@manufacturerA.com', 'www.manufacturerA.com', '123-456-7890', 1990, 'logoA.png', 'GBP', 'English');",
      "INSERT INTO manufacturers (manufacturer_id, manufacturer_name, headquarters, contact_email, manufacturer_website, manufacturer_phone, manufacturer_founded_year, manufacturer_logo_url, manufacturer_currency, manufacturer_language) VALUES (2, 'Manufacturer B', 'Germany', 'contact@manufacturerB.com', 'www.manufacturerB.com', '098-765-4321', 1985, 'logoB.png', 'AUD', 'German');",
      "INSERT INTO manufacturers (manufacturer_id, manufacturer_name, headquarters, contact_email, manufacturer_website, manufacturer_phone, manufacturer_founded_year, manufacturer_logo_url, manufacturer_currency, manufacturer_language) VALUES (3, 'Manufacturer C', 'Japan', 'contact@manufacturerC.com', 'www.manufacturerC.com', '555-555-5555', 2000, 'logoC.png', 'CAD', 'Japanese');",
      "INSERT INTO manufacturers (manufacturer_id, manufacturer_name, headquarters, contact_email, manufacturer_website, manufacturer_phone, manufacturer_founded_year, manufacturer_logo_url, manufacturer_currency, manufacturer_language) VALUES (4, 'Manufacturer D', 'France', 'contact@manufacturerD.com', 'www.manufacturerD.com', '444-444-4444', 1975, 'logoD.png', 'INR', 'French');",
      "INSERT INTO manufacturers (manufacturer_id, manufacturer_name, headquarters, contact_email, manufacturer_website, manufacturer_phone, manufacturer_founded_year, manufacturer_logo_url, manufacturer_currency, manufacturer_language) VALUES (5, 'Manufacturer E', 'Italy', 'contact@manufacturerE.com', 'www.manufacturerE.com', '333-333-3333', 1980, 'logoE.png', 'CNY', 'Italian');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_validate_manufacturer_currency that, before inserting a row into the manufacturers table, checks if the new manufacturer_currency is not 'USD', 'EUR', or 'JPY' and, if so, sets it to 'USD'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_validate_manufacturer_currency that runs before inserting into the manufacturers table, and if the new manufacturer_currency is not USD, EUR, or JPY, set it to USD by default.",
    "id": 68,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function validate_manufacturer_currency that checks if the NEW.manufacturer_currency value is NOT IN the list ('USD', 'EUR', 'JPY') and, if true, sets it to 'USD'. Second, define the trigger trg_validate_manufacturer_currency on table manufacturers that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that is invoked before a new row is inserted into the manufacturers table. The function checks the value of the manufacturer_currency column in the new row. If the value of manufacturer_currency is not one of the specified currencies ('USD', 'EUR', 'JPY'), the function sets the manufacturer_currency to 'USD'. The trigger, named trg_validate_manufacturer_currency, is defined to execute this function for each row before an insert operation on the manufacturers table, ensuring that the manufacturer_currency column always contains a valid currency code from the specified list or defaults to 'USD' if the provided value is not valid.",
    "original_summary": "Create a BEFORE INSERT trigger function for the manufacturers table. If the new row's manufacturer_currency is not 'USD', 'EUR', or 'JPY', set it to 'USD'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger that runs before adding entries to the manufacturers list. Basically, if the currency for a new manufacturer isn't one of the typical major ones, just default it to the most common one."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function cleanup_user_data that deletes all records from the access_logs table where the user_id column matches the OLD.user_id and deletes all records from the weather_reports table where the creator_id column matches the OLD.user_id, then returns the OLD record.\nSecond, define the trigger trg_cleanup_user_data on table users that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION cleanup_user_data() RETURNS TRIGGER AS $$\nBEGIN\n    -- Delete related records from access_logs\n    DELETE FROM access_logs WHERE user_id = OLD.user_id;\n\n    -- Delete related records from weather_reports (this table was implicitly identified by the error)\n    -- Assuming weather_reports has a column like 'creator_id' or 'user_id' that references users.user_id\n    -- Based on the error \"weather_reports_creator_id_fkey\", the column is likely 'creator_id'.\n    DELETE FROM weather_reports WHERE creator_id = OLD.user_id;\n\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cleanup_user_data\nBEFORE DELETE ON users\nFOR EACH ROW\nEXECUTE FUNCTION cleanup_user_data();",
    "database_name": "weather_data_collection_and_analysis_535790",
    "tables": [
      "access_logs",
      "users"
    ],
    "call_sqls": [
      "DELETE FROM users WHERE user_id = 0;",
      "DELETE FROM users WHERE user_id = 1;",
      "INSERT INTO users (user_id, user_name, email, role, department, last_login_date, password_hash) VALUES (2, 'Charlie Brown', 'charlie.brown@example.com', 'admin', 'IT', '2023-10-01', 'hashed_password_2');\nDELETE FROM users WHERE user_id = 2;",
      "INSERT INTO users (user_id, user_name, email, role, department, last_login_date, password_hash) VALUES (3, 'Diana Prince', 'diana.prince@example.com', 'user', 'Marketing', '2023-10-02', 'hashed_password_3');\nINSERT INTO access_logs (access_id, data_id, user_id, access_date, access_type, ip_address, user_agent, duration) VALUES (100, 10, 3, '2023-10-02', 'view', '192.168.1.10', 'Chrome', 45);\nDELETE FROM users WHERE user_id = 3;",
      "INSERT INTO users (user_id, user_name, email, role, department, last_login_date, password_hash) VALUES (4, 'Eve Adams', 'eve.adams@example.com', 'guest', 'Support', '2023-10-03', 'hashed_password_4');\nINSERT INTO access_logs (access_id, data_id, user_id, access_date, access_type, ip_address, user_agent, duration) VALUES (101, 11, 4, '2023-10-03', 'download', '192.168.1.11', 'Firefox', 90);\nDELETE FROM users WHERE user_id = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named cleanup_user_data that, before deleting a row from the users table, deletes all related records from the access_logs table where the user_id matches the deleted user's user_id and from the weather_reports table where the creator_id matches the deleted user's user_id, then returns the OLD record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named cleanup_user_data that runs before a row is deleted from the users table, ensuring that when a user is removed, all associated entries in the access_logs table where user_id matches and in the weather_reports table where creator_id matches are also deleted, and then returns the old user record.",
    "id": 69,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named cleanup_user_data that is executed automatically by a trigger named cleanup_user_data_trigger, which fires before a delete operation on the users table for each row being deleted. Within this function, perform two delete operations. First, delete all rows from the access_logs table where the user_id column matches the OLD.user_id value (the user_id from the row being deleted in the users table). Second, delete all rows from the weather_reports table where the creator_id column matches the OLD.user_id value. After these deletions, the function returns the OLD row record to the trigger mechanism. Second, define the trigger cleanup_user_data_trigger on the users table to execute the cleanup_user_data function before each row deletion.",
    "original_ir": "Write a PLpgSQL trigger function that is executed before a row is deleted from the users table. This function, named cleanup_user_data, does not take any parameters directly but operates on the OLD record, which represents the row being deleted from the users table. The function performs two main operations: first, it deletes all records from the access_logs table where the user_id column matches the user_id of the row being deleted from the users table. Second, it deletes all records from the weather_reports table where the creator_id column matches the user_id of the row being deleted. The function then returns the OLD record. This function is associated with a trigger named trg_cleanup_user_data, which is set to fire before a delete operation on each row of the users table, ensuring that related records in the access_logs and weather_reports tables are removed prior to the deletion of a user.",
    "original_summary": "Create a BEFORE DELETE row-level trigger function named cleanup_user_data. For a row being deleted from the users table, delete related records from the access_logs table (where user_id matches) and the weather_reports table (where creator_id matches). Return the OLD record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger function called cleanup_user_data that runs before a user is removed. When a row from the users table is taken out, also get rid of any associated entries in the access_logs and weather_reports tables where the user identifiers line up. Make sure the old record is given back."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_related_climate_model` that deletes rows from the `climate_models` table where its `year` column matches the `year` column value from the `OLD` record of the deleted row.\nSecond, define the trigger `trg_emissions_data_delete` on table `emissions_data` that fires `AFTER` `DELETE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_climate_model() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM climate_models WHERE year = OLD.year;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_emissions_data_delete\nAFTER DELETE ON emissions_data\nFOR EACH ROW EXECUTE FUNCTION delete_related_climate_model();",
    "database_name": "climate_change_impact_analysis_and_emissions_tracking",
    "tables": [
      "climate_models",
      "emissions_data",
      "emissions_data_sources",
      "emissions_metrics",
      "gas_concentrations",
      "research_publications",
      "users"
    ],
    "call_sqls": [
      "DELETE FROM emissions_data WHERE year = 0;",
      "DELETE FROM emissions_data WHERE year = 1;",
      "DELETE FROM emissions_data WHERE year = (SELECT year FROM emissions_data ORDER BY year DESC LIMIT 1);",
      "DELETE FROM emissions_data WHERE year IN (SELECT year FROM emissions_data LIMIT 2);",
      "DELETE FROM emissions_data WHERE year = (SELECT MIN(year) FROM emissions_data);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named delete_related_climate_model that fires AFTER DELETE on the emissions_data table via trigger trg_emissions_data_delete, and for each deleted row, removes all corresponding records from the climate_models table where the year in climate_models matches the year of the deleted emissions_data row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called delete_related_climate_model that, after a row is deleted from the emissions_data table, automatically removes any corresponding rows in the climate_models table where the year matches the year of the deleted emissions_data record, and ensure the trigger is named trg_emissions_data_delete.",
    "id": 70,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named `delete_related_climate_model`. This function is designed to be executed in response to data deletion events on the `emissions_data` table. The function does not accept any explicit input parameters beyond the implicit `OLD` record provided by the trigger mechanism, which represents the state of the row *before* the `DELETE` operation that fired the trigger. The function's primary purpose is to perform a cascading deletion operation to maintain referential integrity between the `emissions_data` and `climate_models` tables based on the shared `year` column.\n\nThe function's logic is as follows: it executes a `DELETE` statement targeting the `climate_models` table. The rows to be deleted are identified by a single condition: the `year` column in the `climate_models` table must match the value of the `year` column from the `OLD` record. This ensures that any climate model records associated with the same year as the deleted emissions data record are also removed. After performing the deletion, the function returns the `OLD` record, which is the standard practice for `AFTER DELETE` triggers in PostgreSQL to indicate that the triggering operation has completed.\n\nSecond, define the trigger `trg_emissions_data_delete` on the `emissions_data` table. This trigger is configured to fire `AFTER DELETE` operations on the `emissions_data` table. It is a `FOR EACH ROW` trigger, meaning that the `delete_related_climate_model` function will be executed once for each row that is deleted from the `emissions_data` table. The trigger explicitly executes the `delete_related_climate_model()` function. Therefore, whenever a row in the `emissions_data` table is deleted, this trigger will activate, and the `delete_related_climate_model` function will automatically delete any corresponding rows from the `climate_models` table where the `year` matches the `year` of the row that was just deleted.",
    "original_ir": "Write a PostgreSQL trigger function named delete_related_climate_model that returns a trigger, which is automatically executed by a trigger named trg_emissions_data_delete defined on the emissions_data table to fire after every row deletion operation on that table, and this function performs a single delete operation on the climate_models table where the year column value in climate_models matches the year column value from the OLD record of the deleted row in emissions_data, and the function concludes by returning the OLD record.",
    "original_summary": "Create a PostgreSQL trigger function named delete_related_climate_model that returns a trigger. It fires AFTER DELETE on the emissions_data table via trigger trg_emissions_data_delete. It deletes rows from the climate_models table where its year equals the OLD.year from the deleted emissions_data row. The function returns OLD.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Define a PostgreSQL trigger function called delete_related_climate_model that returns a trigger. Set it to execute AFTER DELETE on the emissions_data table using the trigger name trg_emissions_data_delete. Ensure it deletes any rows in the climate_models table where the year matches the OLD.year value from the deleted emissions_data record. Finally, make the function return OLD."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_favorites_capitalize_note` that, for a new row, checks if `favorite_id` is NULL and if so, selects the maximum existing `favorite_id` from the `favorites` table, uses `COALESCE` to return -1 if the maximum is NULL, adds 1 to that result, and assigns it to `NEW.favorite_id`; then, if `note` is not NULL and its length is greater than zero, transforms it by using `UPPER` and `SUBSTR` on the first character and concatenating it with the remainder from the second character via `SUBSTR`, assigning the result to `NEW.note`.\nSecond, define the trigger `capitalize_first_letter` on table `favorites` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_favorites_capitalize_note() RETURNS TRIGGER AS $$\nBEGIN\n    -- Generate favorite_id if not provided\n    IF NEW.favorite_id IS NULL THEN\n        SELECT COALESCE(MAX(favorite_id), -1) + 1 INTO NEW.favorite_id FROM favorites;\n    END IF;\n    \n    -- Capitalize first letter of note\n    IF NEW.note IS NOT NULL AND LENGTH(NEW.note) > 0 THEN\n        NEW.note := UPPER(SUBSTR(NEW.note, 1, 1)) || SUBSTR(NEW.note, 2);\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER capitalize_first_letter\nBEFORE INSERT ON favorites\nFOR EACH ROW EXECUTE FUNCTION trg_favorites_capitalize_note();",
    "database_name": "real_estate_property_management_and_valuation",
    "tables": [
      "favorites"
    ],
    "call_sqls": [
      "INSERT INTO favorites (user_id, property_id, favorite_date, note) VALUES (1, 100, '2024-05-01', 'nice view');",
      "INSERT INTO favorites (favorite_id, user_id, property_id, favorite_date, note) VALUES (NULL, 2, 101, '2024-05-02', 'spacious apartment');",
      "INSERT INTO favorites (user_id, property_id, favorite_date, note) VALUES (3, 102, '2024-05-03', 'good neighborhood');",
      "INSERT INTO favorites (user_id, property_id, favorite_date) VALUES (4, 103, '2024-05-04');",
      "INSERT INTO favorites (user_id, property_id, favorite_date, note) VALUES (5, 104, '2024-05-05', '');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_favorites_capitalize_note that fires BEFORE INSERT on the favorites table for each row. If the favorite_id is not provided, assign it as the next sequential number based on the maximum existing favorite_id, starting from 0 if the table is empty. Additionally, if a note is provided and not empty, capitalize its first letter. Return the updated row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named capitalize_first_letter that runs before inserting new rows into the favorites table. If the new favorite_id is not provided, assign the next available number by incrementing the highest existing favorite_id from the favorites table. Additionally, if a note is provided, ensure its first letter is capitalized. The trigger should properly handle the new row data.",
    "id": 71,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named trg_favorites_capitalize_note that returns a trigger and is executed automatically by a trigger named capitalize_first_letter, which is defined to fire before any insert operation on the favorites table for each individual row being inserted. The function operates on the NEW row variable, which represents the row data to be inserted.\n\nThe function declares a variable, typically named max_id, of type bigint to store the maximum existing favorite_id from the favorites table. The function's logic begins by checking if the NEW.favorite_id is NULL. If it is NULL, the function performs a SELECT operation on the favorites table to retrieve the maximum value from the favorite_id column, storing this value into the max_id variable. If no rows exist in the favorites table, the SELECT operation returns NULL, which the function handles by using COALESCE to treat NULL as 0. The function then calculates the next available favorite_id by adding 1 to the max_id value (or 0 if max_id was NULL) and assigns this calculated value to the NEW.favorite_id column.\n\nNext, the function checks if the NEW.note column is NOT NULL. If a note is provided, the function ensures its first letter is capitalized. This is done by applying string transformations: it takes the first character of the NEW.note string using the SUBSTRING function, converts it to uppercase using the UPPER function, and then concatenates this uppercase first character with the remainder of the original note string starting from the second character onward using the SUBSTRING function again. The resulting string, with the first letter capitalized, is then assigned back to the NEW.note column.\n\nAfter these operations, the function returns the modified NEW row record to the database engine to proceed with the insert operation using this altered data. The trigger, named capitalize_first_letter, is defined to invoke this function before any row is inserted into the favorites table, ensuring that the favorite_id is auto-incremented if not provided and that the note's first letter is capitalized if a note is present.",
    "original_ir": "Write a PostgreSQL trigger function named trg_favorites_capitalize_note that executes before each row is inserted into the favorites table, which first checks if the new row's favorite_id column is null and, if so, performs a select query on the favorites table to find the maximum existing favorite_id value, uses the COALESCE function to return -1 if no maximum is found, adds 1 to that result, and assigns this calculated value to the NEW.favorite_id column; then, the function checks if the new row's note column is not null and has a length greater than zero, and if true, transforms the note value by extracting the first character using the SUBSTR function, converting it to uppercase with the UPPER function, concatenating it with the remainder of the string starting from the second character obtained via another SUBSTR call, and assigns this modified string back to the NEW.note column; finally, the function returns the modified NEW row record.",
    "original_summary": "Create a PostgreSQL trigger function named trg_favorites_capitalize_note that fires BEFORE INSERT on the favorites table FOR EACH ROW. If NEW.favorite_id is null, set it to the maximum existing favorite_id plus 1 (starting at 0 if table is empty). Then, if NEW.note is not null and not empty, capitalize its first letter. Return the modified NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a trigger for the favorites table that runs before adding new entries. If the new favorite's ID isn't provided, figure out the next number to use based on what's already there. Also, if there's a note written for it, maybe tidy it up by making sure the first letter is a capital. Just make sure the trigger handles the new row properly."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function prevent_duplicate_team_members that checks if a row already exists in the team_members table where the team_id and user_id match the NEW values and the left_at column is NULL, raising a notice with the message 'User is already a member of this team' and returning NULL to prevent insertion if such a row exists, otherwise returning NEW.\nSecond, define the trigger trigger_prevent_duplicate_team_members on table team_members that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION prevent_duplicate_team_members() RETURNS TRIGGER AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM team_members WHERE team_id = NEW.team_id AND user_id = NEW.user_id AND left_at IS NULL) THEN\n    RAISE NOTICE 'User is already a member of this team';\n    RETURN NULL; -- Prevent the insertion\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_prevent_duplicate_team_members\nBEFORE INSERT ON team_members\nFOR EACH ROW EXECUTE FUNCTION prevent_duplicate_team_members();",
    "database_name": "user_management_and_authorization_system",
    "tables": [
      "team_invitations",
      "team_members",
      "teams",
      "users"
    ],
    "call_sqls": [
      "INSERT INTO team_members (team_id, user_id, is_leader, joined_at, role_in_team) VALUES (1, 0, 0, '2023-10-01 10:00:00', 'member');",
      "INSERT INTO team_members (team_id, user_id, is_leader, joined_at, role_in_team) VALUES (1, 1, 0, '2023-10-01 10:00:00', 'member');",
      "INSERT INTO team_members (team_id, user_id, is_leader, joined_at, role_in_team) VALUES (0, 0, 1, '2023-10-01 10:00:00', 'leader');",
      "INSERT INTO team_members (team_id, user_id, is_leader, joined_at, role_in_team) VALUES (0, 1, 0, '2023-10-01 10:00:00', 'member');",
      "INSERT INTO team_members (team_id, user_id, is_leader, joined_at, role_in_team) VALUES (1, 0, 1, '2023-10-01 10:00:00', 'leader');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trigger_prevent_duplicate_team_members that executes BEFORE INSERT on the team_members table to ensure no duplicate active members are added. The trigger checks if a new row has the same team_id and user_id as an existing row where left_at is NULL, indicating the user is currently active in the team. If such a duplicate exists, it raises a notice stating 'User is already a member of this team' and prevents the insertion by returning NULL; otherwise, it allows the insertion by returning NEW.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trigger_prevent_duplicate_team_members that runs before inserting a record into the team_members table, and checks if the user being added is already an active member of the same team by verifying that there is an existing record with matching team_id and user_id where left_at is null; if such a record exists, it raises a notice saying 'User is already a member of this team' and prevents the insertion, otherwise it allows the new record to be added.",
    "id": 72,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named prevent_duplicate_team_members that returns a trigger and is executed automatically by a trigger named trigger_prevent_duplicate_team_members, which is defined to fire BEFORE any INSERT operation on the team_members table for each individual row being inserted. The function's logic begins by checking for the existence of at least one record in the team_members table where the team_id column matches the NEW.team_id value from the row being inserted, and the user_id column matches the NEW.user_id value from the row being inserted, and the left_at column is NULL, indicating an active membership, using a SELECT 1 statement within an EXISTS condition. If such a record exists in the team_members table, the function raises a notice with the message 'User is already a member of this team' and returns NULL, thereby preventing the insertion from proceeding. If no such record exists, the function proceeds by returning the NEW row record, thereby allowing the INSERT operation on the team_members table to complete. Second, define the trigger trigger_prevent_duplicate_team_members on table team_members to execute the prevent_duplicate_team_members function before each row insertion.",
    "original_ir": "Write a PLpgSQL function that serves as a trigger function to prevent the insertion of duplicate active team members into the team_members table. This function is executed before an insert operation on the team_members table. It checks if there is already an existing row in the team_members table with the same team_id and user_id as the new row being inserted, where the left_at column is NULL, indicating that the user is currently an active member of the team. If such a row exists, the function raises a notice with the message 'User is already a member of this team' and returns NULL, effectively preventing the insertion of the new row. If no such row exists, the function allows the insertion to proceed by returning the NEW record. The trigger named trigger_prevent_duplicate_team_members is created to invoke this function before any insert operation on the team_members table, ensuring that no duplicate active team members are added.",
    "original_summary": "Create a BEFORE INSERT trigger function on team_members that prevents duplicate active members. If a new row has the same team_id and user_id as an existing row where left_at is NULL, raise a notice 'User is already a member of this team' and return NULL. Otherwise, return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that kicks in before we add someone to the team_members list. Basically, if you're trying to add a person to a team and they're already listed as an active member there (meaning they haven't left yet, so left_at is empty), we gotta stop it. The trigger should check for matching team and user IDs where left_at is null. If it finds a match, just put out a message saying 'User is already a member of this team' and don't insert anything. If they're not already an active member, then go ahead and let the new record through."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `cleanup_performance_data` that deletes rows from the `metric_values` table where the `version_id` matches the `OLD.version_id` and then deletes rows from the `performances` table where the `version_id` also matches the `OLD.version_id`, finally returning the OLD record.\nSecond, define the trigger `trg_cleanup_performance_data` on table `versions` that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION cleanup_performance_data() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM metric_values WHERE version_id = OLD.version_id;\n    DELETE FROM performances WHERE version_id = OLD.version_id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cleanup_performance_data\n    BEFORE DELETE ON versions\n    FOR EACH ROW\n    EXECUTE FUNCTION cleanup_performance_data();",
    "database_name": "machine_learning_model_performance_metrics_773034",
    "tables": [
      "models",
      "versions",
      "metric_values",
      "performances"
    ],
    "call_sqls": [
      "DELETE FROM versions WHERE version_id = 0;",
      "DELETE FROM versions WHERE version_id = 1;",
      "DELETE FROM versions WHERE version_id = (SELECT version_id FROM versions ORDER BY version_id DESC LIMIT 1);",
      "DELETE FROM versions WHERE version_id = (SELECT version_id FROM versions ORDER BY RANDOM() LIMIT 1);",
      "DELETE FROM versions WHERE version_id IN (SELECT version_id FROM versions LIMIT 2);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named cleanup_performance_data that, before a row is deleted from the versions table, deletes all related rows from the metric_values and performances tables where the version_id matches the version_id of the row being deleted from versions.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named cleanup_performance_data that, before a row is deleted from the versions table, deletes all matching rows in the metric_values and performances tables using the version_id from the row being deleted, then returns the OLD record.",
    "id": 73,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named cleanup_performance_data. This function is executed before a row is deleted from the versions table. The function operates on the OLD record, which represents the row being deleted. The function does not take any parameters directly but uses the OLD record's version_id column. The function performs two delete operations. First, it deletes all rows from the metric_values table where the version_id column matches the OLD.version_id. Second, it deletes all rows from the performances table where the version_id column matches the OLD.version_id. After these deletions, the function returns the OLD record, allowing the original delete operation on the versions table to proceed. Second, define the trigger trg_cleanup_performance_data on the versions table. This trigger is set to fire before each row is deleted from the versions table, and it calls the cleanup_performance_data function. The trigger ensures that whenever a version record is deleted, all associated metric values and performance records linked by the same version_id are also removed, maintaining referential integrity.",
    "original_ir": "Write a PLpgSQL trigger function named cleanup_performance_data that is designed to execute before a row is deleted from the versions table. This function does not take any parameters directly, but it operates using the OLD record, which represents the row that is about to be deleted from the versions table. The function performs two delete operations: first, it deletes all rows from the metric_values table where the version_id column matches the version_id of the OLD record from the versions table; second, it deletes all rows from the performances table where the version_id column also matches the version_id of the OLD record. After executing these delete operations, the function returns the OLD record. The trigger named trg_cleanup_performance_data is associated with the versions table and is set to fire before a delete operation on each row, ensuring that the cleanup_performance_data function is executed for every row that is deleted from the versions table.",
    "original_summary": "Create a BEFORE DELETE row-level trigger function named cleanup_performance_data for the versions table. It deletes related rows from metric_values and performances tables where version_id matches the OLD record's version_id, then returns OLD.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a BEFORE DELETE trigger cleanup_performance_data for versions. Delete matching rows in metric_values and performances using OLD.version_id, then return OLD."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_new_enrollment` that declares a local variable `new_attendance_id` of type TEXT, assigns it the concatenated value of `NEW.enrollment_id` and the literal string `_ATT`, inserts a new record into the `attendance` table using this variable for the `attendance_id` column and `NEW.enrollment_id` for the `enrollment_id` column while setting both `attendance_count` and `absence_count` to 0, and includes an EXCEPTION block to raise a NOTICE with the error message from `SQLERRM` on failure while still returning NEW.\nSecond, define the trigger `trg_log_new_enrollment` on table `student_courses` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_new_enrollment() RETURNS TRIGGER AS $$\nDECLARE\n    new_attendance_id TEXT;\nBEGIN\n    -- Generate a unique attendance_id using enrollment_id with a suffix\n    new_attendance_id := NEW.enrollment_id || '_ATT';\n    \n    -- Insert attendance record with proper unique attendance_id\n    INSERT INTO attendance (attendance_id, enrollment_id, attendance_count, absence_count) \n    VALUES (new_attendance_id, NEW.enrollment_id, 0, 0);\n    \n    RETURN NEW;\nEXCEPTION\n    WHEN others THEN\n        -- Log error but don't prevent the original insert\n        RAISE NOTICE 'Failed to create attendance record for enrollment %: %', NEW.enrollment_id, SQLERRM;\n        RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_new_enrollment\n    AFTER INSERT ON student_courses\n    FOR EACH ROW\n    EXECUTE FUNCTION log_new_enrollment();",
    "database_name": "student_academic_performance_tracking",
    "tables": [
      "student_courses",
      "students",
      "courses",
      "attendance",
      "finals"
    ],
    "call_sqls": [
      "INSERT INTO student_courses (enrollment_id, student_id, course_id, semester_id, grade, status) VALUES ('ENR100', 'STU100', 'CS101', 'SEM2024F', NULL, 'Enrolled');",
      "INSERT INTO student_courses (enrollment_id, student_id, course_id, semester_id, grade, status) VALUES ('ENR101', 'STU101', 'BIO101', 'SEM2024F', NULL, 'Enrolled');",
      "INSERT INTO student_courses (enrollment_id, student_id, course_id, semester_id, grade, status) VALUES ('ENR102', 'STU100', 'CS102', 'SEM2024F', NULL, 'Enrolled');",
      "INSERT INTO student_courses (enrollment_id, student_id, course_id, semester_id, grade, status) VALUES ('ENR103', 'STU102', 'BIO101', 'SEM2024F', NULL, 'Enrolled');",
      "INSERT INTO student_courses (enrollment_id, student_id, course_id, semester_id, grade, status) VALUES ('ENR104', 'STU101', 'CS101', 'SEM2024F', NULL, 'Enrolled');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_log_new_enrollment that, after each new row is inserted into the student_courses table, automatically creates a corresponding record in the attendance table by generating a unique attendance_id from the new enrollment_id with an '_ATT' suffix and initializing the attendance_count and absence_count to zero; if any error occurs during this process, log an error notice without blocking the original insert.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called log_new_enrollment that, after each insert into the student_courses table, automatically generates a unique attendance_id by appending '_ATT' to the new enrollment_id, inserts a corresponding record into the attendance table with attendance_count and absence_count set to zero, logs an error notice if the insertion fails without blocking the original insert, and returns the NEW row.",
    "id": 74,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_new_enrollment` that declares a local variable `new_attendance_id` of type TEXT, assigns it the concatenated value of `NEW.enrollment_id` and the literal string `_ATT`, inserts a new record into the `attendance` table using this variable for the `attendance_id` column and `NEW.enrollment_id` for the `enrollment_id` column while setting both `attendance_count` and `absence_count` to 0, and includes an EXCEPTION block to raise a NOTICE with the error message from `SQLERRM` on failure while still returning NEW.\nSecond, define the trigger `trg_log_new_enrollment` on table `student_courses` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `log_new_enrollment` that is designed to be executed `AFTER INSERT` operations on the `student_courses` table, `FOR EACH ROW` that is inserted. This function does not accept any explicit parameters but implicitly receives special trigger variables: `NEW` (representing the new row being inserted into `student_courses`) and `OLD` (which would represent the old row, but is not used in an `AFTER INSERT` trigger). The function declares a local variable named `new_attendance_id` of type `TEXT`. Upon execution, the function first constructs a unique identifier for an attendance record by concatenating the value of the `enrollment_id` column from the `NEW` row (the newly inserted row in `student_courses`) with the literal string `_ATT`. This concatenated string is then assigned to the `new_attendance_id` variable. Subsequently, the function attempts to insert a new record into the `attendance` table. For this insertion, the `attendance_id` column is populated with the value stored in the `new_attendance_id` variable, the `enrollment_id` column is populated with the value of the `enrollment_id` column from the `NEW` row, the `attendance_count` column is set to the integer literal `0`, and the `absence_count` column is also set to the integer literal `0`. After this insertion, the function returns the `NEW` row, allowing the original `INSERT` operation on `student_courses` to complete successfully. In the event that any error occurs during the execution of the `BEGIN` block (specifically, during the `INSERT` operation into the `attendance` table), the `EXCEPTION` block is activated. Within this `EXCEPTION` block, a notice message is raised. This notice includes the literal string 'Failed to create attendance record for enrollment %: %', where the first `%` placeholder is replaced by the value of the `enrollment_id` column from the `NEW` row, and the second `%` placeholder is replaced by the SQL error message obtained from the `SQLERRM` special variable. After raising this notice, the function still returns the `NEW` row, ensuring that the original `INSERT` operation on the `student_courses` table is not prevented or rolled back due to the failure to create the attendance record. The trigger `trg_log_new_enrollment` is defined to execute this `log_new_enrollment` function. This trigger is activated `AFTER` an `INSERT` statement is performed on the `student_courses` table, and it executes `FOR EACH ROW` that is inserted into `student_courses`.",
    "original_summary": "Create an AFTER INSERT trigger function named log_new_enrollment that generates a unique attendance_id and inserts a record into the attendance table with default counts. Handle exceptions by logging an error notice without preventing the original insert. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER INSERT trigger function named log_new_enrollment that generates a unique attendance_id, inserts a record into the attendance table with default counts, handles exceptions by logging an error notice without preventing the original insert, and returns NEW?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function backup_deleted_mapping that inserts a row into the indicator_sectors table using values from the OLD record, specifically setting indicator_sector_id to OLD.indicator_sector_id + 20000, indicator_id to OLD.indicator_id, sector_id to OLD.sector_id, weight to OLD.weight, start_year to OLD.start_year, and end_year to the fixed value 1999, and then returns OLD. Second, define the trigger trg_backup_deleted_mapping on table indicator_sectors that fires BEFORE DELETE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION backup_deleted_mapping() RETURNS TRIGGER AS $$\nBEGIN\nINSERT INTO indicator_sectors (indicator_sector_id, indicator_id, sector_id, weight, start_year, end_year) VALUES (OLD.indicator_sector_id + 20000, OLD.indicator_id, OLD.sector_id, OLD.weight, OLD.start_year, 1999);\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_backup_deleted_mapping\nBEFORE DELETE ON indicator_sectors\nFOR EACH ROW EXECUTE FUNCTION backup_deleted_mapping();",
    "database_name": "economic_data_analysis_and_reporting_564662",
    "tables": [
      "economic_indicators",
      "indicator_sectors",
      "sectors"
    ],
    "call_sqls": [
      "DELETE FROM indicator_sectors WHERE indicator_sector_id = 0;",
      "DELETE FROM indicator_sectors WHERE indicator_sector_id = 1;",
      "DELETE FROM indicator_sectors WHERE indicator_sector_id = 2;",
      "DELETE FROM indicator_sectors WHERE indicator_sector_id = 3;",
      "DELETE FROM indicator_sectors WHERE indicator_sector_id = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_backup_deleted_mapping that, before deleting a row from the indicator_sectors table, inserts a backup copy into the same table by setting the indicator_sector_id to the original value plus 20000, copying the indicator_id, sector_id, weight, and start_year from the deleted row, and setting the end_year to 1999.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named trg_backup_deleted_mapping that runs before each row is deleted from the indicator_sectors table, and for every row being removed, it creates a backup copy in the same table by taking the original indicator_sector_id and adding 20000 to it, then copying the indicator_id, sector_id, weight, and start_year exactly, while setting the end_year to a fixed value of 1999.",
    "id": 75,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function backup_deleted_mapping that inserts a row into the indicator_sectors table using values from the OLD record, specifically setting indicator_sector_id to OLD.indicator_sector_id + 20000, indicator_id to OLD.indicator_id, sector_id to OLD.sector_id, weight to OLD.weight, start_year to OLD.start_year, and end_year to the fixed value 1999, and then returns OLD. Second, define the trigger trg_backup_deleted_mapping on table indicator_sectors that fires BEFORE DELETE for each row and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named backup_deleted_mapping that is executed automatically by a trigger named trg_backup_deleted_mapping before any delete operation on the indicator_sectors table for each individual row being deleted, where the function performs a single insert operation into the same indicator_sectors table, using the values from the old row (represented by the OLD record variable) that is about to be deleted, specifically inserting a new row with the indicator_sector_id column value set to the old indicator_sector_id value plus 20000, the indicator_id column set to the old indicator_id value, the sector_id column set to the old sector_id value, the weight column set to the old weight value, the start_year column set to the old start_year value, and the end_year column set to the fixed value 1999, thereby creating a backup copy of the deleted record with a modified primary key and an updated end date before the original row is removed, and the function concludes by returning the OLD record to allow the triggering delete operation to proceed.",
    "original_summary": "Create a BEFORE DELETE trigger on indicator_sectors. For each row to be deleted, insert a backup copy into the same table. The backup's indicator_sector_id is old_id + 20000. Copy indicator_id, sector_id, and weight. Copy start_year. Set end_year to 1999.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so we need a trigger that kicks in right before something gets zapped from the indicator_sectors table. For every row that's about to be deleted, we gotta stash a backup copy back into that same table. For the backup, take the old indicator_sector_id and just add 20000 to it. Then, copy over the indicator_id, sector_id, weight, and the start_year as-is. Oh, and for the end_year, just hardcode it to 1999."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function create_guide_on_category_insert that inserts a new row into the size_guides table using values from the NEW record, specifically setting guide_id to NEW.size_id + 1000, size_id to NEW.size_id, guide_description to the concatenation of 'Auto-generated guide for ' and NEW.general_size, fit_type to 'Standard', fit_description to 'Default fit guide created automatically', and both created_at and updated_at to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS' using TO_CHAR(NOW()). Second, define the trigger trg_create_guide_on_category on table size_categories that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION create_guide_on_category_insert() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO size_guides (guide_id, size_id, guide_description, fit_type, fit_description, created_at, updated_at) VALUES (NEW.size_id + 1000, NEW.size_id, 'Auto-generated guide for ' || NEW.general_size, 'Standard', 'Default fit guide created automatically', TO_CHAR(NOW(), 'YYYY-MM-DD HH24:MI:SS'), TO_CHAR(NOW(), 'YYYY-MM-DD HH24:MI:SS'));\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_create_guide_on_category\n    AFTER INSERT ON size_categories\n    FOR EACH ROW\n    EXECUTE FUNCTION create_guide_on_category_insert();",
    "database_name": "apparel_sizing_and_measurement_standards_965455",
    "tables": [
      "measurements",
      "size_categories",
      "size_guides"
    ],
    "call_sqls": [
      "INSERT INTO size_categories (size_id, general_size, us_size, eu_size, uk_size, category_type, category_description, created_at, updated_at) VALUES (2, 'Medium', '8 - 10', '40 - 42', '12 - 14', 'Women', 'Standard fit for most body types.', '2023-01-03 00:00:00', '2023-01-03 00:00:00');",
      "INSERT INTO size_categories (size_id, general_size, us_size, eu_size, uk_size, category_type, category_description, created_at, updated_at) VALUES (3, 'Large', '12 - 14', '44 - 46', '16 - 18', 'Women', 'Comfortable fit for larger frames.', '2023-01-04 00:00:00', '2023-01-04 00:00:00');",
      "INSERT INTO size_categories (size_id, general_size, us_size, eu_size, uk_size, category_type, category_description, created_at, updated_at) VALUES (4, 'X-Large', '16 - 18', '48 - 50', '20 - 22', 'Women', 'Relaxed fit for extra comfort.', '2023-01-05 00:00:00', '2023-01-05 00:00:00');",
      "INSERT INTO size_categories (size_id, general_size, us_size, eu_size, uk_size, category_type, category_description, created_at, updated_at) VALUES (5, 'Small', '36 - 38', '46 - 48', '36 - 38', 'Men', 'Slim fit for men.', '2023-01-06 00:00:00', '2023-01-06 00:00:00');",
      "INSERT INTO size_categories (size_id, general_size, us_size, eu_size, uk_size, category_type, category_description, created_at, updated_at) VALUES (6, 'Medium', '40 - 42', '50 - 52', '40 - 42', 'Men', 'Regular fit for men.', '2023-01-07 00:00:00', '2023-01-07 00:00:00');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named create_guide_on_category_insert that executes AFTER INSERT on the size_categories table, and for each new row, automatically inserts a corresponding record into the size_guides table, setting guide_id to NEW.size_id plus 1000, size_id to NEW.size_id, guide_description to 'Auto-generated guide for ' concatenated with NEW.general_size, fit_type to 'Standard', fit_description to 'Default fit guide created automatically', and both created_at and updated_at to the current timestamp in 'YYYY-MM-DD HH24:MI:SS' format.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_create_guide_on_category_insert that, after a new row is inserted into the size_categories table, automatically creates a corresponding record in the size_guides table. For each new size_categories entry, insert into size_guides with guide_id set to the new size_id plus 1000, size_id as the new size_id, guide_description as 'Auto-generated guide for ' combined with the new general_size, fit_type as 'Standard', fit_description as 'Default fit guide created automatically', and both created_at and updated_at as the current timestamp. Return the new row.",
    "id": 76,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named create_guide_on_category_insert, which is executed by a trigger named trg_create_guide_on_category_insert. This trigger is defined to fire after an insert operation on the size_categories table for each row inserted. The function returns the NEW row data after performing an insert operation into the size_guides table.\n\nThe function declares no explicit variables, as all operations use direct column references and built-in functions. It performs a single SQL operation: an INSERT into the size_guides table. The columns inserted are guide_id, size_id, guide_description, fit_type, fit_description, created_at, and updated_at. The values are derived from the NEW row of the size_categories table and fixed constants. Specifically, guide_id is calculated by adding 1000 to the NEW.size_id from the inserted size_categories row. size_id is set directly to NEW.size_id. guide_description is constructed by concatenating the string 'Auto-generated guide for ' with the NEW.general_size value from the inserted row. fit_type is set to the constant string 'Standard'. fit_description is set to the constant string 'Default fit guide created automatically'. Both created_at and updated_at are set to the current timestamp using the CURRENT_TIMESTAMP function.\n\nThe function includes no conditional logic or control flow; it executes the INSERT unconditionally for every new row in size_categories. After the INSERT, the function returns the NEW row from the size_categories table, which is the row that was just inserted, to satisfy the trigger requirement. The trigger is configured as an AFTER INSERT trigger on the size_categories table, firing for each row, and it calls the create_guide_on_category_insert function. This ensures that whenever a new record is added to size_categories, a corresponding auto-generated guide is created in the size_guides table with predefined values based on the new category data.",
    "original_ir": "Write a PostgreSQL trigger function named create_guide_on_category_insert that is executed automatically after every INSERT operation on the size_categories table for each new row, and within this function, perform an INSERT into the size_guides table using the following values: for the guide_id column, use the value of the NEW.size_id column from the triggering insert plus the integer 1000; for the size_id column, use the value of the NEW.size_id column directly; for the guide_description column, construct a string by concatenating the literal 'Auto-generated guide for ' with the value from the NEW.general_size column; for the fit_type column, use the literal string 'Standard'; for the fit_description column, use the literal string 'Default fit guide created automatically'; for the created_at column, use the current timestamp formatted as a string in 'YYYY-MM-DD HH24:MI:SS' format via the TO_CHAR function called with NOW(); and for the updated_at column, use the identical formatted current timestamp string; after the insert, the function returns the NEW row record to the trigger.",
    "original_summary": "Create an AFTER INSERT trigger function named create_guide_on_category_insert for the size_categories table. For each new row, insert into size_guides: guide_id as NEW.size_id + 1000, size_id as NEW.size_id, guide_description as 'Auto-generated guide for ' || NEW.general_size, fit_type as 'Standard', fit_description as 'Default fit guide created automatically', and both created_at and updated_at as the current timestamp formatted 'YYYY-MM-DD HH24:MI:SS'. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create AFTER INSERT trigger create_guide_on_category_insert for size_categories. Insert into size_guides: guide_id as NEW.size_id + 1000, size_id as NEW.size_id, guide_description as 'Auto-generated guide for ' || NEW.general_size, fit_type as 'Standard', fit_description as 'Default fit guide created automatically', created_at and updated_at as current timestamp. Return NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_region_description` that updates the `description` column in the `regions` table by using `CONCAT` to append the string ' - Updated' to the existing description for the row where the `region_id` matches the `NEW.region_id` from the `neighborhoods` table.\nSecond, define the trigger `trg_update_region_description` on table `neighborhoods` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_region_description() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE regions\n  SET description = CONCAT(description, ' - Updated')\n  WHERE region_id = NEW.region_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_region_description\nAFTER INSERT ON neighborhoods\nFOR EACH ROW EXECUTE FUNCTION update_region_description();",
    "database_name": "crime_statistics_and_reporting_791805",
    "tables": [
      "crimes",
      "regions",
      "predictions",
      "neighborhoods"
    ],
    "call_sqls": [
      "INSERT INTO neighborhoods (neighborhood_id, region_id, neighborhood_name, description) VALUES (100, 1, 'Test Neighborhood 1', 'Initial description');",
      "INSERT INTO neighborhoods (neighborhood_id, region_id, neighborhood_name, description) VALUES (101, 2, 'Test Neighborhood 2', 'Another description');",
      "INSERT INTO neighborhoods (neighborhood_id, region_id, neighborhood_name, description) VALUES (102, 1, 'Test Neighborhood 3', 'Third description');",
      "INSERT INTO neighborhoods (neighborhood_id, region_id, neighborhood_name, description) VALUES (103, 3, 'Test Neighborhood 4', 'Fourth description');",
      "INSERT INTO neighborhoods (neighborhood_id, region_id, neighborhood_name, description) VALUES (104, 2, 'Test Neighborhood 5', 'Fifth description');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_region_description that fires after each row is inserted into the neighborhoods table, and for each insertion, updates the regions table by appending ' - Updated' to the description column for the row where region_id matches the new row's region_id, then returns the NEW record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_update_region_description that runs after each row is inserted into the neighborhoods table, updating the regions table by appending ' - Updated' to the description column for the row where region_id matches the new row's region_id, and returns the NEW record.",
    "id": 77,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_region_description` that updates the `description` column in the `regions` table by using `CONCAT` to append the string ' - Updated' to the existing description for the row where the `region_id` matches the `NEW.region_id` from the `neighborhoods` table.\nSecond, define the trigger `trg_update_region_description` on table `neighborhoods` that fires `AFTER` `INSERT` and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that, upon the insertion of a new row into the neighborhoods table, updates the description column in the regions table by appending the string ' - Updated' to the existing description for the row where the region_id matches the region_id of the newly inserted row in neighborhoods. The function is executed for each row inserted into the neighborhoods table, and it returns the newly inserted row.",
    "original_summary": "Create a trigger function that fires after each row insert into the `neighborhoods` table. The function updates the `regions` table by appending ' - Updated' to the `description` column for the row where `region_id` matches the new row's `region_id`. The function returns the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create a trigger function that executes after each row is inserted into the `neighborhoods` table. This function must update the `regions` table by appending ' - Updated' to the `description` column for the row whose `region_id` matches the new row's `region_id`. Ensure the function returns the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `deactivate_brand_on_product_deactivation` that updates the `brands` table, setting `is_active` to 0 for the `brand_id` of the updated product row (NEW.brand_id), but only if a subquery finds no other rows in the `products` table with the same `brand_id` and an `is_active` value of 1. The function must return the NEW row.\nSecond, define the trigger `trg_deactivate_brand` on table `products` that fires AFTER UPDATE OF the `is_active` column, for each row where OLD.is_active is 1 and NEW.is_active is 0, and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION deactivate_brand_on_product_deactivation() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE brands SET is_active = 0 WHERE brand_id = NEW.brand_id AND NOT EXISTS (\n    SELECT 1 FROM products WHERE brand_id = NEW.brand_id AND is_active = 1\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_deactivate_brand\nAFTER UPDATE OF is_active ON products\nFOR EACH ROW WHEN (OLD.is_active = 1 AND NEW.is_active = 0) EXECUTE FUNCTION deactivate_brand_on_product_deactivation();",
    "database_name": "fashion_size_conversion_and_measurement_tracking",
    "tables": [
      "brands",
      "order_items",
      "orders",
      "product_sizes",
      "products",
      "size_conversions",
      "size_measurements",
      "users"
    ],
    "call_sqls": [
      "UPDATE products SET is_active = 0 WHERE product_id = 0;",
      "UPDATE products SET is_active = 0 WHERE product_id = 1;",
      "UPDATE products SET is_active = 0 WHERE product_id = 0 AND brand_id = 0;",
      "UPDATE products SET is_active = 0 WHERE product_id = 1 AND brand_id = 0;",
      "UPDATE products SET is_active = 0 WHERE product_id = 0 AND category = 'tops';"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_deactivate_brand that fires AFTER UPDATE on the products table when the is_active column changes from 1 to 0, and updates the brands table by setting is_active to 0 for the brand associated with the deactivated product (using NEW.brand_id), but only if no other active products exist for that same brand in the products table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_deactivate_brand that fires AFTER UPDATE on the is_active column of the products table, specifically when is_active changes from 1 to 0, and updates the brands table by setting is_active to 0 for the brand linked to the deactivated product, but only after confirming that no other active products remain associated with that brand in the products table, then returns the NEW record.",
    "id": 78,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `deactivate_brand_on_product_deactivation`. This function is a trigger function that returns a trigger. It is designed to be executed after an update operation on the `products` table. The function implicitly receives the `NEW` and `OLD` record variables representing the row state after and before the update, respectively. The function's purpose is to conditionally deactivate a brand in the `brands` table when a product linked to that brand is deactivated, but only if no other active products remain for that brand.\n\nThe function begins by checking if the update operation is relevant. It uses an `IF` statement with the condition `OLD.is_active = 1 AND NEW.is_active = 0`. This condition evaluates to true only when the `is_active` column of the updated row in the `products` table changes from the value 1 (active) to 0 (inactive). If this condition is not met, the function skips the main logic and proceeds to return the `NEW` record.\n\nIf the condition is true, the function proceeds to check if the brand associated with the deactivated product has any other active products. It performs a `SELECT` statement with a `COUNT` aggregation. The query selects the count of rows from the `products` table where the `brand_id` equals `NEW.brand_id` (the brand ID of the recently deactivated product) and the `is_active` column equals 1. This count represents the number of other products that are still active for the same brand. The result of this count is stored into a local variable, for example, `active_product_count`.\n\nNext, the function uses another `IF` statement to check the value of `active_product_count`. The condition is `active_product_count = 0`. If this condition is true, it means the recently deactivated product was the last active product for its brand. In this case, the function executes an `UPDATE` statement on the `brands` table. The update sets the `is_active` column to 0 for the row where `brand_id` equals `NEW.brand_id`. This effectively deactivates the brand.\n\nAfter potentially performing the update on the `brands` table, or if the `active_product_count` was not zero, the function reaches its end. It executes a `RETURN NEW;` statement, which returns the `NEW` record (the updated row from the `products` table) to the trigger mechanism. This is standard for an `AFTER` trigger.\n\nSecond, define the trigger `trg_deactivate_brand` on the `products` table. This trigger is configured to execute `AFTER UPDATE` on the `products` table. The `FOR EACH ROW` clause specifies that the trigger function should be invoked once for every row that is updated. The trigger is further defined with a `WHEN` condition: `(OLD.is_active IS DISTINCT FROM NEW.is_active)`. This condition ensures the trigger only fires when the `is_active` column's value actually changes. The `EXECUTE FUNCTION deactivate_brand_on_product_deactivation()` clause binds the trigger to the function created in the first step.",
    "original_ir": "Write a PLpgSQL function that is triggered after an update operation on the is_active column of the products table, specifically when the old value of is_active was 1 and the new value is 0, indicating a deactivation of a product. The function, named deactivate_brand_on_product_deactivation, updates the brands table by setting the is_active column to 0 for the brand associated with the deactivated product. This update occurs only if there are no other active products associated with the same brand, as determined by a subquery that checks for the existence of any rows in the products table where the brand_id matches the brand_id of the deactivated product and the is_active column is 1. The function returns the modified row of the products table, represented by the NEW keyword, which contains the current state of the row after the update operation. The trigger, named trg_deactivate_brand, is defined to execute this function for each row affected by the update operation on the products table, ensuring that the brand's active status is updated accordingly whenever a product is deactivated.",
    "original_summary": "Create an AFTER UPDATE trigger on the products table that fires when is_active changes from 1 to 0. The trigger function should update the brands table, setting is_active to 0 for the brand associated with the deactivated product, but only if no other active products exist for that brand. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER UPDATE trigger on the products table, which should be activated specifically when the is_active column transitions from a value of 1 down to 0. The associated trigger function must then carefully update the brands table, setting its is_active flag to 0 for the particular brand that is linked to the recently deactivated product. However, this update should proceed only after verifying thoroughly that no other currently active products remain associated with that same brand. Finally, ensure the trigger returns the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_access_duration_on_report_update` that updates the `access_logs` table by setting the `duration` column to the absolute difference between the epoch value of `CURRENT_TIMESTAMP` and the row's `access_id` column, but only for rows where `user_id` matches a single `user_id` from the `users` table where the `email` contains the substring '@example.com' and where the `access_type` is exactly 'view'.\nSecond, define the trigger `trg_update_access_duration_on_report_update` on table `reports` that fires AFTER UPDATE of the `key_findings` column and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_access_duration_on_report_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE access_logs SET duration = ABS(EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) - access_id) WHERE user_id = (SELECT user_id FROM users WHERE email LIKE '%@example.com' LIMIT 1) AND access_type = 'view';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_access_duration_on_report_update\n    AFTER UPDATE OF key_findings ON reports\n    FOR EACH ROW\n    EXECUTE FUNCTION update_access_duration_on_report_update();",
    "database_name": "air_quality_monitoring_and_analysis_918261",
    "tables": [
      "access_logs",
      "users",
      "reports"
    ],
    "call_sqls": [
      "UPDATE reports SET key_findings = 'Updated finding 1' WHERE report_id = 0;",
      "UPDATE reports SET key_findings = 'Updated finding 2' WHERE report_id = 1;",
      "UPDATE reports SET key_findings = 'Another updated finding' WHERE report_name = 'Monthly Report - May 2023';",
      "UPDATE reports SET key_findings = 'Final update for Q2' WHERE report_type = 'quarterly';",
      "UPDATE reports SET key_findings = 'New key findings for report 0' WHERE report_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named update_access_duration_on_report_update that, after an update to the key_findings column on the reports table, updates the duration column in the access_logs table by setting it to the difference between the current Unix epoch timestamp and the row's access_id, but only for rows where the user has an email containing '@example.com' and the access_type is 'view'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_access_duration_on_report_update that, after an update to the key_findings column in the reports table, updates the duration column in the access_logs table by setting it to the absolute difference between the current Unix timestamp and the access_id, but only for rows where the associated user's email contains '@example.com' and the access_type is 'view', then returns the NEW row.",
    "id": 79,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_access_duration_on_report_update` that updates the `access_logs` table by setting the `duration` column to the absolute difference between the epoch value of `CURRENT_TIMESTAMP` and the row's `access_id` column, but only for rows where `user_id` matches a single `user_id` from the `users` table where the `email` contains the substring '@example.com' and where the `access_type` is exactly 'view'.\nSecond, define the trigger `trg_update_access_duration_on_report_update` on table `reports` that fires AFTER UPDATE of the `key_findings` column and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `update_access_duration_on_report_update` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, receiving special `NEW` and `OLD` records representing the new and old row versions, respectively, though only `NEW` is returned. The function performs a single `UPDATE` operation on the `access_logs` table. Specifically, it sets the `duration` column in `access_logs` to the absolute difference between the current timestamp (obtained using `CURRENT_TIMESTAMP` and then extracted as an epoch value in seconds using `EXTRACT(EPOCH FROM ...)`) and the value of the `access_id` column from the same `access_logs` row. This `UPDATE` operation is conditionally applied to rows in `access_logs` where two conditions are met: first, the `user_id` column in `access_logs` matches the `user_id` retrieved from the `users` table for a user whose `email` column contains the substring '@example.com' (case-sensitive, and `LIMIT 1` ensures only one such user_id is considered if multiple match the email pattern); and second, the `access_type` column in `access_logs` is exactly equal to the string literal 'view'. After executing this `UPDATE` statement, the function returns the `NEW` record, which is standard behavior for `BEFORE` or `AFTER` row-level triggers in PostgreSQL.\n\nAdditionally, a trigger named `trg_update_access_duration_on_report_update` is defined. This trigger is configured to execute `AFTER` an `UPDATE` operation on the `reports` table, specifically when the `key_findings` column of a row in `reports` is modified. It is a `FOR EACH ROW` trigger, meaning it will execute the associated function once for each row that is updated. The trigger `EXECUTE`s the previously described `update_access_duration_on_report_update()` function.",
    "original_summary": "Create an AFTER UPDATE trigger function named update_access_duration_on_report_update for the reports table when the key_findings column is updated. The function updates the duration column in the access_logs table. It sets duration to the difference between the current Unix epoch timestamp and the row's access_id. This update applies only to rows where the user has an email containing '@example.com' and the access_type is 'view'. The function returns the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER UPDATE trigger function, meticulously named update_access_duration_on_report_update, to be associated with the reports table specifically for instances when the key_findings column undergoes a modification. This comprehensive function is designed to subsequently refresh the duration column within the access_logs table. It achieves this by calculating and assigning the duration to the precise numerical difference obtained from subtracting the row's unique access_id from the current Unix epoch timestamp. Importantly, this targeted update is scoped to apply exclusively to those rows where the associated user's email address incorporates the domain '@example.com' and, concurrently, where the recorded access_type is explicitly designated as 'view'. Finally, the function gracefully concludes its operation by returning the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `adjust_team_metrics` that inserts a new record into the `teams` table using values from the `NEW` record of the `players` table, specifically setting `team_id` to `NEW.player_id + 2000`, `team_name` to `'Dynamic Team'`, `conference` to `'Virtual'`, `division` to `'Generated'`, `arena` to `'Virtual Arena'`, `city` to `'Virtual City'`, `state` to `'Virtual State'`, and `established` to `2000 + CAST(tan(NEW.experience) * 5 AS INTEGER)`, then returns `NULL`. Second, define the trigger `trg_adjust_team_metrics` on table `players` that fires `AFTER INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_team_metrics() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO teams (team_id, team_name, conference, division, arena, city, state, established) \n    VALUES (NEW.player_id + 2000, 'Dynamic Team', 'Virtual', 'Generated', 'Virtual Arena', 'Virtual City', 'Virtual State', 2000 + CAST(tan(NEW.experience) * 5 AS INTEGER));\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_adjust_team_metrics\n    AFTER INSERT ON players\n    FOR EACH ROW\n    EXECUTE FUNCTION adjust_team_metrics();",
    "database_name": "nba_team_statistics_and_performance_tracking",
    "tables": [
      "players",
      "teams",
      "games",
      "game_statistics",
      "injuries"
    ],
    "call_sqls": [
      "INSERT INTO players (player_id, player_name, team_id, position, height, weight, jersey_number, date_of_birth, experience, college) VALUES (100, 'Test Player 1', 1, 'guard', '6-2', '195', 5, '1995-05-15', 3, 'Test University');",
      "INSERT INTO players (player_id, player_name, team_id, position, height, weight, jersey_number, date_of_birth, experience, college) VALUES (101, 'Test Player 2', 2, 'forward', '6-8', '230', 21, '1998-08-22', 1, 'Another College');",
      "INSERT INTO players (player_id, player_name, team_id, position, height, weight, jersey_number, date_of_birth, experience, college) VALUES (102, 'Test Player 3', 3, 'center', '7-0', '250', 33, '1992-11-10', 8, 'State University');",
      "INSERT INTO players (player_id, player_name, team_id, position, height, weight, jersey_number, date_of_birth, experience, college) VALUES (103, 'Test Player 4', 1, 'guard', '6-4', '210', 8, '1990-03-30', 12, 'Old School U');",
      "INSERT INTO players (player_id, player_name, team_id, position, height, weight, jersey_number, date_of_birth, experience, college) VALUES (104, 'Test Player 5', 2, 'forward', '6-7', '225', 15, '1999-07-07', 0, 'Rookie College');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named adjust_team_metrics that fires AFTER INSERT on the players table, and for each new row, inserts a corresponding team into the teams table with the team_id set to the new player's player_id plus 2000, team_name as 'Dynamic Team', conference as 'Virtual', division as 'Generated', arena as 'Virtual Arena', city as 'Virtual City', state as 'Virtual State', and established year calculated as 2000 plus the integer result of multiplying the tangent of the new player's experience by 5.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named adjust_team_metrics that runs AFTER INSERT on the players table, and for each new player, insert a new record into the teams table with the team_id set to the new player's player_id plus 2000, the team_name as 'Dynamic Team', the conference as 'Virtual', the division as 'Generated', the arena as 'Virtual Arena', the city as 'Virtual City', the state as 'Virtual State', and the established year as 2000 plus the integer result of multiplying the tangent of the new player's experience by 5, making the function return NULL.",
    "id": 80,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named `adjust_team_metrics` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives the `NEW` record, which represents the newly inserted row in the `players` table. The function's purpose is to automatically insert a new record into the `teams` table whenever a new player is added to the `players` table.\n\nThe function begins by declaring a variable named `established_year` of type `bigint`. This variable will store the calculated value for the `established` column in the new `teams` record.\n\nThe function then performs a calculation to determine the `established` year. It uses the `NEW.experience` value from the newly inserted player record. The calculation involves computing the tangent of the `NEW.experience` value using the `TAN()` function. Since `NEW.experience` is an integer, it is implicitly cast to a numeric type for the trigonometric operation. The result of `TAN(NEW.experience)` is then multiplied by 5. The product is cast to an integer using the `::integer` operation. Finally, 2000 is added to this integer result, and the final value is assigned to the `established_year` variable.\n\nAfter the calculation, the function executes an `INSERT` operation into the `teams` table. The `INSERT` statement specifies values for the following columns:\n- `team_id`: set to the value of `NEW.player_id` (the player ID from the newly inserted player) plus 2000.\n- `team_name`: set to the literal string `'Dynamic Team'`.\n- `conference`: set to the literal string `'Virtual'`.\n- `division`: set to the literal string `'Generated'`.\n- `arena`: set to the literal string `'Virtual Arena'`.\n- `city`: set to the literal string `'Virtual City'`.\n- `state`: set to the literal string `'Virtual State'`.\n- `established`: set to the value of the `established_year` variable calculated earlier.\n\nThe function concludes by returning `NULL`, as specified for an `AFTER` trigger function.\n\nSecond, define a trigger named `adjust_team_metrics` on the `players` table. This trigger is configured to execute the `adjust_team_metrics()` function. The trigger is set to activate `AFTER` any `INSERT` operation on the `players` table. The `FOR EACH ROW` clause specifies that the trigger function will be executed once for each row that is inserted. The `EXECUTE FUNCTION adjust_team_metrics()` clause indicates that the `adjust_team_metrics` function is the specific function to be called when the trigger activates.",
    "original_ir": "Write a PL/pgSQL trigger function named `adjust_team_metrics` that is designed to be executed automatically after an `INSERT` operation on the `players` table. This function takes no explicit parameters but implicitly receives `NEW` and `OLD` records as part of the trigger context. The function's primary purpose is to insert a new record into the `teams` table. Specifically, it inserts a record with the following column values: the `team_id` is calculated by adding `2000` to the `player_id` of the newly inserted row in the `players` table (accessed via `NEW.player_id`); the `team_name` is set to the literal string `'Dynamic Team'`; the `conference` is set to the literal string `'Virtual'`; the `division` is set to the literal string `'Generated'`; the `arena` is set to the literal string `'Virtual Arena'`; the `city` is set to the literal string `'Virtual City'`; the `state` is set to the literal string `'Virtual State'`; and the `established` year is calculated by adding `2000` to the integer part of the result of multiplying the tangent of the `experience` value from the newly inserted `players` record (accessed via `NEW.experience`) by `5`. The `tan()` function calculates the tangent of the `NEW.experience` value, which is then multiplied by `5`, and the result is explicitly cast to an `INTEGER` before being added to `2000`. After performing this insertion, the function returns `NULL`, indicating that no modification to the row being inserted into the `players` table is intended. This `adjust_team_metrics` function is then associated with a trigger named `trg_adjust_team_metrics`. This trigger is configured to activate `AFTER INSERT` operations on the `players` table. It is set to execute `FOR EACH ROW`, meaning the `adjust_team_metrics` function will be invoked once for every row that is inserted into the `players` table. The trigger explicitly `EXECUTE FUNCTION adjust_team_metrics()`.",
    "original_summary": "Create an AFTER INSERT trigger function named adjust_team_metrics on the players table. Insert a new team into the teams table. Set team_id to NEW.player_id + 2000, team_name to 'Dynamic Team', conference to 'Virtual', division to 'Generated', arena to 'Virtual Arena', city to 'Virtual City', state to 'Virtual State', and established to 2000 + (TAN(NEW.experience) * 5)::INTEGER. Return NULL.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Create a trigger function named adjust_team_metrics that runs AFTER INSERT on the players table. This function should insert a new record into the teams table. Set the team_id to the NEW.player_id plus 2000, the team_name to 'Dynamic Team', the conference to 'Virtual', the division to 'Generated', the arena to 'Virtual Arena', the city to 'Virtual City', the state to 'Virtual State', and the established year to 2000 plus the integer result of TAN(NEW.experience) multiplied by 5. Make the function return NULL."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_shipment_arrival` that inserts a new row into the `inventory` table using values from the `NEW` record and a subquery. The inserted values are: `inventory_id` as `NEW.shipment_id * 1000`; `garment_id` from a subquery `SELECT garment_id FROM shipment_items WHERE shipment_id = NEW.shipment_id LIMIT 1`; `size_id` as 0; `warehouse_id` as `NEW.warehouse_id`; `store_id` as 0; `quantity` as 100; `reorder_level` as 20; and `reorder_quantity` as 50. The function must return `NEW`.\nSecond, define the trigger `trg_log_shipment_arrival` on table `shipments` that fires AFTER INSERT for each row and executes the function `log_shipment_arrival`.",
    "plsql": "CREATE OR REPLACE FUNCTION log_shipment_arrival() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO inventory (inventory_id, garment_id, size_id, warehouse_id, store_id, quantity, reorder_level, reorder_quantity) VALUES (NEW.shipment_id * 1000, (SELECT garment_id FROM shipment_items WHERE shipment_id = NEW.shipment_id LIMIT 1), 0, NEW.warehouse_id, 0, 100, 20, 50);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_shipment_arrival\n    AFTER INSERT ON shipments\n    FOR EACH ROW\n    EXECUTE FUNCTION log_shipment_arrival();",
    "database_name": "clothing_size_specifications_and_inventory_management_39101",
    "tables": [
      "garments",
      "clothing_sizes",
      "inventory",
      "warehouses",
      "shipments",
      "shipment_items"
    ],
    "call_sqls": [
      "INSERT INTO shipments (shipment_id, supplier_id, warehouse_id, shipment_date, expected_delivery_date) VALUES (100, 1, 0, '2023-06-01', '2023-06-05');",
      "INSERT INTO shipment_items (shipment_item_id, shipment_id, garment_id, quantity) VALUES (1000, 100, 0, 50);",
      "INSERT INTO shipments (shipment_id, supplier_id, warehouse_id, shipment_date, expected_delivery_date) VALUES (101, 2, 1, '2023-06-02', '2023-06-06');",
      "INSERT INTO shipment_items (shipment_item_id, shipment_id, garment_id, quantity) VALUES (1001, 101, 1, 75);",
      "INSERT INTO shipments (shipment_id, supplier_id, warehouse_id, shipment_date, expected_delivery_date) VALUES (102, 1, 0, '2023-06-03', '2023-06-07');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named log_shipment_arrival that executes after each new row is inserted into the shipments table, and for each new shipment, it adds a corresponding record to the inventory table by setting inventory_id to the shipment's shipment_id multiplied by 1000, garment_id to the first garment_id found in shipment_items for that shipment, size_id to 0, warehouse_id to the new shipment's warehouse_id, store_id to 0, quantity to 100, reorder_level to 20, and reorder_quantity to 50.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named log_shipment_arrival that, after each new row is inserted into the shipments table, automatically adds a corresponding record to the inventory table. For each new shipment, set the inventory_id to the shipment_id multiplied by 1000, obtain the garment_id from the first matching entry in the shipment_items table, assign the size_id as 0, use the warehouse_id from the new shipment, set store_id to 0, quantity to 100, reorder_level to 20, and reorder_quantity to 50, then return the new shipment record.",
    "id": 81,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `log_shipment_arrival` that returns a `TRIGGER` type. This function is designed to execute after each new row is inserted into the `shipments` table. The function declares a variable `v_garment_id` of type `bigint` to store the garment ID retrieved from the `shipment_items` table. The function's body performs the following operations: it queries the `shipment_items` table to find the first matching entry for the newly inserted shipment by selecting the `garment_id` where `shipment_id` equals `NEW.shipment_id`, ordering by `shipment_item_id` in ascending order, and limiting the result to one row. This retrieved `garment_id` is stored in the variable `v_garment_id`. Then, it inserts a new record into the `inventory` table with the following column values: `inventory_id` is set to `NEW.shipment_id` multiplied by 1000, `garment_id` is set to the value of `v_garment_id`, `size_id` is set to 0, `warehouse_id` is set to `NEW.warehouse_id`, `store_id` is set to 0, `quantity` is set to 100, `reorder_level` is set to 20, and `reorder_quantity` is set to 50. After the insertion, the function returns the `NEW` record from the `shipments` table. Second, define the trigger `log_shipment_arrival_trigger` on the `shipments` table. This trigger is configured to activate `AFTER INSERT` operations on the `shipments` table. It is a `FOR EACH ROW` trigger, meaning it will execute for every row that is inserted. The trigger executes the `log_shipment_arrival()` function, automatically adding a corresponding inventory record for each new shipment.",
    "original_ir": "Write a PL/pgSQL trigger function named `log_shipment_arrival` that is designed to be executed after an `INSERT` operation on the `shipments` table. This function does not accept any explicit input parameters but operates on the `NEW` record, which represents the newly inserted row in the `shipments` table. The function returns a `TRIGGER` type, indicating its role as a trigger function. The core operation of this function is to insert a new record into the `inventory` table. The `inventory_id` for this new record is calculated by multiplying the `shipment_id` from the `NEW` record (the newly inserted shipment) by 1000. The `garment_id` for the new inventory record is retrieved by performing a subquery: it selects the `garment_id` from the `shipment_items` table where the `shipment_id` matches the `shipment_id` of the `NEW` record, and it limits the result to one row. The `size_id` is set to a static value of 0. The `warehouse_id` is taken directly from the `warehouse_id` of the `NEW` record. The `store_id` is set to a static value of 0. The `quantity` is set to a static value of 100. The `reorder_level` is set to a static value of 20. The `reorder_quantity` is set to a static value of 50. After performing this insertion, the function returns the `NEW` record, which is standard behavior for `AFTER` row-level triggers in PostgreSQL.\n\nAccompanying this function is a trigger named `trg_log_shipment_arrival`. This trigger is defined to activate `AFTER INSERT` operations on the `shipments` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is inserted into the `shipments` table. When activated, it executes the `log_shipment_arrival()` function.",
    "original_summary": "Create an AFTER INSERT trigger function named log_shipment_arrival on the shipments table. For each new shipment, insert a record into the inventory table. Set inventory_id to NEW.shipment_id * 1000, garment_id to the first matching garment_id from shipment_items, size_id to 0, warehouse_id to NEW.warehouse_id, store_id to 0, quantity to 100, reorder_level to 20, and reorder_quantity to 50. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER INSERT trigger function designated as 'log_shipment_arrival' for the shipments table. Upon the insertion of each new shipment, it is required to insert a corresponding record into the inventory table. The inventory_id shall be assigned the value of NEW.shipment_id multiplied by 1000. The garment_id should be derived from the first matching garment_id found in the shipment_items table. The size_id is to be set to 0, and the warehouse_id should be assigned the value from NEW.warehouse_id. Furthermore, set store_id to 0, quantity to 100, reorder_level to 20, and reorder_quantity to 50. The function must conclude by returning the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function validate_invitation_status_change that checks if OLD.status is 'accepted' and NEW.status is not 'accepted', and if so, sets NEW.status to OLD.status to prevent the change.\nSecond, define the trigger trigger_validate_invitation_status_change on table team_invitations that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_invitation_status_change() RETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.status = 'accepted' AND NEW.status != 'accepted' THEN\n    NEW.status := OLD.status;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_validate_invitation_status_change\nBEFORE UPDATE ON team_invitations\nFOR EACH ROW EXECUTE FUNCTION validate_invitation_status_change();",
    "database_name": "user_management_and_authorization_system",
    "tables": [
      "team_invitations",
      "team_members",
      "teams",
      "users"
    ],
    "call_sqls": [
      "UPDATE team_invitations SET status = 'pending' WHERE invitation_id = 0;",
      "UPDATE team_invitations SET status = 'accepted' WHERE invitation_id = 1;",
      "UPDATE team_invitations SET status = 'declined' WHERE invitation_id = 0 AND status = 'pending';",
      "UPDATE team_invitations SET status = 'pending' WHERE invitation_id = 1 AND status = 'accepted';",
      "UPDATE team_invitations SET status = 'accepted' WHERE invitation_id = 0 AND status = 'pending';"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trigger_validate_invitation_status_change that executes BEFORE UPDATE on the team_invitations table to prevent any changes to the status column once it is set to 'accepted'. If an update attempts to modify the status from 'accepted' to a different value, the trigger should revert the NEW.status back to the original OLD.status value, ensuring the status remains 'accepted'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trigger_validate_invitation_status_change that runs before updates on the team_invitations table to prevent the status from being changed once it has been accepted. If the old status was 'accepted' and the new status is different, keep the new status the same as the old accepted status, then return the updated record.",
    "id": 82,
    "generated_ir": "Write a PostgreSQL PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named `validate_invitation_status_change`. This function is designed to be executed before an `UPDATE` operation on the `team_invitations` table. The function does not accept any explicit parameters but operates on the implicit `OLD` and `NEW` records, where `OLD` represents the row before the update and `NEW` represents the row after the update. The function's primary purpose is to enforce a business rule that prevents the `status` column from being changed once it has been set to 'accepted'. The function's logic is as follows: it checks if the `OLD.status` value is exactly equal to the string literal 'accepted'. If this condition is true, it then checks if the `NEW.status` value is different from the `OLD.status` value. If both conditions are met, meaning the old status was 'accepted' and the new status is attempting to change to a different value, the function intervenes by setting the `NEW.status` column to be equal to the `OLD.status` value, thereby preserving the 'accepted' status and preventing the change. This modification is performed directly on the `NEW` record. After this conditional logic, the function returns the `NEW` record, which may have been altered. If the old status was not 'accepted', or if the new status is the same as the old status, the function returns the `NEW` record unchanged.\n\nSecond, define a trigger named `trigger_validate_invitation_status_change` on the `team_invitations` table. This trigger is configured to fire `BEFORE UPDATE` on the `team_invitations` table. It is a `FOR EACH ROW` trigger, meaning the `validate_invitation_status_change` function will be executed once for each row that is being updated in the `team_invitations` table. The trigger explicitly `EXECUTE FUNCTION validate_invitation_status_change()`.",
    "original_ir": "Write a PostgreSQL trigger function named validate_invitation_status_change that returns a trigger and is executed automatically by a trigger named trigger_validate_invitation_status_change, which is defined to fire BEFORE any UPDATE operation on the team_invitations table for each individual row being modified. The function accesses the OLD and NEW pseudo-records representing the row's state before and after the update. It specifically checks a condition on the status column: if the OLD.status value is exactly equal to the string literal 'accepted' and the NEW.status value is not equal to the string literal 'accepted', then the function performs an assignment operation, setting the NEW.status value to be equal to the OLD.status value, thereby preventing the status from being changed away from 'accepted'. If the condition is not met, no assignment occurs. The function concludes by returning the potentially modified NEW record, which will be used for the actual UPDATE operation on the team_invitations table.",
    "original_summary": "Create a BEFORE UPDATE trigger function on team_invitations that prevents changing the status from 'accepted'. If OLD.status is 'accepted' and NEW.status is different, set NEW.status back to OLD.status. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger that runs before updates on the team_invitations table. It should basically stop the status from being changed once it's been accepted. So, if the old status was 'accepted' and someone tries to put in a different new status, just make the new status the same as the old one. Then, just return the new record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `handle_warehouse_deletion` that updates the `shipments` table by setting `warehouse_id` to NULL where it matches the OLD record's `warehouse_id` and then deletes rows from the `inventory` table where `warehouse_id` matches the OLD record's `warehouse_id`, finally returning OLD.\nSecond, define the trigger `trg_handle_warehouse_deletion` on table `warehouses` that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION handle_warehouse_deletion() RETURNS TRIGGER AS $$\nBEGIN\n    -- Update shipments to set warehouse_id to NULL or a default value before deleting the warehouse\n    UPDATE shipments SET warehouse_id = NULL WHERE warehouse_id = OLD.warehouse_id;\n\n    -- Delete inventory records related to the warehouse\n    DELETE FROM inventory WHERE warehouse_id = OLD.warehouse_id;\n\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_handle_warehouse_deletion\n    BEFORE DELETE ON warehouses\n    FOR EACH ROW\n    EXECUTE FUNCTION handle_warehouse_deletion();",
    "database_name": "clothing_size_specifications_and_inventory_management_39101",
    "tables": [
      "garments",
      "clothing_sizes",
      "inventory",
      "warehouses",
      "shipments",
      "shipment_items"
    ],
    "call_sqls": [
      "DELETE FROM warehouses WHERE warehouse_id = 1;",
      "DELETE FROM warehouses WHERE warehouse_name = 'Secondary Warehouse';",
      "DELETE FROM warehouses WHERE location LIKE '%Townville%';",
      "DELETE FROM warehouses WHERE warehouse_id IN (0, 2);",
      "DELETE FROM warehouses WHERE capacity < 6000;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named handle_warehouse_deletion that executes BEFORE DELETE on the warehouses table, and for each warehouse being deleted, sets the warehouse_id to NULL in all related records in the shipments table and removes all associated records from the inventory table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called handle_warehouse_deletion that runs before a row is deleted from the warehouses table, ensuring that for each deleted warehouse, all related shipments have their warehouse_id set to NULL and all inventory records linked to that warehouse_id are removed, then returns the OLD record.",
    "id": 83,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named handle_warehouse_deletion that is automatically executed before each row deletion from the warehouses table. The function performs the following operations: it updates the shipments table by setting the warehouse_id column to NULL for all rows where the warehouse_id matches the warehouse_id value from the OLD row (the row being deleted). Then, it deletes all rows from the inventory table where the warehouse_id matches the warehouse_id value from the OLD row. After these operations, the function returns the OLD row to allow the original delete operation to proceed. Second, define the trigger trg_handle_warehouse_deletion on the warehouses table to fire before each row deletion, executing the handle_warehouse_deletion function.",
    "original_ir": "Write a PL/pgSQL trigger function named `handle_warehouse_deletion` that is designed to be executed before a row is deleted from the `warehouses` table. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to the `OLD` record, which represents the row being deleted from the `warehouses` table. The primary purpose of this function is to maintain data integrity and consistency across related tables when a warehouse record is removed. Specifically, it performs two main operations: First, it updates records in the `shipments` table. For every row in the `shipments` table where the `warehouse_id` column matches the `warehouse_id` of the `OLD` record (the warehouse being deleted), it sets the `warehouse_id` column to `NULL`. This effectively disassociates shipments from the warehouse that is about to be deleted, preventing foreign key constraint violations if `warehouse_id` in `shipments` is a foreign key referencing `warehouses`. Second, it deletes records from the `inventory` table. It removes all rows from the `inventory` table where the `warehouse_id` column matches the `warehouse_id` of the `OLD` record. This ensures that all inventory items associated with the deleted warehouse are also removed, maintaining data consistency. After performing these operations, the function returns the `OLD` record, which is standard behavior for `BEFORE` triggers in PostgreSQL, allowing the original `DELETE` operation on the `warehouses` table to proceed. This trigger function is then associated with a trigger named `trg_handle_warehouse_deletion`. This trigger is configured to activate `BEFORE DELETE` operations on the `warehouses` table. It is set to execute `FOR EACH ROW`, meaning the `handle_warehouse_deletion` function will be invoked once for every row that is targeted for deletion from the `warehouses` table. The trigger executes the `handle_warehouse_deletion()` function.",
    "original_summary": "Create a BEFORE DELETE trigger function named handle_warehouse_deletion on the warehouses table. For each warehouse being deleted, update all shipments with that warehouse_id to NULL, then delete all inventory records with that warehouse_id. Return OLD.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Define a BEFORE DELETE trigger function called handle_warehouse_deletion for the warehouses table. For each deleted warehouse, first set the warehouse_id to NULL in all related shipments, then remove all inventory records linked to that warehouse_id. Ensure the function returns OLD."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_user_activity` that deletes all rows from the `user_activity` table where its `user_id` column matches the `user_id` from the `OLD` row and then returns `OLD`.\nSecond, define the trigger `delete_activity_trigger` on table `user_status` that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_user_activity() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM user_activity WHERE user_id = OLD.user_id;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_activity_trigger\nAFTER DELETE ON user_status\nFOR EACH ROW EXECUTE FUNCTION delete_user_activity();",
    "database_name": "user_activity_and_status_tracking",
    "tables": [
      "server_info",
      "user_activity",
      "user_server_sync",
      "user_status"
    ],
    "call_sqls": [
      "DELETE FROM user_status WHERE user_id = '@spyglass:localhost:8800';",
      "DELETE FROM user_status WHERE status_type = 'busy';",
      "DELETE FROM user_status WHERE user_id LIKE '%anon%';",
      "DELETE FROM user_status WHERE status_id = 1;",
      "DELETE FROM user_status WHERE created_at < '1570040280000';"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named delete_activity_trigger that executes after a row is deleted from the user_status table, and for each deleted row, it removes all corresponding records from the user_activity table where the user_id matches the deleted user's user_id, then returns the deleted row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called delete_activity_trigger that, after a row is deleted from the user_status table, removes all matching entries from the user_activity table where the user_id equals the user_id of the deleted row, and returns the deleted row.",
    "id": 84,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_user_activity` that deletes all rows from the `user_activity` table where its `user_id` column matches the `user_id` from the `OLD` row and then returns `OLD`.\nSecond, define the trigger `delete_activity_trigger` on table `user_status` that fires AFTER DELETE and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `delete_user_activity` that is designed to be executed as a trigger. This function does not accept any explicit parameters in its signature, as trigger functions implicitly receive special variables like `OLD` and `NEW` representing the row data. The function's purpose is to delete records from the `user_activity` table. Specifically, it performs a `DELETE` operation on the `user_activity` table, removing all rows where the value in the `user_id` column of the `user_activity` table matches the value of the `user_id` column from the `OLD` row. The `OLD` row refers to the state of the row in the `user_status` table *before* the triggering `DELETE` event occurred. After performing the deletion, the function returns the `OLD` row, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL.\n\nFollowing this, a trigger named `delete_activity_trigger` is created. This trigger is configured to activate `AFTER DELETE` operations on the `user_status` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is deleted from the `user_status` table. When activated, this trigger executes the previously defined `delete_user_activity()` function. Therefore, whenever a row is deleted from the `user_status` table, the `delete_user_activity` function will be invoked, and it will delete corresponding records from the `user_activity` table based on the `user_id` of the row that was just deleted from `user_status`.",
    "original_summary": "Create an AFTER DELETE trigger function on user_status table. For each deleted row, delete all records from user_activity table where user_id matches the OLD user_id. Return the OLD row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct an AFTER DELETE trigger function for the user_status table, which, upon the deletion of any row, meticulously identifies and removes all corresponding entries within the user_activity table where the user_id precisely matches the OLD user_id value from the deleted record, ultimately returning the OLD row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_delete_sensor_log` that, before a DELETE on the `sensors` table, performs a DELETE from the `data_imports` table where the `import_data` column contains the substring 'Sensor ' concatenated with the `OLD.sensor_id`.\nSecond, define the trigger `delete_sensor_log_trigger` on table `sensors` that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_sensor_log() RETURNS TRIGGER AS $$\nBEGIN\nDELETE FROM data_imports WHERE import_data LIKE '%Sensor ' || OLD.sensor_id || '%';\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_sensor_log_trigger\nBEFORE DELETE ON sensors\nFOR EACH ROW EXECUTE FUNCTION trg_delete_sensor_log();",
    "database_name": "weather_monitoring_and_forecasting_868568",
    "tables": [
      "weather_stations",
      "sensors",
      "air_temperature_measurements",
      "solar_radiation_measurements",
      "wind_speed_measurements",
      "weather_forecasts",
      "data_imports"
    ],
    "call_sqls": [
      "DELETE FROM sensors WHERE sensor_id = 0;",
      "DELETE FROM sensors WHERE sensor_id = 1;",
      "DELETE FROM sensors WHERE sensor_id = 2;",
      "DELETE FROM sensors WHERE sensor_id = 3;",
      "DELETE FROM sensors WHERE sensor_id = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named delete_sensor_log_trigger that executes BEFORE DELETE on the sensors table, and for each deleted row, removes all rows from the data_imports table where the import_data column contains the text 'Sensor ' followed by the sensor_id value from the deleted row, then returns the deleted row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named delete_sensor_log_trigger that, before deleting a row from the sensors table, removes any rows in the data_imports table where the import_data field contains the text 'Sensor ' followed by the ID of the sensor being deleted, and then returns the sensor row to proceed with the deletion.",
    "id": 85,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named `trg_delete_sensor_log` that is designed to be executed `BEFORE DELETE` operations on the `sensors` table. This function operates `FOR EACH ROW` that is about to be deleted. The function does not declare any local variables.\n\nUpon execution for a specific row (referred to as `OLD` within the trigger context, representing the sensor row to be deleted), the function performs a `DELETE` operation on the `data_imports` table. It removes all rows from `data_imports` where the `import_data` column contains the exact string literal 'Sensor ' (including the space) concatenated with the `sensor_id` value from the `OLD` row (i.e., `OLD.sensor_id`). This concatenation forms a search pattern like 'Sensor X', where X is the ID of the sensor being deleted. The function uses the `LIKE` operator with the pattern `'%Sensor ' || OLD.sensor_id || '%'` to match any `import_data` that contains this substring anywhere within its text.\n\nAfter performing this deletion from `data_imports`, the function returns the `OLD` row, indicating that the trigger has completed its pre-deletion logic and the original delete operation on the `sensors` table should proceed.\n\nSecond, define the trigger `delete_sensor_log_trigger` on the `sensors` table. It is a `BEFORE DELETE` trigger, meaning it fires before the `DELETE` statement removes a row from the `sensors` table. The `FOR EACH ROW` clause ensures that the `trg_delete_sensor_log` function is executed individually for every row in the `sensors` table that is targeted for deletion.",
    "original_ir": "Write a PLpgSQL trigger function that is invoked before a row is deleted from the sensors table, specifically targeting the row that is about to be deleted. The function, named trg_delete_sensor_log, does not take any parameters directly but operates on the OLD record, which represents the row being deleted. Within the function, a DELETE operation is performed on the data_imports table, removing any rows where the import_data column contains a substring matching 'Sensor ' concatenated with the sensor_id from the OLD record. This concatenation operation constructs a search pattern using the OLD.sensor_id, which is a column in the sensors table, to identify relevant entries in the data_imports table. The function returns the OLD record, which is standard practice for trigger functions that operate before a DELETE operation. The trigger, named delete_sensor_log_trigger, is defined to execute this function for each row that is deleted from the sensors table, ensuring that the corresponding entries in the data_imports table are removed whenever a sensor is deleted.",
    "original_summary": "Create a BEFORE DELETE trigger function for the sensors table. For each row being deleted, delete all rows from the data_imports table where the import_data column contains the string 'Sensor ' concatenated with the OLD.sensor_id. Return the OLD row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so I need a trigger that kicks in right before we delete a sensor. For each sensor we're about to ditch, we gotta also clean out any rows in the data_imports table where the import_data field has the text 'Sensor ' followed by that sensor's ID. Oh, and at the end, just hand back the sensor row we're deleting."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `track_login_activity` that inserts a row into the `access_logs` table. The `access_id` is derived by selecting `COALESCE(MAX(access_id), 0) + 1` from the `access_logs` table. The other column values are: `data_id` as 1, `user_id` as `NEW.user_id`, `access_date` as `CURRENT_DATE::text`, `access_type` as 'system_login', `ip_address` as '0.0.0.0', `user_agent` as 'Trigger', and `duration` as 1. The function must return `NEW`.\nSecond, define the trigger `trg_track_login_activity` on table `users` that fires `AFTER UPDATE` for each row when `(NEW.last_login_date IS DISTINCT FROM OLD.last_login_date)` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION track_login_activity() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO access_logs (access_id, data_id, user_id, access_date, access_type, ip_address, user_agent, duration)\n    SELECT\n        COALESCE(MAX(access_id), 0) + 1,\n        1,\n        NEW.user_id,\n        CURRENT_DATE::text, -- Corrected to store current date as text in 'YYYY-MM-DD' format\n        'system_login',\n        '0.0.0.0',\n        'Trigger',\n        1\n    FROM access_logs;\n    RETURN NEW; -- Added the required RETURN statement for a trigger function\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_track_login_activity\nAFTER UPDATE ON users\nFOR EACH ROW\nWHEN (NEW.last_login_date IS DISTINCT FROM OLD.last_login_date) -- Using IS DISTINCT FROM for NULL-safe comparison\nEXECUTE FUNCTION track_login_activity();",
    "database_name": "weather_data_collection_and_analysis_535790",
    "tables": [
      "access_logs",
      "users"
    ],
    "call_sqls": [
      "UPDATE users SET last_login_date = '2023-10-01' WHERE user_id = 0;",
      "UPDATE users SET last_login_date = '2023-10-02' WHERE user_id = 1;",
      "UPDATE users SET last_login_date = '2023-10-03' WHERE user_id = 0;",
      "UPDATE users SET last_login_date = '2023-10-04' WHERE user_id = 1;",
      "UPDATE users SET last_login_date = '2023-10-05' WHERE user_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_track_login_activity that fires AFTER UPDATE on the users table for each row only when the last_login_date changes, to insert a new record into the access_logs table with an access_id set to the next sequential number, user_id set to the updated user's user_id, access_date set to the current date, access_type set to 'system_login', ip_address set to '0.0.0.0', user_agent set to 'Trigger', data_id set to 1, and duration set to 1.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named track_login_activity that, after updating the users table when the last_login_date field changes, inserts a new row into the access_logs table with an access_id set to the next sequential number, user_id from the updated record, access_date as the current date, access_type as 'system_login', ip_address as '0.0.0.0', user_agent as 'Trigger', and data_id and duration both as 1, then returns the NEW record.",
    "id": 86,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named track_login_activity that is designed to be executed as a trigger function. This function does not take any parameters directly but operates on the implicit OLD and NEW records provided by the trigger context. The function is intended to run after an update operation on the users table for each row that is updated. The function first checks if the last_login_date column in the NEW record is different from the last_login_date column in the OLD record, indicating that the last_login_date field has changed. If the condition is true, the function performs an INSERT operation into the access_logs table. For the insertion, the function sets the access_id column to the next sequential number by using a subquery that selects the maximum existing access_id value from the access_logs table and adds 1 to it, handling the case where the table is empty by defaulting to 1. The user_id column is set to the user_id value from the NEW record of the users table. The access_date column is set to the current date in text format by calling the current_date function and casting it to text. The access_type column is set to the literal string 'system_login'. The ip_address column is set to the literal string '0.0.0.0'. The user_agent column is set to the literal string 'Trigger'. The data_id column is set to the integer value 1. The duration column is set to the integer value 1. After performing the insert, the function returns the NEW record to allow the triggering update operation on the users table to proceed. Second, define the trigger named tr_track_login_activity on the users table, specifying that it should execute after an update operation for each row, and call the track_login_activity function.",
    "original_ir": "Write a PostgreSQL trigger function named track_login_activity that is executed by a trigger named trg_track_login_activity, which is defined to fire after an update operation on the users table for each individual row, but only when the condition specified in the trigger's WHEN clause is met, specifically when the NEW.last_login_date value is different from the OLD.last_login_date value, using the IS DISTINCT FROM operator to ensure a proper comparison that accounts for potential NULL values in either the old or new state of the column. The function's body performs a single INSERT operation into the access_logs table, populating the columns access_id, data_id, user_id, access_date, access_type, ip_address, user_agent, and duration. The value for the access_id column is derived from a subquery that selects from the access_logs table, calculating the new ID as the result of the COALESCE function applied to the maximum existing access_id value, returning 0 if the maximum is NULL, and then adding 1 to that result. The data_id column is hardcoded to the integer value 1. The user_id column is populated with the NEW.user_id value from the triggering update on the users table. The access_date column is set to the result of casting the CURRENT_DATE to a text data type, which yields the date in the 'YYYY-MM-DD' format. The access_type column is assigned the string literal 'system_login'. The ip_address column is assigned the string literal '0.0.0.0'. The user_agent column is assigned the string literal 'Trigger'. The duration column is assigned the integer value 1. Finally, the trigger function returns the NEW row record to the calling trigger mechanism.",
    "original_summary": "Create an AFTER UPDATE row-level trigger function named track_login_activity that fires only when the last_login_date changes. Insert a new record into the access_logs table. The access_id should be the next sequential number. Set user_id to the NEW.user_id, access_date to the current date, access_type to 'system_login', ip_address to '0.0.0.0', user_agent to 'Trigger', data_id to 1, and duration to 1. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Alright, so I need a trigger that runs after an update, but only when the last_login_date field actually gets changed. Let's call this trigger function track_login_activity. When it fires, it should pop a new row into the access_logs table. For the access_id, just grab the next number in line. Stick the NEW.user_id into user_id, use right now for the access_date, and set access_type to 'system_login'. For ip_address, put '0.0.0.0', and for user_agent, just use 'Trigger'. Set data_id and duration both to 1. Finally, hand back the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `check_statement_date_age` that checks if the age of the `statement_date` from the `NEW` record, converted to a TIMESTAMP using `to_timestamp` with the format 'YYYY-MM-DD', is greater than an interval of '10 years'. If true, it updates the `status` column to 'archived' in the `financial_statements` table where the `statement_id` matches `NEW.statement_id`. The function must end by returning the `NEW` record.\nSecond, define the trigger `statement_date_age_trigger` on table `financial_statements` that fires AFTER UPDATE OF the `statement_date` column and executes the function `check_statement_date_age`.",
    "plsql": "CREATE OR REPLACE FUNCTION check_statement_date_age() RETURNS TRIGGER AS $$\nBEGIN\nIF age(to_timestamp(NEW.statement_date, 'YYYY-MM-DD')) > interval '10 years' THEN\nUPDATE financial_statements SET status = 'archived' WHERE statement_id = NEW.statement_id;\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER statement_date_age_trigger\nAFTER UPDATE OF statement_date ON financial_statements\nFOR EACH ROW EXECUTE FUNCTION check_statement_date_age();",
    "database_name": "financial_statement_analysis_and_reporting_660831",
    "tables": [
      "financial_statements",
      "balance_sheets",
      "income_statements",
      "cash_flow_statements"
    ],
    "call_sqls": [
      "UPDATE financial_statements SET statement_date = '2000-01-01' WHERE statement_id = 0;",
      "UPDATE financial_statements SET statement_date = '1995-06-15' WHERE statement_id = 1;",
      "UPDATE financial_statements SET statement_date = '2015-03-20' WHERE statement_id = 0;",
      "UPDATE financial_statements SET statement_date = '1990-11-01' WHERE statement_id = 1;",
      "UPDATE financial_statements SET statement_date = '2005-09-30' WHERE statement_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named statement_date_age_trigger that fires after an update to the statement_date column in the financial_statements table, and for each updated row, if the age of the NEW.statement_date exceeds 10 years, update the financial_statements table to set the status to 'archived' where the statement_id matches the NEW.statement_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called statement_date_age_trigger that runs after an update to the statement_date column in the financial_statements table. If the updated statement_date is older than 10 years, set the status to 'archived' for that financial_statements record and return the updated record.",
    "id": 87,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `check_statement_date_age` that checks if the age of the `statement_date` from the `NEW` record, converted to a TIMESTAMP using `to_timestamp` with the format 'YYYY-MM-DD', is greater than an interval of '10 years'. If true, it updates the `status` column to 'archived' in the `financial_statements` table where the `statement_id` matches `NEW.statement_id`. The function must end by returning the `NEW` record.\nSecond, define the trigger `statement_date_age_trigger` on table `financial_statements` that fires AFTER UPDATE OF the `statement_date` column and executes the function `check_statement_date_age`.",
    "original_ir": "Write a PL/pgSQL trigger function named `check_statement_date_age` that is designed to be executed in response to data manipulation language (DML) events on a specific table. This function takes no explicit input parameters but implicitly receives special record variables `NEW` and `OLD` from the triggering event, representing the new and old row values, respectively. The primary purpose of this function is to evaluate the age of a financial statement based on its `statement_date` and, if it exceeds a certain threshold, to update the `status` of that statement to 'archived'.\n\nThe function begins its execution by evaluating a conditional `IF` statement. The condition within this `IF` statement involves calculating the age of the `statement_date` from the `NEW` record. Specifically, it first converts the `statement_date` column from the `NEW` row (which is expected to be a `TEXT` or `VARCHAR` type representing a date in 'YYYY-MM-DD' format) into a `TIMESTAMP` data type using the `to_timestamp()` function with the format mask 'YYYY-MM-DD'. Subsequently, the `age()` function is applied to this converted `TIMESTAMP` value. The `age()` function calculates the difference between the current timestamp and the provided timestamp, returning an `INTERVAL` data type. This calculated `INTERVAL` is then compared against a fixed `INTERVAL` literal of '10 years'.\n\nIf the calculated age of the `NEW.statement_date` is strictly greater than '10 years', the `IF` condition evaluates to true, and the code block within the `IF` statement is executed. Inside this block, an `UPDATE` operation is performed on the `financial_statements` table. This `UPDATE` statement sets the `status` column of the affected row(s) to the string literal value 'archived'. The `WHERE` clause of this `UPDATE` statement specifies that only the row where the `statement_id` column matches the `statement_id` value from the `NEW` record (`NEW.statement_id`) should be updated.\n\nAfter the `IF` statement (regardless of whether the condition was true or false), the function concludes by returning the `NEW` record. This `NEW` record represents the row that was just updated or inserted, allowing the DML operation that triggered the function to proceed with the potentially modified row.\n\nA separate `CREATE TRIGGER` statement defines a trigger named `statement_date_age_trigger`. This trigger is configured to activate `AFTER UPDATE OF statement_date` on the `financial_statements` table. This means the trigger will fire immediately after an `UPDATE` statement successfully modifies the `statement_date` column of any row in the `financial_statements` table. The `FOR EACH ROW` clause specifies that the trigger function `check_statement_date_age()` should be executed once for each row that is affected by the `UPDATE` operation. The `EXECUTE FUNCTION check_statement_date_age()` clause specifies that the previously defined PL/pgSQL function `check_statement_date_age` is the routine to be executed when the trigger fires.",
    "original_summary": "Create a trigger function named check_statement_date_age that fires after updating the statement_date column in the financial_statements table. If the age of the NEW.statement_date exceeds 10 years, update the financial_statements table to set the status to 'archived' where statement_id matches NEW.statement_id. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger function called check_statement_date_age that runs after the statement_date in the financial_statements table gets changed. If the date from the update seems quite old, like it's been around for a good whileâ€”say, more than a decent number of yearsâ€”then mark those older records as 'archived' for the matching statement. Just give back the updated record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_team_manager that updates the teams table by setting its team_manager column to the NEW.agent_name value, specifically for the row where its team_id matches the NEW.team_id from the player_contracts table, and then returns the NEW row.\nSecond, define the trigger team_manager_update_trigger on table player_contracts that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_team_manager() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE teams SET team_manager = NEW.agent_name WHERE team_id = NEW.team_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER team_manager_update_trigger\nAFTER INSERT ON player_contracts\nFOR EACH ROW EXECUTE FUNCTION update_team_manager();",
    "database_name": "sports_data_analysis_and_visualization",
    "tables": [
      "games",
      "player_contracts",
      "player_games",
      "player_stats",
      "players",
      "teams"
    ],
    "call_sqls": [
      "INSERT INTO player_contracts (contract_id, player_id, team_id, contract_value, contract_length, contract_start_date, contract_end_date, contract_status, signing_bonus, weekly_salary, agent_name, agent_contact) VALUES (2, 1, 0, 600000.0, 3, '2022-01-01', '2025-01-01', 'active', 60000.0, 18000.0, 'John Doe', 'john.doe@example.com');",
      "INSERT INTO player_contracts (contract_id, player_id, team_id, contract_value, contract_length, contract_start_date, contract_end_date, contract_status, signing_bonus, weekly_salary, agent_name, agent_contact) VALUES (3, 0, 1, 750000.0, 4, '2023-01-01', '2027-01-01', 'active', 80000.0, 22000.0, 'Jane Smith', 'jane.smith@example.com');",
      "INSERT INTO player_contracts (contract_id, player_id, team_id, contract_value, contract_length, contract_start_date, contract_end_date, contract_status, signing_bonus, weekly_salary, agent_name, agent_contact) VALUES (4, 1, 1, 500000.0, 2, '2021-01-01', '2023-01-01', 'active', 55000.0, 17000.0, 'John Doe', 'john.doe@example.com');",
      "INSERT INTO player_contracts (contract_id, player_id, team_id, contract_value, contract_length, contract_start_date, contract_end_date, contract_status, signing_bonus, weekly_salary, agent_name, agent_contact) VALUES (5, 0, 0, 800000.0, 5, '2020-01-01', '2025-01-01', 'active', 90000.0, 25000.0, 'Jane Smith', 'jane.smith@example.com');",
      "INSERT INTO player_contracts (contract_id, player_id, team_id, contract_value, contract_length, contract_start_date, contract_end_date, contract_status, signing_bonus, weekly_salary, agent_name, agent_contact) VALUES (6, 1, 0, 700000.0, 3, '2023-01-01', '2026-01-01', 'active', 65000.0, 19000.0, 'John Doe', 'john.doe@example.com');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named team_manager_update_trigger that, after each new row is inserted into the player_contracts table, updates the team_manager column in the teams table to the new agent_name value for the matching team_id.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called team_manager_update_trigger that, after a new record is inserted into the player_contracts table, updates the team_manager column in the teams table to match the newly inserted agent_name, but only for the team where the team_id matches.",
    "id": 88,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_team_manager that updates the teams table by setting its team_manager column to the NEW.agent_name value, specifically for the row where its team_id matches the NEW.team_id from the player_contracts table, and then returns the NEW row.\nSecond, define the trigger team_manager_update_trigger on table player_contracts that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_team_manager that returns a trigger, which is then bound by a trigger named team_manager_update_trigger to fire after every insert operation on the player_contracts table for each new row, and within the function body, it executes an update statement on the teams table, specifically setting the team_manager column to the value of the NEW.agent_name from the inserted player_contracts row, but only for the row in the teams table where the team_id column matches the value of the NEW.team_id from the inserted player_contracts row, and finally the function returns the NEW row record.",
    "original_summary": "Create an AFTER INSERT trigger function on player_contracts that updates the team_manager column in teams to the new agent_name where team_id matches.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct an AFTER INSERT trigger function for the table named 'player_contracts'. The function's purpose is to modify the 'team_manager' column within the 'teams' table, setting its value to the newly inserted 'agent_name', but only for records where the 'team_id' values correspond."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_sync_user_permissions` that performs an INSERT into the `user_permissions` table. The INSERT should populate the `user_id` column with `NEW.user_id` from the `users` table, the `permission_id` column by selecting the `permission_id` from the `permissions` table where `permission_name` is exactly 'view_data', and the `granted_at` column with `NEW.created_at` from the `users` table. The function must then return `NEW`.\nSecond, define the trigger `sync_user_permissions_trigger` on table `users` that fires AFTER INSERT for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_sync_user_permissions() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO user_permissions (user_id, permission_id, granted_at) SELECT NEW.user_id, permission_id, NEW.created_at FROM permissions WHERE permission_name = 'view_data';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER sync_user_permissions_trigger\nAFTER INSERT ON users\nFOR EACH ROW EXECUTE FUNCTION trg_sync_user_permissions();",
    "database_name": "weather_data_collection_and_analysis_704531",
    "tables": [
      "users",
      "permissions",
      "user_permissions",
      "access_logs",
      "weather_data",
      "weather_stations",
      "weather_types",
      "data_formats"
    ],
    "call_sqls": [
      "INSERT INTO users (user_id, user_name, email, role, password_hash, last_login, created_at, updated_at, status) VALUES (2, 'Charlie Brown', 'charlie.brown@example.com', 'developer', 'hashed_password_3', '2023-10-03 10:00:00', '2023-05-03 12:00:00', '2023-10-03 12:00:00', 'active');",
      "INSERT INTO users (user_id, user_name, email, role, password_hash, last_login, created_at, updated_at, status) VALUES (3, 'Dana Scully', 'dana.scully@example.com', 'investigator', 'hashed_password_4', '2023-10-04 10:00:00', '2023-05-04 12:00:00', '2023-10-04 12:00:00', 'active');",
      "INSERT INTO users (user_id, user_name, email, role, password_hash, last_login, created_at, updated_at, status) VALUES (4, 'Fox Mulder', 'fox.mulder@example.com', 'agent', 'hashed_password_5', '2023-10-05 10:00:00', '2023-05-05 12:00:00', '2023-10-05 12:00:00', 'active');",
      "INSERT INTO users (user_id, user_name, email, role, password_hash, last_login, created_at, updated_at, status) VALUES (5, 'John Doe', 'john.doe@example.com', 'analyst', 'hashed_password_6', '2023-10-06 10:00:00', '2023-05-06 12:00:00', '2023-10-06 12:00:00', 'active');",
      "INSERT INTO users (user_id, user_name, email, role, password_hash, last_login, created_at, updated_at, status) VALUES (6, 'Jane Smith', 'jane.smith@example.com', 'manager', 'hashed_password_7', '2023-10-07 10:00:00', '2023-05-07 12:00:00', '2023-10-07 12:00:00', 'active');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named sync_user_permissions_trigger that fires AFTER INSERT on the users table, and for each new user, automatically grants the 'view_data' permission by inserting a record into the user_permissions table with the user's user_id, the corresponding permission_id from the permissions table where permission_name is 'view_data', and the granted_at timestamp set to the user's created_at.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called sync_user_permissions_trigger that runs after each new row is inserted into the users table, automatically creating a matching permission record. For every new user added, it inserts a row into the user_permissions table, setting the user_id to the new user's ID, the permission_id to the ID from the permissions table where the permission_name is exactly 'view_data', and the granted_at timestamp to the new user's created_at timestamp, then returns the new user record.",
    "id": 89,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named trg_sync_user_permissions that returns a trigger and is executed by a trigger named sync_user_permissions_trigger, which is defined to fire AFTER an INSERT operation on the users table for each individual row being inserted. The function performs an INSERT operation into the user_permissions table. For each new user inserted into the users table, the function retrieves the permission_id from the permissions table where the permission_name column value is exactly equal to the string 'view_data'. It then inserts a new row into the user_permissions table with three column values: the user_id is set to the user_id value from the NEW record (the newly inserted user row), the permission_id is set to the permission_id value retrieved from the permissions table, and the granted_at timestamp is set to the created_at timestamp value from the NEW user record. After this insertion, the function returns the NEW row, which represents the newly inserted user record.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_sync_user_permissions` that is designed to be executed in response to data manipulation events on a specific table, and a trigger named `sync_user_permissions_trigger` that invokes this function. The `trg_sync_user_permissions` function is a trigger function, meaning it is executed automatically by the database system when a defined event occurs on a table. It does not take explicit parameters in its signature but implicitly receives special variables like `NEW` and `OLD` which represent the new and old row data respectively, depending on the trigger event. In this specific context, since the trigger is defined `AFTER INSERT`, the `NEW` variable represents the row that has just been inserted into the `users` table. The function's primary operation is an `INSERT` statement into the `user_permissions` table. This `INSERT` statement populates three columns in the `user_permissions` table: `user_id`, `permission_id`, and `granted_at`. The values for these columns are derived from a `SELECT` subquery. Specifically, the `user_id` column in `user_permissions` is populated with the value from the `user_id` column of the `NEW` row (the newly inserted row in the `users` table). The `permission_id` column in `user_permissions` is populated with values from the `permission_id` column of the `permissions` table. The `granted_at` column in `user_permissions` is populated with the value from the `created_at` column of the `NEW` row (the newly inserted row in the `users` table). The `SELECT` subquery retrieves `permission_id` values from the `permissions` table, but only for rows where the `permission_name` column in the `permissions` table is exactly equal to the string literal `'view_data'`. After performing this `INSERT` operation, the function returns the `NEW` row. The `sync_user_permissions_trigger` is defined as an `AFTER INSERT` trigger on the `users` table. This means that the trigger will fire after a new row has been successfully inserted into the `users` table. It is a `FOR EACH ROW` trigger, which indicates that the `trg_sync_user_permissions` function will be executed once for every single row that is inserted into the `users` table. The trigger's action is to `EXECUTE FUNCTION trg_sync_user_permissions()`, which means it calls the previously described trigger function.",
    "original_summary": "Create an AFTER INSERT trigger function on users that automatically inserts a permission record. For each new user, insert into user_permissions (user_id, permission_id, granted_at) selecting NEW.user_id, permission_id from permissions where permission_name = 'view_data', and NEW.created_at as granted_at. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Construct a detailed AFTER INSERT trigger function designed specifically for the users table, which will meticulously and automatically handle the insertion of a corresponding permission record. For every single new user that is added, the function must proceed to insert a new row into the user_permissions table, carefully populating the user_id, permission_id, and granted_at columns. This is achieved by selecting the NEW.user_id, alongside the permission_id diligently fetched from the permissions table where the permission_name is precisely equal to 'view_data', while also using the NEW.created_at timestamp to serve as the value for the granted_at field. Finally, the function must conclusively return the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_log_employee_changes` that inserts a new record into the `audit_logs` table. For the `audit_id`, calculate it by adding 1 to the maximum existing `audit_id` from the `audit_logs` table, using `COALESCE` to default to 0 if the result is NULL. For `employee_id`, use `NEW.id`. For `changed_by`, use `NEW.user_id`. For `change_date`, `created_at`, and `updated_at`, use `CURRENT_TIMESTAMP::text`. For `change_description`, insert the static string 'Employee record modified'. The function must return `NEW`.\nSecond, define the trigger `log_employee_changes` on table `employees` that fires `AFTER` `UPDATE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_log_employee_changes() RETURNS TRIGGER AS $$\nBEGIN\nINSERT INTO audit_logs (audit_id, employee_id, changed_by, change_date, change_description, created_at, updated_at) \nVALUES (\n    COALESCE((SELECT MAX(audit_id) FROM audit_logs), 0) + 1, \n    NEW.id, \n    NEW.user_id, \n    CURRENT_TIMESTAMP::text, \n    'Employee record modified', \n    CURRENT_TIMESTAMP::text, \n    CURRENT_TIMESTAMP::text\n);\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_employee_changes\nAFTER UPDATE ON employees\nFOR EACH ROW EXECUTE FUNCTION trg_log_employee_changes();",
    "database_name": "human_resources_management_and_employee_skills_tracking",
    "tables": [
      "employees",
      "users",
      "audit_logs",
      "leave_requests",
      "payroll"
    ],
    "call_sqls": [
      "UPDATE employees SET first_name = 'Jonathan', updated_at = CURRENT_TIMESTAMP::text WHERE id = 0;",
      "UPDATE employees SET phone = '9876543210', address = '456 Oak Ave' WHERE id = 1;",
      "UPDATE employees SET job_title = 'Senior Software Engineer', department_id = 1 WHERE id = 0;",
      "UPDATE employees SET marital_status = 'Married', emergency_contact_name = 'John Doe' WHERE id = 1;",
      "UPDATE employees SET is_active = 0 WHERE id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `trg_log_employee_changes` that fires AFTER UPDATE on the `employees` table for each row, inserting a new record into the `audit_logs` table with a new `audit_id` generated by incrementing the maximum existing ID (starting from 1 if none exist), the employee's ID from `NEW.id`, the user who made the change from `NEW.user_id`, the current timestamp as text for `change_date`, a static description 'Employee record modified', and the current timestamp as text for both `created_at` and `updated_at`.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called log_employee_changes that runs after each update on the employees table, logging details into the audit_logs table by generating a new audit_id as the next number after the highest existing one, inserting the employee's id and user_id from the updated record, recording the current timestamp as change_date, using 'Employee record modified' as the change_description, and setting both created_at and updated_at to the current timestamp, ensuring the new record is returned.",
    "id": 90,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_log_employee_changes` that inserts a new record into the `audit_logs` table. For the `audit_id`, calculate it by adding 1 to the maximum existing `audit_id` from the `audit_logs` table, using `COALESCE` to default to 0 if the result is NULL. For `employee_id`, use `NEW.id`. For `changed_by`, use `NEW.user_id`. For `change_date`, `created_at`, and `updated_at`, use `CURRENT_TIMESTAMP::text`. For `change_description`, insert the static string 'Employee record modified'. The function must return `NEW`.\nSecond, define the trigger `log_employee_changes` on table `employees` that fires `AFTER` `UPDATE` and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_log_employee_changes` that is designed to be executed after an `UPDATE` operation on the `employees` table for each row affected. This function does not accept any explicit parameters but operates on implicit `NEW` and `OLD` records provided by the trigger mechanism. The function's primary purpose is to insert a new record into the `audit_logs` table to document changes made to an employee record. Specifically, it inserts values into the following columns of the `audit_logs` table: `audit_id`, `employee_id`, `changed_by`, `change_date`, `change_description`, `created_at`, and `updated_at`. For the `audit_id` column, it calculates a new unique identifier by first querying the `audit_logs` table to find the maximum existing `audit_id` value. If no records exist in `audit_logs` (i.e., `MAX(audit_id)` returns `NULL`), it defaults to `0`. It then adds `1` to this value to generate the next sequential `audit_id`. For the `employee_id` column, it uses the `id` column from the `NEW` record, which represents the employee's ID after the update. For the `changed_by` column, it uses the `user_id` column from the `NEW` record, indicating the user who performed the update. For the `change_date` column, it records the current timestamp converted to text using `CURRENT_TIMESTAMP::text`. For the `change_description` column, it inserts the static string literal 'Employee record modified'. For both the `created_at` and `updated_at` columns, it records the current timestamp converted to text using `CURRENT_TIMESTAMP::text`. After successfully inserting the audit log entry, the function returns the `NEW` record, allowing the `UPDATE` operation on the `employees` table to complete normally. This trigger function is then associated with a trigger named `log_employee_changes`, which is configured to execute `AFTER UPDATE` operations on the `employees` table `FOR EACH ROW`, invoking the `trg_log_employee_changes` function.",
    "original_summary": "Create a PostgreSQL trigger function named `trg_log_employee_changes` that fires AFTER UPDATE on the `employees` table FOR EACH ROW. Insert a new record into the `audit_logs` table. Generate a new `audit_id` by taking the maximum existing ID plus one (starting at 1). Populate the log with the employee's ID (`NEW.id`), the user who made the change (`NEW.user_id`), the current timestamp as text for `change_date`, the static description 'Employee record modified', and the current timestamp as text for both `created_at` and `updated_at`. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger function for the employees table that runs after updates. It should log some details about the change into an audit table. For the audit ID, just figure out the next number somehow, maybe by looking at the highest one already there. Put in the employee's ID and the user who did it, along with a timestamp for when it happened. Use a description like 'Employee record modified' and also note the current time for creation and update stamps. Make sure the new record is returned."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function create_default_status that inserts a new row into the statuses table using values derived from the NEW row of the departments table: calculate status_id as NEW.department_id + 100, set status_name to 'Department Active', description to 'Default status for department employees', effective_date to the current date using CURRENT_DATE, and reason to 'Department Creation'. Second, define the trigger trg_create_default_status on table departments that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION create_default_status() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO statuses (status_id, status_name, description, effective_date, reason) VALUES (NEW.department_id + 100, 'Department Active', 'Default status for department employees', CURRENT_DATE, 'Department Creation');\n  RETURN NULL; -- For AFTER triggers, return NULL\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_create_default_status\nAFTER INSERT ON departments\nFOR EACH ROW\nEXECUTE FUNCTION create_default_status();",
    "database_name": "human_resource_management_and_employee_tracking",
    "tables": [
      "employees",
      "departments",
      "job_titles",
      "statuses",
      "leaves"
    ],
    "call_sqls": [
      "INSERT INTO departments (department_id, department_name, location, manager_id, budget, phone_number, email, number_of_employees) VALUES (100, 'Research & Development', 'Boston', 5, 1000000.0, '555-123-4567', 'rnd@example.com', 25);",
      "INSERT INTO departments (department_id, department_name, location, manager_id, budget, phone_number, email, number_of_employees) VALUES (101, 'Quality Assurance', 'Austin', 6, 650000.0, '555-987-6543', 'qa@example.com', 12);",
      "INSERT INTO departments (department_id, department_name, location, manager_id, budget, phone_number, email, number_of_employees) VALUES (102, 'Human Resources', 'Chicago', 7, 450000.0, '555-456-7890', 'hr@example.com', 8);",
      "INSERT INTO departments (department_id, department_name, location, manager_id, budget, phone_number, email, number_of_employees) VALUES (103, 'Marketing', 'Seattle', 8, 850000.0, '555-789-0123', 'marketing@example.com', 18);",
      "INSERT INTO departments (department_id, department_name, location, manager_id, budget, phone_number, email, number_of_employees) VALUES (104, 'Customer Support', 'Denver', 9, 550000.0, '555-321-0987', 'support@example.com', 22);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `trg_create_default_status` that, after each new row is inserted into the `departments` table, automatically adds a corresponding default record to the `statuses` table. The new status record should set `status_id` to the new department's `department_id` plus 100, assign `status_name` as 'Department Active', set `description` to 'Default status for department employees', set `effective_date` to the current date, and set `reason` to 'Department Creation'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named `trg_create_default_status` that fires after a new department is inserted into the `departments` table, automatically adding a record to the `statuses` table with the new department's ID plus 100 as the `status_id`, setting `status_name` to 'Department Active', `description` to 'Default status for department employees', `effective_date` to today's date, and `reason` to 'Department Creation'.",
    "id": 91,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function create_default_status that inserts a new row into the statuses table using values derived from the NEW row of the departments table: calculate status_id as NEW.department_id + 100, set status_name to 'Department Active', description to 'Default status for department employees', effective_date to the current date using CURRENT_DATE, and reason to 'Department Creation'. Second, define the trigger trg_create_default_status on table departments that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that is executed after a new row is inserted into the departments table. This function, named create_default_status, does not take any parameters and is associated with a trigger named trg_create_default_status. The function performs an insert operation into the statuses table, adding a new row with the following values: the status_id is calculated by adding 100 to the NEW.department_id of the recently inserted department row; the status_name is set to the string 'Department Active'; the description is set to 'Default status for department employees'; the effective_date is set to the current date using the CURRENT_DATE function; and the reason is set to 'Department Creation'. The function returns NULL, which is standard for AFTER triggers in PostgreSQL, indicating that no modification is made to the triggering table. The trigger is defined to execute this function for each row that is inserted into the departments table, ensuring that a default status is automatically created for each new department.",
    "original_summary": "Create an AFTER INSERT trigger function `create_default_status` and trigger `trg_create_default_status` on the `departments` table. The function should insert a row into the `statuses` table with: `status_id` as `NEW.department_id + 100`, `status_name` as 'Department Active', `description` as 'Default status for department employees', `effective_date` as CURRENT_DATE, and `reason` as 'Department Creation'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Hey, can you set up a trigger that fires after we add a new department? We need a function called `create_default_status` and a trigger named `trg_create_default_status` on the `departments` table. Basically, whenever a new department pops in, this function should automatically add a record to the `statuses` table. For that new record, use the new department's ID plus 100 for the `status_id`, call the `status_name` 'Department Active', set the `description` to 'Default status for department employees', make the `effective_date` today, and put 'Department Creation' as the `reason`."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_update_optimizer` that unconditionally sets the `NEW.optimizer` column to the constant string 'SGD' and returns the modified `NEW` row.\nSecond, define the trigger `update_optimizer_trigger` on table `experiment_configurations` that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_optimizer() RETURNS TRIGGER AS $$\nBEGIN\n    -- Prevent infinite recursion by directly modifying NEW.optimizer\n    -- This function should be a BEFORE trigger to modify the row before it's written.\n    NEW.optimizer := 'SGD';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_optimizer_trigger\nBEFORE INSERT OR UPDATE ON experiment_configurations\nFOR EACH ROW EXECUTE FUNCTION trg_update_optimizer();",
    "database_name": "machine_learning_model_performance_tracking_and_analysis_455100",
    "tables": [
      "dataset_features",
      "experiment_configurations",
      "model_architectures"
    ],
    "call_sqls": [
      "INSERT INTO experiment_configurations (config_id, experiment_id, batch_size, epochs, optimizer) VALUES (1, 101, 32, 10, 'Adam');",
      "INSERT INTO experiment_configurations (config_id, experiment_id, batch_size, epochs, optimizer) VALUES (2, 102, 64, 20, 'RMSprop');",
      "UPDATE experiment_configurations SET batch_size = 128 WHERE config_id = 1;",
      "UPDATE experiment_configurations SET epochs = 30 WHERE config_id = 2;",
      "INSERT INTO experiment_configurations (config_id, experiment_id, batch_size, epochs, optimizer) VALUES (3, 103, 16, 5, 'Adagrad');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `update_optimizer_trigger` that, before inserting or updating a row in the `experiment_configurations` table, automatically sets the `optimizer` column to 'SGD' for the new or updated row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called update_optimizer_trigger that, before any insert or update operation on the experiment_configurations table, automatically sets the optimizer field to 'SGD' for the new row.",
    "id": 92,
    "generated_ir": "Write a PostgreSQL PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named trg_update_optimizer. This function is defined to return a trigger data type, which is standard for PostgreSQL trigger functions. The function does not accept any explicit parameters; it operates using the implicit trigger context variables NEW and OLD provided by PostgreSQL. Within the function, a single assignment operation is performed on the NEW pseudo-record before the triggering INSERT or UPDATE operation is applied to the database. Specifically, the optimizer field (column) of the NEW pseudo-record is set to the string literal 'SGD'. This assignment modifies the row data that will be inserted or updated. After this modification, the function concludes by returning the modified NEW pseudo-record, which is a mandatory action for BEFORE row-level triggers to ensure the altered data is used for the actual table operation.\n\nSecond, define the trigger named update_optimizer_trigger on the experiment_configurations table. This trigger is configured to fire BEFORE either an INSERT or an UPDATE operation occurs on the experiment_configurations table. It is a FOR EACH ROW trigger, meaning the associated trg_update_optimizer function executes once for every individual row that is affected by an INSERT or UPDATE statement on the experiment_configurations table. The trigger is set to EXECUTE FUNCTION trg_update_optimizer(), linking it to the defined trigger function. The overall effect is that whenever a new row is inserted into the experiment_configurations table or an existing row is updated, the optimizer column value for that row is automatically set to 'SGD' immediately before the data modification is committed to the table.",
    "original_ir": "Write a PostgreSQL trigger function named trg_update_optimizer that is defined to return a trigger, which is then bound to the table experiment_configurations via a trigger named update_optimizer_trigger; the trigger is a BEFORE trigger that fires for each row before any INSERT operation or UPDATE operation on the experiment_configurations table, and when it fires, the function executes a single assignment operation that directly sets the value of the NEW.optimizer column, which represents the new row version to be written, to the constant string literal 'SGD', thereby unconditionally overriding any optimizer value provided in the INSERT or UPDATE statement, and finally the function returns the modified NEW row record to allow the triggering operation to proceed with the altered data.",
    "original_summary": "Create a BEFORE INSERT OR UPDATE trigger named `update_optimizer_trigger` on the `experiment_configurations` table that runs FOR EACH ROW. It calls a trigger function `trg_update_optimizer` that sets NEW.optimizer to 'SGD' and returns NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a BEFORE INSERT OR UPDATE trigger, designated as `update_optimizer_trigger`, for the `experiment_configurations` table. This trigger is to execute FOR EACH ROW and must invoke the function `trg_update_optimizer`. The function's operation is to assign the value 'SGD' to the NEW.optimizer parameter and subsequently return the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_crime_severity` that updates the `severity_level` column in the `crimes` table using a CASE expression on the `NEW.predicted_crime_rate` from the `predictions` table, setting it to 'High' if the rate is greater than 10 and to 'Medium' otherwise, and ensures the update only applies where the `crime_id` matches `NEW.crime_id` before returning the `NEW` record.\nSecond, define the trigger `trg_update_crime_severity` on table `predictions` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_crime_severity() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE crimes\n  SET severity_level = CASE WHEN NEW.predicted_crime_rate > 10 THEN 'High' ELSE 'Medium' END\n  WHERE crime_id = NEW.crime_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_crime_severity\nAFTER INSERT ON predictions\nFOR EACH ROW EXECUTE FUNCTION update_crime_severity();",
    "database_name": "crime_statistics_and_reporting_791805",
    "tables": [
      "crimes",
      "regions",
      "predictions",
      "neighborhoods"
    ],
    "call_sqls": [
      "INSERT INTO predictions (prediction_id, crime_id, region_id, neighborhood_id, prediction_date, predicted_crime_rate) VALUES (0, 0, 1, 1, '2023-05-01', 12.5);",
      "INSERT INTO predictions (prediction_id, crime_id, region_id, neighborhood_id, prediction_date, predicted_crime_rate) VALUES (1, 1, 1, 1, '2023-05-02', 8.0);",
      "INSERT INTO predictions (prediction_id, crime_id, region_id, neighborhood_id, prediction_date, predicted_crime_rate) VALUES (2, 0, 1, 1, '2023-05-03', 10.1);",
      "INSERT INTO predictions (prediction_id, crime_id, region_id, neighborhood_id, prediction_date, predicted_crime_rate) VALUES (3, 1, 1, 1, '2023-05-04', 9.9);",
      "INSERT INTO predictions (prediction_id, crime_id, region_id, neighborhood_id, prediction_date, predicted_crime_rate) VALUES (4, 0, 1, 1, '2023-05-05', 15.0);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named `trg_update_crime_severity` that fires after each row is inserted into the `predictions` table, updating the `severity_level` column in the `crimes` table to 'High' if the new `predicted_crime_rate` value exceeds 10, otherwise setting it to 'Medium', based on a matching `crime_id` between the tables.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named `trg_update_crime_severity` that, after each row is inserted into the `predictions` table, updates the `severity_level` column in the `crimes` table to 'High' if the new `predicted_crime_rate` exceeds 10, otherwise sets it to 'Medium', but only for the matching `crime_id` in the `crimes` table based on the new row's `crime_id`.",
    "id": 93,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a PostgreSQL PL/pgSQL function named `update_crime_severity` that is designed to be executed as a trigger. This function takes no explicit parameters but operates on the `NEW` record, which represents the row that has just been inserted into the `predictions` table. The function performs an `UPDATE` operation on the `crimes` table. The `UPDATE` statement sets the `severity_level` column to a new value determined by a conditional expression. The conditional expression evaluates the `predicted_crime_rate` value from the `NEW` record. If the `NEW.predicted_crime_rate` is greater than 10, the expression resolves to the string literal 'High'. If the `NEW.predicted_crime_rate` is not greater than 10 (i.e., it is less than or equal to 10), the expression resolves to the string literal 'Medium'. This `UPDATE` operation only affects rows in the `crimes` table where the `crime_id` column matches the `crime_id` value from the `NEW` record of the `predictions` table. Finally, the function returns the `NEW` record, which is typically ignored for `AFTER` triggers but is required by the trigger function signature.\n\nSecond, define the trigger `trg_update_crime_severity` on the `predictions` table. This trigger is configured to execute `AFTER INSERT` operations on the `predictions` table. For `EACH ROW` affected by an `INSERT` statement, it invokes the `update_crime_severity()` function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `update_crime_severity` that is designed to be executed as a trigger, and a trigger named `trg_update_crime_severity` that invokes this function. The `update_crime_severity` function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the new and old row values, respectively, for the row that caused the trigger to fire. The purpose of this function is to update the `severity_level` column in the `crimes` table. Specifically, it performs an `UPDATE` operation on the `crimes` table. The `SET` clause of this `UPDATE` statement assigns a value to the `severity_level` column based on a conditional `CASE` expression. This `CASE` expression evaluates the value of the `predicted_crime_rate` column from the `NEW` record (which represents the newly inserted row in the `predictions` table). If `NEW.predicted_crime_rate` is strictly greater than the numeric literal `10`, then the `severity_level` column is set to the string literal `'High'`. Otherwise, if `NEW.predicted_crime_rate` is not greater than `10` (i.e., it is less than or equal to `10`), the `severity_level` column is set to the string literal `'Medium'`. The `WHERE` clause of the `UPDATE` statement ensures that only the row in the `crimes` table where the `crime_id` column matches the `crime_id` column from the `NEW` record (i.e., `NEW.crime_id`) is updated. After performing this update, the function `RETURN`s the `NEW` record, which is standard behavior for `BEFORE` or `AFTER` row-level triggers that do not intend to modify the row being inserted or updated. The `trg_update_crime_severity` trigger is defined to execute `AFTER INSERT` operations on the `predictions` table. It is a `FOR EACH ROW` trigger, meaning it will fire once for every row that is inserted into the `predictions` table. When it fires, it `EXECUTE`s the `update_crime_severity()` function.",
    "original_summary": "Create a trigger function `update_crime_severity` and a trigger `trg_update_crime_severity`. The trigger fires after each row insert into the `predictions` table. The function updates the `severity_level` column in the `crimes` table to 'High' if the new `predicted_crime_rate` > 10, otherwise to 'Medium', where the `crime_id` matches the new row's `crime_id`. The function returns the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a trigger function named `update_crime_severity` and an associated trigger designated as `trg_update_crime_severity`. This trigger is to be activated subsequent to the insertion of each individual row into the `predictions` table. The function's purpose is to modify the `severity_level` column within the `crimes` table. It shall assign a value of 'High' if the newly inserted `predicted_crime_rate` exceeds 10; otherwise, it shall assign a value of 'Medium'. This update is conditional upon the `crime_id` in the `crimes` table matching the `crime_id` present in the new row. The function must conclude by returning the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_user_last_login` that assigns the current date, formatted as a 'YYYY-MM-DD' string using `TO_CHAR(NOW(), 'YYYY-MM-DD')`, to the `last_login_date` column of the `NEW` row variable.\nSecond, define the trigger `trg_user_login` on table `users` that fires `BEFORE` `UPDATE` for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_user_last_login() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.last_login_date = TO_CHAR(NOW(), 'YYYY-MM-DD');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_user_login\nBEFORE UPDATE ON users\nFOR EACH ROW\nEXECUTE FUNCTION update_user_last_login();",
    "database_name": "university_course_management_and_syllabus_approval",
    "tables": [
      "course_proposals",
      "courses",
      "syllabi",
      "users"
    ],
    "call_sqls": [
      "UPDATE users SET user_name = 'Dr. John Smith Updated' WHERE user_id = 0;",
      "UPDATE users SET email = 'jane.doe.new@university.edu' WHERE user_id = 1;",
      "UPDATE users SET role = 'faculty' WHERE user_id = 0;",
      "UPDATE users SET position = 'Associate Professor' WHERE user_id = 1;",
      "UPDATE users SET department_id = 2 WHERE user_id = 0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_user_login that, before updating a row in the users table, sets the NEW.last_login_date to the current date in 'YYYY-MM-DD' format and returns the updated row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_user_login that, before updating a row in the users table, sets the NEW.last_login_date to today's date in 'YYYY-MM-DD' format and returns NEW.",
    "id": 94,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named `update_user_last_login` that is designed to execute automatically before a row is updated in the `users` table. This function takes no explicit input parameters beyond the standard trigger context variables. Within the function's `BEGIN` and `END` block, a single assignment operation is performed. This operation modifies the `last_login_date` column of the `NEW` pseudo-record, which represents the new row data in the context of the triggering event. The new value for `last_login_date` is set to the current date, formatted as a string in 'YYYY-MM-DD' format, by invoking the PostgreSQL function `CURRENT_DATE` and implicitly casting it to text. After this assignment, the function returns the modified `NEW` pseudo-record, which is a standard requirement for `BEFORE` row-level triggers to ensure the updated value is persisted.\n\nFollowing the function definition, a trigger named `trg_user_login` is created. This trigger is defined to execute `BEFORE UPDATE` on the `users` table. This means the trigger will activate before any `UPDATE` operation on a row in the `users` table, regardless of which columns are modified. The `FOR EACH ROW` clause specifies that the trigger function `update_user_last_login()` will be executed once for each row that is updated in the `users` table. The `EXECUTE FUNCTION update_user_last_login()` clause specifies that the previously defined `update_user_last_login` function should be invoked when the trigger conditions are met.",
    "original_ir": "Write a PostgreSQL trigger function named update_user_last_login that returns a trigger and is executed automatically by a trigger named trg_user_login before any update operation on the users table for each individual row being updated, where the function's logic assigns the current date, obtained by calling the NOW() function and formatted to a 'YYYY-MM-DD' string using the TO_CHAR() function, to the last_login_date column of the NEW row variable representing the incoming updated row data, and then returns this modified NEW row record to proceed with the update operation.",
    "original_summary": "Create a BEFORE UPDATE trigger function named update_user_last_login on the users table. The function should set the NEW.last_login_date to the current date in 'YYYY-MM-DD' format and then return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Make a BEFORE UPDATE trigger called update_user_last_login for users. It sets NEW.last_login_date to today's date (format 'YYYY-MM-DD') and returns NEW."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_dataset_quality` that updates the `data_quality` column to 'High' in the `datasets` table where the `dataset_id` matches `NEW.dataset_id` and either `NEW.property_value` is greater than 1000000 or `NEW.total_rooms` is greater than 2000, then returns `NEW`.\nSecond, define the trigger `housing_data_quality_trigger` on table `housing_data` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_dataset_quality() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE datasets SET data_quality = 'High' WHERE dataset_id = NEW.dataset_id AND (NEW.property_value > 1000000 OR NEW.total_rooms > 2000);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER housing_data_quality_trigger\n    AFTER INSERT ON housing_data\n    FOR EACH ROW\n    EXECUTE FUNCTION update_dataset_quality();",
    "database_name": "geographic_and_demographic_data_analysis_941845",
    "tables": [
      "datasets",
      "housing_data"
    ],
    "call_sqls": [
      "INSERT INTO housing_data (housing_id, dataset_id, median_age, total_rooms, total_bedrooms, total_bathrooms, property_type, year_built, property_value) VALUES (2, 0, 25, 3000, 500, 250, 'Condo', 1995, 1500000.0);",
      "INSERT INTO housing_data (housing_id, dataset_id, median_age, total_rooms, total_bedrooms, total_bathrooms, property_type, year_built, property_value) VALUES (3, 1, 40, 2500, 600, 300, 'Townhouse', 2005, 1200000.0);",
      "INSERT INTO housing_data (housing_id, dataset_id, median_age, total_rooms, total_bedrooms, total_bathrooms, property_type, year_built, property_value) VALUES (4, 0, 30, 1500, 400, 200, 'Single-family', 1990, 2000000.0);",
      "INSERT INTO housing_data (housing_id, dataset_id, median_age, total_rooms, total_bedrooms, total_bathrooms, property_type, year_built, property_value) VALUES (5, 1, 35, 2200, 550, 275, 'Apartment', 2015, 1100000.0);",
      "INSERT INTO housing_data (housing_id, dataset_id, median_age, total_rooms, total_bedrooms, total_bathrooms, property_type, year_built, property_value) VALUES (6, 0, 28, 1800, 450, 225, 'Duplex', 2000, 1300000.0);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named housing_data_quality_trigger that, after each new row is inserted into the housing_data table, updates the datasets table to set the data_quality column to 'High' for the matching dataset_id when the inserted row has a property_value greater than 1000000 or a total_rooms greater than 2000.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_dataset_quality that, after each insertion into the housing_data table, updates the datasets table by setting the data_quality field to 'High' for records where the dataset_id matches the inserted dataset_id, but only if the inserted property_value exceeds 1,000,000 or the inserted total_rooms exceeds 2,000, and then returns the new record.",
    "id": 95,
    "generated_ir": "Write a PostgreSQL PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named update_dataset_quality that is designed to be executed after each insertion into the housing_data table. This function does not accept any explicit parameters but utilizes the implicit NEW record provided by the trigger context, which contains the values of the newly inserted row in the housing_data table. The function's primary purpose is to conditionally update the data_quality column in the datasets table based on specific criteria derived from the inserted housing_data row.\n\nThe function begins by declaring no explicit variables, as it directly uses the NEW record. The core logic involves performing an UPDATE operation on the datasets table. The UPDATE statement sets the data_quality column to the string literal 'High' for rows in the datasets table where the dataset_id column matches the dataset_id value from the NEW record (i.e., NEW.dataset_id). However, this update is conditional and only executes if at least one of two criteria is met based on the inserted housing_data row: either the property_value column from the NEW record (NEW.property_value) exceeds the numeric value 1,000,000, or the total_rooms column from the NEW record (NEW.total_rooms) exceeds the integer value 2,000. This condition is implemented using a WHERE clause in the UPDATE statement that combines the dataset_id match with an OR logical operator to check both criteria. Specifically, the UPDATE affects rows in datasets where datasets.dataset_id = NEW.dataset_id AND (NEW.property_value > 1000000 OR NEW.total_rooms > 2000). After executing this conditional update, the function returns the NEW record to indicate successful completion and allow the triggering INSERT operation to proceed normally.\n\nSecond, define an AFTER INSERT trigger named update_dataset_quality_trigger on the housing_data table. This trigger is configured to fire after each row insertion into the housing_data table, operating as a FOR EACH ROW trigger. It executes the update_dataset_quality() function for every newly inserted row, ensuring that the datasets table's data_quality is updated accordingly based on the inserted housing_data values.",
    "original_ir": "Write a PL/pgSQL function named `update_dataset_quality` that is designed to be executed as a trigger. This function does not accept any explicit input parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. It is declared to return a `TRIGGER` type, which is standard for PL/pgSQL trigger functions. The core logic of this function involves a single `UPDATE` operation. Specifically, it updates the `datasets` table. Within this `UPDATE` statement, it sets the value of the `data_quality` column to the string literal 'High'. This update is conditional, applying only to rows in the `datasets` table where two conditions are met simultaneously. The first condition requires that the `dataset_id` column in the `datasets` table matches the `dataset_id` column from the `NEW` record, which represents the newly inserted or updated row in the table that fired the trigger. The second condition is a compound logical OR expression: either the `property_value` column from the `NEW` record is strictly greater than the numeric literal `1000000`, or the `total_rooms` column from the `NEW` record is strictly greater than the numeric literal `2000`. After attempting this update, the function returns the `NEW` record, which is a standard requirement for `BEFORE` or `AFTER` row-level triggers in PostgreSQL, indicating that the row that caused the trigger to fire should be processed further (or returned as is).\n\nFollowing the function definition, a trigger named `housing_data_quality_trigger` is created. This trigger is configured to activate `AFTER INSERT` operations on the `housing_data` table. It is a `FOR EACH ROW` trigger, meaning that the associated function will be executed once for every row that is inserted into the `housing_data` table. The trigger is set to `EXECUTE FUNCTION update_dataset_quality()`, which means that the previously defined `update_dataset_quality` function will be invoked whenever a new row is inserted into the `housing_data` table. During the execution of the `update_dataset_quality` function, the `NEW` record will contain the data of the row that was just inserted into `housing_data`, allowing the function to access its `dataset_id`, `property_value`, and `total_rooms` columns for the conditional update on the `datasets` table.",
    "original_summary": "Create a trigger function named update_dataset_quality that returns a trigger. After an insert on the housing_data table, update the datasets table to set data_quality to 'High' where dataset_id matches NEW.dataset_id and (NEW.property_value > 1000000 OR NEW.total_rooms > 2000). Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Please construct a trigger function designated as 'update_dataset_quality' that yields a trigger. Following an insertion operation on the 'housing_data' table, it is required to execute an update on the 'datasets' table. The 'data_quality' field should be set to the value 'High' for records where the 'dataset_id' corresponds to the NEW.dataset_id value, provided that the condition (NEW.property_value exceeds 1,000,000 OR NEW.total_rooms exceeds 2,000) is satisfied. The function must conclude by returning the NEW record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_parameter_aggregates` that updates the `typ_value` column in the `component_parameters` table by calculating the average of the `NEW.min_value` and `NEW.max_value` for the row where `component_id` equals `NEW.component_id` and `parameter_id` equals `NEW.parameter_id`.\nSecond, define the trigger `trigger_update_parameter_aggregates` on table `component_parameters` that fires AFTER UPDATE of the `min_value` or `max_value` columns and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_parameter_aggregates() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE component_parameters SET typ_value = (NEW.min_value + NEW.max_value) / 2 WHERE component_id = NEW.component_id AND parameter_id = NEW.parameter_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_update_parameter_aggregates\n    AFTER UPDATE OF min_value, max_value ON component_parameters\n    FOR EACH ROW\n    EXECUTE FUNCTION update_parameter_aggregates();",
    "database_name": "electronic_component_specification_and_parameter_tracking",
    "tables": [
      "access_logs",
      "components",
      "users",
      "datasheets",
      "component_conditions",
      "component_parameters",
      "conditions",
      "parameters"
    ],
    "call_sqls": [
      "UPDATE component_parameters SET min_value = -60.0, max_value = 140.0 WHERE component_id = 0 AND parameter_id = 0;",
      "UPDATE component_parameters SET min_value = -50.0, max_value = 130.0 WHERE component_id = 0 AND parameter_id = 1;",
      "UPDATE component_parameters SET min_value = -55.0, max_value = 125.0 WHERE component_id = 1 AND parameter_id = 0;",
      "UPDATE component_parameters SET min_value = -65.0, max_value = 150.0 WHERE component_id = 1 AND parameter_id = 1;",
      "UPDATE component_parameters SET min_value = -60.0, max_value = 140.0 WHERE component_id = 1 AND parameter_id = 1;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trigger_update_parameter_aggregates that fires AFTER UPDATE of the min_value or max_value columns on the component_parameters table, and for each updated row, updates the typ_value column in the component_parameters table for the matching row (identified by NEW.component_id and NEW.parameter_id) to the average of the new min_value and max_value.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called update_parameter_aggregates that runs after an update to the min_value or max_value columns on the component_parameters table. When either the min_value or max_value is changed, calculate a typical value for that specific component and parameter by taking the midpoint between the new minimum and maximum values, and store this result in the typ_value field for the corresponding row. Ensure the trigger returns the updated row details.",
    "id": 96,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named update_parameter_aggregates that returns a trigger and is designed to be executed as part of an AFTER UPDATE trigger on the component_parameters table. The function declares no local variables. The trigger is defined to fire after each row update on the component_parameters table, but only when the update modifies either the min_value column or the max_value column, as determined by the trigger condition. Within the function, a conditional check is performed using the TG_OP special variable to confirm the operation is an UPDATE, and then a check is made to see if either the NEW.min_value is different from the OLD.min_value or the NEW.max_value is different from the OLD.max_value. If this condition is true, the function performs an UPDATE operation on the same component_parameters table, targeting the row where component_id equals NEW.component_id and parameter_id equals NEW.parameter_id. The update sets the typ_value column to the calculated midpoint between NEW.min_value and NEW.max_value, computed as (NEW.min_value + NEW.max_value) / 2.0. After this update, the function returns the NEW row, which represents the updated state of the component_parameters record. Second, define the trigger trg_update_parameter_aggregates on the component_parameters table to fire AFTER UPDATE for each row, with a WHEN condition that checks if OLD.min_value IS DISTINCT FROM NEW.min_value OR OLD.max_value IS DISTINCT FROM NEW.max_value, ensuring the trigger only executes when either the min_value or max_value columns have actually changed.",
    "original_ir": "Write a PLpgSQL function that is triggered after an update operation on the min_value or max_value columns of the component_parameters table. This function, named update_parameter_aggregates, takes no parameters directly but operates in the context of a trigger. It updates the typ_value column in the component_parameters table by calculating the average of the new values of min_value and max_value, specifically for the row where the component_id matches NEW.component_id and the parameter_id matches NEW.parameter_id. The function returns the NEW row, indicating that it operates on the updated data. The associated trigger, named trigger_update_parameter_aggregates, is defined to execute this function after any update to the min_value or max_value columns in the component_parameters table, ensuring that the typ_value is recalculated and updated whenever these values change.",
    "original_summary": "Create a PostgreSQL AFTER UPDATE trigger function named update_parameter_aggregates for the component_parameters table. The function fires when min_value or max_value is updated. It updates the typ_value column for the matching row (NEW.component_id, NEW.parameter_id) to the average of the new min_value and max_value. It returns the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger function for the component_parameters table that runs after an update. It should be called something like update_parameter_aggregates. The main idea is that when the min or max values get changed, you should figure out a typical value for that specific component and parameter. Do this by taking the middle point or average of the new minimum and maximum numbers and putting that result into the typ_value field. Just make sure the function gives back the updated row details."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_access_on_high_cpu_load` that validates the `NEW.time_id` exists in the `time_measurements` table and raises an exception if not, then checks if `NEW.load_value` is greater than 85 to insert a new record into `access_logs` with `access_id` calculated as `COALESCE(MAX(access_id), 0) + 1`, `user_id` as 1, `system_id` as `NEW.system_id`, `access_date` as `CURRENT_DATE::text`, `access_type` as 'cpu_alert', `access_ip_address` as '0.0.0.0', and `access_duration` as 0.\nSecond, define the trigger `trg_log_access_on_high_cpu_load` on table `cpu_loads` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_access_on_high_cpu_load() RETURNS TRIGGER AS $$\nBEGIN\n  -- Validate that the time_id exists in time_measurements\n  IF NOT EXISTS (SELECT 1 FROM time_measurements WHERE time_id = NEW.time_id) THEN\n    RAISE EXCEPTION 'time_id % does not exist in time_measurements', NEW.time_id;\n  END IF;\n  \n  -- Only log access if CPU load is high\n  IF NEW.load_value > 85 THEN\n    INSERT INTO access_logs (access_id, user_id, system_id, access_date, access_type, access_ip_address, access_duration)\n    SELECT COALESCE(MAX(access_id), 0) + 1, 1, NEW.system_id, CURRENT_DATE::text, 'cpu_alert', '0.0.0.0', 0\n    FROM access_logs;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_access_on_high_cpu_load\nAFTER INSERT ON cpu_loads\nFOR EACH ROW EXECUTE FUNCTION log_access_on_high_cpu_load();",
    "database_name": "system_performance_monitoring_and_analysis_481541",
    "tables": [
      "systems",
      "access_logs",
      "users",
      "battery_powers",
      "cpu_loads",
      "memory_usages",
      "time_measurements"
    ],
    "call_sqls": [
      "INSERT INTO time_measurements (time_id, system_id, metric_id, time_value, measurement_timestamp, measurement_interval) VALUES (100, 0, 0, 60, '2023-05-03 09:00:00', 60);\nINSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (100, 0, 90, 100, 1, 'high');",
      "INSERT INTO time_measurements (time_id, system_id, metric_id, time_value, measurement_timestamp, measurement_interval) VALUES (101, 1, 0, 60, '2023-05-03 09:01:00', 60);\nINSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (101, 1, 95, 101, 1, 'critical');",
      "INSERT INTO time_measurements (time_id, system_id, metric_id, time_value, measurement_timestamp, measurement_interval) VALUES (102, 0, 0, 60, '2023-05-03 09:02:00', 60);\nINSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (102, 0, 86, 102, 1, 'high');",
      "INSERT INTO time_measurements (time_id, system_id, metric_id, time_value, measurement_timestamp, measurement_interval) VALUES (103, 1, 0, 60, '2023-05-03 09:03:00', 60);\nINSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (103, 1, 80, 103, 0, 'low');",
      "INSERT INTO time_measurements (time_id, system_id, metric_id, time_value, measurement_timestamp, measurement_interval) VALUES (104, 0, 0, 60, '2023-05-03 09:04:00', 60);\nINSERT INTO cpu_loads (load_id, system_id, load_value, time_id, load_threshold_exceeded, load_criticality) VALUES (104, 0, 50, 104, 0, 'low');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_log_access_on_high_cpu_load that executes after each row is inserted into the cpu_loads table. The trigger must validate that the new time_id exists in the time_measurements table; if it does not, raise an exception. If the new load_value exceeds 85, insert a new record into the access_logs table, generating a new access_id as the maximum existing access_id plus one (or starting at 1 if none exist), setting user_id to 1, system_id to the new system_id, access_date to the current date as text, access_type to 'cpu_alert', access_ip_address to '0.0.0.0', and access_duration to 0. Return the new row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_log_access_on_high_cpu_load that runs AFTER INSERT on the cpu_loads table to validate that the NEW.time_id exists in the time_measurements table, raising an exception if it does not, and then, if the NEW.load_value exceeds 85, inserts a new row into the access_logs table by generating a new access_id as the maximum existing access_id plus one (or 1 if null), setting user_id to 1, system_id to NEW.system_id, access_date to the current date as text, access_type to 'cpu_alert', access_ip_address to '0.0.0.0', and access_duration to 0, before returning NEW.",
    "id": 97,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named log_access_on_high_cpu_load. This function is a trigger function that operates in the context of a trigger and does not take any parameters directly. It is designed to execute after an INSERT operation on the cpu_loads table for each new row. The function begins by declaring a variable new_access_id of type bigint to store the generated access_id for the new access_logs entry. The function then performs a validation check: it queries the time_measurements table to verify that the NEW.time_id from the inserted cpu_loads row exists. This is done using a SELECT statement that checks for the existence of a row in time_measurements where the time_id matches NEW.time_id. If no such row exists, the function raises an exception with a message indicating that the time_id is invalid. If the validation passes, the function proceeds to check if the NEW.load_value from the inserted cpu_loads row exceeds 85. If this condition is true, the function performs an INSERT operation into the access_logs table. To generate the new access_id, it executes a subquery that calculates the maximum existing access_id from the access_logs table and adds one to it. If the table is empty and the maximum returns NULL, it defaults to 1 using COALESCE. The other columns for the new access_logs row are set as follows: user_id is set to 1, system_id is set to NEW.system_id from the inserted cpu_loads row, access_date is set to the current date converted to text using the CURRENT_DATE function, access_type is set to the string 'cpu_alert', access_ip_address is set to '0.0.0.0', and access_duration is set to 0. After the INSERT operation, the function returns the NEW record, which represents the newly inserted row in the cpu_loads table. If the NEW.load_value does not exceed 85, the function simply returns NEW without performing any additional operations. Second, define the trigger named trg_log_access_on_high_cpu_load on the cpu_loads table. This trigger is configured to fire AFTER INSERT on the cpu_loads table for each row. It is a row-level trigger, meaning it executes once for each row inserted into the cpu_loads table. The trigger is set to execute the log_access_on_high_cpu_load function, ensuring that the validation and conditional logging operations are performed automatically whenever a new row is added to the cpu_loads table.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `log_access_on_high_cpu_load` that is designed to be executed `AFTER INSERT` operations on the `cpu_loads` table, `FOR EACH ROW`. This function receives no explicit parameters but operates on the `NEW` record, which represents the newly inserted row in the `cpu_loads` table.\n\nUpon execution, the function first performs a validation check: it queries the `time_measurements` table to determine if a record exists where the `time_id` column matches the `time_id` value from the `NEW` record (`NEW.time_id`). If no such record is found in `time_measurements`, the function raises an exception with the message 'time_id % does not exist in time_measurements', substituting '%' with the actual `NEW.time_id` value, thereby halting the current operation.\n\nIf the `time_id` validation passes, the function proceeds to a conditional block. It checks if the `load_value` column from the `NEW` record (`NEW.load_value`) is greater than 85. If this condition is true, indicating a high CPU load, the function then inserts a new record into the `access_logs` table. The values for the columns in `access_logs` are determined as follows:\n- `access_id`: This value is calculated by first finding the maximum `access_id` currently present in the `access_logs` table. If no records exist (i.e., `MAX(access_id)` returns `NULL`), `COALESCE` ensures that `0` is used instead. This result is then incremented by `1` to generate a new, unique `access_id`.\n- `user_id`: This is set to the static integer value `1`.\n- `system_id`: This is populated with the `system_id` value from the `NEW` record (`NEW.system_id`).\n- `access_date`: This is set to the current date, cast to a `text` data type, using the `CURRENT_DATE::text` expression.\n- `access_type`: This is set to the static string literal `'cpu_alert'`.\n- `access_ip_address`: This is set to the static string literal `'0.0.0.0'`.\n- `access_duration`: This is set to the static integer value `0`.\n\nAfter either skipping the insertion (if `NEW.load_value` is not greater than 85) or completing the insertion, the function returns the `NEW` record, allowing the original `INSERT` operation on `cpu_loads` to complete.\n\nThe trigger `trg_log_access_on_high_cpu_load` is defined to execute this `log_access_on_high_cpu_load` function `AFTER INSERT` on the `cpu_loads` table for every row that is inserted.",
    "original_summary": "Create an AFTER INSERT trigger function for the cpu_loads table. Validate that NEW.time_id exists in time_measurements; raise an exception if not. If NEW.load_value > 85, insert a new row into access_logs. Generate a new access_id as MAX(access_id)+1 (or 1 if null). Set user_id to 1, system_id to NEW.system_id, access_date to CURRENT_DATE::text, access_type to 'cpu_alert', access_ip_address to '0.0.0.0', and access_duration to 0. Return NEW.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create an AFTER INSERT trigger function for the cpu_loads table that validates the existence of NEW.time_id in the time_measurements table, raising an exception if it is not found, and then, if NEW.load_value exceeds 85, inserts a new row into the access_logs table by generating a new access_id as MAX(access_id)+1 (or 1 if null), setting user_id to 1, system_id to NEW.system_id, access_date to CURRENT_DATE::text, access_type to 'cpu_alert', access_ip_address to '0.0.0.0', and access_duration to 0, before finally returning NEW?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_expected_delivery` that checks if the `NEW` record's `status` column equals the string 'pending' and, if true, sets the `expected_delivery_date` column to the result of adding 7 days to the current date and casting it to text.\nSecond, define the trigger `trg_update_expected_delivery` on table `orders` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_expected_delivery() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.status = 'pending' THEN\n    NEW.expected_delivery_date := (CURRENT_DATE + INTERVAL '7 days')::text;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_expected_delivery\nBEFORE INSERT ON orders\nFOR EACH ROW EXECUTE FUNCTION update_expected_delivery();",
    "database_name": "supply_chain_management_and_supplier_warehouse_tracking",
    "tables": [
      "orders"
    ],
    "call_sqls": [
      "INSERT INTO orders (order_id, supplier_id, order_date, status, total_amount, shipping_method, tracking_number) VALUES (2, 0, '2023-05-03', 'pending', 100.00, 'Air', 'TRACK123');",
      "INSERT INTO orders (order_id, supplier_id, order_date, status, total_amount, shipping_method, tracking_number) VALUES (3, 0, '2023-05-04', 'pending', 250.50, 'Sea', 'TRACK456');",
      "INSERT INTO orders (order_id, supplier_id, order_date, status, total_amount, shipping_method, tracking_number) VALUES (4, 0, '2023-05-05', 'pending', 75.25, 'Air', 'TRACK789');",
      "INSERT INTO orders (order_id, supplier_id, order_date, status, total_amount, shipping_method, tracking_number) VALUES (5, 0, '2023-05-06', 'completed', 500.00, 'Air', 'TRACK101');",
      "INSERT INTO orders (order_id, supplier_id, order_date, status, total_amount, shipping_method, tracking_number) VALUES (6, 0, '2023-05-07', 'pending', 120.00, 'Sea', 'TRACK112');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_expected_delivery that, before inserting a row into the ORDERS table, checks if the new row's STATUS is 'pending' and, if so, sets its EXPECTED_DELIVERY_DATE to the current date plus 7 days as text, then returns the updated row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called update_expected_delivery that, before inserting a row into the orders table, checks if the new row's status is 'pending' and, if so, sets its expected_delivery_date to the current date plus seven days as text, then returns the updated row.",
    "id": 98,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named update_expected_delivery with a return type of TRIGGER, which will be executed before an INSERT operation on the orders table for each row. Within this function, declare a variable to hold the calculated expected delivery date. The function checks if the NEW.status column from the triggering row is equal to the string 'pending'. If this condition is true, it calculates the expected delivery date by taking the current date, adding seven days to it, and converting the result to a text format. This calculated date is then assigned to the NEW.expected_delivery_date column. If the status is not 'pending', no change is made to the NEW.expected_delivery_date. After this conditional logic, the function returns the NEW row record, which includes any modifications made. Second, define a trigger named update_expected_delivery on the orders table, specifying that it should fire BEFORE INSERT for each row, and it should execute the update_expected_delivery function. This ensures that before any new row is inserted into the orders table, the trigger function is invoked to potentially adjust the expected_delivery_date based on the status value.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_expected_delivery` that is designed to be executed before an `INSERT` operation on the `orders` table. This function takes no explicit parameters but operates on the `NEW` pseudo-record, which represents the row about to be inserted into the `orders` table. The function's primary purpose is to conditionally set the `expected_delivery_date` column of the `NEW` record. Specifically, it evaluates a conditional statement: `IF NEW.status = 'pending' THEN`. This condition checks if the value of the `status` column in the `NEW` record is exactly equal to the string literal 'pending'. If this condition evaluates to true, the function proceeds to assign a new value to the `expected_delivery_date` column of the `NEW` record. The assigned value is derived by taking the `CURRENT_DATE` (which represents the current date at the time of execution), adding an `INTERVAL` of '7 days' to it, and then explicitly casting the resulting date value to a `text` data type using `::text`. After this conditional assignment, regardless of whether the condition was met or not, the function returns the `NEW` record. This returned `NEW` record, potentially modified, is then used by the `INSERT` statement to complete the insertion into the `orders` table.\n\nAccompanying this function is a PostgreSQL trigger named `trg_update_expected_delivery`. This trigger is configured to execute `BEFORE INSERT` operations on the `orders` table. The `FOR EACH ROW` clause specifies that the trigger function `update_expected_delivery()` will be executed once for each row that is being inserted into the `orders` table. The `EXECUTE FUNCTION update_expected_delivery()` clause indicates that the `update_expected_delivery` function is the specific PL/pgSQL function to be invoked by this trigger.",
    "original_summary": "Create a trigger function named update_expected_delivery that returns a trigger. Before inserting a row into the orders table, if the new row's status is 'pending', set its expected_delivery_date to the current date plus 7 days cast as text. Return the NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Define a trigger function called update_expected_delivery that returns a trigger. Before any insert into the orders table, check if the new row's status is 'pending'. If it is, assign its expected_delivery_date to the current date plus seven days, cast as text. Finally, return the NEW row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_payment_status` that checks if the `NEW.refunded_amount_cents` is greater than 0 and `NEW.payment_status` is not 'refunded'; if true, it updates the `payments` table to set `payment_status` to 'refunded' where `payment_id` matches `NEW.payment_id`. The function must return the `NEW` record.\nSecond, define the trigger `trg_update_payment_status` on table `payments` that fires AFTER UPDATE OF the `refunded_amount_cents` column and executes the function, using a FOR EACH ROW condition with a WHEN clause that checks if `OLD.refunded_amount_cents IS DISTINCT FROM NEW.refunded_amount_cents`.",
    "plsql": "CREATE OR REPLACE FUNCTION update_payment_status() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.refunded_amount_cents > 0 AND NEW.payment_status != 'refunded' THEN\n        UPDATE payments SET payment_status = 'refunded' WHERE payment_id = NEW.payment_id;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_payment_status\n    AFTER UPDATE OF refunded_amount_cents ON payments\n    FOR EACH ROW\n    WHEN (OLD.refunded_amount_cents IS DISTINCT FROM NEW.refunded_amount_cents)\n    EXECUTE FUNCTION update_payment_status();",
    "database_name": "e_commerce_payment_processing_and_fraud_detection",
    "tables": [
      "payments",
      "fraud_detection",
      "installment_plans",
      "transaction_fees",
      "users"
    ],
    "call_sqls": [
      "UPDATE payments SET refunded_amount_cents = 1000, payment_status = 'completed' WHERE payment_id = 0;",
      "UPDATE payments SET refunded_amount_cents = 500, payment_status = 'pending' WHERE payment_id = 1;",
      "UPDATE payments SET refunded_amount_cents = 2000, payment_status = 'processing' WHERE payment_id = 2;",
      "UPDATE payments SET refunded_amount_cents = 0, payment_status = 'completed' WHERE payment_id = 3;",
      "UPDATE payments SET refunded_amount_cents = 1500, payment_status = 'failed' WHERE payment_id = 4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_payment_status that executes AFTER UPDATE on the payments table when the refunded_amount_cents column changes, and if the new refunded_amount_cents is greater than 0 and the payment_status is not 'refunded', update the payment_status to 'refunded' for that payment_id in the payments table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger named update_payment_status that runs AFTER UPDATE on the payments table when the refunded_amount_cents column is modified, so that if the new refunded_amount_cents is greater than 0 and the payment_status is not already 'refunded', it updates the payment_status to 'refunded' for that payment_id and returns the NEW record.",
    "id": 99,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named update_payment_status. This function is defined to return a trigger type, meaning it will be used in a trigger context. The function does not take any explicit parameters; it implicitly accesses the OLD and NEW records from the payments table due to the trigger operation. The function is executed by a trigger that is set to activate AFTER an UPDATE operation on the payments table, specifically when the refunded_amount_cents column is modified. The trigger operates for each row affected by the update.\n\nWithin the function, the business logic is as follows: it checks a condition using an IF statement. The condition evaluates whether the NEW.refunded_amount_cents value (the updated value in the refunded_amount_cents column) is greater than 0 AND whether the NEW.payment_status value (the updated value in the payment_status column) is not equal to the string 'refunded'. If both parts of this condition are true, the function performs an UPDATE operation on the payments table. This UPDATE operation sets the payment_status column to the string 'refunded' for the specific row where the payment_id column value matches the NEW.payment_id value (which is the payment_id of the row being updated in the payments table). After executing the UPDATE (if the condition is met), the function returns the NEW record, which represents the state of the row after the update operation, including any changes made by this trigger function.\n\nSecond, define the trigger named trg_update_payment_status on the payments table. This trigger is configured to fire AFTER UPDATE on the payments table. It is set to execute for each row (row-level trigger). Additionally, a WHEN condition is applied to the trigger so that it only fires when the OLD.refunded_amount_cents value (the value before the update) is different from the NEW.refunded_amount_cents value (the value after the update), ensuring the trigger only runs when the refunded_amount_cents column is actually modified. The trigger calls the update_payment_status function described above.",
    "original_ir": "Write a PL/pgSQL trigger function named `update_payment_status` that takes no explicit parameters but operates within the context of a trigger, receiving special `NEW` and `OLD` records representing the new and old row versions, respectively. This function is designed to be executed by a trigger. Inside the function, a conditional check is performed: if the `refunded_amount_cents` column of the `NEW` record (representing the updated row) is strictly greater than `0` AND the `payment_status` column of the `NEW` record is NOT equal to the string literal `'refunded'`, then an `UPDATE` operation is executed. This `UPDATE` operation targets the `payments` table, setting the `payment_status` column to the string literal `'refunded'` for the row where the `payment_id` column matches the value of the `payment_id` column from the `NEW` record. After this conditional logic, the function always returns the `NEW` record, which is standard behavior for `BEFORE` or `AFTER` row-level triggers in PostgreSQL.\n\nAdditionally, define a trigger named `trg_update_payment_status` that is configured to execute `AFTER UPDATE` operations on the `payments` table. This trigger specifically monitors changes to the `refunded_amount_cents` column. It is a `FOR EACH ROW` trigger, meaning it will execute once for each row affected by an `UPDATE` statement. A `WHEN` clause is specified for this trigger, ensuring that the trigger's associated function, `update_payment_status()`, is only executed if the value of the `refunded_amount_cents` column in the `OLD` record (the row's state before the update) is `IS DISTINCT FROM` the value of the `refunded_amount_cents` column in the `NEW` record (the row's state after the update). This `WHEN` condition effectively means the trigger fires only when the `refunded_amount_cents` column has actually changed its value. When these conditions are met, the trigger executes the `update_payment_status()` function.",
    "original_summary": "Create a PostgreSQL trigger function named update_payment_status that executes AFTER UPDATE on the payments table when the refunded_amount_cents column changes. If the new refunded_amount_cents is greater than 0 and the payment_status is not 'refunded', update the payment_status to 'refunded' for that payment_id. Return the NEW record.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "How can I create a PostgreSQL trigger function named update_payment_status that runs AFTER UPDATE on the payments table when the refunded_amount_cents column is modified, so that if the new refunded_amount_cents is greater than 0 and the payment_status is not already 'refunded', it updates the payment_status to 'refunded' for that payment_id and returns the NEW record?"
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_obesity_risk that checks if the NEW.obesity_id is NULL and, if true, assigns a value by selecting the COALESCE(MAX(obesity_id), 0) + 1 from the obesity_data table. It then checks if the NEW.bmi is greater than 30 and, if true, sets the NEW.weight_management_plan to 'High Risk'. The function must return the NEW row.\nSecond, define the trigger trg_update_obesity_risk on table obesity_data that fires BEFORE INSERT for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_obesity_risk() RETURNS TRIGGER AS $$\nBEGIN\n    -- Ensure obesity_id is set if it's NULL\n    IF NEW.obesity_id IS NULL THEN\n        SELECT COALESCE(MAX(obesity_id), 0) + 1 INTO NEW.obesity_id FROM obesity_data;\n    END IF;\n    \n    -- Update weight management plan if BMI > 30\n    IF NEW.bmi > 30 THEN\n        NEW.weight_management_plan = 'High Risk';\n    END IF;\n    \n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_obesity_risk\n    BEFORE INSERT ON obesity_data\n    FOR EACH ROW\n    EXECUTE FUNCTION update_obesity_risk();",
    "database_name": "healthcare_data_analytics_and_patient_outcome_tracking",
    "tables": [
      "cardiovascular_data",
      "chronic_conditions",
      "comorbidities",
      "covid_status",
      "hypertension_data",
      "mortality_data",
      "obesity_data"
    ],
    "call_sqls": [
      "INSERT INTO obesity_data (patient_id, bmi, waist_circumference, body_fat_percentage) VALUES (3, 32.0, 42.0, 27.0);",
      "INSERT INTO obesity_data (patient_id, bmi, waist_circumference, body_fat_percentage) VALUES (4, 29.0, 39.0, 23.0);",
      "INSERT INTO obesity_data (patient_id, bmi, waist_circumference, body_fat_percentage) VALUES (5, 31.5, 41.0, 26.0);",
      "INSERT INTO obesity_data (patient_id, bmi, waist_circumference, body_fat_percentage) VALUES (6, 28.5, 37.0, 21.0);",
      "INSERT INTO obesity_data (patient_id, bmi, waist_circumference, body_fat_percentage) VALUES (7, 33.0, 43.0, 28.0);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL trigger named trg_update_obesity_risk that executes BEFORE INSERT on the obesity_data table to automatically assign a sequential obesity_id if it is null and set the weight_management_plan to 'High Risk' when the bmi exceeds 30, returning the updated NEW row.",
    "natural_language": "Write a PostgreSQL PL/pgSQL trigger called trg_update_obesity_risk that runs before inserting rows into the obesity_data table. If the obesity_id is missing for the new record, assign it the next available number from the existing obesity_id values. For rows where the bmi exceeds 30, set the weight_management_plan to 'High Risk'. Ensure the modified new row is returned.",
    "id": 100,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_obesity_risk that checks if the NEW.obesity_id is NULL and, if true, assigns a value by selecting the COALESCE(MAX(obesity_id), 0) + 1 from the obesity_data table. It then checks if the NEW.bmi is greater than 30 and, if true, sets the NEW.weight_management_plan to 'High Risk'. The function must return the NEW row.\nSecond, define the trigger trg_update_obesity_risk on table obesity_data that fires BEFORE INSERT for each row and executes the function.",
    "original_ir": "Write a PLpgSQL function that is triggered before an insert operation on the obesity_data table. This function first checks if the obesity_id column in the new row being inserted is NULL. If it is NULL, the function assigns a new obesity_id by selecting the maximum existing obesity_id from the obesity_data table, adding 1 to it, and setting this value in the NEW row's obesity_id column. Next, the function evaluates the bmi column in the NEW row; if the bmi value is greater than 30, it updates the weight_management_plan column in the NEW row to 'High Risk'. The function then returns the modified NEW row to be inserted into the obesity_data table. The trigger named trg_update_obesity_risk is created to execute this function for each row before it is inserted into the obesity_data table, ensuring that the obesity_id and weight_management_plan are appropriately set based on the conditions specified.",
    "original_summary": "Create a BEFORE INSERT trigger function for the obesity_data table. If the new row's obesity_id is null, assign the next sequential ID. If the bmi is greater than 30, set the weight_management_plan to 'High Risk'. Return the modified NEW row.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "trigger",
    "original_natural_language": "Set up a trigger to run before adding entries to the obesity_data table. If the obesity_id for the incoming record is missing, fill it in with the next available number. For rows where the bmi seems pretty high, maybe over 30, mark the weight_management_plan as something like 'High Risk'. Make sure the updated new row is sent back."
  }
]