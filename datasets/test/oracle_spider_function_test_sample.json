[
  {
    "ir": "Write an Oracle PL/SQL function named `get_settled_amount` that accepts a single input parameter, `para_Policy_ID`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Internally, the function declares a local variable named `settled_amount` of data type `NUMBER` to temporarily store the calculated sum. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `CLAIMS` table. Specifically, it calculates the `SUM` of the values in the `AMOUNT_SETTLED` column. This summation is performed only for those rows in the `CLAIMS` table where the value in the `POLICY_ID` column matches the value provided in the input parameter `para_Policy_ID`. The result of this summation is then stored into the local variable `settled_amount`. Following this data retrieval, the function proceeds with a conditional check: it evaluates whether the value stored in `settled_amount` `IS NOT NULL`. If `settled_amount` contains a non-null value, the function returns the value of `settled_amount`. Otherwise, if `settled_amount` `IS NULL` (which would occur if no matching records were found in the `CLAIMS` table for the given `para_Policy_ID`, resulting in a `SUM` of `NULL`), the function returns the numeric literal `0`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_settled_amount(para_Policy_ID NUMBER) RETURN NUMBER IS settled_amount NUMBER;\nBEGIN\n  SELECT SUM(AMOUNT_SETTLED) INTO settled_amount FROM CLAIMS WHERE POLICY_ID = para_Policy_ID;\n  \n  IF settled_amount IS NOT NULL THEN\n    RETURN settled_amount;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS"
    ],
    "call_sqls": [
      "SELECT get_settled_amount(744) FROM DUAL",
      "SELECT get_settled_amount(552) FROM DUAL",
      "SELECT get_settled_amount(473) FROM DUAL",
      "SELECT get_settled_amount(119) FROM DUAL",
      "SELECT get_settled_amount(141) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_settled_amount` that accepts a policy ID number and returns the total sum of settled amounts for that policy from the CLAIMS table. If no matching records are found, return 0.",
    "natural_language": "Write a PL/SQL function called `get_settled_amount` that takes a policy ID and gives back roughly the overall settled total for that policy from the CLAIMS data. If there aren't really any matching entries, just return zero.",
    "id": 1,
    "generated_ir": "Write an Oracle PL/SQL function named get_settled_amount that accepts a single input parameter p_policy_id of type NUMBER, which is used to identify a specific insurance policy, and returns a value of type NUMBER. The function declares a local variable v_total_settled of type NUMBER to store the computed result. It then executes a SELECT statement that queries the CLAIMS table to calculate the sum of the AMOUNT_SETTLED column for all rows where the POLICY_ID column in the CLAIMS table is equal to the provided input parameter p_policy_id. This aggregated sum is stored into the local variable v_total_settled via the INTO clause. If no rows match the condition, the SELECT statement will raise a NO_DATA_FOUND exception. The function includes an exception handling section to catch the NO_DATA_FOUND exception and, when caught, assigns the value 0 to the variable v_total_settled. After the exception handling, the function returns the value stored in v_total_settled. The function operates within the insurance_policies database and uses the CLAIMS table exclusively, focusing on the POLICY_ID and AMOUNT_SETTLED columns."
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_CUSTOMER_EMAIL that takes a single input parameter, P_CUSTOMER_ID, of type NUMBER, representing the unique identifier of a customer, and returns a value of type VARCHAR2. The function begins by declaring a local variable, V_EMAIL, of type VARCHAR2 with a maximum length of 255 characters, which will be used to store the email address retrieved from the database. Within the function body, a SELECT statement is executed to query the CUSTOMERS table, specifically retrieving the value from the EMAIL_ADDRESS column for the row where the CUSTOMER_ID column matches the value provided in the P_CUSTOMER_ID parameter. The result of this query is assigned to the V_EMAIL variable using the INTO clause. After the SELECT operation, a conditional statement checks whether the value stored in V_EMAIL is not NULL. If V_EMAIL contains a non-NULL value, the function returns the value of V_EMAIL, which represents the email address of the customer. If V_EMAIL is NULL, indicating that no email address was found for the specified customer ID, the function returns the string 'No Email Found'.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_CUSTOMER_EMAIL (P_CUSTOMER_ID IN NUMBER) RETURN VARCHAR2 IS\n  V_EMAIL VARCHAR2(255);\nBEGIN\n  SELECT EMAIL_ADDRESS\n  INTO V_EMAIL\n  FROM CUSTOMERS\n  WHERE CUSTOMER_ID = P_CUSTOMER_ID;\n\n  IF V_EMAIL IS NOT NULL THEN\n    RETURN V_EMAIL;\n  ELSE\n    RETURN 'No Email Found';\n  END IF;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_CUSTOMER_EMAIL(113) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(114) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(115) FROM DUAL",
      "SELECT GET_CUSTOMER_EMAIL(120) FROM DUAL",
      "SELECT CUSTOMER_ID, GET_CUSTOMER_EMAIL(CUSTOMER_ID) AS EMAIL FROM COMPLAINTS WHERE COMPLAINT_ID = 1"
    ],
    "summary": "Create a PL/SQL function named `GET_CUSTOMER_EMAIL` that returns a VARCHAR2. It accepts a customer ID as input. The function retrieves and returns the customer's email address from the CUSTOMERS table. If no email is found, return 'No Email Found'.",
    "natural_language": "Please construct a PL/SQL function, designated as `GET_CUSTOMER_EMAIL`, which shall yield a value of the VARCHAR2 datatype. This function must be designed to accept a customer identifier as its input parameter. Its operational logic is to query the CUSTOMERS table to retrieve the associated email address for the specified customer. In the event that no corresponding email record is located, the function is to return the string 'No Email Found'.",
    "id": 2,
    "generated_ir": "Write an Oracle PL/SQL function named GET_CUSTOMER_EMAIL that takes a single input parameter, P_CUSTOMER_ID, of type NUMBER, representing the unique identifier of a customer, and returns a value of type VARCHAR2. The function begins by declaring a local variable, V_EMAIL, of type VARCHAR2 with a maximum length of 255 characters, which will be used to store the email address retrieved from the database. Within the function body, a SELECT statement is executed to query the CUSTOMERS table, specifically retrieving the value from the EMAIL_ADDRESS column for the row where the CUSTOMER_ID column matches the value provided in the P_CUSTOMER_ID parameter. The result of this query is assigned to the V_EMAIL variable using the INTO clause. After the SELECT operation, a conditional statement checks whether the value stored in V_EMAIL is not NULL. If V_EMAIL contains a non-NULL value, the function returns the value of V_EMAIL, which represents the email address of the customer. If V_EMAIL is NULL, indicating that no email address was found for the specified customer ID, the function returns the string 'No Email Found'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_EMPLOYEE_PHONE` that is designed to retrieve the phone number of a specific employee. This function accepts one input parameter: `EMPLOYEE_ID_IN`, which is of data type `NUMBER` and represents the unique identifier for an employee whose phone number is to be retrieved. The function is declared to return a value of data type `VARCHAR2`, which will be the employee's phone number. Internally, the function declares a local variable named `EMPLOYEE_PHONE_OUT` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved phone number. The core operation of the function involves a `SELECT` statement that queries the `EMPLOYEES` table. This `SELECT` statement retrieves the value from the `EMPLOYEE_PHONE` column. The retrieved value is then immediately stored into the `EMPLOYEE_PHONE_OUT` local variable using the `INTO` clause. The selection of the specific row from the `EMPLOYEES` table is determined by a `WHERE` clause, which specifies that the `EMPLOYEE_ID` column in the `EMPLOYEES` table must exactly match the value provided by the `EMPLOYEE_ID_IN` input parameter. After successfully executing the `SELECT` statement and populating `EMPLOYEE_PHONE_OUT`, the function then returns the value currently held in the `EMPLOYEE_PHONE_OUT` variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_EMPLOYEE_PHONE(EMPLOYEE_ID_IN NUMBER) RETURN VARCHAR2 IS\n  EMPLOYEE_PHONE_OUT VARCHAR2(255);\nBEGIN\n  SELECT EMPLOYEE_PHONE\n  INTO EMPLOYEE_PHONE_OUT\n  FROM EMPLOYEES\n  WHERE EMPLOYEE_ID = EMPLOYEE_ID_IN;\n  RETURN EMPLOYEE_PHONE_OUT;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "CUSTOMERS",
      "ORDER_DELIVERIES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "SELECT GET_EMPLOYEE_PHONE(1) FROM DUAL",
      "SELECT GET_EMPLOYEE_PHONE(2) FROM DUAL",
      "SELECT GET_EMPLOYEE_PHONE(3) FROM DUAL",
      "SELECT GET_EMPLOYEE_PHONE(4) FROM DUAL",
      "SELECT GET_EMPLOYEE_PHONE(6) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_EMPLOYEE_PHONE that takes an employee ID (NUMBER) and returns a VARCHAR2 phone number. It retrieves the EMPLOYEE_PHONE from the EMPLOYEES table for the given ID and returns it.",
    "natural_language": "Develop a comprehensive PL/SQL function called GET_EMPLOYEE_PHONE, which is designed to accept a single numeric input parameter representing an employee ID and subsequently provide a VARCHAR2 output containing the corresponding phone number. This function will meticulously query the EMPLOYEES table to locate and retrieve the specific EMPLOYEE_PHONE value associated with the provided identifier, ensuring it is accurately returned.",
    "id": 3,
    "generated_ir": "Write an Oracle PL/SQL function named `GET_EMPLOYEE_PHONE` that is designed to retrieve the phone number of a specific employee. This function accepts one input parameter: `EMPLOYEE_ID_IN`, which is of data type `NUMBER` and represents the unique identifier for an employee whose phone number is to be retrieved. The function is declared to return a value of data type `VARCHAR2`, which will be the employee's phone number. Internally, the function declares a local variable named `EMPLOYEE_PHONE_OUT` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved phone number. The core operation of the function involves a `SELECT` statement that queries the `EMPLOYEES` table. This `SELECT` statement retrieves the value from the `EMPLOYEE_PHONE` column. The retrieved value is then immediately stored into the `EMPLOYEE_PHONE_OUT` local variable using the `INTO` clause. The selection of the specific row from the `EMPLOYEES` table is determined by a `WHERE` clause, which specifies that the `EMPLOYEE_ID` column in the `EMPLOYEES` table must exactly match the value provided by the `EMPLOYEE_ID_IN` input parameter. After successfully executing the `SELECT` statement and populating `EMPLOYEE_PHONE_OUT`, the function then returns the value currently held in the `EMPLOYEE_PHONE_OUT` variable as its result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_average_student_age that accepts a single input parameter p_city_code of data type VARCHAR2 and returns a value of data type NUMBER; within the function, a local variable v_average_age of type NUMBER is declared; the function's logic executes a SELECT statement that calculates the average value of the AGE column from the STUDENT table, specifically for rows where the CITY_CODE column matches the value provided in the input parameter p_city_code; the result of this AVG aggregation is stored into the local variable v_average_age using an INTO clause; the function then concludes by returning the value contained in v_average_age.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_average_student_age(p_city_code VARCHAR2) RETURN NUMBER IS\n  v_average_age NUMBER;\nBEGIN\n  SELECT AVG(AGE) INTO v_average_age FROM STUDENT WHERE CITY_CODE = p_city_code;\n  RETURN v_average_age;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_average_student_age('BAL') FROM dual",
      "SELECT fn_get_average_student_age('PIT') FROM dual",
      "SELECT fn_get_average_student_age('PHL') FROM dual",
      "SELECT fn_get_average_student_age('HKG') FROM dual",
      "SELECT fn_get_average_student_age('WAS') FROM dual"
    ],
    "summary": "Create a PL/SQL function named fn_get_average_student_age that accepts a VARCHAR2 city code and returns the average age of students from that city as a NUMBER.",
    "natural_language": "What is the average age of students from a given city, and can you provide it as a PL/SQL function named fn_get_average_student_age that takes a VARCHAR2 city code and returns the result as a NUMBER?",
    "id": 4,
    "generated_ir": "Write an Oracle PL/SQL function named `fn_get_average_student_age` that accepts a single input parameter, `p_city_code`, of data type `VARCHAR2`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_average_age` of data type `NUMBER`. The core operation of this function is to perform a `SELECT` statement to calculate the average age of students from a specific city. The `SELECT` statement queries the `STUDENT` table, using the `AVG` aggregate function on the `AGE` column. The result of this calculation is stored into the `v_average_age` variable. The `SELECT` statement includes a `WHERE` clause that filters the rows from the `STUDENT` table. The filtering condition checks if the `CITY_CODE` column in the `STUDENT` table is equal to the input parameter `p_city_code`. This ensures the average is calculated only for students whose city code matches the provided input. After the average age is computed and stored in `v_average_age`, the function returns the value of `v_average_age`. If no students are found for the given city code, the `AVG` function will return `NULL`, and the function will consequently return `NULL`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_category_performance that accepts a single input parameter p_category of type VARCHAR2 and returns a VARCHAR2 value. The function begins by declaring three local NUMBER variables: v_product_count, v_total_revenue, and v_avg_price. It then executes a SELECT statement that queries the products table (aliased as p) by joining it with the order_items table (aliased as oi) on the condition that the product_id column from the products table matches the product_id column in the order_items table. The SELECT statement filters rows where the production_type_code column in the products table equals the input parameter p_category. For the filtered result set, the query calculates three aggregate values: the count of distinct product_id values from the products table, the sum of the product of the product_quantity column from order_items (converted to a NUMBER using the TO_NUMBER function) and the unit_price column from products (with the NVL function ensuring a result of 0 if the sum is null), and the average of the unit_price column from products (with NVL returning 0 if the average is null). These three calculated values are assigned into the local variables v_product_count, v_total_revenue, and v_avg_price respectively. After the query, the function uses an IF-ELSIF-ELSE conditional block to determine the return value. If v_product_count equals 0, the function returns the string literal 'NO_PRODUCTS'. Otherwise, if v_total_revenue is greater than 20000, it returns 'HIGH_REVENUE_CATEGORY'. Otherwise, if v_avg_price is greater than 400, it returns 'PREMIUM_CATEGORY'. If none of the previous conditions are met, the function returns 'STANDARD_CATEGORY'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_category_performance(p_category VARCHAR2) RETURN VARCHAR2 IS\n    v_product_count NUMBER;\n    v_total_revenue NUMBER;\n    v_avg_price NUMBER;\nBEGIN\n    SELECT COUNT(p.product_id), \n           NVL(SUM(TO_NUMBER(oi.product_quantity) * p.unit_price), 0),\n           NVL(AVG(p.unit_price), 0)\n    INTO v_product_count, v_total_revenue, v_avg_price\n    FROM products p\n    JOIN order_items oi ON p.product_id = oi.product_id\n    WHERE p.production_type_code = p_category;\n    \n    IF v_product_count = 0 THEN\n        RETURN 'NO_PRODUCTS';\n    ELSIF v_total_revenue > 20000 THEN\n        RETURN 'HIGH_REVENUE_CATEGORY';\n    ELSIF v_avg_price > 400 THEN\n        RETURN 'PREMIUM_CATEGORY';\n    ELSE\n        RETURN 'STANDARD_CATEGORY';\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_product_category_performance('Food') FROM DUAL",
      "SELECT get_product_category_performance('Books') FROM DUAL",
      "SELECT get_product_category_performance('Electronics') FROM DUAL",
      "SELECT get_product_category_performance('DVDs') FROM DUAL",
      "SELECT get_product_category_performance('Clothing') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_product_category_performance that accepts a category name (VARCHAR2) and returns a VARCHAR2. It calculates the product count, total revenue, and average price for that category from the products and order_items tables. It returns 'NO_PRODUCTS' if count is zero, 'HIGH_REVENUE_CATEGORY' if revenue > 20000, 'PREMIUM_CATEGORY' if average price > 400, else 'STANDARD_CATEGORY'.",
    "natural_language": "Write a function get_product_category_performance(category_name VARCHAR2) returning VARCHAR2. It finds product count, total revenue, and average price for that category. Return 'NO_PRODUCTS' if count zero, 'HIGH_REVENUE_CATEGORY' if revenue > 20000, 'PREMIUM_CATEGORY' if avg price > 400, else 'STANDARD_CATEGORY'.",
    "id": 5,
    "generated_ir": "Write an Oracle PL/SQL function named `get_product_category_performance` that accepts one input parameter: `category_name` of type `VARCHAR2`. This function returns a single `VARCHAR2` string. The function is designed to analyze the performance of a specified product category by calculating key metrics from the database and returning a descriptive classification based on those metrics.\n\nThe function begins by declaring three local variables: `v_product_count` of type `NUMBER`, `v_total_revenue` of type `NUMBER`, and `v_average_price` of type `NUMBER`. These variables will store the calculated metrics.\n\nThe core of the function is a single `SELECT` statement that performs an aggregation query across multiple joined tables to compute the required metrics for the given category name. The query retrieves data from the `PRODUCT_CATEGORIES`, `PRODUCTS`, `ORDER_ITEMS`, and `ORDERS` tables.\n\nThe `SELECT` statement uses the following operations and conditions:\n1.  It calculates the count of distinct `PRODUCT_ID` values from the `PRODUCTS` table, assigning this result to the `v_product_count` variable.\n2.  It calculates the total revenue by summing the product of the `UNIT_PRICE` from the `PRODUCTS` table and the `PRODUCT_QUANTITY` from the `ORDER_ITEMS` table. The `PRODUCT_QUANTITY` is converted from `VARCHAR2` to `NUMBER` using the `TO_NUMBER` function for this calculation. This sum is assigned to the `v_total_revenue` variable.\n3.  It calculates the average unit price (`UNIT_PRICE`) from the `PRODUCTS` table, assigning this result to the `v_average_price` variable.\n\nThe tables are joined as follows to link categories to orders:\n-   The `PRODUCT_CATEGORIES` table is joined to the `PRODUCTS` table using the `PRODUCTION_TYPE_CODE` column.\n-   The `PRODUCTS` table is joined to the `ORDER_ITEMS` table using the `PRODUCT_ID` column.\n-   The `ORDER_ITEMS` table is joined to the `ORDERS` table using the `ORDER_ID` column.\n\nThe query includes a `WHERE` clause with a single condition: it filters the results to only include rows where the `PRODUCTION_TYPE_CODE` column in the `PRODUCT_CATEGORIES` table matches the input parameter `category_name`.\n\nAfter the `SELECT` statement executes, the function implements a control flow structure using `IF` and `ELSIF` statements to determine the return value based on the calculated metrics, in the following order of precedence:\n1.  First, it checks if the value of `v_product_count` is equal to 0. If true, the function returns the string literal 'NO_PRODUCTS'.\n2.  If the product count is not zero, it then checks if the value of `v_total_revenue` is greater than 20000. If true, the function returns the string literal 'HIGH_REVENUE_CATEGORY'.\n3.  If the revenue condition is not met, it then checks if the value of `v_average_price` is greater than 400. If true, the function returns the string literal 'PREMIUM_CATEGORY'.\n4.  If none of the above conditions are true, the function returns the string literal 'STANDARD_CATEGORY'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named CALCULATE_STAFF_SCORE that accepts a single mandatory input parameter named STAFF_ID_IN of the NUMBER data type and returns a value of the NUMBER data type, where the function's logic begins by declaring a local variable named SCORE of the NUMBER data type and initializing it with the result of the mathematical expression SQRT(STAFF_ID_IN * 10), which first multiplies the input parameter STAFF_ID_IN by the constant integer 10 and then calculates the square root of that product using the built-in SQRT function, and finally the function returns the value stored in the SCORE variable.",
    "plsql": "CREATE OR REPLACE FUNCTION CALCULATE_STAFF_SCORE(STAFF_ID_IN NUMBER) RETURN NUMBER IS\n  SCORE NUMBER := SQRT(STAFF_ID_IN * 10);\nBEGIN\n  RETURN SCORE;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT CALCULATE_STAFF_SCORE(114) FROM DUAL",
      "SELECT CALCULATE_STAFF_SCORE(120) FROM DUAL",
      "SELECT CALCULATE_STAFF_SCORE(115) FROM DUAL",
      "SELECT CALCULATE_STAFF_SCORE(116) FROM DUAL",
      "SELECT CALCULATE_STAFF_SCORE(117) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named CALCULATE_STAFF_SCORE that accepts a staff ID (NUMBER), calculates the square root of the staff ID multiplied by 10, and returns the result (NUMBER).",
    "natural_language": "Please construct a PL/SQL function designated as CALCULATE_STAFF_SCORE. This function shall accept a single numerical parameter representing a staff identification number. Its operation must compute the square root of the product of the provided staff ID and the constant value ten. The function is required to return the computed result as a numerical data type.",
    "id": 6,
    "generated_ir": "Write an Oracle PL/SQL function named CALCULATE_STAFF_SCORE that accepts a single mandatory input parameter named STAFF_ID_IN of the NUMBER data type and returns a value of the NUMBER data type, where the function's logic begins by declaring a local variable named SCORE of the NUMBER data type and initializing it with the result of the mathematical expression SQRT(STAFF_ID_IN * 10), which first multiplies the input parameter STAFF_ID_IN by the constant integer 10 and then calculates the square root of that product using the built-in SQRT function, and finally the function returns the value stored in the SCORE variable."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `translate_device_carrier` that accepts two input parameters: `device_id_val` of data type `NUMBER` and `from_chars` of data type `VARCHAR2`. This function is designed to return a single value of data type `VARCHAR2` with a maximum length of 255 characters. Upon execution, the function declares a local variable named `result_val` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved and transformed data. The core operation of the function involves a `SELECT` statement that queries the `DEVICE` table. Specifically, it selects the `CARRIER` column from the `DEVICE` table. Before returning the `CARRIER` value, it applies the `TRANSLATE` function to it. The `TRANSLATE` function replaces all occurrences of characters specified in the `from_chars` input parameter within the `CARRIER` column's value with corresponding characters from the literal string `'ABC'`. The result of this `TRANSLATE` operation is then stored into the `result_val` local variable. This selection and translation are performed only for rows in the `DEVICE` table where the `DEVICE_ID` column's value matches the `device_id_val` input parameter. Finally, the function returns the value stored in the `result_val` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION translate_device_carrier(device_id_val NUMBER, from_chars VARCHAR2) RETURN VARCHAR2 IS\n  result_val VARCHAR2(255);\nBEGIN\n  SELECT TRANSLATE(CARRIER, from_chars, 'ABC') INTO result_val FROM DEVICE WHERE DEVICE_ID = device_id_val;\n  RETURN result_val;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT translate_device_carrier(1, 'MTS') FROM dual",
      "SELECT translate_device_carrier(2, 'Verizon') FROM dual",
      "SELECT translate_device_carrier(3, 'Telus') FROM dual",
      "SELECT translate_device_carrier(1, 'Mobility') FROM dual",
      "SELECT translate_device_carrier(2, 'Wireless') FROM dual"
    ],
    "summary": "Create a function named `translate_device_carrier` that returns a VARCHAR2. It takes a device ID (NUMBER) and a character set (VARCHAR2). It selects the CARRIER from the DEVICE table for the given ID, translates the characters in the carrier using the provided 'from_chars' and the literal 'ABC', and returns the result.",
    "natural_language": "How can I create a function called `translate_device_carrier` that returns a VARCHAR2, takes a device ID (NUMBER) and a character set (VARCHAR2) as inputs, selects the CARRIER from the DEVICE table for the specified ID, translates the characters in that carrier using the provided 'from_chars' and the literal string 'ABC', and then returns the translated result?",
    "id": 7,
    "generated_ir": "Write an Oracle PL/SQL function named `translate_device_carrier` that accepts two input parameters: `device_id_val` of data type `NUMBER` and `from_chars` of data type `VARCHAR2`. This function is designed to return a single value of data type `VARCHAR2` with a maximum length of 255 characters. Upon execution, the function declares a local variable named `result_val` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved and transformed data. The core operation of the function involves a `SELECT` statement that queries the `DEVICE` table. Specifically, it selects the `CARRIER` column from the `DEVICE` table. Before returning the `CARRIER` value, it applies the `TRANSLATE` function to it. The `TRANSLATE` function replaces all occurrences of characters specified in the `from_chars` input parameter within the `CARRIER` column's value with corresponding characters from the literal string `'ABC'`. The result of this `TRANSLATE` operation is then stored into the `result_val` local variable. This selection and translation are performed only for rows in the `DEVICE` table where the `DEVICE_ID` column's value matches the `device_id_val` input parameter. Finally, the function returns the value stored in the `result_val` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_average_product_price that calculates and returns the average price of products from the PRODUCTS table. The function does not take any input parameters and returns a value of type NUMBER. Inside the function, a local variable v_avg_price of type NUMBER is declared to store the result of the average calculation. The function performs a SELECT operation to compute the average of the PRODUCT_PRICE column from the PRODUCTS table, and the result is stored into the v_avg_price variable using the INTO clause. The function then returns the value stored in v_avg_price, which represents the average product price. There are no conditional statements or special operations such as function calls like UPPER() or LOWER() involved in this function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_product_price RETURN NUMBER IS\n  v_avg_price NUMBER;\nBEGIN\n  SELECT AVG(PRODUCT_PRICE)\n  INTO v_avg_price\n  FROM PRODUCTS;\n  RETURN v_avg_price;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "REGULAR_ORDERS",
      "REGULAR_ORDER_PRODUCTS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_average_product_price FROM DUAL",
      "SELECT get_average_product_price() FROM DUAL",
      "DECLARE\n  v_avg NUMBER;\nBEGIN\n  v_avg := get_average_product_price;\n  DBMS_OUTPUT.PUT_LINE('Average Price: ' || v_avg);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average Product Price: ' || get_average_product_price);\nEND;",
      "SELECT get_average_product_price AS avg_price FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_average_product_price` with no parameters that returns the average price of all products from the PRODUCTS table.",
    "natural_language": "Write a PL/SQL function `get_average_product_price` with no parameters to return the average price from PRODUCTS.",
    "id": 8,
    "generated_ir": "Write an Oracle PL/SQL function named get_average_product_price that accepts no input parameters and is designed to return a NUMBER value representing the average price. The function begins by declaring a local variable v_average_price of type NUMBER. The function then executes a SELECT statement that queries the PRODUCTS table, specifically calculating the average of the PRODUCT_PRICE column using the AVG aggregate function. The result of this calculation is assigned into the local variable v_average_price. The function then returns the value stored in v_average_price as its result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_timezone_adoption_date` that accepts a single input parameter, `p_dog_id`, which is of data type `NUMBER` and represents the unique identifier for a dog. This function is designed to return a `VARCHAR2` string, specifically a formatted date and time string. The function's primary purpose is to retrieve the adoption date for a specific dog, convert it to a `TIMESTAMP` data type, adjust it to the current database session's time zone, and then format it as a string.\n\nInside the function's `BEGIN` block, a local variable `v_date_adopted` of type `VARCHAR2(255)` is declared to temporarily store the formatted adoption date. The core operation involves a `SELECT` statement that queries the `DOGS` table. This `SELECT` statement retrieves the `DATE_ADOPTED` column. The `DATE_ADOPTED` column's value is first converted to a `TIMESTAMP` data type using the `TO_TIMESTAMP` function, with the format mask `'YYYY-MM-DD HH24:MI:SS'` indicating that the original `DATE_ADOPTED` string is expected to be in the format of year-month-day hour:minute:second. This `TIMESTAMP` value is then explicitly adjusted to the time zone of the current database session using the `AT TIME ZONE SESSIONTIMEZONE` clause. Finally, the resulting time zone-adjusted `TIMESTAMP` is converted back into a `VARCHAR2` string using the `TO_CHAR` function, again with the format mask `'YYYY-MM-DD HH24:MI:SS'`. The result of this conversion is then stored into the `v_date_adopted` variable. The `WHERE` clause of the `SELECT` statement filters the records in the `DOGS` table, ensuring that only the row where the `DOG_ID` column matches the input parameter `p_dog_id` is considered.\n\nAfter the `SELECT` statement successfully executes and populates `v_date_adopted`, the function returns the value stored in `v_date_adopted`.\n\nThe function includes an `EXCEPTION` block to handle potential errors. If the `SELECT` statement does not find any row matching the provided `p_dog_id` (i.e., `NO_DATA_FOUND` exception occurs), the function catches this specific exception and returns `NULL`. If any other type of error occurs during the execution of the `SELECT` statement, such as an invalid date format in the `DATE_ADOPTED` column that prevents `TO_TIMESTAMP` from succeeding, or any other conversion error (caught by the `WHEN OTHERS` clause), the function also catches this general exception and returns `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_timezone_adoption_date(p_dog_id IN NUMBER) RETURN VARCHAR2 IS\n    v_date_adopted VARCHAR2(255);\nBEGIN\n    SELECT TO_CHAR(\n             TO_TIMESTAMP(DATE_ADOPTED, 'YYYY-MM-DD HH24:MI:SS') AT TIME ZONE SESSIONTIMEZONE,\n             'YYYY-MM-DD HH24:MI:SS'\n           )\n    INTO v_date_adopted\n    FROM DOGS\n    WHERE DOG_ID = p_dog_id;\n    \n    RETURN v_date_adopted;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\n    WHEN OTHERS THEN\n        -- Handle invalid date format or other conversion errors\n        RETURN NULL;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "SELECT get_timezone_adoption_date(1) FROM dual",
      "SELECT get_timezone_adoption_date(2) FROM dual",
      "SELECT get_timezone_adoption_date(3) FROM dual",
      "SELECT get_timezone_adoption_date(4) FROM dual",
      "SELECT get_timezone_adoption_date(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_timezone_adoption_date` that accepts a dog ID (NUMBER) and returns a VARCHAR2. It retrieves the adoption date for the specified dog from the DOGS table, converts it to a TIMESTAMP, adjusts it to the session time zone, formats it as 'YYYY-MM-DD HH24:MI:SS', and returns the string. Return NULL if no data is found or if any error occurs.",
    "natural_language": "Develop a PL/SQL function called `get_timezone_adjustment_date` that takes a single numeric input representing a dog's unique identifier and yields a VARCHAR2 string. This function should meticulously query the DOGS table to locate the precise adoption date for the provided dog ID. Upon finding the record, it must carefully convert the date into a TIMESTAMP, thoughtfully adjust that timestamp to align with the current session's time zone, and then elegantly format the final result into the specific 'YYYY-MM-DD HH24:MI:SS' pattern. It is essential that the function gracefully handles cases where no corresponding data exists or if any unforeseen errors arise during execution, securely returning a NULL value in such instances.",
    "id": 9,
    "generated_ir": "Write an Oracle PL/SQL function named `get_timezone_adoption_date` that accepts a single input parameter, `p_dog_id`, which is of data type `NUMBER` and represents the unique identifier for a dog. This function is designed to return a `VARCHAR2` string, specifically a formatted date and time string. The function's primary purpose is to retrieve the adoption date for a specific dog, convert it to a `TIMESTAMP` data type, adjust it to the current database session's time zone, and then format it as a string.\n\nInside the function's `BEGIN` block, a local variable `v_date_adopted` of type `VARCHAR2(255)` is declared to temporarily store the formatted adoption date. The core operation involves a `SELECT` statement that queries the `DOGS` table. This `SELECT` statement retrieves the `DATE_ADOPTED` column. The `DATE_ADOPTED` column's value is first converted to a `TIMESTAMP` data type using the `TO_TIMESTAMP` function, with the format mask `'YYYY-MM-DD HH24:MI:SS'` indicating that the original `DATE_ADOPTED` string is expected to be in the format of year-month-day hour:minute:second. This `TIMESTAMP` value is then explicitly adjusted to the time zone of the current database session using the `AT TIME ZONE SESSIONTIMEZONE` clause. Finally, the resulting time zone-adjusted `TIMESTAMP` is converted back into a `VARCHAR2` string using the `TO_CHAR` function, again with the format mask `'YYYY-MM-DD HH24:MI:SS'`. The result of this conversion is then stored into the `v_date_adopted` variable. The `WHERE` clause of the `SELECT` statement filters the records in the `DOGS` table, ensuring that only the row where the `DOG_ID` column matches the input parameter `p_dog_id` is considered.\n\nAfter the `SELECT` statement successfully executes and populates `v_date_adopted`, the function returns the value stored in `v_date_adopted`.\n\nThe function includes an `EXCEPTION` block to handle potential errors. If the `SELECT` statement does not find any row matching the provided `p_dog_id` (i.e., `NO_DATA_FOUND` exception occurs), the function catches this specific exception and returns `NULL`. If any other type of error occurs during the execution of the `SELECT` statement, such as an invalid date format in the `DATE_ADOPTED` column that prevents `TO_TIMESTAMP` from succeeding, or any other conversion error (caught by the `WHEN OTHERS` clause), the function also catches this general exception and returns `NULL`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_order_value_with_discount that accepts a single parameter p_customer_id of type NUMBER, which represents the unique identifier of a customer. The function is designed to calculate the total order value for the specified customer, applying a discount based on the total value. It initializes a local variable v_total_value of type NUMBER to zero, which will store the cumulative value of all products ordered by the customer. Another local variable, v_discount, also of type NUMBER, is initialized to zero and will hold the discount amount. The function executes a SELECT statement that calculates the sum of the product of PRODUCT_QUANTITY and a fixed price of 10 for each order item associated with the customer. This is achieved by joining the ORDERS table, aliased as o, with the ORDER_ITEMS table, aliased as oi, on the ORDER_ID column, and filtering the results where the CUSTOMER_ID column in the ORDERS table matches the input parameter p_customer_id. The result of this calculation is stored in the v_total_value variable. The function then calculates the discount by dividing v_total_value by 100 and applying the FLOOR function to round down to the nearest whole number, storing the result in v_discount. Finally, the function returns the total order value after subtracting the calculated discount, which is the difference between v_total_value and v_discount.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_order_value_with_discount(p_customer_id NUMBER) RETURN NUMBER IS\n    v_total_value NUMBER := 0;\n    v_discount NUMBER := 0;\nBEGIN\n    SELECT SUM(TO_NUMBER(oi.PRODUCT_QUANTITY) * 10) INTO v_total_value\n    FROM ORDERS o JOIN ORDER_ITEMS oi ON o.ORDER_ID = oi.ORDER_ID\n    WHERE o.CUSTOMER_ID = p_customer_id;\n    \n    v_discount := FLOOR(v_total_value / 100);\n    \n    RETURN v_total_value - v_discount;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "SELECT calculate_order_value_with_discount(1) FROM dual",
      "SELECT calculate_order_value_with_discount(5) FROM dual",
      "SELECT calculate_order_value_with_discount(7) FROM dual",
      "SELECT calculate_order_value_with_discount(12) FROM dual",
      "SELECT calculate_order_value_with_discount(8) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `calculate_order_value_with_discount` that accepts a `p_customer_id` (NUMBER) and returns a NUMBER. It calculates the total order value for the customer by summing (PRODUCT_QUANTITY * 10) from ORDER_ITEMS joined with ORDERS, applies a discount equal to the floor of (total value / 100), and returns the total value minus the discount.",
    "natural_language": "Develop a PL/SQL function called `calculate_order_value_with_discount` that takes a single numeric input parameter, specifically a `p_customer_id`, and yields a NUMBER as its output. This function meticulously computes the comprehensive total order value for the specified customer by first aggregating the sum of all product quantities, each multiplied by a unit price of 10, which are meticulously retrieved from the ORDER_ITEMS table after carefully joining it with the ORDERS table based on the relevant order identifiers. Subsequently, it thoughtfully determines an applicable discount, which is precisely calculated as the mathematical floor of the preliminary total value divided by 100. Finally, the function elegantly returns the final net amount, which is the initial total value gracefully reduced by the thoughtfully derived discount.",
    "id": 10,
    "generated_ir": "Write an Oracle PL/SQL function named `calculate_order_value_with_discount` that accepts a single input parameter `p_customer_id` of data type `NUMBER`. The function returns a `NUMBER` representing the final net order value for the specified customer after applying a discount. The function begins by declaring a local variable `v_total_value` of type `NUMBER` to store the preliminary aggregated order value before discount. It also declares a local variable `v_discount` of type `NUMBER` to store the calculated discount amount. The first operation is a `SELECT` statement that queries the `ORDER_ITEMS` table. This `SELECT` statement performs an `INNER JOIN` with the `ORDERS` table using the condition `ORDER_ITEMS.ORDER_ID = ORDERS.ORDER_ID` to link order items to their respective orders. The `WHERE` clause filters the joined result set to include only those records where `ORDERS.CUSTOMER_ID` equals the input parameter `p_customer_id`. Within the `SELECT` clause, the function calculates the sum of all product quantities multiplied by a fixed unit price of 10. Specifically, it uses the expression `SUM(TO_NUMBER(ORDER_ITEMS.PRODUCT_QUANTITY) * 10)`. The `TO_NUMBER` function is applied to the `PRODUCT_QUANTITY` column, which is stored as `VARCHAR2(255)`, to convert it to a numeric value for arithmetic operations. The result of this aggregation is stored into the `v_total_value` variable. Next, the function calculates the discount by taking the mathematical floor of `v_total_value` divided by 100. This is computed using the expression `FLOOR(v_total_value / 100)`, and the result is stored into the `v_discount` variable. Finally, the function returns the net amount, which is computed as `v_total_value` minus `v_discount`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_price_tier` that accepts a single input parameter, `p_entry_id`, which is of data type `NUMBER` and represents a unique identifier for a catalog entry. This function is designed to return a `VARCHAR2` value with a maximum length of 15 characters, indicating the price tier of the catalog entry.\n\nUpon execution, the function first declares two local variables: `v_dollar_price` of data type `NUMBER` to store the price of the catalog entry, and `v_tier` of data type `VARCHAR2` with a maximum length of 15 characters to store the determined price tier.\n\nThe function then performs a `SELECT` operation to retrieve the `PRICE_IN_DOLLARS` column value from the `CATALOG_CONTENTS` table. This retrieval is conditioned on matching the `CATALOG_ENTRY_ID` column in the `CATALOG_CONTENTS` table with the value provided in the input parameter `p_entry_id`. The retrieved `PRICE_IN_DOLLARS` value is then stored into the local variable `v_dollar_price`.\n\nFollowing the data retrieval, the function proceeds with a series of conditional checks (`IF-ELSIF-ELSE`) based on the value stored in `v_dollar_price` to determine the appropriate price tier:\n1. If the value of `v_dollar_price` is strictly greater than 600, the local variable `v_tier` is assigned the string literal 'PREMIUM'.\n2. Otherwise, if the value of `v_dollar_price` is strictly greater than 400, the local variable `v_tier` is assigned the string literal 'MID_RANGE'.\n3. Otherwise, if the value of `v_dollar_price` is strictly greater than 200, the local variable `v_tier` is assigned the string literal 'STANDARD'.\n4. In all other cases (i.e., if `v_dollar_price` is less than or equal to 200), the local variable `v_tier` is assigned the string literal 'BUDGET'.\n\nFinally, the function returns the determined price tier, which is the value stored in the `v_tier` variable, as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_price_tier(p_entry_id NUMBER) RETURN VARCHAR2 IS\n    v_dollar_price NUMBER;\n    v_tier VARCHAR2(15);\nBEGIN\n    SELECT PRICE_IN_DOLLARS INTO v_dollar_price FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_dollar_price > 600 THEN v_tier := 'PREMIUM';\n    ELSIF v_dollar_price > 400 THEN v_tier := 'MID_RANGE';\n    ELSIF v_dollar_price > 200 THEN v_tier := 'STANDARD';\n    ELSE v_tier := 'BUDGET';\n    END IF;\n    RETURN v_tier;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT get_price_tier(1) FROM DUAL",
      "SELECT get_price_tier(2) FROM DUAL",
      "SELECT get_price_tier(3) FROM DUAL",
      "SELECT get_price_tier(4) FROM DUAL",
      "SELECT get_price_tier(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_price_tier that accepts a catalog entry ID (NUMBER) and returns a VARCHAR2(15) price tier. Retrieve the price from CATALOG_CONTENTS and classify it: >600 as 'PREMIUM', >400 as 'MID_RANGE', >200 as 'STANDARD', otherwise 'BUDGET'.",
    "natural_language": "Develop a PL/SQL function, which should be named get_price_tier, that is designed to accept a single input parameter: a catalog entry ID of the NUMBER data type. This function must return a price tier classification as a VARCHAR2 string with a maximum length of fifteen characters. To determine the appropriate tier, you must first retrieve the associated price value from the CATALOG_CONTENTS table. Subsequently, you should implement a detailed classification logic: if the price is found to be greater than 600, it should be categorized as 'PREMIUM'; if it is greater than 400, it should be labeled 'MID_RANGE'; if it exceeds 200, it should be designated 'STANDARD'; and for all other cases, the entry should be assigned the 'BUDGET' tier.",
    "id": 11,
    "generated_ir": "Write an Oracle PL/SQL function named get_price_tier that accepts a single input parameter, p_catalog_entry_id, which is of data type NUMBER. This function is designed to return a single value of data type VARCHAR2 with a maximum length of fifteen characters. Upon execution, the function first declares a local variable named v_price of data type NUMBER to store the retrieved price value. The core operation of the function involves executing a SELECT statement to retrieve data from the CATALOG_CONTENTS table. Specifically, it selects the value from the PRICE_IN_DOLLARS column for the row where the CATALOG_ENTRY_ID column matches the value provided in the input parameter p_catalog_entry_id. The result of this SELECT statement is then stored into the local variable v_price. Following this data retrieval, the function implements a conditional logic block using IF and ELSIF statements to classify the price tier based on the value stored in v_price. If v_price is greater than 600, the function returns the string 'PREMIUM'. If v_price is greater than 400, the function returns the string 'MID_RANGE'. If v_price is greater than 200, the function returns the string 'STANDARD'. For all other cases, meaning when v_price is less than or equal to 200, the function returns the string 'BUDGET'. Finally, the function concludes by returning the determined price tier string as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_customer_complaint_status` that accepts two input parameters: `p_customer_id` of data type `NUMBER`, intended to represent a unique identifier for a customer, and `p_status_code` of data type `VARCHAR2`, intended to represent a specific status code for a complaint. This function is designed to return a single value of data type `VARCHAR2(255)`. The function's execution begins by declaring a local variable named `v_result` of data type `VARCHAR2(255)` to temporarily store the retrieved complaint type code. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `COMPLAINTS` table. It attempts to retrieve the value from the `COMPLAINT_TYPE_CODE` column. The retrieved value is then immediately stored into the local variable `v_result`. The `SELECT` statement includes a `WHERE` clause with three conditions that must all be met for a row to be considered. The first condition is `CUSTOMER_ID = p_customer_id`, which filters rows to include only those where the value in the `CUSTOMER_ID` column matches the value provided in the `p_customer_id` input parameter. The second condition is `COMPLAINT_STATUS_CODE = p_status_code`, which further filters the rows to include only those where the value in the `COMPLAINT_STATUS_CODE` column matches the value provided in the `p_status_code` input parameter. The third condition is `ROWNUM = 1`, which restricts the result set to only the first row that satisfies the preceding conditions, effectively ensuring that only one `COMPLAINT_TYPE_CODE` is returned even if multiple rows match the customer ID and status code criteria. After the `SELECT` statement has executed and the `v_result` variable has been populated, the function concludes by returning the value currently held in the `v_result` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_complaint_status(p_customer_id NUMBER, p_status_code VARCHAR2) RETURN VARCHAR2 IS\n    v_result VARCHAR2(255);\nBEGIN\n    SELECT COMPLAINT_TYPE_CODE INTO v_result FROM COMPLAINTS WHERE CUSTOMER_ID = p_customer_id AND COMPLAINT_STATUS_CODE = p_status_code AND ROWNUM = 1;\n    RETURN v_result;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_customer_complaint_status(120, 'Closed') FROM DUAL",
      "SELECT get_customer_complaint_status(113, 'New') FROM DUAL",
      "SELECT get_customer_complaint_status(114, 'Closed') FROM DUAL",
      "SELECT get_customer_complaint_status(120, 'New') FROM DUAL",
      "SELECT get_customer_complaint_status(113, 'Closed') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_customer_complaint_status` that returns a VARCHAR2. It takes a customer ID (NUMBER) and a status code (VARCHAR2) as input. The function queries the COMPLAINTS table to return the COMPLAINT_TYPE_CODE for the first row where CUSTOMER_ID and COMPLAINT_STATUS_CODE match the input parameters.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_customer_complaint_status` that spits back a VARCHAR2? It needs to take a customer ID (that's a NUMBER) and a status code (a VARCHAR2). Basically, the function should check the COMPLAINTS table and grab the COMPLAINT_TYPE_CODE from the first matching row where the CUSTOMER_ID and COMPLAINT_STATUS_CODE line up with the numbers and codes we give it.",
    "id": 12,
    "generated_ir": "Write an Oracle PL/SQL function named `get_customer_complaint_status` that accepts two input parameters: `p_customer_id` of data type `NUMBER`, intended to represent a unique identifier for a customer, and `p_status_code` of data type `VARCHAR2`, intended to represent a specific status code for a complaint. This function is designed to return a single value of data type `VARCHAR2(255)`. The function's execution begins by declaring a local variable named `v_result` of data type `VARCHAR2(255)` to temporarily store the retrieved complaint type code. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `COMPLAINTS` table. It attempts to retrieve the value from the `COMPLAINT_TYPE_CODE` column. The retrieved value is then immediately stored into the local variable `v_result`. The `SELECT` statement includes a `WHERE` clause with three conditions that must all be met for a row to be considered. The first condition is `CUSTOMER_ID = p_customer_id`, which filters rows to include only those where the value in the `CUSTOMER_ID` column matches the value provided in the `p_customer_id` input parameter. The second condition is `COMPLAINT_STATUS_CODE = p_status_code`, which further filters the rows to include only those where the value in the `COMPLAINT_STATUS_CODE` column matches the value provided in the `p_status_code` input parameter. The third condition is `ROWNUM = 1`, which restricts the result set to only the first row that satisfies the preceding conditions, effectively ensuring that only one `COMPLAINT_TYPE_CODE` is returned even if multiple rows match the customer ID and status code criteria. After the `SELECT` statement has executed and the `v_result` variable has been populated, the function concludes by returning the value currently held in the `v_result` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_song_count that accepts a single input parameter p_singer_id of the NUMBER data type, which represents the unique identifier of a singer, and returns a single value of the NUMBER data type; the function declares a local variable v_count of the NUMBER data type; within the execution block, the function performs a SELECT statement that queries the SONG table, using the COUNT(*) aggregate function to calculate the total number of rows; the SELECT statement includes a WHERE clause with the condition that the SINGER_ID column in the SONG table must be equal to the value supplied in the input parameter p_singer_id; the result of the COUNT(*) operation is stored into the local variable v_count using the INTO clause; the function then concludes its execution by using the RETURN statement to send the value stored in v_count back to the caller.",
    "plsql": "CREATE OR REPLACE FUNCTION get_song_count(p_singer_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM SONG WHERE SINGER_ID = p_singer_id;\n  RETURN v_count;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "SELECT get_song_count(1) FROM DUAL",
      "SELECT get_song_count(2) FROM DUAL",
      "SELECT get_song_count(3) FROM DUAL",
      "SELECT get_song_count(4) FROM DUAL",
      "SELECT get_song_count(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_song_count that accepts a singer ID (NUMBER) and returns the count of songs (NUMBER) for that singer by counting rows in the SONG table where SINGER_ID matches the input.",
    "natural_language": "What is the total number of songs for a given singer ID, obtained by counting the relevant entries in the SONG table?",
    "id": 13,
    "generated_ir": "Write an Oracle PL/SQL function named get_song_count that accepts a single input parameter p_singer_id of the NUMBER data type, which represents the unique identifier of a singer, and returns a single value of the NUMBER data type; the function declares a local variable v_count of the NUMBER data type; within the execution block, the function performs a SELECT statement that queries the SONG table, using the COUNT(*) aggregate function to calculate the total number of rows; the SELECT statement includes a WHERE clause with the condition that the SINGER_ID column in the SONG table must be equal to the value supplied in the input parameter p_singer_id; the result of the COUNT(*) operation is stored into the local variable v_count using the INTO clause; the function then concludes its execution by using the RETURN statement to send the value stored in v_count back to the caller."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_individual_full_name` that is designed to retrieve the concatenated full name of an individual based on their unique identifier. This function accepts one input parameter: `p_individual_id`, which is of data type `NUMBER` and represents the primary key or unique identifier for an individual record in the `INDIVIDUALS` table. The function is declared to return a `VARCHAR2` data type, which will hold the full name of the individual.\n\nInside the function's execution block, a local variable `v_full_name` of type `VARCHAR2` with a maximum length of 255 characters is declared to temporarily store the retrieved full name. The core operation involves a `SELECT` statement that queries the `INDIVIDUALS` table. This `SELECT` statement concatenates the values from the `INDIVIDUAL_FIRST_NAME` column and the `INDIVIDUAL_LAST_NAME` column, separated by a single space character. The `TRIM` function is applied to the result of this concatenation to remove any leading or trailing whitespace that might result from empty first or last names, or from the concatenation itself. The concatenated and trimmed full name is then assigned to the `v_full_name` variable using the `INTO` clause. The `WHERE` clause of the `SELECT` statement filters the records in the `INDIVIDUALS` table, ensuring that only the row where the `INDIVIDUAL_ID` column matches the value provided in the input parameter `p_individual_id` is selected. After successfully retrieving and assigning the full name to `v_full_name`, the function concludes by returning the value stored in `v_full_name` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_individual_full_name(p_individual_id NUMBER) RETURN VARCHAR2 IS\n  v_full_name VARCHAR2(255);\nBEGIN\n  SELECT TRIM(INDIVIDUAL_FIRST_NAME || ' ' || INDIVIDUAL_LAST_NAME) INTO v_full_name\n  FROM INDIVIDUALS\n  WHERE INDIVIDUAL_ID = p_individual_id;\n  RETURN v_full_name;\nEND;",
    "database_name": "e_government",
    "tables": [
      "ADDRESSES",
      "INDIVIDUALS",
      "ORGANIZATIONS",
      "ORGANIZATION_CONTACT_INDIVIDUALS",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "SELECT get_individual_full_name(1) FROM DUAL",
      "SELECT get_individual_full_name(2) FROM DUAL",
      "SELECT get_individual_full_name(3) FROM DUAL",
      "SELECT get_individual_full_name(10) FROM DUAL",
      "SELECT get_individual_full_name(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_individual_full_name` that returns a VARCHAR2. It accepts an individual ID (NUMBER). The function retrieves the trimmed concatenation of INDIVIDUAL_FIRST_NAME and INDIVIDUAL_LAST_NAME (separated by a space) from the INDIVIDUALS table where INDIVIDUAL_ID matches the input parameter.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_individual_full_name`? It should spit back a VARCHAR2. You'll give it an individual's ID (as a NUMBER). What it does is grab the person's first and last name from the INDIVIDUALS table, smoosh 'em together with a space in between (and trim off any extra spaces), but only for the record where the INDIVIDUAL_ID matches the number you passed in.",
    "id": 14,
    "generated_ir": "Write an Oracle PL/SQL function named `get_individual_full_name` that is designed to retrieve the concatenated full name of an individual based on their unique identifier. This function accepts one input parameter: `p_individual_id`, which is of data type `NUMBER` and represents the primary key or unique identifier for an individual record in the `INDIVIDUALS` table. The function is declared to return a `VARCHAR2` data type, which will hold the full name of the individual.\n\nInside the function's execution block, a local variable `v_full_name` of type `VARCHAR2` with a maximum length of 255 characters is declared to temporarily store the retrieved full name. The core operation involves a `SELECT` statement that queries the `INDIVIDUALS` table. This `SELECT` statement concatenates the values from the `INDIVIDUAL_FIRST_NAME` column and the `INDIVIDUAL_LAST_NAME` column, separated by a single space character. The `TRIM` function is applied to the result of this concatenation to remove any leading or trailing whitespace that might result from empty first or last names, or from the concatenation itself. The concatenated and trimmed full name is then assigned to the `v_full_name` variable using the `INTO` clause. The `WHERE` clause of the `SELECT` statement filters the records in the `INDIVIDUALS` table, ensuring that only the row where the `INDIVIDUAL_ID` column matches the value provided in the input parameter `p_individual_id` is selected. After successfully retrieving and assigning the full name to `v_full_name`, the function concludes by returning the value stored in `v_full_name` as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_party_form_status` that accepts a single input parameter, `p_party_id`, which is of data type `NUMBER` and represents a unique identifier for a party. This function is designed to return a `VARCHAR2` value, specifically a form status code. Upon execution, the function initializes a local variable `v_form_status` of type `VARCHAR2` with a maximum length of 255 characters. The primary operation involves attempting to retrieve a `FORM_STATUS_CODE` from the `PARTY_FORMS` table. This retrieval is performed by selecting the `FORM_STATUS_CODE` column and storing its value into the `v_form_status` variable. The selection is constrained by two conditions: first, the `PARTY_ID` column in the `PARTY_FORMS` table must match the value provided in the `p_party_id` input parameter; second, `ROWNUM = 1` is used to ensure that only the first row encountered that satisfies the `PARTY_ID` condition is considered, effectively limiting the result set to a single row. After this selection, the function immediately returns the value stored in `v_form_status`. The function includes exception handling for two specific scenarios. If a `NO_DATA_FOUND` exception occurs, meaning no rows in the `PARTY_FORMS` table match the provided `p_party_id`, the function returns `NULL`. If a `TOO_MANY_ROWS` exception occurs, indicating that the initial `SELECT` statement found more than one row matching the `p_party_id` (despite the `ROWNUM = 1` clause, which would prevent the exception from being raised by the `SELECT` itself, but rather by the implicit assumption of a single row return for `INTO` clause without `ROWNUM=1` or if `ROWNUM=1` was not effective in preventing multiple rows from being considered by the database engine before the `INTO` clause), the function executes a second `SELECT` statement. This second `SELECT` statement is identical to the first: it selects the `FORM_STATUS_CODE` into `v_form_status` from the `PARTY_FORMS` table where `PARTY_ID` matches `p_party_id` and `ROWNUM = 1`. This ensures that even if multiple rows exist for the given `p_party_id`, only the `FORM_STATUS_CODE` from the first encountered row is retrieved and subsequently returned by the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_party_form_status(p_party_id NUMBER) RETURN VARCHAR2 IS\n  v_form_status VARCHAR2(255);\nBEGIN\n  SELECT FORM_STATUS_CODE INTO v_form_status\n  FROM PARTY_FORMS\n  WHERE PARTY_ID = p_party_id\n  AND ROWNUM = 1;\n  \n  RETURN v_form_status;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN TOO_MANY_ROWS THEN\n    -- Get the first status if multiple exist\n    SELECT FORM_STATUS_CODE INTO v_form_status\n    FROM PARTY_FORMS\n    WHERE PARTY_ID = p_party_id\n    AND ROWNUM = 1;\n    RETURN v_form_status;\nEND;",
    "database_name": "e_government",
    "tables": [
      "ADDRESSES",
      "INDIVIDUALS",
      "ORGANIZATIONS",
      "ORGANIZATION_CONTACT_INDIVIDUALS",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "SELECT get_party_form_status(2) FROM dual",
      "SELECT get_party_form_status(15) FROM dual",
      "SELECT get_party_form_status(8) FROM dual",
      "SELECT get_party_form_status(10) FROM dual",
      "SELECT get_party_form_status(4) FROM dual"
    ],
    "summary": "Create a function named get_party_form_status that accepts a NUMBER parameter p_party_id and returns a VARCHAR2. It queries the FORM_STATUS_CODE from the PARTY_FORMS table where PARTY_ID matches the parameter, returning the first row's value. Handle NO_DATA_FOUND by returning NULL and TOO_MANY_ROWS by re-querying with ROWNUM = 1.",
    "natural_language": "Function get_party_form_status(p_party_id NUMBER) returns VARCHAR2. Fetch FORM_STATUS_CODE from PARTY_FORMS for given PARTY_ID. Return first row's value. On NO_DATA_FOUND return NULL. On TOO_MANY_ROWS requery with ROWNUM=1.",
    "id": 15,
    "generated_ir": "Write an Oracle PL/SQL function named `get_party_form_status` that accepts a single input parameter, `p_party_id`, which is of data type `NUMBER` and represents a unique identifier for a party. This function is designed to return a `VARCHAR2` value, specifically a form status code. Upon execution, the function initializes a local variable `v_form_status` of type `VARCHAR2` with a maximum length of 255 characters. The primary operation involves attempting to retrieve a `FORM_STATUS_CODE` from the `PARTY_FORMS` table. This retrieval is performed by selecting the `FORM_STATUS_CODE` column and storing its value into the `v_form_status` variable. The selection is constrained by two conditions: first, the `PARTY_ID` column in the `PARTY_FORMS` table must match the value provided in the `p_party_id` input parameter; second, `ROWNUM = 1` is used to ensure that only the first row encountered that satisfies the `PARTY_ID` condition is considered, effectively limiting the result set to a single row. After this selection, the function immediately returns the value stored in `v_form_status`. The function includes exception handling for two specific scenarios. If a `NO_DATA_FOUND` exception occurs, meaning no rows in the `PARTY_FORMS` table match the provided `p_party_id`, the function returns `NULL`. If a `TOO_MANY_ROWS` exception occurs, indicating that the initial `SELECT` statement found more than one row matching the `p_party_id` (despite the `ROWNUM = 1` clause, which would prevent the exception from being raised by the `SELECT` itself, but rather by the implicit assumption of a single row return for `INTO` clause without `ROWNUM=1` or if `ROWNUM=1` was not effective in preventing multiple rows from being considered by the database engine before the `INTO` clause), the function executes a second `SELECT` statement. This second `SELECT` statement is identical to the first: it selects the `FORM_STATUS_CODE` into `v_form_status` from the `PARTY_FORMS` table where `PARTY_ID` matches `p_party_id` and `ROWNUM = 1`. This ensures that even if multiple rows exist for the given `p_party_id`, only the `FORM_STATUS_CODE` from the first encountered row is retrieved and subsequently returned by the function."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_country` that accepts a single input parameter, `p_member_id`, which is of data type `NUMBER`. This function is designed to retrieve the country associated with a specific member from the `MEMBER` table. Inside the function's `BEGIN` block, a local variable `v_country` of data type `VARCHAR2` with a maximum length of 255 characters is declared to temporarily store the retrieved country name. The function then executes a `SELECT` statement to query the `MEMBER` table. This `SELECT` statement retrieves the value from the `COUNTRY` column and stores it into the `v_country` variable. The selection is filtered by a `WHERE` clause, which specifies that only the row where the `MEMBER_ID` column's value matches the input parameter `p_member_id` should be considered. After successfully retrieving the country into `v_country`, the function returns the value stored in `v_country` as its result, which is of data type `VARCHAR2`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_country(p_member_id NUMBER) RETURN VARCHAR2 IS\n    v_country VARCHAR2(255);\nBEGIN\n    SELECT COUNTRY INTO v_country FROM MEMBER WHERE MEMBER_ID = p_member_id;\n    RETURN v_country;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_member_country(1) FROM dual",
      "SELECT get_member_country(2) FROM dual",
      "SELECT get_member_country(3) FROM dual",
      "SELECT get_member_country(4) FROM dual",
      "SELECT get_member_country(10) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_member_country that accepts a member ID (NUMBER) and returns a VARCHAR2. It should query the MEMBER table to retrieve and return the COUNTRY value for the specified member.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_member_country? It should take a member ID (that's a NUMBER) and spit back a VARCHAR2. Basically, it needs to look up that member in the MEMBER table and grab their COUNTRY for us.",
    "id": 16,
    "generated_ir": "Write an Oracle PL/SQL function named get_member_country that accepts a single input parameter, p_member_id, of type NUMBER, which represents the identifier of a member. The function returns a value of type VARCHAR2, specifically the country associated with the given member. The function begins by declaring a local variable, v_country, of type VARCHAR2(255), which will store the country value retrieved from the database. The function then executes a SELECT statement to retrieve the COUNTRY column from the MEMBER table, specifically from the row where the MEMBER_ID column matches the value provided in the p_member_id parameter. The result of this SELECT operation is stored in the v_country variable. After the SELECT operation, the function returns the value stored in v_country, which represents the country of the specified member. If no member with the given ID exists in the MEMBER table, the SELECT statement will not return any rows, resulting in a NO_DATA_FOUND exception. The function does not explicitly handle this exception, so it will propagate to the caller, indicating that the member ID was not found."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_sculpture_medium_count that accepts two input parameters: a numeric parameter p_artist_id and a string parameter p_medium, and returns a numeric value. The function declares a local numeric variable v_count. The function executes a SELECT statement that queries the SCULPTURES table, using the COUNT(*) aggregate function to calculate the total number of rows. The SELECT statement includes a WHERE clause with two conditions joined by a logical AND operator: the first condition checks that the SCULPTORID column in the SCULPTURES table is equal to the input parameter p_artist_id, and the second condition checks that the MEDIUM column in the SCULPTURES table is equal to the input parameter p_medium. The result of the COUNT(*) operation is stored into the local variable v_count using an INTO clause. The function then concludes by returning the value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_sculpture_medium_count(p_artist_id NUMBER, p_medium VARCHAR2) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_count\n    FROM SCULPTURES\n    WHERE SCULPTORID = p_artist_id AND MEDIUM = p_medium;\n    RETURN v_count;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT get_artist_sculpture_medium_count(222, 'bronze') FROM DUAL",
      "SELECT get_artist_sculpture_medium_count(555, 'bronze') FROM DUAL",
      "SELECT get_artist_sculpture_medium_count(111, 'bronze') FROM DUAL",
      "SELECT get_artist_sculpture_medium_count(222, 'wood') FROM DUAL",
      "SELECT get_artist_sculpture_medium_count(555, 'marble') FROM DUAL"
    ],
    "summary": "Create a function named get_artist_sculpture_medium_count that returns a number. It takes an artist ID (number) and a medium (string) as input. The function should count and return the number of rows in the SCULPTURES table where the SCULPTORID matches the given artist ID and the MEDIUM matches the given medium.",
    "natural_language": "How many sculptures by a specific artist, identified by their ID, are made using a specified medium?",
    "id": 17,
    "generated_ir": "Write an Oracle PL/SQL function named `get_artist_sculpture_medium_count` that accepts two input parameters: `p_artist_id` of type `NUMBER`, which represents the unique identifier of an artist, and `p_medium` of type `VARCHAR2`, which represents the specified sculpture medium. The function returns a single value of data type `NUMBER`, representing the count of sculptures created by the specified artist using the specified medium.\n\nUpon execution, the function declares a single local variable: `v_count` of type `NUMBER` to store the computed count of sculptures.\n\nThe function then performs a single `SELECT` operation. The `SELECT` statement uses the `COUNT` aggregate function to calculate the number of rows. It queries the `SCULPTURES` table, filtering records where two conditions are met simultaneously using an `AND` operator. The first condition checks that the `SCULPTORID` column in the `SCULPTURES` table matches the input parameter `p_artist_id`. The second condition checks that the `MEDIUM` column in the `SCULPTURES` table matches the input parameter `p_medium`. The result of this count aggregation is stored directly into the `v_count` variable.\n\nFollowing the data retrieval and aggregation, the function returns the value stored in the `v_count` variable, which represents the total number of sculptures by the specified artist made from the specified medium."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_song_instrument_count that accepts a single parameter, p_song_id, which is of type NUMBER and represents the unique identifier of a song. The function is designed to return a NUMBER that indicates the count of instruments associated with the specified song. Within the function, a local variable v_instrument_count of type NUMBER is initialized to zero to store the result of the count operation. The function performs a SELECT statement that counts the total number of rows in the INSTRUMENTS table where the SONGID column matches the value of the input parameter p_song_id. The result of this count operation is stored into the local variable v_instrument_count using the INTO clause. Finally, the function returns the value of v_instrument_count, which represents the number of instruments linked to the song identified by p_song_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_song_instrument_count(p_song_id NUMBER) RETURN NUMBER IS\n    v_instrument_count NUMBER := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_instrument_count FROM INSTRUMENTS WHERE SONGID = p_song_id;\n    RETURN v_instrument_count;\nEND;",
    "database_name": "music_2",
    "tables": [
      "ALBUMS",
      "SONGS",
      "TRACKLISTS",
      "INSTRUMENTS",
      "PERFORMANCE",
      "VOCALS"
    ],
    "call_sqls": [
      "SELECT get_song_instrument_count(1) FROM DUAL",
      "SELECT get_song_instrument_count(2) FROM DUAL",
      "SELECT get_song_instrument_count(3) FROM DUAL",
      "SELECT get_song_instrument_count(4) FROM DUAL",
      "SELECT get_song_instrument_count(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_song_instrument_count that accepts a song ID (NUMBER) and returns the total count of instruments associated with that song from the INSTRUMENTS table.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_song_instrument_count? It should take a song's ID (as a NUMBER) and spit back how many instruments from the INSTRUMENTS table are linked to that tune.",
    "id": 18,
    "generated_ir": "Write an Oracle PL/SQL function named get_song_instrument_count that accepts one input parameter p_song_id of type NUMBER. The function returns a NUMBER data type. Its purpose is to count and return the total number of distinct instruments associated with a specific song, as identified by the song ID parameter. The function begins by declaring a local variable v_instrument_count of type NUMBER to store the result. It then executes a SELECT statement that queries the INSTRUMENTS table. The SELECT statement uses the COUNT aggregate function on the INSTRUMENT column to calculate the total number of instrument entries. The query includes a WHERE clause with a single condition: the SONGID column in the INSTRUMENTS table must exactly match the value of the input parameter p_song_id. The result of this count operation is stored directly into the v_instrument_count variable. Finally, the function returns the value stored in v_instrument_count, which represents the total count of instruments for the given song ID."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_book_title_by_review_rank that accepts a single input parameter p_rank of type NUMBER and returns a VARCHAR2 value, where the function's logic is to query the database to retrieve a book title based on a specific review ranking; the function declares a local variable v_title of type VARCHAR2 with a maximum length of 255 characters to hold the result, then executes a SELECT statement that fetches a value into v_title from the TITLE column of the BOOK table, using a subquery in the WHERE clause to determine which book to select; the subquery selects a BOOK_ID from the REVIEW table where the RANK column exactly matches the input parameter p_rank, and this BOOK_ID value is then used in the outer query's condition BOOK.BOOK_ID = (subquery result) to locate the corresponding book record; after the SELECT INTO operation populates v_title, the function returns the value stored in v_title as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_book_title_by_review_rank(p_rank IN NUMBER) RETURN VARCHAR2\nIS\n    v_title VARCHAR2(255);\nBEGIN\n    SELECT TITLE INTO v_title FROM BOOK WHERE BOOK_ID = (SELECT BOOK_ID FROM REVIEW WHERE RANK = p_rank);\n    RETURN v_title;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT get_book_title_by_review_rank(16) FROM dual",
      "SELECT get_book_title_by_review_rank(25) FROM dual",
      "SELECT get_book_title_by_review_rank(26) FROM dual",
      "SELECT get_book_title_by_review_rank(10) FROM dual",
      "SELECT get_book_title_by_review_rank(20) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_book_title_by_review_rank that accepts a rank number and returns the title of the book with a review matching that rank.",
    "natural_language": "Develop a PL/SQL function, which should be named get_book_title_by_review_rank, that is designed to take a single input parameter representing a specific rank number; this function must then meticulously retrieve and return the precise title of the book which possesses a review that has been assigned the exact rank provided.",
    "id": 19,
    "generated_ir": "Write an Oracle PL/SQL function named get_book_title_by_review_rank that accepts one input parameter: p_rank of type NUMBER. The function returns a single VARCHAR2 value, which is the title of a book. The function is designed to retrieve the title of a book that has a review with a specific rank.\n\nThe function begins by declaring a local variable v_title of type VARCHAR2(255) to hold the book title retrieved from the database.\n\nThe core logic of the function is a SELECT statement that queries the database. This SELECT statement performs an implicit inner join between the BOOK table and the REVIEW table. The join condition is based on matching the BOOK_ID column from the BOOK table with the BOOK_ID column from the REVIEW table.\n\nThe SELECT statement includes a WHERE clause that filters the joined result set. The filter condition specifies that the RANK column from the REVIEW table must be exactly equal to the value of the input parameter p_rank.\n\nFrom this filtered result set, the query selects a single column: the TITLE column from the BOOK table. The selected value is fetched INTO the local variable v_title.\n\nAfter the SELECT operation completes, the function returns the value stored in the v_title variable. This is the title of the book associated with the review that has the specified rank. If no review matches the provided rank, the function will raise a NO_DATA_FOUND exception, which is the default behavior for a SELECT INTO statement that returns no rows. The function does not contain explicit exception handling for this case."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_customer_order_summary` that accepts a single input parameter, `p_customer_id`, which is of data type `NUMBER` and represents the unique identifier for a customer. This function is designed to return a `VARCHAR2` string indicating a summary category for the customer's order activity.\n\nInside the function, three local variables are declared: `v_order_count` of type `NUMBER` to store the distinct count of orders, `v_total_quantity` of type `NUMBER` to store the sum of product quantities across all order items, and `v_avg_unit_price` of type `NUMBER` to store the average unit price of products in the customer's orders.\n\nThe core logic begins with a `SELECT` statement that queries data from three tables: `orders` (aliased as `o`), `order_items` (aliased as `oi`), and `products` (aliased as `p`). This query performs a `LEFT JOIN` between `orders` and `order_items` on the condition `o.order_id = oi.order_id`, linking orders to their respective items. Subsequently, it performs another `LEFT JOIN` between `order_items` and `products` on the condition `oi.product_id = p.product_id`, connecting order items to the details of the products they contain.\n\nThe `WHERE` clause filters the results to include only orders associated with the `p_customer_id` provided as input to the function, specifically `o.customer_id = p_customer_id`.\n\nThe `SELECT` list calculates three aggregate values:\n1. `COUNT(DISTINCT o.order_id)`: This counts the number of unique orders placed by the specified customer.\n2. `NVL(SUM(TO_NUMBER(oi.product_quantity)), 0)`: This calculates the sum of `product_quantity` from the `order_items` table. The `TO_NUMBER` function is used to explicitly convert `oi.product_quantity` to a numeric type before summation, ensuring correct arithmetic if the column is not already numeric. The `NVL` function ensures that if `SUM` returns `NULL` (e.g., if there are no order items for the customer), the result for `v_total_quantity` will be `0` instead of `NULL`.\n3. `NVL(AVG(p.unit_price), 0)`: This calculates the average `unit_price` from the `products` table for all products included in the customer's orders. The `NVL` function ensures that if `AVG` returns `NULL` (e.g., if there are no products associated with the order items), the result for `v_avg_unit_price` will be `0` instead of `NULL`.\n\nThese three calculated values are then assigned to the respective local variables: `v_order_count`, `v_total_quantity`, and `v_avg_unit_price`.\n\nFollowing the data retrieval, a series of `IF-ELSIF-ELSE` conditional statements determine the customer's order summary category:\n1. `IF v_order_count = 0 THEN RETURN 'NO_ORDERS';`: If the `v_order_count` is zero, meaning the customer has placed no orders, the function immediately returns the string 'NO_ORDERS'.\n2. `ELSIF v_total_quantity > 20 THEN RETURN 'HIGH_VOLUME';`: If the customer has placed at least one order (`v_order_count` is not zero) and the `v_total_quantity` of all products ordered exceeds 20, the function returns the string 'HIGH_VOLUME'.\n3. `ELSIF v_avg_unit_price > 500 THEN RETURN 'PREMIUM';`: If the customer has placed at least one order, the total quantity is not greater than 20, and the `v_avg_unit_price` of products ordered exceeds 500, the function returns the string 'PREMIUM'.\n4. `ELSE RETURN 'STANDARD';`: If none of the above conditions are met (i.e., the customer has placed at least one order, the total quantity is 20 or less, and the average unit price is 500 or less), the function returns the string 'STANDARD'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_order_summary(p_customer_id NUMBER) RETURN VARCHAR2 IS\n    v_order_count NUMBER;\n    v_total_quantity NUMBER;\n    v_avg_unit_price NUMBER;\nBEGIN\n    SELECT COUNT(DISTINCT o.order_id), \n           NVL(SUM(TO_NUMBER(oi.product_quantity)), 0),\n           NVL(AVG(p.unit_price), 0)\n    INTO v_order_count, v_total_quantity, v_avg_unit_price\n    FROM orders o\n    LEFT JOIN order_items oi ON o.order_id = oi.order_id\n    LEFT JOIN products p ON oi.product_id = p.product_id\n    WHERE o.customer_id = p_customer_id;\n    \n    IF v_order_count = 0 THEN\n        RETURN 'NO_ORDERS';\n    ELSIF v_total_quantity > 20 THEN\n        RETURN 'HIGH_VOLUME';\n    ELSIF v_avg_unit_price > 500 THEN\n        RETURN 'PREMIUM';\n    ELSE\n        RETURN 'STANDARD';\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_customer_order_summary(1) FROM DUAL",
      "SELECT get_customer_order_summary(5) FROM DUAL",
      "SELECT get_customer_order_summary(7) FROM DUAL",
      "SELECT get_customer_order_summary(12) FROM DUAL",
      "SELECT get_customer_order_summary(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_customer_order_summary that accepts a p_customer_id NUMBER and returns a VARCHAR2. It calculates the customer's distinct order count, total product quantity (converted to NUMBER), and average product unit price. Return 'NO_ORDERS' if order count is 0, 'HIGH_VOLUME' if total quantity > 20, 'PREMIUM' if average price > 500, else 'STANDARD'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_customer_order_summary? It needs to take a customer ID (as a NUMBER) and spit back a VARCHAR2. Basically, it should figure out: how many different orders the customer has, the total number of products they've bought (as a NUMBER), and the average price per item. If they haven't placed any orders, just return 'NO_ORDERS'. If they've bought more than 20 items total, call it 'HIGH_VOLUME'. If their average price is over 500 bucks, that's 'PREMIUM'. Otherwise, just tag it as 'STANDARD'.",
    "id": 20,
    "generated_ir": "Write an Oracle PL/SQL function named get_customer_order_summary that operates on the customers_and_invoices database. The function accepts a single input parameter, p_customer_id, of type NUMBER, representing the unique identifier of a customer. The function returns a VARCHAR2 string that categorizes the customer's order activity based on specific criteria.\n\nWithin the function, several local variables are declared: v_order_count of type NUMBER to store the total number of distinct orders placed by the customer; v_total_items of type NUMBER to store the total quantity of products purchased across all orders; v_total_price of type NUMBER to store the cumulative monetary value of all purchased items before any tax considerations; v_avg_price of type NUMBER to store the calculated average price per item; and v_result of type VARCHAR2 to hold the final categorization string to be returned.\n\nThe function's logic begins by executing a SELECT statement that queries the ORDERS table, aliased as o, and the ORDER_ITEMS and PRODUCTS tables, aliased as oi and p respectively. It performs a join operation: the ORDERS table is joined with the ORDER_ITEMS table on the condition that o.ORDER_ID equals oi.ORDER_ID. The result is then joined with the PRODUCTS table on the condition that oi.PRODUCT_ID equals p.PRODUCT_ID. The SELECT statement uses aggregation functions to calculate three key metrics from the joined dataset where the o.CUSTOMER_ID matches the input parameter p_customer_id. It calculates the count of distinct o.ORDER_ID values, storing it into v_order_count. It calculates the sum of the oi.PRODUCT_QUANTITY column (which is of VARCHAR2 type and must be explicitly converted to a NUMBER using the TO_NUMBER function for arithmetic operations), storing it into v_total_items. It calculates the sum of the expression (TO_NUMBER(oi.PRODUCT_QUANTITY) * p.UNIT_PRICE), which represents the total extended price for each order item, storing it into v_total_price. This query uses the INTO clause to populate the three variables v_order_count, v_total_items, and v_total_price simultaneously.\n\nFollowing the data retrieval, the function implements control flow logic using IF-THEN-ELSIF statements. The first condition checks if v_order_count is equal to 0. If true, the function sets the v_result variable to the string 'NO_ORDERS'. If the customer has placed orders (v_order_count > 0), the function proceeds to calculate the average price per item by dividing v_total_price by v_total_items and assigns the result to v_avg_price. It then evaluates two subsequent conditions. It checks if v_total_items is greater than 20. If true, it sets v_result to 'HIGH_VOLUME'. If not, it then checks if v_avg_price is greater than 500. If true, it sets v_result to 'PREMIUM'. If neither of these conditions is met (i.e., total items are 20 or less and the average price is 500 or less), the function sets v_result to 'STANDARD'.\n\nFinally, the function returns the value stored in the v_result variable, which contains the appropriate categorization string ('NO_ORDERS', 'HIGH_VOLUME', 'PREMIUM', or 'STANDARD') based on the analyzed order data for the specified customer."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_average_treatment_cost` that is designed to return a single numeric value representing the average cost of all treatments recorded in the database. This function does not accept any input parameters. Internally, it declares a local variable named `v_avg_cost` of data type `NUMBER` to temporarily store the calculated average. The core operation involves executing a `SELECT` statement to compute the average of the `COST_OF_TREATMENT` column from all rows within the `TREATMENTS` table. The result of this aggregation, which is the average cost, is then immediately stored into the `v_avg_cost` variable. Finally, the function returns the value held by `v_avg_cost` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_treatment_cost RETURN NUMBER IS\n    v_avg_cost NUMBER;\nBEGIN\n    SELECT AVG(COST_OF_TREATMENT) INTO v_avg_cost FROM TREATMENTS;\n    RETURN v_avg_cost;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "SELECT calculate_average_treatment_cost FROM DUAL",
      "SELECT calculate_average_treatment_cost() FROM DUAL",
      "DECLARE\n  v_avg NUMBER;\nBEGIN\n  v_avg := calculate_average_treatment_cost;\n  DBMS_OUTPUT.PUT_LINE('Average cost: ' || v_avg);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average treatment cost: ' || calculate_average_treatment_cost);\nEND;",
      "SELECT TREATMENT_ID, DOG_ID, COST_OF_TREATMENT, calculate_average_treatment_cost AS AVG_COST FROM TREATMENTS WHERE ROWNUM <= 3"
    ],
    "summary": "Create a PL/SQL function named calculate_average_treatment_cost that returns the average cost from the COST_OF_TREATMENT column in the TREATMENTS table.",
    "natural_language": "What is the average cost from the COST_OF_TREATMENT column in the TREATMENTS table? Create a PL/SQL function named calculate_average_treatment_cost to return this value.",
    "id": 21,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_average_treatment_cost that does not accept any input parameters and returns a NUMBER value representing the average cost of treatments. The function begins by declaring a local NUMBER variable, v_average_cost, to store the computed average. It then executes a SELECT statement on the TREATMENTS table to calculate the average of the COST_OF_TREATMENT column using the AVG aggregate function. The result of this aggregation is stored into the v_average_cost variable. Since there is no filtering condition, the average is computed across all rows in the TREATMENTS table. Finally, the function returns the value stored in v_average_cost."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_oldest_institution_year that returns a NUMBER type value. This function does not take any input parameters. It begins by declaring a local variable v_oldest_year of type NUMBER, which will be used to store the result of a query. The function then executes a SELECT statement to retrieve the minimum value from the FOUNDED column of the INSTITUTION table, which represents the year an institution was founded. The result of this query is stored into the v_oldest_year variable. The function then returns the value of v_oldest_year, but if v_oldest_year is NULL, it returns 0 instead, using the NVL function to handle this potential NULL value. The function includes an exception handling block to manage any errors that may occur during execution. If a NO_DATA_FOUND exception is raised, indicating that the query returned no rows, the function returns 0. For any other exceptions, the function re-raises the exception to be handled by the calling environment.",
    "plsql": "CREATE OR REPLACE FUNCTION get_oldest_institution_year\nRETURN NUMBER\nIS\n    v_oldest_year NUMBER;\nBEGIN\n    SELECT MIN(FOUNDED)\n    INTO v_oldest_year\n    FROM INSTITUTION;\n    \n    RETURN NVL(v_oldest_year, 0);\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 0;\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "institution_sports",
    "tables": [
      "CHAMPIONSHIP",
      "INSTITUTION"
    ],
    "call_sqls": [
      "SELECT get_oldest_institution_year FROM DUAL",
      "SELECT get_oldest_institution_year() FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Oldest Year: ' || get_oldest_institution_year);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_oldest_institution_year;\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "SELECT i.name, i.founded, get_oldest_institution_year AS oldest_year\nFROM institution i\nWHERE i.founded = get_oldest_institution_year"
    ],
    "summary": "Create a PL/SQL function named get_oldest_institution_year with no parameters that returns a NUMBER. It finds the minimum FOUNDED year from the INSTITUTION table. Return 0 if the result is NULL or if NO_DATA_FOUND is raised. Re-raise any other exceptions.",
    "natural_language": "Write a PL/SQL function called get_oldest_institution_year that takes no inputs and gives back a NUMBER. It should figure out the earliest, or maybe the most long-standing, FOUNDED year from the INSTITUTION table. If nothing comes up or if it hits a certain kind of missing data error, just hand back 0. But if some other unexpected problem pops up, let that error go through as usual.",
    "id": 22,
    "generated_ir": "Write an Oracle PL/SQL function named `get_oldest_institution_year` that takes no input parameters and returns a value of type `NUMBER`. The function is designed to retrieve the earliest (minimum) `FOUNDED` year from the `INSTITUTION` table. The function declares a local variable `v_oldest_year` of type `NUMBER` to temporarily store the result of the query. The core logic involves executing a `SELECT` statement that uses the `MIN` aggregation function on the `FOUNDED` column from the `INSTITUTION` table. The result of this `MIN` aggregation is stored into the `v_oldest_year` variable using an `INTO` clause. The function then returns the value of `v_oldest_year`. To handle specific error conditions, the function includes an exception handling block. If a `NO_DATA_FOUND` exception is raised (which would occur if the `INSTITUTION` table is empty or the `MIN` aggregation returns `NULL`), the function catches this exception and returns `0`. Additionally, if a `VALUE_ERROR` exception is raised (which could occur due to data type conversion issues or other data-related errors), the function also catches this exception and returns `0`. For any other unanticipated exceptions, the exception handling block is structured to allow them to propagate normally by not catching them, meaning the function will raise those errors to the caller."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_festival_volume_total that accepts a single input parameter p_category of type VARCHAR2 and returns a value of type NUMBER. The function declares two local NUMBER variables: v_total, initialized to 0, and v_multiplier, initialized to 2. The function executes a SELECT statement that queries the MUSIC_FESTIVAL table, applying a filter condition where the CATEGORY column equals the input parameter p_category. Within this query, the SQL aggregate function SUM is applied to the VOLUME column for all rows matching the condition, and the NVL function is used to convert a potential NULL result from the SUM operation to the numeric value 0. The result of this SELECT statement is stored into the local variable v_total. The function's return value is computed by multiplying the retrieved v_total by the constant multiplier v_multiplier.",
    "plsql": "CREATE OR REPLACE FUNCTION get_festival_volume_total(p_category VARCHAR2) RETURN NUMBER IS\n    v_total NUMBER := 0;\n    v_multiplier NUMBER := 2;\nBEGIN\n    SELECT NVL(SUM(VOLUME), 0) INTO v_total FROM MUSIC_FESTIVAL WHERE CATEGORY = p_category;\n    RETURN v_total * v_multiplier;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_festival_volume_total('Best Song') FROM DUAL",
      "SELECT get_festival_volume_total('Best Lyrics') FROM DUAL",
      "SELECT get_festival_volume_total('Best Album') FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total: ' || get_festival_volume_total('Best Song'));\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_festival_volume_total('Best Lyrics');\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;"
    ],
    "summary": "Create a PL/SQL function named get_festival_volume_total that accepts a category (VARCHAR2) and returns a NUMBER. The function should query the MUSIC_FESTIVAL table, sum the VOLUME for the given category (defaulting to 0 if NULL), and return the total multiplied by 2.",
    "natural_language": "Construct a PL/SQL function called get_festival_volume_total, which is designed to receive a single input parameter of type VARCHAR2 representing a music category and will output a value of type NUMBER. This function should perform a detailed query against the MUSIC_FESTIVAL table, meticulously calculating the sum of all VOLUME entries that precisely match the specified category. To ensure robustness, if the summed total is found to be NULL, it must gracefully default to zero. Finally, the function must return this carefully derived total amount after it has been distinctly multiplied by two.",
    "id": 23,
    "generated_ir": "Write an Oracle PL/SQL function named get_festival_volume_total that accepts a single input parameter p_category of type VARCHAR2 representing a music category, and returns a single numeric value of type NUMBER. Within the function, a local variable v_total_volume of type NUMBER is declared to hold the intermediate sum of volume entries, and a local variable v_final_total of type NUMBER is declared to hold the final result after multiplication. The function's logic begins by executing a SELECT statement that queries the MUSIC_FESTIVAL table. This SELECT statement uses the SUM aggregate function on the VOLUME column to calculate the total volume for all rows where the CATEGORY column exactly matches the input parameter p_category. The result of this summation is stored directly into the local variable v_total_volume. Following the SELECT operation, the function uses a conditional check: if the value in v_total_volume is NULL, it assigns the value 0 to v_total_volume. After this NULL-handling step, the function calculates the final result by multiplying the value in v_total_volume by 2 and stores the product in the variable v_final_total. Finally, the function returns the value stored in v_final_total."
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_CUSTOMER_PAYMENT_METHOD that accepts a single input parameter named CUSTOMER_ID_IN of the NUMBER data type and returns a value of the VARCHAR2 data type. The function declares a local variable named PAYMENT_METHOD_OUT of type VARCHAR2 with a maximum length of 255 characters. The function executes a SELECT statement that queries the PAYMENT_METHOD column from the CUSTOMERS table. The query applies the TO_SINGLE_BYTE function to the PAYMENT_METHOD column value, which converts any multi-byte characters in the string to their single-byte equivalents. The query includes a WHERE clause condition that filters the result to only the row where the CUSTOMER_ID column value is equal to the input parameter CUSTOMER_ID_IN. The result of this query is then stored into the local variable PAYMENT_METHOD_OUT. Finally, the function returns the value stored in the PAYMENT_METHOD_OUT variable.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_CUSTOMER_PAYMENT_METHOD(CUSTOMER_ID_IN NUMBER) RETURN VARCHAR2 IS\n  PAYMENT_METHOD_OUT VARCHAR2(255);\nBEGIN\n  SELECT TO_SINGLE_BYTE(PAYMENT_METHOD)\n  INTO PAYMENT_METHOD_OUT\n  FROM CUSTOMERS\n  WHERE CUSTOMER_ID = CUSTOMER_ID_IN;\n  RETURN PAYMENT_METHOD_OUT;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "CUSTOMERS",
      "ORDER_DELIVERIES",
      "EMPLOYEES",
      "TRUCKS"
    ],
    "call_sqls": [
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(1) FROM DUAL",
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(2) FROM DUAL",
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(3) FROM DUAL",
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(10) FROM DUAL",
      "SELECT GET_CUSTOMER_PAYMENT_METHOD(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_CUSTOMER_PAYMENT_METHOD that takes a customer ID (NUMBER) and returns a VARCHAR2. It retrieves the PAYMENT_METHOD from the CUSTOMERS table for the given ID, converting any multi-byte characters to single-byte, and returns the result.",
    "natural_language": "Write a function GET_CUSTOMER_PAYMENT_METHOD that returns a VARCHAR2. It takes a customer ID, gets the PAYMENT_METHOD from CUSTOMERS for that ID, converts multi-byte to single-byte, and returns it.",
    "id": 24,
    "generated_ir": "Write an Oracle PL/SQL function named GET_CUSTOMER_PAYMENT_METHOD that is designed to return a single value of type VARCHAR2. This function accepts one input parameter: p_customer_id, which is of data type NUMBER and is intended to identify a specific customer. Within the function, a local variable v_payment_method_raw of type VARCHAR2 is declared to temporarily store the raw payment method value retrieved from the database. A second local variable v_payment_method_converted of type VARCHAR2 is declared to store the converted value after character set transformation. The core operation of this function involves executing a SELECT statement. This SELECT statement queries the CUSTOMERS table, specifically targeting the PAYMENT_METHOD column, and retrieves the value into the v_payment_method_raw variable for the row where the CUSTOMER_ID matches the provided p_customer_id input parameter. Following the data retrieval, the function performs a character set conversion on the value stored in v_payment_method_raw. It uses the CONVERT function to transform the string from a multi-byte character set to a single-byte character set. The specific conversion is from the AL32UTF8 character set (a common multi-byte Unicode encoding) to the US7ASCII character set (a single-byte encoding). The result of this CONVERT operation is stored in the v_payment_method_converted variable. Finally, the function returns the value stored in v_payment_method_converted as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_sculpture_year` that accepts a single input parameter named `sculpture_id` of data type `NUMBER`. This function is designed to return a `VARCHAR2` string. The function begins by declaring a local variable named `sculpture_year` of data type `NUMBER`. The core operation involves executing a `SELECT` statement to retrieve the value from the `YEAR` column of the `SCULPTURES` table. This retrieval is conditional, specifically targeting the row where the value in the `SCULPTUREID` column matches the value provided in the `sculpture_id` input parameter. The retrieved `YEAR` value is then assigned to the `sculpture_year` local variable. Following this data retrieval, the function proceeds with a conditional logic block: it checks if the value stored in `sculpture_year` is strictly greater than `1900`. If this condition evaluates to true, the function immediately returns the string literal `'Modern'`. Otherwise, if the condition `sculpture_year > 1900` evaluates to false (meaning `sculpture_year` is less than or equal to `1900`), the function returns the string literal `'Classical'`.",
    "plsql": "CREATE OR REPLACE FUNCTION check_sculpture_year(sculpture_id NUMBER) RETURN VARCHAR2 IS\n  sculpture_year NUMBER;\nBEGIN\n  SELECT YEAR INTO sculpture_year FROM SCULPTURES WHERE SCULPTUREID = sculpture_id;\n  IF sculpture_year > 1900 THEN\n    RETURN 'Modern';\n  ELSE\n    RETURN 'Classical';\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT check_sculpture_year(20) FROM DUAL",
      "SELECT check_sculpture_year(21) FROM DUAL",
      "SELECT check_sculpture_year(22) FROM DUAL",
      "SELECT SCULPTUREID, TITLE, check_sculpture_year(SCULPTUREID) AS ERA FROM SCULPTURES",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE(check_sculpture_year(20));\nEND;"
    ],
    "summary": "Create a PL/SQL function named `check_sculpture_year` that takes a `sculpture_id` (NUMBER) and returns a VARCHAR2. It retrieves the sculpture's `YEAR` from the `SCULPTURES` table. If the year is greater than 1900, return 'Modern'; otherwise, return 'Classical'.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `check_sculpture_year`? It should take a `sculpture_id` (that's a NUMBER) and spit back a VARCHAR2. Basically, it needs to grab the sculpture's `YEAR` from the `SCULPTURES` table. If the year's after 1900, just say 'Modern'; if it's 1900 or older, call it 'Classical'.",
    "id": 25,
    "generated_ir": "Write an Oracle PL/SQL function named `check_sculpture_year` that accepts a single input parameter named `sculpture_id` of data type `NUMBER`. This function is designed to return a `VARCHAR2` string. The function begins by declaring a local variable named `sculpture_year` of data type `NUMBER`. The core operation involves executing a `SELECT` statement to retrieve the value from the `YEAR` column of the `SCULPTURES` table. This retrieval is conditional, specifically targeting the row where the value in the `SCULPTUREID` column matches the value provided in the `sculpture_id` input parameter. The retrieved `YEAR` value is then assigned to the `sculpture_year` local variable. Following this data retrieval, the function proceeds with a conditional logic block: it checks if the value stored in `sculpture_year` is strictly greater than `1900`. If this condition evaluates to true, the function immediately returns the string literal `'Modern'`. Otherwise, if the condition `sculpture_year > 1900` evaluates to false (meaning `sculpture_year` is less than or equal to `1900`), the function returns the string literal `'Classical'`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_address_country that accepts a single parameter, p_address_id, which is of type NUMBER and represents the unique identifier of an address. The function is designed to return a value of type VARCHAR2, specifically the country associated with the given address ID. Within the function, a local variable v_country of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the country name. The function executes a SELECT statement to retrieve the COUNTRY column from the ADDRESSES table, where the ADDRESS_ID column matches the value of the input parameter p_address_id. The retrieved country name is stored in the v_country variable. Finally, the function returns the value stored in v_country, which is the country name corresponding to the specified address ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_address_country(p_address_id NUMBER) RETURN VARCHAR2 IS\n  v_country VARCHAR2(255);\nBEGIN\n  SELECT COUNTRY INTO v_country\n  FROM ADDRESSES\n  WHERE ADDRESS_ID = p_address_id;\n  RETURN v_country;\nEND;",
    "database_name": "e_government",
    "tables": [
      "ADDRESSES",
      "INDIVIDUALS",
      "ORGANIZATIONS",
      "ORGANIZATION_CONTACT_INDIVIDUALS",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "SELECT get_address_country(1) FROM dual",
      "SELECT get_address_country(2) FROM dual",
      "SELECT get_address_country(3) FROM dual",
      "SELECT get_address_country(4) FROM dual",
      "SELECT get_address_country(5) FROM dual"
    ],
    "summary": "Create a function named get_address_country that accepts a NUMBER parameter p_address_id and returns a VARCHAR2. It queries the COUNTRY from the ADDRESSES table where ADDRESS_ID matches the parameter, stores it in a VARCHAR2(255) variable, and returns that value.",
    "natural_language": "Create a function called get_address_country that takes a NUMBER for the address identifier and gives back a VARCHAR2. It should look up the general area or COUNTRY from the ADDRESSES list for entries that are kind of close to the provided ID, put that into a text variable, and then hand back that result.",
    "id": 26,
    "generated_ir": "Write an Oracle PL/SQL function named get_address_country that returns a VARCHAR2 type value. This function accepts a single input parameter p_address_id of type NUMBER, which represents the address identifier to look up. The function declares a local variable v_country of type VARCHAR2(255) to store the retrieved country value. The function queries the ADDRESSES table in the e_government database, selecting the COUNTRY column where the ADDRESS_ID column exactly matches the provided p_address_id parameter. The selected country value is stored into the v_country variable. The function then returns the value stored in v_country. If no matching address is found, the function will return NULL."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_member_rank_category that accepts a single input parameter, p_member_id, of type NUMBER, which represents the unique identifier of a member. The function returns a value of type VARCHAR2. Within the function, declare a local variable v_rank of type NUMBER to store the rank of the member and another local variable v_category of type VARCHAR2 with a maximum length of 20 characters to store the category of the member. The function begins by executing a SELECT statement to retrieve the RANK_IN_ROUND value from the ROUND table where the MEMBER_ID column matches the input parameter p_member_id. The retrieved rank value is stored in the v_rank variable. The function then evaluates the value of v_rank using an IF statement. If v_rank is less than or equal to 2, the function assigns the string 'TOP_TIER' to the v_category variable. Otherwise, it assigns the string 'OTHER' to v_category. Finally, the function returns the value of v_category, which indicates the rank category of the member based on their rank in the ROUND table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_rank_category(p_member_id NUMBER) RETURN VARCHAR2 IS\n  v_rank NUMBER;\n  v_category VARCHAR2(20);\nBEGIN\n  SELECT RANK_IN_ROUND INTO v_rank FROM ROUND WHERE MEMBER_ID = p_member_id;\n  IF v_rank <= 2 THEN\n    v_category := 'TOP_TIER';\n  ELSE\n    v_category := 'OTHER';\n  END IF;\n  RETURN v_category;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_member_rank_category(1) FROM DUAL",
      "SELECT get_member_rank_category(2) FROM DUAL",
      "SELECT get_member_rank_category(10) FROM DUAL",
      "SELECT get_member_rank_category(3) FROM DUAL",
      "SELECT get_member_rank_category(4) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_member_rank_category that accepts a member ID number and returns a VARCHAR2. It retrieves the member's rank from the ROUND table. If the rank is 1 or 2, return 'TOP_TIER'; otherwise, return 'OTHER'.",
    "natural_language": "Develop a PL/SQL function, which should be named get_member_rank_category, that is designed to accept a specific member ID number as its input parameter and will subsequently return a value of the VARCHAR2 data type. This function will meticulously query the ROUND table to retrieve the precise rank associated with the provided member. In the detailed scenario where the retrieved rank is determined to be exactly 1 or 2, the function must thoughtfully return the descriptive string 'TOP_TIER'; for all other rank values, it should comprehensively return the string 'OTHER'.",
    "id": 27,
    "generated_ir": "Write an Oracle PL/SQL function named get_member_rank_category that accepts a single input parameter, p_member_id, of type NUMBER, which represents the unique identifier of a member. The function returns a value of type VARCHAR2. Within the function, declare a local variable v_rank of type NUMBER to store the rank of the member and another local variable v_category of type VARCHAR2 with a maximum length of 20 characters to store the category of the member. The function begins by executing a SELECT statement to retrieve the RANK_IN_ROUND value from the ROUND table where the MEMBER_ID column matches the input parameter p_member_id. The retrieved rank value is stored in the v_rank variable. The function then evaluates the value of v_rank using an IF statement. If v_rank is less than or equal to 2, the function assigns the string 'TOP_TIER' to the v_category variable. Otherwise, it assigns the string 'OTHER' to v_category. Finally, the function returns the value of v_category, which indicates the rank category of the member based on their rank in the ROUND table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_PRODUCT_CATEGORY that accepts a single input parameter named PRODUCT_ID_IN of the NUMBER data type and returns a value of the VARCHAR2 data type; within the function, a local variable named CATEGORY of type VARCHAR2 with a maximum length of 255 characters is declared; the function's execution logic performs a SELECT query on the PRODUCTS table, specifically retrieving the value from the PRODUCT_CATEGORY_CODE column for the single row where the PRODUCT_ID column value is exactly equal to the provided input parameter PRODUCT_ID_IN; the retrieved value is stored into the local CATEGORY variable using an INTO clause; the function then concludes by returning the value stored in the CATEGORY variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PRODUCT_CATEGORY(PRODUCT_ID_IN NUMBER) RETURN VARCHAR2 IS\n  CATEGORY VARCHAR2(255);\nBEGIN\n  SELECT PRODUCT_CATEGORY_CODE\n  INTO CATEGORY\n  FROM PRODUCTS\n  WHERE PRODUCT_ID = PRODUCT_ID_IN;\n\n  RETURN CATEGORY;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT GET_PRODUCT_CATEGORY(117) FROM DUAL",
      "SELECT GET_PRODUCT_CATEGORY(118) FROM DUAL",
      "SELECT GET_PRODUCT_CATEGORY(119) FROM DUAL",
      "SELECT GET_PRODUCT_CATEGORY(4) FROM DUAL",
      "SELECT GET_PRODUCT_CATEGORY(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_PRODUCT_CATEGORY that accepts a PRODUCT_ID_IN (NUMBER) and returns a VARCHAR2. It retrieves the PRODUCT_CATEGORY_CODE from the PRODUCTS table where PRODUCT_ID matches the input parameter and returns that value.",
    "natural_language": "Develop a PL/SQL function called GET_PRODUCT_CATEGORY, which is designed to take a single numeric input parameter, specifically a PRODUCT_ID_IN of type NUMBER, and subsequently provide a VARCHAR2 as its return value. This function works by meticulously querying the PRODUCTS table to locate and retrieve the precise PRODUCT_CATEGORY_CODE associated with the product whose PRODUCT_ID exactly corresponds to the supplied input parameter, ultimately returning that specific categorical code.",
    "id": 28,
    "generated_ir": "Write an Oracle PL/SQL function named GET_PRODUCT_CATEGORY that accepts a single input parameter named PRODUCT_ID_IN of the NUMBER data type and returns a value of the VARCHAR2 data type; within the function, a local variable named CATEGORY of type VARCHAR2 with a maximum length of 255 characters is declared; the function's execution logic performs a SELECT query on the PRODUCTS table, specifically retrieving the value from the PRODUCT_CATEGORY_CODE column for the single row where the PRODUCT_ID column value is exactly equal to the provided input parameter PRODUCT_ID_IN; the retrieved value is stored into the local CATEGORY variable using an INTO clause; the function then concludes by returning the value stored in the CATEGORY variable as its result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_painting_area that accepts a single input parameter named painting_id of type NUMBER, which is used to identify a specific painting, and returns a value of type NUMBER. The function begins by declaring a local variable named painting_area of type NUMBER. It then executes a SELECT statement that queries the PAINTINGS table, retrieving the product of the HEIGHT_MM column and the WIDTH_MM column for the row where the PAINTINGID column matches the provided painting_id parameter, and stores the result into the painting_area variable. Following the data retrieval, the function evaluates a conditional IF statement: if the calculated painting_area is greater than 1,000,000, the function returns the painting_area value directly; otherwise, if the painting_area is less than or equal to 1,000,000, the function returns the value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_painting_area(painting_id NUMBER) RETURN NUMBER IS\n  painting_area NUMBER;\nBEGIN\n  SELECT HEIGHT_MM * WIDTH_MM INTO painting_area FROM PAINTINGS WHERE PAINTINGID = painting_id;\n  IF painting_area > 1000000 THEN\n    RETURN painting_area;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "art_1",
    "tables": [
      "ARTISTS",
      "PAINTINGS",
      "SCULPTURES"
    ],
    "call_sqls": [
      "SELECT calculate_painting_area(80) FROM DUAL",
      "SELECT calculate_painting_area(83) FROM DUAL",
      "SELECT calculate_painting_area(84) FROM DUAL",
      "SELECT calculate_painting_area( (SELECT PAINTINGID FROM PAINTINGS WHERE TITLE = 'A Sunday on La Grande Jatte') ) FROM DUAL",
      "SELECT calculate_painting_area( (SELECT PAINTINGID FROM PAINTINGS WHERE PAINTERID = 222 AND ROWNUM = 1) ) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `calculate_painting_area` that takes a `painting_id` (NUMBER) and returns a NUMBER. It calculates the area (HEIGHT_MM * WIDTH_MM) from the `PAINTINGS` table. If the area is greater than 1,000,000, return the area; otherwise, return 0.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `calculate_painting_area`? It should take a painting's ID (as a NUMBER) and spit back a NUMBER. Basically, it needs to grab the height and width from the `PAINTINGS` table and multiply 'em to get the area. If that area's hugelike over a millionjust give back the area. Otherwise, if it's on the smaller side, just return a zero.",
    "id": 29,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_painting_area that accepts a single input parameter named painting_id of type NUMBER, which is used to identify a specific painting, and returns a value of type NUMBER. The function begins by declaring a local variable named painting_area of type NUMBER. It then executes a SELECT statement that queries the PAINTINGS table, retrieving the product of the HEIGHT_MM column and the WIDTH_MM column for the row where the PAINTINGID column matches the provided painting_id parameter, and stores the result into the painting_area variable. Following the data retrieval, the function evaluates a conditional IF statement: if the calculated painting_area is greater than 1,000,000, the function returns the painting_area value directly; otherwise, if the painting_area is less than or equal to 1,000,000, the function returns the value 0."
  },
  {
    "ir": "Write an Oracle PL/SQL function named determine_size_category that accepts a single input parameter p_size_code of type VARCHAR2 and returns a VARCHAR2 value, which begins by declaring two local NUMBER variables v_dog_count and v_max_weight, then executes a SELECT statement that queries the dogs table to count all rows and find the maximum numeric value of the weight column for rows where the size_code column exactly matches the provided p_size_code parameter, converting the weight column to a NUMBER using the TO_NUMBER function, and stores the resulting count and maximum weight into the variables v_dog_count and v_max_weight respectively, after which it uses an IF-ELSIF-ELSE conditional block to evaluate the retrieved data: if the v_dog_count equals zero, the function returns the string literal 'NO_DOGS'; otherwise, if the v_max_weight is less than 10, it returns 'LIGHTWEIGHT_GROUP'; otherwise, if the v_max_weight is greater than or equal to 10 and less than 25, it returns 'MEDIUM_GROUP'; and in all other cases where v_max_weight is 25 or greater, it returns 'HEAVYWEIGHT_GROUP'.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_size_category(p_size_code VARCHAR2) RETURN VARCHAR2 IS\n    v_dog_count NUMBER;\n    v_max_weight NUMBER;\nBEGIN\n    SELECT COUNT(*), MAX(TO_NUMBER(weight)) INTO v_dog_count, v_max_weight FROM dogs WHERE size_code = p_size_code;\n    IF v_dog_count = 0 THEN\n        RETURN 'NO_DOGS';\n    ELSIF v_max_weight < 10 THEN\n        RETURN 'LIGHTWEIGHT_GROUP';\n    ELSIF v_max_weight >= 10 AND v_max_weight < 25 THEN\n        RETURN 'MEDIUM_GROUP';\n    ELSE\n        RETURN 'HEAVYWEIGHT_GROUP';\n    END IF;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "BREEDS",
      "SIZES"
    ],
    "call_sqls": [
      "SELECT determine_size_category('LGE') FROM DUAL",
      "SELECT determine_size_category('MED') FROM DUAL",
      "SELECT determine_size_category('SML') FROM DUAL",
      "SELECT determine_size_category('XL') FROM DUAL",
      "SELECT determine_size_category('XXL') FROM DUAL"
    ],
    "summary": "Create a function named `determine_size_category` that accepts a `VARCHAR2` parameter `p_size_code` and returns a `VARCHAR2`. It should count the dogs and find the maximum weight (converted to NUMBER) for the given `size_code`. Return 'NO_DOGS' if count is zero. Otherwise, return 'LIGHTWEIGHT_GROUP' if max weight <10, 'MEDIUM_GROUP' if between 10 and 25 (inclusive of 10), or 'HEAVYWEIGHT_GROUP' if 25 or greater.",
    "natural_language": "Alright, so we need a function called `determine_size_category`. It takes a `VARCHAR2` parameter, let's call it `p_size_code`, and spits back a `VARCHAR2`. Here's what it's gotta do: first, check how many dogs there are for that size code and also find the heaviest one (make sure that weight is a NUMBER). If there aren't any dogs for that code, just return 'NO_DOGS'. If there are dogs, look at that max weight. If it's under 10, return 'LIGHTWEIGHT_GROUP'. If it's 10 up to and including 25, that's 'MEDIUM_GROUP'. If it's 25 or more, that's 'HEAVYWEIGHT_GROUP'.",
    "id": 30,
    "generated_ir": "Write an Oracle PL/SQL function named determine_size_category that accepts one input parameter: p_size_code of type VARCHAR2, and returns a VARCHAR2 value representing a size category based on the dogs associated with that size code. The function operates on the dog_kennels database and uses the DOGS table.\n\nThe function declares two local variables: v_dog_count of type NUMBER to store the count of dogs for the given size code, and v_max_weight of type NUMBER to store the maximum weight among those dogs.\n\nThe function first executes a SELECT statement that uses the SQL aggregate functions COUNT and MAX to retrieve the total number of dogs and the highest weight value from the DOGS table. The query selects COUNT(*) and MAX(TO_NUMBER(WEIGHT)) from the DOGS table, with a WHERE clause that filters records to include only those where the SIZE_CODE column matches the input parameter p_size_code. The results are stored into the variables v_dog_count and v_max_weight.\n\nNext, the function implements conditional logic using IF-THEN-ELSIF statements. It first checks if v_dog_count is equal to 0. If true, the function returns the string 'NO_DOGS'.\n\nIf v_dog_count is greater than 0, the function proceeds to evaluate v_max_weight. It checks if v_max_weight is less than 10. If true, the function returns the string 'LIGHTWEIGHT_GROUP'.\n\nIf v_max_weight is not less than 10, the function checks if v_max_weight is less than or equal to 25. If true, the function returns the string 'MEDIUM_GROUP'.\n\nIf v_max_weight is greater than 25, the function returns the string 'HEAVYWEIGHT_GROUP'.\n\nThe function ends by returning the determined category string."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_avg_rank` that accepts one input parameter, `p_member_id`, which is of data type `NUMBER` and represents the unique identifier for a member. This function is designed to return a single value of data type `NUMBER`, representing the average rank of the specified member across various rounds. The function declares a local variable `v_avg_rank` of data type `NUMBER` to temporarily store the calculated average rank. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `ROUND` table. Within this `SELECT` statement, the `REGR_AVGX` aggregate function is utilized. The `REGR_AVGX` function calculates the average of the independent variable in a linear regression model. In this specific context, `REGR_AVGX` is applied to the `ROUND_ID` column as the independent variable and `RANK_IN_ROUND` as the dependent variable. This effectively calculates the average of the `ROUND_ID` values, weighted by their corresponding `RANK_IN_ROUND` values, for all records where the `MEMBER_ID` column in the `ROUND` table matches the value provided by the input parameter `p_member_id`. The result of this `REGR_AVGX` calculation is then stored into the local variable `v_avg_rank`. Finally, the function returns the value stored in `v_avg_rank` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_avg_rank(p_member_id NUMBER) RETURN NUMBER IS\n  v_avg_rank NUMBER;\nBEGIN\n  SELECT REGR_AVGX(r.RANK_IN_ROUND, r.ROUND_ID) INTO v_avg_rank FROM ROUND r WHERE r.MEMBER_ID = p_member_id;\n  RETURN v_avg_rank;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_member_avg_rank(1) FROM DUAL",
      "SELECT get_member_avg_rank(2) FROM DUAL",
      "SELECT get_member_avg_rank(3) FROM DUAL",
      "SELECT get_member_avg_rank(10) FROM DUAL",
      "SELECT get_member_avg_rank(4) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_member_avg_rank that accepts a member ID. It uses the REGR_AVGX function on the ROUND table to calculate the average of ROUND_ID weighted by RANK_IN_ROUND for the given member and returns this value.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be designated as get_member_avg_rank, which is designed to receive a specific member ID as its input parameter. This function will meticulously employ the REGR_AVGX function, applied to the dataset within the ROUND table, in order to compute a precise weighted average. This calculation specifically determines the average of the ROUND_ID values, where each round ID is thoughtfully weighted according to its corresponding RANK_IN_ROUND, exclusively for the member identified by the provided ID, and subsequently returns this computed numerical result.",
    "id": 31,
    "generated_ir": "Write an Oracle PL/SQL function named get_member_avg_rank that accepts a single input parameter p_member_id of type NUMBER and returns a NUMBER value. The function operates on the decoration_competition database. It begins by declaring a local variable v_avg_rank of type NUMBER to store the computed result. The core operation is a SELECT statement that queries the ROUND table, applying the REGR_AVGX Oracle aggregate function. This function calculates the weighted average of the ROUND_ID column, using the RANK_IN_ROUND column as the weight. The SELECT statement includes a WHERE clause to filter rows where the MEMBER_ID column equals the provided input parameter p_member_id, ensuring the calculation is performed exclusively for the specified member. The result of this REGR_AVGX calculation is directly selected into the local variable v_avg_rank. After the SELECT operation, the function returns the value stored in v_avg_rank. The function includes an EXCEPTION handler to manage potential errors: if the initial SELECT statement finds no matching data for the given member_id (NO_DATA_FOUND exception), the function returns NULL; for any other exceptions that occur during execution, the function also returns NULL after handling the error."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_tonnage_by_type_year that accepts three input parameters: a string parameter named type_filter, a numeric parameter named start_year, and a numeric parameter named end_year, and returns a single numeric value. The function declares a local numeric variable named total_tonnage. The function's logic executes a single SQL SELECT statement that performs a SUM aggregation on the TONNAGE column from the SHIP table, aliased as 's'. This query joins the SHIP table to the MISSION table, aliased as 'm', using the condition that the SHIP_ID column in the SHIP table equals the SHIP_ID column in the MISSION table. The query applies two filter conditions in its WHERE clause: the first condition uses the LOWER function to convert both the TYPE column from the SHIP table and the input parameter type_filter to lowercase and checks for equality, ensuring a case-insensitive comparison; the second condition checks that the LAUNCHED_YEAR column from the MISSION table is between the values of the input parameters start_year and end_year, inclusive. The result of the SUM aggregation is assigned into the local variable total_tonnage. The function concludes by returning the value stored in the total_tonnage variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_tonnage_by_type_year(type_filter IN VARCHAR2, start_year IN NUMBER, end_year IN NUMBER) RETURN NUMBER IS\n  total_tonnage NUMBER;\nBEGIN\n  SELECT SUM(s.TONNAGE)\n  INTO total_tonnage\n  FROM SHIP s\n  JOIN MISSION m ON s.SHIP_ID = m.SHIP_ID\n  WHERE LOWER(s.TYPE) = LOWER(type_filter)\n    AND m.LAUNCHED_YEAR BETWEEN start_year AND end_year;\n  RETURN total_tonnage;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "SELECT get_total_tonnage_by_type_year('Cargo ship', 1910, 1920) FROM DUAL",
      "SELECT get_total_tonnage_by_type_year('Battle ship', 1930, 1940) FROM DUAL",
      "SELECT get_total_tonnage_by_type_year('Cargo ship', 1900, 1950) FROM DUAL",
      "SELECT get_total_tonnage_by_type_year('Battle ship', 1916, 1916) FROM DUAL",
      "SELECT get_total_tonnage_by_type_year('Cargo ship', 1925, 1935) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_tonnage_by_type_year that returns the total tonnage. It accepts a ship type, a start year, and an end year. The function sums the tonnage from the SHIP table joined with the MISSION table where the ship type (case-insensitive) matches the input and the mission's launched year is within the specified range.",
    "natural_language": "What is the total tonnage for a given ship type, calculated by summing the tonnage from ships whose type matches (case-insensitively) and whose missions were launched between a specified start year and end year?",
    "id": 32,
    "generated_ir": "Write an Oracle PL/SQL function named get_total_tonnage_by_type_year that accepts three input parameters: a string parameter named type_filter, a numeric parameter named start_year, and a numeric parameter named end_year, and returns a single numeric value. The function declares a local numeric variable named total_tonnage. The function's logic executes a single SQL SELECT statement that performs a SUM aggregation on the TONNAGE column from the SHIP table, aliased as 's'. This query joins the SHIP table to the MISSION table, aliased as 'm', using the condition that the SHIP_ID column in the SHIP table equals the SHIP_ID column in the MISSION table. The query applies two filter conditions in its WHERE clause: the first condition uses the LOWER function to convert both the TYPE column from the SHIP table and the input parameter type_filter to lowercase and checks for equality, ensuring a case-insensitive comparison; the second condition checks that the LAUNCHED_YEAR column from the MISSION table is between the values of the input parameters start_year and end_year, inclusive. The result of the SUM aggregation is assigned into the local variable total_tonnage. The function concludes by returning the value stored in the total_tonnage variable."
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_student_count_by_country that accepts a single input parameter p_country of type VARCHAR2 and returns a value of type NUMBER. The function declares a local variable v_count of type NUMBER. The function's logic executes a SELECT statement that performs a COUNT(*) aggregation. This SELECT statement queries from a join between two tables: the STUDENT table, aliased as 's', and the CITY table, aliased as 'c'. The tables are joined using the condition that the CITY_CODE column from the STUDENT table equals the CITY_CODE column from the CITY table. The query includes a WHERE clause with a condition that compares the COUNTRY column from the CITY table to the input parameter p_country. To ensure a case-insensitive comparison, both sides of the condition are transformed to lowercase using the LOWER function: LOWER(c.COUNTRY) is compared to LOWER(p_country). The result of the COUNT(*) operation, which is the total number of student records associated with cities in the specified country, is retrieved into the local variable v_count using an INTO clause. The function concludes by returning the value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_student_count_by_country(p_country VARCHAR2) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM STUDENT s JOIN CITY c ON s.CITY_CODE = c.CITY_CODE WHERE LOWER(c.COUNTRY) = LOWER(p_country);\n    RETURN v_count;\nEND;",
    "database_name": "address_1",
    "tables": [
      "CITY",
      "DIRECT_DISTANCE",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT fn_get_student_count_by_country('USA') FROM dual",
      "SELECT fn_get_student_count_by_country('Canada') FROM dual",
      "SELECT fn_get_student_count_by_country('India') FROM dual",
      "SELECT fn_get_student_count_by_country('Australia') FROM dual",
      "SELECT fn_get_student_count_by_country('UK') FROM dual"
    ],
    "summary": "Create a function named `fn_get_student_count_by_country` that accepts a country parameter and returns the count of students from that country using a case-insensitive join between the STUDENT and CITY tables.",
    "natural_language": "Write a function called `fn_get_student_count_by_country` that takes a country name and gives back the number of students from around there. It should match up the STUDENT and CITY tables in a way that ignores differences in letter casing.",
    "id": 33,
    "generated_ir": "Write an Oracle PL/SQL function named fn_get_student_count_by_country that accepts a single input parameter p_country of type VARCHAR2 and returns a value of type NUMBER. The function declares a local variable v_count of type NUMBER. The function's logic executes a SELECT statement that performs a COUNT(*) aggregation. This SELECT statement queries from a join between two tables: the STUDENT table, aliased as 's', and the CITY table, aliased as 'c'. The tables are joined using the condition that the CITY_CODE column from the STUDENT table equals the CITY_CODE column from the CITY table. The query includes a WHERE clause with a condition that compares the COUNTRY column from the CITY table to the input parameter p_country. To ensure a case-insensitive comparison, both sides of the condition are transformed to lowercase using the LOWER function: LOWER(c.COUNTRY) is compared to LOWER(p_country). The result of the COUNT(*) operation, which is the total number of student records associated with cities in the specified country, is retrieved into the local variable v_count using an INTO clause. The function concludes by returning the value stored in v_count."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_marriage_service_count that returns a numeric value representing the count of records in the SERVICES table where the SERVICE_TYPE_CODE column, when converted to lowercase using the LOWER() function, matches the string 'marriage'. The function does not take any input parameters. It declares a local variable v_count of type NUMBER to store the result of the query. Within the function's execution block, a SELECT statement is used to count all rows in the SERVICES table that satisfy the condition of having a SERVICE_TYPE_CODE that, when transformed to lowercase, equals 'marriage'. The COUNT(*) aggregate function is employed to determine the total number of such rows, and the result is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the number of marriage service records found in the SERVICES table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_marriage_service_count RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM SERVICES WHERE LOWER(SERVICE_TYPE_CODE) = 'marriage';\n  RETURN v_count;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_marriage_service_count FROM DUAL",
      "SELECT get_marriage_service_count() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_marriage_service_count;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Marriage services: ' || get_marriage_service_count);\nEND;",
      "SELECT get_marriage_service_count AS marriage_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_marriage_service_count with no parameters that returns the count of rows from the SERVICES table where the lowercase SERVICE_TYPE_CODE equals 'marriage'.",
    "natural_language": "What is the count of rows in the SERVICES table where the SERVICE_TYPE_CODE, converted to lowercase, is 'marriage'?",
    "id": 34,
    "generated_ir": "Write an Oracle PL/SQL function named get_marriage_service_count that returns a NUMBER value, which declares a local variable v_count of type NUMBER, then executes a SELECT statement that counts the number of rows (COUNT(*)) from the SERVICES table where the SERVICE_TYPE_CODE column, after being converted to lowercase using the LOWER function, is exactly equal to the string 'marriage', stores this count into the v_count variable, and finally returns the value of v_count as the function's result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_average_settlement_ratio` that accepts a single input parameter, `p_customer_id`, which is of data type `NUMBER`. The purpose of this function is to compute and return a single `NUMBER` value representing the average settlement ratio for a specific customer. The function's execution begins by declaring a local variable named `v_avg_ratio` of data type `NUMBER` to temporarily store the calculated average. Subsequently, the function executes a `SELECT` statement to perform the core calculation. This `SELECT` statement calculates the average of a derived ratio. The ratio is determined by dividing the value in the `AMOUNT_SETTLED` column by the value in the `AMOUNT_CLAIMED` column. This calculation is performed for each relevant record. The `SELECT` statement retrieves data from the `CLAIMS` table, aliased as `cl`, and joins it with the `CUSTOMER_POLICIES` table, aliased as `cp`. The join condition specifies that records from `CLAIMS` and `CUSTOMER_POLICIES` are linked where the `POLICY_ID` column in the `CLAIMS` table (`cl.POLICY_ID`) matches the `POLICY_ID` column in the `CUSTOMER_POLICIES` table (`cp.POLICY_ID`). Furthermore, the `WHERE` clause filters these joined records, ensuring that only those records where the `CUSTOMER_ID` column in the `CUSTOMER_POLICIES` table (`cp.CUSTOMER_ID`) is equal to the value provided in the input parameter `p_customer_id` are considered for the average calculation. The result of this average calculation is then stored into the local variable `v_avg_ratio`. Finally, the function concludes its execution by returning the value stored in `v_avg_ratio` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_settlement_ratio(p_customer_id NUMBER) RETURN NUMBER IS\n    v_avg_ratio NUMBER;\nBEGIN\n    SELECT AVG(AMOUNT_SETTLED / AMOUNT_CLAIMED) INTO v_avg_ratio\n    FROM CLAIMS cl\n    JOIN CUSTOMER_POLICIES cp ON cl.POLICY_ID = cp.POLICY_ID\n    WHERE cp.CUSTOMER_ID = p_customer_id;\n    RETURN v_avg_ratio;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "SELECT calculate_average_settlement_ratio(1) FROM DUAL",
      "SELECT calculate_average_settlement_ratio(2) FROM DUAL",
      "SELECT calculate_average_settlement_ratio(3) FROM DUAL",
      "SELECT calculate_average_settlement_ratio(4) FROM DUAL",
      "SELECT calculate_average_settlement_ratio(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_average_settlement_ratio that accepts a customer ID number, calculates the average of (AMOUNT_SETTLED / AMOUNT_CLAIMED) from the CLAIMS table for all policies belonging to that customer by joining with CUSTOMER_POLICIES, and returns the average as a number.",
    "natural_language": "Write function calculate_average_settlement_ratio. Takes customer ID. Return average of AMOUNT_SETTLED / AMOUNT_CLAIMED from CLAIMS via CUSTOMER_POLICIES join.",
    "id": 35,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_average_settlement_ratio that accepts a single input parameter, p_customer_id, which is of data type NUMBER. This function is designed to return a numeric value representing the average settlement ratio for all claims associated with a specific customer. The function declares a local variable v_average_ratio of type NUMBER to store the computed result. The core operation involves a SELECT statement that calculates the average of the ratio between the AMOUNT_SETTLED and AMOUNT_CLAIMED columns from the CLAIMS table. This SELECT statement uses the AVG aggregate function on the expression AMOUNT_SETTLED / AMOUNT_CLAIMED. To associate claims with a specific customer, the query performs an INNER JOIN between the CLAIMS table and the CUSTOMER_POLICIES table. The join condition is CLAIMS.POLICY_ID = CUSTOMER_POLICIES.POLICY_ID. A WHERE clause filters the results to include only those rows where the CUSTOMER_POLICIES.CUSTOMER_ID column matches the value provided by the input parameter p_customer_id. The result of this SELECT statement, which is the average settlement ratio for the specified customer, is then stored into the v_average_ratio variable using the INTO clause. Finally, the function returns the value stored in v_average_ratio."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_catalog_price_difference that accepts two parameters: p_catalog_entry_id of type NUMBER, which represents the unique identifier for a catalog entry, and p_currency of type VARCHAR2, which specifies the currency code ('USD' or 'EUR'). The function returns a NUMBER representing the price difference between the catalog entry's price in dollars and euros. Inside the function, declare three local variables: v_price_dollars, v_price_euros, and v_result, all of type NUMBER. Execute a SELECT statement to retrieve the PRICE_IN_DOLLARS and PRICE_IN_EUROS columns from the CATALOG_CONTENTS table where the CATALOG_ENTRY_ID matches the provided p_catalog_entry_id, storing the results in v_price_dollars and v_price_euros respectively. Use the UPPER() function to convert the p_currency parameter to uppercase for case-insensitive comparison. Implement conditional logic using IF-ELSIF-ELSE statements: if p_currency is 'USD', calculate the difference by subtracting v_price_euros from v_price_dollars and assign the result to v_result; if p_currency is 'EUR', calculate the difference by subtracting v_price_dollars from v_price_euros and assign the result to v_result; if p_currency is neither 'USD' nor 'EUR', set v_result to NULL. Return v_result as the function's output. Handle exceptions using an EXCEPTION block: if a NO_DATA_FOUND exception occurs, indicating no matching catalog entry, return NULL; if a TOO_MANY_ROWS exception occurs, indicating multiple matching entries, return NULL.",
    "plsql": "CREATE OR REPLACE FUNCTION get_catalog_price_difference(p_catalog_entry_id NUMBER, p_currency VARCHAR2) RETURN NUMBER IS\n    v_price_dollars NUMBER;\n    v_price_euros   NUMBER;\n    v_result        NUMBER;\nBEGIN\n    SELECT PRICE_IN_DOLLARS, PRICE_IN_EUROS\n      INTO v_price_dollars, v_price_euros\n      FROM CATALOG_CONTENTS\n     WHERE CATALOG_ENTRY_ID = p_catalog_entry_id;\n\n    IF UPPER(p_currency) = 'USD' THEN\n        v_result := v_price_dollars - v_price_euros;\n    ELSIF UPPER(p_currency) = 'EUR' THEN\n        v_result := v_price_euros - v_price_dollars;\n    ELSE\n        v_result := NULL;\n    END IF;\n\n    RETURN v_result;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\n    WHEN TOO_MANY_ROWS THEN\n        RETURN NULL;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "SELECT get_catalog_price_difference(1, 'USD') FROM DUAL",
      "SELECT get_catalog_price_difference(2, 'EUR') FROM DUAL",
      "SELECT get_catalog_price_difference(3, 'USD') FROM DUAL",
      "SELECT get_catalog_price_difference(5, 'EUR') FROM DUAL",
      "SELECT get_catalog_price_difference(15, 'GBP') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_catalog_price_difference that takes a catalog entry ID and a currency code ('USD' or 'EUR'), and returns the price difference between dollars and euros for that entry. Return NULL for invalid currency or if no/multiple entries are found.",
    "natural_language": "Function get_catalog_price_difference: takes catalog ID and currency ('USD'/'EUR'), returns USD-EUR price difference. Return NULL for invalid currency or no/multiple matches.",
    "id": 36,
    "generated_ir": "Write an Oracle PL/SQL function named get_catalog_price_difference that accepts two parameters: p_catalog_entry_id of type NUMBER, which represents the unique identifier for a catalog entry, and p_currency of type VARCHAR2, which specifies the currency code ('USD' or 'EUR'). The function returns a NUMBER representing the price difference between the catalog entry's price in dollars and euros. Inside the function, declare three local variables: v_price_dollars, v_price_euros, and v_result, all of type NUMBER. Execute a SELECT statement to retrieve the PRICE_IN_DOLLARS and PRICE_IN_EUROS columns from the CATALOG_CONTENTS table where the CATALOG_ENTRY_ID matches the provided p_catalog_entry_id, storing the results in v_price_dollars and v_price_euros respectively. Use the UPPER() function to convert the p_currency parameter to uppercase for case-insensitive comparison. Implement conditional logic using IF-ELSIF-ELSE statements: if p_currency is 'USD', calculate the difference by subtracting v_price_euros from v_price_dollars and assign the result to v_result; if p_currency is 'EUR', calculate the difference by subtracting v_price_dollars from v_price_euros and assign the result to v_result; if p_currency is neither 'USD' nor 'EUR', set v_result to NULL. Return v_result as the function's output. Handle exceptions using an EXCEPTION block: if a NO_DATA_FOUND exception occurs, indicating no matching catalog entry, return NULL; if a TOO_MANY_ROWS exception occurs, indicating multiple matching entries, return NULL."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_staff_with_formatted_names` that is designed to return a `SYS_REFCURSOR` data type, which is a pointer to a result set. This function does not accept any input parameters. Upon execution, the function declares a local variable named `v_cursor` of type `SYS_REFCURSOR`. The core operation involves opening this `v_cursor` to execute a `SELECT` statement. This `SELECT` statement retrieves data from the `STAFF` table. Specifically, it selects the `STAFF_ID` column directly. It also constructs a new computed column aliased as `display_name`. This `display_name` is created by concatenating several components: first, the value from the `FIRST_NAME` column is padded on the right with the hyphen character (`-`) until it reaches a total length of 15 characters using the `RPAD` function; then, a single space character (` `) is appended; finally, the value from the `LAST_NAME` column is padded on the right with the asterisk character (`*`) until it reaches a total length of 15 characters, also using the `RPAD` function. After the `SELECT` statement is executed and the result set is populated into `v_cursor`, the function returns this `v_cursor` to the caller, allowing the caller to fetch rows from the generated result set.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_with_formatted_names RETURN SYS_REFCURSOR IS\n    v_cursor SYS_REFCURSOR;\nBEGIN\n    OPEN v_cursor FOR SELECT STAFF_ID, RPAD(FIRST_NAME, 15, '-') || ' ' || RPAD(LAST_NAME, 15, '*') AS display_name FROM STAFF;\n    RETURN v_cursor;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "ADDRESSES",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "DECLARE\n    v_cursor SYS_REFCURSOR;\n    v_staff_id STAFF.STAFF_ID%TYPE;\n    v_display_name VARCHAR2(255);\nBEGIN\n    v_cursor := get_staff_with_formatted_names();\n    LOOP\n        FETCH v_cursor INTO v_staff_id, v_display_name;\n        EXIT WHEN v_cursor%NOTFOUND;\n        DBMS_OUTPUT.PUT_LINE('Staff ID: ' || v_staff_id || ', Display Name: ' || v_display_name);\n    END LOOP;\n    CLOSE v_cursor;\nEND;",
      "DECLARE\n    v_cursor SYS_REFCURSOR;\n    v_staff_id STAFF.STAFF_ID%TYPE;\n    v_display_name VARCHAR2(255);\nBEGIN\n    v_cursor := get_staff_with_formatted_names();\n    FETCH v_cursor INTO v_staff_id, v_display_name;\n    DBMS_OUTPUT.PUT_LINE('First Staff: ' || v_display_name);\n    CLOSE v_cursor;\nEND;",
      "SELECT STAFF_ID, RPAD(FIRST_NAME, 15, '-') || ' ' || RPAD(LAST_NAME, 15, '*') AS display_name FROM STAFF WHERE STAFF_ID = 1",
      "SELECT STAFF_ID, RPAD(FIRST_NAME, 15, '-') || ' ' || RPAD(LAST_NAME, 15, '*') AS display_name FROM STAFF WHERE FIRST_NAME = 'Janessa'",
      "SELECT STAFF_ID, RPAD(FIRST_NAME, 15, '-') || ' ' || RPAD(LAST_NAME, 15, '*') AS display_name FROM STAFF WHERE LAST_NAME = 'Sawayn'"
    ],
    "summary": "Create a PL/SQL function named get_staff_with_formatted_names that returns a SYS_REFCURSOR. The function selects STAFF_ID and a computed display_name from the STAFF table. The display_name concatenates RPAD(FIRST_NAME, 15, '-'), a space, and RPAD(LAST_NAME, 15, '*').",
    "natural_language": "Write a PL/SQL function that fetches a list of staff members. It should return a cursor. For each person, get their ID and a nicely formatted name. The name should be put together by taking the first name, padding it out to a decent length with some dashes, adding a space, and then doing something similar with the last name but using asterisks to fill it out to a good width.",
    "id": 37,
    "generated_ir": "Write an Oracle PL/SQL function named get_staff_with_formatted_names that returns a SYS_REFCURSOR. The function does not accept any input parameters. It declares a cursor variable named staff_cursor of type SYS_REFCURSOR to hold the result set. The function opens the staff_cursor for a SELECT query that retrieves data from the STAFF table. The query selects two columns for each row: the STAFF_ID column directly, and a calculated expression for the formatted name. The formatted name is constructed by concatenating three string components using the concatenation operator. The first component is the result of applying the RPAD function to the FIRST_NAME column from the STAFF table. The RPAD function pads the first name on the right with the hyphen character '-' until the total string length reaches 15 characters. The second component is a single space character. The third component is the result of applying the RPAD function to the LAST_NAME column from the STAFF table. This RPAD function pads the last name on the right with the asterisk character '*' until the total string length reaches 15 characters. The query does not include a WHERE clause, so it processes all rows in the STAFF table. The opened cursor containing the staff IDs and their corresponding formatted names is returned as the function's result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_staff_complaint_assignment that accepts two mandatory input parameters: a numeric parameter p_staff_id representing a staff identifier and a numeric parameter p_complaint_id representing a complaint identifier, and returns a single numeric value; within the function's execution block, it declares a local numeric variable v_assigned, then performs a SELECT operation on the COMPLAINTS table to count the number of rows where the STAFF_ID column exactly matches the input parameter p_staff_id and the COMPLAINT_ID column exactly matches the input parameter p_complaint_id, storing the resulting count value into the variable v_assigned, and finally returns the value of v_assigned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION check_staff_complaint_assignment(p_staff_id NUMBER, p_complaint_id NUMBER) RETURN NUMBER IS\n    v_assigned NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_assigned FROM COMPLAINTS WHERE STAFF_ID = p_staff_id AND COMPLAINT_ID = p_complaint_id;\n    RETURN v_assigned;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT check_staff_complaint_assignment(114, 1) FROM DUAL",
      "SELECT check_staff_complaint_assignment(120, 2) FROM DUAL",
      "SELECT check_staff_complaint_assignment(115, 3) FROM DUAL",
      "SELECT check_staff_complaint_assignment(114, 3) FROM DUAL",
      "SELECT check_staff_complaint_assignment(120, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `check_staff_complaint_assignment` that returns a NUMBER. It takes a staff ID and a complaint ID (both NUMBER) as input. The function queries the COMPLAINTS table to count and return the number of rows where both the STAFF_ID and COMPLAINT_ID match the input parameters.",
    "natural_language": "Count and return the number of rows in the COMPLAINTS table where the STAFF_ID and COMPLAINT_ID match the given staff ID and complaint ID parameters.",
    "id": 38,
    "generated_ir": "Write an Oracle PL/SQL function named check_staff_complaint_assignment that returns a NUMBER data type. This function accepts two input parameters: p_staff_id of type NUMBER representing a staff identifier, and p_complaint_id of type NUMBER representing a complaint identifier. Within the function body, declare a local variable named v_count of type NUMBER to store the count of matching rows. The function performs a SELECT operation to count the number of rows in the COMPLAINTS table. Specifically, it calculates COUNT(*) from the COMPLAINTS table. The result of this count is stored into the v_count variable using the INTO clause. The SELECT statement includes a WHERE clause to filter rows based on two conditions: the STAFF_ID column must exactly equal the p_staff_id input parameter, and the COMPLAINT_ID column must exactly equal the p_complaint_id input parameter. After the SELECT statement executes, the function returns the value stored in v_count, which represents the number of complaints assigned to the specified staff member with the given complaint ID."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_product_price` that accepts a single input parameter, `p_product_code`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. The function declares a local variable named `v_price` of data type `NUMBER` to temporarily store the retrieved product price. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `price` column of the `products` table. The retrieved `price` value is then immediately stored into the local variable `v_price`. The selection of the specific row from the `products` table is determined by a `WHERE` clause, which specifies that the value in the `code` column of the `products` table must be equal to the value provided in the input parameter `p_product_code`. After successfully executing the `SELECT` statement and populating `v_price`, the function then returns the value currently held by the `v_price` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_price(p_product_code NUMBER) RETURN NUMBER IS\n    v_price NUMBER;\nBEGIN\n    SELECT price INTO v_price FROM products WHERE code = p_product_code;\n    RETURN v_price;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_product_price(1) FROM dual",
      "SELECT get_product_price(2) FROM dual",
      "SELECT get_product_price(3) FROM dual",
      "SELECT get_product_price(4) FROM dual",
      "SELECT get_product_price(5) FROM dual"
    ],
    "summary": "Create a function named get_product_price that takes a product code number as input, retrieves the corresponding price from the products table, and returns it as a number.",
    "natural_language": "What is the price for a given product code, and can you provide it as a function named get_product_price that returns the price as a number from the products table?",
    "id": 39,
    "generated_ir": "Write an Oracle PL/SQL function named `get_product_price` that accepts a single input parameter, `p_product_code`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. The function declares a local variable named `v_price` of data type `NUMBER` to temporarily store the retrieved product price. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `price` column of the `products` table. The retrieved `price` value is then immediately stored into the local variable `v_price`. The selection of the specific row from the `products` table is determined by a `WHERE` clause, which specifies that the value in the `code` column of the `products` table must be equal to the value provided in the input parameter `p_product_code`. After successfully executing the `SELECT` statement and populating `v_price`, the function then returns the value currently held by the `v_price` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_review_rank_by_book_title that accepts a single input parameter p_title of type VARCHAR2, which represents the title of a book, and returns a value of type NUMBER; the function declares a local variable v_rank of type NUMBER; the function's execution block begins by performing a SELECT statement that retrieves a value from the RANK column of the REVIEW table; this SELECT statement uses a WHERE clause with the condition BOOK_ID = (subquery result); the subquery is a nested SELECT statement that retrieves the BOOK_ID from the BOOK table where the TITLE column exactly matches the value of the input parameter p_title; the result of this subquery, a single BOOK_ID, is used to filter the outer SELECT from the REVIEW table; the value retrieved from the REVIEW.RANK column is assigned into the local variable v_rank; the function then concludes by using a RETURN statement to output the value stored in v_rank.",
    "plsql": "CREATE OR REPLACE FUNCTION get_review_rank_by_book_title(p_title IN VARCHAR2) RETURN NUMBER\nIS\n    v_rank NUMBER;\nBEGIN\n    SELECT RANK INTO v_rank FROM REVIEW WHERE BOOK_ID = (SELECT BOOK_ID FROM BOOK WHERE TITLE = p_title);\n    RETURN v_rank;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "SELECT get_review_rank_by_book_title('A Game of Thrones') FROM dual",
      "SELECT get_review_rank_by_book_title('A Clash of Kings') FROM dual",
      "SELECT get_review_rank_by_book_title('A Storm of Swords') FROM dual",
      "SELECT get_review_rank_by_book_title('A Feast for Crows') FROM dual",
      "SELECT get_review_rank_by_book_title('A Dance with Dragons') FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_review_rank_by_book_title` that returns the review rank (as NUMBER) for a given book title (input VARCHAR2).",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_review_rank_by_book_title`? It should spit out the review rank (as a NUMBER) when you give it a book title (as a VARCHAR2 input).",
    "id": 40,
    "generated_ir": "Write an Oracle PL/SQL function named `get_review_rank_by_book_title` that accepts a single input parameter, `p_book_title`, which is of the `VARCHAR2` data type. The purpose of this parameter is to specify the title of a book for which the review rank is to be retrieved. The function is designed to return a single value of the `NUMBER` data type, representing the rank from the review associated with the specified book title.\n\nInternally, the function declares a local variable named `v_review_rank` of the `NUMBER` data type to temporarily store the result of a database query.\n\nThe core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `RANK` column of the `REVIEW` table. The result of this query is then stored into the `v_review_rank` local variable.\n\nThe `SELECT` statement includes a `FROM` clause that specifies the `REVIEW` table. It uses a `JOIN` to combine rows from the `REVIEW` table with rows from the `BOOK` table. The join condition is `REVIEW.BOOK_ID = BOOK.BOOK_ID`, linking reviews to their corresponding books based on the matching `BOOK_ID` column.\n\nThe `SELECT` statement includes a `WHERE` clause that filters the joined result set. The condition in the `WHERE` clause is `BOOK.TITLE = p_book_title`, which means only rows where the value in the `TITLE` column of the `BOOK` table matches the value provided in the `p_book_title` input parameter are considered for retrieving the rank.\n\nAfter the `SELECT` statement has executed and the rank value is stored in `v_review_rank`, the function then returns the value stored in `v_review_rank` as its output. If no matching book title is found, the function will handle the `NO_DATA_FOUND` exception implicitly by not finding a row to fetch into the variable, which would need to be managed in a complete implementation, but the described logic assumes a match exists."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_device_stock_info` that accepts a single input parameter, `p_device_id`, which is of the `NUMBER` data type. This function is designed to return a single value of the `NUMBER` data type. Upon execution, the function declares a local variable named `v_total_stock` of the `NUMBER` data type. The core operation of the function involves executing a `SELECT` statement to calculate the sum of the `QUANTITY` column from the `STOCK` table. This summation is performed only for rows where the `DEVICE_ID` column in the `STOCK` table matches the value provided by the input parameter `p_device_id`. The result of this summation is then stored into the local variable `v_total_stock`. Finally, the function returns the value of `v_total_stock`. If `v_total_stock` is `NULL` (which would occur if no matching `DEVICE_ID` records are found in the `STOCK` table), the `NVL` function is used to return `0` instead of `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_stock_info(p_device_id IN NUMBER) RETURN NUMBER IS\n    v_total_stock NUMBER;\nBEGIN\n    SELECT SUM(QUANTITY) INTO v_total_stock FROM STOCK WHERE DEVICE_ID = p_device_id;\n    RETURN NVL(v_total_stock, 0);\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_device_stock_info(1) FROM DUAL",
      "SELECT get_device_stock_info(2) FROM DUAL",
      "SELECT get_device_stock_info(3) FROM DUAL",
      "SELECT get_device_stock_info(6) FROM DUAL",
      "SELECT get_device_stock_info(99) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_device_stock_info` that accepts a `p_device_id` (NUMBER) and returns a NUMBER. It calculates the total stock quantity for the given device ID from the `STOCK` table, returning 0 if no stock is found.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_device_stock_info`? It should take a device ID (as a NUMBER) and spit back a NUMBER. Basically, it needs to add up all the stock we have for that specific device from the STOCK table. If there's no stock found for it, just have it return a zero.",
    "id": 41,
    "generated_ir": "Write an Oracle PL/SQL function named `get_device_stock_info` that accepts a single input parameter, `p_device_id`, which is of the `NUMBER` data type. This function is designed to return a single value of the `NUMBER` data type. Upon execution, the function declares a local variable named `v_total_stock` of the `NUMBER` data type. The core operation of the function involves executing a `SELECT` statement to calculate the sum of the `QUANTITY` column from the `STOCK` table. This summation is performed only for rows where the `DEVICE_ID` column in the `STOCK` table matches the value provided by the input parameter `p_device_id`. The result of this summation is then stored into the local variable `v_total_stock`. Finally, the function returns the value of `v_total_stock`. If `v_total_stock` is `NULL` (which would occur if no matching `DEVICE_ID` records are found in the `STOCK` table), the `NVL` function is used to return `0` instead of `NULL`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_movie_title_length that calculates and returns a numeric value representing the average length of movie titles stored in the TITLE column of the MOVIE table. The function does not take any input parameters. Inside the function, a local variable named avg_length of type NUMBER is declared to store the result of the calculation. The function executes a SQL SELECT statement that computes the average length of all values in the TITLE column by using the LENGTH function to determine the length of each title. The AVG function is then applied to these lengths to calculate the average. The result of this calculation is stored in the avg_length variable using the INTO clause. Finally, the function returns the value of avg_length, which represents the average length of the movie titles in the MOVIE table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_movie_title_length RETURN NUMBER IS\n  avg_length NUMBER;\nBEGIN\n  SELECT AVG(LENGTH(TITLE)) INTO avg_length FROM MOVIE;\n  RETURN avg_length;\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "SELECT get_movie_title_length FROM dual",
      "SELECT get_movie_title_length() FROM dual",
      "DECLARE\n  avg_len NUMBER;\nBEGIN\n  avg_len := get_movie_title_length;\n  DBMS_OUTPUT.PUT_LINE('Average title length: ' || avg_len);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Result: ' || get_movie_title_length);\nEND;",
      "SELECT m.title, LENGTH(m.title), get_movie_title_length AS avg_length FROM movie m WHERE m.mid = 101"
    ],
    "summary": "Create a PL/SQL function named get_movie_title_length that returns the average character length of the TITLE column in the MOVIE table.",
    "natural_language": "Write a PL/SQL function called get_movie_title_length that gives us a rough idea of the typical length, in characters, for the TITLE entries in the MOVIE table.",
    "id": 42,
    "generated_ir": "Write an Oracle PL/SQL function named get_movie_title_length that returns a VARCHAR2 value, which provides a summary of the typical character length of movie titles. The function declares a local variable v_avg_length of type NUMBER to store the average length, a variable v_median_length of type NUMBER to store the median length, and a variable v_result of type VARCHAR2(200) to format the final output string. The function performs a SELECT operation on the MOVIE table to calculate the average character length of the TITLE column using the AVG(LENGTH(TITLE)) function, storing this value in v_avg_length. It then performs another SELECT operation on the MOVIE table to calculate the median character length of the TITLE column using the MEDIAN(LENGTH(TITLE)) function, storing this value in v_median_length. The function then constructs the v_result string by concatenating the literal 'Average: ' with the rounded v_avg_length (using ROUND to zero decimal places), the literal ', Median: ' with the rounded v_median_length, and the literal ' characters'. Finally, the function returns the v_result string as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_average_council_tax that accepts a single input parameter, master_customer_id, of type NUMBER, which represents the unique identifier for a master customer. The function calculates and returns a NUMBER representing the average value of the COUNCIL_TAX_ID column from the COUNCIL_TAX table. This calculation is performed by executing a SELECT statement that computes the average of the COUNCIL_TAX_ID values. The SELECT statement involves a JOIN operation between the COUNCIL_TAX table and the CMI_CROSS_REFERENCES table, using the CMI_CROSS_REF_ID column as the joining key. The JOIN condition ensures that only those rows from the COUNCIL_TAX table are considered where the CMI_CROSS_REF_ID matches the corresponding CMI_CROSS_REF_ID in the CMI_CROSS_REFERENCES table. Additionally, the WHERE clause filters the results to include only those rows where the MASTER_CUSTOMER_ID column in the CMI_CROSS_REFERENCES table matches the input parameter master_customer_id. The result of the average calculation is stored in a local variable named avg_council_tax, which is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_council_tax(master_customer_id IN NUMBER) RETURN NUMBER IS\n  avg_council_tax NUMBER;\nBEGIN\n  SELECT AVG(COUNCIL_TAX_ID)\n  INTO avg_council_tax\n  FROM COUNCIL_TAX ct\n  JOIN CMI_CROSS_REFERENCES ccr ON ct.CMI_CROSS_REF_ID = ccr.CMI_CROSS_REF_ID\n  WHERE ccr.MASTER_CUSTOMER_ID = master_customer_id;\n  RETURN avg_council_tax;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_average_council_tax(1) FROM DUAL",
      "SELECT get_average_council_tax(2) FROM DUAL",
      "SELECT get_average_council_tax(3) FROM DUAL",
      "SELECT get_average_council_tax(4) FROM DUAL",
      "SELECT get_average_council_tax(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_average_council_tax` that accepts a `master_customer_id` (NUMBER) and returns the average value of `COUNCIL_TAX_ID` (NUMBER) from the `COUNCIL_TAX` table, joined with `CMI_CROSS_REFERENCES` on `CMI_CROSS_REF_ID`, filtered by the input `MASTER_CUSTOMER_ID`.",
    "natural_language": "Please construct a PL/SQL function designated as `get_average_council_tax`. This function should accept a single numeric parameter, `master_customer_id`, and return the computed average of the `COUNCIL_TAX_ID` column, which is of the NUMBER data type. The average is to be derived from the `COUNCIL_TAX` table, which must be joined with the `CMI_CROSS_REFERENCES` table using the `CMI_CROSS_REF_ID` column as the join condition. The data set must be filtered such that only records corresponding to the provided `MASTER_CUSTOMER_ID` input parameter are considered in the calculation.",
    "id": 43,
    "generated_ir": "Write an Oracle PL/SQL function named get_average_council_tax that accepts a single input parameter, p_master_customer_id, of data type NUMBER. This function returns a NUMBER representing the computed average of the COUNCIL_TAX_ID column from the COUNCIL_TAX table, filtered and joined based on the provided master customer identifier.\n\nThe function begins by declaring a local variable, v_average_tax, of type NUMBER to store the result of the average calculation.\n\nThe core operation is a SELECT statement that calculates the average of the COUNCIL_TAX_ID column. This SELECT statement queries from the COUNCIL_TAX table, aliased as 'ct'. It performs an INNER JOIN with the CMI_CROSS_REFERENCES table, aliased as 'ccr', on the condition that ct.CMI_CROSS_REF_ID equals ccr.CMI_CROSS_REF_ID. The WHERE clause filters the joined result set to include only those records where ccr.MASTER_CUSTOMER_ID equals the input parameter p_master_customer_id.\n\nThe calculated average value from this filtered and joined dataset is then stored into the local variable v_average_tax. Finally, the function returns the value stored in v_average_tax."
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_manufacturer_status that accepts a single input parameter p_code of type NUMBER, which represents the code of a manufacturer. The function retrieves the REVENUE value from the MANUFACTURERS table for the row where the CODE column matches the provided p_code. It stores this REVENUE value in a local variable v_revenue of type NUMBER. The function then evaluates the value of v_revenue using a conditional statement. If v_revenue is greater than 100, the function returns the string 'Premium'. If v_revenue is less than or equal to 100, it returns the string 'Standard'. If none of these conditions are met, which is theoretically impossible given the conditions, it returns 'Unknown'. The function is designed to categorize manufacturers based on their revenue into 'Premium' or 'Standard' status.",
    "plsql": "CREATE OR REPLACE FUNCTION check_manufacturer_status(p_code NUMBER) RETURN VARCHAR2 IS\n  v_revenue NUMBER;\nBEGIN\n  SELECT REVENUE INTO v_revenue FROM MANUFACTURERS WHERE CODE = p_code;\n  \n  IF v_revenue > 100 THEN\n    RETURN 'Premium';\n  ELSIF v_revenue <= 100 THEN\n    RETURN 'Standard';\n  ELSE\n    RETURN 'Unknown';\n  END IF;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT check_manufacturer_status(1) FROM DUAL",
      "SELECT check_manufacturer_status(2) FROM DUAL",
      "SELECT check_manufacturer_status(3) FROM DUAL",
      "SELECT check_manufacturer_status(4) FROM DUAL",
      "SELECT check_manufacturer_status(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named check_manufacturer_status that accepts a NUMBER parameter p_code. It should retrieve the REVENUE from the MANUFACTURERS table for the matching CODE. Return 'Premium' if revenue > 100, 'Standard' if <= 100, otherwise 'Unknown'.",
    "natural_language": "Develop a PL/SQL function, which should be named check_manufacturer_status, that is designed to accept a single numeric parameter identified as p_code. This function must query the MANUFACTURERS table to carefully extract the REVENUE value specifically associated with the provided CODE. Subsequently, it should return the descriptive label 'Premium' in cases where the retrieved revenue definitively exceeds 100, the label 'Standard' if the revenue is determined to be less than or equal to 100, and finally, the label 'Unknown' for any other scenario.",
    "id": 44,
    "generated_ir": "Write an Oracle PL/SQL function named check_manufacturer_status that accepts a single input parameter p_code of the NUMBER data type and returns a value of the VARCHAR2 data type. The function declares a local variable v_revenue of the NUMBER data type to store the revenue retrieved from the database. It executes a SELECT statement that queries the MANUFACTURERS table to retrieve the REVENUE column value for the row where the CODE column equals the provided p_code parameter value, storing the result into the local variable v_revenue. After fetching the revenue, the function uses conditional logic: if the value of v_revenue is greater than 100, it returns the string literal 'Premium'; else if the value of v_revenue is less than or equal to 100, it returns the string literal 'Standard'; otherwise, for any other scenario (which includes cases where v_revenue is null or does not meet the previous conditions), it returns the string literal 'Unknown'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_claim_amount` that accepts a single input parameter. This parameter, named `para_Policy_ID`, is of the `NUMBER` data type and is intended to represent a unique identifier for a policy. The function is designed to return a single value of the `NUMBER` data type, which will represent the total claim amount associated with the provided policy ID.\n\nUpon execution, the function declares a local variable named `claim_amount` of the `NUMBER` data type to temporarily store the calculated sum of claimed amounts. The core operation involves a `SELECT` statement that calculates the sum of values from the `AMOUNT_CLAIMED` column. This summation is performed on rows within the `CLAIMS` table. The `WHERE` clause of the `SELECT` statement filters these rows, ensuring that only those records where the `POLICY_ID` column matches the value provided by the input parameter `para_Policy_ID` are included in the sum. The result of this summation is then stored into the `claim_amount` local variable.\n\nFollowing the data retrieval, the function proceeds with a conditional check using an `IF` statement. It evaluates whether the `claim_amount` variable is `NOT NULL`. If `claim_amount` contains a non-null value (meaning that at least one claim was found for the given `para_Policy_ID` and its `AMOUNT_CLAIMED` was summed), the function immediately returns the value stored in `claim_amount`. Conversely, if the `claim_amount` variable is `NULL` (which would occur if no claims were found for the specified `para_Policy_ID`, resulting in `SUM()` returning `NULL`), the `ELSE` block is executed, and the function returns the numeric value `0`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_claim_amount(para_Policy_ID NUMBER) RETURN NUMBER IS claim_amount NUMBER;\nBEGIN\n  SELECT SUM(AMOUNT_CLAIMED) INTO claim_amount FROM CLAIMS WHERE POLICY_ID = para_Policy_ID;\n  \n  IF claim_amount IS NOT NULL THEN\n    RETURN claim_amount;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMER_POLICIES",
      "CUSTOMERS"
    ],
    "call_sqls": [
      "SELECT get_claim_amount(744) FROM DUAL",
      "SELECT get_claim_amount(552) FROM DUAL",
      "SELECT get_claim_amount(473) FROM DUAL",
      "SELECT get_claim_amount(119) FROM DUAL",
      "SELECT get_claim_amount(141) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_claim_amount` that accepts a policy ID number and returns the total sum of claimed amounts for that policy from the CLAIMS table. If no claims are found, return 0.",
    "natural_language": "Please construct a PL/SQL function designated as `get_claim_amount`. This function shall receive a policy ID number as its input parameter. Its purpose is to compute and return the aggregate sum of all claimed amounts associated with the specified policy, as recorded in the CLAIMS table. In the event that no corresponding claims are located, the function must yield a value of zero.",
    "id": 45,
    "generated_ir": "Write an Oracle PL/SQL function named `get_claim_amount` that accepts a single input parameter. This parameter, named `para_Policy_ID`, is of the `NUMBER` data type and is intended to represent a unique identifier for a policy. The function is designed to return a single value of the `NUMBER` data type, which will represent the total claim amount associated with the provided policy ID.\n\nUpon execution, the function declares a local variable named `claim_amount` of the `NUMBER` data type to temporarily store the calculated sum of claimed amounts. The core operation involves a `SELECT` statement that calculates the sum of values from the `AMOUNT_CLAIMED` column. This summation is performed on rows within the `CLAIMS` table. The `WHERE` clause of the `SELECT` statement filters these rows, ensuring that only those records where the `POLICY_ID` column matches the value provided by the input parameter `para_Policy_ID` are included in the sum. The result of this summation is then stored into the `claim_amount` local variable.\n\nFollowing the data retrieval, the function proceeds with a conditional check using an `IF` statement. It evaluates whether the `claim_amount` variable is `NOT NULL`. If `claim_amount` contains a non-null value (meaning that at least one claim was found for the given `para_Policy_ID` and its `AMOUNT_CLAIMED` was summed), the function immediately returns the value stored in `claim_amount`. Conversely, if the `claim_amount` variable is `NULL` (which would occur if no claims were found for the specified `para_Policy_ID`, resulting in `SUM()` returning `NULL`), the `ELSE` block is executed, and the function returns the numeric value `0`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_account_name` that is designed to retrieve the name of an account based on its unique identifier. This function accepts a single input parameter, `p_account_id`, which is of the `NUMBER` data type and represents the primary key or unique identifier for an account record. The function is declared to return a value of the `VARCHAR2` data type, specifically a string of up to 255 characters, which will be the name of the account. Internally, the function declares a local variable named `v_account_name`, also of the `VARCHAR2(255)` data type, to temporarily store the retrieved account name. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `ACCOUNTS` table, specifically selecting the value from the `ACCOUNT_NAME` column. The retrieved `ACCOUNT_NAME` value is then immediately stored into the `v_account_name` local variable using the `INTO` clause. The selection of the row from the `ACCOUNTS` table is constrained by a `WHERE` clause, which specifies that only the row where the `ACCOUNT_ID` column's value is equal to the value passed in the `p_account_id` input parameter should be considered. After successfully retrieving the `ACCOUNT_NAME` into `v_account_name`, the function concludes by returning the value stored in `v_account_name` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_account_name(p_account_id NUMBER) RETURN VARCHAR2 IS\n  v_account_name VARCHAR2(255);\nBEGIN\n  SELECT ACCOUNT_NAME\n  INTO v_account_name\n  FROM ACCOUNTS\n  WHERE ACCOUNT_ID = p_account_id;\n  RETURN v_account_name;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "INVOICES",
      "INVOICE_LINE_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_account_name(1) FROM DUAL",
      "SELECT get_account_name(2) FROM DUAL",
      "SELECT get_account_name(3) FROM DUAL",
      "SELECT get_account_name(10) FROM DUAL",
      "SELECT get_account_name(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_account_name that accepts an account ID (NUMBER) and returns the corresponding account name (VARCHAR2) from the ACCOUNTS table.",
    "natural_language": "Function get_account_name: input account ID (NUMBER), output account name (VARCHAR2) from ACCOUNTS.",
    "id": 46,
    "generated_ir": "Write an Oracle PL/SQL function named `get_account_name` that is designed to retrieve the name of an account based on its unique identifier. This function accepts a single input parameter, `p_account_id`, which is of the `NUMBER` data type and represents the primary key or unique identifier for an account record. The function is declared to return a value of the `VARCHAR2` data type, specifically a string of up to 255 characters, which will be the name of the account. Internally, the function declares a local variable named `v_account_name`, also of the `VARCHAR2(255)` data type, to temporarily store the retrieved account name. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `ACCOUNTS` table, specifically selecting the value from the `ACCOUNT_NAME` column. The retrieved `ACCOUNT_NAME` value is then immediately stored into the `v_account_name` local variable using the `INTO` clause. The selection of the row from the `ACCOUNTS` table is constrained by a `WHERE` clause, which specifies that only the row where the `ACCOUNT_ID` column's value is equal to the value passed in the `p_account_id` input parameter should be considered. After successfully retrieving the `ACCOUNT_NAME` into `v_account_name`, the function concludes by returning the value stored in `v_account_name` as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_product_price_increase that accepts two input parameters: a numeric parameter p_product_id to identify a specific product and a numeric parameter p_percentage representing a percentage increase value. The function executes a SELECT statement that queries the PRODUCTS table, specifically retrieving the PRODUCT_PRICE column for the single row where the PRODUCT_ID column matches the provided p_product_id parameter. It then performs an arithmetic calculation on the retrieved price, multiplying it by the expression (1 + p_percentage/100), which effectively increases the original price by the specified percentage. The result of this calculation is stored in a local variable v_new_price. The function concludes by returning the calculated v_new_price as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_product_price_increase(p_product_id NUMBER, p_percentage NUMBER) RETURN NUMBER IS\n    v_new_price NUMBER;\nBEGIN\n    SELECT PRODUCT_PRICE * (1 + p_percentage/100) INTO v_new_price FROM PRODUCTS WHERE PRODUCT_ID = p_product_id;\n    RETURN v_new_price;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT calculate_product_price_increase(117, 10) FROM DUAL",
      "SELECT calculate_product_price_increase(118, 5) FROM DUAL",
      "SELECT calculate_product_price_increase(119, 15) FROM DUAL",
      "SELECT calculate_product_price_increase(117, 20) FROM DUAL",
      "SELECT calculate_product_price_increase(118, 2.5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `calculate_product_price_increase` that returns a NUMBER. It takes a product ID and a percentage increase (both NUMBER) as input. The function queries the PRODUCTS table for the PRODUCT_PRICE of the given product ID, calculates the new price by increasing it by the specified percentage, and returns the result.",
    "natural_language": "Write a PL/SQL function called `calculate_product_price_increase` that returns a NUMBER. It must accept a product ID and a percentage increase, both as NUMBER inputs. Have the function look up the PRODUCT_PRICE from the PRODUCTS table for the provided product ID, compute the new price by applying the percentage increase, and then return that new price.",
    "id": 47,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_product_price_increase that accepts two input parameters: p_product_id of type NUMBER, representing the unique identifier of a product, and p_percentage_increase of type NUMBER, representing the percentage increase to be applied. The function returns a single numerical value of type NUMBER. The function's primary operation involves querying the PRODUCTS table. It executes a SELECT statement to retrieve the PRODUCT_PRICE column from the PRODUCTS table where the PRODUCT_ID column exactly matches the value provided in the p_product_id input parameter. The retrieved price value is stored into a local variable named v_current_price of type NUMBER. The function then performs a calculation to determine the new price: it multiplies v_current_price by the sum of 1 and p_percentage_increase divided by 100, storing the result into a local variable named v_new_price of type NUMBER. Finally, the function returns the value stored in the v_new_price variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_enrollment_category that accepts two input parameters: a numeric parameter p_university_id and a numeric parameter p_threshold, and returns a VARCHAR2 string. The function executes a SELECT statement that queries the UNIVERSITY table, specifically retrieving the ENROLLMENT column for the row where the UNIVERSITY_ID column exactly matches the provided p_university_id parameter. For that retrieved row, it uses a CASE expression to evaluate the ENROLLMENT value: if the ENROLLMENT value is strictly greater than the input p_threshold parameter, the expression yields the string 'LARGE'; otherwise, it yields the string 'SMALL'. This resulting string is assigned to the local variable result via an INTO clause. The function then returns the value stored in the result variable. If the SELECT statement finds no rows matching the p_university_id condition, a NO_DATA_FOUND exception is raised and handled by returning a NULL value. If the SELECT statement unexpectedly finds more than one row matching the p_university_id condition, a TOO_MANY_ROWS exception is raised and handled by also returning a NULL value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_enrollment_category(p_university_id NUMBER, p_threshold NUMBER) RETURN VARCHAR2 IS\n  result VARCHAR2(10);\nBEGIN\n  SELECT CASE WHEN ENROLLMENT > p_threshold THEN 'LARGE' ELSE 'SMALL' END \n  INTO result \n  FROM UNIVERSITY \n  WHERE UNIVERSITY_ID = p_university_id;\n  \n  RETURN result;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN NULL;\n  WHEN TOO_MANY_ROWS THEN\n    RETURN NULL;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "SELECT get_enrollment_category(1, 2000) FROM dual",
      "SELECT get_enrollment_category(2, 3000) FROM dual",
      "SELECT get_enrollment_category(3, 1500) FROM dual",
      "SELECT get_enrollment_category(1, 2500) FROM dual",
      "SELECT get_enrollment_category(2, 4000) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_enrollment_category that accepts a university ID and a threshold. It returns 'LARGE' if the university's enrollment exceeds the threshold, otherwise 'SMALL'. Handle no data found and too many rows exceptions by returning NULL.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_enrollment_category? It should take a uni ID and a cutoff number. If the uni's student count is bigger than that cutoff, spit out 'LARGE'. If not, just say 'SMALL'. Oh, and if it can't find the uni or finds too many, just have it return NULL to keep things simple.",
    "id": 48,
    "generated_ir": "Write an Oracle PL/SQL function named get_enrollment_category that takes two input parameters: a parameter named p_university_id of type NUMBER to represent the university identifier, and a parameter named p_cutoff of type NUMBER to represent the enrollment threshold. The function returns a VARCHAR2 data type value, which will be either 'LARGE', 'SMALL', or NULL.\n\nThe function declares a local variable v_enrollment of type NUMBER to temporarily hold the student count retrieved from the database.\n\nThe function's execution block begins with a single SQL SELECT operation. It queries the UNIVERSITY table, specifically selecting the ENROLLMENT column value for the row where the UNIVERSITY_ID column matches the input parameter p_university_id. This retrieved enrollment value is stored into the local variable v_enrollment using the INTO clause.\n\nThis SELECT statement is enclosed within an exception handling block to manage potential errors. If the SELECT statement finds no matching row (a NO_DATA_FOUND exception), the function's logic will handle this by returning a NULL value. If the SELECT statement unexpectedly returns more than one row for the given ID (a TOO_MANY_ROWS exception), the function will also handle this by returning a NULL value.\n\nFollowing the successful retrieval of the enrollment value into v_enrollment, the function implements a conditional logic check using an IF-THEN-ELSE construct. It compares the value in v_enrollment against the input parameter p_cutoff. If v_enrollment is greater than p_cutoff, the function returns the string 'LARGE'. Otherwise, the function returns the string 'SMALL'.\n\nThe function concludes by outputting the determined category string or NULL, as dictated by the data retrieval and comparison logic."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_manufacturer_name that accepts a single input parameter p_manufacturer_code of type NUMBER and returns a value of type VARCHAR2, which declares a local variable v_name of type VARCHAR2 with a maximum length of 255 characters, and within its execution block performs a SELECT operation on the manufacturers table to retrieve the value from the name column, assigning it into the local variable v_name, using a WHERE clause condition that specifies the code column must be equal to the input parameter p_manufacturer_code, and finally returns the value stored in the v_name variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_manufacturer_name(p_manufacturer_code NUMBER) RETURN VARCHAR2 IS\n    v_name VARCHAR2(255);\nBEGIN\n    SELECT name INTO v_name FROM manufacturers WHERE code = p_manufacturer_code;\n    RETURN v_name;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_manufacturer_name(1) FROM DUAL",
      "SELECT get_manufacturer_name(2) FROM DUAL",
      "SELECT get_manufacturer_name(3) FROM DUAL",
      "SELECT get_manufacturer_name(4) FROM DUAL",
      "SELECT get_manufacturer_name(5) FROM DUAL"
    ],
    "summary": "Create a function named get_manufacturer_name that takes a manufacturer code number as input, retrieves the corresponding name from the manufacturers table, and returns it as a VARCHAR2.",
    "natural_language": "Make a function called get_manufacturer_name that, when given a certain manufacturer code, fetches the related name from the manufacturers list and gives it back as a VARCHAR2.",
    "id": 49,
    "generated_ir": "Write an Oracle PL/SQL function named get_manufacturer_name that accepts one input parameter: a NUMBER parameter p_manufacturer_code to specify a manufacturer's identifier, and returns a single VARCHAR2 value representing the manufacturer's name. The function initializes a local variable v_manufacturer_name of type VARCHAR2 with a maximum length of 255 characters. It then executes a SELECT statement that queries data from the MANUFACTURERS table. The SELECT statement retrieves the value from the NAME column. The WHERE clause of the SELECT statement specifies that the CODE column in the MANUFACTURERS table must be equal to the input parameter p_manufacturer_code. The value retrieved from the NAME column for the row corresponding to the provided manufacturer code is then stored into the local variable v_manufacturer_name. Finally, the function returns the value stored in the v_manufacturer_name variable. If no row is found matching the provided manufacturer code, the function will handle the NO_DATA_FOUND exception implicitly by not assigning a value to v_manufacturer_name, resulting in the function returning a NULL value."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_company_market_to_sales` that accepts two input parameters: `para_company_id` of data type `NUMBER` which represents a unique identifier for a company, and `para_rank` of data type `NUMBER` which represents a specific ranking associated with a company. This function is designed to return a single value of data type `NUMBER`. The function's execution begins by declaring a local variable named `v_ratio` of data type `NUMBER` to temporarily store the calculated market-to-sales ratio. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `COMPANY` table. Specifically, it calculates a ratio by dividing the value from the `MARKET_VALUE` column by the value from the `SALES_BILLION` column. This calculated ratio is then rounded to three decimal places using the `ROUND` function. The result of this calculation is then assigned to the local variable `v_ratio`. The `SELECT` statement includes a `WHERE` clause to filter the rows from the `COMPANY` table, ensuring that only the row where the `COMPANY_ID` column matches the value provided in the `para_company_id` input parameter AND the `RANK` column matches the value provided in the `para_rank` input parameter is considered for the calculation. After the `SELECT` statement successfully executes and `v_ratio` is populated, the function concludes by returning the value stored in the `v_ratio` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_company_market_to_sales(para_company_id NUMBER, para_rank NUMBER) RETURN NUMBER IS\n  v_ratio NUMBER;\nBEGIN\n  SELECT ROUND(MARKET_VALUE / SALES_BILLION, 3) INTO v_ratio FROM COMPANY WHERE COMPANY_ID = para_company_id AND RANK = para_rank;\n  RETURN v_ratio;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "SELECT get_company_market_to_sales(1, 1) FROM DUAL",
      "SELECT get_company_market_to_sales(2, 3) FROM DUAL",
      "SELECT get_company_market_to_sales(3, 4) FROM DUAL",
      "SELECT get_company_market_to_sales(1, 3) FROM DUAL",
      "SELECT get_company_market_to_sales(2, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_company_market_to_sales` that returns a NUMBER. It accepts a company ID and a rank as input parameters. The function calculates and returns the market-to-sales ratio (MARKET_VALUE / SALES_BILLION) rounded to three decimal places from the COMPANY table, filtered by the matching COMPANY_ID and RANK.",
    "natural_language": "Write a PL/SQL function that gives back a NUMBER. It should take a company identifier and a rank number. The function needs to figure out a kind of market-to-sales figure (using MARKET_VALUE divided by SALES_BILLION) for a company from the COMPANY data, making sure it's for the right company and its general standing. The final number should be trimmed to roughly three decimal places.",
    "id": 50,
    "generated_ir": "Write an Oracle PL/SQL function named `get_company_market_to_sales` that accepts two input parameters: `p_company_id` of type `NUMBER` to identify a specific company and `p_rank` of type `NUMBER` to specify a rank number. The function returns a `NUMBER` value representing a calculated market-to-sales figure. The function begins by declaring a local variable `v_market_to_sales` of type `NUMBER` to store the calculation result. It then executes a `SELECT` statement to retrieve the `MARKET_VALUE` and `SALES_BILLION` columns from the `COMPANY` table for the row where the `COMPANY_ID` column matches the provided `p_company_id` input parameter and the `RANK` column matches the provided `p_rank` input parameter. The function calculates the market-to-sales figure by dividing the retrieved `MARKET_VALUE` by the retrieved `SALES_BILLION`. This calculated value is then rounded to three decimal places using the `ROUND` function. The rounded result is stored in the `v_market_to_sales` variable. Finally, the function returns the value stored in `v_market_to_sales`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named CHECK_MUSICAL_YEAR that accepts a single input parameter p_musical_id of the NUMBER data type, which is used to identify a specific musical record, and returns a VARCHAR2 string. The function begins by declaring a local variable v_year of type NUMBER. It then executes a SELECT statement to query the MUSICAL table, specifically retrieving the value from the YEAR column for the single row where the MUSICAL_ID column exactly matches the provided input parameter p_musical_id, and stores this retrieved year value into the local variable v_year. Following this data retrieval, the function evaluates a conditional IF statement: it checks if the value stored in v_year is numerically less than 1990. If this condition is true, the function immediately returns the string literal 'OLD'. If the condition is false, meaning the year is 1990 or greater, the function executes the ELSE branch and returns the string literal 'NEW'.",
    "plsql": "CREATE OR REPLACE FUNCTION CHECK_MUSICAL_YEAR(p_musical_id NUMBER) RETURN VARCHAR2 IS\n  v_year NUMBER;\nBEGIN\n  SELECT YEAR INTO v_year FROM MUSICAL WHERE MUSICAL_ID = p_musical_id;\n  IF v_year < 1990 THEN\n    RETURN 'OLD';\n  ELSE\n    RETURN 'NEW';\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT CHECK_MUSICAL_YEAR(1) FROM DUAL",
      "SELECT CHECK_MUSICAL_YEAR(2) FROM DUAL",
      "SELECT CHECK_MUSICAL_YEAR(3) FROM DUAL",
      "SELECT CHECK_MUSICAL_YEAR(4) FROM DUAL",
      "SELECT CHECK_MUSICAL_YEAR(5) FROM DUAL"
    ],
    "summary": "Create a function named CHECK_MUSICAL_YEAR that takes a musical_id (NUMBER) and returns a VARCHAR2. It retrieves the year from the MUSICAL table for the given ID. If the year is less than 1990, return 'OLD'; otherwise, return 'NEW'.",
    "natural_language": "Define a function called CHECK_MUSICAL_YEAR that accepts a musical_id parameter of type NUMBER and yields a VARCHAR2 output. The function shall query the MUSICAL table to obtain the year associated with the provided identifier. Should the retrieved year be prior to 1990, the function is to return the string 'OLD'; if not, it shall return 'NEW'.",
    "id": 51,
    "generated_ir": "Write an Oracle PL/SQL function named CHECK_MUSICAL_YEAR that accepts a single input parameter, musical_id, of data type NUMBER, representing the unique identifier for a musical. The function returns a value of data type VARCHAR2, which will be either 'OLD' or 'NEW' based on the year of the specified musical.\n\nInternally, the function declares a local variable named v_year of data type NUMBER to temporarily store the year value retrieved from the database.\n\nThe core operation involves executing a SELECT statement to query the MUSICAL table. This SELECT statement retrieves the value from the YEAR column for the row where the MUSICAL_ID column matches the value provided by the musical_id input parameter. The result of this query is stored into the v_year local variable.\n\nAfter retrieving the year, the function evaluates a conditional statement using an IF-THEN-ELSE structure. It checks if the value stored in v_year is less than 1990. If this condition is true, the function returns the string literal 'OLD'. If the condition is false (meaning the year is 1990 or later), the function returns the string literal 'NEW'.\n\nFinally, the function concludes by returning the determined string value."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_member_timezone` that accepts a single input parameter, `p_member_id`, of data type `NUMBER`. This function is designed to return a `VARCHAR2` value representing a timezone. Inside the function's executable block, a local variable named `v_timezone` is declared with a `VARCHAR2` data type and a maximum length of 50 characters. The first operation performed is an assignment to this `v_timezone` variable. The value assigned is the result of calling the built-in Oracle SQL function `SESSIONTIMEZONE`. This function retrieves the current session's time zone, which is typically set by the `TIME_ZONE` parameter in the `ALTER SESSION` command or inherited from the database or operating system environment. After this assignment, the function immediately returns the value currently stored in the `v_timezone` variable. The `p_member_id` parameter is declared but is not utilized within the function's logic to retrieve or process any data.",
    "plsql": "CREATE OR REPLACE FUNCTION get_member_timezone(p_member_id NUMBER) RETURN VARCHAR2 IS\n    v_timezone VARCHAR2(50);\nBEGIN\n    v_timezone := SESSIONTIMEZONE;\n    RETURN v_timezone;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_member_timezone(1) FROM DUAL",
      "SELECT get_member_timezone(2) FROM DUAL",
      "SELECT get_member_timezone(10) FROM DUAL",
      "SELECT get_member_timezone(100) FROM DUAL",
      "SELECT get_member_timezone(NULL) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_member_timezone that accepts a member ID (NUMBER) and returns a VARCHAR2. It should return the current session's timezone using SESSIONTIMEZONE. The input parameter is declared but not used within the function logic.",
    "natural_language": "Write a PL/SQL function called get_member_timezone that takes a member ID number and gives back a string. It should basically fetch the kind of timezone setting that's currently active for the session, using that SESSIONTIMEZONE thing. The member ID you pass in is there, but you don't really do anything with it inside the function.",
    "id": 52,
    "generated_ir": "Write an Oracle PL/SQL function named `get_member_timezone` that accepts a single input parameter, `p_member_id`, of data type `NUMBER`. This function is designed to return a `VARCHAR2` value representing a timezone. Inside the function's executable block, a local variable named `v_timezone` is declared with a `VARCHAR2` data type and a maximum length of 50 characters. The first operation performed is an assignment to this `v_timezone` variable. The value assigned is the result of calling the built-in Oracle SQL function `SESSIONTIMEZONE`. This function retrieves the current session's time zone, which is typically set by the `TIME_ZONE` parameter in the `ALTER SESSION` command or inherited from the database or operating system environment. After this assignment, the function immediately returns the value currently stored in the `v_timezone` variable. The `p_member_id` parameter is declared but is not utilized within the function's logic to retrieve or process any data."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `VERIFY_CHARACTER_LENGTH` that accepts a single input parameter, `p_actor_id`, which is of data type `NUMBER`. This function is designed to return a `NUMBER` value. Internally, the function declares a local variable named `v_length`, also of data type `NUMBER`, to temporarily store a calculated length. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the `LENGTH` of the `CHARACTER` column from the `ACTOR` table. The `LENGTH` function is an Oracle SQL built-in function that calculates the number of characters in a string. The retrieval is conditional, specifically targeting rows in the `ACTOR` table where the `ACTOR_ID` column matches the value provided by the input parameter `p_actor_actor_id`. The result of this `LENGTH` calculation is then stored into the `v_length` local variable. Following this data retrieval, the function proceeds with a conditional logic block (`IF` statement). It evaluates whether the value stored in `v_length` is strictly greater than the numeric literal `15`. If this condition (`v_length > 15`) evaluates to `TRUE`, the function immediately returns the numeric literal `1`. Otherwise, if the condition evaluates to `FALSE` (meaning `v_length` is less than or equal to `15`), the function executes the `ELSE` block and returns the numeric literal `0`.",
    "plsql": "CREATE OR REPLACE FUNCTION VERIFY_CHARACTER_LENGTH(p_actor_id NUMBER) RETURN NUMBER IS\n  v_length NUMBER;\nBEGIN\n  SELECT LENGTH(CHARACTER) INTO v_length FROM ACTOR WHERE ACTOR_ID = p_actor_id;\n  IF v_length > 15 THEN\n    RETURN 1;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT VERIFY_CHARACTER_LENGTH(1) FROM DUAL",
      "SELECT VERIFY_CHARACTER_LENGTH(2) FROM DUAL",
      "SELECT VERIFY_CHARACTER_LENGTH(3) FROM DUAL",
      "SELECT VERIFY_CHARACTER_LENGTH(4) FROM DUAL",
      "SELECT VERIFY_CHARACTER_LENGTH(5) FROM DUAL"
    ],
    "summary": "Create a function named VERIFY_CHARACTER_LENGTH that takes an actor_id (NUMBER) and returns a NUMBER. It calculates the length of the CHARACTER name from the ACTOR table for the given ID. If the length is greater than 15, return 1; otherwise, return 0.",
    "natural_language": "Develop a function called VERIFY_CHARACTER_LENGTH which accepts a single numeric input parameter representing an actor_id and yields a numeric output. This function should meticulously compute the precise length of the CHARACTER name entry, retrieved specifically from the ACTOR table based on the provided identifier. Should this calculated length be determined to exceed fifteen characters, the function must conclusively return the value one; in all other cases, it should definitively return the value zero.",
    "id": 53,
    "generated_ir": "Write an Oracle PL/SQL function named VERIFY_CHARACTER_LENGTH that accepts a single input parameter, p_actor_id, of data type NUMBER, representing the unique identifier of an actor. The function returns a NUMBER value, where 1 indicates that the length of the character name associated with the given actor_id exceeds fifteen characters, and 0 indicates it does not.\n\nUpon execution, the function first declares a local variable, v_character_name, of data type VARCHAR2(255), to store the retrieved CHARACTER column value from the ACTOR table. It also declares a local variable, v_character_length, of data type NUMBER, to store the computed length of the character name. A third local variable, v_result, of data type NUMBER, is declared to hold the final return value, initialized to 0.\n\nThe function then performs a SELECT operation. This SELECT statement retrieves the value from the CHARACTER column of the ACTOR table and assigns it to the v_character_name variable. The retrieval is conditioned by a WHERE clause that matches the ACTOR_ID column in the ACTOR table with the value provided in the p_actor_id input parameter.\n\nAfter successfully retrieving the character name, the function calculates its length using the LENGTH function, which counts the number of characters in the v_character_name string. The result of this calculation is assigned to the v_character_length variable.\n\nThe function then proceeds to evaluate a conditional statement (IF-THEN-ELSE) to determine the return value. The condition checks if the value stored in v_character_length is greater than 15. If this condition is true, the v_result variable is set to 1. If the condition is false, the v_result variable remains at its initialized value of 0.\n\nAfter the conditional logic has been evaluated and v_result has been assigned its final value, the function concludes by returning the current value of the v_result variable.\n\nIf the initial SELECT statement fails to find a row matching the provided p_actor_id, a NO_DATA_FOUND exception will be raised. The function includes an EXCEPTION block to handle this specific scenario. When a NO_DATA_FOUND exception is caught, the function will return the value 0, indicating that no character name was found to evaluate. If any other unexpected exception occurs during execution, it is caught by a WHEN OTHERS exception handler, which also causes the function to return the value 0."
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes a single input parameter P_PEOPLE_ID of type NUMBER, retrieves the NAME and HOMETOWN columns from the PEOPLE table for the row where the PEOPLE_ID column matches the value of P_PEOPLE_ID, and returns a formatted string based on the length of the retrieved NAME value. Specifically, the function first declares two local variables, V_NAME and V_HOMETOWN, both of type VARCHAR2 with a maximum length of 255 characters, to store the retrieved NAME and HOMETOWN values. It then executes a SELECT statement to fetch the NAME and HOMETOWN values from the PEOPLE table into these variables, using a WHERE clause to filter rows where PEOPLE_ID equals the input parameter P_PEOPLE_ID. After retrieving the values, the function evaluates the length of the NAME value using the LENGTH function. If the length of V_NAME exceeds 10 characters, the function concatenates V_NAME, the string ' from ', and V_HOMETOWN, and returns this concatenated result. Otherwise, it concatenates V_NAME, the string ' (', V_HOMETOWN, and the closing parenthesis ')', and returns this alternative concatenated result.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_PEOPLE_NAME_FORMAT(P_PEOPLE_ID NUMBER) RETURN VARCHAR2 IS\n  V_NAME VARCHAR2(255);\n  V_HOMETOWN VARCHAR2(255);\nBEGIN\n  SELECT NAME, HOMETOWN INTO V_NAME, V_HOMETOWN\n  FROM PEOPLE\n  WHERE PEOPLE_ID = P_PEOPLE_ID;\n\n  IF LENGTH(V_NAME) > 10 THEN\n    RETURN V_NAME || ' from ' || V_HOMETOWN;\n  ELSE\n    RETURN V_NAME || ' (' || V_HOMETOWN || ')';\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "SELECT GET_PEOPLE_NAME_FORMAT(1) FROM DUAL",
      "SELECT GET_PEOPLE_NAME_FORMAT(2) FROM DUAL",
      "SELECT GET_PEOPLE_NAME_FORMAT(3) FROM DUAL",
      "SELECT GET_PEOPLE_NAME_FORMAT(4) FROM DUAL",
      "SELECT GET_PEOPLE_NAME_FORMAT(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function that accepts a P_PEOPLE_ID (NUMBER) and returns a VARCHAR2. It retrieves the NAME and HOMETOWN from the PEOPLE table for the specified ID. If the name length exceeds 10 characters, return 'Name from Hometown'; otherwise, return 'Name (Hometown)'.",
    "natural_language": "Write a PL/SQL function that takes a person's ID number and gives back a text string. It should fetch the person's name and where they're from from the people records for that ID. If the name is kind of long, more than a handful of characters, then give back 'Name from Hometown'. If it's shorter, just return it as 'Name (Hometown)'.",
    "id": 54,
    "generated_ir": "Write an Oracle PL/SQL function that takes a single input parameter P_PEOPLE_ID of type NUMBER, retrieves the NAME and HOMETOWN columns from the PEOPLE table for the row where the PEOPLE_ID column matches the value of P_PEOPLE_ID, and returns a formatted string based on the length of the retrieved NAME value. Specifically, the function first declares two local variables, V_NAME and V_HOMETOWN, both of type VARCHAR2 with a maximum length of 255 characters, to store the retrieved NAME and HOMETOWN values. It then executes a SELECT statement to fetch the NAME and HOMETOWN values from the PEOPLE table into these variables, using a WHERE clause to filter rows where PEOPLE_ID equals the input parameter P_PEOPLE_ID. After retrieving the values, the function evaluates the length of the NAME value using the LENGTH function. If the length of V_NAME exceeds 10 characters, the function concatenates V_NAME, the string ' from ', and V_HOMETOWN, and returns this concatenated result. Otherwise, it concatenates V_NAME, the string ' (', V_HOMETOWN, and the closing parenthesis ')', and returns this alternative concatenated result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_focal_length` that is designed to return a single numeric value representing the maximum focal length recorded in a specific database table. This function does not accept any input parameters. Internally, it declares a local variable named `v_max_focal_length` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `CAMERA_LENS` table. Specifically, it calculates the maximum value among all entries in the `FOCAL_LENGTH_MM` column of the `CAMERA_LENS` table. The result of this aggregation (the single maximum focal length) is then immediately assigned to the `v_max_focal_length` variable using the `INTO` clause. Finally, the function concludes its execution by returning the value currently held in the `v_max_focal_length` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_focal_length\nRETURN NUMBER\nIS\n    v_max_focal_length NUMBER;\nBEGIN\n    SELECT MAX(FOCAL_LENGTH_MM) \n    INTO v_max_focal_length \n    FROM CAMERA_LENS;\n    \n    RETURN v_max_focal_length;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "SELECT get_max_focal_length FROM DUAL",
      "SELECT get_max_focal_length() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_max_focal_length;\n  DBMS_OUTPUT.PUT_LINE('Max focal length: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Maximum focal length is: ' || get_max_focal_length);\nEND;",
      "SELECT brand, name, focal_length_mm FROM camera_lens WHERE focal_length_mm = get_max_focal_length"
    ],
    "summary": "Create a PL/SQL function named get_max_focal_length with no parameters that returns the maximum value from the FOCAL_LENGTH_MM column in the CAMERA_LENS table.",
    "natural_language": "Please construct a PL/SQL function, designated as 'get_max_focal_length', which accepts no parameters and is defined to return the maximum numerical value present in the FOCAL_LENGTH_MM column of the CAMERA_LENS table.",
    "id": 55,
    "generated_ir": "Write an Oracle PL/SQL function named `get_max_focal_length` that is designed to return a single numeric value representing the maximum focal length recorded in a specific database table. This function does not accept any input parameters. Internally, it declares a local variable named `v_max_focal_length` of data type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `CAMERA_LENS` table. Specifically, it calculates the maximum value among all entries in the `FOCAL_LENGTH_MM` column of the `CAMERA_LENS` table. The result of this aggregation (the single maximum focal length) is then immediately assigned to the `v_max_focal_length` variable using the `INTO` clause. Finally, the function concludes its execution by returning the value currently held in the `v_max_focal_length` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_pet_count that accepts two input parameters: a numeric parameter p_stuid representing a student identifier and a string parameter p_pettype representing a type of pet, and returns a numeric value; within the function, a local variable v_count of type NUMBER is declared; the function's logic executes a SELECT statement that performs an INNER JOIN between the HAS_PET table (aliased as h) and the PETS table (aliased as p) using the condition that the PETID column from the HAS_PET table equals the PETID column from the PETS table; from this joined result set, the function counts all rows where the STUID column from the HAS_PET table matches the input parameter p_stuid and where the PETTYPE column from the PETS table, after being converted to uppercase using the UPPER function, matches the input parameter p_pettype after it is also converted to uppercase using the UPPER function; this count is stored into the local variable v_count via the INTO clause; the function then concludes by returning the value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_pet_count(p_stuid NUMBER, p_pettype VARCHAR2)\nRETURN NUMBER\nIS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count \n  FROM HAS_PET h \n  JOIN PETS p ON h.PETID = p.PETID \n  WHERE h.STUID = p_stuid AND UPPER(p.PETTYPE) = UPPER(p_pettype);\n  RETURN v_count;\nEND;",
    "database_name": "pets_1",
    "tables": [
      "HAS_PET",
      "PETS",
      "STUDENT"
    ],
    "call_sqls": [
      "SELECT get_student_pet_count(1001, 'cat') FROM dual",
      "SELECT get_student_pet_count(1001, 'dog') FROM dual",
      "SELECT get_student_pet_count(1002, 'cat') FROM dual",
      "SELECT get_student_pet_count(1002, 'dog') FROM dual",
      "SELECT get_student_pet_count(1001, 'CAT') FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_student_pet_count that returns a number. It accepts a student ID (number) and a pet type (string). It counts rows from an inner join of the HAS_PET and PETS tables where the student ID matches and the pet type (case-insensitive) matches, then returns the count.",
    "natural_language": "How many pets of a specified type does a given student have, based on a case-insensitive match in the HAS_PET and PETS tables?",
    "id": 56,
    "generated_ir": "Write an Oracle PL/SQL function named `get_student_pet_count` that accepts two input parameters. The first parameter, `p_stuid`, is of data type `NUMBER` and represents the unique identifier for a student. The second parameter, `p_pettype`, is of data type `VARCHAR2` and represents the type of pet to count. The function returns a `NUMBER` data type, specifically the count of pets of the specified type owned by the given student.\n\nInternally, the function declares a local variable `v_pet_count` of type `NUMBER` to temporarily store the result of the count operation.\n\nThe core operation involves a `SELECT` statement that uses the `COUNT(*)` aggregate function to calculate the number of rows. The data is retrieved from the `HAS_PET` table, aliased as `hp`, and the `PETS` table, aliased as `p`. These two tables are joined using an `INNER JOIN` condition where the `PETID` column from the `HAS_PET` table (`hp.PETID`) matches the `PETID` column from the `PETS` table (`p.PETID`), establishing the relationship between pet ownership records and pet details.\n\nThe `WHERE` clause contains two filter conditions connected by an `AND` operator. The first condition filters the results to include only the rows where the `STUID` column from the `HAS_PET` table (`hp.STUID`) matches the value provided in the input parameter `p_stuid`. The second condition performs a case-insensitive match on the pet type. It uses the `UPPER()` function to convert the `PETTYPE` column from the `PETS` table (`p.PETTYPE`) to uppercase and compares it to the result of applying the `UPPER()` function to the input parameter `p_pettype`. This ensures the match is not sensitive to differences in letter case.\n\nThe result of this `SELECT` statement, which is the count of matching rows, is then stored into the `v_pet_count` variable using the `INTO` clause. Finally, the function returns the value stored in `v_pet_count`."
  },
  {
    "ir": "Write an Oracle PL/SQL stored function named `get_total_problems` that is designed to return a single numeric value representing the total count of records within a specific database table. This function does not accept any input parameters. Internally, it declares a local variable named `total_problems` of the `NUMBER` data type to temporarily store the calculated count. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows in the `PROBLEMS` table. The result of this `COUNT(*)` aggregation is then immediately assigned to the `total_problems` local variable using the `INTO` clause. Finally, the function returns the value stored in the `total_problems` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_problems RETURN NUMBER IS\n  total_problems NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO total_problems\n  FROM PROBLEMS;\n  RETURN total_problems;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT get_total_problems FROM DUAL",
      "SELECT get_total_problems() FROM DUAL",
      "DECLARE\n  v_total_problems NUMBER;\nBEGIN\n  v_total_problems := get_total_problems;\n  DBMS_OUTPUT.PUT_LINE('Total problems: ' || v_total_problems);\nEND;",
      "SELECT get_total_problems FROM dual",
      "SELECT get_total_problems() AS total_problem_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_total_problems that returns the total number of records in the PROBLEMS table as a NUMBER.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be named get_total_problems, which will meticulously calculate and return, as a precise NUMBER data type, the complete and total count of all existing records contained within the designated PROBLEMS table.",
    "id": 57,
    "generated_ir": "Write an Oracle PL/SQL stored function named `get_total_problems` that is designed to return a single numeric value representing the total count of records within a specific database table. This function does not accept any input parameters. Internally, it declares a local variable named `total_problems` of the `NUMBER` data type to temporarily store the calculated count. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows in the `PROBLEMS` table. The result of this `COUNT(*)` aggregation is then immediately assigned to the `total_problems` local variable using the `INTO` clause. Finally, the function returns the value stored in the `total_problems` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_AWARD_STATUS that accepts a single input parameter `p_musical_id` of the NUMBER data type, which is used to identify a specific musical record, and returns a VARCHAR2 string. The function begins by declaring a local variable `v_result` of type VARCHAR2(255). It then executes a SELECT statement to query the `MUSICAL` table, retrieving the value from the `RESULT` column for the row where the `MUSICAL_ID` column exactly matches the provided input parameter `p_musical_id`, and stores this retrieved value into the local variable `v_result`. Following this data retrieval, the function evaluates the content of `v_result` using an IF-THEN-ELSE conditional statement: if the value of `v_result` is exactly equal to the string literal 'Nominated', the function returns the string 'PENDING'; otherwise, for any other value in `v_result`, the function returns the string 'FINAL'.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_AWARD_STATUS(p_musical_id NUMBER) RETURN VARCHAR2 IS\n  v_result VARCHAR2(255);\nBEGIN\n  SELECT RESULT INTO v_result FROM MUSICAL WHERE MUSICAL_ID = p_musical_id;\n  IF v_result = 'Nominated' THEN\n    RETURN 'PENDING';\n  ELSE\n    RETURN 'FINAL';\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT GET_AWARD_STATUS(1) FROM DUAL",
      "SELECT GET_AWARD_STATUS(2) FROM DUAL",
      "SELECT GET_AWARD_STATUS(3) FROM DUAL",
      "SELECT GET_AWARD_STATUS(4) FROM DUAL",
      "SELECT GET_AWARD_STATUS(5) FROM DUAL"
    ],
    "summary": "Create a function named GET_AWARD_STATUS that takes a musical_id (NUMBER) and returns a VARCHAR2. It retrieves the result from the MUSICAL table for the given ID. If the result is 'Nominated', return 'PENDING'; otherwise, return 'FINAL'.",
    "natural_language": "Make function GET_AWARD_STATUS(musical_id NUMBER) return VARCHAR2. For given ID, fetch MUSICAL table result. Return 'PENDING' if 'Nominated', else 'FINAL'.",
    "id": 58,
    "generated_ir": "Write an Oracle PL/SQL function named GET_AWARD_STATUS that accepts a single input parameter `p_musical_id` of the NUMBER data type, which is used to identify a specific musical record, and returns a VARCHAR2 string. The function begins by declaring a local variable `v_result` of type VARCHAR2(255). It then executes a SELECT statement to query the `MUSICAL` table, retrieving the value from the `RESULT` column for the row where the `MUSICAL_ID` column exactly matches the provided input parameter `p_musical_id`, and stores this retrieved value into the local variable `v_result`. Following this data retrieval, the function evaluates the content of `v_result` using an IF-THEN-ELSE conditional statement: if the value of `v_result` is exactly equal to the string literal 'Nominated', the function returns the string 'PENDING'; otherwise, for any other value in `v_result`, the function returns the string 'FINAL'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_device_availability` that accepts a single input parameter, `p_device_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_availability` of data type `NUMBER`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT` aggregation on the `SHOP_ID` column from the `STOCK` table. The `COUNT` aggregation counts the number of rows in the `STOCK` table that satisfy a specific condition. The condition for row selection is `DEVICE_ID = p_device_id`, meaning only rows where the value in the `DEVICE_ID` column of the `STOCK` table is equal to the value passed in the `p_device_id` input parameter are included in the count. The result of this `COUNT` aggregation is then stored into the local variable `v_availability`. Finally, the function returns the value currently held by the `v_availability` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_device_availability(p_device_id IN NUMBER) RETURN NUMBER IS\n    v_availability NUMBER;\nBEGIN\n    SELECT COUNT(SHOP_ID) INTO v_availability FROM STOCK WHERE DEVICE_ID = p_device_id;\n    RETURN v_availability;\nEND;",
    "database_name": "device",
    "tables": [
      "DEVICE",
      "SHOP",
      "STOCK"
    ],
    "call_sqls": [
      "SELECT get_device_availability(1) FROM DUAL",
      "SELECT get_device_availability(2) FROM DUAL",
      "SELECT get_device_availability(3) FROM DUAL",
      "SELECT get_device_availability(6) FROM DUAL",
      "SELECT get_device_availability(99) FROM DUAL"
    ],
    "summary": "Create a function named `get_device_availability` that accepts a `NUMBER` parameter `p_device_id` and returns a `NUMBER`. It should count the rows in the `STOCK` table where `DEVICE_ID` equals the input parameter and return that count.",
    "natural_language": "Make a function `get_device_availability` that takes a NUMBER `p_device_id` and returns a NUMBER. Count STOCK rows where DEVICE_ID matches the input and return the count.",
    "id": 59,
    "generated_ir": "Write an Oracle PL/SQL function named `get_device_availability` that accepts a single input parameter, `p_device_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_availability` of data type `NUMBER`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT` aggregation on the `SHOP_ID` column from the `STOCK` table. The `COUNT` aggregation counts the number of rows in the `STOCK` table that satisfy a specific condition. The condition for row selection is `DEVICE_ID = p_device_id`, meaning only rows where the value in the `DEVICE_ID` column of the `STOCK` table is equal to the value passed in the `p_device_id` input parameter are included in the count. The result of this `COUNT` aggregation is then stored into the local variable `v_availability`. Finally, the function returns the value currently held by the `v_availability` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_artist_famous_title_count that accepts a single input parameter p_artist_id of the NUMBER data type and returns a value of the NUMBER data type, which is designed to calculate and return the count of famous titles associated with a specific artist. The function declares a local variable v_title_count of type NUMBER to store the result. The core operation is a SELECT statement that queries the ARTIST table, using the COUNT(*) aggregate function to count all rows. This count is performed with a WHERE clause that specifies two conditions: the ARTIST_ID column must exactly equal the provided input parameter p_artist_id, and the FAMOUS_TITLE column for that row must not be NULL, as checked by the IS NOT NULL condition. The result of this count is retrieved from the database and stored directly into the local variable v_title_count using the INTO clause. Finally, the function concludes by returning the value stored in v_title_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_artist_famous_title_count(p_artist_id NUMBER) RETURN NUMBER IS\n    v_title_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_title_count\n    FROM ARTIST\n    WHERE ARTIST_ID = p_artist_id AND FAMOUS_TITLE IS NOT NULL;\n    RETURN v_title_count;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT get_artist_famous_title_count(1) FROM DUAL",
      "SELECT get_artist_famous_title_count(2) FROM DUAL",
      "SELECT get_artist_famous_title_count(4) FROM DUAL",
      "SELECT get_artist_famous_title_count(99) FROM DUAL",
      "SELECT get_artist_famous_title_count(0) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_artist_famous_title_count that takes an artist ID (NUMBER) and returns the count (NUMBER) of rows for that artist where the FAMOUS_TITLE column is not NULL.",
    "natural_language": "Write a PL/SQL function to get a rough number of notable works for a particular artist, based on their ID. The function should count how many entries for that artist have something filled in the column for famous titles.",
    "id": 60,
    "generated_ir": "Write an Oracle PL/SQL function named get_artist_famous_title_count that accepts a single input parameter named p_artist_id of data type NUMBER, which corresponds to the ARTIST_ID column. The function returns a single numeric value of type NUMBER, representing the count of notable works for the specified artist. The function operates within the music_4 database.\n\nThe function begins by declaring a local variable named v_count of type NUMBER to hold the computed result. The core logic executes a SELECT statement that queries the ARTIST table. This SELECT statement uses the COUNT aggregate function to calculate the number of rows. The COUNT function is applied specifically to the FAMOUS_TITLE column. The selection is conditioned by a WHERE clause that filters rows based on two criteria combined with an AND operator. The first criterion specifies that the ARTIST_ID column must equal the value provided by the input parameter p_artist_id. The second criterion uses the IS NOT NULL operator to ensure that only rows where the FAMOUS_TITLE column contains a non-null value are included in the count. Consequently, the query counts the number of entries for the given artist ID that have a populated famous title. The result of this COUNT operation is directly assigned into the local variable v_count using a SELECT INTO clause. After the SELECT INTO operation successfully completes, the function concludes by using a RETURN statement to output the value stored in the v_count variable."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_mutual_friend_count that accepts two input parameters, p_student_id of type NUMBER and p_friend_id of type NUMBER, and returns a NUMBER value. The function declares a local variable v_count of type NUMBER. The function's logic begins by executing a SELECT statement that uses the COUNT(*) aggregate function to calculate a total and stores the result into the v_count variable. This SELECT statement queries from the FRIEND table, which is aliased as f1, and performs an inner JOIN with another instance of the FRIEND table, aliased as f2, on the condition that the FRIEND_ID column value from the f1 table alias is equal to the FRIEND_ID column value from the f2 table alias. The WHERE clause of this query specifies two conditions that must both be true: the STUDENT_ID column from the f1 table alias must equal the input parameter p_student_id, and the STUDENT_ID column from the f2 table alias must equal the input parameter p_friend_id. After the SELECT statement executes, the function uses an IF-THEN-ELSE conditional statement to evaluate the v_count variable. If the v_count variable is found to be NULL, the function returns the value 0. Otherwise, if v_count is not NULL, the function returns the value stored in the v_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_mutual_friend_count(p_student_id NUMBER, p_friend_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM FRIEND f1\n    JOIN FRIEND f2 ON f1.FRIEND_ID = f2.FRIEND_ID\n    WHERE f1.STUDENT_ID = p_student_id AND f2.STUDENT_ID = p_friend_id;\n    IF v_count IS NULL THEN\n        RETURN 0;\n    ELSE\n        RETURN v_count;\n    END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_mutual_friend_count(1101, 1247) FROM DUAL",
      "SELECT get_mutual_friend_count(1381, 1689) FROM DUAL",
      "SELECT get_mutual_friend_count(1510, 1911) FROM DUAL",
      "SELECT get_mutual_friend_count(1025, 1316) FROM DUAL",
      "SELECT get_mutual_friend_count(1468, 1304) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_mutual_friend_count that accepts two student IDs (NUMBER) and returns a NUMBER. It counts mutual friends by joining the FRIEND table on FRIEND_ID where each ID is a STUDENT_ID. Return the count, or 0 if NULL.",
    "natural_language": "Develop a comprehensive PL/SQL function, to be designated as get_mutual_friend_count, which will gracefully accept two distinct student identifiers, both of the NUMBER data type, and will subsequently yield a NUMBER as its result. This function is tasked with meticulously calculating the precise count of mutual friends shared between the two specified students. It achieves this by intelligently querying the FRIEND table, performing a join operation on the FRIEND_ID column where each provided identifier corresponds to a valid STUDENT_ID entry. The function must thoughtfully return the final tally of these mutual connections; however, in the event that the result is determined to be NULL, it should considerately and automatically return a value of zero instead.",
    "id": 61,
    "generated_ir": "Write an Oracle PL/SQL function named get_mutual_friend_count that accepts two input parameters, p_student_id of type NUMBER and p_friend_id of type NUMBER, and returns a NUMBER value. The function declares a local variable v_count of type NUMBER. The function's logic begins by executing a SELECT statement that uses the COUNT(*) aggregate function to calculate a total and stores the result into the v_count variable. This SELECT statement queries from the FRIEND table, which is aliased as f1, and performs an inner JOIN with another instance of the FRIEND table, aliased as f2, on the condition that the FRIEND_ID column value from the f1 table alias is equal to the FRIEND_ID column value from the f2 table alias. The WHERE clause of this query specifies two conditions that must both be true: the STUDENT_ID column from the f1 table alias must equal the input parameter p_student_id, and the STUDENT_ID column from the f2 table alias must equal the input parameter p_friend_id. After the SELECT statement executes, the function uses an IF-THEN-ELSE conditional statement to evaluate the v_count variable. If the v_count variable is found to be NULL, the function returns the value 0. Otherwise, if v_count is not NULL, the function returns the value stored in the v_count variable."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_size_score that accepts a single parameter p_entry_id of type NUMBER, which represents the identifier of a catalog entry. The function retrieves the LENGTH and HEIGHT values from the CATALOG_CONTENTS table where the CATALOG_ENTRY_ID matches the provided p_entry_id. These values are stored in local variables v_length and v_height, both of type VARCHAR2 with a maximum length of 255 characters. The function then evaluates these values using a series of conditional statements. If both v_length and v_height are equal to '9', the function assigns a score of 10 to the local variable v_score of type NUMBER. If v_length is '6' and v_height is '5', v_score is set to 7. If v_length is '3' and v_height is '7', v_score is set to 5. For all other combinations of v_length and v_height, v_score is assigned a default value of 3. Finally, the function returns the computed score stored in v_score.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_size_score(p_entry_id NUMBER) RETURN NUMBER IS\n    v_length VARCHAR2(255);\n    v_height VARCHAR2(255);\n    v_score NUMBER;\nBEGIN\n    SELECT LENGTH, HEIGHT INTO v_length, v_height FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_length = '9' AND v_height = '9' THEN v_score := 10;\n    ELSIF v_length = '6' AND v_height = '5' THEN v_score := 7;\n    ELSIF v_length = '3' AND v_height = '7' THEN v_score := 5;\n    ELSE v_score := 3;\n    END IF;\n    RETURN v_score;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT calculate_size_score(1) FROM DUAL",
      "SELECT calculate_size_score(2) FROM DUAL",
      "SELECT calculate_size_score(3) FROM DUAL",
      "SELECT CATALOG_ENTRY_ID, calculate_size_score(CATALOG_ENTRY_ID) AS SIZE_SCORE FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = 1",
      "SELECT CC.*, calculate_size_score(CC.CATALOG_ENTRY_ID) AS SIZE_SCORE FROM CATALOG_CONTENTS CC WHERE CC.LENGTH = '9' AND CC.HEIGHT = '9'"
    ],
    "summary": "Create a PL/SQL function named calculate_size_score that takes a catalog entry ID (NUMBER) and returns a score (NUMBER). The score is based on the entry's LENGTH and HEIGHT values: 10 for ('9','9'), 7 for ('6','5'), 5 for ('3','7'), and 3 for all other combinations.",
    "natural_language": "Please construct a PL/SQL function designated as `calculate_size_score`. This function shall accept a single input parameter of type NUMBER, specifically a catalog entry identifier, and shall return a computed score, also of type NUMBER. The scoring logic is to be derived from the LENGTH and HEIGHT attributes associated with the provided entry. The function must implement the following conditional mapping: a score of 10 is to be returned for the combination ('9', '9'); a score of 7 for ('6', '5'); and a score of 5 for ('3', '7'). For any other combination of LENGTH and HEIGHT values, the function must return a score of 3.",
    "id": 62,
    "generated_ir": "Write an Oracle PL/SQL function named `calculate_size_score` that accepts a single input parameter `p_catalog_entry_id` of data type `NUMBER`. This function is designed to return a computed `NUMBER` score based on the `LENGTH` and `HEIGHT` attributes of a specific catalog entry. The function operates within the `product_catalog` database and queries the `CATALOG_CONTENTS` table.\n\nInternally, the function declares two local variables: `v_length` of type `VARCHAR2(255)` and `v_height` of type `VARCHAR2(255)`. These variables will hold the string values retrieved from the `LENGTH` and `HEIGHT` columns, respectively.\n\nThe function's execution begins by performing a `SELECT` operation to retrieve the values from the `LENGTH` and `HEIGHT` columns of the `CATALOG_CONTENTS` table. This `SELECT` statement uses a `WHERE` clause to filter the query, specifying that only the row where the `CATALOG_ENTRY_ID` column exactly matches the value provided in the `p_catalog_entry_id` input parameter should be considered. The retrieved `LENGTH` value is assigned to the `v_length` variable, and the retrieved `HEIGHT` value is assigned to the `v_height` variable.\n\nFollowing this data retrieval, the function proceeds with a conditional `IF` statement to determine the score based on the combination of `v_length` and `v_height` values. The `IF` statement evaluates the conditions in a specific order. First, it checks if `v_length` is exactly equal to the string `'9'` AND `v_height` is exactly equal to the string `'9'`. If this condition is true, the function immediately executes a `RETURN` statement, returning the numeric value `10`.\n\nIf the first condition is false, the function proceeds to an `ELSIF` clause. This clause checks if `v_length` is exactly equal to the string `'6'` AND `v_height` is exactly equal to the string `'5'`. If this condition is true, the function immediately executes a `RETURN` statement, returning the numeric value `7`.\n\nIf the second condition is also false, the function proceeds to another `ELSIF` clause. This clause checks if `v_length` is exactly equal to the string `'3'` AND `v_height` is exactly equal to the string `'7'`. If this condition is true, the function immediately executes a `RETURN` statement, returning the numeric value `5`.\n\nIf none of the above conditions are met, meaning the combination of `v_length` and `v_height` does not match any of the three specified pairs, the function executes the `ELSE` block. In this `ELSE` block, the function returns the default numeric value `3`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_benefits_overpayments_count that accepts a single input parameter named master_customer_id of the NUMBER data type and returns a value of the NUMBER data type; the function declares a local variable named overpayments_count of the NUMBER data type; the function executes a SELECT statement that performs a COUNT(*) operation on the result of an inner join between the BENEFITS_OVERPAYMENTS table (aliased as bo) and the CMI_CROSS_REFERENCES table (aliased as ccr) where the join condition specifies that the CMI_CROSS_REF_ID column from the BENEFITS_OVERPAYMENTS table must equal the CMI_CROSS_REF_ID column from the CMI_CROSS_REFERENCES table; the SELECT statement includes a WHERE clause that filters the joined result set to only those rows where the MASTER_CUSTOMER_ID column from the CMI_CROSS_REFERENCES table is equal to the input parameter master_customer_id; the result of the COUNT(*) operation is stored into the local variable overpayments_count; the function then returns the value stored in the overpayments_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_benefits_overpayments_count(master_customer_id IN NUMBER) RETURN NUMBER IS\n  overpayments_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO overpayments_count\n  FROM BENEFITS_OVERPAYMENTS bo\n  JOIN CMI_CROSS_REFERENCES ccr ON bo.CMI_CROSS_REF_ID = ccr.CMI_CROSS_REF_ID\n  WHERE ccr.MASTER_CUSTOMER_ID = master_customer_id;\n  RETURN overpayments_count;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_benefits_overpayments_count(1) FROM dual",
      "SELECT get_benefits_overpayments_count(2) FROM dual",
      "SELECT get_benefits_overpayments_count(3) FROM dual",
      "SELECT get_benefits_overpayments_count(4) FROM dual",
      "SELECT get_benefits_overpayments_count(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_benefits_overpayments_count` that accepts a `master_customer_id` (NUMBER) and returns the count of records (NUMBER) from an inner join of the `BENEFITS_OVERPAYMENTS` and `CMI_CROSS_REFERENCES` tables where their `CMI_CROSS_REF_ID` columns match and the `MASTER_CUSTOMER_ID` equals the input parameter.",
    "natural_language": "Hey, can you whip up a PL/SQL function called `get_benefits_overpayments_count`? It should take a `master_customer_id` (as a NUMBER) and spit back how many records it finds. That count comes from linking the `BENEFITS_OVERPAYMENTS` and `CMI_CROSS_REFERENCES` tables together where their `CMI_CROSS_REF_ID` columns are the same, but only for the specific customer ID we give it.",
    "id": 63,
    "generated_ir": "Write an Oracle PL/SQL function named get_benefits_overpayments_count that accepts a single input parameter named master_customer_id of the NUMBER data type and returns a value of the NUMBER data type; the function declares a local variable named overpayments_count of the NUMBER data type; the function executes a SELECT statement that performs a COUNT(*) operation on the result of an inner join between the BENEFITS_OVERPAYMENTS table (aliased as bo) and the CMI_CROSS_REFERENCES table (aliased as ccr) where the join condition specifies that the CMI_CROSS_REF_ID column from the BENEFITS_OVERPAYMENTS table must equal the CMI_CROSS_REF_ID column from the CMI_CROSS_REFERENCES table; the SELECT statement includes a WHERE clause that filters the joined result set to only those rows where the MASTER_CUSTOMER_ID column from the CMI_CROSS_REFERENCES table is equal to the input parameter master_customer_id; the result of the COUNT(*) operation is stored into the local variable overpayments_count; the function then returns the value stored in the overpayments_count variable."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_service_type_by_event that accepts two mandatory input parameters: para_event_id of type NUMBER, which represents the unique identifier for an event, and para_participant_id of type NUMBER, which represents the unique identifier for a participant. The function returns a single VARCHAR2 value with a maximum length of 255 characters. The function's execution begins by declaring a local variable v_service_type of type VARCHAR2(255) to hold the result. The core logic performs a SELECT operation that retrieves data from three tables: EVENTS (aliased as e), SERVICES (aliased as s), and PARTICIPANTS_IN_EVENTS (aliased as pie). It joins the EVENTS table to the SERVICES table using the condition that the SERVICE_ID column in the EVENTS table matches the SERVICE_ID column in the SERVICES table. It also joins the EVENTS table to the PARTICIPANTS_IN_EVENTS table using the condition that the EVENT_ID column in the EVENTS table matches the EVENT_ID column in the PARTICIPANTS_IN_EVENTS table. The SELECT statement specifically fetches the value from the SERVICE_TYPE_CODE column of the SERVICES table. The WHERE clause filters the combined result set to include only rows where the EVENT_ID column in the PARTICIPANTS_IN_EVENTS table is equal to the input parameter para_event_id and where the PARTICIPANT_ID column in the PARTICIPANTS_IN_EVENTS table is equal to the input parameter para_participant_id. The retrieved SERVICE_TYPE_CODE value is assigned into the local variable v_service_type. Finally, the function returns the value stored in v_service_type.",
    "plsql": "CREATE OR REPLACE FUNCTION get_service_type_by_event(para_event_id NUMBER, para_participant_id NUMBER) RETURN VARCHAR2 IS\n  v_service_type VARCHAR2(255);\nBEGIN\n  SELECT s.SERVICE_TYPE_CODE INTO v_service_type\n  FROM EVENTS e\n  JOIN SERVICES s ON e.SERVICE_ID = s.SERVICE_ID\n  JOIN PARTICIPANTS_IN_EVENTS pie ON e.EVENT_ID = pie.EVENT_ID\n  WHERE pie.EVENT_ID = para_event_id AND pie.PARTICIPANT_ID = para_participant_id;\n  RETURN v_service_type;\nEND;",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "EVENTS",
      "PARTICIPANTS",
      "PARTICIPANTS_IN_EVENTS",
      "SERVICES"
    ],
    "call_sqls": [
      "SELECT get_service_type_by_event(3, 26) FROM DUAL",
      "SELECT get_service_type_by_event(8, 66) FROM DUAL",
      "SELECT get_service_type_by_event(13, 86) FROM DUAL",
      "SELECT get_service_type_by_event(3, 9) FROM DUAL",
      "SELECT get_service_type_by_event(8, 28) FROM DUAL"
    ],
    "summary": "Create a function named get_service_type_by_event that accepts two NUMBER parameters, para_event_id and para_participant_id, and returns a VARCHAR2(255). It queries the SERVICE_TYPE_CODE from the SERVICES table by joining EVENTS and PARTICIPANTS_IN_EVENTS where the EVENT_ID and PARTICIPANT_ID match the parameters, stores the result in a variable, and returns it.",
    "natural_language": "Create a function called get_service_type_by_event that takes a couple of NUMBER inputs, para_event_id and para_participant_id, and gives back a VARCHAR2(255). It should look up the SERVICE_TYPE_CODE from the SERVICES table by connecting it with EVENTS and PARTICIPANTS_IN_EVENTS where the IDs are roughly the same as the provided ones, put whatever it finds into a variable, and then return that result.",
    "id": 64,
    "generated_ir": "Write an Oracle PL/SQL function named get_service_type_by_event that accepts two mandatory input parameters: para_event_id of type NUMBER, which represents the unique identifier for an event, and para_participant_id of type NUMBER, which represents the unique identifier for a participant. The function returns a single VARCHAR2 value with a maximum length of 255 characters. The function's execution begins by declaring a local variable v_service_type of type VARCHAR2(255) to hold the result. The core logic performs a SELECT operation that retrieves data from three tables: EVENTS (aliased as e), SERVICES (aliased as s), and PARTICIPANTS_IN_EVENTS (aliased as pie). It joins the EVENTS table to the SERVICES table using the condition that the SERVICE_ID column in the EVENTS table matches the SERVICE_ID column in the SERVICES table. It also joins the EVENTS table to the PARTICIPANTS_IN_EVENTS table using the condition that the EVENT_ID column in the EVENTS table matches the EVENT_ID column in the PARTICIPANTS_IN_EVENTS table. The SELECT statement specifically fetches the value from the SERVICE_TYPE_CODE column of the SERVICES table. The WHERE clause filters the combined result set to include only rows where the EVENT_ID column in the PARTICIPANTS_IN_EVENTS table is equal to the input parameter para_event_id and where the PARTICIPANT_ID column in the PARTICIPANTS_IN_EVENTS table is equal to the input parameter para_participant_id. The retrieved SERVICE_TYPE_CODE value is assigned into the local variable v_service_type. Finally, the function returns the value stored in v_service_type."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_staff_email that accepts a single parameter, p_staff_id, which is of type NUMBER and represents the unique identifier of a staff member. The function is designed to return a value of type VARCHAR2, specifically the email address associated with the given staff ID. Within the function, a local variable v_email of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the email address retrieved from the database. The function executes a SELECT statement that queries the STAFF table, specifically targeting the EMAIL_ADDRESS column, and retrieves the email address for the row where the STAFF_ID column matches the value provided in the p_staff_id parameter. The retrieved email address is stored in the v_email variable. After successfully obtaining the email address, the function returns the value stored in v_email, effectively providing the email address associated with the specified staff ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_email(p_staff_id NUMBER) RETURN VARCHAR2 IS\n  v_email VARCHAR2(255);\nBEGIN\n  SELECT EMAIL_ADDRESS INTO v_email FROM STAFF WHERE STAFF_ID = p_staff_id;\n  RETURN v_email;\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_staff_email(114) FROM DUAL",
      "SELECT get_staff_email(115) FROM DUAL",
      "SELECT get_staff_email(116) FROM DUAL",
      "SELECT get_staff_email(117) FROM DUAL",
      "SELECT get_staff_email(120) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_staff_email that accepts a staff_id number and returns the corresponding email_address as a varchar2 from the STAFF table.",
    "natural_language": "Write a PL/SQL function to get the email for a staff member. The function should take a staff identifier and give back the email address from the staff records.",
    "id": 65,
    "generated_ir": "Write an Oracle PL/SQL function named get_staff_email that accepts a single parameter, p_staff_id, which is of type NUMBER and represents the unique identifier of a staff member. The function is designed to return a value of type VARCHAR2, specifically the email address associated with the given staff ID. Within the function, a local variable v_email of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the email address retrieved from the database. The function executes a SELECT statement that queries the STAFF table, specifically targeting the EMAIL_ADDRESS column, and retrieves the email address for the row where the STAFF_ID column matches the value provided in the p_staff_id parameter. The retrieved email address is stored in the v_email variable. After successfully obtaining the email address, the function returns the value stored in v_email, effectively providing the email address associated with the specified staff ID."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_avg_logs_per_problem that takes no parameters and returns a single NUMBER value, which begins by declaring a local NUMBER variable v_avg to hold the result, then executes a SQL query that first groups all rows from the PROBLEM_LOG table by the PROBLEM_ID column, calculates the count of rows per group using COUNT(*), and aliases this count as cnt, then uses this grouped result set as an inline view from which it calculates the overall arithmetic average of all these per-group counts using the AVG aggregate function on the cnt column, stores this computed average value into the local variable v_avg, and finally returns the value stored in v_avg as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_avg_logs_per_problem RETURN NUMBER IS\n    v_avg NUMBER;\nBEGIN\n    SELECT AVG(cnt) INTO v_avg FROM (\n        SELECT COUNT(*) as cnt FROM PROBLEM_LOG GROUP BY PROBLEM_ID\n    );\n    RETURN v_avg;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_avg_logs_per_problem FROM DUAL",
      "SELECT get_avg_logs_per_problem() FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average logs per problem: ' || get_avg_logs_per_problem);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_avg_logs_per_problem;\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "SELECT get_avg_logs_per_problem AS avg_logs FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_avg_logs_per_problem that returns the average number of log entries per problem from the PROBLEM_LOG table.",
    "natural_language": "Write a PL/SQL function called get_avg_logs_per_problem to return the average count of log entries for each problem from the PROBLEM_LOG table.",
    "id": 66,
    "generated_ir": "Write an Oracle PL/SQL function named get_avg_logs_per_problem that takes no parameters and returns a single NUMBER value, which begins by declaring a local NUMBER variable v_avg to hold the result, then executes a SQL query that first groups all rows from the PROBLEM_LOG table by the PROBLEM_ID column, calculates the count of rows per group using COUNT(*), and aliases this count as cnt, then uses this grouped result set as an inline view from which it calculates the overall arithmetic average of all these per-group counts using the AVG aggregate function on the cnt column, stores this computed average value into the local variable v_avg, and finally returns the value stored in v_avg as the function's result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_volume_category that accepts a single input parameter p_entry_id of type NUMBER, which represents the identifier of a catalog entry. The function returns a value of type VARCHAR2. Within the function, declare two local variables: v_capacity of type VARCHAR2(255) and v_category of type VARCHAR2(20). The function begins by executing a SELECT statement to retrieve the CAPACITY column value from the CATALOG_CONTENTS table, where the CATALOG_ENTRY_ID column matches the value of the input parameter p_entry_id. The retrieved CAPACITY value is stored in the v_capacity variable. The function then evaluates the value of v_capacity using a series of conditional statements. If v_capacity equals '8', the function assigns the string 'LARGE' to the v_category variable. If v_capacity equals '5', it assigns 'MEDIUM' to v_category. If v_capacity equals '1', it assigns 'SMALL' to v_category. If none of these conditions are met, the function assigns 'UNKNOWN' to v_category. Finally, the function returns the value of v_category, which represents the category of the volume based on its capacity.",
    "plsql": "CREATE OR REPLACE FUNCTION get_volume_category(p_entry_id NUMBER) RETURN VARCHAR2 IS\n    v_capacity VARCHAR2(255);\n    v_category VARCHAR2(20);\nBEGIN\n    SELECT CAPACITY INTO v_capacity FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_capacity = '8' THEN v_category := 'LARGE';\n    ELSIF v_capacity = '5' THEN v_category := 'MEDIUM';\n    ELSIF v_capacity = '1' THEN v_category := 'SMALL';\n    ELSE v_category := 'UNKNOWN';\n    END IF;\n    RETURN v_category;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT get_volume_category(1) FROM DUAL",
      "SELECT get_volume_category(2) FROM DUAL",
      "SELECT get_volume_category(3) FROM DUAL",
      "SELECT CATALOG_ENTRY_ID, CAPACITY, get_volume_category(CATALOG_ENTRY_ID) AS VOLUME_CATEGORY FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = 1",
      "SELECT CATALOG_ENTRY_ID, CATALOG_ENTRY_NAME, get_volume_category(CATALOG_ENTRY_ID) FROM CATALOG_CONTENTS WHERE CAPACITY IN ('1', '5', '8')"
    ],
    "summary": "Create a PL/SQL function named get_volume_category that takes a catalog entry ID (NUMBER) and returns a category string (VARCHAR2). The category is determined by the entry's CAPACITY: 'LARGE' for '8', 'MEDIUM' for '5', 'SMALL' for '1', and 'UNKNOWN' for any other value.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_volume_category? It should take a catalog entry ID (that's a NUMBER) and spit back a category as a string (VARCHAR2). Basically, we need to figure out the category based on the entry's CAPACITY: if it's '8', call it 'LARGE'; if it's '5', that's 'MEDIUM'; if it's '1', that's 'SMALL'; and for anything else, just say 'UNKNOWN'.",
    "id": 67,
    "generated_ir": "Write an Oracle PL/SQL function named get_volume_category that accepts a single input parameter p_entry_id of type NUMBER, which represents the identifier of a catalog entry. The function returns a value of type VARCHAR2. Within the function, declare two local variables: v_capacity of type VARCHAR2(255) and v_category of type VARCHAR2(20). The function begins by executing a SELECT statement to retrieve the CAPACITY column value from the CATALOG_CONTENTS table, where the CATALOG_ENTRY_ID column matches the value of the input parameter p_entry_id. The retrieved CAPACITY value is stored in the v_capacity variable. The function then evaluates the value of v_capacity using a series of conditional statements. If v_capacity equals '8', the function assigns the string 'LARGE' to the v_category variable. If v_capacity equals '5', it assigns 'MEDIUM' to v_category. If v_capacity equals '1', it assigns 'SMALL' to v_category. If none of these conditions are met, the function assigns 'UNKNOWN' to v_category. Finally, the function returns the value of v_category, which represents the category of the volume based on its capacity."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_friendship_status` that accepts two input parameters: `p_student_id`, a `NUMBER` type representing the ID of the primary student, and `p_target_id`, a `NUMBER` type representing the ID of the target individual whose relationship with the primary student is to be determined. This function is designed to return a `VARCHAR2` string of up to 20 characters, indicating the nature of the relationship between the two provided IDs.\n\nUpon execution, the function first declares two local variables: `v_status`, a `VARCHAR2` variable of size 20 to store the determined relationship status, and `v_count`, a `NUMBER` variable to hold the count of records found in database queries.\n\nThe function then proceeds with a conditional check:\n1. It evaluates if the value of `p_student_id` is equal to the value of `p_target_id`.\n   a. If they are equal, indicating that the primary student and the target individual are the same person, the `v_status` variable is assigned the string literal 'SAME_PERSON'.\n   b. If they are not equal, the function proceeds to further checks to determine the relationship:\n      i. It executes a `SELECT COUNT(*)` statement to count the number of rows in the `FRIEND` table where the `STUDENT_ID` column matches `p_student_id` AND the `FRIEND_ID` column matches `p_target_id`. The result of this count is stored in the `v_count` variable.\n      ii. It then checks if the value of `v_count` is greater than 0.\n          1. If `v_count` is greater than 0, meaning a direct friendship record exists, the `v_status` variable is assigned the string literal 'DIRECT_FRIEND'.\n          2. If `v_count` is not greater than 0, indicating no direct friendship, the function performs another check:\n             a. It executes a `SELECT COUNT(*)` statement to count the number of rows in the `LIKES` table where the `STUDENT_ID` column matches `p_student_id` AND the `LIKED_ID` column matches `p_target_id`. The result of this count is again stored in the `v_count` variable.\n             b. It then checks if the value of `v_count` is greater than 0.\n                i. If `v_count` is greater than 0, meaning the primary student likes the target individual, the `v_status` variable is assigned the string literal 'LIKES_TARGET'.\n                ii. If `v_count` is not greater than 0, indicating no direct friendship and no 'likes' relationship, the `v_status` variable is assigned the string literal 'NO_RELATION'.\n\nFinally, after all conditional checks, the function returns the final value stored in the `v_status` variable.\n\nThe function also includes an exception handling block:\n1. If any unhandled exception occurs during the execution of the function (caught by `WHEN OTHERS`), the function will immediately return the string literal 'ERROR'.",
    "plsql": "CREATE OR REPLACE FUNCTION check_friendship_status(p_student_id NUMBER, p_target_id NUMBER) RETURN VARCHAR2 IS\n  v_status VARCHAR2(20);\n  v_count NUMBER;\nBEGIN\n  IF p_student_id = p_target_id THEN\n    v_status := 'SAME_PERSON';\n  ELSE\n    SELECT COUNT(*) INTO v_count FROM FRIEND WHERE STUDENT_ID = p_student_id AND FRIEND_ID = p_target_id;\n    IF v_count > 0 THEN\n      v_status := 'DIRECT_FRIEND';\n    ELSE\n      SELECT COUNT(*) INTO v_count FROM LIKES WHERE STUDENT_ID = p_student_id AND LIKED_ID = p_target_id;\n      IF v_count > 0 THEN\n        v_status := 'LIKES_TARGET';\n      ELSE\n        v_status := 'NO_RELATION';\n      END IF;\n    END IF;\n  END IF;\n  RETURN v_status;\nEXCEPTION\n  WHEN OTHERS THEN\n    RETURN 'ERROR';\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT check_friendship_status(1101, 1641) FROM dual",
      "SELECT check_friendship_status(1247, 1501) FROM dual",
      "SELECT check_friendship_status(1101, 1911) FROM dual",
      "SELECT check_friendship_status(1247, 1468) FROM dual",
      "SELECT check_friendship_status(1025, 1304) FROM dual"
    ],
    "summary": "Create a PL/SQL function named check_friendship_status that takes two NUMBER parameters (p_student_id, p_target_id) and returns a VARCHAR2(20). It returns 'SAME_PERSON' if the IDs are equal, 'DIRECT_FRIEND' if a record exists in the FRIEND table, 'LIKES_TARGET' if a record exists in the LIKES table, or 'NO_RELATION' otherwise. Handle any exception by returning 'ERROR'.",
    "natural_language": "Write a PL/SQL function check_friendship_status(p_student_id NUMBER, p_target_id NUMBER) returning VARCHAR2(20). Logic: return 'SAME_PERSON' for equal IDs, 'DIRECT_FRIEND' if in FRIEND table, 'LIKES_TARGET' if in LIKES table, else 'NO_RELATION'. On exception, return 'ERROR'.",
    "id": 68,
    "generated_ir": "Write an Oracle PL/SQL function named check_friendship_status that accepts two parameters: p_student_id of type NUMBER, which identifies the first student, and p_target_id of type NUMBER, which identifies the second student. The function returns a VARCHAR2(20) string indicating the relationship status between the two students. Inside the function, declare a local variable v_status of type VARCHAR2(20) to store the computed relationship status. The function's logic proceeds as follows: First, check if p_student_id is equal to p_target_id. If they are equal, set v_status to the string 'SAME_PERSON'. If they are not equal, then check for a direct friendship by executing a SELECT statement that queries the FRIEND table. Specifically, look for a row where the STUDENT_ID column equals p_student_id and the FRIEND_ID column equals p_target_id. If such a row exists, set v_status to 'DIRECT_FRIEND'. If no direct friendship is found, then check if the first student likes the second student by executing a SELECT statement on the LIKES table. Look for a row where the STUDENT_ID column equals p_student_id and the LIKED_ID column equals p_target_id. If such a row exists, set v_status to 'LIKES_TARGET'. If none of the previous conditions are met, set v_status to 'NO_RELATION'. The function should include an exception handling block to catch any exceptions that occur during execution. If an exception is caught, set v_status to 'ERROR'. Finally, return the value of v_status as the function's result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_highest_position that accepts a single input parameter p_song_id of the NUMBER data type and returns a value of the NUMBER data type, where the function's purpose is to retrieve the highest chart position for a specific song, and the function's logic begins by declaring a local variable v_position of the NUMBER data type, then executes a SELECT statement that queries the SONG table to retrieve the value from the HIGHEST_POSITION column for the single row where the SONG_ID column value exactly matches the input parameter p_song_id, storing the retrieved value directly into the local variable v_position, and finally concludes by using a RETURN statement to output the value stored in v_position as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_highest_position(p_song_id NUMBER) RETURN NUMBER IS\n  v_position NUMBER;\nBEGIN\n  SELECT HIGHEST_POSITION INTO v_position FROM SONG WHERE SONG_ID = p_song_id;\n  RETURN v_position;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "SELECT get_highest_position(3) FROM DUAL",
      "SELECT get_highest_position(4) FROM DUAL",
      "SELECT get_highest_position(5) FROM DUAL",
      "SELECT get_highest_position(10) FROM DUAL",
      "SELECT SONG_ID, TITLE, get_highest_position(SONG_ID) AS HIGHEST_POS FROM SONG WHERE SONG_ID = 3"
    ],
    "summary": "Create a PL/SQL function named get_highest_position that accepts a song ID (NUMBER) and returns the highest chart position (NUMBER) for that song by selecting the HIGHEST_POSITION from the SONG table where SONG_ID matches the input.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_highest_position'. This function shall receive a song identifier of the NUMBER data type as its parameter. Its purpose is to retrieve and return the peak chart position, also of NUMBER type, for the specified song. This is achieved by querying the HIGHEST_POSITION column from the SONG table where the SONG_ID column corresponds to the provided input parameter.",
    "id": 69,
    "generated_ir": "Write an Oracle PL/SQL function that retrieves and returns the highest chart position for a specific song from the SONG table. The function, named get_highest_position, accepts one input parameter: a numeric parameter p_song_id to specify a song identifier. The function returns a NUMBER type. Inside the function, a local variable v_highest_position of type NUMBER is declared to store the result of the query. The function executes a SELECT statement that retrieves the value from the HIGHEST_POSITION column of the SONG table. The SELECT statement filters the rows by checking if the SONG_ID column in the SONG table exactly matches the p_song_id input parameter. The retrieved value is stored into the v_highest_position variable. Finally, the function returns the value stored in v_highest_position."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_activity_score that accepts a single input parameter p_id of type NUMBER and returns a NUMBER value. The function calculates a composite activity score for a student based on their social interactions, with the calculation logic dependent on the student's grade level. The function begins by declaring local variables v_score, v_grade, v_friend_count, and v_liked_count, all of type NUMBER. It first queries the HIGHSCHOOLER table, selecting the GRADE column value into v_grade for the row where the ID column equals the input p_id. If the retrieved v_grade is greater than 9, the function performs a query joining the HIGHSCHOOLER table (aliased as h) to the FRIEND table (aliased as f) with a LEFT JOIN on the condition h.ID equals f.STUDENT_ID, and to the LIKES table (aliased as l) with a LEFT JOIN on the condition h.ID equals l.STUDENT_ID, specifically for the row where h.ID equals p_id. From this joined result set, it counts the distinct values of f.FRIEND_ID into v_friend_count and the distinct values of l.LIKED_ID into v_liked_count. The final v_score is then computed as (v_friend_count multiplied by 2) plus v_liked_count. If the retrieved v_grade is equal to 9, the function executes an identical query to obtain v_friend_count and v_liked_count, but computes v_score as the simple sum of v_friend_count and v_liked_count. The function returns the calculated v_score. If the initial SELECT statement raises a NO_DATA_FOUND exception because p_id does not exist in the HIGHSCHOOLER table, the exception handler is invoked. Within the handler, if p_id is greater than 0, it queries the FRIEND table, counting the distinct FRIEND_ID values into v_score for rows where STUDENT_ID equals p_id. If p_id is not greater than 0, it assigns -1 to v_score. The handler then returns this v_score value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_activity_score(p_id NUMBER) RETURN NUMBER IS\n  v_score NUMBER;\n  v_grade NUMBER;\n  v_friend_count NUMBER;\n  v_liked_count NUMBER;\nBEGIN\n  -- Check if the student exists and get their grade\n  SELECT GRADE INTO v_grade FROM HIGHSCHOOLER WHERE ID = p_id;\n\n  IF v_grade > 9 THEN\n    SELECT\n        COUNT(DISTINCT f.FRIEND_ID),\n        COUNT(DISTINCT l.LIKED_ID)\n    INTO\n        v_friend_count,\n        v_liked_count\n    FROM HIGHSCHOOLER h\n    LEFT JOIN FRIEND f ON h.ID = f.STUDENT_ID\n    LEFT JOIN LIKES l ON h.ID = l.STUDENT_ID\n    WHERE h.ID = p_id;\n    v_score := (v_friend_count * 2) + v_liked_count;\n  ELSIF v_grade = 9 THEN\n    SELECT\n        COUNT(DISTINCT f.FRIEND_ID),\n        COUNT(DISTINCT l.LIKED_ID)\n    INTO\n        v_friend_count,\n        v_liked_count\n    FROM HIGHSCHOOLER h\n    LEFT JOIN FRIEND f ON h.ID = f.STUDENT_ID\n    LEFT JOIN LIKES l ON h.ID = l.STUDENT_ID\n    WHERE h.ID = p_id;\n    v_score := v_friend_count + v_liked_count;\n  END IF;\n\n  RETURN v_score;\n\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    -- If p_id is not found in HIGHSCHOOLER, check FRIEND table or assign -1\n    IF p_id > 0 THEN\n      SELECT COUNT(DISTINCT f.FRIEND_ID) INTO v_score FROM FRIEND f WHERE f.STUDENT_ID = p_id;\n    ELSE\n      v_score := -1;\n    END IF;\n    RETURN v_score;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "SELECT get_student_activity_score(1510) FROM DUAL",
      "SELECT get_student_activity_score(1689) FROM DUAL",
      "SELECT get_student_activity_score(1381) FROM DUAL",
      "SELECT get_student_activity_score(1101) FROM DUAL",
      "SELECT get_student_activity_score(9999) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_student_activity_score that accepts a NUMBER parameter p_id and returns a NUMBER. For a student in HIGHSCHOOLER, if their grade > 9, calculate score as (friend_count * 2) + liked_count. If grade = 9, calculate score as friend_count + liked_count. If the student ID is not found and p_id > 0, return the count of their distinct friends from the FRIEND table; otherwise, return -1.",
    "natural_language": "Alright, so I need you to whip up a PL/SQL function called get_student_activity_score. It's gotta take in a number for the student's ID and spit back a number too. Here's the deal: if the kid's in HIGHSCHOOLER and they're above 9th grade, figure out their score by doubling their friend count and then adding how many likes they've got. If they're exactly in 9th grade, just add the friend count and liked count together. Now, if you can't find the student at all but the ID passed in is a positive number, then just give me back how many unique pals they have in the FRIEND table. Otherwise, if all else fails, just return -1.",
    "id": 70,
    "generated_ir": "Write an Oracle PL/SQL function named get_student_activity_score that accepts a single input parameter p_id of type NUMBER and returns a NUMBER value. The function calculates a composite activity score for a student based on their social interactions, with the calculation logic dependent on the student's grade level. The function begins by declaring local variables v_score, v_grade, v_friend_count, and v_liked_count, all of type NUMBER. It first queries the HIGHSCHOOLER table, selecting the GRADE column value into v_grade for the row where the ID column equals the input p_id. If the retrieved v_grade is greater than 9, the function performs a query joining the HIGHSCHOOLER table (aliased as h) to the FRIEND table (aliased as f) with a LEFT JOIN on the condition h.ID equals f.STUDENT_ID, and to the LIKES table (aliased as l) with a LEFT JOIN on the condition h.ID equals l.STUDENT_ID, specifically for the row where h.ID equals p_id. From this joined result set, it counts the distinct values of f.FRIEND_ID into v_friend_count and the distinct values of l.LIKED_ID into v_liked_count. The final v_score is then computed as (v_friend_count multiplied by 2) plus v_liked_count. If the retrieved v_grade is equal to 9, the function executes an identical query to obtain v_friend_count and v_liked_count, but computes v_score as the simple sum of v_friend_count and v_liked_count. The function returns the calculated v_score. If the initial SELECT statement raises a NO_DATA_FOUND exception because p_id does not exist in the HIGHSCHOOLER table, the exception handler is invoked. Within the handler, if p_id is greater than 0, it queries the FRIEND table, counting the distinct FRIEND_ID values into v_score for rows where STUDENT_ID equals p_id. If p_id is not greater than 0, it assigns -1 to v_score. The handler then returns this v_score value."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_average_order_quantity that accepts a single input parameter p_customer_id of type NUMBER and returns a value of type NUMBER, which begins by declaring two local NUMBER variables v_total_quantity and v_order_count, initializing both to zero, then executes a SELECT statement that retrieves data from the ORDERS table (aliased as o) and the ORDER_ITEMS table (aliased as oi) by performing an inner join on the condition that the ORDER_ID column from the ORDERS table equals the ORDER_ID column from the ORDER_ITEMS table, specifically filtering rows where the CUSTOMER_ID column in the ORDERS table matches the provided input parameter p_customer_id, and within this query, it calculates the sum of the PRODUCT_QUANTITY column from the ORDER_ITEMS table after converting each value to a NUMBER using the TO_NUMBER function, storing this result into the variable v_total_quantity, and simultaneously calculates the count of distinct ORDER_ID values from the ORDERS table, storing this result into the variable v_order_count, and finally, the function returns the result of dividing the value in v_total_quantity by the value in v_order_count.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_order_quantity(p_customer_id NUMBER) RETURN NUMBER IS\n    v_total_quantity NUMBER := 0;\n    v_order_count NUMBER := 0;\nBEGIN\n    SELECT SUM(TO_NUMBER(oi.PRODUCT_QUANTITY)), COUNT(DISTINCT o.ORDER_ID) INTO v_total_quantity, v_order_count\n    FROM ORDERS o JOIN ORDER_ITEMS oi ON o.ORDER_ID = oi.ORDER_ID\n    WHERE o.CUSTOMER_ID = p_customer_id;\n    \n    RETURN v_total_quantity / v_order_count;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "SELECT calculate_average_order_quantity(1) FROM DUAL",
      "SELECT calculate_average_order_quantity(5) FROM DUAL",
      "SELECT calculate_average_order_quantity(7) FROM DUAL",
      "SELECT calculate_average_order_quantity(12) FROM DUAL",
      "SELECT calculate_average_order_quantity(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `calculate_average_order_quantity` that accepts a `p_customer_id` (NUMBER) and returns a NUMBER. It calculates the average product quantity per order for the customer by summing the PRODUCT_QUANTITY (converted to NUMBER) from ORDER_ITEMS and dividing by the distinct count of ORDER_ID from ORDERS, joined on ORDER_ID.",
    "natural_language": "Develop a comprehensive PL/SQL function, which should be distinctly named `calculate_average_order_quantity`. This function must be designed to accept a single input parameter, specifically a `p_customer_id` of the NUMBER data type, and it will reliably return a value of the NUMBER type. Its primary purpose is to meticulously compute the average quantity of products per individual order for the specified customer. This calculation is achieved by first aggregating the total sum of the PRODUCT_QUANTITY values, which are carefully converted to NUMBER, from all relevant entries in the ORDER_ITEMS table. This sum is then divided by the precise count of distinct ORDER_ID values retrieved from the ORDERS table, ensuring an accurate average, where the two tables are properly joined using their common ORDER_ID field.",
    "id": 71,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_average_order_quantity that accepts a single input parameter p_customer_id of type NUMBER and returns a value of type NUMBER. The function declares a local variable v_average_quantity of type NUMBER to store the computed result. The function's core operation is to calculate the average product quantity per order for a given customer by performing a SELECT statement that combines data from the ORDERS and ORDER_ITEMS tables. Specifically, it computes the sum of all PRODUCT_QUANTITY values from the ORDER_ITEMS table, converting each PRODUCT_QUANTITY from VARCHAR2 to NUMBER using an explicit type conversion, and divides this sum by the count of distinct ORDER_ID values from the ORDERS table. The tables are joined using the ORDER_ID column, which is present in both tables. The query includes a condition to filter records where the CUSTOMER_ID in the ORDERS table matches the input parameter p_customer_id. The result of this calculation is directly assigned to the v_average_quantity variable. Finally, the function returns the value stored in v_average_quantity. If no orders exist for the specified customer, the query will return NULL, and the function will consequently return NULL."
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_architect_bridge_count that accepts a single parameter, p_architect_id, of type NUMBER, which represents the unique identifier of an architect. The function is designed to return a NUMBER that indicates the total count of bridges associated with the specified architect. Within the function, a local variable v_count of type NUMBER is declared to store the result of the count operation. The function executes a SELECT statement that counts all rows in the BRIDGE table where the value in the ARCHITECT_ID column matches the value of the input parameter p_architect_id. The result of this count operation is stored in the v_count variable using the INTO clause. Finally, the function returns the value stored in v_count, which represents the number of bridges designed by the architect identified by p_architect_id.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_architect_bridge_count(p_architect_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM BRIDGE WHERE ARCHITECT_ID = p_architect_id;\n  RETURN v_count;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT fn_get_architect_bridge_count(2) FROM DUAL",
      "SELECT fn_get_architect_bridge_count(3) FROM DUAL",
      "SELECT fn_get_architect_bridge_count(4) FROM DUAL",
      "SELECT fn_get_architect_bridge_count(1) FROM DUAL",
      "SELECT fn_get_architect_bridge_count(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named fn_get_architect_bridge_count that accepts a NUMBER architect ID and returns the total count of bridges designed by that architect as a NUMBER.",
    "natural_language": "Function fn_get_architect_bridge_count: input architect ID (NUMBER), output their bridge count (NUMBER).",
    "id": 72,
    "generated_ir": "Write an Oracle PL/SQL function named fn_get_architect_bridge_count that accepts a single parameter, p_architect_id, of type NUMBER, which represents the unique identifier of an architect. The function is designed to return a NUMBER that indicates the total count of bridges associated with the specified architect. Within the function, a local variable v_count of type NUMBER is declared to store the result of the count operation. The function executes a SELECT statement that counts all rows in the BRIDGE table where the value in the ARCHITECT_ID column matches the value of the input parameter p_architect_id. The result of this count operation is stored in the v_count variable using the INTO clause. Finally, the function returns the value stored in v_count, which represents the number of bridges designed by the architect identified by p_architect_id."
  },
  {
    "ir": "Write an Oracle PL/SQL function named find_max_speed_for_nation_type that accepts three parameters: nation of type VARCHAR2, ship_type of type VARCHAR2, and year_cutoff of type NUMBER. The function is designed to return a NUMBER representing the maximum speed in knots of ships that meet specific criteria. The function begins by declaring a local variable max_speed of type NUMBER to store the result of the query. It then performs a SELECT operation to retrieve the maximum value of the SPEED_KNOTS column from the MISSION table, which is aliased as m. This table is joined with the SHIP table, aliased as s, using the SHIP_ID column as the common key. The WHERE clause filters the results based on three conditions: the NATIONALITY column in the SHIP table must match the nation parameter, the TYPE column in the SHIP table must match the ship_type parameter, and the LAUNCHED_YEAR column in the MISSION table must be less than the year_cutoff parameter. The LOWER() function is applied to both the NATIONALITY and TYPE columns as well as the nation and ship_type parameters to ensure case-insensitive comparison. After executing the query, the maximum speed value is stored in the max_speed variable, which is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION find_max_speed_for_nation_type(nation IN VARCHAR2, ship_type IN VARCHAR2, year_cutoff IN NUMBER) RETURN NUMBER IS\n  max_speed NUMBER;\nBEGIN\n  SELECT MAX(m.SPEED_KNOTS)\n  INTO max_speed\n  FROM MISSION m\n  JOIN SHIP s ON m.SHIP_ID = s.SHIP_ID\n  WHERE LOWER(s.NATIONALITY) = LOWER(nation)\n    AND LOWER(s.TYPE) = LOWER(ship_type)\n    AND m.LAUNCHED_YEAR < year_cutoff;\n  RETURN max_speed;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "SELECT find_max_speed_for_nation_type('United Kingdom', 'Cargo ship', 1950) FROM DUAL",
      "SELECT find_max_speed_for_nation_type('United States', 'Battle ship', 1940) FROM DUAL",
      "SELECT find_max_speed_for_nation_type('Germany', 'Cargo ship', 1930) FROM DUAL",
      "SELECT find_max_speed_for_nation_type('Norway', 'Battle ship', 2000) FROM DUAL",
      "SELECT find_max_speed_for_nation_type('United Kingdom', 'Battle ship', 1920) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named find_max_speed_for_nation_type that returns the maximum speed. It accepts a nationality, a ship type, and a year cutoff. The function finds the maximum speed from the MISSION table joined with the SHIP table where the ship's nationality and type (both case-insensitive) match the inputs and the mission's launched year is less than the cutoff.",
    "natural_language": "Write a PL/SQL function that gives us the top speed. It should take a country, a kind of vessel, and a not-too-recent year. The function needs to look through mission and ship info to find the highest speed where the ship's country and general category are roughly like the ones provided, and the mission happened a good while back, before that year cutoff.",
    "id": 73,
    "generated_ir": "Write an Oracle PL/SQL function named `find_max_speed_for_nation_type` that accepts three input parameters: `p_nationality` of type `VARCHAR2`, representing the country of the ship; `p_type` of type `VARCHAR2`, representing the general category or kind of vessel; and `p_year_cutoff` of type `NUMBER`, representing a year threshold such that only missions launched before this year are considered. The function returns a single value of data type `NUMBER`, which is the highest speed found.\n\nThe function begins by declaring a local variable `v_max_speed` of type `NUMBER`.\n\nThe core operation is a single `SELECT` statement that uses the `MAX` aggregate function. This statement queries a joined dataset from the `MISSION` and `SHIP` tables. The `JOIN` is performed by matching the `SHIP_ID` column from the `MISSION` table with the `SHIP_ID` column from the `SHIP` table.\n\nThe `SELECT` statement includes a `WHERE` clause with three primary filtering conditions, all of which must be true for a row to be considered.\n\nThe first condition uses the `UPPER` function to perform a case-insensitive, partial string match on the `SHIP.NATIONALITY` column. It checks if the uppercase version of `SHIP.NATIONALITY` contains the uppercase version of the input parameter `p_nationality`. This implements the requirement for the ship's country to be \"roughly like\" the one provided.\n\nThe second condition also uses the `UPPER` function for a case-insensitive, partial string match. It checks if the uppercase version of the `SHIP.TYPE` column contains the uppercase version of the input parameter `p_type`. This implements the requirement for the ship's general category to be \"roughly like\" the one provided.\n\nThe third condition checks that the `MISSION.LAUNCHED_YEAR` column is strictly less than the input parameter `p_year_cutoff`. This ensures only missions that happened \"a good while back, before that year cutoff\" are included.\n\nThe `SELECT` statement applies the `MAX` aggregate function to the `MISSION.SPEED_KNOTS` column across all rows that satisfy the join and filter conditions. The result of this aggregation, which is the highest speed value found (or `NULL` if no rows match), is retrieved and directly assigned to the local variable `v_max_speed`.\n\nFinally, the function returns the value stored in the `v_max_speed` variable. If no matching records are found, the `MAX` function will return `NULL`, and the function will consequently return `NULL`."
  },
  {
    "ir": "Write an Oracle PL/SQL function that calculates and returns the total number of distinct values present in the PROBLEM_STATUS_CODE column of the PROBLEM_STATUS_CODES table. The function, named get_problem_status_count, does not take any input parameters and returns a single numeric value of type NUMBER. Within the function, a local variable named status_count of type NUMBER is declared to store the result of the calculation. The function executes a SQL SELECT statement that counts the number of unique values in the PROBLEM_STATUS_CODE column by using the COUNT function combined with the DISTINCT keyword. The result of this query is assigned to the status_count variable using the INTO clause. Finally, the function returns the value stored in status_count as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_problem_status_count RETURN NUMBER IS\n  status_count NUMBER;\nBEGIN\n  SELECT COUNT(DISTINCT PROBLEM_STATUS_CODE)\n  INTO status_count\n  FROM PROBLEM_STATUS_CODES;\n  RETURN status_count;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT get_problem_status_count FROM DUAL",
      "SELECT get_problem_status_count() FROM DUAL",
      "DECLARE\n  v_count NUMBER;\nBEGIN\n  v_count := get_problem_status_count;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_count);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Status count: ' || get_problem_status_count);\nEND;",
      "SELECT get_problem_status_count AS status_code_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_problem_status_count that returns the count of distinct PROBLEM_STATUS_CODE values from the PROBLEM_STATUS_CODES table as a NUMBER.",
    "natural_language": "Function get_problem_status_count returns distinct PROBLEM_STATUS_CODE count from PROBLEM_STATUS_CODES.",
    "id": 74,
    "generated_ir": "Write an Oracle PL/SQL function named `get_problem_status_count` that accepts no input parameters and returns a single numeric value. This function is designed to calculate and return the count of distinct `PROBLEM_STATUS_CODE` values present in the `PROBLEM_STATUS_CODES` table.\n\nThe function begins by declaring a local variable `v_count` of type `NUMBER` to store the calculated count of distinct status codes.\n\nThe core operation is a `SELECT` statement that performs an aggregation on the `PROBLEM_STATUS_CODES` table. The SQL query uses the `COUNT` aggregate function with the `DISTINCT` keyword applied to the `PROBLEM_STATUS_CODE` column. This ensures that each unique status code is counted only once, regardless of how many times it might appear in the table (though in practice, since `PROBLEM_STATUS_CODE` is the table's primary key, each value is inherently unique, making `DISTINCT` functionally redundant but semantically explicit for the requirement). The `FROM` clause specifies the `PROBLEM_STATUS_CODES` table as the sole data source.\n\nThe result of this `SELECT COUNT(DISTINCT PROBLEM_STATUS_CODE)` query is fetched directly into the local variable `v_count` using the `INTO` clause.\n\nAfter the `SELECT...INTO` operation completes, the function concludes by returning the value stored in the `v_count` variable. This value represents the total number of unique problem status codes defined in the `PROBLEM_STATUS_CODES` reference table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_invoice_date that accepts a single input parameter p_invoice_number of type NUMBER, which represents the identifier for an invoice, and returns a value of type VARCHAR2. The function declares a local variable v_invoice_date of type VARCHAR2 with a maximum length of 255 characters to hold the result. The function executes a SELECT statement that retrieves the value from the INVOICE_DATE column in the INVOICES table, specifically for the row where the INVOICE_NUMBER column exactly matches the value provided in the input parameter p_invoice_number, and stores the retrieved value into the local variable v_invoice_date. The function then returns the value stored in v_invoice_date.",
    "plsql": "CREATE OR REPLACE FUNCTION get_invoice_date(p_invoice_number NUMBER) RETURN VARCHAR2 IS\n  v_invoice_date VARCHAR2(255);\nBEGIN\n  SELECT INVOICE_DATE\n  INTO v_invoice_date\n  FROM INVOICES\n  WHERE INVOICE_NUMBER = p_invoice_number;\n  RETURN v_invoice_date;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ACCOUNTS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "INVOICES",
      "INVOICE_LINE_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_invoice_date(1) FROM DUAL",
      "SELECT get_invoice_date(2) FROM DUAL",
      "SELECT get_invoice_date(3) FROM DUAL",
      "SELECT get_invoice_date(9) FROM DUAL",
      "SELECT get_invoice_date(10) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_invoice_date that accepts an invoice number (NUMBER) and returns the corresponding invoice date (VARCHAR2) from the INVOICES table.",
    "natural_language": "Write a PL/SQL function to get the invoice date as a string. It should take an invoice number and fetch the date from the INVOICES table for that invoice.",
    "id": 75,
    "generated_ir": "Write an Oracle PL/SQL function named get_invoice_date that accepts a single input parameter p_invoice_number of type NUMBER, which represents the identifier for an invoice, and returns a value of type VARCHAR2. The function declares a local variable v_invoice_date of type VARCHAR2 with a maximum length of 255 characters to hold the result. The function executes a SELECT statement that retrieves the value from the INVOICE_DATE column in the INVOICES table, specifically for the row where the INVOICE_NUMBER column exactly matches the value provided in the input parameter p_invoice_number, and stores the retrieved value into the local variable v_invoice_date. The function then returns the value stored in v_invoice_date."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_category_sales that accepts a single input parameter p_category of type VARCHAR2 and returns a NUMBER. The function begins by declaring four local NUMBER variables: v_total_sales initialized to 0, v_item_count initialized to 0, v_avg_price initialized to 0, and v_vat_rate initialized to 0. It then executes a SELECT statement that queries the order_items, products, and product_categories tables. The query joins the order_items table to the products table using the product_id column, and joins the products table to the product_categories table using the production_type_code column. The WHERE clause filters the results to only include rows where the production_type_code column from the products table matches the input parameter p_category. The SELECT statement calculates four aggregate values: the sum of the product of the order_items.product_quantity (converted to a NUMBER) and the products.unit_price, wrapped in a NVL function to return 0 if the result is null; the count of all rows; the average of the products.unit_price, wrapped in a NVL function to return 0 if the result is null; and the maximum value of the product_categories.vat_rating, wrapped in a NVL function to return 0 if the result is null. These four calculated values are assigned into the local variables v_total_sales, v_item_count, v_avg_price, and v_vat_rate respectively. After the query, the function uses an IF-ELSIF-ELSE conditional block to determine the return value. If v_item_count equals 0, the function returns 0. Otherwise, if v_avg_price is greater than 600, the function returns the value of v_total_sales multiplied by 1.1. Otherwise, if v_vat_rate is greater than 14, the function returns the value of v_total_sales multiplied by 0.95. If none of the previous conditions are met, the function returns the unmodified v_total_sales value. The function includes an EXCEPTION handler that catches the NO_DATA_FOUND exception and returns 0, and a generic WHEN OTHERS handler that re-raises the caught exception.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_category_sales(p_category VARCHAR2) RETURN NUMBER IS\n    v_total_sales NUMBER := 0;\n    v_item_count NUMBER := 0;\n    v_avg_price NUMBER := 0;\n    v_vat_rate NUMBER := 0;\nBEGIN\n    SELECT NVL(SUM(TO_NUMBER(oi.product_quantity) * p.unit_price), 0), \n           COUNT(*),\n           NVL(AVG(p.unit_price), 0),\n           NVL(MAX(pc.vat_rating), 0)\n    INTO v_total_sales, v_item_count, v_avg_price, v_vat_rate\n    FROM order_items oi\n    JOIN products p ON oi.product_id = p.product_id\n    JOIN product_categories pc ON p.production_type_code = pc.production_type_code\n    WHERE p.production_type_code = p_category;\n    \n    IF v_item_count = 0 THEN\n        RETURN 0;\n    ELSIF v_avg_price > 600 THEN\n        RETURN v_total_sales * 1.1;\n    ELSIF v_vat_rate > 14 THEN\n        RETURN v_total_sales * 0.95;\n    ELSE\n        RETURN v_total_sales;\n    END IF;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 0;\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT calculate_category_sales('Food') FROM DUAL",
      "SELECT calculate_category_sales('Books') FROM DUAL",
      "SELECT calculate_category_sales('Electronics') FROM DUAL",
      "SELECT calculate_category_sales('DVDs') FROM DUAL",
      "SELECT calculate_category_sales('Clothing') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_category_sales that accepts a p_category VARCHAR2 and returns a NUMBER. It calculates total sales, item count, average price, and max VAT rate for a product category. Return 0 if item count is 0. If average price > 600, return total sales * 1.1. If VAT rate > 14, return total sales * 0.95. Otherwise, return total sales. Handle NO_DATA_FOUND by returning 0 and re-raise other exceptions.",
    "natural_language": "Please construct a PL/SQL function designated as 'calculate_category_sales'. This function shall accept a single input parameter, 'p_category', of type VARCHAR2, and shall return a value of type NUMBER. Its purpose is to compute the aggregate sales total, the count of items, the average price, and the maximum VAT rate pertinent to the specified product category. Should the item count be zero, the function must return zero. Subsequently, if the computed average price exceeds 600, the function is to return the total sales multiplied by 1.1. Alternatively, if the maximum VAT rate is greater than 14, the function shall return the total sales multiplied by 0.95. In all other cases, the total sales figure is to be returned. It is required to handle the NO_DATA_FOUND exception by returning a value of zero, while all other exceptions must be re-raised.",
    "id": 76,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_category_sales that accepts a single input parameter p_category of type VARCHAR2 and returns a NUMBER. The function begins by declaring four local NUMBER variables: v_total_sales initialized to 0, v_item_count initialized to 0, v_avg_price initialized to 0, and v_vat_rate initialized to 0. It then executes a SELECT statement that queries the order_items, products, and product_categories tables. The query joins the order_items table to the products table using the product_id column, and joins the products table to the product_categories table using the production_type_code column. The WHERE clause filters the results to only include rows where the production_type_code column from the products table matches the input parameter p_category. The SELECT statement calculates four aggregate values: the sum of the product of the order_items.product_quantity (converted to a NUMBER) and the products.unit_price, wrapped in a NVL function to return 0 if the result is null; the count of all rows; the average of the products.unit_price, wrapped in a NVL function to return 0 if the result is null; and the maximum value of the product_categories.vat_rating, wrapped in a NVL function to return 0 if the result is null. These four calculated values are assigned into the local variables v_total_sales, v_item_count, v_avg_price, and v_vat_rate respectively. After the query, the function uses an IF-ELSIF-ELSE conditional block to determine the return value. If v_item_count equals 0, the function returns 0. Otherwise, if v_avg_price is greater than 600, the function returns the value of v_total_sales multiplied by 1.1. Otherwise, if v_vat_rate is greater than 14, the function returns the value of v_total_sales multiplied by 0.95. If none of the previous conditions are met, the function returns the unmodified v_total_sales value. The function includes an EXCEPTION handler that catches the NO_DATA_FOUND exception and returns 0, and a generic WHEN OTHERS handler that re-raises the caught exception."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_country_score_sum` that is designed to calculate and return the total sum of various score components for a specific country. This function accepts a single input parameter, `p_country_id`, which is of data type `NUMBER` and represents the unique identifier of the country for which the score sum is to be computed. Internally, the function declares a local variable named `v_sum_score` of data type `NUMBER` to temporarily store the calculated sum of scores. The core operation involves a `SELECT` statement that retrieves data from the `COUNTRIES` table. This `SELECT` statement calculates the sum of six distinct score columns: `OVERALL_SCORE`, `JUSTICE_SCORE`, `HEALTH_SCORE`, `EDUCATION_SCORE`, `ECONOMICS_SCORE`, and `POLITICS_SCORE`. The values from these six columns are added together to produce a single cumulative score. This calculated sum is then immediately assigned to the `v_sum_score` local variable. The `SELECT` statement includes a `WHERE` clause that filters the rows in the `COUNTRIES` table, ensuring that the score sum is calculated only for the row where the `ID` column matches the value provided by the input parameter `p_country_id`. After the sum is calculated and stored in `v_sum_score`, the function concludes by returning the value held in `v_sum_score` as its output, which is of data type `NUMBER`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_score_sum(p_country_id NUMBER) RETURN NUMBER IS\n  v_sum_score NUMBER;\nBEGIN\n  SELECT OVERALL_SCORE + JUSTICE_SCORE + HEALTH_SCORE + EDUCATION_SCORE + ECONOMICS_SCORE + POLITICS_SCORE INTO v_sum_score FROM COUNTRIES WHERE ID = p_country_id;\n  RETURN v_sum_score;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_country_score_sum(1) FROM DUAL",
      "SELECT get_country_score_sum(2) FROM DUAL",
      "SELECT get_country_score_sum(3) FROM DUAL",
      "SELECT c.NAME, get_country_score_sum(c.ID) AS total_score FROM COUNTRIES c WHERE c.ID = 1",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total Score for Country ID 2: ' || get_country_score_sum(2));\nEND;"
    ],
    "summary": "Create a PL/SQL function named get_country_score_sum that accepts a country ID and returns the sum of its OVERALL_SCORE, JUSTICE_SCORE, HEALTH_SCORE, EDUCATION_SCORE, ECONOMICS_SCORE, and POLITICS_SCORE from the COUNTRIES table.",
    "natural_language": "Sum OVERALL_SCORE, JUSTICE_SCORE, HEALTH_SCORE, EDUCATION_SCORE, ECONOMICS_SCORE, and POLITICS_SCORE for a given country ID.",
    "id": 77,
    "generated_ir": "Write an Oracle PL/SQL function named `get_country_score_sum` that accepts one input parameter: `p_country_id` of data type `NUMBER`, which represents the unique identifier of a country. This function returns a single numeric value representing the sum of six specific score columns for the specified country. The function begins by declaring a local numeric variable `v_total_sum` to store the computed result. The core operation is a single `SELECT` statement that retrieves data from the `COUNTRIES` table. The `SELECT` statement calculates a sum by adding together the values from six columns in the `COUNTRIES` table: `OVERALL_SCORE`, `JUSTICE_SCORE`, `HEALTH_SCORE`, `EDUCATION_SCORE`, `ECONOMICS_SCORE`, and `POLITICS_SCORE`. This calculation is performed for a single row, which is filtered by a `WHERE` clause that ensures only the row where the `ID` column matches the value provided in the input parameter `p_country_id` is considered. The result of this summation is then stored directly into the variable `v_total_sum`. After the `SELECT` operation completes, the function returns the value stored in the `v_total_sum` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_staff_name that accepts two parameters: p_staff_id of type NUMBER and p_staff_gender of type VARCHAR2. The purpose of this function is to retrieve and return the name of a staff member from the STAFF table. The function begins by declaring a local variable v_name of type VARCHAR2 with a maximum length of 255 characters, which will be used to store the staff name retrieved from the database. The function then executes a SELECT statement to fetch the STAFF_NAME from the STAFF table, where the STAFF_ID column matches the value of the p_staff_id parameter and the STAFF_GENDER column matches the value of the p_staff_gender parameter. The result of this query is stored in the v_name variable. Finally, the function returns the value of v_name, which contains the name of the staff member that meets the specified criteria.",
    "plsql": "CREATE OR REPLACE FUNCTION get_staff_name(p_staff_id NUMBER, p_staff_gender VARCHAR2) RETURN VARCHAR2 IS\n    v_name VARCHAR2(255);\nBEGIN\n    SELECT STAFF_NAME INTO v_name FROM STAFF WHERE STAFF_ID = p_staff_id AND STAFF_GENDER = p_staff_gender;\n    RETURN v_name;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "ORDER_ITEMS",
      "STAFF",
      "STAFF_DEPARTMENT_ASSIGNMENTS"
    ],
    "call_sqls": [
      "SELECT get_staff_name(1, '1') FROM DUAL",
      "SELECT get_staff_name(2, '1') FROM DUAL",
      "SELECT get_staff_name(3, '1') FROM DUAL",
      "SELECT get_staff_name(1, '0') FROM DUAL",
      "SELECT get_staff_name(4, '1') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_staff_name` that returns a VARCHAR2. It accepts a staff ID (NUMBER) and a staff gender (VARCHAR2). The function retrieves the STAFF_NAME from the STAFF table where STAFF_ID and STAFF_GENDER match the input parameters.",
    "natural_language": "Write a PL/SQL function called `get_staff_name` that gives back a text string. It should take a staff number and a gender indicator. The function needs to look up and return the staff member's name from the STAFF records when the provided ID and general gender description seem to match the table's data.",
    "id": 78,
    "generated_ir": "Write an Oracle PL/SQL function named `get_staff_name` that accepts two input parameters: `p_staff_id` of type `NUMBER` and `p_staff_gender` of type `VARCHAR2`. The function returns a `VARCHAR2` value representing the staff member's name. Inside the function, declare a local variable `v_staff_name` of type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved name. The function's primary operation involves executing a `SELECT` statement to retrieve data from the `STAFF` table. Specifically, it attempts to select the value from the `STAFF_NAME` column into the `v_staff_name` variable. The `SELECT` statement includes a `WHERE` clause with two conditions: first, it filters rows where the `STAFF_ID` column matches the value provided by the input parameter `p_staff_id`; second, it filters rows where the `STAFF_GENDER` column matches the value provided by the input parameter `p_staff_gender`. Following the `SELECT` statement, the function returns the value stored in the `v_staff_name` variable. If no matching row is found, the `SELECT` statement will not populate `v_staff_name`, resulting in a `NULL` value being returned."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_purchase_behavior that accepts a single input parameter p_customer_id of type NUMBER and returns a VARCHAR2 string, which analyzes a customer's purchase history by performing a SELECT query that joins the orders, order_items, and products tables, specifically retrieving the count of distinct orders for the given customer into variable v_order_count, the sum of the product of the product_quantity from order_items and the unit_price from products (with the product_quantity converted from a string to a number using TO_NUMBER) into variable v_total_spent, and the average of that same product calculation into variable v_avg_order_value, using NVL to substitute a value of 0 for any NULL results from the aggregate functions, all filtered by the condition that the customer_id in the orders table matches the input p_customer_id, and then, using conditional IF-ELSIF-ELSE logic, returns the string 'NO_PURCHASES' if v_order_count equals 0, returns 'BIG_SPENDER' if v_total_spent is greater than 5000, returns 'HIGH_AVG_ORDER' if v_avg_order_value is greater than 300, and otherwise returns the string 'REGULAR_CUSTOMER'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_purchase_behavior(p_customer_id NUMBER) RETURN VARCHAR2 IS\n    v_order_count NUMBER;\n    v_total_spent NUMBER;\n    v_avg_order_value NUMBER;\nBEGIN\n    SELECT COUNT(o.order_id), \n           NVL(SUM(TO_NUMBER(oi.product_quantity) * p.unit_price), 0),\n           NVL(AVG(TO_NUMBER(oi.product_quantity) * p.unit_price), 0)\n    INTO v_order_count, v_total_spent, v_avg_order_value\n    FROM orders o\n    JOIN order_items oi ON o.order_id = oi.order_id\n    JOIN products p ON oi.product_id = p.product_id\n    WHERE o.customer_id = p_customer_id;\n    \n    IF v_order_count = 0 THEN\n        RETURN 'NO_PURCHASES';\n    ELSIF v_total_spent > 5000 THEN\n        RETURN 'BIG_SPENDER';\n    ELSIF v_avg_order_value > 300 THEN\n        RETURN 'HIGH_AVG_ORDER';\n    ELSE\n        RETURN 'REGULAR_CUSTOMER';\n    END IF;\nEND;",
    "database_name": "customers_and_invoices",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PRODUCT_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_customer_purchase_behavior(1) FROM DUAL",
      "SELECT get_customer_purchase_behavior(5) FROM DUAL",
      "SELECT get_customer_purchase_behavior(7) FROM DUAL",
      "SELECT get_customer_purchase_behavior(12) FROM DUAL",
      "SELECT get_customer_purchase_behavior(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_customer_purchase_behavior that accepts a p_customer_id NUMBER and returns a VARCHAR2. It calculates the customer's distinct order count, total spent (converted quantity * price), and average order value. Return 'NO_PURCHASES' if order count is 0, 'BIG_SPENDER' if total spent > 5000, 'HIGH_AVG_ORDER' if average value > 300, else 'REGULAR_CUSTOMER'.",
    "natural_language": "What PL/SQL function can be created to return a VARCHAR2 classification for a customer's purchase behavior based on their distinct order count, total amount spent, and average order value, given a customer ID, and how should it categorize them as 'NO_PURCHASES', 'BIG_SPENDER', 'HIGH_AVG_ORDER', or 'REGULAR_CUSTOMER'?",
    "id": 79,
    "generated_ir": "Write an Oracle PL/SQL function named `get_customer_purchase_behavior` that takes a single input parameter `p_customer_id` of type `NUMBER` and returns a `VARCHAR2` classification string. The function is designed to analyze a customer's purchase history from the `customers_and_invoices` database schema and categorize their behavior.\n\nThe function begins by declaring several local variables. It declares `v_distinct_order_count` as `NUMBER` to store the count of unique orders placed by the customer. It declares `v_total_amount_spent` as `NUMBER` to store the sum of all money spent by the customer. It declares `v_average_order_value` as `NUMBER` to store the calculated average spend per order. It also declares `v_classification` as `VARCHAR2(50)` to hold the final behavioral category determined by the function's logic.\n\nThe core of the function involves executing a single `SELECT` statement that performs multiple aggregations from the `ORDERS` and `ORDER_ITEMS` tables, joined with the `PRODUCTS` table. The `SELECT` statement uses the `INTO` clause to populate the three aggregation variables (`v_distinct_order_count`, `v_total_amount_spent`, `v_average_order_value`) in one operation.\n\nThe `SELECT` statement retrieves data for a specific customer by using a `WHERE` clause on `ORDERS.CUSTOMER_ID = p_customer_id`. It performs a `COUNT(DISTINCT ORDERS.ORDER_ID)` to calculate the number of unique orders, storing the result in `v_distinct_order_count`. It calculates the total amount spent by performing a `SUM(PRODUCTS.UNIT_PRICE * TO_NUMBER(ORDER_ITEMS.PRODUCT_QUANTITY))`. This sum multiplies the `UNIT_PRICE` from the `PRODUCTS` table by the `PRODUCT_QUANTITY` from the `ORDER_ITEMS` table (after converting the `VARCHAR2` quantity to a `NUMBER`), aggregating this product across all order items for the customer's orders. The result is stored in `v_total_amount_spent`.\n\nTo obtain the `UNIT_PRICE` for the calculation, the query joins the `ORDER_ITEMS` table to the `PRODUCTS` table on the condition `ORDER_ITEMS.PRODUCT_ID = PRODUCTS.PRODUCT_ID`. The `ORDERS` table is joined to the `ORDER_ITEMS` table on `ORDERS.ORDER_ID = ORDER_ITEMS.ORDER_ID` to link customers to their purchased items.\n\nAfter the aggregations, the function calculates the average order value by dividing `v_total_amount_spent` by `v_distinct_order_count` and assigns the result to `v_average_order_value`. This calculation is protected by a check to avoid division by zero; if `v_distinct_order_count` is zero, `v_average_order_value` is set to zero.\n\nFollowing the data retrieval and calculation, the function implements a conditional business logic block using `IF` and `ELSIF` statements to assign the classification based on the calculated metrics. The logic checks conditions in a specific order of precedence. First, it checks if `v_distinct_order_count` is equal to 0. If true, it assigns the classification 'NO_PURCHASES' to `v_classification`. If the customer has made purchases, it then checks if `v_total_amount_spent` is greater than 10000. If true, it assigns the classification 'BIG_SPENDER' to `v_classification`. If not a big spender, it then checks if `v_average_order_value` is greater than 500. If true, it assigns the classification 'HIGH_AVG_ORDER' to `v_classification`. If none of the previous conditions are met, meaning the customer has orders, spent less than or equal to 10000 total, and has an average order value less than or equal to 500, the function assigns the default classification 'REGULAR_CUSTOMER' to `v_classification`.\n\nFinally, the function concludes by returning the value stored in the `v_classification` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_employee_email that accepts a single parameter, p_emp_id, which is of type NUMBER and represents the unique identifier of an employee. The function is designed to return a value of type VARCHAR2, specifically the email address associated with the employee whose ID matches the provided p_emp_id. Within the function, a local variable v_email of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the email address retrieved from the database. The function executes a SELECT statement that targets the EMAIL column within the EMPLOYEES table, using the condition WHERE EMPLOYEE_ID = p_emp_id to filter the results and ensure that only the email address of the employee with the specified ID is selected. The result of this query is assigned to the v_email variable using the INTO clause. Finally, the function returns the value stored in v_email, effectively providing the email address of the employee identified by the input parameter p_emp_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_email(p_emp_id NUMBER) RETURN VARCHAR2 IS\n    v_email VARCHAR2(255);\nBEGIN\n    SELECT EMAIL INTO v_email FROM EMPLOYEES WHERE EMPLOYEE_ID = p_emp_id;\n    RETURN v_email;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "SELECT get_employee_email(100) FROM dual",
      "SELECT get_employee_email(101) FROM dual",
      "SELECT get_employee_email(102) FROM dual",
      "SELECT get_employee_email(103) FROM dual",
      "SELECT get_employee_email(104) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_employee_email that accepts an employee ID (NUMBER) and returns the corresponding email address (VARCHAR2) from the EMPLOYEES table.",
    "natural_language": "Write a function get_employee_email to return an employee's email from EMPLOYEES given their ID.",
    "id": 80,
    "generated_ir": "Write an Oracle PL/SQL function named get_employee_email that accepts a single parameter, p_emp_id, which is of type NUMBER and represents the unique identifier of an employee. The function is designed to return a value of type VARCHAR2, specifically the email address associated with the employee whose ID matches the provided p_emp_id. Within the function, a local variable v_email of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the email address retrieved from the database. The function executes a SELECT statement that targets the EMAIL column within the EMPLOYEES table, using the condition WHERE EMPLOYEE_ID = p_emp_id to filter the results and ensure that only the email address of the employee with the specified ID is selected. The result of this query is assigned to the v_email variable using the INTO clause. Finally, the function returns the value stored in v_email, effectively providing the email address of the employee identified by the input parameter p_emp_id."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_language_usage_status that accepts a single input parameter p_language_id of the NUMBER data type and returns a VARCHAR2 value, where the function's purpose is to determine and return a descriptive status for a language based on how many countries officially use it, by first executing a SELECT statement that queries the OFFICIAL_LANGUAGES table, counting all rows where the LANGUAGE_ID column matches the provided p_language_id parameter, and storing the resulting count in a local variable v_country_count, then evaluating this count with a series of IF-ELSIF-ELSE conditional statements: if the count equals zero, the function returns the string 'UNUSED'; if the count equals one, it returns 'SINGLE_COUNTRY'; if the count equals two, it returns 'TWO_COUNTRIES'; and for any count greater than two, the function returns the string 'WIDESPREAD'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_language_usage_status(p_language_id NUMBER) RETURN VARCHAR2 IS\n  v_country_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_country_count FROM OFFICIAL_LANGUAGES WHERE LANGUAGE_ID = p_language_id;\n  IF v_country_count = 0 THEN\n    RETURN 'UNUSED';\n  ELSIF v_country_count = 1 THEN\n    RETURN 'SINGLE_COUNTRY';\n  ELSIF v_country_count = 2 THEN\n    RETURN 'TWO_COUNTRIES';\n  ELSE\n    RETURN 'WIDESPREAD';\n  END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT get_language_usage_status(1) FROM dual",
      "SELECT get_language_usage_status(2) FROM dual",
      "SELECT get_language_usage_status(3) FROM dual",
      "SELECT get_language_usage_status(4) FROM dual",
      "SELECT get_language_usage_status(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_language_usage_status that returns a status string ('UNUSED', 'SINGLE_COUNTRY', 'TWO_COUNTRIES', or 'WIDESPREAD') based on the number of countries using a given language ID.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_language_usage_status? It should spit out a status stringlike 'UNUSED', 'SINGLE_COUNTRY', 'TWO_COUNTRIES', or 'WIDESPREAD'depending on how many countries are actually using a specific language ID.",
    "id": 81,
    "generated_ir": "Write an Oracle PL/SQL function named get_language_usage_status that accepts a single input parameter p_language_id of the NUMBER data type and returns a VARCHAR2 value, where the function's purpose is to determine and return a descriptive status for a language based on how many countries officially use it, by first executing a SELECT statement that queries the OFFICIAL_LANGUAGES table, counting all rows where the LANGUAGE_ID column matches the provided p_language_id parameter, and storing the resulting count in a local variable v_country_count, then evaluating this count with a series of IF-ELSIF-ELSE conditional statements: if the count equals zero, the function returns the string 'UNUSED'; if the count equals one, it returns 'SINGLE_COUNTRY'; if the count equals two, it returns 'TWO_COUNTRIES'; and for any count greater than two, the function returns the string 'WIDESPREAD'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_council_tax_total` that is designed to return a single numeric value. This function does not accept any input parameters. Upon execution, it declares a local variable named `v_total` of type `NUMBER` to temporarily store the calculated sum. The core operation involves executing a `SELECT` statement to query the `COUNCIL_TAX` table. Within this `SELECT` statement, it calculates the sum of all values in the `COUNCIL_TAX_ID` column. The `NVL` (Null Value Logic) function is applied to the `SUM(COUNCIL_TAX_ID)` result, ensuring that if the `SUM` operation returns `NULL` (which would happen if the `COUNCIL_TAX` table is empty or if all `COUNCIL_TAX_ID` values are `NULL`), the `NVL` function will substitute `0` instead of `NULL`. The result of this `SUM` (or `0` if `NULL`) is then stored into the `v_total` variable. After successfully calculating and storing the sum, the function returns the value currently held in `v_total`. The function also includes an exception handling block. If any unhandled exception occurs during the execution of the `SELECT` statement or any other part of the `BEGIN...END` block, the `WHEN OTHERS` clause will catch it, and in such an event, the function will return the numeric value `0` instead of the calculated sum.",
    "plsql": "CREATE OR REPLACE FUNCTION get_council_tax_total\nRETURN NUMBER\nIS\n    v_total NUMBER;\nBEGIN\n    SELECT NVL(SUM(COUNCIL_TAX_ID), 0)\n    INTO v_total\n    FROM COUNCIL_TAX;\n    \n    RETURN v_total;\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN 0;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "ELECTORAL_REGISTER",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_council_tax_total FROM DUAL",
      "SELECT get_council_tax_total() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_council_tax_total;\n  DBMS_OUTPUT.PUT_LINE('Total: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Council Tax Total: ' || get_council_tax_total);\nEND;",
      "SELECT get_council_tax_total AS total_sum FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_council_tax_total that returns a NUMBER with no parameters. It sums the COUNCIL_TAX_ID column from the COUNCIL_TAX table, returning 0 for NULL or empty results. Return the sum, or 0 if an exception occurs.",
    "natural_language": "Write a PL/SQL function get_council_tax_total with no parameters returning NUMBER. Sum COUNCIL_TAX_ID from COUNCIL_TAX. Return sum, 0 for NULL/empty, or 0 on exception.",
    "id": 82,
    "generated_ir": "Write an Oracle PL/SQL function named `get_council_tax_total` that is designed to return a single numeric value. This function does not accept any input parameters. Upon execution, it declares a local variable named `v_total` of type `NUMBER` to temporarily store the calculated sum. The core operation involves executing a `SELECT` statement to query the `COUNCIL_TAX` table. Within this `SELECT` statement, it calculates the sum of all values in the `COUNCIL_TAX_ID` column. The `NVL` (Null Value Logic) function is applied to the `SUM(COUNCIL_TAX_ID)` result, ensuring that if the `SUM` operation returns `NULL` (which would happen if the `COUNCIL_TAX` table is empty or if all `COUNCIL_TAX_ID` values are `NULL`), the `NVL` function will substitute `0` instead of `NULL`. The result of this `SUM` (or `0` if `NULL`) is then stored into the `v_total` variable. After successfully calculating and storing the sum, the function returns the value currently held in `v_total`. The function also includes an exception handling block. If any unhandled exception occurs during the execution of the `SELECT` statement or any other part of the `BEGIN...END` block, the `WHEN OTHERS` clause will catch it, and in such an event, the function will return the numeric value `0` instead of the calculated sum."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_teacher_classroom that accepts two input parameters: a VARCHAR2 parameter named p_lastname representing a teacher's last name and a VARCHAR2 parameter named p_firstname representing a teacher's first name, and returns a NUMBER data type; within the function's execution block, it declares a local NUMBER variable named v_classroom, then executes a SELECT statement that queries the CLASSROOM column from the TEACHERS table, retrieving a single value into the v_classroom variable where the table's LASTNAME column exactly matches the input parameter p_lastname and the table's FIRSTNAME column exactly matches the input parameter p_firstname, and finally returns the value stored in the v_classroom variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_teacher_classroom(p_lastname VARCHAR2, p_firstname VARCHAR2) RETURN NUMBER IS\n  v_classroom NUMBER;\nBEGIN\n  SELECT CLASSROOM INTO v_classroom FROM TEACHERS WHERE LASTNAME = p_lastname AND FIRSTNAME = p_firstname;\n  RETURN v_classroom;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_teacher_classroom('Smith', 'John') FROM dual",
      "SELECT get_teacher_classroom('Doe', 'Jane') FROM dual",
      "SELECT get_teacher_classroom('Brown', 'Charlie') FROM dual",
      "SELECT get_teacher_classroom('Johnson', 'Emily') FROM dual",
      "SELECT get_teacher_classroom('Williams', 'Michael') FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_teacher_classroom` that accepts a teacher's last name and first name (both VARCHAR2) and returns the classroom number (NUMBER) for that teacher from the TEACHERS table.",
    "natural_language": "What is the classroom number for the teacher with the specified first and last name?",
    "id": 83,
    "generated_ir": "Write an Oracle PL/SQL function named get_teacher_classroom that returns a NUMBER type value representing the classroom number associated with a teacher identified by their first and last name. The function takes two input parameters: p_firstname of type VARCHAR2(255) to specify the teacher's first name, and p_lastname of type VARCHAR2(255) to specify the teacher's last name. The function begins by declaring a local variable v_classroom of type NUMBER, which is intended to store the classroom number retrieved from the TEACHERS table. The function then executes a SELECT statement that queries the TEACHERS table to fetch the CLASSROOM column value where the FIRSTNAME column matches the p_firstname parameter and the LASTNAME column matches the p_lastname parameter. This SELECT statement uses a WHERE clause to filter rows based on the equality of both the FIRSTNAME and LASTNAME columns to the provided parameter values. The retrieved CLASSROOM value is stored into the v_classroom variable. After successfully retrieving and storing the classroom number, the function concludes by returning the value stored in v_classroom, thereby providing the classroom number for the specified teacher."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_problem_category_count that returns a single numeric value, declares a local variable named category_count of type NUMBER, executes a SELECT statement that queries the PROBLEM_LOG table, calculates the count of distinct values found in the PROBLEM_CATEGORY_CODE column of that table, stores the result of this count into the local variable category_count, and then returns the value of this variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_problem_category_count RETURN NUMBER IS\n  category_count NUMBER;\nBEGIN\n  SELECT COUNT(DISTINCT PROBLEM_CATEGORY_CODE)\n  INTO category_count\n  FROM PROBLEM_LOG;\n  RETURN category_count;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "SELECT get_problem_category_count FROM DUAL",
      "SELECT get_problem_category_count() FROM DUAL",
      "DECLARE\n  v_count NUMBER;\nBEGIN\n  v_count := get_problem_category_count;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_count);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Problem categories: ' || get_problem_category_count);\nEND;",
      "SELECT get_problem_category_count AS category_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_problem_category_count that returns the count of distinct PROBLEM_CATEGORY_CODE values from the PROBLEM_LOG table as a NUMBER.",
    "natural_language": "What is the count of distinct PROBLEM_CATEGORY_CODE values in the PROBLEM_LOG table? Create a PL/SQL function named get_problem_category_count to return this count as a NUMBER.",
    "id": 84,
    "generated_ir": "Write an Oracle PL/SQL function named get_problem_category_count that returns a single numeric value, declares a local variable named category_count of type NUMBER, executes a SELECT statement that queries the PROBLEM_LOG table, calculates the count of distinct values found in the PROBLEM_CATEGORY_CODE column of that table, stores the result of this count into the local variable category_count, and then returns the value of this variable as the function's result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_catalog_volume that takes two input parameters: a NUMBER parameter named p_entry_id and a NUMBER parameter named p_multiplier, and returns a NUMBER value. The function begins by declaring four local NUMBER variables: v_length, v_height, v_width, and v_volume. It then executes a SELECT statement to query the CATALOG_CONTENTS table, retrieving the values from the columns named \"LENGTH\", \"HEIGHT\", and \"WIDTH\" for the specific row where the CATALOG_ENTRY_ID column matches the input parameter p_entry_id. For each of these three retrieved column values, the function uses the TO_NUMBER function with the format model '999999.99' to explicitly convert the column's string value into a numeric data type, and then wraps this conversion in an NVL function to substitute a value of 0 if the conversion results in a NULL. These three processed values are assigned into the local variables v_length, v_height, and v_width, respectively. The function then calculates the volume by multiplying the values stored in v_length, v_height, and v_width together and then multiplying that product by the input parameter p_multiplier, storing the final result in the v_volume variable. The function returns this calculated v_volume value. If any exception occurs during the execution of the SELECT statement, the data conversion, or the calculation, the function's EXCEPTION block with the WHEN OTHERS clause catches the error and causes the function to return a value of 0 instead.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_catalog_volume(p_entry_id NUMBER, p_multiplier NUMBER) RETURN NUMBER IS\n  v_length NUMBER;\n  v_height NUMBER;\n  v_width NUMBER;\n  v_volume NUMBER;\nBEGIN\n  SELECT NVL(TO_NUMBER(\"LENGTH\", '999999.99'), 0),\n         NVL(TO_NUMBER(\"HEIGHT\", '999999.99'), 0),\n         NVL(TO_NUMBER(\"WIDTH\", '999999.99'), 0)\n  INTO v_length, v_height, v_width\n  FROM CATALOG_CONTENTS\n  WHERE CATALOG_ENTRY_ID = p_entry_id;\n\n  v_volume := v_length * v_height * v_width * p_multiplier;\n  RETURN v_volume;\n\nEXCEPTION\n  WHEN OTHERS THEN\n    RETURN 0; -- Return 0 or handle the error as needed\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "SELECT calculate_catalog_volume(1, 1.5) FROM dual",
      "SELECT calculate_catalog_volume(2, 2.0) FROM dual",
      "SELECT calculate_catalog_volume(3, 0.5) FROM dual",
      "SELECT calculate_catalog_volume(1, 3.0) FROM dual",
      "SELECT calculate_catalog_volume(2, 1.2) FROM dual"
    ],
    "summary": "Create a PL/SQL function named calculate_catalog_volume that takes a catalog entry ID and a multiplier, calculates the volume from LENGTH, HEIGHT, and WIDTH columns (converted to number with NULL as 0), multiplies by the multiplier, and returns the result. Return 0 on any error.",
    "natural_language": "How can I create a PL/SQL function called calculate_catalog_volume that accepts a catalog entry ID and a multiplier, computes the volume using the LENGTH, HEIGHT, and WIDTH columns (treating NULL as 0 after conversion to number), multiplies that volume by the given multiplier, and then returns the final result, while ensuring it returns 0 if any error occurs?",
    "id": 85,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_catalog_volume that accepts two input parameters: p_catalog_entry_id of type NUMBER and p_multiplier of type NUMBER. The function is designed to return a NUMBER value. The purpose of this function is to compute a volume based on dimensions from a catalog entry, apply a multiplier, and handle potential errors gracefully by returning 0.\n\nThe function begins by declaring three local variables: v_length, v_height, and v_width, each of type NUMBER. These variables will store the numeric values of the corresponding dimension columns after conversion and null handling.\n\nThe core operation involves executing a SELECT statement to retrieve data from the CATALOG_CONTENTS table. The query selects three specific columns: LENGTH, HEIGHT, and WIDTH. It filters the records to only include the row where the CATALOG_ENTRY_ID column matches the input parameter p_catalog_entry_id. The SELECT statement uses the INTO clause to assign the retrieved values directly to the three declared local variables (v_length, v_height, v_width).\n\nFor each of the three dimension values (LENGTH, HEIGHT, WIDTH), the function performs a data conversion and null-handling operation. Since the columns are defined as VARCHAR2(255) but contain numeric string examples, the function must convert them to numbers. It uses the NVL function to treat any NULL value as the string '0'. Then, it uses the TO_NUMBER function to convert the resulting string (either the original non-null value or '0') into a numeric data type. This ensures that if a column value is NULL, it is treated as 0 for the calculation.\n\nAfter obtaining the three numeric dimension values, the function calculates the volume by multiplying them together: v_length * v_height * v_width. It then calculates the final result by multiplying this computed volume by the input parameter p_multiplier.\n\nThe entire calculation block is wrapped within an exception handling section. The function declares an exception handler for OTHERS, which catches any exception that occurs during the execution of the block (such as a conversion error from TO_NUMBER if a non-numeric string is encountered, or a no_data_found exception if the SELECT statement does not find a matching CATALOG_ENTRY_ID). If any exception is caught, the function does not propagate the error; instead, it returns the value 0 immediately.\n\nIf no exception occurs during the SELECT and calculation steps, the function proceeds to return the final calculated result (volume * multiplier).\n\nThe function operates within the product_catalog database context and interacts primarily with the CATALOG_CONTENTS table, specifically using the CATALOG_ENTRY_ID, LENGTH, HEIGHT, and WIDTH columns."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_next_ceremony_date that accepts a single parameter p_festival_id of type NUMBER, which is intended to represent the unique identifier of a festival. The function is designed to calculate and return a DATE value. It begins by initializing a local variable v_result_date with the current system date obtained using the SYSDATE function. Another local variable, v_next_monday, is declared and initialized to store the date of the next Monday following the current system date, which is determined using the NEXT_DAY function with 'MONDAY' as the specified day of the week. The function then updates the v_result_date variable by adding 30 days to the value stored in v_next_monday, effectively setting v_result_date to a date that is 30 days after the next Monday. Finally, the function returns the value of v_result_date, which represents the calculated date for the next ceremony. The function does not perform any database operations such as updates, inserts, deletes, or selects, nor does it involve any conditional logic or interaction with database tables.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_next_ceremony_date(p_festival_id NUMBER) RETURN DATE IS\n    v_result_date DATE := SYSDATE;\n    v_next_monday DATE := NEXT_DAY(SYSDATE, 'MONDAY');\nBEGIN\n    v_result_date := v_next_monday + 30;\n    RETURN v_result_date;\nEND;",
    "database_name": "music_4",
    "tables": [
      "ARTIST",
      "MUSIC_FESTIVAL",
      "VOLUME"
    ],
    "call_sqls": [
      "SELECT calculate_next_ceremony_date(1) FROM DUAL",
      "SELECT calculate_next_ceremony_date(2) FROM DUAL",
      "SELECT calculate_next_ceremony_date(3) FROM DUAL",
      "SELECT calculate_next_ceremony_date(10) FROM DUAL",
      "SELECT calculate_next_ceremony_date(15) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_next_ceremony_date that accepts a festival ID (NUMBER) and returns a DATE. The function should calculate the date as 30 days after the next Monday from the current system date.",
    "natural_language": "Write a PL/SQL function called calculate_next_ceremony_date that takes a festival ID and gives back a date. It should figure out the date by adding a fair number of days, like around a month or so, after the upcoming Monday from today's date.",
    "id": 86,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_next_ceremony_date that accepts a single parameter p_festival_id of type NUMBER, which is intended to represent the unique identifier of a festival. The function is designed to calculate and return a DATE value. It begins by initializing a local variable v_result_date with the current system date obtained using the SYSDATE function. Another local variable, v_next_monday, is declared and initialized to store the date of the next Monday following the current system date, which is determined using the NEXT_DAY function with 'MONDAY' as the specified day of the week. The function then updates the v_result_date variable by adding 30 days to the value stored in v_next_monday, effectively setting v_result_date to a date that is 30 days after the next Monday. Finally, the function returns the value of v_result_date, which represents the calculated date for the next ceremony. The function does not perform any database operations such as updates, inserts, deletes, or selects, nor does it involve any conditional logic or interaction with database tables."
  },
  {
    "ir": "Write an Oracle PL/SQL function named determine_best_currency that accepts a single input parameter p_entry_id of type NUMBER, which represents a catalog entry identifier, and returns a VARCHAR2 string. The function begins by declaring local variables v_euro_price and v_pound_price, both of type NUMBER, and v_currency of type VARCHAR2(10). It executes a SELECT statement to query the CATALOG_CONTENTS table, retrieving the PRICE_IN_EUROS and PRICE_IN_POUNDS column values for the specific row where the CATALOG_ENTRY_ID column equals the provided p_entry_id parameter, and stores these values into the v_euro_price and v_pound_price variables respectively. Following the data retrieval, the function uses a conditional IF-ELSIF-ELSE block to determine the return value. The first condition checks if v_euro_price is less than v_pound_price AND if v_euro_price is also less than 200; if true, it assigns the string 'EUR_CHEAP' to v_currency. If the first condition is false, the first ELSIF condition checks if v_pound_price is less than v_euro_price AND if v_pound_price is less than 200; if true, it assigns 'GBP_CHEAP' to v_currency. If the second condition is also false, the next ELSIF condition checks if v_euro_price is less than v_pound_price (without the price being under 200); if true, it assigns 'EUR' to v_currency. If none of the preceding conditions are met, the final ELSE block assigns 'GBP' to v_currency. The function concludes by returning the value stored in the v_currency variable.",
    "plsql": "CREATE OR REPLACE FUNCTION determine_best_currency(p_entry_id NUMBER) RETURN VARCHAR2 IS\n    v_euro_price NUMBER;\n    v_pound_price NUMBER;\n    v_currency VARCHAR2(10);\nBEGIN\n    SELECT PRICE_IN_EUROS, PRICE_IN_POUNDS INTO v_euro_price, v_pound_price FROM CATALOG_CONTENTS WHERE CATALOG_ENTRY_ID = p_entry_id;\n    IF v_euro_price < v_pound_price AND v_euro_price < 200 THEN v_currency := 'EUR_CHEAP';\n    ELSIF v_pound_price < v_euro_price AND v_pound_price < 200 THEN v_currency := 'GBP_CHEAP';\n    ELSIF v_euro_price < v_pound_price THEN v_currency := 'EUR';\n    ELSE v_currency := 'GBP';\n    END IF;\n    RETURN v_currency;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "CATALOG_CONTENTS"
    ],
    "call_sqls": [
      "SELECT determine_best_currency(1) FROM dual",
      "SELECT determine_best_currency(2) FROM dual",
      "SELECT determine_best_currency(3) FROM dual",
      "SELECT determine_best_currency(5) FROM dual",
      "SELECT determine_best_currency(6) FROM dual"
    ],
    "summary": "Create a PL/SQL function named determine_best_currency that takes a catalog entry ID (NUMBER) and returns a currency recommendation (VARCHAR2). Compare the entry's PRICE_IN_EUROS and PRICE_IN_POUNDS. Return 'EUR_CHEAP' if the Euro price is lower than the Pound price and under 200, 'GBP_CHEAP' if the Pound price is lower and under 200, 'EUR' if only the Euro price is lower, otherwise return 'GBP'.",
    "natural_language": "Make function determine_best_currency. Input: catalog ID (NUMBER). Output: currency (VARCHAR2). Compare PRICE_IN_EUROS and PRICE_IN_POUNDS. Return 'EUR_CHEAP' if Euro cheaper and <200, 'GBP_CHEAP' if Pound cheaper and <200, 'EUR' if only Euro cheaper, else 'GBP'.",
    "id": 87,
    "generated_ir": "Write an Oracle PL/SQL function named determine_best_currency that is designed to analyze and return a currency recommendation based on price comparisons for a specific catalog entry. This function accepts one input parameter: a catalog ID of data type NUMBER, which corresponds to the CATALOG_ENTRY_ID in the CATALOG_CONTENTS table. The function returns a VARCHAR2 value representing the currency determination.\n\nInternally, the function declares three local variables: v_price_in_euros of type NUMBER to store the Euro price, v_price_in_pounds of type NUMBER to store the Pound price, and v_result of type VARCHAR2 to hold the final currency recommendation.\n\nThe core operation begins with a SELECT statement that retrieves the PRICE_IN_EUROS and PRICE_IN_POUNDS columns from the CATALOG_CONTENTS table for the row where the CATALOG_ENTRY_ID matches the input catalog ID parameter. The retrieved values are stored into the v_price_in_euros and v_price_in_pounds variables, respectively.\n\nFollowing the data retrieval, the function implements a series of conditional comparisons to determine the output. First, it checks if v_price_in_euros is less than v_price_in_pounds. If true, it further evaluates if v_price_in_euros is less than 200. If both conditions are met, the function sets v_result to 'EUR_CHEAP'. If only the first condition is true (Euro is cheaper but not less than 200), it sets v_result to 'EUR'.\n\nIf the initial comparison is false (meaning v_price_in_euros is not less than v_price_in_pounds), the function then checks if v_price_in_pounds is less than v_price_in_euros. If true, it further evaluates if v_price_in_pounds is less than 200. If both conditions are met, the function sets v_result to 'GBP_CHEAP'. If only the first condition is true (Pound is cheaper but not less than 200), it sets v_result to 'GBP'.\n\nFinally, the function returns the value stored in the v_result variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named CALCULATE_AGE_BONUS that takes a single input parameter p_actor_id of type NUMBER, representing the unique identifier of an actor in the ACTOR table. The function retrieves the AGE column value from the ACTOR table for the row where the ACTOR_ID column matches the value of the input parameter p_actor_id. The AGE column is expected to store the age of the actor as a numeric value. The retrieved AGE value is stored in a local variable v_age of type NUMBER. The function then evaluates a conditional statement: if the value of v_age is greater than 25, the function adds 5 to the value of v_age and returns the resulting sum as the output of the function. If the value of v_age is less than or equal to 25, the function directly returns the value of v_age without modification. The function does not perform any updates, inserts, or deletes, and its sole operation is a SELECT statement to retrieve the AGE value from the ACTOR table based on the provided ACTOR_ID. The logic flow involves a single conditional check on the retrieved AGE value and a return statement based on the result of this check.",
    "plsql": "CREATE OR REPLACE FUNCTION CALCULATE_AGE_BONUS(p_actor_id NUMBER) RETURN NUMBER IS\n  v_age NUMBER;\nBEGIN\n  SELECT AGE INTO v_age FROM ACTOR WHERE ACTOR_ID = p_actor_id;\n  IF v_age > 25 THEN\n    RETURN v_age + 5;\n  ELSE\n    RETURN v_age;\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT CALCULATE_AGE_BONUS(1) FROM DUAL",
      "SELECT CALCULATE_AGE_BONUS(2) FROM DUAL",
      "SELECT CALCULATE_AGE_BONUS(3) FROM DUAL",
      "SELECT CALCULATE_AGE_BONUS(ACTOR_ID) FROM ACTOR WHERE AGE = 26",
      "SELECT CALCULATE_AGE_BONUS(ACTOR_ID) FROM ACTOR WHERE AGE = 22"
    ],
    "summary": "Create a function named CALCULATE_AGE_BONUS that takes an actor_id (NUMBER) and returns a NUMBER. It retrieves the actor's age from the ACTOR table. If the age is greater than 25, return the age plus 5; otherwise, return the age.",
    "natural_language": "Define a function called CALCULATE_AGE_BONUS that accepts a single parameter of type NUMBER representing an actor_id and returns a value of type NUMBER. The function shall query the ACTOR table to obtain the specified actor's age. Subsequently, if the retrieved age exceeds 25, the function is to return the sum of the age and 5; otherwise, it should return the age itself.",
    "id": 88,
    "generated_ir": "Write an Oracle PL/SQL function named CALCULATE_AGE_BONUS that accepts a single input parameter p_actor_id of the NUMBER data type, representing the unique identifier of an actor, and returns a value of the NUMBER data type, which is designed to compute a bonus-adjusted age based on the actor's current age. The function begins by declaring a local variable v_age of type NUMBER to store the actor's age retrieved from the database. The function executes a SELECT statement that queries the ACTOR table, specifically selecting the value from the AGE column for the row where the ACTOR_ID column exactly matches the provided p_actor_id parameter, and stores this result into the v_age variable. Following the query, the function uses a conditional IF-THEN-ELSE block to evaluate the value of v_age. If v_age is greater than 25, the function returns the sum of v_age and 5. Otherwise, if v_age is 25 or less, the function returns the value of v_age directly."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `format_university_info` that accepts two input parameters: `p_university_id` of data type `NUMBER`, intended to represent the unique identifier of a university, and `p_format_type` of data type `NUMBER`, which is currently unused within the function's logic. This function is designed to return a `VARCHAR2` string. Upon execution, the function declares a local variable `v_result` of data type `VARCHAR2` with a maximum length of 500 characters. The core operation involves a `SELECT` statement that retrieves data from the `UNIVERSITY` table. Specifically, it concatenates the value from the `UNIVERSITY_NAME` column, a literal string ' - ', and the value from the `CITY` column. The result of this concatenation is then assigned to the `v_result` variable. This selection is performed under a specific condition: the `UNIVERSITY_ID` column in the `UNIVERSITY` table must exactly match the value provided in the `p_university_id` input parameter. After successfully retrieving and concatenating the university name and city based on the provided ID, the function immediately returns the value stored in the `v_result` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION format_university_info(p_university_id NUMBER, p_format_type NUMBER) RETURN VARCHAR2 IS\n  v_result VARCHAR2(500);\nBEGIN\n  SELECT UNIVERSITY_NAME || ' - ' || CITY INTO v_result FROM UNIVERSITY WHERE UNIVERSITY_ID = p_university_id;\n  RETURN v_result;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "SELECT format_university_info(1, 1) FROM DUAL",
      "SELECT format_university_info(2, 1) FROM DUAL",
      "SELECT format_university_info(3, 1) FROM DUAL",
      "SELECT UNIVERSITY_ID, format_university_info(UNIVERSITY_ID, 1) FROM UNIVERSITY WHERE UNIVERSITY_ID = 1",
      "SELECT format_university_info(UNIVERSITY_ID, 1) FROM UNIVERSITY WHERE CITY = 'Aurora'"
    ],
    "summary": "Create a PL/SQL function named format_university_info that accepts a university ID and an unused format type. It returns a concatenated string of the university name and city for the given ID.",
    "natural_language": "Write a PL/SQL function called format_university_info that takes a university ID and an unused format type. It should output a string combining the university's name and city for the specified ID.",
    "id": 89,
    "generated_ir": "Write an Oracle PL/SQL function named `format_university_info` that accepts two input parameters: `p_university_id` of data type `NUMBER`, intended to represent the unique identifier of a university, and `p_format_type` of data type `NUMBER`, which is currently unused within the function's logic. This function is designed to return a `VARCHAR2` string. Upon execution, the function declares a local variable `v_result` of data type `VARCHAR2` with a maximum length of 500 characters. The core operation involves a `SELECT` statement that retrieves data from the `UNIVERSITY` table. Specifically, it concatenates the value from the `UNIVERSITY_NAME` column, a literal string ' - ', and the value from the `CITY` column. The result of this concatenation is then assigned to the `v_result` variable. This selection is performed under a specific condition: the `UNIVERSITY_ID` column in the `UNIVERSITY` table must exactly match the value provided in the `p_university_id` input parameter. After successfully retrieving and concatenating the university name and city based on the provided ID, the function immediately returns the value stored in the `v_result` variable as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_name that accepts a single parameter p_code of type NUMBER, which represents the code of a product. The function is designed to retrieve the name of a product from the PRODUCTS table. It declares a local variable v_name of type VARCHAR2 with a maximum length of 255 characters to store the product name. Within the function's execution block, a SELECT statement is used to query the PRODUCTS table, specifically targeting the NAME column. The query includes a WHERE clause that filters the rows based on the condition that the CODE column in the PRODUCTS table matches the value of the p_code parameter. The result of this query, which is the product name corresponding to the provided product code, is assigned to the v_name variable using the INTO clause. Finally, the function returns the value stored in v_name, which is the name of the product associated with the given product code.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_name(p_code NUMBER) RETURN VARCHAR2 IS\nv_name VARCHAR2(255);\nBEGIN\nSELECT NAME INTO v_name FROM PRODUCTS WHERE CODE = p_code;\nRETURN v_name;\nEND;",
    "database_name": "manufactory_1",
    "tables": [
      "MANUFACTURERS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT get_product_name(1) FROM DUAL",
      "SELECT get_product_name(2) FROM DUAL",
      "SELECT get_product_name(3) FROM DUAL",
      "SELECT get_product_name(4) FROM DUAL",
      "SELECT get_product_name(5) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_product_name that accepts a NUMBER parameter p_code and returns a VARCHAR2. It selects the NAME from the PRODUCTS table where CODE equals p_code and returns the value.",
    "natural_language": "Write a PL/SQL function called get_product_name that takes a NUMBER parameter p_code and returns a VARCHAR2. Have it fetch the NAME from the PRODUCTS table where CODE matches p_code and then return that name.",
    "id": 90,
    "generated_ir": "Write an Oracle PL/SQL function named get_product_name that accepts a single parameter p_code of type NUMBER, which represents the code of a product. The function is designed to retrieve the name of a product from the PRODUCTS table. It declares a local variable v_name of type VARCHAR2 with a maximum length of 255 characters to store the product name. Within the function's execution block, a SELECT statement is used to query the PRODUCTS table, specifically targeting the NAME column. The query includes a WHERE clause that filters the rows based on the condition that the CODE column in the PRODUCTS table matches the value of the p_code parameter. The result of this query, which is the product name corresponding to the provided product code, is assigned to the v_name variable using the INTO clause. Finally, the function returns the value stored in v_name, which is the name of the product associated with the given product code."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_total_rent_arrears` that accepts a single input parameter named `master_customer_id` of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `total_arrears` of data type `NUMBER` to temporarily store the calculated sum. The core operation of this function involves executing a `SELECT` statement to retrieve data. Specifically, it calculates the `SUM` of the values in the `COUNCIL_TAX_ID` column. This summation is performed on rows retrieved from two tables: `RENT_ARREARS`, aliased as `ra`, and `CMI_CROSS_REFERENCES`, aliased as `ccr`. These two tables are joined using an `INNER JOIN` operation. The join condition specifies that rows from `RENT_ARREARS` and `CMI_CROSS_REFERENCES` are matched when the value in the `CMI_CROSS_REF_ID` column of the `RENT_ARREARS` table is equal to the value in the `CMI_CROSS_REF_ID` column of the `CMI_CROSS_REFERENCES` table. Furthermore, a `WHERE` clause is applied to filter the joined results. This condition ensures that only rows where the value in the `MASTER_CUSTOMER_ID` column of the `CMI_CROSS_REFERENCES` table is equal to the value passed into the function via the `master_customer_id` input parameter are considered for the summation. The calculated `SUM` of `COUNCIL_TAX_ID` values, based on these join and filter conditions, is then stored into the `total_arrears` local variable. Finally, the function returns the value currently held in the `total_arrears` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_rent_arrears(master_customer_id IN NUMBER) RETURN NUMBER IS\n  total_arrears NUMBER;\nBEGIN\n  SELECT SUM(COUNCIL_TAX_ID)\n  INTO total_arrears\n  FROM RENT_ARREARS ra\n  JOIN CMI_CROSS_REFERENCES ccr ON ra.CMI_CROSS_REF_ID = ccr.CMI_CROSS_REF_ID\n  WHERE ccr.MASTER_CUSTOMER_ID = master_customer_id;\n  RETURN total_arrears;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "SELECT get_total_rent_arrears(1) FROM dual",
      "SELECT get_total_rent_arrears(2) FROM dual",
      "SELECT get_total_rent_arrears(3) FROM dual",
      "SELECT get_total_rent_arrears(4) FROM dual",
      "SELECT get_total_rent_arrears(5) FROM dual"
    ],
    "summary": "Create a PL/SQL function named `get_total_rent_arrears` that accepts a `master_customer_id` (NUMBER) and returns the sum of `COUNCIL_TAX_ID` (NUMBER) by joining the `RENT_ARREARS` and `CMI_CROSS_REFERENCES` tables where their `CMI_CROSS_REF_ID` columns match and the `MASTER_CUSTOMER_ID` equals the input parameter.",
    "natural_language": "Calculate the total rent arrears for a specific master customer. Write a PL/SQL function called `get_total_rent_arrears` that takes a `master_customer_id` number as input, joins the `RENT_ARREARS` and `CMI_CROSS_REFERENCES` tables on their matching `CMI_CROSS_REF_ID`, filters for the given customer ID, and returns the sum of the `COUNCIL_TAX_ID` values.",
    "id": 91,
    "generated_ir": "Write an Oracle PL/SQL function named get_total_rent_arrears that calculates and returns the total sum of council tax ID values associated with rent arrears for a specific master customer. The function resides in the local_govt_mdm database. It accepts a single input parameter, p_master_customer_id, of data type NUMBER, which specifies the master customer for whom the total rent arrears are to be calculated. The function returns a single numeric value of data type NUMBER.\n\nInternally, the function declares a local variable v_total_arrears of data type NUMBER to store the computed sum. The core operation is a SELECT statement that performs an aggregation. This SELECT statement queries the RENT_ARREARS table, specifically summing the values from its COUNCIL_TAX_ID column. To correctly filter the data for the specified master customer, the query joins the RENT_ARREARS table with the CMI_CROSS_REFERENCES table. The join condition is an INNER JOIN on the equality of the CMI_CROSS_REF_ID column from both tables (RENT_ARREARS.CMI_CROSS_REF_ID = CMI_CROSS_REFERENCES.CMI_CROSS_REF_ID). The query includes a WHERE clause to filter the joined result set. The filtering condition is that the MASTER_CUSTOMER_ID column from the CMI_CROSS_REFERENCES table must exactly match the value provided by the input parameter p_master_customer_id. The result of the SUM aggregation is directly selected into the local variable v_total_arrears. After the SELECT statement executes and populates v_total_arrears, the function returns the value stored in this variable as its final output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_customer_debt_total` that takes a single input parameter `p_cross_ref_id` of type `NUMBER`, representing a unique identifier for a customer, and returns a `NUMBER` value representing the total debt associated with the customer. The function begins by initializing a local variable `v_total` to 0, which will accumulate the total debt. It also declares four additional local variables: `v_benefits`, `v_rent`, `v_parking`, and `v_tax`, all of type `NUMBER`, to store intermediate sums of debts from different categories. The function performs four separate `SELECT` statements to retrieve the sum of the `COUNCIL_TAX_ID` column from four different tables (`BENEFITS_OVERPAYMENTS`, `RENT_ARREARS`, `PARKING_FINES`, and `COUNCIL_TAX`) where the `CMI_CROSS_REF_ID` column matches the input parameter `p_cross_ref_id`. Each `SELECT` statement uses the `COALESCE` function to ensure that a `NULL` result is replaced with 0, and the retrieved values are stored in the respective local variables (`v_benefits`, `v_rent`, `v_parking`, and `v_tax`). After retrieving the values, the function applies conditional logic to adjust the value of `v_benefits` based on its magnitude: if `v_benefits` is greater than 100, it is multiplied by 1.1 and added to `v_total`; if `v_benefits` is greater than 50 but less than or equal to 100, it is multiplied by 1.05 and added to `v_total`; otherwise, the unmodified value of `v_benefits` is added to `v_total`. Finally, the function adds the values of `v_rent`, `v_parking`, and `v_tax directly to `v_total`. The function concludes by returning the computed value of `v_total`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_customer_debt_total(p_cross_ref_id NUMBER) RETURN NUMBER IS\n  v_total NUMBER := 0;\n  v_benefits NUMBER;\n  v_rent NUMBER;\n  v_parking NUMBER;\n  v_tax NUMBER;\nBEGIN\n  SELECT COALESCE(SUM(COUNCIL_TAX_ID), 0) INTO v_benefits FROM BENEFITS_OVERPAYMENTS WHERE CMI_CROSS_REF_ID = p_cross_ref_id;\n  SELECT COALESCE(SUM(COUNCIL_TAX_ID), 0) INTO v_rent FROM RENT_ARREARS WHERE CMI_CROSS_REF_ID = p_cross_ref_id;\n  SELECT COALESCE(SUM(COUNCIL_TAX_ID), 0) INTO v_parking FROM PARKING_FINES WHERE CMI_CROSS_REF_ID = p_cross_ref_id;\n  SELECT COALESCE(SUM(COUNCIL_TAX_ID), 0) INTO v_tax FROM COUNCIL_TAX WHERE CMI_CROSS_REF_ID = p_cross_ref_id;\n  IF v_benefits > 100 THEN\n    v_total := v_total + v_benefits * 1.1;\n  ELSIF v_benefits > 50 THEN\n    v_total := v_total + v_benefits * 1.05;\n  ELSE\n    v_total := v_total + v_benefits;\n  END IF;\n  v_total := v_total + v_rent + v_parking + v_tax;\n  RETURN v_total;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CUSTOMER_MASTER_INDEX",
      "CMI_CROSS_REFERENCES",
      "COUNCIL_TAX",
      "BENEFITS_OVERPAYMENTS",
      "RENT_ARREARS",
      "PARKING_FINES"
    ],
    "call_sqls": [
      "SELECT calculate_customer_debt_total(65) FROM DUAL",
      "SELECT calculate_customer_debt_total(41) FROM DUAL",
      "SELECT calculate_customer_debt_total(83) FROM DUAL",
      "SELECT calculate_customer_debt_total(4) FROM DUAL",
      "SELECT calculate_customer_debt_total(8) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named calculate_customer_debt_total that accepts a customer ID number and returns the total debt. Sum the COUNCIL_TAX_ID from the BENEFITS_OVERPAYMENTS, RENT_ARREARS, PARKING_FINES, and COUNCIL_TAX tables where CMI_CROSS_REF_ID matches the input. Apply a multiplier to the benefits sum based on its value (1.1 if >100, 1.05 if >50 and <=100, else 1). Return the total.",
    "natural_language": "Hey, I need you to write a PL/SQL function called calculate_customer_debt_total. It should take a customer's ID number and spit out their total debt. Here's how to figure it out: add up the COUNCIL_TAX_ID from a bunch of tablesBENEFITS_OVERPAYMENTS, RENT_ARREARS, PARKING_FINES, and COUNCIL_TAXbut only for entries where the CMI_CROSS_REF_ID matches the ID you're given. Oh, and for the benefits part, you gotta tweak it: if that sum is over 100, multiply it by 1.1; if it's more than 50 but not over 100, use 1.05; otherwise, just leave it as is. Then just add everything together and hand back the total.",
    "id": 92,
    "generated_ir": "Write an Oracle PL/SQL function named `calculate_customer_debt_total` that takes a single input parameter `p_cross_ref_id` of type `NUMBER`, representing a unique identifier for a customer, and returns a `NUMBER` value representing the total debt associated with the customer. The function begins by initializing a local variable `v_total` to 0, which will accumulate the total debt. It also declares four additional local variables: `v_benefits`, `v_rent`, `v_parking`, and `v_tax`, all of type `NUMBER`, to store intermediate sums of debts from different categories. The function performs four separate `SELECT` statements to retrieve the sum of the `COUNCIL_TAX_ID` column from four different tables (`BENEFITS_OVERPAYMENTS`, `RENT_ARREARS`, `PARKING_FINES`, and `COUNCIL_TAX`) where the `CMI_CROSS_REF_ID` column matches the input parameter `p_cross_ref_id`. Each `SELECT` statement uses the `COALESCE` function to ensure that a `NULL` result is replaced with 0, and the retrieved values are stored in the respective local variables (`v_benefits`, `v_rent`, `v_parking`, and `v_tax`). After retrieving the values, the function applies conditional logic to adjust the value of `v_benefits` based on its magnitude: if `v_benefits` is greater than 100, it is multiplied by 1.1 and added to `v_total`; if `v_benefits` is greater than 50 but less than or equal to 100, it is multiplied by 1.05 and added to `v_total`; otherwise, the unmodified value of `v_benefits` is added to `v_total`. Finally, the function adds the values of `v_rent`, `v_parking`, and `v_tax directly to `v_total`. The function concludes by returning the computed value of `v_total`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named GET_SERIES_STATUS that takes a single input parameter SERIES_ID of type NUMBER and returns a value of type VARCHAR2. The purpose of this function is to determine the status of a TV series based on the number of seasons and episodes it has, using data stored in the TV_SERIES table. The function begins by declaring three local variables: SEASON_COUNT and EPISODE_COUNT of type NUMBER, which will store the number of seasons and episodes for the specified series, and STATUS of type VARCHAR2(20), which will hold the resulting status to be returned. The function then executes a SELECT statement to retrieve the values of the NUM_OF_SEASONS and NUM_OF_EPISODES columns from the TV_SERIES table for the row where the SID column matches the input parameter SERIES_ID. These values are stored in the SEASON_COUNT and EPISODE_COUNT variables, respectively. Next, the function evaluates a series of conditional statements to determine the status of the series based on the retrieved values. If SEASON_COUNT is greater than 10, the STATUS variable is set to 'LONG_RUNNING'. If the first condition is not met but EPISODE_COUNT is greater than 100, the STATUS variable is set to 'EPISODIC'. If neither of the previous conditions is met but SEASON_COUNT equals 1 and EPISODE_COUNT is less than 10, the STATUS variable is set to 'MINISERIES'. If none of these conditions are satisfied, the STATUS variable is set to 'STANDARD'. Finally, the function returns the value of the STATUS variable, which represents the determined status of the TV series.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_SERIES_STATUS(SERIES_ID IN NUMBER) RETURN VARCHAR2 IS\n  SEASON_COUNT NUMBER;\n  EPISODE_COUNT NUMBER;\n  STATUS VARCHAR2(20);\nBEGIN\n  SELECT NUM_OF_SEASONS, NUM_OF_EPISODES\n  INTO SEASON_COUNT, EPISODE_COUNT\n  FROM TV_SERIES\n  WHERE SID = SERIES_ID;\n  IF SEASON_COUNT > 10 THEN\n    STATUS := 'LONG_RUNNING';\n  ELSIF EPISODE_COUNT > 100 THEN\n    STATUS := 'EPISODIC';\n  ELSIF SEASON_COUNT = 1 AND EPISODE_COUNT < 10 THEN\n    STATUS := 'MINISERIES';\n  ELSE\n    STATUS := 'STANDARD';\n  END IF;\n  RETURN STATUS;\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "MADE_BY",
      "COMPANY"
    ],
    "call_sqls": [
      "SELECT GET_SERIES_STATUS(101) FROM DUAL",
      "SELECT GET_SERIES_STATUS(205) FROM DUAL",
      "SELECT GET_SERIES_STATUS(312) FROM DUAL",
      "SELECT GET_SERIES_STATUS(418) FROM DUAL",
      "SELECT GET_SERIES_STATUS(529) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named GET_SERIES_STATUS that accepts a series ID number and returns a VARCHAR2 status. Retrieve the series' season and episode count from the TV_SERIES table. Return 'LONG_RUNNING' if seasons >10, 'EPISODIC' if episodes >100, 'MINISERIES' if seasons=1 and episodes<10, else 'STANDARD'.",
    "natural_language": "Develop a comprehensive PL/SQL function called GET_SERIES_STATUS, which is designed to meticulously accept a specific series ID number as its input parameter and subsequently provide a detailed VARCHAR2 status as its output. This function should first carefully retrieve the precise count of both seasons and episodes for the given series from the TV_SERIES table. Based on this retrieved data, it must then thoughtfully determine and return the appropriate status label: it should return 'LONG_RUNNING' if the total number of seasons is definitively greater than ten, 'EPISODIC' if the cumulative episode count substantially exceeds one hundred, 'MINISERIES' if the series consists of exactly one season and also has fewer than ten episodes, and in all other remaining cases, it should reliably return the default status of 'STANDARD'.",
    "id": 93,
    "generated_ir": "Write an Oracle PL/SQL function named GET_SERIES_STATUS that takes a single input parameter SERIES_ID of type NUMBER and returns a value of type VARCHAR2. The purpose of this function is to determine the status of a TV series based on the number of seasons and episodes it has, using data stored in the TV_SERIES table. The function begins by declaring three local variables: SEASON_COUNT and EPISODE_COUNT of type NUMBER, which will store the number of seasons and episodes for the specified series, and STATUS of type VARCHAR2(20), which will hold the resulting status to be returned. The function then executes a SELECT statement to retrieve the values of the NUM_OF_SEASONS and NUM_OF_EPISODES columns from the TV_SERIES table for the row where the SID column matches the input parameter SERIES_ID. These values are stored in the SEASON_COUNT and EPISODE_COUNT variables, respectively. Next, the function evaluates a series of conditional statements to determine the status of the series based on the retrieved values. If SEASON_COUNT is greater than 10, the STATUS variable is set to 'LONG_RUNNING'. If the first condition is not met but EPISODE_COUNT is greater than 100, the STATUS variable is set to 'EPISODIC'. If neither of the previous conditions is met but SEASON_COUNT equals 1 and EPISODE_COUNT is less than 10, the STATUS variable is set to 'MINISERIES'. If none of these conditions are satisfied, the STATUS variable is set to 'STANDARD'. Finally, the function returns the value of the STATUS variable, which represents the determined status of the TV series."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_college_leader_name that accepts a single input parameter p_college_id of type NUMBER, which represents the unique identifier of a college. The function is designed to return a value of type VARCHAR2, specifically the name of the leader associated with the college identified by the provided p_college_id. Within the function, declare a local variable v_leader_name of type VARCHAR2 with a maximum length of 255 characters to temporarily store the leader's name. Execute a SELECT statement to retrieve the LEADER_NAME from the COLLEGE table where the COLLEGE_ID column matches the value of the input parameter p_college_id. Assign the result of this query to the local variable v_leader_name. Finally, return the value stored in v_leader_name as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_college_leader_name(p_college_id NUMBER) RETURN VARCHAR2 IS\n    v_leader_name VARCHAR2(255);\nBEGIN\n    SELECT LEADER_NAME INTO v_leader_name FROM COLLEGE WHERE COLLEGE_ID = p_college_id;\n    RETURN v_leader_name;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "SELECT get_college_leader_name(1) FROM DUAL",
      "SELECT get_college_leader_name(2) FROM DUAL",
      "SELECT get_college_leader_name(3) FROM DUAL",
      "SELECT get_college_leader_name(COLLEGE_ID) FROM COLLEGE WHERE NAME = 'Saskatchewan School'",
      "SELECT get_college_leader_name(COLLEGE_ID) FROM COLLEGE WHERE COLLEGE_LOCATION = 'Ottawa'"
    ],
    "summary": "Create a PL/SQL function named get_college_leader_name that accepts a college_id number and returns the leader_name from the college table as a varchar2.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_college_leader_name? It should take a college_id (that's a number) and spit back the leader_name from the college table as a varchar2.",
    "id": 94,
    "generated_ir": "Write an Oracle PL/SQL function named get_college_leader_name that accepts one mandatory input parameter: p_college_id of type NUMBER, which represents the unique identifier for a college. The function returns a single string value of type VARCHAR2. The function's execution block begins by declaring a local variable v_leader_name of type VARCHAR2(255) to temporarily hold the result. It then performs a SELECT operation on the COLLEGE table, specifically retrieving the value from the LEADER_NAME column. This retrieval is conditioned by a WHERE clause that requires the COLLEGE_ID column in the table to exactly equal the input parameter p_college_id. The selected leader_name value is fetched directly into the local variable v_leader_name. Finally, the function concludes by using a RETURN statement to output the value stored in v_leader_name."
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes three input parameters: p_actor_id of type NUMBER, p_musical_id of type NUMBER, and p_category of type VARCHAR2, and returns a value of type VARCHAR2. The function is named get_actor_name and is designed to retrieve the name of an actor from the ACTOR table based on specific conditions. The function begins by declaring a local variable v_name of type VARCHAR2(255) to store the actor's name temporarily. Within the function body, a SELECT statement is executed to fetch the NAME column from the ACTOR table, which is aliased as 'a'. The ACTOR table is joined with the MUSICAL table, aliased as 'm', using the MUSICAL_ID column as the join condition. The SELECT statement includes a WHERE clause with three conditions: the ACTOR_ID column in the ACTOR table must match the value of the p_actor_id parameter, the MUSICAL_ID column in the MUSICAL table must match the value of the p_musical_id parameter, and the CATEGORY column in the MUSICAL table must match the value of the p_category parameter. If the SELECT statement successfully retrieves a matching row, the NAME value is assigned to the v_name variable. Finally, the function returns the value stored in v_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_actor_name(p_actor_id NUMBER, p_musical_id NUMBER, p_category VARCHAR2) RETURN VARCHAR2 IS\n  v_name VARCHAR2(255);\nBEGIN\n  SELECT a.NAME INTO v_name FROM ACTOR a JOIN MUSICAL m ON a.MUSICAL_ID = m.MUSICAL_ID WHERE a.ACTOR_ID = p_actor_id AND m.MUSICAL_ID = p_musical_id AND m.CATEGORY = p_category;\n  RETURN v_name;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "SELECT get_actor_name(1, 1, 'Best Book of a Musical') FROM DUAL",
      "SELECT get_actor_name(2, 2, 'Best Performance by a Leading ...') FROM DUAL",
      "SELECT get_actor_name(3, 1, 'Best Book of a Musical') FROM DUAL",
      "SELECT get_actor_name(1, 2, 'Best Performance by a Leading ...') FROM DUAL",
      "SELECT get_actor_name(2, 3, 'Best Direction of a Musical') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_actor_name that returns a VARCHAR2. It accepts an actor ID (NUMBER), a musical ID (NUMBER), and a category (VARCHAR2). Retrieve and return the actor's NAME from the ACTOR table by joining with the MUSICAL table where the actor ID, musical ID, and category all match the input parameters.",
    "natural_language": "Hey, can you whip up a PL/SQL function called get_actor_name that spits back a VARCHAR2? It needs to take in an actor ID (a NUMBER), a musical ID (also a NUMBER), and a category (a VARCHAR2). Basically, go grab the actor's NAME from the ACTOR table, but you gotta link it up with the MUSICAL table where the actor ID, musical ID, and category all line up with the numbers and text you're given.",
    "id": 95,
    "generated_ir": "Write an Oracle PL/SQL function that takes three input parameters: p_actor_id of type NUMBER, p_musical_id of type NUMBER, and p_category of type VARCHAR2, and returns a value of type VARCHAR2. The function is named get_actor_name and is designed to retrieve the name of an actor from the ACTOR table based on specific conditions. The function begins by declaring a local variable v_name of type VARCHAR2(255) to store the actor's name temporarily. Within the function body, a SELECT statement is executed to fetch the NAME column from the ACTOR table, which is aliased as 'a'. The ACTOR table is joined with the MUSICAL table, aliased as 'm', using the MUSICAL_ID column as the join condition. The SELECT statement includes a WHERE clause with three conditions: the ACTOR_ID column in the ACTOR table must match the value of the p_actor_id parameter, the MUSICAL_ID column in the MUSICAL table must match the value of the p_musical_id parameter, and the CATEGORY column in the MUSICAL table must match the value of the p_category parameter. If the SELECT statement successfully retrieves a matching row, the NAME value is assigned to the v_name variable. Finally, the function returns the value stored in v_name."
  },
  {
    "ir": "Write an Oracle PL/SQL function named fn_get_mill_count_by_type that accepts a single input parameter p_type of data type VARCHAR2 and returns a value of data type NUMBER; within the function, declare a local variable v_count of type NUMBER, then execute a SELECT statement that queries the MILL table to count all rows where the value in the column named TYPE is exactly equal to the value provided in the input parameter p_type, storing the result of this count operation into the local variable v_count, and finally return the value stored in v_count as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION fn_get_mill_count_by_type(p_type VARCHAR2) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM MILL WHERE TYPE = p_type;\n  RETURN v_count;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "SELECT fn_get_mill_count_by_type('Windmill') FROM DUAL",
      "SELECT fn_get_mill_count_by_type('Watermill') FROM DUAL",
      "SELECT fn_get_mill_count_by_type('Tide Mill') FROM DUAL",
      "SELECT fn_get_mill_count_by_type('Post Mill') FROM DUAL",
      "SELECT fn_get_mill_count_by_type('Smock Mill') FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named fn_get_mill_count_by_type that accepts a VARCHAR2 type and returns the count of mills with that specific type as a NUMBER.",
    "natural_language": "Make function fn_get_mill_count_by_type returning NUMBER, taking VARCHAR2 input for mill type.",
    "id": 96,
    "generated_ir": "Write an Oracle PL/SQL function named fn_get_mill_count_by_type that accepts a single input parameter, p_mill_type, of data type VARCHAR2, which represents the type of mill to be counted. The function is designed to return a single value of data type NUMBER, which will represent the total count of mills matching the specified type.\n\nInside the function's executable block, a local variable named v_mill_count of data type NUMBER is declared to temporarily store the result of a counting operation.\n\nThe core operation involves a SELECT statement that queries the MILL table. The SELECT statement uses the COUNT(*) aggregate function to calculate the total number of rows in the MILL table where the TYPE column exactly matches the value provided in the input parameter p_mill_type. This count operation is filtered by a WHERE clause: `MILL.TYPE = p_mill_type`. The result of this COUNT(*) operation is then stored into the local variable v_mill_count.\n\nFinally, the function returns the value stored in the v_mill_count variable, which represents the total number of mills of the specified type found in the MILL table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_student_count_by_classroom that accepts a single input parameter, p_classroom, of type NUMBER, which represents the classroom identifier. The function is designed to return a value of type NUMBER, which indicates the total count of students associated with the specified classroom. Within the function, a local variable v_count of type NUMBER is declared to store the result of a query operation. The function begins by executing a SELECT statement that counts all rows in the LIST table where the CLASSROOM column matches the value provided in the p_classroom parameter. The result of this COUNT operation is stored into the v_count variable. Finally, the function returns the value of v_count, which represents the number of students in the specified classroom.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_count_by_classroom(p_classroom NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM LIST WHERE CLASSROOM = p_classroom;\n  RETURN v_count;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "SELECT get_student_count_by_classroom(101) FROM dual",
      "SELECT get_student_count_by_classroom(202) FROM dual",
      "SELECT get_student_count_by_classroom(303) FROM dual",
      "SELECT get_student_count_by_classroom(404) FROM dual",
      "SELECT get_student_count_by_classroom(505) FROM dual"
    ],
    "summary": "Create a PL/SQL function named get_student_count_by_classroom that takes a classroom ID (NUMBER) and returns a NUMBER. It counts and returns the number of students in the LIST table for the specified classroom.",
    "natural_language": "Please construct a PL/SQL function designated as 'get_student_count_by_classroom'. This function shall accept a single input parameter of the NUMBER data type, representing a classroom identifier. Its purpose is to ascertain and return, as a NUMBER, the total count of student records associated with the specified classroom within the LIST table.",
    "id": 97,
    "generated_ir": "Write an Oracle PL/SQL function named get_student_count_by_classroom that accepts a single input parameter, p_classroom, of type NUMBER, which represents the classroom identifier. The function is designed to return a value of type NUMBER, which indicates the total count of students associated with the specified classroom. Within the function, a local variable v_count of type NUMBER is declared to store the result of a query operation. The function begins by executing a SELECT statement that counts all rows in the LIST table where the CLASSROOM column matches the value provided in the p_classroom parameter. The result of this COUNT operation is stored into the v_count variable. Finally, the function returns the value of v_count, which represents the number of students in the specified classroom."
  },
  {
    "ir": "Write an Oracle PL/SQL function that takes two input parameters, para_company_id of type NUMBER and para_rank of type NUMBER, and returns a value of type NUMBER. The function is named get_company_asset_ratio and is designed to calculate and return the ratio of the ASSETS_BILLION column to the SALES_BILLION column from the COMPANY table for a specific company identified by the para_company_id parameter and a specific rank identified by the para_rank parameter. Inside the function, a local variable v_ratio of type NUMBER is declared to store the calculated ratio. The function performs a SELECT statement to retrieve the ASSETS_BILLION and SALES_BILLION values from the COMPANY table, where the COMPANY_ID column matches the value of para_company_id and the RANK column matches the value of para_rank. The retrieved values are used to compute the ratio by dividing ASSETS_BILLION by SALES_BILLION, and the result is rounded to three decimal places using the ROUND function. The computed ratio is then assigned to the v_ratio variable. Finally, the function returns the value stored in v_ratio as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_company_asset_ratio(para_company_id NUMBER, para_rank NUMBER) RETURN NUMBER IS\n  v_ratio NUMBER;\nBEGIN\n  SELECT ROUND(ASSETS_BILLION / SALES_BILLION, 3) INTO v_ratio FROM COMPANY WHERE COMPANY_ID = para_company_id AND RANK = para_rank;\n  RETURN v_ratio;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "SELECT get_company_asset_ratio(1, 1) FROM DUAL",
      "SELECT get_company_asset_ratio(2, 3) FROM DUAL",
      "SELECT get_company_asset_ratio(3, 4) FROM DUAL",
      "SELECT get_company_asset_ratio(1, 3) FROM DUAL",
      "SELECT get_company_asset_ratio(2, 1) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named get_company_asset_ratio that accepts a company_id and a rank as NUMBER parameters. It returns the ratio of ASSETS_BILLION to SALES_BILLION from the COMPANY table for the matching row, rounded to three decimal places.",
    "natural_language": "Write a PL/SQL function called get_company_asset_ratio that takes a company_id and a rank as NUMBER inputs. Return the ASSETS_BILLION to SALES_BILLION ratio, rounded to three decimal places, for the corresponding company in the COMPANY table.",
    "id": 98,
    "generated_ir": "Write an Oracle PL/SQL function that takes two input parameters, para_company_id of type NUMBER and para_rank of type NUMBER, and returns a value of type NUMBER. The function is named get_company_asset_ratio and is designed to calculate and return the ratio of the ASSETS_BILLION column to the SALES_BILLION column from the COMPANY table for a specific company identified by the para_company_id parameter and a specific rank identified by the para_rank parameter. Inside the function, a local variable v_ratio of type NUMBER is declared to store the calculated ratio. The function performs a SELECT statement to retrieve the ASSETS_BILLION and SALES_BILLION values from the COMPANY table, where the COMPANY_ID column matches the value of para_company_id and the RANK column matches the value of para_rank. The retrieved values are used to compute the ratio by dividing ASSETS_BILLION by SALES_BILLION, and the result is rounded to three decimal places using the ROUND function. The computed ratio is then assigned to the v_ratio variable. Finally, the function returns the value stored in v_ratio as the output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_total_problems` that is designed to return a single numeric value. This function declares a local variable named `v_total` of the `NUMBER` data type to temporarily store the result of a database query. The core operation performed by this function is a `SELECT` statement that calculates the total count of all rows present in the table named `PROBLEMS`. Specifically, it uses the aggregate function `COUNT(*)` to count every row in the `PROBLEMS` table, irrespective of the values in its columns. The result of this `COUNT(*)` operation is then immediately stored into the previously declared local variable `v_total`. Finally, the function concludes its execution by returning the numeric value currently held by the `v_total` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_problems RETURN NUMBER IS\n    v_total NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total FROM PROBLEMS;\n    RETURN v_total;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "SELECT get_total_problems FROM DUAL",
      "SELECT get_total_problems() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_total_problems;\n  DBMS_OUTPUT.PUT_LINE('Total problems: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total problems: ' || get_total_problems);\nEND;",
      "SELECT get_total_problems AS total_count FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named `get_total_problems` that takes no parameters and returns the total count of all rows (NUMBER) in the PROBLEMS table.",
    "natural_language": "Develop a comprehensive PL/SQL function, which should be named `get_total_problems`, that accepts no input parameters whatsoever and is designed to meticulously calculate and return, as a NUMBER data type, the complete and total count of every single row contained within the PROBLEMS table.",
    "id": 99,
    "generated_ir": "Write an Oracle PL/SQL function named get_total_problems that accepts no input parameters. The function returns a NUMBER data type. Within the function, declare a local variable v_total_count of type NUMBER to store the result of the count operation. The function performs a SELECT operation to count all rows from the PROBLEMS table using the COUNT(*) aggregate function. The result of this count is stored in the v_total_count variable. The function then returns the value stored in v_total_count."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `has_english_language` that accepts a single input parameter, `p_country_id`, which is of data type `NUMBER` and represents the unique identifier for a country. This function is designed to determine if the specified country has 'English' listed as one of its official languages. The function declares a local variable `v_exists` of data type `NUMBER` to store the result of a database query. The core operation of the function involves executing a `SELECT` statement to count the number of records. This `SELECT` statement performs an `INNER JOIN` between two tables: `OFFICIAL_LANGUAGES` (aliased as `ol`) and `LANGUAGES` (aliased as `l`). The join condition `ol.LANGUAGE_ID = l.ID` links records from `OFFICIAL_LANGUAGES` to `LANGUAGES` based on their respective language identifiers. The `WHERE` clause of the `SELECT` statement applies two conditions: `ol.COUNTRY_ID = p_country_id` filters the results to include only official languages associated with the country identified by the input parameter `p_country_id`, and `l.NAME = 'English'` further restricts the results to only those languages whose name is exactly 'English'. The `COUNT(*)` aggregate function counts the number of rows that satisfy both the join condition and the `WHERE` clause conditions. The result of this count is then stored into the local variable `v_exists`. Finally, the function returns the value stored in `v_exists`, which will be `1` if 'English' is an official language for the given country, or `0` if it is not.",
    "plsql": "CREATE OR REPLACE FUNCTION has_english_language(p_country_id NUMBER) RETURN NUMBER IS\n  v_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_exists FROM OFFICIAL_LANGUAGES ol JOIN LANGUAGES l ON ol.LANGUAGE_ID = l.ID WHERE ol.COUNTRY_ID = p_country_id AND l.NAME = 'English';\n  RETURN v_exists;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "SELECT has_english_language(1) FROM DUAL",
      "SELECT has_english_language(2) FROM DUAL",
      "SELECT has_english_language(3) FROM DUAL",
      "SELECT has_english_language(999) FROM DUAL",
      "SELECT has_english_language(0) FROM DUAL"
    ],
    "summary": "Create a PL/SQL function named has_english_language that accepts a country ID and returns 1 if 'English' is an official language for that country (by checking the OFFICIAL_LANGUAGES and LANGUAGES tables), otherwise returns 0.",
    "natural_language": "Construct a PL/SQL function, which should be named has_english_language, that takes as its input a specific country ID. This function must then perform a detailed check by querying both the OFFICIAL_LANGUAGES and LANGUAGES tables to determine whether 'English' is formally registered as an official language for the given nation. If the meticulous verification confirms this fact, the function should thoughtfully return a value of 1; otherwise, it must definitively return a value of 0.",
    "id": 100,
    "generated_ir": "Write an Oracle PL/SQL function named has_english_language that accepts one input parameter: a country ID of type NUMBER. The function returns a NUMBER value, specifically 1 if English is an official language for the given country, or 0 otherwise.\n\nThe function begins by declaring a local variable v_language_count of type NUMBER to store the result of a count operation. The core logic involves a SELECT statement that performs a COUNT operation on the OFFICIAL_LANGUAGES table, aliased as ol. This SELECT statement joins the OFFICIAL_LANGUAGES table with the LANGUAGES table, aliased as l, using the condition ol.language_id = l.id. The WHERE clause of this SELECT statement contains two conditions connected by the AND operator. The first condition, ol.country_id = input_country_id, filters the records to only include those where the COUNTRY_ID column in the OFFICIAL_LANGUAGES table matches the input country ID parameter. The second condition, l.name = 'English', filters the records to only include those where the NAME column in the LANGUAGES table exactly matches the string 'English'. The result of this COUNT operation, which represents the number of official language records for the specified country that are specifically for the English language, is then assigned to the local variable v_language_count.\n\nFollowing the SELECT operation, the function uses an IF-THEN-ELSE control structure to determine the return value. The IF condition checks whether the value stored in v_language_count is greater than 0. If this condition evaluates to TRUE, indicating that at least one record was found confirming English as an official language for the given country, the function returns the value 1. If the condition evaluates to FALSE, meaning the count is 0 and no such record exists, the function proceeds to the ELSE branch and returns the value 0."
  }
]