[
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_validate_album_year` that validates the `Year` column of the new row by checking if its value is greater than the current year obtained from `EXTRACT(YEAR FROM CURRENT_DATE)`; if true, it returns NULL to cancel the operation, otherwise it returns the NEW row.\nSecond, define the trigger `validate_album_year` on table `Albums` that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_album_year() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"Year\" > EXTRACT(YEAR FROM CURRENT_DATE) THEN\n        RETURN NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_album_year\nBEFORE INSERT OR UPDATE ON \"Albums\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_album_year();",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Albums\" (\"Title\", \"Year\", \"Label\", \"Type\") VALUES ('Valid Album', 2023, 'Test Label', 'Studio');",
      "INSERT INTO \"Albums\" (\"Title\", \"Year\", \"Label\", \"Type\") VALUES ('Future Album', 2050, 'Future Label', 'Studio');",
      "UPDATE \"Albums\" SET \"Year\" = 2022 WHERE \"Title\" = 'Valid Album';",
      "UPDATE \"Albums\" SET \"Year\" = 2030 WHERE \"Title\" = 'Valid Album';",
      "INSERT INTO \"Albums\" (\"Title\", \"Year\", \"Label\", \"Type\") VALUES ('Current Year Album', EXTRACT(YEAR FROM CURRENT_DATE), 'Current Label', 'Live');"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function on the Albums table. For each row, validate the Year column. If the new Year is greater than the current year, return NULL to cancel the operation. Otherwise, return the NEW record to proceed.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE trigger function for the Albums table that validates the Year column, cancels the operation by returning NULL if the new Year is greater than the current year, and otherwise proceeds by returning the NEW record?",
    "id": 1,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_validate_album_year` that validates the `Year` column of the new row by checking if its value is greater than the current year obtained from `EXTRACT(YEAR FROM CURRENT_DATE)`; if true, it returns NULL to cancel the operation, otherwise it returns the NEW row.\nSecond, define the trigger `validate_album_year` on table `Albums` that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named trg_validate_album_year that returns a trigger, which is then bound to the \"Albums\" table via a BEFORE INSERT OR UPDATE trigger named validate_album_year, executing for each row. The function's logic is to validate the \"Year\" column value of the new row (referenced as NEW) being inserted or updated. It performs a conditional check using an IF statement: if the value in NEW.\"Year\" is greater than the result of the EXTRACT(YEAR FROM CURRENT_DATE) function call, which retrieves the current calendar year as an integer, then the function returns NULL, effectively canceling the insert or update operation for that specific row. If the condition is not met, meaning the \"Year\" value is less than or equal to the current year, the function proceeds to return the NEW row record, allowing the insert or update operation to proceed normally with the original data."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `remove_teacher_assignment` that deletes rows from the `teachers` table where the `\"Classroom\"` column equals the `OLD.\"Classroom\"` value from the deleted row and returns `OLD`.\nSecond, define the trigger `remove_teacher_on_list_delete` on table `list` that fires AFTER DELETE and executes the function `remove_teacher_assignment`.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_teacher_assignment() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM teachers WHERE \"Classroom\" = OLD.\"Classroom\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER remove_teacher_on_list_delete\nAFTER DELETE ON list\nFOR EACH ROW EXECUTE FUNCTION remove_teacher_assignment();",
    "database_name": "student_1",
    "tables": [
      "list",
      "teachers"
    ],
    "call_sqls": [
      "DELETE FROM list WHERE \"Classroom\" = 101;",
      "DELETE FROM list WHERE \"Classroom\" = 112;",
      "DELETE FROM list WHERE \"Classroom\" = 107;",
      "DELETE FROM list WHERE \"Classroom\" = 101 AND \"Grade\" = 2;",
      "DELETE FROM list WHERE \"Classroom\" = 112 AND \"LastName\" = 'KRISTENSEN';"
    ],
    "summary": "Create a trigger function named `remove_teacher_assignment` that, after a row is deleted from the `list` table, deletes all rows from the `teachers` table where the `Classroom` matches the deleted row's `Classroom` value. Also, create an `AFTER DELETE FOR EACH ROW` trigger named `remove_teacher_on_list_delete` on the `list` table to execute this function.",
    "natural_language": "Set up a trigger function called `remove_teacher_assignment` so that, after something gets taken out of the `list` table, it also clears out any entries in the `teachers` table that are kind of related to that same `Classroom`. Then, make a trigger named `remove_teacher_on_list_delete` on the `list` table to run that function whenever a deletion happens.",
    "id": 2,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named remove_teacher_assignment in the student_1 database. This function is designed to be executed automatically after a DELETE operation on the list table for each deleted row. The function does not declare any local variables. It performs a DELETE operation on the teachers table, targeting all rows where the Classroom column value matches the Classroom value from the deleted row in the list table (referenced as OLD.Classroom). This operation effectively removes any teacher assignments associated with the same classroom as the deleted student record. The function then returns the OLD row record to the trigger mechanism. Second, define a trigger named remove_teacher_on_list_delete on the list table. This trigger is configured to fire AFTER DELETE on the list table for each row, and it executes the remove_teacher_assignment function.",
    "original_ir": "Write a PL/pgSQL trigger function named `remove_teacher_assignment` that is designed to be executed in response to a data manipulation event. This function does not accept any explicit input parameters in its definition, but it operates within the context of a trigger, meaning it implicitly receives special variables such as `OLD` and `NEW` which represent the row before and after the triggering event, respectively. The function is declared to return a `TRIGGER` type, which is standard for PL/pgSQL trigger functions. Upon execution, the function performs a `DELETE` operation on the `teachers` table. The rows to be deleted from the `teachers` table are identified by a `WHERE` clause that specifies a condition: the value in the column named `\"Classroom\"` within the `teachers` table must be equal to the value of the `\"Classroom\"` column from the `OLD` record. The `OLD` record refers to the row that was deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function returns the `OLD` record.\n\nAdditionally, define a trigger named `remove_teacher_on_list_delete`. This trigger is configured to activate `AFTER DELETE` operations on the `list` table. It is specified to execute `FOR EACH ROW`, meaning that the trigger function will be invoked once for every row that is deleted from the `list` table. When activated, this trigger executes the previously defined function, `remove_teacher_assignment()`. Therefore, whenever a row is deleted from the `list` table, the `remove_teacher_assignment` function will be called, and it will delete corresponding records from the `teachers` table where the `\"Classroom\"` column matches the `\"Classroom\"` value of the row that was just deleted from the `list` table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_coaster_park that unconditionally assigns the literal string value 'Updated Park' to the NEW record's column named Park and then returns the modified NEW record.\nSecond, define the trigger roller_coaster_park_update_trigger on table roller_coaster that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_coaster_park() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.\"Park\" = 'Updated Park';\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER roller_coaster_park_update_trigger\nBEFORE UPDATE ON \"roller_coaster\"\nFOR EACH ROW EXECUTE FUNCTION update_coaster_park();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "UPDATE \"roller_coaster\" SET \"Name\" = 'Boardwalk Bullet' WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE \"roller_coaster\" SET \"Name\" = 'Dauling Dragon' WHERE \"Roller_Coaster_ID\" = 2;",
      "UPDATE \"roller_coaster\" SET \"Name\" = 'Hades 360' WHERE \"Roller_Coaster_ID\" = 3;",
      "UPDATE \"roller_coaster\" SET \"Length\" = 3236.0 WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE \"roller_coaster\" SET \"Height\" = 105.0 WHERE \"Roller_Coaster_ID\" = 2;"
    ],
    "summary": "Create a trigger function named update_coaster_park that returns TRIGGER. Before updating a row in the roller_coaster table, set the NEW.\"Park\" column to the string 'Updated Park'. Return the NEW record. Create a BEFORE UPDATE trigger named roller_coaster_park_update_trigger on the roller_coaster table for each row to execute this function.",
    "natural_language": "Construct a trigger function, which should be named update_coaster_park, that is explicitly defined to return a value of type TRIGGER. This function must be designed so that, just prior to the actual modification of any existing row within the roller_coaster table, it will meticulously assign the value 'Updated Park' to the NEW.\"Park\" column. The function must then carefully return the fully prepared NEW record. Subsequently, you must establish a BEFORE UPDATE trigger, to be called roller_coaster_park_update_trigger, which will be securely attached to the roller_coaster table and configured to faithfully execute this precise function for every single row that is updated.",
    "id": 3,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_coaster_park that unconditionally assigns the literal string value 'Updated Park' to the NEW record's column named Park and then returns the modified NEW record.\nSecond, define the trigger roller_coaster_park_update_trigger on table roller_coaster that fires BEFORE UPDATE and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_coaster_park that returns a trigger, which is executed by a trigger named roller_coaster_park_update_trigger defined to fire BEFORE UPDATE on the table named roller_coaster for each row being updated, where the function's logic unconditionally assigns the literal string value 'Updated Park' to the NEW record's column named Park, and then returns the modified NEW record to the calling trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_rounds_on_member_delete` that deletes rows from the `round` table where its `\"Member_ID\"` column matches the `OLD.\"Member_ID\"` from the deleted `member` table row and then returns `OLD`.\nSecond, define the trigger `trg_delete_rounds_on_member_delete` on table `member` that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_rounds_on_member_delete() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM round WHERE \"Member_ID\" = OLD.\"Member_ID\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_rounds_on_member_delete\nAFTER DELETE ON member\nFOR EACH ROW EXECUTE FUNCTION delete_rounds_on_member_delete();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "DELETE FROM member WHERE \"Member_ID\" = 1;",
      "DELETE FROM member WHERE \"Member_ID\" = 2;",
      "DELETE FROM member WHERE \"Member_ID\" = 3;",
      "DELETE FROM member WHERE \"Name\" = 'Jack Nicklaus';",
      "DELETE FROM member WHERE \"Country\" = 'Canada';"
    ],
    "summary": "Create a trigger function named delete_rounds_on_member_delete that fires after a row is deleted from the member table. The function deletes all rows from the round table where the Member_ID matches the deleted member's ID. Return the OLD record.",
    "natural_language": "How can I create a trigger function named delete_rounds_on_member_delete that, after a row is deleted from the member table, deletes all corresponding rows from the round table where the Member_ID matches the deleted member's ID and returns the OLD record?",
    "id": 4,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named delete_rounds_on_member_delete. This function is designed to be used as a trigger function, does not take any parameters, and returns a trigger type. Within the function, it performs a DELETE operation on the round table. The deletion targets all rows in the round table where the Member_ID column matches the Member_ID value from the OLD record, which represents the row that has just been deleted from the member table. This ensures that any rounds associated with the deleted member are also removed. After executing the deletion, the function returns the OLD record, allowing the trigger to complete the deletion operation. Second, define the trigger named trg_delete_rounds_on_member_delete on the member table. This trigger is set to fire after any DELETE operation on the member table. It is defined to execute the delete_rounds_on_member_delete function for each row that is deleted, ensuring that corresponding rows in the round table are automatically cleaned up whenever a member is removed from the member table.",
    "original_ir": "Write a PLpgSQL function named delete_rounds_on_member_delete that is designed to be executed as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to be invoked after a DELETE operation on the member table. The function performs a DELETE operation on the round table, specifically targeting rows where the Member_ID column matches the Member_ID value of the row that was just deleted from the member table. The OLD keyword is used to reference the values of the deleted row from the member table, allowing the function to access the Member_ID of the deleted member. After executing the DELETE operation on the round table, the function returns the OLD record, which represents the state of the deleted row from the member table before the deletion occurred. This function is associated with a trigger named trg_delete_rounds_on_member_delete, which is defined to fire after a row is deleted from the member table. The trigger is set to execute the delete_rounds_on_member_delete function for each row that is deleted, ensuring that all rounds associated with the deleted member are removed from the round table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_employee_deletion` that checks if a row exists in the `\"Order_Deliveries\"` table where the `driver_employee_id` column matches the `OLD.employee_id`; if a match is found, the function returns NULL to abort the operation, otherwise it returns OLD.\nSecond, define the trigger `prevent_employee_delete_trigger` on table `\"Employees\"` that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_employee_deletion() RETURNS TRIGGER AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM \"Order_Deliveries\" WHERE driver_employee_id = OLD.employee_id) THEN\n        RETURN NULL;\n    END IF;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER prevent_employee_delete_trigger\nBEFORE DELETE ON \"Employees\"\nFOR EACH ROW\nEXECUTE FUNCTION validate_employee_deletion();",
    "database_name": "customer_deliveries",
    "tables": [
      "Actual_Orders",
      "Order_Deliveries",
      "Employees",
      "Delivery_Route_Locations",
      "Addresses"
    ],
    "call_sqls": [
      "DELETE FROM \"Employees\" WHERE employee_id = 1;",
      "DELETE FROM \"Employees\" WHERE employee_id = 2;",
      "DELETE FROM \"Employees\" WHERE employee_id = 3;",
      "DELETE FROM \"Employees\" WHERE employee_id = 4;",
      "DELETE FROM \"Employees\" WHERE employee_id = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger on the Employees table. For each row, prevent deletion if the employee's ID exists in the Order_Deliveries table as a driver_employee_id.",
    "natural_language": "Hey, set up a trigger that kicks in before anyone tries to delete a record from the Employees table. Basically, for each employee you're trying to axe, check if their ID is hanging out in the Order_Deliveries table as a driver. If it is, block that deletionâ€”don't let it go through.",
    "id": 5,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named `validate_employee_deletion` in the `customer_deliveries` database. This function is designed to be executed `BEFORE DELETE` on the `Employees` table, `FOR EACH ROW`. The function returns a trigger. It declares no explicit variables. The function's purpose is to prevent the deletion of an employee if that employee is currently assigned as a driver in any delivery record. To implement this, the function performs a `SELECT` operation on the `Order_Deliveries` table. It uses a `SELECT INTO` statement to check for the existence of at least one row where the `driver_employee_id` column equals the `employee_id` of the row being deleted (accessible via the `OLD.employee_id` record). The `SELECT` statement uses the `COUNT(*)` aggregate function to count such matching rows. If the count is greater than `0`, indicating that the employee is referenced as a driver in the `Order_Deliveries` table, the function raises an exception. The exception is of type `SQLSTATE '23000'`, which corresponds to an integrity constraint violation, with a custom error message stating that deletion is not allowed because the employee is assigned to deliveries. This exception prevents the `DELETE` operation from proceeding. If the count is `0`, meaning no matching records are found, the function does nothing and allows the `DELETE` to proceed by implicitly returning `NULL` (as a `BEFORE` trigger, returning `NULL` cancels the operation for the current row, but in this logic flow, the function completes without returning a value explicitly, allowing the operation). The function uses `PERFORM` to execute the `SELECT` statement and capture the result into a temporary variable for the conditional check. Second, define the trigger itself. The trigger is unnamed in the description but should be logically named, for example, `trg_prevent_employee_deletion_if_driver`. It is defined to fire `BEFORE DELETE` on the `Employees` table, `FOR EACH ROW`, and it executes the `validate_employee_deletion()` function. The trigger ensures that any attempt to delete an employee who is listed as a driver in the `Order_Deliveries` table is blocked, maintaining referential integrity by preventing orphaned records in `Order_Deliveries`.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `validate_employee_deletion` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the row before and after the triggering event, respectively. The function's purpose is to determine whether a `DELETE` operation on an employee record should be allowed to proceed. Inside the function, a conditional statement (`IF EXISTS`) is evaluated. This condition performs a `SELECT` operation to check for the existence of any records in the `\"Order_Deliveries\"` table. The `SELECT` statement specifically looks for rows where the `driver_employee_id` column matches the `employee_id` from the `OLD` record (the employee record being considered for deletion). If at least one such record is found in `\"Order_Deliveries\"`, indicating that the employee slated for deletion is currently associated as a driver with existing order deliveries, the function immediately returns `NULL`. A `NULL` return value from a `BEFORE` trigger in PostgreSQL signifies that the triggering operation (in this case, the `DELETE`) should be aborted, and the row should not be deleted. If, however, the `SELECT` operation finds no matching records in `\"Order_Deliveries\"`, meaning the employee is not associated with any existing order deliveries, the conditional statement evaluates to false. In this scenario, the function proceeds to return the `OLD` record. A non-`NULL` return value (like `OLD` or `NEW`) from a `BEFORE` trigger indicates that the triggering operation should be allowed to proceed with the row as returned.\n\nThis function is then associated with a trigger named `prevent_employee_delete_trigger`. This trigger is configured to activate `BEFORE DELETE` operations on the `\"Employees\"` table. It is set to execute `FOR EACH ROW`, meaning the trigger function `validate_employee_deletion()` will be invoked once for every row that is targeted for deletion. The trigger's action is to `EXECUTE FUNCTION validate_employee_deletion()`. Consequently, whenever an attempt is made to delete a row from the `\"Employees\"` table, this trigger will intercept the operation, call the `validate_employee_deletion()` function, and based on the function's return value (either `NULL` to prevent deletion or `OLD` to allow deletion), it will either abort or permit the deletion of that specific employee record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_dog_age_on_arrival` that updates the `age` column in the `\"Dogs\"` table by calculating the difference in years between the `\"date_arrived\"` and `\"date_of_birth\"` columns of the newly inserted row, using the `EXTRACT(YEAR FROM AGE(...))` function, and performs the update where the `\"dog_id\"` matches the `NEW.\"dog_id\"`.\nSecond, define the trigger `trg_dog_age_arrival` on table `\"Dogs\"` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_dog_age_on_arrival() RETURNS TRIGGER AS $$\nBEGIN\nUPDATE \"Dogs\" SET \"age\" = EXTRACT(YEAR FROM AGE(NEW.\"date_arrived\", NEW.\"date_of_birth\")) WHERE \"dog_id\" = NEW.\"dog_id\";\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_dog_age_arrival\nAFTER INSERT ON \"Dogs\"\nFOR EACH ROW EXECUTE FUNCTION update_dog_age_on_arrival();",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1001, 5, '0', 'HUS', 'MED', 'Buddy', NULL, '2020-05-15 10:00:00+08:00', '1', '12.5', '2024-03-20 14:30:00+08:00');",
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1002, 8, '1', 'BUL', 'SML', 'Daisy', NULL, '2019-11-03 08:15:00+08:00', '0', '8.2', '2024-03-21 09:45:00+08:00');",
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1003, 12, '0', 'ESK', 'LGE', 'Max', NULL, '2018-07-22 16:20:00+08:00', '1', '18.7', '2024-03-22 11:20:00+08:00');",
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1004, 3, '0', 'HUS', 'MED', 'Luna', NULL, '2021-02-28 12:10:00+08:00', '0', '11.8', '2024-03-23 13:15:00+08:00');",
      "INSERT INTO \"Dogs\" (\"dog_id\", \"owner_id\", \"abandoned_yn\", \"breed_code\", \"size_code\", \"name\", \"age\", \"date_of_birth\", \"gender\", \"weight\", \"date_arrived\") VALUES (1005, 1, '1', 'BUL', 'SML', 'Rocky', NULL, '2017-12-10 09:45:00+08:00', '1', '9.5', '2024-03-24 10:00:00+08:00');"
    ],
    "summary": "Create an AFTER INSERT trigger function for the \"Dogs\" table. The function calculates a dog's age by extracting the year difference between its arrival date and birth date, then updates the \"age\" column for the matching dog_id.",
    "natural_language": "Create AFTER INSERT trigger for Dogs. It computes age from arrival and birth years, updating the age column for that dog.",
    "id": 6,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_dog_age_on_arrival` that updates the `age` column in the `\"Dogs\"` table by calculating the difference in years between the `\"date_arrived\"` and `\"date_of_birth\"` columns of the newly inserted row, using the `EXTRACT(YEAR FROM AGE(...))` function, and performs the update where the `\"dog_id\"` matches the `NEW.\"dog_id\"`.\nSecond, define the trigger `trg_dog_age_arrival` on table `\"Dogs\"` that fires `AFTER` `INSERT` and executes the function.",
    "original_ir": "Write a PLpgSQL function that updates the age of a dog in the \"Dogs\" table by calculating the difference in years between the dog's date of arrival and date of birth, using the EXTRACT function to determine the year component from the AGE function, and sets this calculated age in the \"age\" column for the row where the \"dog_id\" matches the \"dog_id\" of the newly inserted row. This function is triggered by an AFTER INSERT operation on the \"Dogs\" table, ensuring that each time a new row is inserted into the \"Dogs\" table, the function is executed for that specific row, updating the age based on the newly inserted data. The trigger is named trg_dog_age_arrival and is defined to execute the update_dog_age_on_arrival function for each new row inserted into the \"Dogs\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function monitor_product_updates that deletes all records from the \"Order_Items\" table where the product_id matches the OLD.product_id of the row being deleted from the \"Products\" table and then returns the OLD record to allow the deletion to proceed.\nSecond, define the trigger trigger_monitor_product_updates on table \"Products\" that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION monitor_product_updates() RETURNS TRIGGER AS $$\nBEGIN\n  -- First, delete all related records in Order_Items\n  DELETE FROM \"Order_Items\"\n  WHERE product_id = OLD.product_id;\n\n  -- Then, allow the original DELETE on Products to proceed\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_monitor_product_updates\nBEFORE DELETE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION monitor_product_updates();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products"
    ],
    "call_sqls": [
      "DELETE FROM \"Products\" WHERE product_id = 1;",
      "DELETE FROM \"Products\" WHERE product_id = 2;",
      "DELETE FROM \"Products\" WHERE product_id = 3;",
      "DELETE FROM \"Products\" WHERE product_id = 13;",
      "DELETE FROM \"Products\" WHERE product_id = 10;"
    ],
    "summary": "Create a BEFORE DELETE FOR EACH ROW trigger function on the \"Products\" table. The function must first delete all rows from the \"Order_Items\" table where the product_id matches the OLD.product_id from the \"Products\" table. Then, return OLD to allow the original product deletion to proceed.",
    "natural_language": "Set up a trigger on the Products table that runs before any row is removed. It should handle cleaning up related order items for that product, then let the deletion go through.",
    "id": 7,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named `monitor_product_updates` that is designed to be executed as a trigger. This function takes no explicit parameters but operates on the `OLD` record, which represents the row being deleted from the `Products` table. The function performs a `DELETE` operation on the `Order_Items` table. The rows to be deleted are identified by the condition that the `product_id` column in `Order_Items` must match the `product_id` value from the `OLD` record of the `Products` table. This ensures that all order items associated with the product being deleted are removed first, maintaining referential integrity by cleaning up dependent records. After executing the `DELETE` operation, the function returns the `OLD` record, allowing the original `DELETE` operation on the `Products` table to proceed.\n\nSecond, define the trigger `trg_monitor_product_updates` on the `Products` table. This trigger is configured to execute `BEFORE DELETE` operations on the `Products` table. For `EACH ROW` affected by a `DELETE` statement, it invokes the `monitor_product_updates()` function.",
    "original_ir": "Write a PLpgSQL function that is triggered before a row is deleted from the \"Products\" table, which first deletes all records from the \"Order_Items\" table where the product_id column matches the product_id of the row being deleted from the \"Products\" table, and then allows the deletion of the original row from the \"Products\" table to proceed by returning the OLD record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `log_treatment_insertion` that inserts a new row into the `\"Treatments\"` table with the following values: `treatment_id` is set to the maximum existing `treatment_id` plus one, using `COALESCE(MAX(treatment_id), 0) + 1` to handle an empty table; `dog_id` is taken from `NEW.dog_id`; `professional_id` is set to the static integer `1`; `treatment_type_code` is set to the static string `'EXAM'`; `date_of_treatment` is set to `CURRENT_TIMESTAMP`; and `cost_of_treatment` is set to the static numeric value `100.0000`. The function must then return `NEW`. Second, define the trigger `log_treatment_insertion_trigger` on table `\"Dogs\"` that fires `AFTER INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_treatment_insertion() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Treatments\" (treatment_id, dog_id, professional_id, treatment_type_code, date_of_treatment, cost_of_treatment) VALUES ((SELECT COALESCE(MAX(treatment_id), 0) + 1 FROM \"Treatments\"), NEW.dog_id, 1, 'EXAM', CURRENT_TIMESTAMP, 100.0000);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER log_treatment_insertion_trigger\nAFTER INSERT ON \"Dogs\"\nFOR EACH ROW EXECUTE FUNCTION log_treatment_insertion();",
    "database_name": "dog_kennels",
    "tables": [
      "Dogs",
      "Treatments",
      "Professionals",
      "Treatment_Types"
    ],
    "call_sqls": [
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (100, 1, '0', 'LAB', 'MED', 'Buddy', '5', '2018-01-01 00:00:00+00:00', '1', '25.00', '2023-01-01 00:00:00+00:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (101, 2, '1', 'GER', 'LGE', 'Max', '3', '2020-03-15 00:00:00+00:00', '0', '30.50', '2023-02-01 00:00:00+00:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (102, 3, '0', 'POO', 'SML', 'Daisy', '2', '2021-06-20 00:00:00+00:00', '1', '10.20', '2023-03-01 00:00:00+00:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (103, 4, '1', 'CHI', 'SML', 'Rocky', '7', '2016-09-10 00:00:00+00:00', '0', '5.70', '2023-04-01 00:00:00+00:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (104, 5, '0', 'BEA', 'MED', 'Lucy', '4', '2019-11-05 00:00:00+00:00', '1', '18.90', '2023-05-01 00:00:00+00:00', NULL, NULL);"
    ],
    "summary": "Create a trigger function `log_treatment_insertion` and a trigger `log_treatment_insertion_trigger`. The trigger fires AFTER INSERT on the Dogs table FOR EACH ROW. The function inserts a new record into the Treatments table with: treatment_id as the current max + 1 (or 1 if empty), dog_id from NEW, professional_id as 1, treatment_type_code as 'EXAM', date_of_treatment as CURRENT_TIMESTAMP, and cost_of_treatment as 100.0000. The function returns NEW.",
    "natural_language": "Please construct a trigger function named `log_treatment_insertion` along with an associated trigger designated as `log_treatment_insertion_trigger`. The trigger is to be configured to execute subsequent to any INSERT operation on the Dogs table, applying to each individual row. The function's operation shall be to insert a new entry into the Treatments table. The values for this entry are to be assigned as follows: the `treatment_id` shall be set to one greater than the current maximum value within the column, or to the value 1 if the table is presently empty; the `dog_id` is to be derived from the NEW record; the `professional_id` is to be set to 1; the `treatment_type_code` is to be assigned the value 'EXAM'; the `date_of_treatment` is to be set to the CURRENT_TIMESTAMP; and the `cost_of_treatment` is to be established as 100.0000. The function must conclude by returning the NEW record.",
    "id": 8,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `log_treatment_insertion` that inserts a new row into the `\"Treatments\"` table with the following values: `treatment_id` is set to the maximum existing `treatment_id` plus one, using `COALESCE(MAX(treatment_id), 0) + 1` to handle an empty table; `dog_id` is taken from `NEW.dog_id`; `professional_id` is set to the static integer `1`; `treatment_type_code` is set to the static string `'EXAM'`; `date_of_treatment` is set to `CURRENT_TIMESTAMP`; and `cost_of_treatment` is set to the static numeric value `100.0000`. The function must then return `NEW`. Second, define the trigger `log_treatment_insertion_trigger` on table `\"Dogs\"` that fires `AFTER INSERT` and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `log_treatment_insertion` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special variables like `NEW` (representing the new row being inserted or updated) and `OLD` (representing the old row before an update or delete). The function is declared to return `TRIGGER`, indicating its purpose as a trigger function. The core operation of this function is to insert a new record into the table named `\"Treatments\"`. The `INSERT` statement populates the following columns in the `\"Treatments\"` table: `treatment_id`, `dog_id`, `professional_id`, `treatment_type_code`, `date_of_treatment`, and `cost_of_treatment`. The value for the `treatment_id` column is determined by a subquery: `(SELECT COALESCE(MAX(treatment_id), 0) + 1 FROM \"Treatments\")`. This subquery first selects the maximum value of the `treatment_id` column from the `\"Treatments\"` table. The `COALESCE` function is then applied to this maximum value, ensuring that if `MAX(treatment_id)` returns `NULL` (which would happen if the table is empty), it defaults to `0`. Finally, `1` is added to this result, effectively generating a new `treatment_id` that is one greater than the current highest `treatment_id` or `1` if the table was empty. The value for the `dog_id` column is taken directly from `NEW.dog_id`, which refers to the `dog_id` of the row that caused the trigger to fire. The `professional_id` column is assigned a static integer value of `1`. The `treatment_type_code` column is assigned a static string literal value of `'EXAM'`. The `date_of_treatment` column is set to the current timestamp using the `CURRENT_TIMESTAMP` function. The `cost_of_treatment` column is assigned a static numeric value of `100.0000`. After performing this insertion, the function returns `NEW`, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the original row that triggered the operation should be returned unchanged.\n\nAccompanying this function is a trigger named `log_treatment_insertion_trigger`. This trigger is defined to execute `AFTER INSERT` operations on the table named `\"Dogs\"`. It is a `FOR EACH ROW` trigger, meaning that the associated function (`log_treatment_insertion()`) will be executed once for every row that is inserted into the `\"Dogs\"` table. The trigger specifies that it should `EXECUTE FUNCTION log_treatment_insertion()`, thereby invoking the previously defined PL/pgSQL function `log_treatment_insertion` whenever a new row is successfully inserted into the `\"Dogs\"` table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function log_employee_changes that inserts a row into the job_history table using values from the OLD record of a deleted employee. The inserted columns are EMPLOYEE_ID (from OLD.EMPLOYEE_ID), START_DATE (from OLD.HIRE_DATE), END_DATE (set to CURRENT_DATE), JOB_ID (from OLD.JOB_ID), and DEPARTMENT_ID (from OLD.DEPARTMENT_ID). The function must return NULL.\nSecond, define the trigger trg_log_employee_changes on table employees that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_employee_changes() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"job_history\" (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\") VALUES (OLD.\"EMPLOYEE_ID\", OLD.\"HIRE_DATE\", CURRENT_DATE, OLD.\"JOB_ID\", OLD.\"DEPARTMENT_ID\");\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_employee_changes\n    AFTER DELETE ON \"employees\"\n    FOR EACH ROW\n    EXECUTE FUNCTION log_employee_changes();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "DELETE FROM employees WHERE EMPLOYEE_ID = 100;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 101;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 102;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 103;",
      "DELETE FROM employees WHERE EMPLOYEE_ID = 104;"
    ],
    "summary": "Create an AFTER DELETE trigger function named handle_station_removal for the company table. Delete rows from the station_company table where Company_ID equals OLD.Company_ID and Rank_of_the_Year is greater than 5. Return OLD.",
    "natural_language": "Set up a trigger function called handle_station_removal to run after something gets deleted from the company table. It should clean up related entries in the station_company table for that company, but only for those with a fairly high Rank_of_the_Year. Finally, just give back the record that was removed.",
    "id": 9,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `handle_station_removal` that returns a `TRIGGER` type and is designed to be executed after a `DELETE` operation on the `company` table. This function operates `FOR EACH ROW` that is deleted. The function does not declare any local variables.\n\nUpon execution for a specific deleted row (referred to as `OLD` within the trigger context), the function performs a `DELETE` operation on the `station_company` table. It deletes all rows where the `company_id` column matches the `OLD.company_id` value from the deleted row in the `company` table, but only for those rows where the `Rank_of_the_Year` column is considered \"fairly high.\" Since the natural language description does not specify an exact threshold for \"fairly high,\" the exact condition (e.g., `Rank_of_the_Year > X`) must be determined based on business logic; the operation will use a placeholder condition `Rank_of_the_Year >= threshold_value` where `threshold_value` is a numeric value that defines \"fairly high.\"\n\nFinally, the function returns the `OLD` row, indicating that the trigger has completed its operation and the deleted row record should be used for further processing.\n\nSecond, define the trigger `trg_handle_station_removal` on the `company` table. It is an `AFTER DELETE` trigger, meaning it fires after the `DELETE` statement has completed its removal from the `company` table. The `FOR EACH ROW` clause ensures that the `handle_station_removal` function is executed individually for every row deleted from the `company` table.",
    "original_ir": "Write a PLpgSQL function named log_employee_changes that is designed to be executed as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to be used with a trigger that fires after a DELETE operation on the employees table. The function performs an INSERT operation into the job_history table, which has columns EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, and DEPARTMENT_ID. The values inserted into these columns are derived from the OLD record, which represents the state of the deleted row from the employees table. Specifically, the EMPLOYEE_ID column in job_history is populated with the value from OLD.EMPLOYEE_ID, the START_DATE column is populated with the value from OLD.HIRE_DATE, the END_DATE column is set to the current date using the CURRENT_DATE function, the JOB_ID column is populated with the value from OLD.JOB_ID, and the DEPARTMENT_ID column is populated with the value from OLD.DEPARTMENT_ID. The function returns NULL, which is typical for trigger functions that do not modify the row being processed. The associated trigger, named trg_log_employee_changes, is defined to execute this function after a row is deleted from the employees table, ensuring that the job history of the deleted employee is recorded in the job_history table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function insert_architect_from_mill that inserts a row into the architect table, using NEW.architect_id cast to text for the id column and concatenating the literal string 'Unknown Architect ' with the text representation of NEW.architect_id for the name column, then returns the NEW record. Second, define the trigger mill_architect_insert on table mill that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_architect_from_mill() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"architect\" (\"id\", \"name\") VALUES (NEW.\"architect_id\"::text, 'Unknown Architect ' || NEW.\"architect_id\"::text);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER mill_architect_insert\nBEFORE INSERT ON \"mill\"\nFOR EACH ROW EXECUTE FUNCTION insert_architect_from_mill();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (101, 1, 'Location A', 'Mill A', 'Type A', 2000, 'Notes A');",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (102, 2, 'Location B', 'Mill B', 'Type B', 2001, 'Notes B');",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (103, 3, 'Location C', 'Mill C', 'Type C', 2002, 'Notes C');",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (104, 4, 'Location D', 'Mill D', 'Type D', 2003, 'Notes D');",
      "INSERT INTO mill (architect_id, id, location, name, type, built_year, notes) VALUES (105, 5, 'Location E', 'Mill E', 'Type E', 2004, 'Notes E');"
    ],
    "summary": "Create a trigger function named `insert_architect_from_mill` that returns a trigger. It executes before an INSERT into the `mill` table. For each new row, it inserts a record into the `architect` table. The `id` column uses the `NEW.architect_id` cast to text, and the `name` column is set to `'Unknown Architect '` concatenated with the text representation of `NEW.architect_id`. The function returns the `NEW` record.",
    "natural_language": "Alright, so we need a trigger function called `insert_architect_from_mill` that spits out a trigger. Set it to fire off right before we pop a new row into the `mill` table. For every fresh mill entry, it's gotta also add a record to the `architect` table. For the architect's `id`, just use the new row's `architect_id` turned into text. For the `name`, slap together the string 'Unknown Architect ' with that same `architect_id` (as text, of course). Finally, the function should just hand back the `NEW` row.",
    "id": 10,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named insert_architect_from_mill. This function is designed to be executed before an INSERT operation on the mill table, for each row being inserted. The function takes no explicit parameters but operates on the implicit NEW record provided by the trigger mechanism. The function's primary purpose is to automatically insert a corresponding record into the architect table whenever a new row is added to the mill table.\n\nThe function declares no local variables. It performs a single SQL operation: an INSERT into the architect table. The values for the INSERT are derived from the NEW record of the mill table. Specifically, for the id column of the architect table, the function uses the architect_id value from the NEW record of the mill table, converting it from its native integer data type to a text data type. For the name column of the architect table, the function constructs a string by concatenating the literal string 'Unknown Architect ' with the text representation of the NEW.architect_id value. For the nationality and gender columns of the architect table, the function does not provide explicit values; therefore, these columns will be populated with NULL, as the INSERT statement does not specify values for them.\n\nThe function contains no conditional logic or control flow; it executes the INSERT operation unconditionally for every new mill row. After performing the INSERT, the function returns the NEW record unchanged, which then becomes the actual row data used for the INSERT operation into the mill table.\n\nSecond, define the trigger named insert_architect_from_mill_trigger on table mill. This trigger is configured to fire BEFORE any INSERT statement is executed on the mill table. It is set to operate FOR EACH ROW affected by the INSERT statement, meaning the insert_architect_from_mill() function will be executed once for every row that is being inserted. The trigger's action is to EXECUTE FUNCTION insert_architect_from_mill(), thereby invoking the logic described above for each new row.",
    "original_ir": "Write a PostgreSQL trigger function named insert_architect_from_mill that is executed automatically by a trigger named mill_architect_insert before any new row is inserted into the mill table; this function takes no explicit parameters but has access to the special NEW record variable representing the prospective new row for the mill table; the function's logic performs a single INSERT operation into the architect table, specifying values for two columns: for the id column, it uses the value from the NEW.architect_id field of the triggering mill row, explicitly casting it to text data type, and for the name column, it constructs a string by concatenating the literal string 'Unknown Architect ' with the text representation of the NEW.architect_id value; after this insert, the function returns the unmodified NEW record to allow the original INSERT operation on the mill table to proceed."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_course_grade_trigger` that updates the `course_arrange` table by setting its `Grade` column to the absolute value of `NEW.Teacher_ID` for all rows where the `Teacher_ID` matches `OLD.Teacher_ID`.\nSecond, define the trigger `teacher_update_trigger` on table `teacher` that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_course_grade_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE course_arrange\n    SET \"Grade\" = abs(NEW.\"Teacher_ID\")\n    WHERE \"Teacher_ID\" = OLD.\"Teacher_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER teacher_update_trigger\n    AFTER UPDATE ON teacher\n    FOR EACH ROW\n    EXECUTE FUNCTION update_course_grade_trigger();",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "UPDATE teacher SET \"Teacher_ID\" = 10 WHERE \"Teacher_ID\" = 1;",
      "UPDATE teacher SET \"Teacher_ID\" = 15 WHERE \"Name\" = 'Joseph Huts';",
      "UPDATE teacher SET \"Teacher_ID\" = ABS(\"Teacher_ID\") WHERE \"Teacher_ID\" = 2;",
      "UPDATE teacher SET \"Age\" = '33', \"Teacher_ID\" = 20 WHERE \"Teacher_ID\" = 3;",
      "UPDATE teacher SET \"Teacher_ID\" = -5 WHERE \"Hometown\" = 'Bolton County Borough';"
    ],
    "summary": "Create a trigger function named update_course_grade_trigger that fires AFTER UPDATE on the teacher table for each row. It updates the Grade column in the course_arrange table to the absolute value of NEW.Teacher_ID where Teacher_ID equals OLD.Teacher_ID, then returns NEW.",
    "natural_language": "Please construct a trigger function designated as 'update_course_grade_trigger'. This function should be configured to execute subsequent to any UPDATE operation performed on the 'teacher' table, acting upon each modified row. Its operational logic must update the 'Grade' column within the 'course_arrange' table, setting its value to the absolute magnitude of the NEW.Teacher_ID. This update is to be applied specifically to records where the 'Teacher_ID' matches the OLD.Teacher_ID. The function must conclude by returning the NEW row.",
    "id": 11,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_course_grade_trigger` that updates the `course_arrange` table by setting its `Grade` column to the absolute value of `NEW.Teacher_ID` for all rows where the `Teacher_ID` matches `OLD.Teacher_ID`.\nSecond, define the trigger `teacher_update_trigger` on table `teacher` that fires AFTER UPDATE and executes the function.",
    "original_ir": "Write a PLpgSQL function named update_course_grade_trigger that is designed to be executed as a trigger function. This function does not take any parameters directly but operates using the implicit NEW and OLD records provided by the trigger mechanism. The function performs an update operation on the course_arrange table, specifically targeting the Grade column. It sets the Grade column to the absolute value of the NEW.Teacher_ID, which is the identifier of the teacher after an update operation has occurred on the teacher table. The update is applied to all rows in the course_arrange table where the Teacher_ID matches the OLD.Teacher_ID, which is the identifier of the teacher before the update operation. The function concludes by returning the NEW record, which is a standard practice for trigger functions to indicate the modified row. Additionally, a trigger named teacher_update_trigger is created to automatically invoke the update_course_grade_trigger function after any update operation on the teacher table. This trigger is defined to execute for each row that is updated, ensuring that the function is called individually for each row affected by the update operation on the teacher table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function check_participant_event that checks for duplicate Event_ID and Participant_ID pairs in the Participants_in_Events table; if a duplicate exists, the function returns NULL to skip the insertion, otherwise it returns the NEW row.\nSecond, define the trigger prevent_duplicate_participant_event on table Participants_in_Events that fires BEFORE INSERT and executes the function check_participant_event.",
    "plsql": "CREATE OR REPLACE FUNCTION update_participant_type() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Participants\"\n  SET \"Participant_Type_Code\" = 'Updated'\n  WHERE \"Participant_ID\" = NEW.\"Participant_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE OR REPLACE FUNCTION check_participant_event() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if the (Event_ID, Participant_ID) pair already exists\n  IF EXISTS (\n    SELECT 1 FROM \"Participants_in_Events\" \n    WHERE \"Event_ID\" = NEW.\"Event_ID\" \n    AND \"Participant_ID\" = NEW.\"Participant_ID\"\n  ) THEN\n    -- If it exists, skip the insertion\n    RETURN NULL;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Drop existing trigger if it exists\nDROP TRIGGER IF EXISTS participant_type_trigger ON \"Participants_in_Events\";\nDROP TRIGGER IF EXISTS prevent_duplicate_participant_event ON \"Participants_in_Events\";\n\n-- Create trigger to prevent duplicates BEFORE INSERT\nCREATE TRIGGER prevent_duplicate_participant_event\nBEFORE INSERT ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION check_participant_event();\n\n-- Create the original trigger for AFTER UPDATE\nCREATE TRIGGER participant_type_trigger\nAFTER UPDATE ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION update_participant_type();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 26);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 66);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (13, 86);",
      "UPDATE \"Participants_in_Events\" SET \"Event_ID\" = 8 WHERE \"Participant_ID\" = 26;",
      "UPDATE \"Participants_in_Events\" SET \"Event_ID\" = 3 WHERE \"Participant_ID\" = 66;"
    ],
    "summary": "Create two PostgreSQL trigger functions. First, create a function named `update_participant_type` that, after an update on the `Participants_in_Events` table, updates the `Participants` table by setting `Participant_Type_Code` to 'Updated' for the row where `Participant_ID` matches the updated row's `Participant_ID`. It must return the NEW row. Create an AFTER UPDATE FOR EACH ROW trigger named `participant_type_trigger` on `Participants_in_Events` to execute it. Second, create a function named `check_participant_event` that, before an insert on the `Participants_in_Events` table, checks if the (`Event_ID`, `Participant_ID`) pair already exists. If it exists, return NULL to abort the insert; otherwise, return the NEW row to proceed. Create a BEFORE INSERT FOR EACH ROW trigger named `prevent_duplicate_participant_event` on `Participants_in_Events` to execute it.",
    "natural_language": "Create a couple of PostgreSQL trigger functions. First, make a function called `update_participant_type` that, after some changes to the `Participants_in_Events` table, goes and updates the `Participants` table by setting the `Participant_Type_Code` to something like 'Updated' for any matching participant. It should give back the new row. Set up an AFTER UPDATE trigger named `participant_type_trigger` on that table to run it. Second, create another function named `check_participant_event` that, before putting new data into `Participants_in_Events`, checks if a similar participant-event combination is already there. If it looks like a duplicate, stop the insert; otherwise, let it go through. Create a BEFORE INSERT trigger named `prevent_duplicate_participant_event` to handle that.",
    "id": 12,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function check_participant_event that checks for duplicate Event_ID and Participant_ID pairs in the Participants_in_Events table; if a duplicate exists, the function returns NULL to skip the insertion, otherwise it returns the NEW row.\nSecond, define the trigger prevent_duplicate_participant_event on table Participants_in_Events that fires BEFORE INSERT and executes the function check_participant_event.",
    "original_ir": "Write a PLpgSQL function named update_participant_type that is designed to be used as a trigger function, which updates the Participants table by setting the Participant_Type_Code column to the string 'Updated' for the row where the Participant_ID matches the Participant_ID of the newly updated row in the Participants_in_Events table, and returns the newly updated row. Additionally, write another PLpgSQL function named check_participant_event that serves as a trigger function to prevent duplicate entries in the Participants_in_Events table by checking if a pair of Event_ID and Participant_ID already exists in the table; if such a pair exists, the function returns NULL to skip the insertion, otherwise, it returns the new row to allow the insertion. Implement a trigger named prevent_duplicate_participant_event on the Participants_in_Events table that executes the check_participant_event function before any insert operation to ensure no duplicate Event_ID and Participant_ID pairs are inserted. Also, implement a trigger named participant_type_trigger on the Participants_in_Events table that executes the update_participant_type function after any update operation to ensure the Participant_Type_Code in the Participants table is updated accordingly."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_cmi_cross_ref_trigger that updates the \"CMI_Cross_References\" table by setting the master_customer_id column to the smallest master_customer_id value (selected using ORDER BY master_customer_id LIMIT 1) from the \"Customer_Master_Index\" table, where the cmi_cross_ref_id matches the NEW.cmi_cross_ref_id from the trigger.\nSecond, define the trigger update_cmi_cross_ref on table \"Benefits_Overpayments\" that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_cmi_cross_ref_trigger() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"CMI_Cross_References\" \n  SET master_customer_id = (SELECT master_customer_id FROM \"Customer_Master_Index\" ORDER BY master_customer_id LIMIT 1)\n  WHERE cmi_cross_ref_id = NEW.cmi_cross_ref_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_cmi_cross_ref AFTER INSERT ON \"Benefits_Overpayments\"\nFOR EACH ROW EXECUTE FUNCTION update_cmi_cross_ref_trigger();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (1, 65);",
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (2, 41);",
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (3, 83);",
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (4, 2);",
      "INSERT INTO \"Benefits_Overpayments\" (council_tax_id, cmi_cross_ref_id) VALUES (5, 4);"
    ],
    "summary": "Create an AFTER INSERT trigger on the Benefits_Overpayments table that updates the CMI_Cross_References table. For each new row, set its master_customer_id to the minimum master_customer_id from the Customer_Master_Index table.",
    "natural_language": "Please implement an AFTER INSERT trigger on the Benefits_Overpayments table. Its function is to update the CMI_Cross_References table. For every newly inserted row, the trigger must assign the master_customer_id by selecting the minimum master_customer_id value present in the Customer_Master_Index table.",
    "id": 13,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_cmi_cross_ref_trigger that updates the \"CMI_Cross_References\" table by setting the master_customer_id column to the smallest master_customer_id value (selected using ORDER BY master_customer_id LIMIT 1) from the \"Customer_Master_Index\" table, where the cmi_cross_ref_id matches the NEW.cmi_cross_ref_id from the trigger.\nSecond, define the trigger update_cmi_cross_ref on table \"Benefits_Overpayments\" that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that updates the \"CMI_Cross_References\" table by setting the master_customer_id column to the smallest master_customer_id value from the \"Customer_Master_Index\" table, ordered by master_customer_id in ascending order, for the row where cmi_cross_ref_id matches the cmi_cross_ref_id of the newly inserted row in the \"Benefits_Overpayments\" table. This function is executed by a trigger named update_cmi_cross_ref, which is fired after each row is inserted into the \"Benefits_Overpayments\" table. The trigger ensures that for every new insertion into the \"Benefits_Overpayments\" table, the corresponding row in the \"CMI_Cross_References\" table is updated with the smallest master_customer_id from the \"Customer_Master_Index\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_auto_close_problem` that checks if the NEW row's `date_problem_closed` column is NOT NULL and, if true, performs a DELETE from the \"Problem_Log\" table where `problem_id` matches `NEW.problem_id` and `problem_status_code` does not equal the string 'Solved'.\nSecond, define the trigger `auto_close_problem` on table \"Problems\" that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_auto_close_problem() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.date_problem_closed IS NOT NULL THEN\n        DELETE FROM \"Problem_Log\" \n        WHERE problem_id = NEW.problem_id \n          AND problem_status_code != 'Solved';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER auto_close_problem\nAFTER UPDATE ON \"Problems\"\nFOR EACH ROW EXECUTE FUNCTION trg_auto_close_problem();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Product",
      "Staff"
    ],
    "call_sqls": [
      "UPDATE \"Problems\" SET date_problem_closed = CURRENT_TIMESTAMP WHERE problem_id = 1;",
      "UPDATE \"Problems\" SET date_problem_closed = '2024-01-15 10:30:00+00' WHERE problem_id = 2;",
      "UPDATE \"Problems\" SET date_problem_closed = date_problem_reported + INTERVAL '7 days', closure_authorised_by_staff_id = 5 WHERE problem_id = 3;",
      "UPDATE \"Problems\" SET date_problem_closed = NOW() WHERE problem_id IN (4,5);",
      "UPDATE \"Problems\" SET date_problem_closed = '2024-03-20 14:45:00+00', problem_description = 'Fixed issue' WHERE problem_id = 6;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named trg_auto_close_problem for the \"Problems\" table. If the updated row's date_problem_closed is set to a non-NULL value, delete all rows from the \"Problem_Log\" table where the problem_id matches and the problem_status_code is not 'Solved'. Return the NEW row.",
    "natural_language": "Create AFTER UPDATE trigger trg_auto_close_problem on Problems. If date_problem_closed is set, delete from Problem_Log where problem_id matches and status is not 'Solved'. Return NEW.",
    "id": 14,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named trg_auto_close_problem in the tracking_software_problems database. This function is defined to return a trigger and uses PL/pgSQL language. It is executed automatically by a trigger after an update operation on the Problems table for each row that is updated. The function declares no local variables. The function's logic begins by checking if the NEW row's date_problem_closed column is not null, indicating that the date_problem_closed has been set or modified in the update. If this condition is true, the function performs a delete operation on the Problem_Log table. The delete operation targets rows where the problem_id column in Problem_Log matches the NEW row's problem_id from the Problems table, and simultaneously, the problem_status_code column in Problem_Log is not equal to the string 'Solved'. This ensures that only log entries with a status other than 'Solved' are removed for the specific problem being closed. After the conditional delete, the function returns the NEW row record, allowing the update operation on the Problems table to proceed normally. Second, define the trigger named trg_auto_close_problem on the Problems table. This trigger is set to fire after an update operation on the Problems table for each row. It executes the trg_auto_close_problem function to handle the automatic cleanup of non-solved log entries when a problem is closed by setting its date_problem_closed.",
    "original_ir": "Write a PostgreSQL trigger function named trg_auto_close_problem that is executed automatically after each row update on the \"Problems\" table, which takes no explicit parameters but implicitly receives the OLD and NEW row records for the updated row, and within this function, it checks if the NEW record's date_problem_closed column has a non-NULL value, and if this condition is true, it performs a DELETE operation on the \"Problem_Log\" table where the problem_id column matches the NEW.problem_id value from the \"Problems\" table and simultaneously where the problem_status_code column in \"Problem_Log\" does not equal the string literal 'Solved', thereby removing any log entries for the specific problem that are not marked as 'Solved' when the problem is closed, and finally the function returns the NEW row record to the calling trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_problem_status_on_log` that updates the `\"Problems\"` table, setting the `\"date_problem_closed\"` column to `CURRENT_TIMESTAMP` where the `\"problem_id\"` matches the `NEW.\"problem_id\"` from the `\"Problem_Log\"` table and the `NEW.\"problem_status_code\"` is exactly equal to the string `'Solved'`.\nSecond, define the trigger `trg_update_problem_status_on_log` on table `\"Problem_Log\"` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_problem_status_on_log() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Problems\" SET \"date_problem_closed\" = CURRENT_TIMESTAMP WHERE \"problem_id\" = NEW.\"problem_id\" AND NEW.\"problem_status_code\" = 'Solved';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_problem_status_on_log\n    AFTER INSERT ON \"Problem_Log\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_problem_status_on_log();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problem_Category_Codes",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problems",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (100, 1, 'Solved', 11, 'Middleware', '2023-01-01 10:00:00+00', 'Initial log entry', 'Fixed issue', 'None');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (101, 2, 'Solved', 12, 'GUI', '2023-01-02 11:00:00+00', 'Second log entry', 'Patched bug', 'Details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (102, 3, 'Reported', 11, 'Datatabase', '2023-01-03 12:00:00+00', 'Problem reported', NULL, 'More details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (103, 1, 'Reported', 12, 'Middleware', '2023-01-04 13:00:00+00', 'Problem re-opened', NULL, 'Re-evaluation');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, problem_id, problem_status_code, assigned_to_staff_id, problem_category_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (104, 4, 'Solved', 11, 'GUI', '2023-01-05 14:00:00+00', 'Final solution', 'Implemented fix', 'Closed');"
    ],
    "summary": "Create a trigger function named `update_problem_status_on_log` that, after a row is inserted into the `\"Problem_Log\"` table, updates the `\"Problems\"` table. It sets the `\"date_problem_closed\"` to the current timestamp for the problem where the `\"problem_id\"` matches the new log's `\"problem_id\"` AND the new log's `\"problem_status_code\"` is 'Solved'. Also, create an `AFTER INSERT FOR EACH ROW` trigger named `trg_update_problem_status_on_log` on the `\"Problem_Log\"` table to execute this function.",
    "natural_language": "Please construct a trigger function designated as `update_problem_status_on_log`. This function shall be invoked subsequent to an insertion into the `\"Problem_Log\"` table. Its purpose is to modify the `\"Problems\"` table by setting the `\"date_problem_closed\"` column to the current timestamp. This update is to be applied specifically to the record whose `\"problem_id\"` corresponds to the `\"problem_id` value in the newly inserted log, but only under the condition that the new log's `\"problem_status_code\"` is precisely 'Solved'. Furthermore, please establish an `AFTER INSERT FOR EACH ROW` trigger named `trg_update_problem_status_on_log` on the `\"Problem_Log\"` table, which will call the aforementioned function.",
    "id": 15,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_problem_status_on_log` that updates the `\"Problems\"` table, setting the `\"date_problem_closed\"` column to `CURRENT_TIMESTAMP` where the `\"problem_id\"` matches the `NEW.\"problem_id\"` from the `\"Problem_Log\"` table and the `NEW.\"problem_status_code\"` is exactly equal to the string `'Solved'`.\nSecond, define the trigger `trg_update_problem_status_on_log` on table `\"Problem_Log\"` that fires `AFTER` `INSERT` and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `update_problem_status_on_log` that is designed to be executed in response to data manipulation language (DML) events on a specific table. This function does not accept any explicit input parameters beyond the implicit `NEW` and `OLD` records provided by the trigger mechanism. The function's primary purpose is to conditionally update a record in the `\"Problems\"` table. Specifically, it performs an `UPDATE` operation on the `\"Problems\"` table. The `UPDATE` statement targets rows in the `\"Problems\"` table where the value in the `\"problem_id\"` column matches the value of the `\"problem_id\"` column from the `NEW` record (which represents the newly inserted row in the `Problem_Log` table that activated the trigger). Additionally, this `UPDATE` operation is further conditioned by checking if the value in the `\"problem_status_code\"` column of the `NEW` record is exactly equal to the string literal `'Solved'`. If both of these conditions are met for a given row in the `\"Problems\"` table, the `UPDATE` statement sets the value of the `\"date_problem_closed\"` column in that row to the `CURRENT_TIMESTAMP`, which represents the current date and time when the statement is executed. After attempting this update, the function concludes by returning the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL, indicating that the row that triggered the function should be processed as usual.\n\nThis trigger function is then associated with a trigger named `trg_update_problem_status_on_log`. This trigger is configured to activate `AFTER INSERT` operations on the `\"Problem_Log\"` table. The `FOR EACH ROW` clause specifies that the trigger function `update_problem_status_on_log` will be executed once for each individual row that is inserted into the `\"Problem_Log\"` table. The `EXECUTE FUNCTION update_problem_status_on_log()` clause explicitly calls the previously defined trigger function to perform its logic whenever the trigger is activated."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_update_company_rank` that updates the `Rank` column in the `company` table for a specific `Company_ID`. The update sets the `Rank` to the average of the `Rank_of_the_Year` values from the `station_company` table for the matching `Company_ID` found in the `NEW` row, using the `AVG` aggregate function.\nSecond, define the trigger `update_company_rank` on table `station_company` that fires `AFTER` `INSERT OR UPDATE` and executes the function for each row.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_company_rank() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"company\" \n    SET \"Rank\" = (\n        SELECT AVG(\"Rank_of_the_Year\") \n        FROM \"station_company\" \n        WHERE \"Company_ID\" = NEW.\"Company_ID\"\n    ) \n    WHERE \"Company_ID\" = NEW.\"Company_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_company_rank\nAFTER INSERT OR UPDATE ON \"station_company\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_company_rank();\n\n-- Example of handling the insertion with ON CONFLICT\nINSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\")\nVALUES (4, 1, 2)\nON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (5, 1, 3);",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (6, 2, 4);",
      "UPDATE \"station_company\" SET \"Rank_of_the_Year\" = 5 WHERE \"Station_ID\" = 1 AND \"Company_ID\" = 3;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (7, 1, 1) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "UPDATE \"station_company\" SET \"Rank_of_the_Year\" = 2 WHERE \"Station_ID\" = 11 AND \"Company_ID\" = 1;"
    ],
    "summary": "Create a trigger function named trg_update_company_rank that fires after INSERT or UPDATE on the station_company table. For each affected row, update the company table's Rank column for the matching Company_ID, setting it to the average Rank_of_the_Year from the station_company table for that company. The associated trigger is named update_company_rank.",
    "natural_language": "Please construct a trigger function designated as 'trg_update_company_rank'. This function is to be executed subsequent to any INSERT or UPDATE operation performed on the 'station_company' table. For every row impacted by these operations, it is required to modify the 'Rank' column within the 'company' table. The update should be applied to the record with the corresponding 'Company_ID', assigning it a value equivalent to the computed average of the 'Rank_of_the_Year' values from the 'station_company' table associated with that specific company. The trigger that invokes this function shall be named 'update_company_rank'.",
    "id": 16,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_update_company_rank` that updates the `Rank` column in the `company` table for a specific `Company_ID`. The update sets the `Rank` to the average of the `Rank_of_the_Year` values from the `station_company` table for the matching `Company_ID` found in the `NEW` row, using the `AVG` aggregate function.\nSecond, define the trigger `update_company_rank` on table `station_company` that fires `AFTER` `INSERT OR UPDATE` and executes the function for each row.",
    "original_ir": "Write a PLpgSQL function named trg_update_company_rank that is designed to be used as a trigger function. This function updates the Rank column in the company table for a specific company identified by the Company_ID. The update operation sets the Rank to the average of the Rank_of_the_Year values from the station_company table for the same Company_ID as the one in the newly inserted or updated row. The function is triggered after an insert or update operation on the station_company table, and it executes for each row affected by these operations. The trigger named update_company_rank is created to invoke this function after any insert or update on the station_company table. The trigger ensures that whenever a new row is inserted or an existing row is updated in the station_company table, the trg_update_company_rank function is executed to recalculate and update the Rank of the corresponding company in the company table. Additionally, an example insert statement is provided, which attempts to insert a new row into the station_company table with specific values for Station_ID, Company_ID, and Rank_of_the_Year. If a conflict occurs on the combination of Station_ID and Company_ID, the insert operation does nothing, effectively ignoring the conflict."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_painting_year_from_artist` that updates the `Paintings` table by setting its `year` column to the value of `NEW.birthYear` plus 25 for every row where the `painterID` column matches `NEW.artistID`.\nSecond, define the trigger `artist_birth_update_trigger` on table `Artists` that fires AFTER UPDATE of the `birthYear` column and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_painting_year_from_artist() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Paintings\" SET \"year\" = NEW.\"birthYear\" + 25 WHERE \"painterID\" = NEW.\"artistID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER artist_birth_update_trigger\n    AFTER UPDATE OF \"birthYear\" ON \"Artists\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_painting_year_from_artist();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "UPDATE \"Artists\" SET \"birthYear\" = 1860 WHERE \"artistID\" = 111;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1882 WHERE \"artistID\" = 222;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1854 WHERE \"artistID\" = 333;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1861 WHERE \"artistID\" = 111;",
      "UPDATE \"Artists\" SET \"birthYear\" = 1883 WHERE \"artistID\" = 222;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_painting_year_from_artist for the \"Artists\" table when the birthYear column is updated. For each updated artist row, update the \"Paintings\" table, setting the year to NEW.birthYear + 25 for all paintings where painterID equals NEW.artistID.",
    "natural_language": "Set up a trigger that runs after changes to the Artists table, specifically when the birth year gets adjusted. The trigger should roughly update the year for some of the artist's related paintings in the Paintings table, linking them by the artist's ID and setting the painting year to a value based on the new birth year.",
    "id": 17,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_painting_year_from_artist`. This function is designed to be executed as a trigger after an update operation on the `Artists` table. It does not accept explicit parameters but operates within the trigger context, having access to the special `OLD` and `NEW` records. The function is declared to return a `TRIGGER` type. The function begins by checking if the `birthYear` column has been updated by comparing `OLD.birthYear` and `NEW.birthYear`. If they are equal, indicating no change, the function returns `NEW` without performing any further actions. If a change is detected, the function proceeds to update the `Paintings` table. It updates rows in the `Paintings` table where the `painterID` column matches `NEW.artistID`, linking the paintings to the artist whose birth year was just updated. For each matching painting, the function sets the `year` column to a new value calculated as `NEW.birthYear` plus a fixed offset of 25, representing a rough estimate that the painting was created when the artist was approximately 25 years old. This calculation is applied directly in the `UPDATE` statement. The function then returns `NEW`, allowing the original update on the `Artists` table to proceed. Second, define the trigger on the `Artists` table. The trigger is configured to activate `AFTER UPDATE` operations on the `Artists` table. It is a `FOR EACH ROW` trigger, meaning it executes the function once for every row updated in the `Artists` table. The trigger is set to `EXECUTE FUNCTION update_painting_year_from_artist()`, ensuring that whenever an artist's birth year is updated, the function is invoked to recalculate and update the year for all paintings associated with that artist based on the new birth year.",
    "original_ir": "Write a PostgreSQL trigger function named update_painting_year_from_artist that returns a trigger and is executed by a trigger named artist_birth_update_trigger, where the trigger is defined to fire after an update operation on the birthYear column of the Artists table for each modified row, and the function's logic performs an update on the Paintings table, specifically setting the year column to the value of the NEW.birthYear (the updated birth year from the Artists table) plus 25 for every row in the Paintings table where the painterID column matches the NEW.artistID (the artist identifier from the updated Artists row)."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function trg_create_default_participant that inserts a new row into the Participants table, setting the Participant_ID column to the value of NEW.Service_ID plus 1000, the Participant_Type_Code column to the literal string 'Organizer', and the Participant_Details column to the literal string 'Auto Generated', and then returns the NEW record. Second, define the trigger create_default_participant_trigger on table Services that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_create_default_participant() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Participants\" (\"Participant_ID\", \"Participant_Type_Code\", \"Participant_Details\") VALUES (NEW.\"Service_ID\" + 1000, 'Organizer', 'Auto Generated');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER create_default_participant_trigger\nAFTER INSERT ON \"Services\"\nFOR EACH ROW EXECUTE FUNCTION trg_create_default_participant();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (1, 'Marriage');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (3, 'Death Proof');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (4, 'Birth Proof');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (7, 'Marriage');",
      "INSERT INTO \"Services\" (\"Service_ID\", \"Service_Type_Code\") VALUES (9, 'Death Proof');"
    ],
    "summary": "Create an AFTER INSERT trigger on the Services table that inserts a new row into the Participants table, setting Participant_ID to (Service_ID + 1000), Participant_Type_Code to 'Organizer', and Participant_Details to 'Auto Generated'.",
    "natural_language": "How can I create an AFTER INSERT trigger on the Services table to insert a new row into the Participants table, setting Participant_ID to (Service_ID + 1000), Participant_Type_Code to 'Organizer', and Participant_Details to 'Auto Generated'?",
    "id": 18,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function trg_create_default_participant that inserts a new row into the Participants table, setting the Participant_ID column to the value of NEW.Service_ID plus 1000, the Participant_Type_Code column to the literal string 'Organizer', and the Participant_Details column to the literal string 'Auto Generated', and then returns the NEW record. Second, define the trigger create_default_participant_trigger on table Services that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named trg_create_default_participant that is executed automatically after every insert operation on the Services table for each newly inserted row, which takes no explicit parameters but has access to the special NEW record variable containing the column values of the newly inserted Services row, and within its body performs a single INSERT operation into the Participants table, specifying values for three columns: it sets the Participant_ID column to the result of adding 1000 to the value from the Service_ID column of the NEW record, sets the Participant_Type_Code column to the literal string value 'Organizer', and sets the Participant_Details column to the literal string value 'Auto Generated', and finally returns the NEW record to the trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `insert_city_distance` that performs an INSERT into the \"Direct_distance\" table, setting the column `city1_code` to the NEW row's `city_code`, the column `city2_code` to the literal string 'NYC', and the column `distance` to the literal integer 200, and then returns the NEW row. Second, define the trigger `trg_insert_city_distance` on table \"City\" that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_city_distance() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Direct_distance\" (city1_code, city2_code, distance)\n  VALUES (NEW.city_code, 'NYC', 200);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_city_distance\nAFTER INSERT ON \"City\"\nFOR EACH ROW EXECUTE FUNCTION insert_city_distance();",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('LAX', 'Los Angeles', 'CA', 'USA', 34.0522, -118.2437);",
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('CHI', 'Chicago', 'IL', 'USA', 41.8781, -87.6298);",
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('MIA', 'Miami', 'FL', 'USA', 25.7617, -80.1918);",
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('DEN', 'Denver', 'CO', 'USA', 39.7392, -104.9903);",
      "INSERT INTO \"City\" (city_code, city_name, state, country, latitude, longitude) VALUES ('SEA', 'Seattle', 'WA', 'USA', 47.6062, -122.3321);"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_city_distance on the City table. For each new row, insert a record into the Direct_distance table with city1_code from NEW.city_code, city2_code as 'NYC', and distance as 200. Return NEW.",
    "natural_language": "Construct an AFTER INSERT trigger function, which should be named insert_city_distance, to be associated with the City table. For every single new row that is successfully inserted, you must then proceed to insert a corresponding record into the Direct_distance table. This new record should carefully use the city1_code drawn from the NEW.city_code value, explicitly set the city2_code to the constant value 'NYC', and assign a fixed distance of 200 units. Finally, the trigger function must conclude by returning the NEW row.",
    "id": 19,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `insert_city_distance` that performs an INSERT into the \"Direct_distance\" table, setting the column `city1_code` to the NEW row's `city_code`, the column `city2_code` to the literal string 'NYC', and the column `distance` to the literal integer 200, and then returns the NEW row. Second, define the trigger `trg_insert_city_distance` on table \"City\" that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named insert_city_distance that is executed automatically after every new row insertion into the \"City\" table, and within this function, perform an INSERT operation into the \"Direct_distance\" table, specifying the columns city1_code, city2_code, and distance, where the value for city1_code is taken from the newly inserted row's city_code column, the value for city2_code is the literal string 'NYC', and the value for distance is the literal integer 200, and then return the NEW row record to the trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_payment_on_settlement` that declares a local variable `next_payment_id` of type bigint, computes a new unique payment identifier by querying the `Payments` table for the maximum value in the `Payment_ID` column using the `COALESCE` function to substitute zero if no maximum exists, increments that result by one, and stores it into `next_payment_id`, and then performs an INSERT into the `Payments` table, populating the columns `Payment_ID`, `Settlement_ID`, `Payment_Method_Code`, `Date_Payment_Made`, and `Amount_Payment` with the values from the `next_payment_id` variable, `NEW.Settlement_ID`, the literal string 'MasterCard', the `CURRENT_DATE`, and `NEW.Amount_Settled`, respectively, and finally returns the `NEW` row.\nSecond, define the trigger `trg_insert_payment_on_settlement` on table `Settlements` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_payment_on_settlement() RETURNS TRIGGER AS $$\nDECLARE\n  next_payment_id bigint;\nBEGIN\n  -- Generate a new Payment_ID\n  SELECT COALESCE(MAX(\"Payment_ID\"), 0) + 1 INTO next_payment_id FROM \"Payments\";\n  \n  INSERT INTO \"Payments\" (\"Payment_ID\", \"Settlement_ID\", \"Payment_Method_Code\", \"Date_Payment_Made\", \"Amount_Payment\")\n  VALUES (next_payment_id, NEW.\"Settlement_ID\", 'MasterCard', CURRENT_DATE, NEW.\"Amount_Settled\");\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_payment_on_settlement\nAFTER INSERT ON \"Settlements\"\nFOR EACH ROW EXECUTE FUNCTION insert_payment_on_settlement();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (1, 143, '2017-03-11', '2017-11-03', 43884, 1085, 744);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (2, 423, '2016-08-12', '2018-01-27', 79134, 1724, 552);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (3, 442, '2017-02-24', '2018-01-21', 70088, 1189, 473);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (4, 486, '2018-08-07', '2018-01-16', 38543, 1181, 515);",
      "INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\") VALUES (5, 621, '2017-08-27', '2018-02-04', 57669, 1427, 617);"
    ],
    "summary": "Create a PostgreSQL trigger function named insert_payment_on_settlement that runs AFTER INSERT on the Settlements table. It declares a bigint variable next_payment_id, sets it to the maximum Payment_ID from the Payments table (or 0) plus one, and inserts a row into the Payments table. The row's values are: next_payment_id, NEW.Settlement_ID, 'MasterCard', CURRENT_DATE, and NEW.Amount_Settled. The function returns NEW.",
    "natural_language": "Alright, so we need a trigger function for PostgreSQL, call it 'insert_payment_on_settlement'. It should kick in right after we add a new record to the Settlements table. Here's what it's gotta do: grab the biggest Payment_ID from the Payments table (or start at 0 if it's empty), add one to it, and stash that number in a variable called next_payment_id. Then, it inserts a fresh row into the Payments table using that new ID, the new settlement's ID, 'MasterCard' as the method, today's date, and the settled amount from the new settlement. Finally, just hand back the NEW record. Got it?",
    "id": 20,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_payment_on_settlement` that declares a local variable `next_payment_id` of type bigint, computes a new unique payment identifier by querying the `Payments` table for the maximum value in the `Payment_ID` column using the `COALESCE` function to substitute zero if no maximum exists, increments that result by one, and stores it into `next_payment_id`, and then performs an INSERT into the `Payments` table, populating the columns `Payment_ID`, `Settlement_ID`, `Payment_Method_Code`, `Date_Payment_Made`, and `Amount_Payment` with the values from the `next_payment_id` variable, `NEW.Settlement_ID`, the literal string 'MasterCard', the `CURRENT_DATE`, and `NEW.Amount_Settled`, respectively, and finally returns the `NEW` row.\nSecond, define the trigger `trg_insert_payment_on_settlement` on table `Settlements` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named insert_payment_on_settlement that is executed automatically after each new row is inserted into the Settlements table, and within this function, first declare a local variable next_payment_id of type bigint, then compute a new unique payment identifier by querying the Payments table for the current maximum value in the Payment_ID column, using the COALESCE function to substitute zero if no maximum exists, and incrementing that result by one, storing the outcome into the next_payment_id variable, and subsequently perform an INSERT operation into the Payments table, specifying the columns Payment_ID, Settlement_ID, Payment_Method_Code, Date_Payment_Made, and Amount_Payment, and populating them with the values from the next_payment_id variable, the NEW.Settlement_ID value from the triggering Settlements row, the literal string 'MasterCard', the current date from the CURRENT_DATE function, and the NEW.Amount_Settled value from the triggering Settlements row, respectively, and finally return the NEW row record to the trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_student_count_on_city_delete that deletes all rows from the \"Direct_distance\" table where the city1_code column equals the OLD.city_code value or the city2_code column equals the OLD.city_code value, and then deletes all rows from the \"Student\" table where the city_code column equals the OLD.city_code value, after which it returns the OLD row record.\nSecond, define the trigger trg_update_student_count_on_city_delete on table \"City\" that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_student_count_on_city_delete() RETURNS TRIGGER AS $$\nBEGIN\n  -- Delete related rows in Direct_distance first to maintain referential integrity\n  DELETE FROM \"Direct_distance\" WHERE city1_code = OLD.city_code OR city2_code = OLD.city_code;\n  \n  -- Delete related students\n  DELETE FROM \"Student\" WHERE city_code = OLD.city_code;\n  \n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_student_count_on_city_delete\nBEFORE DELETE ON \"City\"\nFOR EACH ROW EXECUTE FUNCTION update_student_count_on_city_delete();",
    "database_name": "address_1",
    "tables": [
      "City",
      "Direct_distance",
      "Student"
    ],
    "call_sqls": [
      "DELETE FROM \"City\" WHERE city_code = 'BAL';",
      "DELETE FROM \"City\" WHERE city_code = 'PIT';",
      "DELETE FROM \"City\" WHERE city_code = 'PHL';",
      "DELETE FROM \"City\" WHERE city_code = 'NYC';",
      "DELETE FROM \"City\" WHERE city_code = 'ATL';"
    ],
    "summary": "Create a PostgreSQL BEFORE DELETE trigger function named update_student_count_on_city_delete. For each deleted City row, delete related records from Direct_distance where city1_code or city2_code equals OLD.city_code, then delete related records from Student where city_code equals OLD.city_code. Return OLD.",
    "natural_language": "How can I create a PostgreSQL BEFORE DELETE trigger function called update_student_count_on_city_delete that, for each City row being deleted, first removes related records from the Direct_distance table where city1_code or city2_code matches OLD.city_code, and then removes related records from the Student table where city_code matches OLD.city_code, before finally returning OLD?",
    "id": 21,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named update_student_count_on_city_delete in the address_1 database. This function is a trigger function that returns a trigger. It is executed automatically by a trigger defined on the City table. The trigger is a BEFORE DELETE trigger, meaning it fires for each row before the deletion operation on the City table is performed. The function uses the OLD special record variable, which represents the City row that is about to be deleted.\n\nWithin the function, the first operation is a DELETE operation on the Direct_distance table. It deletes all rows from the Direct_distance table where the city1_code column matches the OLD.city_code value from the City row being deleted, or where the city2_code column matches the OLD.city_code value. This removes all distance records associated with the city being deleted, regardless of whether the city appears as city1 or city2 in the Direct_distance table.\n\nThe second operation is another DELETE operation, this time on the Student table. It deletes all rows from the Student table where the city_code column matches the OLD.city_code value from the City row being deleted. This removes all student records associated with the city being deleted.\n\nAfter performing these two DELETE operations, the function concludes by returning the OLD record. This return value allows the original DELETE operation on the City table to proceed, deleting the City row itself.\n\nSecond, define the trigger on the City table. The trigger should be named to fire before each DELETE operation on the City table for each row. It executes the update_student_count_on_city_delete function.",
    "original_ir": "Write a PostgreSQL trigger function named update_student_count_on_city_delete that returns a trigger and is executed by a trigger named trg_update_student_count_on_city_delete, which is defined to fire BEFORE DELETE on the City table for each row being deleted, where the function performs two cascading delete operations: first, it deletes all rows from the Direct_distance table where the city1_code column equals the OLD.city_code value from the deleted City row or where the city2_code column equals the OLD.city_code value, and second, it deletes all rows from the Student table where the city_code column equals the OLD.city_code value, after which the function returns the OLD row record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_song_title_on_album_insert that updates the \"Title\" column in the \"Songs\" table to its uppercase version using the UPPER() function, specifically for the row where the \"SongId\" matches the NEW.\"SongId\" from the trigger.\nSecond, define the trigger tracklist_insert_trigger on table \"Tracklists\" that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_song_title_on_album_insert() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Songs\" SET \"Title\" = UPPER(\"Title\") WHERE \"SongId\" = NEW.\"SongId\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER tracklist_insert_trigger\nAFTER INSERT ON \"Tracklists\"\nFOR EACH ROW EXECUTE FUNCTION update_song_title_on_album_insert();",
    "database_name": "music_2",
    "tables": [
      "Albums",
      "Band",
      "Instruments",
      "Performance",
      "Songs",
      "Tracklists",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (1, 'song one');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (101, 1, 1);",
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (2, 'another song');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (101, 2, 2);",
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (3, 'third track');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (102, 1, 3);",
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (4, 'a short tune');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (103, 1, 4);",
      "INSERT INTO \"Songs\" (\"SongId\", \"Title\") VALUES (5, 'final song');\nINSERT INTO \"Tracklists\" (\"AlbumId\", \"Position\", \"SongId\") VALUES (103, 2, 5);"
    ],
    "summary": "Create an AFTER INSERT trigger function on the \"Tracklists\" table. For each new row, update the \"Songs\" table, setting the \"Title\" to UPPER(\"Title\") where the \"SongId\" matches the new row's \"SongId\". Return the NEW record.",
    "natural_language": "Alright, so every time a new tracklist entry gets added, I need you to set up a trigger that fires right after. This trigger's job is to go into the Songs table and change the song title to all caps, but only for the song whose ID matches the one in the new tracklist row. Just make sure the whole thing spits back the new record that was just inserted.",
    "id": 22,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named update_song_title_on_album_insert, which is executed by a trigger after each insert operation on the tracklists table. The function takes no parameters and returns a trigger type. Upon invocation, it performs an update operation on the Songs table, specifically targeting the row where the SongId column matches the SongId value from the newly inserted row in the tracklists table (referenced as NEW.SongId). The update sets the Title column in the Songs table to the uppercase version of its current value, using the UPPER function to transform the existing title text. The function concludes by returning the NEW record, which represents the row that was just inserted into the tracklists table, allowing the insert operation to proceed normally. Second, define the trigger on the tracklists table to fire after each insert, executing the update_song_title_on_album_insert function for every affected row.",
    "original_ir": "Write a PLpgSQL function that is triggered after a new row is inserted into the \"Tracklists\" table, which updates the \"Title\" column in the \"Songs\" table to its uppercase version for the row where the \"SongId\" matches the \"SongId\" of the newly inserted row in the \"Tracklists\" table. The function does not take any parameters directly, but operates on the implicit NEW record provided by the trigger, which represents the newly inserted row. The trigger named \"tracklist_insert_trigger\" is defined to execute this function after each insert operation on the \"Tracklists\" table, ensuring that every time a new tracklist entry is added, the corresponding song title in the \"Songs\" table is converted to uppercase using the UPPER() function, which is a built-in SQL function that transforms a given string to uppercase letters. The function returns the NEW record, allowing the trigger to complete its operation without altering the inserted data in the \"Tracklists\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_language_on_country_delete` that deletes all rows from the `official_languages` table where the `country_id` matches the `OLD.id` from the `countries` table and then returns the `OLD` record.\nSecond, define the trigger `trg_delete_language` on table `countries` that fires `BEFORE` `DELETE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_language_on_country_delete() RETURNS TRIGGER AS $$\nBEGIN\nDELETE FROM official_languages WHERE country_id = OLD.id;\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_language\nBEFORE DELETE ON countries\nFOR EACH ROW EXECUTE FUNCTION delete_language_on_country_delete();",
    "database_name": "country_language",
    "tables": [
      "countries",
      "languages",
      "official_languages"
    ],
    "call_sqls": [
      "DELETE FROM countries WHERE id = 1;",
      "DELETE FROM countries WHERE name = 'Sweden';",
      "DELETE FROM countries WHERE overall_score < 97.0;",
      "DELETE FROM countries WHERE id IN (2, 3);",
      "DELETE FROM countries WHERE justice_score IS NULL;"
    ],
    "summary": "Create a BEFORE DELETE trigger function on the countries table. For each row to be deleted, first delete all rows from the official_languages table where the country_id matches the OLD.id. Return the OLD record.",
    "natural_language": "Construct a BEFORE DELETE trigger function designed for the countries table. For every individual row that is slated for deletion, it is essential to first meticulously remove all corresponding entries from the official_languages table where the country_id precisely matches the OLD.id value. Subsequently, the function must return the complete OLD record.",
    "id": 23,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_language_on_country_delete` that deletes all rows from the `official_languages` table where the `country_id` matches the `OLD.id` from the `countries` table and then returns the `OLD` record.\nSecond, define the trigger `trg_delete_language` on table `countries` that fires `BEFORE` `DELETE` and executes the function.",
    "original_ir": "Write a PLpgSQL function that is triggered before a row is deleted from the countries table, which deletes all rows from the official_languages table where the country_id matches the id of the row being deleted from the countries table. The function delete_language_on_country_delete does not take any parameters directly but operates using the OLD record, which represents the row that is about to be deleted from the countries table. The OLD record contains the id column, which is used to identify the corresponding rows in the official_languages table that need to be deleted. The function returns the OLD record after performing the deletion operation. The trigger named trg_delete_language is defined to execute this function before a delete operation occurs on each row of the countries table, ensuring that any official languages associated with the country being deleted are also removed from the official_languages table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_dog_weight` that uses a CASE statement to evaluate the `NEW.weight` column from the \"Dogs\" table: it explicitly casts `NEW.weight` to NUMERIC, sets it to the string '0.5' if the cast value is less than 0.5, sets it to the string '100' if the cast value is greater than 100, and otherwise leaves it unchanged, finally returning the modified `NEW` row.\nSecond, define the trigger `trg_validate_dog_weight` on table \"Dogs\" that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_dog_weight() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.weight := CASE \n        WHEN CAST(NEW.weight AS NUMERIC) < 0.5 THEN '0.5'\n        WHEN CAST(NEW.weight AS NUMERIC) > 100 THEN '100'\n        ELSE NEW.weight\n    END;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_dog_weight\n    BEFORE INSERT OR UPDATE ON \"Dogs\"\n    FOR EACH ROW\n    EXECUTE FUNCTION validate_dog_weight();",
    "database_name": "dog_kennels",
    "tables": [
      "Breeds",
      "Charges",
      "Dogs",
      "Owners",
      "Professionals",
      "Sizes",
      "Treatment_Types",
      "Treatments"
    ],
    "call_sqls": [
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (4, 2, '0', 'HUS', 'MED', 'Buddy', '5', '2015-06-15 10:00:00+08:00', '1', '0.3', '2023-10-01 10:00:00+08:00', NULL, NULL);",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (5, 3, '1', 'BUL', 'LGE', 'Max', '7', '2016-04-20 10:00:00+08:00', '0', '150', '2023-10-02 10:00:00+08:00', NULL, NULL);",
      "UPDATE \"Dogs\" SET weight = '0.2' WHERE dog_id = 1;",
      "UPDATE \"Dogs\" SET weight = '120' WHERE dog_id = 2;",
      "INSERT INTO \"Dogs\" (dog_id, owner_id, abandoned_yn, breed_code, size_code, name, age, date_of_birth, gender, weight, date_arrived, date_adopted, date_departed) VALUES (6, 1, '0', 'ESK', 'SML', 'Charlie', '3', '2020-01-10 10:00:00+08:00', '1', '0.4', '2023-10-03 10:00:00+08:00', NULL, NULL);"
    ],
    "summary": "Create a PostgreSQL trigger function named validate_dog_weight that fires BEFORE INSERT OR UPDATE on the Dogs table for each row. It validates the NEW.weight value: if less than 0.5, set it to '0.5'; if greater than 100, set it to '100'. The function returns the modified NEW row.",
    "natural_language": "Create trigger function validate_dog_weight for Dogs table. Before insert or update per row, cap NEW.weight: min 0.5, max 100. Return NEW.",
    "id": 24,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_dog_weight` that uses a CASE statement to evaluate the `NEW.weight` column from the \"Dogs\" table: it explicitly casts `NEW.weight` to NUMERIC, sets it to the string '0.5' if the cast value is less than 0.5, sets it to the string '100' if the cast value is greater than 100, and otherwise leaves it unchanged, finally returning the modified `NEW` row.\nSecond, define the trigger `trg_validate_dog_weight` on table \"Dogs\" that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named validate_dog_weight that returns a trigger and is executed automatically by a trigger named trg_validate_dog_weight, which is defined to fire BEFORE any INSERT or UPDATE operation on the table named \"Dogs\" for each individual row being processed; the function's logic operates on the NEW row variable, specifically its weight column, and uses a CASE statement to evaluate and potentially modify the weight value: first, it explicitly casts the NEW.weight value to the NUMERIC data type and checks if it is less than 0.5, and if this condition is true, it sets the NEW.weight value to the string '0.5'; if the first condition is false, it proceeds to check if the cast NUMERIC value of NEW.weight is greater than 100, and if this condition is true, it sets NEW.weight to the string '100'; if neither condition is met, it leaves the NEW.weight value unchanged, and finally, the function returns the modified NEW row record to the triggering statement."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `create_band_record` that, upon a trigger event, inserts a new row into the `\"Band\"` table, setting the `\"Id\"` column to the value of `NEW.\"Bandmate\"`, the `\"Firstname\"` column to the string `'Unknown'`, and the `\"Lastname\"` column to the string `'Musician'`, and then returns `NEW`.\nSecond, define the trigger `performance_band_trigger` on table `\"Performance\"` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION create_band_record() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Band\" (\"Id\", \"Firstname\", \"Lastname\") VALUES (NEW.\"Bandmate\", 'Unknown', 'Musician');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER performance_band_trigger\nAFTER INSERT ON \"Performance\"\nFOR EACH ROW EXECUTE FUNCTION create_band_record();",
    "database_name": "music_2",
    "tables": [
      "Band",
      "Songs",
      "Instruments",
      "Performance",
      "Vocals"
    ],
    "call_sqls": [
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (1, 101, 'Center Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (2, 102, 'Left Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (3, 103, 'Right Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (4, 104, 'Back Stage');",
      "INSERT INTO \"Performance\" (\"SongId\", \"Bandmate\", \"StagePosition\") VALUES (5, 105, 'Front Stage');"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger function named create_band_record that inserts a new row into the \"Band\" table. Set \"Id\" to NEW.\"Bandmate\", \"Firstname\" to 'Unknown', and \"Lastname\" to 'Musician'. Return NEW. Associate this function with a trigger named performance_band_trigger on the \"Performance\" table.",
    "natural_language": "Create trigger performance_band_trigger on Performance. After insert, run create_band_record. It inserts into Band: Id from NEW.Bandmate, Firstname 'Unknown', Lastname 'Musician'. Return NEW.",
    "id": 25,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `create_band_record`. This function is designed to be executed after an `INSERT` operation on the `Performance` table. It returns a `TRIGGER` type, indicating it is a trigger function. The function implicitly receives the special variable `NEW`, which represents the new row being inserted into the `Performance` table.\n\nThe function's primary purpose is to insert a new record into the `Band` table. Specifically, it inserts values into the `Id`, `Firstname`, and `Lastname` columns. For the `Id` column, it uses the value from `NEW.Bandmate`, which is the `Bandmate` value from the row just inserted into the `Performance` table. For the `Firstname` column, it sets the value to the string literal `'Unknown'`. For the `Lastname` column, it sets the value to the string literal `'Musician'`. After performing this `INSERT` operation, the function returns `NEW`, which is standard behavior for `AFTER` row-level triggers in PostgreSQL.\n\nSecond, define the trigger `performance_band_trigger` on the `Performance` table. This trigger is configured to activate `AFTER INSERT` operations on the `Performance` table. It is a `FOR EACH ROW` trigger, meaning the `create_band_record` function will be executed once for every row that is inserted into the `Performance` table. The `EXECUTE FUNCTION create_band_record()` clause specifies that the `create_band_record` function should be invoked when the trigger fires.",
    "original_ir": "Write a PLpgSQL trigger function that, upon the insertion of a new row into the \"Performance\" table, automatically inserts a new row into the \"Band\" table. This new row in the \"Band\" table will have its \"Id\" column set to the value of the \"Bandmate\" column from the newly inserted row in the \"Performance\" table. The \"Firstname\" column of the new \"Band\" row will be set to the string 'Unknown', and the \"Lastname\" column will be set to the string 'Musician'. The trigger is named \"performance_band_trigger\" and is defined to execute the \"create_band_record\" function after each row is inserted into the \"Performance\" table. The function does not take any parameters and returns the newly inserted row in the \"Performance\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function archive_manufacturer_delete that inserts a new row into the \"Manufacturers\" table using values from the OLD record, specifically setting \"Code\" to OLD.\"Code\" multiplied by -1, \"Name\" to the string 'ARCHIVED: ' concatenated with OLD.\"Name\", \"Headquarter\" to OLD.\"Headquarter\", \"Founder\" to OLD.\"Founder\", and \"Revenue\" to OLD.\"Revenue\" multiplied by -1.0, then returns OLD.\nSecond, define the trigger trg_manufacturers_after_delete on table \"Manufacturers\" that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_manufacturer_delete() RETURNS TRIGGER AS $$\nBEGIN\nINSERT INTO \"Manufacturers\" (\"Code\", \"Name\", \"Headquarter\", \"Founder\", \"Revenue\") VALUES (OLD.\"Code\" * -1, 'ARCHIVED: ' || OLD.\"Name\", OLD.\"Headquarter\", OLD.\"Founder\", OLD.\"Revenue\" * -1.0);\nRETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_manufacturers_after_delete\nAFTER DELETE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION archive_manufacturer_delete();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers"
    ],
    "call_sqls": [
      "DELETE FROM \"Manufacturers\" WHERE \"Code\" = 1;",
      "DELETE FROM \"Manufacturers\" WHERE \"Name\" = 'Creative Labs';",
      "DELETE FROM \"Manufacturers\" WHERE \"Headquarter\" = 'Tokyo';",
      "DELETE FROM \"Manufacturers\" WHERE \"Founder\" = 'Andy';",
      "DELETE FROM \"Manufacturers\" WHERE \"Revenue\" = 120.0;"
    ],
    "summary": "Create an AFTER DELETE trigger function named archive_manufacturer_delete for the Manufacturers table. For each deleted row, insert a new row into the Manufacturers table with the Code and Revenue values negated, and the Name prefixed with 'ARCHIVED: '. Return the OLD record.",
    "natural_language": "How can I create an AFTER DELETE trigger function called archive_manufacturer_delete for the Manufacturers table that, for each deleted row, inserts a new row into the same table with the Code and Revenue values negated and the Name prefixed with 'ARCHIVED: ', and then returns the OLD record?",
    "id": 26,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named archive_manufacturer_delete in the manufactory_1 database. This function is an AFTER DELETE row-level trigger function that operates on the Manufacturers table. The function takes no explicit parameters but has access to the OLD record, which represents the state of the deleted row before deletion. The function declares no variables. For each deleted row, the function performs an INSERT operation into the same Manufacturers table. The inserted row uses the OLD record's values with specific modifications: the Code column value is set to the negation of OLD.Code (e.g., if OLD.Code was 1, it becomes -1), the Name column value is set to the string 'ARCHIVED: ' concatenated with OLD.Name (e.g., if OLD.Name was 'Sony', it becomes 'ARCHIVED: Sony'), and the Revenue column value is set to the negation of OLD.Revenue (e.g., if OLD.Revenue was 120.0, it becomes -120.0). The Headquarter and Founder columns are inserted with their original values from the OLD record (OLD.Headquarter and OLD.Founder, respectively). After the INSERT operation, the function returns the OLD record. Second, define the trigger named archive_manufacturer_delete_trigger on the Manufacturers table to automatically execute the archive_manufacturer_delete function after any DELETE operation on the table for each row.",
    "original_ir": "Write a PostgreSQL trigger function named archive_manufacturer_delete that is executed automatically by a trigger named trg_manufacturers_after_delete, which is defined to fire AFTER a DELETE operation on the table named \"Manufacturers\" for each individual row that is deleted; this function takes no explicit parameters but implicitly receives the OLD record representing the deleted row's state; the function performs a single INSERT operation into the same \"Manufacturers\" table, specifically inserting a new row with the following column values: for the \"Code\" column, it inserts the original OLD.\"Code\" value multiplied by negative one, for the \"Name\" column, it inserts a string formed by concatenating the literal prefix 'ARCHIVED: ' with the original OLD.\"Name\" value, for the \"Headquarter\" column, it inserts the original OLD.\"Headquarter\" value, for the \"Founder\" column, it inserts the original OLD.\"Founder\" value, and for the \"Revenue\" column, it inserts the original OLD.\"Revenue\" value multiplied by negative 1.0; the function then returns the OLD record, which is the standard behavior for an AFTER DELETE trigger."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_set_default_order_date` that sets the `order_date` column of the `NEW` row to the current date using `CURRENT_DATE` and then returns `NEW`.\nSecond, define the trigger `default_date_before_order_insert` on table `\"Customer_Orders\"` that fires `BEFORE` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_set_default_order_date() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"order_date\" = CURRENT_DATE;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER default_date_before_order_insert\nBEFORE INSERT ON \"Customer_Orders\"\nFOR EACH ROW EXECUTE FUNCTION trg_set_default_order_date();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (101, 1, 'Pending');",
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (102, 2, 'Completed');",
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (103, 3, 'Shipped');",
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (104, 4, 'Cancelled');",
      "INSERT INTO \"Customer_Orders\" (order_id, customer_id, order_status_code) VALUES (105, 5, 'Processing');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named trg_set_default_order_date for the Customer_Orders table. For each new row, set the NEW.order_date column to the current date (CURRENT_DATE) if it is not already provided.",
    "natural_language": "Define a BEFORE INSERT trigger function called trg_set_default_order_date on the Customer_Orders table to set the NEW.order_date to CURRENT_DATE whenever a new row is inserted without a date.",
    "id": 27,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `trg_set_default_order_date`. This function is designed to be executed as a trigger before an insert operation on the `Customer_Orders` table. The function takes no explicit input parameters but operates within the context of a trigger, meaning it implicitly receives special variables like `NEW` and `OLD`. Since this is a `BEFORE INSERT` trigger, only the `NEW` record is available, representing the row that is about to be inserted. The function's purpose is to conditionally set a default value for the `order_date` column. Specifically, it checks if the `order_date` column in the `NEW` record is `NULL`. If it is `NULL`, the function assigns the current date to `NEW.order_date` using the `CURRENT_DATE` function, which returns the current date as a `date` data type. Since the `order_date` column is defined as `timestamp with time zone`, the `date` value from `CURRENT_DATE` is implicitly cast to a `timestamp with time zone` with the time portion set to `00:00:00` and the time zone set to the session's time zone. If `NEW.order_date` is not `NULL`, meaning a date value is already provided in the insert statement, the function leaves it unchanged. After this conditional modification, the function returns the `NEW` record, which then becomes the row that is actually inserted into the `Customer_Orders` table.\n\nSecond, define the trigger named `trg_set_default_order_date` on the `Customer_Orders` table. This trigger is configured to activate `BEFORE INSERT` operations on the `Customer_Orders` table. The `FOR EACH ROW` clause specifies that the trigger function `trg_set_default_order_date()` will be executed once for each row that is inserted into the `Customer_Orders` table. The `EXECUTE FUNCTION trg_set_default_order_date()` clause indicates that the previously defined `trg_set_default_order_date` function should be invoked when the trigger fires. Therefore, whenever a new row is inserted into the `Customer_Orders` table, this trigger will automatically set the `order_date` column to the current date if no date value is explicitly provided in the insert statement, ensuring that the `order_date` column always has a valid timestamp value.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_set_default_order_date` that is designed to be executed before an `INSERT` operation on the `\"Customer_Orders\"` table. This function does not accept any explicit parameters. Upon execution, it sets the value of the `order_date` column for the new row being inserted (`NEW.\"order_date\"`) to the current date, which is obtained using the `CURRENT_DATE` function. After this assignment, the function returns the modified new row (`NEW`), allowing the `INSERT` operation to proceed with the `order_date` column populated. This trigger function is then associated with a trigger named `default_date_before_order_insert`. This trigger is configured to activate `BEFORE INSERT` operations on the `\"Customer_Orders\"` table. It is set to execute `FOR EACH ROW`, meaning the `trg_set_default_order_date` function will be invoked once for every row that is being inserted into the `\"Customer_Orders\"` table. The purpose of this trigger is to automatically populate the `order_date` column with the current date whenever a new order record is inserted into the `\"Customer_Orders\"` table, ensuring that the `order_date` is never null and always reflects the date of insertion."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_pet_age that updates the Pets table by incrementing the pet_age column by one for the row where the PetID matches the NEW.PetID from the Has_Pet table.\nSecond, define the trigger pet_age_update on table Has_Pet that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_pet_age() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Pets\"\n  SET \"pet_age\" = \"pet_age\" + 1\n  WHERE \"PetID\" = NEW.\"PetID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER pet_age_update\nAFTER INSERT ON \"Has_Pet\"\nFOR EACH ROW EXECUTE FUNCTION update_pet_age();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1001, 2001);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1002, 2002);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1003, 2003);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1001, 2002);",
      "INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\") VALUES (1002, 2003);"
    ],
    "summary": "Create an AFTER INSERT trigger function named update_pet_age on the Has_Pet table. For each new row, update the Pets table by incrementing pet_age by 1 where PetID equals NEW.PetID. Return NEW.",
    "natural_language": "Alright, so I need you to set up a trigger that kicks in after we add a new record to the Has_Pet table. Name this trigger function \"update_pet_age\". Basically, every time a new row is inserted, it should go and bump up the pet_age by 1 in the Pets table, but only for the PetID that matches the NEW.PetID from the insert. Don't forget to have it return NEW at the end.",
    "id": 28,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `update_pet_age` that is designed to be executed as a trigger. This function does not accept any explicit input parameters but operates on the `NEW` record, which represents the row being inserted into the `Has_Pet` table when the associated trigger fires. The function returns a `TRIGGER` type, indicating its role as a trigger function. The core logic of the function involves performing an `UPDATE` operation on the `Pets` table. Specifically, it updates the `pet_age` column by incrementing its current value by 1. This update is applied only to the row in the `Pets` table where the `PetID` column matches the `PetID` value from the `NEW` record (i.e., the `PetID` of the newly inserted row in the `Has_Pet` table). The `UPDATE` statement uses the syntax `UPDATE Pets SET pet_age = pet_age + 1 WHERE PetID = NEW.PetID`. After this update operation, the function returns the `NEW` record.\n\nSecond, define the trigger `trg_update_pet_age` on table `Has_Pet`. This trigger is configured to execute `AFTER INSERT` operations on the `Has_Pet` table. It is a `FOR EACH ROW` trigger, meaning it will execute the `update_pet_age()` function once for every row that is inserted into the `Has_Pet` table. The `EXECUTE FUNCTION update_pet_age()` clause specifies that the `update_pet_age` function should be invoked when the trigger fires.",
    "original_ir": "Write a PostgreSQL trigger function named update_pet_age that returns a trigger, which is automatically executed by a trigger named pet_age_update defined on the Has_Pet table; the trigger is configured to fire after a new row is inserted into the Has_Pet table for each inserted row, and the function's logic performs an update operation on the Pets table, specifically incrementing the pet_age column value by one for the single row in the Pets table where the PetID column value exactly matches the PetID column value from the newly inserted row (referenced as NEW.PetID) in the Has_Pet table, and the function concludes by returning the NEW row record to the calling trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `trg_cascade_delete_items` that performs a DELETE operation on the `\"Order_Items\"` table, targeting rows where the `\"order_id\"` column matches the `OLD.\"order_id\"` value from the triggering row, and then returns the `OLD` row. Second, define the trigger `delete_items_before_order_delete` on table `\"Customer_Orders\"` that fires BEFORE DELETE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_cascade_delete_items() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Order_Items\" WHERE \"order_id\" = OLD.\"order_id\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_items_before_order_delete\nBEFORE DELETE ON \"Customer_Orders\"\nFOR EACH ROW EXECUTE FUNCTION trg_cascade_delete_items();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 1;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 2;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 3;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 8;",
      "DELETE FROM \"Customer_Orders\" WHERE order_id = 13;"
    ],
    "summary": "Create a trigger function `trg_cascade_delete_items` that deletes rows from the \"Order_Items\" table where the order_id matches the order_id of the row being deleted from the \"Customer_Orders\" table. The function returns the OLD row. Create a BEFORE DELETE FOR EACH ROW trigger named `delete_items_before_order_delete` on the \"Customer_Orders\" table to execute this function.",
    "natural_language": "Set up a trigger that, before removing a customer order, gets rid of any related order items. The trigger should work for each order being deleted and handle the cleanup automatically. Also, make sure the function involved gives back the old order details.",
    "id": 29,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `trg_cascade_delete_items` that performs a DELETE operation on the `\"Order_Items\"` table, targeting rows where the `\"order_id\"` column matches the `OLD.\"order_id\"` value from the triggering row, and then returns the `OLD` row. Second, define the trigger `delete_items_before_order_delete` on table `\"Customer_Orders\"` that fires BEFORE DELETE for each row and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function named `trg_cascade_delete_items` that is designed to be executed in response to a data manipulation event on a table, and a trigger named `delete_items_before_order_delete` that invokes this function. The `trg_cascade_delete_items` function does not accept any explicit parameters beyond the implicit trigger context. When executed, this function performs a `DELETE` operation on the `\"Order_Items\"` table. The `DELETE` operation targets rows in `\"Order_Items\"` where the value in the `\"order_id\"` column of `\"Order_Items\"` is equal to the value of the `\"order_id\"` column from the row that is currently being processed by the triggering event. After the `DELETE` operation is completed, the function returns the `OLD` row, which represents the state of the row in the triggering table before the triggering event occurred. The `delete_items_before_order_delete` trigger is defined to activate `BEFORE DELETE` operations on the `\"Customer_Orders\"` table. This trigger is configured to execute `FOR EACH ROW` that is being deleted from `\"Customer_Orders\"`. For each such row, the trigger executes the `trg_cascade_delete_items()` function."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_catalog_entry_name` that modifies the `NEW.catalog_entry_name` column by prepending the literal string 'Updated ' (including a trailing space) to its existing value using the concatenation operator (`||`).\nSecond, define the trigger `trg_update_catalog_entry_name` on table `\"Catalog_Contents\"` that fires BEFORE UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_catalog_entry_name() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.catalog_entry_name := 'Updated ' || NEW.catalog_entry_name;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_catalog_entry_name\nBEFORE UPDATE ON \"Catalog_Contents\"\nFOR EACH ROW EXECUTE FUNCTION update_catalog_entry_name();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'New Cola' WHERE catalog_entry_id = 1;",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'New Root beer' WHERE catalog_entry_id = 2;",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'New Cream Soda' WHERE catalog_entry_id = 3;",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'Another Cola' WHERE catalog_entry_id = 1;",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'Another Root beer' WHERE catalog_entry_id = 2;"
    ],
    "summary": "Create a PostgreSQL trigger function named update_catalog_entry_name that runs BEFORE UPDATE on the Catalog_Contents table. For each updated row, it prepends the string 'Updated ' to the NEW.catalog_entry_name column value and returns the modified NEW row.",
    "natural_language": "Make a trigger function for PostgreSQL called update_catalog_entry_name that activates BEFORE an UPDATE happens on the Catalog_Contents table. For any row that gets changed, it should kind of add the text 'Updated ' to the front of whatever is in the NEW.catalog_entry_name field, and then give back the adjusted NEW row.",
    "id": 30,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_catalog_entry_name` that modifies the `NEW.catalog_entry_name` column by prepending the literal string 'Updated ' (including a trailing space) to its existing value using the concatenation operator (`||`).\nSecond, define the trigger `trg_update_catalog_entry_name` on table `\"Catalog_Contents\"` that fires BEFORE UPDATE for each row and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_catalog_entry_name that returns a trigger and is executed by a trigger named trg_update_catalog_entry_name, which is defined to fire BEFORE UPDATE on the table named \"Catalog_Contents\" for each row being updated; the function has no explicit input parameters but implicitly accesses the special OLD and NEW row variables representing the row's state before and after the update; within the function's logic, for every row update operation, it modifies the NEW.catalog_entry_name column value by performing a string concatenation operation using the concatenation operator (||), prepending the literal string 'Updated ' (including a trailing space) to the existing value of the NEW.catalog_entry_name column from the incoming update, and then assigns this newly formed string back to the NEW.catalog_entry_name column; the function concludes by returning the modified NEW row record, thereby allowing the triggered update operation to proceed with the altered column data."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_job_history_on_department_change` that inserts a new record into the `job_history` table, populating the `EMPLOYEE_ID` column with the old `EMPLOYEE_ID` value, the `START_DATE` column with the old `HIRE_DATE` value, the `END_DATE` column with the result of the `CURRENT_DATE` function, the `JOB_ID` column with the old `JOB_ID` value, and the `DEPARTMENT_ID` column with the old `DEPARTMENT_ID` value from the `employees` row.\nSecond, define the trigger `trg_update_job_history_on_department_change` on table `employees` that fires BEFORE UPDATE of the `DEPARTMENT_ID` column and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_job_history_on_department_change() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO job_history (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\") \n  VALUES (OLD.\"EMPLOYEE_ID\", OLD.\"HIRE_DATE\", CURRENT_DATE, OLD.\"JOB_ID\", OLD.\"DEPARTMENT_ID\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_job_history_on_department_change\nBEFORE UPDATE OF \"DEPARTMENT_ID\" ON employees\nFOR EACH ROW EXECUTE FUNCTION update_job_history_on_department_change();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history",
      "locations"
    ],
    "call_sqls": [
      "UPDATE employees SET DEPARTMENT_ID = 20 WHERE EMPLOYEE_ID = 100;",
      "UPDATE employees SET DEPARTMENT_ID = 30 WHERE EMPLOYEE_ID = 101;",
      "UPDATE employees SET DEPARTMENT_ID = 40 WHERE EMPLOYEE_ID = 102;",
      "UPDATE employees SET DEPARTMENT_ID = 50 WHERE EMPLOYEE_ID = 103;",
      "UPDATE employees SET DEPARTMENT_ID = 60 WHERE EMPLOYEE_ID = 104;"
    ],
    "summary": "Create a BEFORE UPDATE trigger function for the \"employees\" table. When the \"DEPARTMENT_ID\" column is updated, the function inserts a record into the \"job_history\" table containing the old employee details (EMPLOYEE_ID, HIRE_DATE as START_DATE, JOB_ID, DEPARTMENT_ID) and the current date as END_DATE.",
    "natural_language": "Write a BEFORE UPDATE trigger function for the \"employees\" table that, upon updating the \"DEPARTMENT_ID\" column, inserts a record into the \"job_history\" table with the old employee details (EMPLOYEE_ID, HIRE_DATE as START_DATE, JOB_ID, DEPARTMENT_ID) and sets the END_DATE to the current date.",
    "id": 31,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `update_job_history_on_department_change`. This function is defined to return a trigger and uses PL/pgSQL language. It is designed to be executed as a `BEFORE UPDATE` trigger on the `employees` table within the `hr_1` database.\n\nThe function begins by declaring a variable `v_hire_date` of type `DATE` to temporarily store the hire date of the employee being updated. No other variables are declared.\n\nThe trigger function's logic activates only when the `DEPARTMENT_ID` column of the row in the `employees` table is being updated. This is determined by checking if the `NEW.DEPARTMENT_ID` is different from the `OLD.DEPARTMENT_ID`. If they are equal, the function does nothing and proceeds to return the `NEW` row.\n\nIf the `DEPARTMENT_ID` is being changed, the function performs a `SELECT` operation on the `employees` table. It retrieves the `HIRE_DATE` for the specific employee by querying where `EMPLOYEE_ID` equals `OLD.EMPLOYEE_ID`. The result is stored into the `v_hire_date` variable.\n\nFollowing this, the function executes an `INSERT` operation into the `job_history` table. The inserted record includes the following columns and values:\n- `EMPLOYEE_ID`: set to `OLD.EMPLOYEE_ID` from the `employees` table row before the update.\n- `START_DATE`: set to the value of `v_hire_date` (the employee's original hire date).\n- `END_DATE`: set to the current date, obtained using the `CURRENT_DATE` function.\n- `JOB_ID`: set to `OLD.JOB_ID` from the `employees` table row before the update.\n- `DEPARTMENT_ID`: set to `OLD.DEPARTMENT_ID` from the `employees` table row before the update.\n\nThis insertion creates a historical record capturing the employee's job and department assignment before the change, with the end date marked as the date of the update.\n\nAfter the `INSERT` operation, the function returns the `NEW` row, allowing the update on the `employees` table to proceed with the new `DEPARTMENT_ID` value.\n\nSecond, define the trigger named `trg_update_job_history_on_department_change` on the `employees` table. This trigger is configured to fire `BEFORE UPDATE` on the `employees` table. It is a row-level trigger, specified with `FOR EACH ROW`, meaning it executes once for each row updated. The trigger calls the `update_job_history_on_department_change()` function.",
    "original_ir": "Write a PostgreSQL trigger function named update_job_history_on_department_change that returns a trigger and is executed by a trigger named trg_update_job_history_on_department_change, which is defined to fire BEFORE an UPDATE operation on the DEPARTMENT_ID column of the employees table for each affected row; the function's logic is to insert a new record into the job_history table, populating its columns with specific values: the EMPLOYEE_ID column receives the old EMPLOYEE_ID value from the employees row, the START_DATE column receives the old HIRE_DATE value from the employees row, the END_DATE column receives the result of the CURRENT_DATE function call which provides the current date, the JOB_ID column receives the old JOB_ID value from the employees row, and the DEPARTMENT_ID column receives the old DEPARTMENT_ID value from the employees row; after performing this insert, the function returns the NEW row record to the triggering UPDATE statement."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function remove_customer_data that deletes all records from the \"Customer_Payments\" table where the \"customer_id\" column matches the OLD.\"customer_id\" from the row being deleted and then returns the OLD record.\nSecond, define the trigger customer_cleanup_trigger on table \"Customers\" that fires BEFORE DELETE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_customer_data() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"Customer_Payments\" WHERE \"customer_id\" = OLD.\"customer_id\";\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER customer_cleanup_trigger\nBEFORE DELETE ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION remove_customer_data();",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Payments",
      "Lessons",
      "Staff"
    ],
    "call_sqls": [
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 1;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 2;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 3;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 11;",
      "DELETE FROM \"Customers\" WHERE \"customer_id\" = 14;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named remove_customer_data on the Customers table. For each row to be deleted, delete all records from the Customer_Payments table where the customer_id matches the OLD.customer_id. Return OLD.",
    "natural_language": "How can I create a BEFORE DELETE trigger function called remove_customer_data for the Customers table that, for each row being deleted, removes all records from the Customer_Payments table where the customer_id matches the OLD.customer_id and then returns OLD?",
    "id": 32,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration for the driving_school database. First, create a trigger function named remove_customer_data that returns a trigger and is executed before a delete operation on the Customers table for each row. The function performs a delete operation on the Customer_Payments table, removing all rows where the customer_id column matches the OLD.customer_id value from the row being deleted in the Customers table. After the deletion, the function returns the OLD row record. Second, define the trigger trg_remove_customer_data on the Customers table, set to execute the remove_customer_data function for each row before a delete operation.",
    "original_ir": "Write a PLpgSQL trigger function that is executed before a row is deleted from the \"Customers\" table. This function, named remove_customer_data, does not take any parameters and is designed to perform a specific operation: it deletes all records from the \"Customer_Payments\" table where the \"customer_id\" column matches the \"customer_id\" of the row being deleted from the \"Customers\" table. The function uses the OLD keyword to reference the \"customer_id\" of the row that is about to be deleted. After performing the delete operation on the \"Customer_Payments\" table, the function returns the OLD record, which is the default behavior for a trigger function that is executed before a delete operation. The trigger, named customer_cleanup_trigger, is defined to execute this function for each row that is deleted from the \"Customers\" table, ensuring that any associated payment records are removed from the \"Customer_Payments\" table before the customer record itself is deleted."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function insert_default_company_for_station that inserts a row into the \"station_company\" table using values from the NEW record, specifically NEW.\"Station_ID\" for the \"Station_ID\" column, a static 1 for the \"Company_ID\" column, and a calculated value for the \"Rank_of_the_Year\" column using EXTRACT(YEAR FROM CURRENT_DATE) - NEW.\"Open_Year\" + 1, and then returns NEW. Second, define the trigger gas_station_insert_trigger on table \"gas_station\" that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_default_company_for_station() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (NEW.\"Station_ID\", 1, EXTRACT(YEAR FROM CURRENT_DATE) - NEW.\"Open_Year\" + 1);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER gas_station_insert_trigger\n    AFTER INSERT ON \"gas_station\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_default_company_for_station();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (4, 2001, 'Central Park', 'John Doe', 'Jane Smith', 'Alice Johnson');",
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (5, 2002, 'Downtown', 'Michael Brown', 'Sarah Davis', 'Tom Wilson');",
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (6, 2003, 'Uptown', 'Chris Green', 'Laura White', 'Emma Thompson');",
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (7, 2004, 'Suburbia', 'David Black', 'Emily Clark', 'Oliver King');",
      "INSERT INTO \"gas_station\" (\"Station_ID\", \"Open_Year\", \"Location\", \"Manager_Name\", \"Vice_Manager_Name\", \"Representative_Name\") VALUES (8, 2005, 'Industrial Area', 'Daniel Harris', 'Sophia Lewis', 'Liam Scott');"
    ],
    "summary": "Create a PostgreSQL trigger function named insert_default_company_for_station that fires AFTER INSERT on the gas_station table for each row. It inserts a row into the station_company table with Station_ID from NEW.Station_ID, Company_ID as 1, and Rank_of_the_Year calculated as (EXTRACT(YEAR FROM CURRENT_DATE) - NEW.Open_Year + 1), then returns the NEW record.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as 'insert_default_company_for_station'. This function is to be executed subsequent to an INSERT operation on the 'gas_station' table for each individual row. Its operation shall involve the insertion of a new record into the 'station_company' table. The values for this insertion are to be assigned as follows: the 'Station_ID' column shall receive the value from 'NEW.Station_ID'; the 'Company_ID' column shall be set to the integer 1; and the 'Rank_of_the_Year' column shall be derived from the calculation (EXTRACT(YEAR FROM CURRENT_DATE) - NEW.Open_Year + 1). Upon completion of this insertion, the function must return the 'NEW' record.",
    "id": 33,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named insert_default_company_for_station in the gas_company database, which returns a trigger type. This function is executed automatically by a trigger named trg_insert_default_company_for_station after every insert operation on the gas_station table for each individual row inserted. The function uses the special record variable NEW to access the newly inserted row's column values. It performs an INSERT operation into the station_company table with three column assignments: the Station_ID column is set to the value of NEW.Station_ID from the gas_station table, the Company_ID column is set to the integer constant 1, and the Rank_of_the_Year column is set to the result of the calculation (EXTRACT(YEAR FROM CURRENT_DATE) - NEW.Open_Year + 1), where EXTRACT(YEAR FROM CURRENT_DATE) retrieves the current year as an integer, NEW.Open_Year is the Open_Year value from the newly inserted gas_station row, and 1 is added to the difference. After the INSERT operation completes, the function returns the NEW record to the triggering insert statement. Second, define the trigger trg_insert_default_company_for_station on the gas_station table to fire after insert on each row, executing the insert_default_company_for_station function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `insert_default_company_for_station` that is designed to be executed as a trigger. This function takes no explicit input parameters but operates within the context of a trigger, meaning it has access to special record variables `NEW` and `OLD`. Specifically, it utilizes the `NEW` record, which represents the new row being inserted into the table that the trigger is associated with. The function is declared to return a `TRIGGER` type, which is a standard requirement for functions intended to be used as trigger functions in PostgreSQL. The core operation performed by this function is an `INSERT` statement into the table named `\"station_company\"`. This `INSERT` statement populates three columns: `\"Station_ID\"`, `\"Company_ID\"`, and `\"Rank_of_the_Year\"`. The value for the `\"Station_ID\"` column is derived from `NEW.\"Station_ID\"`, which refers to the value of the `\"Station_ID\"` column from the newly inserted row in the triggering table. The value for the `\"Company_ID\"` column is a static integer literal `1`. The value for the `\"Rank_of_the_Year\"` column is calculated dynamically. This calculation involves first extracting the year component from the current date using the `EXTRACT(YEAR FROM CURRENT_DATE)` function. From this current year, the value of `NEW.\"Open_Year\"` (the \"Open_Year\" column from the newly inserted row in the triggering table) is subtracted. Finally, `1` is added to this result. After performing this `INSERT` operation, the function returns the `NEW` record, which is a standard practice for `AFTER INSERT` triggers to indicate that the operation was successful and to pass the modified (or original) new row back to the calling context.\n\nFollowing the function definition, a trigger named `gas_station_insert_trigger` is created. This trigger is configured to activate `AFTER INSERT` operations on the table named `\"gas_station\"`. The `FOR EACH ROW` clause specifies that the trigger function `insert_default_company_for_station()` should be executed once for each row that is inserted into the `\"gas_station\"` table. The `EXECUTE FUNCTION insert_default_company_for_station()` clause specifies that the previously defined PL/pgSQL function `insert_default_company_for_station` should be invoked when the trigger fires. Therefore, whenever a new row is successfully inserted into the `\"gas_station\"` table, this trigger will automatically execute the `insert_default_company_for_station` function, which in turn inserts a corresponding record into the `\"station_company\"` table, linking the newly inserted gas station to a default company (Company_ID 1) and calculating a rank based on its opening year relative to the current year."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_order_total` that updates the `order_details` column in the `\"Orders\"` table for the row where `order_id` matches the `NEW.order_id` from the trigger context. The update sets `order_details` to a string aggregated by `string_agg`, concatenating the `product_name` from the `\"Products\"` table and the `product_quantity` from the `\"Order_Items\"` table in the format 'product_name (product_quantity)', separated by commas. This is achieved by joining the `\"Order_Items\"` and `\"Products\"` tables on `product_id` and filtering where `\"Order_Items\".order_id` equals `NEW.order_id`.\nSecond, define the trigger `trg_order_items_update` on table `\"Order_Items\"` that fires AFTER INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_total() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Orders\" \n    SET order_details = (\n        SELECT string_agg(\"Products\".product_name || ' (' || \"Order_Items\".product_quantity || ')', ', ') \n        FROM \"Order_Items\" \n        JOIN \"Products\" ON \"Order_Items\".product_id = \"Products\".product_id \n        WHERE \"Order_Items\".order_id = NEW.order_id\n    ) \n    WHERE \"Orders\".order_id = NEW.order_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_order_items_update\nAFTER INSERT OR UPDATE ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION update_order_total();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Order_Items",
      "Products",
      "Product_Categories"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (100, 1, 4, '2');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (101, 1, 10, '1');",
      "UPDATE \"Order_Items\" SET product_quantity = '3' WHERE order_item_id = 100;",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (102, 2, 5, '5');",
      "UPDATE \"Order_Items\" SET product_id = 10 WHERE order_item_id = 102;"
    ],
    "summary": "Create a trigger function named update_order_total that, after each row is inserted or updated in the Order_Items table, updates the order_details column in the Orders table. For the matching order_id, set order_details to a comma-separated string of 'product_name (product_quantity)' by aggregating data from the joined Order_Items and Products tables.",
    "natural_language": "How can I create a trigger function called update_order_total that, after any row is inserted or updated in the Order_Items table, updates the order_details column in the Orders table? For the matching order_id, it should set order_details to a comma-separated string of 'product_name (product_quantity)' by aggregating data from the joined Order_Items and Products tables.",
    "id": 34,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_order_total` that updates the `order_details` column in the `\"Orders\"` table for the row where `order_id` matches the `NEW.order_id` from the trigger context. The update sets `order_details` to a string aggregated by `string_agg`, concatenating the `product_name` from the `\"Products\"` table and the `product_quantity` from the `\"Order_Items\"` table in the format 'product_name (product_quantity)', separated by commas. This is achieved by joining the `\"Order_Items\"` and `\"Products\"` tables on `product_id` and filtering where `\"Order_Items\".order_id` equals `NEW.order_id`.\nSecond, define the trigger `trg_order_items_update` on table `\"Order_Items\"` that fires AFTER INSERT OR UPDATE for each row and executes the function.",
    "original_ir": "Write a PLpgSQL function named update_order_total that is designed to be executed as a trigger. This function does not take any parameters directly but operates on the NEW record provided by the trigger context. The function updates the order_details column in the Orders table for the row where the order_id matches the order_id of the NEW record from the Order_Items table. The update operation involves setting the order_details column to a concatenated string of product names and their respective quantities, formatted as 'product_name (product_quantity)', separated by commas. This concatenation is achieved using the string_agg function, which aggregates the product_name from the Products table and the product_quantity from the Order_Items table. The function performs a SELECT operation to retrieve the product_name from the Products table by joining it with the Order_Items table on the product_id column, ensuring that only items related to the specific order_id of the NEW record are considered. The trigger named trg_order_items_update is created to execute this function after any INSERT or UPDATE operation on the Order_Items table, ensuring that the order_details in the Orders table is updated whenever the Order_Items table is modified. The trigger is defined to execute for each row affected by the INSERT or UPDATE operation, thereby maintaining the order details in real-time as changes occur in the Order_Items table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_department_ranking_on_budget_change` that updates the `department` table by setting the `Ranking` column for the row where `Department_ID` matches `NEW.Department_ID`. The new ranking is calculated as one plus the count of rows in the `department` table where the `Budget_in_Billions` is greater than `NEW.Budget_in_Billions`. The function must return `NEW`.\nSecond, define the trigger `adjust_ranking_after_budget_update` on table `department` that fires AFTER UPDATE of the `Budget_in_Billions` column and executes the function for each row.",
    "plsql": "CREATE OR REPLACE FUNCTION update_department_ranking_on_budget_change() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE department SET \"Ranking\" = (SELECT COUNT(*) FROM department WHERE \"Budget_in_Billions\" > NEW.\"Budget_in_Billions\") + 1 WHERE \"Department_ID\" = NEW.\"Department_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER adjust_ranking_after_budget_update\nAFTER UPDATE OF \"Budget_in_Billions\" ON department\nFOR EACH ROW EXECUTE FUNCTION update_department_ranking_on_budget_change();",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "UPDATE department SET \"Budget_in_Billions\" = 10.0 WHERE \"Department_ID\" = 1;",
      "UPDATE department SET \"Budget_in_Billions\" = 12.0 WHERE \"Department_ID\" = 2;",
      "UPDATE department SET \"Budget_in_Billions\" = 440.0 WHERE \"Department_ID\" = 3;",
      "UPDATE department SET \"Budget_in_Billions\" = 15.0 WHERE \"Department_ID\" = 1;",
      "UPDATE department SET \"Budget_in_Billions\" = 13.0 WHERE \"Department_ID\" = 2;"
    ],
    "summary": "Create a trigger function `update_department_ranking_on_budget_change` and a trigger `adjust_ranking_after_budget_update`. The trigger fires AFTER UPDATE OF Budget_in_Billions on the department table FOR EACH ROW. The function updates the department table, setting the Ranking column for the matching Department_ID to: 1 + (the count of departments with a Budget_in_Billions greater than the NEW row's budget). The function returns NEW.",
    "natural_language": "Create a trigger that, after a department's budget is updated, re-ranks it based on the new budget compared to others.",
    "id": 35,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_department_ranking_on_budget_change` that updates the `department` table by setting the `Ranking` column for the row where `Department_ID` matches `NEW.Department_ID`. The new ranking is calculated as one plus the count of rows in the `department` table where the `Budget_in_Billions` is greater than `NEW.Budget_in_Billions`. The function must return `NEW`.\nSecond, define the trigger `adjust_ranking_after_budget_update` on table `department` that fires AFTER UPDATE of the `Budget_in_Billions` column and executes the function for each row.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `update_department_ranking_on_budget_change` that is designed to be executed as a trigger, and a trigger named `adjust_ranking_after_budget_update` that invokes this function. The function `update_department_ranking_on_budget_change` is defined to return a `TRIGGER` type, indicating its role as a trigger function. Upon execution, this function performs a single `UPDATE` operation on the `department` table. The `UPDATE` statement targets a specific row in the `department` table where the `Department_ID` column matches the `Department_ID` value of the `NEW` record (the row currently being updated by the triggering statement). For this targeted row, the `Ranking` column is set to a new calculated value. This new value is determined by a subquery that counts the number of rows in the `department` table where the `Budget_in_Billions` column is strictly greater than the `Budget_in_Billions` value of the `NEW` record. To the result of this count, `1` is added. This effectively assigns a rank to the department based on its budget relative to other departments, where a higher budget results in a lower (better) rank. After performing this update, the function returns the `NEW` record, which is standard behavior for `BEFORE` or `AFTER` row-level triggers in PostgreSQL. The `adjust_ranking_after_budget_update` trigger is defined to activate `AFTER UPDATE` operations on the `department` table. Specifically, it is configured to fire only when the `Budget_in_Billions` column of a row in the `department` table is updated. This is a `FOR EACH ROW` trigger, meaning the `update_department_ranking_on_budget_change` function will be executed once for each row that is affected by the `UPDATE` statement that modifies the `Budget_in_Billions` column. The trigger's purpose is to automatically recalculate and adjust the `Ranking` of a department whenever its `Budget_in_Billions` value changes, ensuring that the ranking reflects the current budget distribution among departments."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function delete_account_transactions that deletes all rows from the \"Financial_Transactions\" table where the account_id column matches the OLD.account_id from the row being deleted. Second, define the trigger trg_delete_account_transactions on table \"Accounts\" that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_account_transactions() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Financial_Transactions\" WHERE account_id = OLD.account_id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_account_transactions\n    BEFORE DELETE ON \"Accounts\"\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_account_transactions();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoices",
      "Invoice_Line_Items",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "DELETE FROM \"Accounts\" WHERE account_id = 1;",
      "DELETE FROM \"Accounts\" WHERE account_id = 2;",
      "DELETE FROM \"Accounts\" WHERE account_id = 3;",
      "DELETE FROM \"Accounts\" WHERE account_id = 4;",
      "DELETE FROM \"Accounts\" WHERE account_id = 5;"
    ],
    "summary": "Create a trigger function named delete_account_transactions and a trigger named trg_delete_account_transactions. The function, executed BEFORE DELETE on the Accounts table for each row, deletes all rows from the Financial_Transactions table where the account_id matches the ID of the account being deleted. The function returns OLD.",
    "natural_language": "Please implement a trigger function designated as 'delete_account_transactions' along with an associated trigger named 'trg_delete_account_transactions'. This function is to be invoked BEFORE a DELETE operation on the Accounts table for each individual row. Its purpose is to remove all corresponding entries from the Financial_Transactions table where the account_id corresponds to the ID of the account slated for deletion. The function shall return the OLD record.",
    "id": 36,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named delete_account_transactions that returns a trigger and is executed by a trigger named trg_delete_account_transactions, which is defined to fire BEFORE a DELETE operation on the Accounts table for each individual row being deleted. The function performs a cascading delete operation: it deletes all rows from the Financial_Transactions table where the account_id column value matches the account_id value from the OLD record (the row being deleted from the Accounts table). After this deletion, the function returns the OLD row record.",
    "original_ir": "Write a PLpgSQL trigger function that is invoked before a row is deleted from the \"Accounts\" table. The function, named delete_account_transactions, does not take any parameters directly but operates using the OLD record, which represents the row being deleted from the \"Accounts\" table. The function performs a DELETE operation on the \"Financial_Transactions\" table, removing all rows where the account_id column matches the account_id of the OLD record from the \"Accounts\" table. This ensures that all financial transactions associated with the account being deleted are also removed. The function then returns the OLD record, which is standard practice for trigger functions to allow the deletion operation on the \"Accounts\" table to proceed. The trigger, named trg_delete_account_transactions, is defined to execute this function before any DELETE operation on the \"Accounts\" table, ensuring that the associated transactions are cleaned up prior to the account's removal."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function delete_photos_on_mountain_delete that deletes rows from the photos table where the mountain_id column equals the OLD.id value from the deleted mountain row and then returns OLD.\nSecond, define the trigger trg_delete_photos_on_mountain_delete on table mountain that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_photos_on_mountain_delete() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM photos WHERE mountain_id = OLD.id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_photos_on_mountain_delete\n    BEFORE DELETE ON mountain\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_photos_on_mountain_delete();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "DELETE FROM mountain WHERE id = 1;",
      "DELETE FROM mountain WHERE id = 2;",
      "DELETE FROM mountain WHERE id = 3;",
      "DELETE FROM mountain WHERE id = 4;",
      "DELETE FROM mountain WHERE id = 5;"
    ],
    "summary": "Create a BEFORE DELETE trigger function for the mountain table. For each row being deleted, delete all rows from the photos table where photos.mountain_id equals OLD.id. Return OLD.",
    "natural_language": "Set up a trigger that runs before a mountain entry is removed. When that happens, also get rid of any photo records that seem to be linked to that specific mountain. Just make sure the original mountain data is what gets passed back.",
    "id": 37,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `delete_photos_on_mountain_delete`. This function is a trigger function that does not accept any explicit parameters but operates implicitly with the `OLD` record provided by the trigger mechanism. It returns a `TRIGGER` type, indicating its role as a trigger function. The function is designed to execute before a row is deleted from the `mountain` table in the `mountain_photos` database.\n\nWithin the function, a single SQL operation is performed: a `DELETE` statement targeting the `photos` table. This `DELETE` statement removes all rows from the `photos` table where the `mountain_id` column matches the `id` column value from the `OLD` record, which represents the mountain row being deleted. This ensures that any photo records linked to that specific mountain via the foreign key relationship (`photos.mountain_id = mountain.id`) are also removed, maintaining referential integrity by cleaning up dependent records before the mountain deletion proceeds.\n\nAfter executing the `DELETE` operation, the function returns the `OLD` row, which is the original mountain data being deleted. This return value is standard for `BEFORE DELETE` triggers to allow the deletion to proceed with the passed-back row.\n\nSecond, define the trigger named `trg_delete_photos_on_mountain_delete` on the `mountain` table. This trigger is configured to execute `BEFORE` a `DELETE` operation on the `mountain` table. The `FOR EACH ROW` clause specifies that the trigger function runs once for each row being deleted. When activated, the trigger `EXECUTE FUNCTION delete_photos_on_mountain_delete()`, thereby invoking the trigger function to delete all linked photo records before the mountain row is removed from the database.",
    "original_ir": "Write a PL/pgSQL trigger function named `delete_photos_on_mountain_delete` that is designed to be executed in response to a specific database event. This function does not accept any explicit input parameters in its signature, but as a trigger function, it implicitly receives special variables representing the old and new states of the row being affected by the triggering event. Specifically, it accesses `OLD.id`, which represents the value of the `id` column from the row *before* it was deleted from the `mountain` table. The function performs a single operation: it executes a `DELETE` statement on the `photos` table. The `DELETE` operation targets rows in the `photos` table where the value in the `mountain_id` column is equal to the value of `OLD.id`. After performing this deletion, the function returns `OLD`, which is a special trigger variable representing the row that was deleted from the `mountain` table.\n\nThis trigger function is then associated with a trigger named `trg_delete_photos_on_mountain_delete`. This trigger is configured to activate `BEFORE DELETE` operations on the `mountain` table. The `FOR EACH ROW` clause specifies that the trigger function `delete_photos_on_mountain_delete` will be executed once for each individual row that is being deleted from the `mountain` table. The `EXECUTE FUNCTION delete_photos_on_mountain_delete()` clause explicitly calls the previously defined trigger function to perform its logic. Therefore, whenever a row is deleted from the `mountain` table, this trigger will automatically execute the `delete_photos_on_mountain_delete` function *before* the actual deletion of the mountain row occurs, leading to the deletion of all associated photos from the `photos` table where the `mountain_id` matches the `id` of the mountain being deleted."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_gymnast_total` that calculates the `Total_Points` for the `NEW` record by summing the values of `Floor_Exercise_Points`, `Pommel_Horse_Points`, `Rings_Points`, `Vault_Points`, `Parallel_Bars_Points`, and `Horizontal_Bar_Points`, using `COALESCE` to treat any NULL values as zero, and then returns the modified `NEW` record.\nSecond, define the trigger `update_gymnast_total_trigger` on table `gymnast` that fires `BEFORE` `INSERT OR UPDATE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_gymnast_total() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"Total_Points\" = COALESCE(NEW.\"Floor_Exercise_Points\", 0) + COALESCE(NEW.\"Pommel_Horse_Points\", 0) + COALESCE(NEW.\"Rings_Points\", 0) + COALESCE(NEW.\"Vault_Points\", 0) + COALESCE(NEW.\"Parallel_Bars_Points\", 0) + COALESCE(NEW.\"Horizontal_Bar_Points\", 0);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_gymnast_total_trigger\n    BEFORE INSERT OR UPDATE ON gymnast\n    FOR EACH ROW\n    EXECUTE FUNCTION update_gymnast_total();\n\n-- Example of using ON CONFLICT to handle duplicate keys\nINSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (10, 9.5, 9.6, 9.7, 9.8, 9.9, 9.4)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (1, 9.725, 9.737, 9.512, 9.575, 9.762, 9.75)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (2, 9.7, 9.625, 9.625, 9.65, 9.587, 9.737)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (4, 8.987, 9.75, 9.75, 9.575, 9.787, 9.725)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (5, 9.8, 9.6, 9.7, 9.9, 9.85, 9.65)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\")\nVALUES (6, 9.9, 9.8, 9.85, 9.75, 9.7, 9.8)\nON CONFLICT (\"Gymnast_ID\") DO UPDATE\nSET \"Floor_Exercise_Points\" = EXCLUDED.\"Floor_Exercise_Points\",\n    \"Pommel_Horse_Points\" = EXCLUDED.\"Pommel_Horse_Points\",\n    \"Rings_Points\" = EXCLUDED.\"Rings_Points\",\n    \"Vault_Points\" = EXCLUDED.\"Vault_Points\",\n    \"Parallel_Bars_Points\" = EXCLUDED.\"Parallel_Bars_Points\",\n    \"Horizontal_Bar_Points\" = EXCLUDED.\"Horizontal_Bar_Points\";"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function named update_gymnast_total on the gymnast table. For each row, calculate the Total_Points by summing the COALESCE values of Floor_Exercise_Points, Pommel_Horse_Points, Rings_Points, Vault_Points, Parallel_Bars_Points, and Horizontal_Bar_Points (treating NULL as 0). Assign the result to NEW.Total_Points and return NEW.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE trigger function called update_gymnast_total for the gymnast table that calculates the Total_Points by adding together the Floor_Exercise_Points, Pommel_Horse_Points, Rings_Points, Vault_Points, Parallel_Bars_Points, and Horizontal_Bar_Points (treating any NULL values as zero) and then assigns this sum to NEW.Total_Points before returning NEW?",
    "id": 38,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function update_gymnast_total in the gymnast database. This function is a trigger function written in PL/pgSQL language, defined to return a trigger type. It does not accept any explicit parameters but operates implicitly on the special record variables NEW and OLD provided by the trigger context. The function is designed to execute before an INSERT or UPDATE operation on each row of the gymnast table.\n\nWithin the function, the primary operation is to calculate a sum and assign it to a field in the NEW record. The calculation involves adding together the values from six specific columns of the NEW record: Floor_Exercise_Points, Pommel_Horse_Points, Rings_Points, Vault_Points, Parallel_Bars_Points, and Horizontal_Bar_Points. Each of these column values is of the real data type. The function must handle potential NULL values in any of these columns by treating them as zero for the purpose of the addition. This is achieved by using the COALESCE function on each column reference, which returns the column's value if it is not NULL, or returns zero if it is NULL.\n\nThe logic proceeds as follows: The function computes the expression COALESCE(NEW.Floor_Exercise_Points, 0) + COALESCE(NEW.Pommel_Horse_Points, 0) + COALESCE(NEW.Rings_Points, 0) + COALESCE(NEW.Vault_Points, 0) + COALESCE(NEW.Parallel_Bars_Points, 0) + COALESCE(NEW.Horizontal_Bar_Points, 0). This expression yields a single real number representing the total points. The function then assigns the result of this calculation to the Total_Points column of the NEW record (i.e., NEW.Total_Points). No variables are explicitly declared within the function; the calculation and assignment are performed directly. After the assignment, the function returns the modified NEW record, which will be used for the subsequent INSERT or UPDATE operation.\n\nSecond, define the trigger itself on the gymnast table. The trigger is associated with the update_gymnast_total function. It is configured to fire before an INSERT or UPDATE operation occurs on the gymnast table. The trigger is set to execute for each row (FOR EACH ROW), meaning the function logic runs individually for every row that is being inserted or updated. The trigger ensures that whenever a row is inserted into or updated in the gymnast table, the Total_Points column is automatically populated or recalculated as the sum of the six specified apparatus points, with NULLs handled as zeros.",
    "original_ir": "Write a PLpgSQL function named update_gymnast_total that is designed to be used as a trigger function. This function does not take any parameters directly but operates on the NEW record, which represents the row being inserted or updated in the gymnast table. The function calculates the total points for a gymnast by summing up the individual event points: Floor_Exercise_Points, Pommel_Horse_Points, Rings_Points, Vault_Points, Parallel_Bars_Points, and Horizontal_Bar_Points. For each of these columns, the function uses the COALESCE function to treat any NULL values as zero, ensuring that the sum is computed correctly even if some event points are missing. The result of this summation is assigned to the Total_Points column of the NEW record. The function then returns the modified NEW record. A trigger named update_gymnast_total_trigger is created to automatically invoke this function before any insert or update operation on the gymnast table. This trigger ensures that the Total_Points column is always up-to-date with the sum of the individual event points whenever a row is inserted or updated. Additionally, an example insert statement is provided, which attempts to insert a new row into the gymnast table with specified points for each event. If a row with the same Gymnast_ID already exists, the ON CONFLICT clause updates the existing row's event points with the new values provided in the insert statement, ensuring that the gymnast's scores are always current."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_country_language_on_coaster_update` that updates the `country` table by appending the string ' Coaster' to the existing value in the `\"Languages\"` column for the row where the `\"Country_ID\"` matches the `NEW.\"Country_ID\"` from the updated `roller_coaster` row, using the concatenation operator `||`, and returns the `NEW` row.\nSecond, define the trigger `trg_update_language_on_coaster_update` on table `roller_coaster` that fires `AFTER UPDATE OF \"Name\"` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_country_language_on_coaster_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE country SET \"Languages\" = \"Languages\" || ' Coaster' WHERE \"Country_ID\" = NEW.\"Country_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_language_on_coaster_update\n    AFTER UPDATE OF \"Name\" ON roller_coaster\n    FOR EACH ROW\n    EXECUTE FUNCTION update_country_language_on_coaster_update();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "UPDATE roller_coaster SET \"Name\" = 'New Name 1' WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE roller_coaster SET \"Name\" = 'New Name 2' WHERE \"Roller_Coaster_ID\" = 2;",
      "UPDATE roller_coaster SET \"Name\" = 'New Name 3' WHERE \"Roller_Coaster_ID\" = 3;",
      "UPDATE roller_coaster SET \"Name\" = 'New Name 4' WHERE \"Roller_Coaster_ID\" = 1;",
      "UPDATE roller_coaster SET \"Name\" = 'New Name 5' WHERE \"Roller_Coaster_ID\" = 2;"
    ],
    "summary": "Create a trigger function named `update_country_language_on_coaster_update` that, after the `Name` column of a row in the `roller_coaster` table is updated, appends the string ' Coaster' to the `Languages` column in the `country` table for the row matching the updated coaster's `Country_ID`. Also, create an `AFTER UPDATE OF \"Name\" FOR EACH ROW` trigger named `trg_update_language_on_coaster_update` on the `roller_coaster` table to execute this function.",
    "natural_language": "Create a trigger function called `update_country_language_on_coaster_update`. After a `Name` update in the `roller_coaster` table, have it append ' Coaster' to the `Languages` column in the `country` table for the matching `Country_ID`. Then, set up an `AFTER UPDATE OF \"Name\" FOR EACH ROW` trigger named `trg_update_language_on_coaster_update` on the `roller_coaster` table to run this function.",
    "id": 39,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_country_language_on_coaster_update` that updates the `country` table by appending the string ' Coaster' to the existing value in the `\"Languages\"` column for the row where the `\"Country_ID\"` matches the `NEW.\"Country_ID\"` from the updated `roller_coaster` row, using the concatenation operator `||`, and returns the `NEW` row.\nSecond, define the trigger `trg_update_language_on_coaster_update` on table `roller_coaster` that fires `AFTER UPDATE OF \"Name\"` and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_country_language_on_coaster_update that returns a trigger and is executed by a trigger named trg_update_language_on_coaster_update, which is defined to fire after an update operation on the Name column of the roller_coaster table for each row that is updated; the function's logic performs an update on the country table, specifically it appends the string ' Coaster' to the existing value in the Languages column for the single row in the country table where the Country_ID column value matches the NEW.Country_ID value from the updated roller_coaster row, using the concatenation operator ||, and finally the function returns the NEW row record to the invoking trigger."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_delete_orphaned_stations` that deletes rows from the `gas_station` table where the `\"Station_ID\"` is not found in the `\"Station_ID\"` column of the `station_company` table and returns the `OLD` record.\nSecond, define the trigger `delete_orphaned_stations` on table `station_company` that fires `AFTER` `DELETE` for each statement and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_orphaned_stations() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM gas_station WHERE \"Station_ID\" NOT IN (SELECT \"Station_ID\" FROM station_company);\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_orphaned_stations\nAFTER DELETE ON station_company\nFOR EACH STATEMENT EXECUTE FUNCTION trg_delete_orphaned_stations();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM station_company WHERE \"Station_ID\" = 11;",
      "DELETE FROM station_company WHERE \"Station_ID\" = 1;",
      "DELETE FROM station_company WHERE \"Station_ID\" = 6;",
      "DELETE FROM station_company WHERE \"Station_ID\" = 2;",
      "DELETE FROM station_company WHERE \"Station_ID\" = 3;"
    ],
    "summary": "Create an AFTER DELETE trigger on the station_company table. After a delete statement, remove rows from the gas_station table where the Station_ID no longer exists in the station_company table. Return the OLD record.",
    "natural_language": "How can I create an AFTER DELETE trigger on the station_company table that removes rows from the gas_station table when their Station_ID no longer exists in station_company after a deletion, and returns the OLD record?",
    "id": 40,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named `trg_delete_orphaned_stations` that is designed to be executed as a trigger. This function does not take any explicit parameters but operates within the trigger context, providing access to the special `OLD` record, which represents the row that was deleted from the `station_company` table. The function's purpose is to delete orphaned rows from the `gas_station` table after a deletion occurs in the `station_company` table.\n\nThe function begins by declaring a variable named `orphaned_station_id` of type `INTEGER` to temporarily hold the `Station_ID` value from the deleted row. The function then performs a `DELETE` operation on the `gas_station` table. The `DELETE` statement targets rows in `gas_station` where the `Station_ID` column matches the `Station_ID` from the `OLD` record (i.e., the `Station_ID` that was just removed from `station_company`), but only if that `Station_ID` no longer exists in the `station_company` table. This condition is enforced using a subquery with a `NOT EXISTS` clause. The subquery checks the `station_company` table for any rows where the `Station_ID` column equals the `OLD.Station_ID`. If no such rows are found, the subquery returns true, indicating that the `Station_ID` is orphaned, and the corresponding row in `gas_station` is deleted. After the `DELETE` operation, the function returns the `OLD` record, which is required for trigger functions that operate in a row-level context and ensures the deletion proceeds normally.\n\nSecond, define the trigger `trg_delete_orphaned_stations_trigger` on the `station_company` table. This trigger is configured as an `AFTER DELETE` trigger, meaning it fires after a row is successfully deleted from the `station_company` table. It is a `FOR EACH ROW` trigger, so the `trg_delete_orphaned_stations` function executes once for each row deleted from `station_company`. The trigger is set to `EXECUTE FUNCTION trg_delete_orphaned_stations()`, linking it to the function. The overall logic ensures that whenever a row is deleted from `station_company`, the trigger automatically checks if the associated `Station_ID` becomes orphaned (i.e., no longer referenced in `station_company`), and if so, removes the corresponding row from the `gas_station` table to maintain data consistency, even though no explicit foreign key relationship is defined between the tables.",
    "original_ir": "Write a PLpgSQL trigger function that, upon the deletion of any row from the station_company table, executes a process to remove any rows from the gas_station table where the \"Station_ID\" column does not have a corresponding \"Station_ID\" in the station_company table. The function trg_delete_orphaned_stations is defined to perform this operation, and it is associated with a trigger named delete_orphaned_stations. This trigger is set to activate after a DELETE operation on the station_company table and is configured to execute once per statement, not per row. The function does not take any parameters and returns the OLD record, which is a standard practice in triggers to indicate the state of the data before the triggering event. The DELETE operation within the function targets the gas_station table, specifically removing entries where the \"Station_ID\" is not found in the set of \"Station_ID\" values currently present in the station_company table, effectively cleaning up any orphaned records in the gas_station table that no longer have an associated company."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_business_rates_trigger` that updates the `\"Business_Rates\"` table by setting its `cmi_cross_ref_id` column to the value of `NEW.cmi_cross_ref_id` where the `business_rates_id` column matches `NEW.council_tax_id`.\nSecond, define the trigger `update_business_rates` on table `\"Council_Tax\"` that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_business_rates_trigger() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Business_Rates\" SET cmi_cross_ref_id = NEW.cmi_cross_ref_id WHERE business_rates_id = NEW.council_tax_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_business_rates AFTER UPDATE ON \"Council_Tax\"\nFOR EACH ROW EXECUTE FUNCTION update_business_rates_trigger();",
    "database_name": "local_govt_mdm",
    "tables": [
      "Benefits_Overpayments",
      "Business_Rates",
      "CMI_Cross_References",
      "Council_Tax",
      "Customer_Master_Index",
      "Electoral_Register",
      "Parking_Fines",
      "Rent_Arrears"
    ],
    "call_sqls": [
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 105 WHERE council_tax_id = 1;",
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 106 WHERE council_tax_id = 2;",
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 107 WHERE council_tax_id = 3;",
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 108 WHERE council_tax_id = 4;",
      "UPDATE \"Council_Tax\" SET cmi_cross_ref_id = 109 WHERE council_tax_id = 5;"
    ],
    "summary": "Create an AFTER UPDATE trigger on the Council_Tax table. For each updated row, update the Business_Rates table, setting cmi_cross_ref_id to the new value where business_rates_id matches the updated council_tax_id.",
    "natural_language": "Construct a detailed AFTER UPDATE trigger to be applied to the Council_Tax table, which will, for every single row that is modified, meticulously update the corresponding entry in the Business_Rates table by setting its cmi_cross_ref_id to the freshly updated value, but only in those specific records where the business_rates_id precisely matches the updated council_tax_id from the Council_Tax table.",
    "id": 41,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named update_business_rates_trigger in the local_govt_mdm database. This function is defined to return a trigger and uses PL/pgSQL language. The function declares no explicit variables. The trigger fires AFTER an UPDATE operation on the Council_Tax table for each row that is modified. For each updated row, the function performs an UPDATE operation on the Business_Rates table. It sets the cmi_cross_ref_id column in Business_Rates to the new value of the cmi_cross_ref_id from the updated row in Council_Tax, which is accessed via the NEW record. This update is conditional, applying only to rows in the Business_Rates table where the business_rates_id column exactly matches the council_tax_id value from the NEW record of the Council_Tax table. After executing the update, the function returns the NEW record to satisfy the trigger requirement. Second, define the trigger named update_business_rates_trigger on the Council_Tax table. This trigger is set to execute the function update_business_rates_trigger after each UPDATE operation on the Council_Tax table, ensuring that corresponding Business_Rates entries are synchronized with the updated cmi_cross_ref_id based on matching IDs.",
    "original_ir": "Write a PLpgSQL trigger function that is executed after an update operation on the \"Council_Tax\" table. This function, named update_business_rates_trigger, does not take any parameters directly but operates using the implicit NEW record, which represents the new state of the row being updated in the \"Council_Tax\" table. The function performs an update operation on the \"Business_Rates\" table, setting the cmi_cross_ref_id column to the value of NEW.cmi_cross_ref_id, which is the updated value from the \"Council_Tax\" table. The update is applied to rows in the \"Business_Rates\" table where the business_rates_id column matches the NEW.council_tax_id value from the updated row in the \"Council_Tax\" table. After performing the update, the function returns the NEW record, which is standard practice for trigger functions to allow the update operation on the \"Council_Tax\" table to proceed. The trigger named update_business_rates is defined to execute this function after any update operation on the \"Council_Tax\" table, ensuring that changes in the council_tax_id and cmi_cross_ref_id columns in \"Council_Tax\" are reflected in the corresponding rows of the \"Business_Rates\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function validate_problem_exists that checks if a record with a matching problem_id exists in the \"Problems\" table for the NEW row, using a SELECT statement with the EXISTS condition, and returns NEW if found or NULL if not. Second, define the trigger validate_problem_trigger on table \"Problem_Log\" that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_problem_exists() RETURNS TRIGGER AS $$\nBEGIN\n  RETURN CASE WHEN EXISTS (SELECT 1 FROM \"Problems\" WHERE problem_id = NEW.problem_id) THEN NEW ELSE NULL END;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_problem_trigger\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION validate_problem_exists();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problems",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problem_Category_Codes"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (100, 11, 1, 'Middleware', 'Solved', NOW(), 'Test description', 'Test fix', 'Test details');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (101, 12, 2, 'GUI', 'Reported', NOW(), 'Another description', NULL, NULL);",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (102, 13, 3, 'Datatabase', 'Solved', NOW(), 'Database issue', 'Fixed index', NULL);",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (103, 14, 999, 'Middleware', 'Reported', NOW(), 'Invalid problem', NULL, NULL);",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (104, 15, 8, 'GUI', 'Solved', NOW(), 'Valid entry', 'Applied patch', 'Additional notes');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named validate_problem_exists for the Problem_Log table. It must check if the NEW.problem_id exists in the Problems table. If it exists, return NEW to allow the insert; otherwise, return NULL to prevent it.",
    "natural_language": "Construct a BEFORE INSERT trigger function, to be named validate_problem_exists, for the Problem_Log table. This function must meticulously verify whether the NEW.problem_id value is present within the Problems table. If a corresponding entry is indeed found, the function should return NEW to explicitly permit the insertion to proceed. Conversely, if no matching record exists, it must return NULL, thereby definitively blocking the operation to maintain data integrity.",
    "id": 42,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function validate_problem_exists that checks if a record with a matching problem_id exists in the \"Problems\" table for the NEW row, using a SELECT statement with the EXISTS condition, and returns NEW if found or NULL if not. Second, define the trigger validate_problem_trigger on table \"Problem_Log\" that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"Problem_Log\" table. The function, named validate_problem_exists, does not take any parameters directly but operates on the NEW record being inserted into the \"Problem_Log\" table. It checks if there is an existing record in the \"Problems\" table with a problem_id that matches the problem_id of the NEW record. This is done using a SELECT statement with the EXISTS condition, which queries the \"Problems\" table to see if any row contains the same problem_id as the NEW record. If such a record exists, the function returns the NEW record, allowing the insert operation to proceed. If no matching record is found, the function returns NULL, effectively preventing the insertion of the NEW record into the \"Problem_Log\" table. The trigger, named validate_problem_trigger, is defined to execute this function for each row before an insert operation on the \"Problem_Log\" table, ensuring that only records with a valid problem_id already present in the \"Problems\" table are inserted into the \"Problem_Log\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function trg_delete_related_proteins that deletes rows from the protein table where its Institution_id column matches the Institution_id value from the OLD record.\nSecond, define the trigger delete_related_proteins on table Institution that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_related_proteins() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"protein\" WHERE \"Institution_id\" = OLD.\"Institution_id\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_related_proteins\nAFTER DELETE ON \"Institution\"\nFOR EACH ROW EXECUTE FUNCTION trg_delete_related_proteins();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '0';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '1';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '2';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '3';",
      "DELETE FROM \"Institution\" WHERE \"Institution_id\" = '5';"
    ],
    "summary": "Create an AFTER DELETE trigger function for the \"Institution\" table named trg_delete_related_proteins. The function must delete rows from the \"protein\" table where its Institution_id equals OLD.Institution_id. The function should return OLD.",
    "natural_language": "Define an AFTER DELETE trigger function called trg_delete_related_proteins for the \"Institution\" table. Ensure the function deletes all corresponding rows from the \"protein\" table where the Institution_id matches the OLD.Institution_id and returns OLD.",
    "id": 43,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function trg_delete_related_proteins that deletes rows from the protein table where its Institution_id column matches the Institution_id value from the OLD record.\nSecond, define the trigger delete_related_proteins on table Institution that fires AFTER DELETE and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named trg_delete_related_proteins that returns a trigger, which is automatically executed as an AFTER DELETE trigger on the Institution table for each deleted row; this function performs a DELETE operation on the protein table where the value in the protein table's Institution_id column is equal to the value of the Institution_id column from the OLD record representing the deleted Institution row, and the function concludes by returning the OLD row record to the trigger execution context."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_capacity_on_value_change that conditionally updates the \"Capacity\" column in the \"Warehouses\" table: if the new \"Value\" is greater than 500 and the old \"Value\" was less than or equal to 500, decrement the \"Capacity\" by 1 for the warehouse where \"Code\" matches NEW.\"Warehouse\"; conversely, if the new \"Value\" is less than or equal to 500 and the old \"Value\" was greater than 500, increment the \"Capacity\" by 1 for that matching warehouse.\nSecond, define the trigger trg_boxes_value_change on table \"Boxes\" that fires AFTER UPDATE OF \"Value\" and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_capacity_on_value_change() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"Value\" > 500 AND OLD.\"Value\" <= 500 THEN\n        UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" - 1 WHERE \"Code\" = NEW.\"Warehouse\";\n    ELSIF NEW.\"Value\" <= 500 AND OLD.\"Value\" > 500 THEN\n        UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" + 1 WHERE \"Code\" = NEW.\"Warehouse\";\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_value_change\nAFTER UPDATE OF \"Value\" ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION update_capacity_on_value_change();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "UPDATE \"Boxes\" SET \"Value\" = 600 WHERE \"Code\" = '0MN7';",
      "UPDATE \"Boxes\" SET \"Value\" = 400 WHERE \"Warehouse\" = 3 AND \"Value\" = 600;",
      "UPDATE \"Boxes\" SET \"Value\" = 550 WHERE \"Warehouse\" = 1 AND \"Contents\" = 'Scissors';",
      "UPDATE \"Boxes\" SET \"Value\" = 500 WHERE \"Code\" = '4H8P';",
      "UPDATE \"Boxes\" SET \"Value\" = 750, \"Warehouse\" = 4 WHERE \"Code\" = '4RT3';"
    ],
    "summary": "Create an AFTER UPDATE trigger function named update_capacity_on_value_change on the Boxes table, firing when the Value column changes. If the new Value > 500 and the old Value <= 500, decrement the Capacity by 1 in the Warehouses table for the matching warehouse. If the new Value <= 500 and the old Value > 500, increment the Capacity by 1.",
    "natural_language": "Create trigger update_capacity_on_value_change after Boxes update on Value change. If Value crosses 500 threshold, adjust Warehouses.Capacity accordingly.",
    "id": 44,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_capacity_on_value_change that conditionally updates the \"Capacity\" column in the \"Warehouses\" table: if the new \"Value\" is greater than 500 and the old \"Value\" was less than or equal to 500, decrement the \"Capacity\" by 1 for the warehouse where \"Code\" matches NEW.\"Warehouse\"; conversely, if the new \"Value\" is less than or equal to 500 and the old \"Value\" was greater than 500, increment the \"Capacity\" by 1 for that matching warehouse.\nSecond, define the trigger trg_boxes_value_change on table \"Boxes\" that fires AFTER UPDATE OF \"Value\" and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_capacity_on_value_change that is executed automatically after any update operation on the \"Value\" column of the \"Boxes\" table for each modified row, which compares the new and old values of the \"Value\" column and conditionally updates the \"Capacity\" column in the \"Warehouses\" table: if the new \"Value\" is greater than 500 and the old \"Value\" was less than or equal to 500, it executes an UPDATE statement on the \"Warehouses\" table to decrement the \"Capacity\" by 1 for the specific warehouse where the \"Code\" column matches the NEW.\"Warehouse\" value from the updated box; conversely, if the new \"Value\" is less than or equal to 500 and the old \"Value\" was greater than 500, it executes an UPDATE statement on the \"Warehouses\" table to increment the \"Capacity\" by 1 for the warehouse where the \"Code\" column matches the NEW.\"Warehouse\" value."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function trg_remove_expired_addresses that deletes rows from the Customer_Addresses table where the customer_id matches NEW.customer_id and the date_to is earlier than the current timestamp obtained via CURRENT_TIMESTAMP, then returns the NEW record.\nSecond, define the trigger remove_expired_addresses on table Customers that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_remove_expired_addresses() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Customer_Addresses\" WHERE customer_id = NEW.customer_id AND date_to < CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER remove_expired_addresses\nAFTER INSERT ON \"Customers\"\nFOR EACH ROW EXECUTE FUNCTION trg_remove_expired_addresses();",
    "database_name": "department_store",
    "tables": [
      "Customers",
      "Customer_Addresses",
      "Addresses",
      "Customer_Orders"
    ],
    "call_sqls": [
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (4, 'Credit Card', '123', 'John Doe', '123 Main St', '555-1234', 'john.doe@example.com');",
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (5, 'Direct Debit', '456', 'Jane Smith', '456 Elm St', '555-5678', 'jane.smith@example.com');",
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (6, 'Credit Card', '789', 'Alice Johnson', '789 Oak St', '555-9012', 'alice.johnson@example.com');",
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (7, 'Direct Debit', '012', 'Bob Brown', '012 Pine St', '555-3456', 'bob.brown@example.com');",
      "INSERT INTO \"Customers\" (customer_id, payment_method_code, customer_code, customer_name, customer_address, customer_phone, customer_email) VALUES (8, 'Credit Card', '345', 'Charlie Black', '345 Maple St', '555-7890', 'charlie.black@example.com');"
    ],
    "summary": "Create an AFTER INSERT trigger on the Customers table. For each new row, delete records from the Customer_Addresses table where the customer_id matches and the date_to is earlier than the current timestamp.",
    "natural_language": "For each new customer added, delete any old addresses from the Customer_Addresses table where the customer_id matches and the date_to is in the past.",
    "id": 45,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration for the department_store database. First, create a trigger function named `trg_remove_expired_addresses` that returns a `TRIGGER` type. This function is designed to be executed after an `INSERT` operation on the `Customers` table. It operates within the context of a row-level trigger, meaning it has access to the special `NEW` record representing the newly inserted row in the `Customers` table. The function's primary purpose is to delete outdated address records from the `Customer_Addresses` table for the newly added customer.\n\nThe function begins by performing a `DELETE` operation on the `Customer_Addresses` table. This deletion targets rows where two conditions are met: first, the `customer_id` column in `Customer_Addresses` must exactly match the `customer_id` value from the `NEW` record (i.e., the `customer_id` of the newly inserted customer). Second, the `date_to` column in `Customer_Addresses` must be less than the current timestamp, indicating that the address association has expired. The current timestamp is obtained using the `CURRENT_TIMESTAMP` function, which provides the current date and time with time zone. After executing this conditional deletion, the function returns the `NEW` record, which is standard for `AFTER` row-level triggers in PostgreSQL to ensure the trigger chain continues correctly.\n\nSecond, define the trigger named `trg_remove_expired_addresses` on the `Customers` table. This trigger is configured to fire `AFTER INSERT` operations on the `Customers` table. It is a `FOR EACH ROW` trigger, meaning the `trg_remove_expired_addresses` function will be invoked once for every new row inserted into the `Customers` table. The trigger executes the function to automatically clean up expired addresses in the `Customer_Addresses` table whenever a new customer is added, ensuring data consistency by removing obsolete address associations for that customer.",
    "original_ir": "Write a PostgreSQL trigger function named trg_remove_expired_addresses that returns a trigger and is executed by a trigger named remove_expired_addresses, which is defined to fire automatically after every INSERT operation on the Customers table for each new row added. The function performs a DELETE operation on the Customer_Addresses table, targeting all rows where the customer_id column matches the customer_id value from the newly inserted row (accessed via the NEW record) and where the date_to column holds a timestamp that is earlier than the current date and time obtained via the CURRENT_TIMESTAMP function. After the deletion, the function returns the NEW record to the trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_validate_mountain_prominence` that checks if the NEW record's \"Prominence\" column is greater than its \"Height\" column and, if true, sets \"Prominence\" to the value of \"Height\".\nSecond, define the trigger `validate_mountain_prominence` on table \"mountain\" that fires BEFORE INSERT OR UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_mountain_prominence() RETURNS TRIGGER AS $$\nBEGIN\n    IF NEW.\"Prominence\" > NEW.\"Height\" THEN\n        NEW.\"Prominence\" := NEW.\"Height\";\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_mountain_prominence\nBEFORE INSERT OR UPDATE ON \"mountain\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_mountain_prominence();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "INSERT INTO mountain (name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES ('Test Peak', 5000.0, 6000.0, 'Test Range', 'Test Country');",
      "UPDATE mountain SET \"Prominence\" = 5500.0 WHERE name = 'Test Peak';",
      "INSERT INTO mountain (name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES ('Valid Peak', 3000.0, 1500.0, 'Valid Range', 'Valid Country');",
      "UPDATE mountain SET \"Height\" = 2500.0, \"Prominence\" = 3000.0 WHERE name = 'Valid Peak';",
      "INSERT INTO mountain (name, \"Height\", \"Prominence\", \"Range\", \"Country\") VALUES ('Zero Prominence', 1000.0, 0.0, 'Zero Range', 'Zero Country');"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger function named trg_validate_mountain_prominence for the mountain table. If the NEW.Prominence value is greater than NEW.Height, set NEW.Prominence equal to NEW.Height. Return the NEW record.",
    "natural_language": "Define a BEFORE INSERT OR UPDATE row-level trigger function called trg_validate_mountain_prominence for the mountain table. Ensure that if the NEW.Prominence value exceeds NEW.Height, you set NEW.Prominence to equal NEW.Height. Then return the NEW record.",
    "id": 46,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_validate_mountain_prominence` that checks if the NEW record's \"Prominence\" column is greater than its \"Height\" column and, if true, sets \"Prominence\" to the value of \"Height\".\nSecond, define the trigger `validate_mountain_prominence` on table \"mountain\" that fires BEFORE INSERT OR UPDATE and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_validate_mountain_prominence` that operates on the `mountain` table. This function is designed to be executed `BEFORE` an `INSERT` or `UPDATE` operation on each row of the `mountain` table. The function receives the `NEW` record, which represents the row data after the proposed `INSERT` or `UPDATE` but before it is committed to the table. Inside the function, a conditional statement checks if the value in the `Prominence` column of the `NEW` record is strictly greater than the value in the `Height` column of the same `NEW` record. Both `Prominence` and `Height` are assumed to be numeric columns. If this condition evaluates to true, the function then modifies the `NEW` record by setting the value of its `Prominence` column to the current value of its `Height` column. After this potential modification, the function returns the `NEW` record. The associated trigger, named `validate_mountain_prominence`, is configured to fire `BEFORE` any `INSERT` or `UPDATE` event on the `mountain` table, `FOR EACH ROW`, and it executes the `trg_validate_mountain_prominence` function."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function insert_round_on_member_insert that inserts a new row into the round table using values from the NEW record of the member table, specifically setting the Member_ID column to NEW.Member_ID, the Decoration_Theme column to the literal string 'New Theme', and the Rank_in_Round column to the integer 1, and then returns NEW. Second, define the trigger trg_insert_round_on_member_insert on table member that fires AFTER INSERT and executes the function insert_round_on_member_insert.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_round_on_member_insert() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO round (\"Member_ID\", \"Decoration_Theme\", \"Rank_in_Round\") VALUES (NEW.\"Member_ID\", 'New Theme', 1);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_round_on_member_insert\nAFTER INSERT ON member\nFOR EACH ROW EXECUTE FUNCTION insert_round_on_member_insert();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (4, 'Tiger Woods', 'United States', 1);",
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (5, 'Rory McIlroy', 'Northern Ireland', 2);",
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (6, 'Jordan Spieth', 'United States', 1);",
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (7, 'Dustin Johnson', 'United States', 3);",
      "INSERT INTO member (Member_ID, Name, Country, College_ID) VALUES (8, 'Brooks Koepka', 'United States', 2);"
    ],
    "summary": "Create a trigger function named insert_round_on_member_insert that fires after an insert on the member table. For the new member, insert a row into the round table with the new Member_ID, 'New Theme' for Decoration_Theme, and 1 for Rank_in_Round. Return the NEW record.",
    "natural_language": "How can I create a trigger function called insert_round_on_member_insert that executes after an insert on the member table, so that for each new member, it inserts a row into the round table using the new Member_ID, sets the Decoration_Theme to 'New Theme', sets the Rank_in_Round to 1, and then returns the NEW record?",
    "id": 47,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function insert_round_on_member_insert that inserts a new row into the round table using values from the NEW record of the member table, specifically setting the Member_ID column to NEW.Member_ID, the Decoration_Theme column to the literal string 'New Theme', and the Rank_in_Round column to the integer 1, and then returns NEW. Second, define the trigger trg_insert_round_on_member_insert on table member that fires AFTER INSERT and executes the function insert_round_on_member_insert.",
    "original_ir": "Write a PostgreSQL trigger function named insert_round_on_member_insert that is automatically executed by a trigger named trg_insert_round_on_member_insert, which is defined to fire after every insert operation on the member table for each newly inserted row, where the function performs a single insert operation into the round table, specifying the column values for the new row as follows: the Member_ID column is set to the value of the Member_ID column from the newly inserted member row (accessed via the NEW record), the Decoration_Theme column is set to the literal string value 'New Theme', and the Rank_in_Round column is set to the integer value 1, and the function concludes by returning the NEW row record to the invoking trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function insert_job_history_record that inserts a new row into the job_history table using values from the NEW record of the employees table, specifically mapping NEW.EMPLOYEE_ID to EMPLOYEE_ID, NEW.HIRE_DATE to START_DATE, the CURRENT_DATE function to END_DATE, NEW.JOB_ID to JOB_ID, and NEW.DEPARTMENT_ID to DEPARTMENT_ID, and then returns NEW.\nSecond, define the trigger job_history_record_insert on table employees that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_job_history_record() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"job_history\" (\"EMPLOYEE_ID\", \"START_DATE\", \"END_DATE\", \"JOB_ID\", \"DEPARTMENT_ID\")\n  VALUES (NEW.\"EMPLOYEE_ID\", NEW.\"HIRE_DATE\", CURRENT_DATE, NEW.\"JOB_ID\", NEW.\"DEPARTMENT_ID\");\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER job_history_record_insert\nAFTER INSERT ON \"employees\"\nFOR EACH ROW EXECUTE FUNCTION insert_job_history_record();",
    "database_name": "hr_1",
    "tables": [
      "countries",
      "departments",
      "employees",
      "job_history",
      "jobs",
      "locations",
      "regions"
    ],
    "call_sqls": [
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (207, 'John', 'Doe', 'JDOE', '515.123.4570', '2023-01-15', 'IT_PROG', 8000.00, NULL, 103, 60);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (208, 'Jane', 'Smith', 'JSMITH', '515.123.4571', '2022-05-20', 'SA_REP', 9500.00, 0.10, 145, 80);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (209, 'Peter', 'Jones', 'PJONES', '515.123.4572', '2021-11-01', 'MK_REP', 7000.00, NULL, 201, 20);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (210, 'Alice', 'Williams', 'AWILLIAMS', '515.123.4573', '2024-03-10', 'HR_REP', 6000.00, NULL, 101, 40);",
      "INSERT INTO employees (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID) VALUES (211, 'Robert', 'Brown', 'RBROWN', '515.123.4574', '2020-08-25', 'PU_CLERK', 4000.00, NULL, 114, 30);"
    ],
    "summary": "Create an AFTER INSERT trigger function for the employees table. After inserting a row, insert a record into the job_history table. Set EMPLOYEE_ID to NEW.EMPLOYEE_ID, START_DATE to NEW.HIRE_DATE, END_DATE to CURRENT_DATE, JOB_ID to NEW.JOB_ID, and DEPARTMENT_ID to NEW.DEPARTMENT_ID. Return the NEW row.",
    "natural_language": "Alright, so I need a trigger that kicks in right after we add someone new to the employees table. When that happens, we gotta also log an entry in the job_history table. Just copy over the new employee's ID, their hire date as the start date, use today's date for the end date, and grab their job ID and department ID from the new record. Finally, just hand back the new row as is.",
    "id": 48,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `insert_job_history_record` in the `hr_1` database. This function is an `AFTER INSERT` trigger function that executes automatically after a new row is inserted into the `employees` table. The function does not accept explicit parameters but implicitly accesses the special `NEW` record, which contains the values of the newly inserted row in the `employees` table. The function's purpose is to insert a corresponding record into the `job_history` table to log the employee's initial job assignment.\n\nWithin the function, an `INSERT` statement is executed on the `job_history` table. The `job_history` table has columns `EMPLOYEE_ID`, `START_DATE`, `END_DATE`, `JOB_ID`, and `DEPARTMENT_ID`. For the `EMPLOYEE_ID` column, the value is taken directly from `NEW.EMPLOYEE_ID`, which is the employee identifier from the newly inserted row in the `employees` table. For the `START_DATE` column, the value is taken directly from `NEW.HIRE_DATE`, which is the hire date of the new employee from the `employees` table. For the `END_DATE` column, the value is set to the current date using the `CURRENT_DATE` function, representing today's date. For the `JOB_ID` column, the value is taken directly from `NEW.JOB_ID`, which is the job identifier from the newly inserted row in the `employees` table. For the `DEPARTMENT_ID` column, the value is taken directly from `NEW.DEPARTMENT_ID`, which is the department identifier from the newly inserted row in the `employees` table. After performing this insertion, the function returns `NEW`, which is the newly inserted row from the `employees` table, allowing the trigger to complete its operation without modifying the original insert.\n\nSecond, define the trigger `trigger_insert_job_history_record` on the `employees` table. This trigger is configured to fire `AFTER INSERT` on the `employees` table. It is specified to execute `FOR EACH ROW`, meaning the `insert_job_history_record` function will be invoked once for every row inserted into the `employees` table. The trigger explicitly `EXECUTE FUNCTION insert_job_history_record()`, linking the insert event to the execution of the described PL/pgSQL function.",
    "original_ir": "Write a PLpgSQL function that is designed to be used as a trigger function, which automatically inserts a new record into the job_history table whenever a new row is added to the employees table. The function does not take any parameters directly, but operates using the NEW record, which is a special variable representing the row that was just inserted into the employees table. The function inserts a new row into the job_history table with the following columns: EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, and DEPARTMENT_ID. The EMPLOYEE_ID is set to the value of the EMPLOYEE_ID column from the NEW record. The START_DATE is set to the value of the HIRE_DATE column from the NEW record. The END_DATE is set to the current date, obtained using the CURRENT_DATE function, which provides the current date according to the system clock. The JOB_ID is set to the value of the JOB_ID column from the NEW record, and the DEPARTMENT_ID is set to the value of the DEPARTMENT_ID column from the NEW record. After performing the insertion into the job_history table, the function returns the NEW record, which is a standard practice in trigger functions to allow the operation that fired the trigger to proceed. The function is associated with a trigger named job_history_record_insert, which is defined to execute after an insert operation on the employees table. This trigger is specified to execute the insert_job_history_record function for each row that is inserted into the employees table, ensuring that a corresponding entry is made in the job_history table for every new employee record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `remove_product_from_order` that performs a DELETE on the \"Order_Items\" table where the `order_id` matches `NEW.order_id` and the `product_id` is found within an array. This array is created by using `array_remove` on the static bigint array `ARRAY[1, 2, 3]` to exclude the `NEW.product_id`.\nSecond, define the trigger `trigger_remove_product_from_order` on table \"Order_Items\" that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_product_from_order() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Order_Items\"\n    WHERE order_id = NEW.order_id\n    AND product_id = ANY(array_remove(ARRAY[1, 2, 3]::bigint[], NEW.product_id));\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_remove_product_from_order\nAFTER INSERT ON \"Order_Items\"\nFOR EACH ROW\nEXECUTE FUNCTION remove_product_from_order();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Customers",
      "Order_Items",
      "Products",
      "Customer_Addresses",
      "Department_Stores",
      "Departments"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (100, 1, 1);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (101, 1, 2);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (102, 1, 3);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (103, 2, 1);",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id) VALUES (104, 2, 4);"
    ],
    "summary": "Create an AFTER INSERT trigger function named remove_product_from_order on the Order_Items table. For each new item inserted, delete any other items in the same order that have a product_id of 1, 2, or 3, but exclude the product_id of the newly inserted row from this deletion. Return the NEW record.",
    "natural_language": "Alright, so set up a trigger function called remove_product_from_order that kicks in AFTER we INSERT something into the Order_Items table. Basically, whenever a new item gets added, it should clean out any other items in that same order that have a product_id of 1, 2, or 3. But hey, don't touch the product_id we just insertedâ€”leave that one alone. After all that, just hand back the NEW record.",
    "id": 49,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named remove_product_from_order, which is executed automatically by a trigger named trg_remove_product_from_order, defined to fire after every insert operation on the Order_Items table for each new row. The function operates within the department_store database and is designed to handle the insertion of a new row into the Order_Items table. Upon insertion, the function performs a delete operation on the Order_Items table, targeting rows where the order_id column matches the NEW.order_id value from the newly inserted row, and where the product_id column is in the set of values 1, 2, or 3, but explicitly excluding the row where the order_item_id matches the NEW.order_item_id from the inserted row to ensure the newly inserted item is not removed. This ensures that any existing items in the same order with product_id values of 1, 2, or 3 are deleted, while preserving the newly added item. The function concludes by returning the NEW row record to the trigger execution context. Second, define the trigger trg_remove_product_from_order on the Order_Items table to execute the remove_product_from_order function after each insert operation.",
    "original_ir": "Write a PLpgSQL trigger function that is executed after an insert operation on the \"Order_Items\" table. This function, named remove_product_from_order, does not take any parameters directly but operates on the NEW record, which represents the row being inserted. The function performs a DELETE operation on the \"Order_Items\" table, targeting rows where the order_id matches the order_id of the newly inserted row (NEW.order_id) and the product_id is found within a modified array. This array is initially composed of the integers 1, 2, and 3, cast to an array of type bigint. The function uses the array_remove function to exclude the product_id of the newly inserted row (NEW.product_id) from this array. The DELETE operation thus removes any existing order items that have the same order_id as the new row and a product_id that is either 1, 2, or 3, except for the product_id of the newly inserted row. After performing the DELETE operation, the function returns the NEW record, allowing the insert operation to proceed. The trigger, named trigger_remove_product_from_order, is defined to execute this function after each row is inserted into the \"Order_Items\" table, ensuring that the described logic is applied to every new insertion."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function calculate_location_bit_length that compares the bit length of the new Location value to the bit length of the old Location value using the bit_length function, and if the new bit length is strictly greater, it executes an UPDATE on the gas_station table to increment the Open_Year column by one for the row where the Station_ID matches the NEW.Station_ID, and finally returns the NEW row. Second, define the trigger trg_calculate_location_bit_length on table gas_station that fires AFTER UPDATE OF the Location column and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_location_bit_length() RETURNS TRIGGER AS $$\nBEGIN\n  IF bit_length(NEW.\"Location\") > bit_length(OLD.\"Location\") THEN\n    UPDATE gas_station SET \"Open_Year\" = \"Open_Year\" + 1 WHERE \"Station_ID\" = NEW.\"Station_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_calculate_location_bit_length\nAFTER UPDATE OF \"Location\" ON gas_station\nFOR EACH ROW EXECUTE FUNCTION calculate_location_bit_length();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "UPDATE gas_station SET \"Location\" = '123 Main Street, Springfield' WHERE \"Station_ID\" = 1;",
      "UPDATE gas_station SET \"Location\" = '456 Oak Avenue, Longer City Name Example' WHERE \"Station_ID\" = 2;",
      "UPDATE gas_station SET \"Location\" = 'A' WHERE \"Station_ID\" = 3;",
      "UPDATE gas_station SET \"Location\" = 'Herne Hill Updated with More Characters' WHERE \"Station_ID\" = 1;",
      "UPDATE gas_station SET \"Location\" = 'A very long location string designed to increase the bit length significantly compared to the previous value' WHERE \"Station_ID\" = 2;"
    ],
    "summary": "Create a trigger function named `calculate_location_bit_length` that returns a trigger. It executes after an update to the `Location` column of the `gas_station` table. For each updated row, if the bit length of the new `Location` value is greater than the old value's bit length, it increments the `Open_Year` column by one for that row. The function returns the `NEW` record.",
    "natural_language": "Create trigger `calculate_location_bit_length` that runs after updating `Location` in `gas_station`. If new `Location` bit length exceeds the old, increment that row's `Open_Year` by one. Return NEW.",
    "id": 50,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named calculate_location_bit_length in the gas_company database. This function is defined to return a trigger and is executed after an update operation on the gas_station table. The function operates on the NEW and OLD records available in the trigger context, which represent the updated row's new and previous states, respectively.\n\nThe function declares no explicit variables; it directly uses the NEW and OLD records. It performs a conditional check: if the bit length of the Location column in the NEW record is greater than the bit length of the Location column in the OLD record. The bit length is calculated using the bit_length function in PostgreSQL, which returns the number of bits in the text string. If this condition is true, the function updates the same row in the gas_station table by incrementing the Open_Year column by one. Specifically, it sets Open_Year to Open_Year + 1 for the row where Station_ID matches the Station_ID of the NEW record. This update ensures that only the row being updated by the original UPDATE statement is modified. After the conditional update, the function returns the NEW record, allowing the original update operation to proceed.\n\nSecond, define the trigger calculate_location_bit_length on the gas_station table. This trigger is set to fire after an update on the Location column of the gas_station table, meaning it executes only when the Location column is modified in an UPDATE statement. The trigger executes the calculate_location_bit_length function for each row that is updated, ensuring the logic is applied row-by-row.",
    "original_ir": "Write a PostgreSQL trigger function named calculate_location_bit_length that returns a trigger and is invoked automatically after any update operation on the Location column of the gas_station table for each modified row, where the function's logic compares the bit length of the new Location value to the bit length of the old Location value using the bit_length function, and if the bit length of the new Location value is strictly greater than the bit length of the old Location value, it executes an update statement on the gas_station table, incrementing the Open_Year column by one specifically for the row where the Station_ID column matches the Station_ID value from the newly updated row, and finally the function returns the NEW row record to the calling trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_warehouse_exists` that checks for the existence of a warehouse by using a `SELECT 1` statement on the `\"Warehouses\"` table where its `\"Code\"` column matches the `NEW.\"Warehouse\"` value from the trigger context; if no matching row is found (`NOT EXISTS`), the function must raise an exception with the message 'Warehouse does not exist', otherwise it returns `NEW`.\nSecond, define the trigger `trg_boxes_before_insert_validate` on table `\"Boxes\"` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_warehouse_exists() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"Warehouses\" WHERE \"Code\" = NEW.\"Warehouse\") THEN\n        RAISE EXCEPTION 'Warehouse does not exist';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_before_insert_validate\nBEFORE INSERT ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION validate_warehouse_exists();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('0MN7', 'Rocks', 180.0, 1);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('4H8P', 'Scissors', 250.0, 2);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('4RT3', 'Rocks', 190.0, 3);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('5XY9', 'Paper', 200.0, 3);",
      "INSERT INTO \"Boxes\" (\"Code\", \"Contents\", \"Value\", \"Warehouse\") VALUES ('6AB2', 'Sand', 220.0, 1);"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger function named `validate_warehouse_exists` on the \"Boxes\" table. The function must check if a warehouse with a \"Code\" equal to NEW.\"Warehouse\" exists in the \"Warehouses\" table. If it does not exist, raise an exception with the message 'Warehouse does not exist'. If it exists, return NEW. Also, create a trigger named `trg_boxes_before_insert_validate` to execute this function.",
    "natural_language": "How can I create a BEFORE INSERT FOR EACH ROW trigger function called `validate_warehouse_exists` for the \"Boxes\" table that verifies the existence of a warehouse with a matching \"Code\" in the \"Warehouses\" table, raises an exception if it doesn't exist, and then create a trigger named `trg_boxes_before_insert_validate` to run this function?",
    "id": 51,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_warehouse_exists` that checks for the existence of a warehouse by using a `SELECT 1` statement on the `\"Warehouses\"` table where its `\"Code\"` column matches the `NEW.\"Warehouse\"` value from the trigger context; if no matching row is found (`NOT EXISTS`), the function must raise an exception with the message 'Warehouse does not exist', otherwise it returns `NEW`.\nSecond, define the trigger `trg_boxes_before_insert_validate` on table `\"Boxes\"` that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `validate_warehouse_exists` that is designed to be executed as a trigger, and a trigger named `trg_boxes_before_insert_validate` that invokes this function. The `validate_warehouse_exists` function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special variables like `NEW` which represents the new row being inserted or updated. The purpose of this function is to validate the existence of a warehouse referenced by a new row in the `\"Boxes\"` table. Specifically, when a new row is about to be inserted into the `\"Boxes\"` table, the trigger `trg_boxes_before_insert_validate` fires *before* the insertion occurs, for *each row* being inserted. The trigger then executes the `validate_warehouse_exists` function. Inside the function, a `SELECT` statement is performed to check for the existence of a record in the `\"Warehouses\"` table. This `SELECT` statement attempts to retrieve the literal value `1` from the `\"Warehouses\"` table. The condition for this `SELECT` statement is `WHERE \"Code\" = NEW.\"Warehouse\"`. This means it looks for a row in the `\"Warehouses\"` table where the value in its `\"Code\"` column exactly matches the value in the `\"Warehouse\"` column of the `NEW` row (the row currently being inserted into `\"Boxes\"`). If the `SELECT` statement returns no rows (i.e., `NOT EXISTS` is true), indicating that no warehouse with the specified code exists in the `\"Warehouses\"` table, then the function raises an exception with the message 'Warehouse does not exist'. This action prevents the `INSERT` operation on the `\"Boxes\"` table from completing. If, however, the `SELECT` statement finds at least one row (i.e., `NOT EXISTS` is false), meaning a warehouse with the specified code does exist, then the function proceeds without raising an exception and returns `NEW`. Returning `NEW` allows the `INSERT` operation on the `\"Boxes\"` table to continue with the row as it was provided."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_headquarter_on_name_change that checks if the new \"Name\" value differs from the old \"Name\" value and, when true, sets the new \"Headquarter\" value to the concatenation of the string 'Updated ' and the first three characters of the new \"Name\" using the SUBSTR function.\nSecond, define the trigger trg_manufacturers_before_update on table \"Manufacturers\" that fires BEFORE UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_headquarter_on_name_change() RETURNS TRIGGER AS $$\nBEGIN\nIF NEW.\"Name\" != OLD.\"Name\" THEN\nNEW.\"Headquarter\" = 'Updated ' || SUBSTR(NEW.\"Name\", 1, 3);\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_manufacturers_before_update\nBEFORE UPDATE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION update_headquarter_on_name_change();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers"
    ],
    "call_sqls": [
      "UPDATE \"Manufacturers\" SET \"Name\" = 'New Sony' WHERE \"Code\" = 1;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'Creative Labs Inc.' WHERE \"Code\" = 2;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'HP' WHERE \"Code\" = 3;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'Samsung Electronics' WHERE \"Code\" = 4;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'Apple Inc.' WHERE \"Code\" = 5;"
    ],
    "summary": "Create a BEFORE UPDATE trigger function named update_headquarter_on_name_change for the Manufacturers table. For each updated row, if the Name column changes, set the Headquarter column to 'Updated ' concatenated with the first three characters of the new Name. Return the modified NEW record.",
    "natural_language": "Please construct a BEFORE UPDATE trigger function designated as 'update_headquarter_on_name_change' for the Manufacturers table. For each row undergoing an update, should the value within the Name column be altered, the procedure must assign the Headquarter column a value comprising the string 'Updated ' concatenated with the initial three characters from the new Name value. The function should subsequently return the modified NEW record.",
    "id": 52,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_headquarter_on_name_change` in the database `manufactory_1`. This function is a trigger function written in PL/pgSQL, designed to be executed before an update operation on the `Manufacturers` table. The function does not accept explicit parameters but operates within the trigger context, having access to the special `NEW` and `OLD` records. The `NEW` record represents the row after the update, and the `OLD` record represents the row before the update.\n\nThe function's purpose is to conditionally modify the `Headquarter` column in the `Manufacturers` table when the `Name` column is updated. It begins by checking if the `Name` column in the `NEW` record differs from the `Name` column in the `OLD` record. This comparison is performed using a conditional `IF` statement. If the values are different, indicating that the `Name` has been altered, the function proceeds to update the `Headquarter` column in the `NEW` record. The update assigns a new value to `NEW.Headquarter`, constructed by concatenating the string literal 'Updated ' with the first three characters extracted from the `NEW.Name` value. The extraction of the first three characters is done using the `SUBSTRING` function, which takes `NEW.Name` as the input string and extracts characters starting from position 1 for a length of 3. If `NEW.Name` is shorter than three characters, the `SUBSTRING` function returns all available characters. The concatenation is performed using the `||` operator, resulting in a string like 'Updated Son' if `NEW.Name` is 'Sony'. This modified `NEW.Headquarter` value is then set in the `NEW` record. If the `Name` column has not changed, the function takes no action and leaves the `NEW.Headquarter` unchanged. After the conditional logic, the function returns the `NEW` record, which includes any modifications made to the `Headquarter` column. This return is standard for `BEFORE` row-level triggers in PostgreSQL, allowing the updated row to be persisted.\n\nSecond, define the trigger on the `Manufacturers` table. The trigger is configured to execute `BEFORE UPDATE` on the `Manufacturers` table. It is a `FOR EACH ROW` trigger, meaning the `update_headquarter_on_name_change` function is invoked once for every row that is updated in the table. The trigger calls the `update_headquarter_on_name_change()` function to perform the described logic, ensuring that any update to a row in the `Manufacturers` table that changes the `Name` column automatically updates the `Headquarter` column as specified.",
    "original_ir": "Write a PostgreSQL trigger function named update_headquarter_on_name_change that returns a trigger and is executed by a trigger named trg_manufacturers_before_update, which is defined to fire BEFORE UPDATE on the \"Manufacturers\" table for each row being updated. The function begins by checking a condition: if the new value of the \"Name\" column (NEW.\"Name\") is not equal to the old value of the \"Name\" column (OLD.\"Name\") from the row before the update. When this condition is true, the function performs an assignment to modify the new value for the \"Headquarter\" column in the row being updated (NEW.\"Headquarter\") by concatenating the literal string 'Updated ' with a substring extracted from the new \"Name\" value. The substring operation uses the SUBSTR function, which takes two arguments: the source string NEW.\"Name\" and the starting position 1, and extracts the first three characters from the string. The function then concludes by returning the modified NEW row record, which includes the potentially updated \"Headquarter\" value, to be used as the actual row data for the UPDATE operation on the \"Manufacturers\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function validate_product_price that inspects the NEW row's unit_price column from the Products table and, if the value is less than or equal to zero, modifies the NEW row by setting unit_price to the fixed numeric value 1.00.\nSecond, define the trigger trg_check_product_price on table Products that fires BEFORE INSERT OR UPDATE for each row and executes the function validate_product_price.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_product_price() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"unit_price\" <= 0 THEN\n    NEW.\"unit_price\" := 1.00;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_product_price\nBEFORE INSERT OR UPDATE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION validate_product_price();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Invoices",
      "Invoice_Line_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Products\" (product_id, product_name, unit_price) VALUES (100, 'Test Product', -10.00);",
      "INSERT INTO \"Products\" (product_id, product_name, unit_price) VALUES (101, 'Zero Price Product', 0.00);",
      "UPDATE \"Products\" SET unit_price = -5.50 WHERE product_id = 1;",
      "UPDATE \"Products\" SET unit_price = 0.00 WHERE product_id = 2;",
      "INSERT INTO \"Products\" (product_id, product_name, unit_price, production_type_code) VALUES (102, 'Valid Price Product', 25.99, 'Electronics');"
    ],
    "summary": "Create a trigger function named validate_product_price that fires BEFORE INSERT OR UPDATE on the \"Products\" table for each row. If the new \"unit_price\" is <= 0, set it to 1.00. Return the modified NEW row.",
    "natural_language": "Construct a trigger function, which should be named validate_product_price, designed to activate BEFORE either an INSERT operation or an UPDATE operation is performed on the database table known as \"Products,\" specifically for each individual row that is affected. In the event that the newly provided value for the \"unit_price\" column is found to be less than or equal to zero, the function must then carefully and automatically adjust that value, setting it precisely to 1.00 instead. Finally, the function must return the NEW row record, now containing the potentially modified data.",
    "id": 53,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function named validate_product_price for the customers_and_invoices database. The function is defined to return a TRIGGER and is written in PL/pgSQL language. It is designed to execute BEFORE INSERT or UPDATE operations on the Products table for each row affected. The function checks the unit_price column value from the NEW row record, which represents the row being inserted or updated. If the NEW.unit_price is less than or equal to zero, the function modifies it by setting NEW.unit_price to 1.00. This adjustment ensures that the unit_price is always positive. The function then returns the NEW row, which includes the original data or the modified unit_price value if a change was made. This return allows the INSERT or UPDATE operation to proceed with the potentially corrected data.\n\nSecond, define the trigger trg_validate_product_price on the Products table. The trigger is set to fire BEFORE INSERT or UPDATE for each row, and it calls the validate_product_price function. This ensures that any attempt to insert or update a row in the Products table with a unit_price less than or equal to zero will automatically have the unit_price corrected to 1.00 before the operation is completed.",
    "original_ir": "Write a PostgreSQL trigger function named validate_product_price that returns a trigger and is invoked by a trigger named trg_check_product_price, which is defined to execute before any insert or update operation on the table named \"Products\" for each affected row, where the function logic inspects the new row value for the column \"unit_price\" and, if this value is less than or equal to zero, modifies the new row by setting the \"unit_price\" column to the fixed numeric value 1.00, and then returns the modified new row for the database operation to proceed."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function adjust_age_with_random that checks if the combination of NEW.\"Club_ID\" and NEW.\"Member_ID\" already exists in the \"club_leader\" table using an EXISTS subquery; if it exists, the function returns NULL to prevent the insert. If the combination does not exist, the function updates the \"member\" table by increasing the \"Age\" column for the row where \"Member_ID\" matches NEW.\"Member_ID\", adding the value FLOOR(random() * 5) + 1.\nSecond, define the trigger random_age_increase on table \"club_leader\" that fires BEFORE INSERT for each row and executes the function adjust_age_with_random.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_age_with_random() RETURNS TRIGGER AS $$\nBEGIN\n    -- Check if this Club_ID, Member_ID combination already exists\n    IF EXISTS (SELECT 1 FROM \"club_leader\" WHERE \"Club_ID\" = NEW.\"Club_ID\" AND \"Member_ID\" = NEW.\"Member_ID\") THEN\n        RETURN NULL; -- Prevent the insert\n    END IF;\n    \n    UPDATE \"member\" SET \"Age\" = \"Age\" + FLOOR(random() * 5) + 1 WHERE \"Member_ID\" = NEW.\"Member_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER random_age_increase\n    BEFORE INSERT ON \"club_leader\"\n    FOR EACH ROW\n    EXECUTE FUNCTION adjust_age_with_random();",
    "database_name": "club_leader",
    "tables": [
      "club",
      "club_leader",
      "member"
    ],
    "call_sqls": [
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (1, 1984, '2024');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (3, 1985, '2023');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (4, 1986, '2022');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (8, 1987, '2021');",
      "INSERT INTO \"club_leader\" (\"Club_ID\", \"Member_ID\", \"Year_Join\") VALUES (6, 1988, '2020');"
    ],
    "summary": "Create a PLpgSQL BEFORE INSERT trigger function on club_leader. If a row with the same Club_ID and Member_ID exists, return NULL to prevent the insert. Otherwise, update the member table by increasing the Age for the matching Member_ID by a random integer between 1 and 5, then return NEW. Name the trigger random_age_increase.",
    "natural_language": "Alright, so we need a trigger for the club_leader table that fires before a new entry is added. Here's the deal: if there's already a record with the same Club_ID and Member_ID combo, just block the insert entirely. If it's a new combo, then we gotta go to the member table, find that Member_ID, and bump up their Age by some random number from 1 to 5. After that, the insert can go ahead. Oh, and don't forget to name this whole thing random_age_increase.",
    "id": 54,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function adjust_age_with_random that checks if the combination of NEW.\"Club_ID\" and NEW.\"Member_ID\" already exists in the \"club_leader\" table using an EXISTS subquery; if it exists, the function returns NULL to prevent the insert. If the combination does not exist, the function updates the \"member\" table by increasing the \"Age\" column for the row where \"Member_ID\" matches NEW.\"Member_ID\", adding the value FLOOR(random() * 5) + 1.\nSecond, define the trigger random_age_increase on table \"club_leader\" that fires BEFORE INSERT for each row and executes the function adjust_age_with_random.",
    "original_ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the \"club_leader\" table. The function checks if a combination of \"Club_ID\" and \"Member_ID\" already exists in the \"club_leader\" table. If such a combination exists, the function prevents the insert operation by returning NULL. If the combination does not exist, the function updates the \"member\" table by increasing the \"Age\" column of the row where \"Member_ID\" matches the \"Member_ID\" of the new row being inserted. The age is increased by a random integer value between 1 and 5, inclusive, calculated using the FLOOR function applied to the result of the random() function multiplied by 5, and then adding 1. After updating the age, the function allows the insert operation to proceed by returning the new row. The trigger named \"random_age_increase\" is associated with this function and is set to execute before each row is inserted into the \"club_leader\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function adjust_course_grade_trigger that updates the Grade column in the course_arrange table to the absolute value of the newly inserted Grade, using the abs function, for the row where the Course_ID matches NEW.Course_ID and the Teacher_ID matches NEW.Teacher_ID, and then returns NEW.\nSecond, define the trigger course_arrange_insert_trigger on table course_arrange that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_course_grade_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE course_arrange SET \"Grade\" = abs(NEW.\"Grade\") WHERE \"Course_ID\" = NEW.\"Course_ID\" AND \"Teacher_ID\" = NEW.\"Teacher_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER course_arrange_insert_trigger\n    AFTER INSERT ON course_arrange\n    FOR EACH ROW\n    EXECUTE FUNCTION adjust_course_grade_trigger();",
    "database_name": "course_teach",
    "tables": [
      "course",
      "course_arrange",
      "teacher"
    ],
    "call_sqls": [
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (2, 5, -1);",
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (3, 3, -3);",
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (2, 2, -5);",
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (3, 5, -2);",
      "INSERT INTO course_arrange (\"Course_ID\", \"Teacher_ID\", \"Grade\") VALUES (2, 3, -4);"
    ],
    "summary": "Create a trigger function named adjust_course_grade_trigger that fires AFTER INSERT on the course_arrange table for each row. It updates the Grade column in the same table to the absolute value of the NEW.Grade for the row matching the inserted Course_ID and Teacher_ID, then returns NEW.",
    "natural_language": "Set up a trigger function called adjust_course_grade_trigger that runs after something gets added to the course_arrange table. For each new entry, it should kind of adjust the Grade column in that same table, making sure the grade is a positive number for that specific course and teacher combination, and then just pass along the new record.",
    "id": 55,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function adjust_course_grade_trigger that updates the Grade column in the course_arrange table to the absolute value of the newly inserted Grade, using the abs function, for the row where the Course_ID matches NEW.Course_ID and the Teacher_ID matches NEW.Teacher_ID, and then returns NEW.\nSecond, define the trigger course_arrange_insert_trigger on table course_arrange that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function named adjust_course_grade_trigger that is executed after a new row is inserted into the course_arrange table. This function updates the Grade column in the course_arrange table to the absolute value of the newly inserted Grade for the row where the Course_ID matches the newly inserted Course_ID and the Teacher_ID matches the newly inserted Teacher_ID. The trigger named course_arrange_insert_trigger is defined to invoke this function after each row insertion into the course_arrange table, ensuring that the Grade value is always stored as a non-negative number. The function returns the newly inserted row after performing the update operation."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function cleanup_orphaned_records that deletes rows from the \"management\" table where its \"head_ID\" column matches the OLD.\"head_ID\" value from the deleted \"head\" row and returns NULL.\nSecond, define the trigger trg_cleanup_orphaned_records on table \"head\" that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION cleanup_orphaned_records() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"management\" WHERE \"head_ID\" = OLD.\"head_ID\";\n  RETURN NULL; -- For AFTER triggers, the function must return NULL\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_cleanup_orphaned_records\nAFTER DELETE ON \"head\"\nFOR EACH ROW EXECUTE FUNCTION cleanup_orphaned_records();",
    "database_name": "department_management",
    "tables": [
      "department",
      "head",
      "management"
    ],
    "call_sqls": [
      "DELETE FROM head WHERE head_ID = 1;",
      "DELETE FROM head WHERE head_ID = 2;",
      "DELETE FROM head WHERE head_ID = 3;",
      "DELETE FROM head WHERE head_ID = 4;",
      "DELETE FROM head WHERE head_ID = 5;"
    ],
    "summary": "Create a PostgreSQL trigger function named cleanup_orphaned_records that fires AFTER DELETE on the \"head\" table for each row. The function deletes rows from the \"management\" table where \"head_ID\" equals OLD.\"head_ID\" and returns NULL.",
    "natural_language": "Define a PostgreSQL trigger function called cleanup_orphaned_records that executes AFTER DELETE on the \"head\" table for each row. This function must remove rows from the \"management\" table where \"head_ID\" matches OLD.\"head_ID\" and should return NULL.",
    "id": 56,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function cleanup_orphaned_records that deletes rows from the \"management\" table where its \"head_ID\" column matches the OLD.\"head_ID\" value from the deleted \"head\" row and returns NULL.\nSecond, define the trigger trg_cleanup_orphaned_records on table \"head\" that fires AFTER DELETE and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger that is named `trg_cleanup_orphaned_records` and is activated immediately after a `DELETE` operation is performed on the table named `\"head\"`. This trigger is configured to execute for each individual row that is deleted from the `\"head\"` table. Upon activation, the trigger invokes a function named `cleanup_orphaned_records()`. The `cleanup_orphaned_records()` function is defined to return a `TRIGGER` type, indicating its role as a trigger function. Inside this function, a `DELETE` operation is executed on the table named `\"management\"`. This `DELETE` operation targets and removes rows from the `\"management\"` table where the value in the column named `\"head_ID\"` is equal to the value of the `\"head_ID\"` column from the row that was just deleted from the `\"head\"` table. The `OLD` keyword refers to the row that was deleted from the `\"head\"` table, and `OLD.\"head_ID\"` specifically accesses the value of the `\"head_ID\"` column from that deleted row. After performing the deletion from the `\"management\"` table, the `cleanup_orphaned_records()` function explicitly returns `NULL`. This `NULL` return value is a requirement for `AFTER` triggers in PostgreSQL, signifying that the trigger has completed its operation and does not intend to modify the data being operated on by the triggering statement."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_company_rank_on_insert` that updates the `Rank` column in the `company` table. The function should set the `Rank` to the maximum value of `Rank_of_the_Year` from the `station_company` table for rows where the `Company_ID` matches the `NEW.\"Company_ID\"` from the trigger context. The function must then return `NEW`.\nSecond, define the trigger `station_company_insert_trigger` on table `station_company` that fires `AFTER` `INSERT` and executes the function `update_company_rank_on_insert()`.",
    "plsql": "CREATE OR REPLACE FUNCTION update_company_rank_on_insert() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"company\" SET \"Rank\" = (SELECT MAX(\"Rank_of_the_Year\") FROM \"station_company\" WHERE \"Company_ID\" = NEW.\"Company_ID\") WHERE \"Company_ID\" = NEW.\"Company_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER station_company_insert_trigger\n    AFTER INSERT ON \"station_company\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_company_rank_on_insert();\n\n-- Example insertion with conflict handling\nINSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\")\nVALUES (11, 1, 1)\nON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (12, 1, 2) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (13, 2, 3) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (14, 3, 4) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (15, 1, 5) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;",
      "INSERT INTO \"station_company\" (\"Station_ID\", \"Company_ID\", \"Rank_of_the_Year\") VALUES (16, 2, 6) ON CONFLICT (\"Station_ID\", \"Company_ID\") DO NOTHING;"
    ],
    "summary": "Create an AFTER INSERT trigger function named update_company_rank_on_insert for the station_company table. For each new row, update the company table's Rank column for the matching Company_ID. Set Rank to the maximum Rank_of_the_Year from station_company for that Company_ID. Return NEW.",
    "natural_language": "Create AFTER INSERT trigger update_company_rank_on_insert for station_company. For new rows, set company.Rank to the max Rank_of_the_Year for that Company_ID from station_company. Return NEW.",
    "id": 57,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named update_company_rank_on_insert. This function is defined to return a trigger and uses PL/pgSQL language. It is executed automatically by a trigger after each INSERT operation on the station_company table for each affected row. The function declares a local variable max_rank of type integer to store the maximum Rank_of_the_Year value. After an insertion into station_company, the function performs a SELECT query on the station_company table to calculate the maximum value of the Rank_of_the_Year column, filtering the rows where the Company_ID matches the NEW.Company_ID from the newly inserted row. The result of this aggregation is assigned to the max_rank variable. Then, the function executes an UPDATE operation on the company table, setting the Rank column to the value stored in max_rank, specifically for the row where the Company_ID equals the NEW.Company_ID. After updating the company table, the function returns the NEW row record, allowing the original INSERT operation to proceed. Second, define the trigger trg_update_company_rank_on_insert on the station_company table to fire AFTER INSERT for each row, executing the update_company_rank_on_insert function, ensuring that whenever a new record is added to station_company, the corresponding company's Rank is recalculated and updated based on the maximum Rank_of_the_Year for that company in the station_company table.",
    "original_ir": "Write a PL/pgSQL function named `update_company_rank_on_insert` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables like `NEW` and `OLD` representing the new and old row data, respectively. The purpose of this function is to update the `Rank` column in the `company` table. Specifically, it performs an `UPDATE` operation on the `company` table. The `UPDATE` targets rows in the `company` table where the `Company_ID` column matches the `Company_ID` value from the newly inserted row, which is accessed via `NEW.\"Company_ID\"`. For these targeted rows, the `Rank` column is set to a new value. This new value is determined by a subquery: `(SELECT MAX(\"Rank_of_the_Year\") FROM \"station_company\" WHERE \"Company_ID\" = NEW.\"Company_ID\")`. This subquery selects the maximum value of the `Rank_of_the_Year` column from the `station_company` table, specifically for records where the `Company_ID` in `station_company` matches the `Company_ID` of the newly inserted row (`NEW.\"Company_ID\"`). After performing this update, the function returns `NEW`, which is the standard behavior for `AFTER` row-level triggers in PostgreSQL, indicating that the modified new row should be used.\n\nFollowing the function definition, a trigger named `station_company_insert_trigger` is created. This trigger is configured to activate `AFTER INSERT` operations on the `station_company` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for every row that is inserted into the `station_company` table. When activated, this trigger `EXECUTE FUNCTION update_company_rank_on_insert()`, thereby invoking the previously defined function.\n\nFinally, an example `INSERT` statement is provided. This statement attempts to insert a new row into the `station_company` table. The values provided for the columns are `Station_ID` as `11`, `Company_ID` as `1`, and `Rank_of_the_Year` as `1`. This `INSERT` statement includes an `ON CONFLICT` clause, which specifies a conflict target on the composite primary key or unique constraint formed by the `Station_ID` and `Company_ID` columns. If a conflict occurs (i.e., a row with the same `Station_ID` and `Company_ID` already exists), the `DO NOTHING` action is executed, meaning the insertion is skipped without raising an error or modifying the existing row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_order_details_on_invoice` that inserts a new row into the `\"Orders\"` table using values from the `NEW` record and the `\"Customers\"` table. The inserted values are: `\"order_id\"` from `NEW.\"order_id\"`; `\"customer_id\"` selected randomly from `\"Customers\"` where the length of `\"customer_first_name\"` is greater than 3; `\"date_order_placed\"` set to `CURRENT_TIMESTAMP`; and `\"order_details\"` set to the string `'Auto-generated from invoice via trigger'`. The function must use an `ON CONFLICT (\"order_id\") DO NOTHING` clause to handle duplicate keys and must return `NEW`.\nSecond, define the trigger `trg_invoice_to_order` on table `\"Invoices\"` that fires `BEFORE` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_details_on_invoice() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check if the order already exists in \"Orders\" to prevent duplicate key errors\n  -- and satisfy the foreign key constraint on \"Invoices\" before the actual INSERT into \"Invoices\" happens.\n  INSERT INTO \"Orders\" (\"order_id\", \"customer_id\", \"date_order_placed\", \"order_details\")\n  VALUES (\n    NEW.\"order_id\",\n    (SELECT \"customer_id\" FROM \"Customers\" WHERE LENGTH(\"customer_first_name\") > 3 ORDER BY RANDOM() LIMIT 1),\n    CURRENT_TIMESTAMP,\n    'Auto-generated from invoice via trigger'\n  )\n  ON CONFLICT (order_id) DO NOTHING; -- If an order with this ID already exists, do nothing.\n\n  RETURN NEW; -- Allow the INSERT into \"Invoices\" to proceed\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_invoice_to_order\nBEFORE INSERT ON \"Invoices\"\nFOR EACH ROW EXECUTE FUNCTION update_order_details_on_invoice();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Customers",
      "Orders",
      "Invoices",
      "Invoice_Line_Items",
      "Products"
    ],
    "call_sqls": [
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (100, 500, CURRENT_TIMESTAMP);",
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (101, 501, '2024-01-15 10:30:00+00');",
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (102, 502, CURRENT_TIMESTAMP);",
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (103, 503, '2024-03-20 14:45:00+00');",
      "INSERT INTO \"Invoices\" (invoice_number, order_id, invoice_date) VALUES (104, 504, CURRENT_TIMESTAMP);"
    ],
    "summary": "Create a trigger function named update_order_details_on_invoice that fires BEFORE INSERT on the Invoices table for each row. It attempts to insert a row into the Orders table using NEW.order_id, a random customer_id from Customers where customer_first_name length > 3, the current timestamp, and a fixed order_details string. On conflict with order_id, do nothing. Return NEW.",
    "natural_language": "Define a trigger function called update_order_details_on_invoice to execute BEFORE INSERT on the Invoices table for each row. Make it attempt to insert a row into the Orders table using the NEW.order_id, a random customer_id from the Customers table where the length of the customer's first name is greater than 3, the current timestamp, and a fixed order_details string. Instruct it to do nothing if there is a conflict on the order_id. Ensure it returns NEW.",
    "id": 58,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `update_order_details_on_invoice`. This function is designed to be executed as a trigger and is declared to return a `TRIGGER` type. It operates within the context of a trigger, receiving special `NEW` and `OLD` records. The function is defined to execute `BEFORE INSERT` on the `Invoices` table for each row.\n\nInside the function, an `INSERT` operation is performed on the `Orders` table. The `INSERT` statement populates the `Orders` table with values for the columns `order_id`, `customer_id`, `date_order_placed`, and `order_details`. For the `order_id` column, the value is taken directly from the `order_id` column of the newly inserted row in the `Invoices` table that activated the trigger, referenced as `NEW.order_id`. For the `customer_id` column, the value is determined by a subquery that selects a random `customer_id` from the `Customers` table. The subquery uses the `ORDER BY RANDOM()` clause to randomize the selection and `LIMIT 1` to return only one row. It includes a `WHERE` condition that filters rows where the length of the `customer_first_name` column is greater than 3, using the `LENGTH()` function. For the `date_order_placed` column, the value is set to the current timestamp using the `CURRENT_TIMESTAMP` function. For the `order_details` column, a static string literal value is inserted; the exact string is not specified in the description but is referred to as a fixed string. The `INSERT` statement includes an `ON CONFLICT (order_id) DO NOTHING` clause, which means if a row with the same `order_id` already exists in the `Orders` table (due to a primary key or unique constraint violation), the insertion is silently skipped without raising an error. After the `INSERT` operation, the function returns the `NEW` record, which is a standard requirement for `BEFORE` row-level triggers in PostgreSQL.\n\nSecond, define the trigger `trg_update_order_details_on_invoice` on the `Invoices` table. This trigger is configured to activate `BEFORE INSERT` operations on the `Invoices` table. The `FOR EACH ROW` clause specifies that the trigger function `update_order_details_on_invoice` will be executed once for every row that is inserted into the `Invoices` table. The `EXECUTE FUNCTION` clause explicitly calls the `update_order_details_on_invoice` function to perform its defined operations for each affected row.",
    "original_ir": "Write a PLpgSQL function named update_order_details_on_invoice that is designed to be executed as a trigger function. This function is triggered before an INSERT operation on the Invoices table. The function attempts to insert a new record into the Orders table with the following columns: order_id, customer_id, date_order_placed, and order_details. The order_id is taken from the NEW record being inserted into the Invoices table. The customer_id is selected from the Customers table, specifically choosing a random customer whose customer_first_name has a length greater than 3 characters. The date_order_placed is set to the current timestamp at the time of the trigger execution. The order_details column is populated with the string 'Auto-generated from invoice via trigger'. The function uses the ON CONFLICT clause to handle any potential duplicate order_id values by doing nothing if a conflict occurs, thus preventing any duplicate key errors. After attempting the insertion into the Orders table, the function returns the NEW record, allowing the original INSERT operation into the Invoices table to proceed. The trigger named trg_invoice_to_order is created to execute this function for each row before an INSERT operation on the Invoices table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function insert_school_colors that checks if the NEW row's School_Colors is NOT NULL and, if true, inserts a row into the school_details table with the School_ID and the UPPER version of School_Colors, using ON CONFLICT to update the Colors column when a duplicate School_ID exists. Second, define the trigger add_school_colors on table school that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_school_colors() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"School_Colors\" IS NOT NULL THEN\n    INSERT INTO school_details (\"School_ID\", \"Colors\")\n    VALUES (NEW.\"School_ID\", UPPER(NEW.\"School_Colors\"))\n    ON CONFLICT (\"School_ID\") DO UPDATE\n    SET \"Colors\" = UPPER(NEW.\"School_Colors\");\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER add_school_colors\nAFTER INSERT ON school\nFOR EACH ROW EXECUTE FUNCTION insert_school_colors();",
    "database_name": "school_player",
    "tables": [
      "player",
      "school",
      "school_details",
      "school_performance"
    ],
    "call_sqls": [
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (1, 'St Aloysius\\' College', 'Milsons Point', 1200.0, 1879.0, 'Catholic', 'Boys', 'Day', 1929.0, 'Royal Blue and Gold');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (2, 'Barker College', 'Hornsby', 2300.0, 1890.0, 'Anglican', 'Boys only to Yr 9 Co-ed Year 1...', 'Day & Boarding', 1929.0, 'Red & Blue');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (3, 'Cranbrook School', 'Bellevue Hill', 1000.0, 1918.0, 'Anglican', 'Boys', 'Day', 1929.0, 'Red, White & Blue');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (4, 'New School', 'New Location', 1500.0, 2000.0, 'Non-Denominational', 'Co-ed', 'Day', 2000.0, 'Green and White');",
      "INSERT INTO school (\"School_ID\", \"School\", \"Location\", \"Enrollment\", \"Founded\", \"Denomination\", \"Boys_or_Girls\", \"Day_or_Boarding\", \"Year_Entered_Competition\", \"School_Colors\") VALUES (5, 'Another School', 'Another Location', 1800.0, 1950.0, 'Catholic', 'Girls', 'Boarding', 1950.0, 'Black and Yellow');"
    ],
    "summary": "Create a PostgreSQL AFTER INSERT trigger function for the school table. If NEW.School_Colors is not null, insert or update school_details: set School_ID to NEW.School_ID and Colors to UPPER(NEW.School_Colors). On conflict, update Colors to the uppercase value. Return NEW.",
    "natural_language": "Alright, so we need a trigger that kicks in after you add a new entry to the school table. Here's the deal: if the new record's School_Colors field isn't empty, you gotta either add a new row to the school_details table or update an existing one. Set the School_ID to the new School_ID and the Colors to the uppercase version of the new School_Colors. If there's already an entry with that School_ID (that's a conflict), just update its Colors to that uppercase value. Finally, the trigger should just hand back the NEW record.",
    "id": 59,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named insert_school_colors that is triggered by the insertion of a new row into the school table. The function operates after the insert and updates the school_details table based on the newly inserted row's School_Colors column. Specifically, if the School_Colors column of the new row is not null and not an empty string, the function attempts to insert a new row into the school_details table with the School_ID set to the new School_ID and the Colors column set to the uppercase version of the new School_Colors. If a row with the same School_ID already exists in the school_details table, the function instead updates the existing row's Colors column to the uppercase version of the new School_Colors, leaving other columns unchanged. The function uses the UPPER string function to convert the School_Colors value to uppercase. The function returns the NEW pseudo-record, which represents the newly inserted row in the school table, without modifying it. Second, define the trigger named insert_school_colors_trigger on the school table to execute the function insert_school_colors after each row insertion.",
    "original_ir": "Write a PLpgSQL function that is triggered after an insert operation on the school table, which checks if the newly inserted row has a non-null value in the School_Colors column. If School_Colors is not null, the function inserts a new row into the school_details table with the School_ID from the newly inserted row and the uppercase version of School_Colors. If a row with the same School_ID already exists in the school_details table, it updates the Colors column to the uppercase version of the new School_Colors value. The function uses the UPPER() function to convert the School_Colors value to uppercase, ensuring consistent formatting in the school_details table. The trigger named add_school_colors is defined to execute this function for each row after an insert operation on the school table, ensuring that the school_details table is updated accordingly whenever a new school record is added."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `delete_related_coasters` that deletes rows from the `roller_coaster` table where the `Country_ID` matches `OLD.Country_ID` and the length of the `Name` column is an even number, using the condition `MOD(LENGTH(\"Name\"), 2) = 0`, and returns the `OLD` record. Second, define the trigger `cleanup_coasters_trigger` on table `country` that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_coasters() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"roller_coaster\" WHERE \"Country_ID\" = OLD.\"Country_ID\" AND MOD(LENGTH(\"Name\"), 2) = 0;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER cleanup_coasters_trigger\nAFTER DELETE ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION delete_related_coasters();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 1;",
      "DELETE FROM \"country\" WHERE \"Name\" = 'Finland';",
      "DELETE FROM \"country\" WHERE \"Population\" < 9000000;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" IN (2, 3);",
      "DELETE FROM \"country\" WHERE \"Area\" > 400000;"
    ],
    "summary": "Create an AFTER DELETE trigger function named delete_related_coasters on the country table. It deletes rows from the roller_coaster table where Country_ID matches OLD.Country_ID and the length of the Name is even. The function returns the OLD row.",
    "natural_language": "Define an AFTER DELETE trigger function called delete_related_coasters for the country table. This function must delete any rows in the roller_coaster table where the Country_ID equals the OLD.Country_ID and the length of the Name is an even number. Ensure the function returns the OLD row.",
    "id": 60,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `delete_related_coasters` in the `roller_coaster` database. This function is an `AFTER DELETE` trigger function for the `country` table. It returns a `TRIGGER` type. The function declares no explicit variables; it uses the implicit `OLD` record provided by the trigger mechanism, which contains the row being deleted from the `country` table.\n\nThe core logic of the function is a single `DELETE` operation on the `roller_coaster` table. This operation deletes rows based on two conditions combined with an `AND` operator. The first condition is that the `Country_ID` column in the `roller_coaster` table must equal the `Country_ID` value from the `OLD` record (i.e., the `Country_ID` of the country row that was just deleted). The second condition involves a calculation on the `Name` column of the `roller_coaster` table: it checks if the length of the `Name` string is an even number. This is determined by using the `LENGTH` function to get the number of characters in the `Name` and then applying the modulo operator (`%`) with `2`. If the result of `LENGTH(Name) % 2` equals `0`, the length is even, and the row qualifies for deletion. The `DELETE` operation removes all rows from the `roller_coaster` table that satisfy both conditions simultaneously.\n\nAfter performing the deletion, the function returns the `OLD` row. This is a standard practice for `AFTER DELETE` row-level triggers in PostgreSQL, as it provides the deleted row's data for any subsequent operations or logging.\n\nSecond, define the trigger named `trg_delete_related_coasters` on the `country` table. This trigger is configured to activate `AFTER DELETE` operations on the `country` table. The `FOR EACH ROW` clause specifies that the trigger function `delete_related_coasters()` should be executed once for every row that is deleted from the `country` table. The `EXECUTE FUNCTION delete_related_coasters()` clause explicitly calls the previously defined trigger function to perform its logic.\n\nIn summary, this setup ensures that whenever a row is deleted from the `country` table, the trigger automatically deletes all related rows in the `roller_coaster` table where the `Country_ID` matches the deleted country's `Country_ID` and the length of the roller coaster's `Name` is an even number, then returns the deleted country row.",
    "original_ir": "Write a PLpgSQL function named delete_related_coasters that is designed to be used as a trigger function. This function does not take any parameters directly but operates in the context of a trigger event. It is intended to execute after a row is deleted from the country table. The function performs a DELETE operation on the roller_coaster table, specifically targeting rows where the Country_ID column matches the Country_ID of the deleted row from the country table, referred to as OLD.Country_ID. Additionally, the function applies a condition to the deletion process: it only deletes rows where the Name column's length is an even number, determined by the MOD function with a divisor of 2. The function returns the OLD record, which is the row that was deleted from the country table, allowing for further processing or logging if needed. The function is written in the PLpgSQL language. A trigger named cleanup_coasters_trigger is created to automatically invoke this function after a row is deleted from the country table. The trigger is defined to execute for each row that is deleted, ensuring that the function is called individually for each deletion event, thereby maintaining the integrity of the roller_coaster table by removing related entries based on the specified conditions."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_college_location_on_college_update that checks if the new College_Location value is distinct from the literal string 'Updated Location' using IS DISTINCT FROM, and if true, updates the college table by setting College_Location to 'Updated Location' where College_ID matches the new College_ID.\nSecond, define the trigger trg_update_college_location_on_college_update on table college that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_college_location_on_college_update() RETURNS TRIGGER AS $$\nBEGIN\n  -- Prevent infinite recursion by only updating if the location is not already the target value\n  IF NEW.\"College_Location\" IS DISTINCT FROM 'Updated Location' THEN\n    UPDATE college\n    SET \"College_Location\" = 'Updated Location'\n    WHERE \"College_ID\" = NEW.\"College_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_college_location_on_college_update\nAFTER UPDATE ON college\nFOR EACH ROW EXECUTE FUNCTION update_college_location_on_college_update();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "UPDATE college SET \"College_Location\" = 'Old Location' WHERE \"College_ID\" = 1;",
      "UPDATE college SET \"Name\" = 'New Name' WHERE \"College_ID\" = 2;",
      "UPDATE college SET \"Leader_Name\" = 'New Leader' WHERE \"College_ID\" = 3;",
      "UPDATE college SET \"College_Location\" = 'Another Location' WHERE \"College_ID\" = 1;",
      "UPDATE college SET \"College_Location\" = 'Updated Location' WHERE \"College_ID\" = 2;"
    ],
    "summary": "Create a trigger function named update_college_location_on_college_update that fires after an update on the college table. If the new College_Location is different from 'Updated Location', update the college's location to 'Updated Location'. Return the NEW record.",
    "natural_language": "How do you create a trigger function named update_college_location_on_college_update that fires after an update on the college table, so that if the new College_Location is different from 'Updated Location', it updates the college's location to 'Updated Location' and returns the NEW record?",
    "id": 61,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `update_college_location_on_college_update`. This function is designed to be executed as a trigger after an update operation on the `college` table. It accepts no explicit input parameters but operates within the trigger context, receiving the special variables `NEW` and `OLD`, which represent the new and old row data, respectively, for the row that caused the trigger to fire. The function is declared to return a `TRIGGER` type, which is standard for PostgreSQL trigger functions.\n\nWithin the function, a conditional check is performed using an `IF` statement. The condition evaluates whether the value of the `College_Location` column in the `NEW` record is different from the string literal `'Updated Location'`. If this condition is true, meaning the new `College_Location` is not equal to `'Updated Location'`, the function executes an `UPDATE` operation on the `college` table. Specifically, it sets the `College_Location` column to the string literal `'Updated Location'` for the row where the `College_ID` column matches the `College_ID` value from the `NEW` record. This ensures that only the college row being updated is affected. After performing this update, the function returns the `NEW` record. If the condition is false, meaning the new `College_Location` is already `'Updated Location'`, the function does not execute any update and simply returns the `NEW` record as is.\n\nSecond, define the trigger `trg_update_college_location_on_college_update` on the `college` table. This trigger is configured to activate `AFTER UPDATE` operations on the `college` table. The `FOR EACH ROW` clause specifies that the trigger function `update_college_location_on_college_update` will be executed once for each row that is updated in the `college` table. The `EXECUTE FUNCTION update_college_location_on_college_update()` clause indicates that the previously defined PL/pgSQL function is to be invoked when the trigger fires. Therefore, whenever a row in the `college` table is updated, this trigger will automatically execute the `update_college_location_on_college_update` function, which conditionally updates the `College_Location` to `'Updated Location'` if it was not already set to that value.",
    "original_ir": "Write a PostgreSQL trigger function named update_college_location_on_college_update that is executed automatically after each row update operation on the college table, which first checks if the new value of the College_Location column for the updated row is different from the literal string 'Updated Location' using the IS DISTINCT FROM comparison, and if this condition is true, the function performs an update on the college table, setting the College_Location column to the literal string 'Updated Location' specifically for the row where the College_ID column matches the new College_ID value from the triggering update event, and finally the function returns the NEW row record to the trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_book_reviews_trigger` that deletes rows from the `\"review\"` table where its `\"Book_ID\"` column matches the `\"Book_ID\"` from the `OLD` record and then returns `OLD`.\nSecond, define the trigger `delete_book_reviews` on table `\"book\"` that fires `AFTER DELETE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_book_reviews_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"review\" WHERE \"Book_ID\" = OLD.\"Book_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER delete_book_reviews\n    AFTER DELETE ON \"book\"\n    FOR EACH ROW\n    EXECUTE FUNCTION delete_book_reviews_trigger();",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "DELETE FROM book WHERE Book_ID = 1;",
      "DELETE FROM book WHERE Book_ID = 2;",
      "DELETE FROM book WHERE Book_ID = 3;",
      "DELETE FROM book WHERE Book_ID = 4;",
      "DELETE FROM book WHERE Book_ID = 5;"
    ],
    "summary": "Create an AFTER DELETE row-level trigger for the book table. For each deleted book row, delete all rows from the review table where the Book_ID matches the deleted book's Book_ID. Return the OLD record.",
    "natural_language": "Please construct an AFTER DELETE row-level trigger for the book table. The trigger's function shall be to delete all corresponding entries from the review table for each deleted book row, specifically those rows where the Book_ID matches the Book_ID of the deleted record. The trigger must then return the OLD record.",
    "id": 62,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_book_reviews_trigger` that deletes rows from the `\"review\"` table where its `\"Book_ID\"` column matches the `\"Book_ID\"` from the `OLD` record and then returns `OLD`.\nSecond, define the trigger `delete_book_reviews` on table `\"book\"` that fires `AFTER DELETE` and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `delete_book_reviews_trigger` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` record variables. The purpose of this function is to perform a data manipulation operation: specifically, a `DELETE` statement. It targets the table named `\"review\"`. The `DELETE` operation is conditional, removing rows from `\"review\"` where the value in its `\"Book_ID\"` column exactly matches the value of the `\"Book_ID\"` column from the `OLD` record. The `OLD` record represents the row that was deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function returns the `OLD` record.\n\nAdditionally, define a PostgreSQL trigger named `delete_book_reviews`. This trigger is configured to activate `AFTER DELETE` operations on the table named `\"book\"`. It is specified to execute `FOR EACH ROW`, meaning that for every individual row deleted from the `\"book\"` table, the trigger will fire. When activated, this trigger executes the previously defined function `delete_book_reviews_trigger()`. The overall effect of this trigger and function combination is to automatically delete all associated review records from the `\"review\"` table whenever a corresponding book record is deleted from the `\"book\"` table, ensuring referential integrity by cascading deletions based on the `\"Book_ID\"` column."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_problem_status` that returns a trigger and uses a CASE statement to return the NEW record if an EXISTS subquery finds a matching `problem_status_code` in the `\"Problem_Status_Codes\"` table, otherwise returns NULL.\nSecond, define the trigger `validate_status_trigger` on table `\"Problem_Log\"` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_problem_status() RETURNS TRIGGER AS $$\nBEGIN\n  RETURN CASE WHEN EXISTS (SELECT 1 FROM \"Problem_Status_Codes\" WHERE problem_status_code = NEW.problem_status_code) THEN NEW ELSE NULL END;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_status_trigger\nBEFORE INSERT ON \"Problem_Log\"\nFOR EACH ROW EXECUTE FUNCTION validate_problem_status();",
    "database_name": "tracking_software_problems",
    "tables": [
      "Problems",
      "Problem_Log",
      "Problem_Status_Codes",
      "Problem_Category_Codes"
    ],
    "call_sqls": [
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (100, 11, 8, 'GUI', 'Reported', '2024-01-15 10:30:00+00:00', 'UI issue reported', NULL, 'Initial report');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (101, 12, 11, 'Middleware', 'Solved', '2024-01-15 11:45:00+00:00', 'Middleware connection fixed', 'Restarted service', 'Resolved');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (102, 13, 1, 'Datatabase', 'Reported', '2024-01-16 09:15:00+00:00', 'Database performance issue', NULL, 'Needs investigation');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (103, 14, 2, 'GUI', 'In Progress', '2024-01-16 14:20:00+00:00', 'Button not working', 'Fixed click handler', 'Testing required');",
      "INSERT INTO \"Problem_Log\" (problem_log_id, assigned_to_staff_id, problem_id, problem_category_code, problem_status_code, log_entry_date, log_entry_description, log_entry_fix, other_log_details) VALUES (104, 15, 3, 'Middleware', 'Closed', '2024-01-17 16:00:00+00:00', 'API timeout resolved', 'Increased timeout setting', 'Verified fix');"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger function named validate_problem_status for the Problem_Log table. The function checks if NEW.problem_status_code exists in the Problem_Status_Codes table. If it exists, return NEW; otherwise, return NULL to abort the operation. Create a trigger named validate_status_trigger to execute it.",
    "natural_language": "Construct a BEFORE INSERT row-level trigger function, to be named validate_problem_status, specifically for the Problem_Log table. This detailed function must meticulously verify whether the value for NEW.problem_status_code is already present within the Problem_Status_Codes table. Should this check confirm a valid, existing code, the function will gracefully return the NEW record to allow the operation. Conversely, if the code is not found, thereby being invalid, the function will deliberately return a NULL value, which effectively aborts the entire insertion attempt. Furthermore, you must create an associated trigger, named validate_status_trigger, which is responsible for executing this validation function automatically before each insert.",
    "id": 63,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_problem_status` that returns a trigger and uses a CASE statement to return the NEW record if an EXISTS subquery finds a matching `problem_status_code` in the `\"Problem_Status_Codes\"` table, otherwise returns NULL.\nSecond, define the trigger `validate_status_trigger` on table `\"Problem_Log\"` that fires BEFORE INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `validate_problem_status` that is designed to be executed as a trigger. This function takes no explicit parameters but implicitly receives special `NEW` and `OLD` records from the trigger context. The `NEW` record represents the new row that is being inserted or updated, and the `OLD` record represents the old row before the update or deletion (though `OLD` is not used in this specific function). The function returns a `TRIGGER` type, indicating its role as a trigger function. Inside the function, a conditional `CASE` statement is evaluated. The condition checks for the existence of a record in the table named `\"Problem_Status_Codes\"`. This check is performed by executing a `SELECT` statement that attempts to retrieve the value `1` (a common practice for existence checks, as the actual value doesn't matter, only the presence of a row) from `\"Problem_Status_Codes\"`. The `WHERE` clause of this `SELECT` statement filters the rows based on the condition `problem_status_code = NEW.problem_status_code`. This means it looks for a row in `\"Problem_Status_Codes\"` where the value in its `problem_status_code` column matches the value of the `problem_status_code` column from the `NEW` record (the row being inserted into `\"Problem_Log\"`). If this `EXISTS` condition evaluates to `TRUE` (meaning a matching `problem_status_code` was found in `\"Problem_Status_Codes\"`), the `CASE` statement returns the `NEW` record. This signifies that the insertion or update operation should proceed with the new row as provided. If the `EXISTS` condition evaluates to `FALSE` (meaning no matching `problem_status_code` was found in `\"Problem_Status_Codes\"`), the `CASE` statement returns `NULL`. Returning `NULL` from a `BEFORE` row-level trigger effectively aborts the `INSERT` or `UPDATE` operation for that specific row, preventing it from being added or modified in the table.\n\nFollowing the function definition, a trigger named `validate_status_trigger` is created. This trigger is configured to execute `BEFORE INSERT` operations on the table named `\"Problem_Log\"`. It is a `FOR EACH ROW` trigger, meaning the `validate_problem_status()` function will be executed once for each row that is being inserted into `\"Problem_Log\"`. The `EXECUTE FUNCTION validate_problem_status()` clause specifies that the previously defined `validate_problem_status` function should be invoked when the trigger fires. The overall purpose of this trigger and function combination is to enforce referential integrity or data validation: it ensures that any `problem_status_code` being inserted into the `\"Problem_Log\"` table must already exist as a valid `problem_status_code` in the `\"Problem_Status_Codes\"` table. If the `problem_status_code` is not found in `\"Problem_Status_Codes\"`, the insertion into `\"Problem_Log\"` is prevented."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_order_status_on_item_update that updates the Customer_Orders table, setting the order_status_code column to the string 'Updated' where the order_id matches the NEW.order_id from the updated Order_Items row, and then returns the NEW row.\nSecond, define the trigger trg_update_order_status_on_item_update on table Order_Items that fires AFTER UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_status_on_item_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Customer_Orders\" SET order_status_code = 'Updated' WHERE order_id = NEW.order_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_status_on_item_update\n    AFTER UPDATE ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_order_status_on_item_update();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "UPDATE \"Order_Items\" SET product_id = 8 WHERE order_item_id = 1;",
      "UPDATE \"Order_Items\" SET product_id = product_id + 1 WHERE order_id = 9;",
      "UPDATE \"Order_Items\" SET order_id = 5 WHERE order_item_id = 2;",
      "UPDATE \"Order_Items\" SET product_id = 3 WHERE order_id = 1;",
      "UPDATE \"Order_Items\" SET order_id = 2, product_id = 4 WHERE order_item_id = 3;"
    ],
    "summary": "Create a PostgreSQL trigger function named `update_order_status_on_item_update` that fires after UPDATE on the `Order_Items` table. For each updated row, update the `Customer_Orders` table, setting `order_status_code` to 'Updated' where `order_id` matches `NEW.order_id`. Return the `NEW` record.",
    "natural_language": "Define a PostgreSQL trigger function called `update_order_status_on_item_update` that executes after an UPDATE on the `Order_Items` table. For each row that is updated, modify the `Customer_Orders` table by setting the `order_status_code` to 'Updated' wherever the `order_id` matches `NEW.order_id`. Ensure the function returns the `NEW` record.",
    "id": 64,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function update_order_status_on_item_update in the department_store database. This function is designed to be executed as a trigger after an UPDATE operation on the Order_Items table, for each row that is updated. The function does not take any parameters directly but operates in the context of a trigger event, using the NEW keyword to access the data of the updated row in the Order_Items table. Specifically, it uses NEW.order_id to identify the associated order. The function performs an UPDATE operation on the Customer_Orders table, targeting rows where the order_id column matches NEW.order_id. For those matching rows, it sets the order_status_code column to the text value 'Updated'. After executing the update, the function returns the NEW record, which represents the updated row from the Order_Items table, allowing the trigger operation to proceed. The function is written in the PL/pgSQL language. Second, define the trigger trg_update_order_status_on_item_update on the Order_Items table. This trigger is configured to execute after an UPDATE operation on the Order_Items table, for each row that is updated. It automatically invokes the update_order_status_on_item_update function, ensuring that whenever a row in Order_Items is updated, the corresponding order in Customer_Orders has its order_status_code set to 'Updated'.",
    "original_ir": "Write a PostgreSQL trigger function named update_order_status_on_item_update that returns a trigger, which is invoked by a trigger named trg_update_order_status_on_item_update configured to fire after any update operation on each row of the Order_Items table, and within the function body, it executes an update statement on the Customer_Orders table, setting the order_status_code column to the literal string value 'Updated' for every row in Customer_Orders where the order_id column value matches the NEW record's order_id value from the updated Order_Items row, and finally the function returns the NEW row record to the invoking trigger."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_artist_paintings` that deletes rows from the `Paintings` table where the `painterID` column equals the `sculptorID` column of the deleted row from the `Sculptures` table (accessed via the `OLD` record) and returns the `OLD` record.\nSecond, define the trigger `trg_delete_artist_paintings` on table `Sculptures` that fires `AFTER` `DELETE` for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_artist_paintings() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Paintings\" WHERE \"painterID\" = OLD.\"sculptorID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_artist_paintings\nAFTER DELETE ON \"Sculptures\"\nFOR EACH ROW EXECUTE FUNCTION delete_artist_paintings();",
    "database_name": "art_1",
    "tables": [
      "Artists",
      "Paintings",
      "Sculptures"
    ],
    "call_sqls": [
      "DELETE FROM \"Sculptures\" WHERE \"sculptureID\" = 20;",
      "DELETE FROM \"Sculptures\" WHERE \"sculptureID\" = 21;",
      "DELETE FROM \"Sculptures\" WHERE \"sculptureID\" = 22;",
      "DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = 222;",
      "DELETE FROM \"Sculptures\" WHERE \"sculptorID\" = 555;"
    ],
    "summary": "Create a trigger function named `delete_artist_paintings` and a trigger named `trg_delete_artist_paintings`. The trigger should fire AFTER DELETE on the \"Sculptures\" table FOR EACH ROW. The function should delete all rows from the \"Paintings\" table where painterID equals OLD.sculptorID. The function must then return OLD.",
    "natural_language": "Construct a trigger function with the detailed name `delete_artist_paintings` and an associated trigger named `trg_delete_artist_paintings`. This trigger should be configured to activate automatically AFTER a DELETE operation is performed on the \"Sculptures\" table, executing FOR EACH ROW that is removed. The function's primary responsibility is to meticulously locate and delete every corresponding row within the \"Paintings\" table where the painterID field precisely matches the OLD.sculptorID value from the deleted sculpture record. Finally, the function must explicitly return the OLD row to complete the operation.",
    "id": 65,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `delete_artist_paintings` that deletes rows from the `Paintings` table where the `painterID` column equals the `sculptorID` column of the deleted row from the `Sculptures` table (accessed via the `OLD` record) and returns the `OLD` record.\nSecond, define the trigger `trg_delete_artist_paintings` on table `Sculptures` that fires `AFTER` `DELETE` for each row and executes the function.",
    "original_ir": "Write a PLpgSQL function named delete_artist_paintings that is designed to be used as a trigger function. This function does not take any parameters directly but operates in the context of a trigger. It is intended to execute after a delete operation on the Sculptures table. The function performs a delete operation on the Paintings table, specifically removing all rows where the painterID column matches the sculptorID column of the row that was just deleted from the Sculptures table. The OLD keyword is used to reference the values of the deleted row from the Sculptures table, allowing access to the sculptorID of the deleted record. The function returns the OLD record, which is a standard practice in trigger functions to allow further processing or logging of the deleted data. The function is associated with a trigger named trg_delete_artist_paintings, which is defined to execute after a row is deleted from the Sculptures table. The trigger is set to fire for each row that is deleted, ensuring that the function is executed individually for each deletion event, thereby maintaining the integrity of the operation by ensuring that all paintings associated with the deleted sculptor are removed from the Paintings table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function validate_bridge_length that checks if the trigger operation is 'INSERT' and if the NEW.id already exists in the bridge table; if it does, it generates a new unique id by selecting the COALESCE(MAX(id), 0) + 1 from the bridge table and assigns it to NEW.id. It then validates that the NEW.length_meters and NEW.length_feet are not negative, setting them to zero if they are. Second, define the trigger bridge_length_validation on table bridge that fires BEFORE INSERT OR UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_bridge_length() RETURNS TRIGGER AS $$\nDECLARE\n    max_id INTEGER;\nBEGIN\n  -- Handle duplicate id for INSERT operations\n  IF TG_OP = 'INSERT' THEN\n    -- Check if the id already exists\n    IF EXISTS (SELECT 1 FROM \"bridge\" WHERE \"id\" = NEW.\"id\") THEN\n      -- Generate a new unique id\n      SELECT COALESCE(MAX(\"id\"), 0) + 1 INTO max_id FROM \"bridge\";\n      NEW.\"id\" := max_id;\n    END IF;\n  END IF;\n\n  -- Validate length fields\n  IF NEW.\"length_meters\" < 0 THEN\n    NEW.\"length_meters\" := 0;\n  END IF;\n  IF NEW.\"length_feet\" < 0 THEN\n    NEW.\"length_feet\" := 0;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER bridge_length_validation\nBEFORE INSERT OR UPDATE ON \"bridge\"\nFOR EACH ROW EXECUTE FUNCTION validate_bridge_length();",
    "database_name": "architecture",
    "tables": [
      "architect",
      "bridge",
      "mill"
    ],
    "call_sqls": [
      "INSERT INTO bridge (id, name, location, length_meters, length_feet, architect_id) VALUES (1, 'Test Bridge', 'Test Location', 100.0, 328.0, 1);",
      "INSERT INTO bridge (id, name, location, length_meters, length_feet, architect_id) VALUES (1, 'Duplicate ID Bridge', 'Another Location', -50.0, -164.0, 2);",
      "UPDATE bridge SET length_meters = -25.5, length_feet = -83.7 WHERE id = 1;",
      "INSERT INTO bridge (name, location, length_meters, length_feet, architect_id) VALUES ('Auto ID Bridge', 'Auto Location', 75.0, 246.0, 3);",
      "UPDATE bridge SET length_feet = -100.0 WHERE name = 'Landscape Arch';"
    ],
    "summary": "Create a trigger function named validate_bridge_length that runs before INSERT or UPDATE on the bridge table. For INSERT operations, if the new id already exists, generate a new unique id by taking the maximum current id and adding 1. Then, ensure the length_meters and length_feet columns are not negative by setting any negative values to zero. Return the modified NEW row.",
    "natural_language": "Construct a trigger function, which should be named validate_bridge_length, designed to execute automatically prior to any INSERT or UPDATE operation performed on the bridge table. In the specific case of an INSERT, if the newly provided id is found to already exist within the table, the function must intelligently generate a fresh, unique identifier by calculating the current maximum id value and then incrementing it by one. Furthermore, the function must thoroughly validate the length_meters and length_feet columns to ensure no negative values are permitted; it should proactively intercept any negative entries and gracefully reset them to zero. Finally, the function must return the fully modified and validated NEW row for processing.",
    "id": 66,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named validate_bridge_length that returns a trigger and is executed by a trigger named trg_bridge_biu, which fires before each row is inserted or updated on the bridge table. The function declares a variable max_id of type integer to store the maximum id value from the bridge table. In the case of an INSERT operation, the function checks if the new id value provided in the NEW row already exists in the bridge table by performing a SELECT to count rows where the id column equals NEW.id; if the count is greater than zero, indicating a duplicate, the function then calculates a fresh unique identifier by selecting the maximum current id value from the bridge table into the max_id variable and sets NEW.id to max_id plus one. For both INSERT and UPDATE operations, the function validates the length_meters and length_feet columns from the NEW row: if NEW.length_meters is less than zero, it sets NEW.length_meters to zero; similarly, if NEW.length_feet is less than zero, it sets NEW.length_feet to zero. The function then returns the modified NEW row record to the trigger. Second, define the trigger trg_bridge_biu on the bridge table to execute the validate_bridge_length function before each row insert or update.",
    "original_ir": "Write a PLpgSQL function named validate_bridge_length that is designed to be used as a trigger function for the bridge table. This function does not take any parameters directly but operates on the special variables NEW and TG_OP, which are provided by the trigger mechanism. The function first checks if the operation being performed is an INSERT, indicated by TG_OP being equal to 'INSERT'. If so, it verifies whether the id of the new row (NEW.\"id\") already exists in the bridge table by executing a SELECT query with a condition on the id column. If a row with the same id is found, the function generates a new unique id by selecting the maximum id currently in the bridge table, adding one to it, and assigning this value to NEW.\"id\". This ensures that the id is unique for the new row. The function then proceeds to validate the length fields of the new row. It checks if the length_meters column of the new row (NEW.\"length_meters\") is less than zero, and if so, sets it to zero to prevent negative values. Similarly, it checks if the length_feet column (NEW.\"length_feet\") is less than zero and sets it to zero if necessary. After performing these validations and potential modifications, the function returns the NEW record, which contains the potentially modified data. This function is associated with a trigger named bridge_length_validation, which is set to fire before any INSERT or UPDATE operation on the bridge table, ensuring that the validations and id adjustments are applied to each new or updated row before it is committed to the table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function trg_customer_events_insert that simply returns the NEW row record without performing any modifications, validations, or additional data operations.\nSecond, define the trigger customer_events_insert_trigger on table \"Customer_Events\" that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_customer_events_insert() RETURNS TRIGGER AS $$\nBEGIN\n    -- No need to insert into the same table; just return the new row\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER customer_events_insert_trigger\nBEFORE INSERT ON \"Customer_Events\"\nFOR EACH ROW EXECUTE FUNCTION trg_customer_events_insert();",
    "database_name": "local_govt_and_lot",
    "tables": [
      "Customer_Events"
    ],
    "call_sqls": [
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (1, 101, '2023-01-01 10:00:00+00:00', 1001, 201, 301);",
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (2, 102, '2023-02-15 11:30:00+00:00', 1002, 202, 302);",
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (3, 103, '2023-03-20 14:00:00+00:00', 1003, 203, 303);",
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (4, 104, '2023-04-10 09:45:00+00:00', 1004, 204, 304);",
      "INSERT INTO \"Customer_Events\" (Customer_Event_ID, customer_id, date_moved_in, property_id, resident_id, thing_id) VALUES (5, 105, '2023-05-05 16:15:00+00:00', 1005, 205, 305);"
    ],
    "summary": "Create a BEFORE INSERT trigger function named trg_customer_events_insert on the Customer_Events table that returns the NEW row without modification.",
    "natural_language": "Hey, can you set up a trigger for me? Before any new entry gets added to the Customer_Events table, I need a trigger function called trg_customer_events_insert. It should just hand back the new row exactly as it is, no changes.",
    "id": 67,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named `trg_customer_events_insert` that is invoked before a row is inserted into the `Customer_Events` table. This function operates within the `local_govt_and_lot` database and is designed to execute as a `BEFORE INSERT` trigger. The function does not take any explicit parameters but implicitly receives a `NEW` record, which represents the row that is about to be inserted. The function's purpose is to return the `NEW` record unchanged, ensuring that no modifications are made to the data before insertion. Specifically, the function accesses the `NEW` record's columns: `Customer_Event_ID` of type `bigint`, `customer_id` of type `bigint`, `date_moved_in` of type `timestamp with time zone`, `property_id` of type `bigint`, `resident_id` of type `bigint`, and `thing_id` of type `bigint`. The function performs no SQL operations such as `SELECT`, `INSERT`, `UPDATE`, or `DELETE`; it contains no business logic, calculations, or control flow statements like `IF` conditions. It simply returns the `NEW` record as-is, which is a standard practice in trigger functions to allow the insertion operation to proceed with the original data. The return type of the function is `TRIGGER`, and it outputs the unaltered `NEW` record. Second, define a trigger named `trg_customer_events_insert` on the `Customer_Events` table. This trigger is configured to execute the `trg_customer_events_insert` function before any insert operation on the `Customer_Events` table. The trigger is set to fire `BEFORE INSERT` and operates `FOR EACH ROW`, ensuring that the function is invoked once for every individual row inserted into the `Customer_Events` table. The trigger ensures that the new row data is passed through without changes, as per the requirement to \"just hand back the new row exactly as it is, no changes.\"",
    "original_ir": "Write a PostgreSQL trigger function named trg_customer_events_insert that returns a trigger, which is executed as a BEFORE INSERT trigger on the \"Customer_Events\" table for each individual new row being inserted, where the function's logic is to simply return the NEW row record without performing any modifications, validations, or additional data operations, thereby allowing the insert operation to proceed normally with the original row data."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_people_country_trigger that unconditionally assigns the literal string 'Unknown' to the NEW record's column \"Country\".\nSecond, define the trigger people_country_update_trigger on table \"people\" that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_people_country_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    NEW.\"Country\" = 'Unknown';\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER people_country_update_trigger\n    BEFORE INSERT ON \"people\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_people_country_trigger();",
    "database_name": "wedding",
    "tables": [
      "church",
      "people",
      "wedding"
    ],
    "call_sqls": [
      "INSERT INTO people (People_ID, Name, Is_Male, Age) VALUES (100, 'John Doe', 'T', 28);",
      "INSERT INTO people (People_ID, Name, Country, Is_Male, Age) VALUES (101, 'Jane Smith', 'USA', 'F', 31);",
      "INSERT INTO people (Name, Is_Male, Age) VALUES ('Alex Johnson', 'T', 25);",
      "INSERT INTO people (People_ID, Name, Is_Male) VALUES (102, 'Maria Garcia', 'F');",
      "INSERT INTO people (People_ID, Name, Country, Is_Male, Age) VALUES (103, 'Test User', NULL, 'T', 40);"
    ],
    "summary": "Create a PostgreSQL BEFORE INSERT trigger function named update_people_country_trigger that sets the Country column of every new row in the people table to 'Unknown'. Then create a trigger named people_country_update_trigger to execute this function before each insert.",
    "natural_language": "Create a BEFORE INSERT trigger on the people table to set Country to 'Unknown' for new rows.",
    "id": 68,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named update_people_country_trigger that is designed to be executed as a trigger. This function does not accept any explicit input parameters but implicitly operates on the NEW pseudo-record provided by the trigger mechanism. The function returns a TRIGGER type, which is standard for PL/pgSQL trigger functions. The primary purpose of this function is to modify the Country column of a new row being inserted into the people table.\n\nUpon execution, the function performs a single assignment operation. It sets the value of the Country column within the NEW record to the string literal 'Unknown'. This is achieved by using the assignment operator in PL/pgSQL: NEW.Country := 'Unknown';. This operation unconditionally overwrites any value that might have been provided for the Country column in the INSERT statement. After this assignment, the function concludes by returning the modified NEW record. This signifies that the row to be inserted now has the Country field set to 'Unknown'.\n\nSecond, define a trigger named trg_update_people_country on the people table. This trigger is configured to execute BEFORE INSERT ON people. This means the update_people_country_trigger function will be called before any INSERT operation is applied to the people table. The FOR EACH ROW clause specifies that the trigger function will be executed once for each row that is being inserted. The EXECUTE FUNCTION update_people_country_trigger() clause explicitly calls the previously defined function. The trigger ensures that for every new row inserted into the people table, the Country column is automatically set to 'Unknown' regardless of the input value.",
    "original_ir": "Write a PostgreSQL trigger function named update_people_country_trigger that returns a trigger and is executed by a trigger named people_country_update_trigger, which is defined to fire BEFORE INSERT on the table named \"people\" for each individual row being inserted, where the function's logic unconditionally assigns the literal string value 'Unknown' to the NEW record's column named \"Country\", thereby overriding any value provided for that column in the original INSERT statement, and then returns the modified NEW row record to the database engine for the subsequent insert operation."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function sync_institution_location_trigger that updates the staff table, setting the Age column to the integer value 25 for every row where the Institution_ID matches the NEW.Institution_ID from the triggering update.\nSecond, define the trigger update_staff_ages on table institution that fires AFTER UPDATE OF the Location column and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION sync_institution_location_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    -- Assuming the intention is to reset or update the age based on some criteria, here we set it to a default value\n    UPDATE staff SET \"Age\" = 25 WHERE \"Institution_ID\" = NEW.\"Institution_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_staff_ages\n    AFTER UPDATE OF \"Location\" ON institution\n    FOR EACH ROW\n    EXECUTE FUNCTION sync_institution_location_trigger();",
    "database_name": "conference",
    "tables": [
      "conference",
      "conference_participation",
      "institution",
      "staff"
    ],
    "call_sqls": [
      "UPDATE institution SET \"Location\" = 'Chicago, Illinois' WHERE \"Institution_ID\" = 1;",
      "UPDATE institution SET \"Location\" = 'Updated Location' WHERE \"Institution_ID\" = 2;",
      "UPDATE institution SET \"Location\" = 'Springfield, Illinois' WHERE \"Institution_Name\" = 'Eureka College';",
      "UPDATE institution SET \"Location\" = 'New York, NY', \"Founded\" = 1900 WHERE \"Institution_ID\" = 3;",
      "UPDATE institution SET \"Location\" = 'Remote' WHERE \"Location\" LIKE '%Illinois%';"
    ],
    "summary": "Create a trigger function named sync_institution_location_trigger that, after the Location column is updated in the institution table, updates the Age column to 25 in the staff table for all rows where the Institution_ID matches the new Institution_ID from the updated institution row.",
    "natural_language": "Create a trigger function, which should be named sync_institution_location_trigger, that executes automatically after any modification is made to the Location column within the institution table; this comprehensive function must then meticulously update the Age column, setting it precisely to 25, across all relevant entries in the staff table, specifically targeting those rows where the Institution_ID corresponds exactly to the new Institution_ID value originating from the recently updated row in the institution table.",
    "id": 69,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named sync_institution_location_trigger, which returns a trigger and is executed after an update operation on the institution table. The function operates on the NEW record, which represents the updated row in the institution table. The function checks if the Location column of the NEW record has been modified by comparing the NEW.Location with the OLD.Location; if they are different, it proceeds to update the Age column in the staff table. Specifically, it updates the Age column to the integer value 25 for all rows in the staff table where the Institution_ID matches the Institution_ID from the NEW record. This ensures that whenever the Location column of any row in the institution table is updated, the Age of all staff members associated with that institution is set to 25. The function then returns the NEW record, allowing the update operation to complete. Second, define the trigger named trg_sync_institution_location on the institution table, which is set to execute the sync_institution_location_trigger function after each update operation on the institution table, but only when the Location column is updated, as specified by a condition on the trigger definition. This trigger ensures that the Age updates in the staff table occur automatically and consistently following changes to institution locations.",
    "original_ir": "Write a PostgreSQL trigger function named sync_institution_location_trigger that returns a trigger and is executed by a trigger named update_staff_ages, which fires after an update operation on the Location column of the institution table for each modified row; the function's logic performs an update on the staff table, setting the Age column to the integer value 25 for every row in the staff table where the Institution_ID column value matches the NEW.Institution_ID value from the triggering update on the institution table, and the function concludes by returning the NEW row record to the invoking trigger."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `delete_related_coasters` that performs a DELETE operation on the `\"roller_coaster\"` table, targeting rows where its `\"Country_ID\"` column matches the OLD record's `\"Country_ID\"` column from the deleted row, and then returns NULL. Second, define the trigger `country_delete_cascade_trigger` on table `\"country\"` that fires AFTER DELETE for each row and executes the function `delete_related_coasters()`.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_coasters() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM \"roller_coaster\" WHERE \"Country_ID\" = OLD.\"Country_ID\";\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER country_delete_cascade_trigger\nAFTER DELETE ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION delete_related_coasters();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "DELETE FROM country WHERE Country_ID = 1;",
      "DELETE FROM country WHERE Country_ID = 2;",
      "DELETE FROM country WHERE Country_ID = 3;",
      "DELETE FROM country WHERE Name = 'Austria';",
      "DELETE FROM country WHERE Population = 5261008;"
    ],
    "summary": "Create a trigger function named delete_related_coasters that returns TRIGGER. After a row is deleted from the \"country\" table, delete all rows from the \"roller_coaster\" table where \"Country_ID\" equals the OLD.\"Country_ID\". Return NULL. Create an AFTER DELETE trigger named country_delete_cascade_trigger on the \"country\" table for each row to execute this function.",
    "natural_language": "Construct a trigger function, which should be named delete_related_coasters, that is designed to return a TRIGGER. This function will perform a crucial cleanup operation: immediately after a specific row is permanently removed from the \"country\" table, it must meticulously locate and delete every single corresponding row from the \"roller_coaster\" table where the \"Country_ID\" column precisely matches the OLD.\"Country_ID\" value from the deleted record. The function should then definitively return NULL. Furthermore, you must establish an AFTER DELETE trigger, to be called country_delete_cascade_trigger, on the \"country\" table; this trigger should be configured to fire for each individual row that is deleted, thereby reliably executing the aforementioned function.",
    "id": 70,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named `delete_related_coasters` that is designed to be executed as a trigger. This function does not accept any explicit input parameters in its definition, but it implicitly receives special trigger-related variables such as `NEW` and `OLD` when invoked by a trigger. The function is declared to return a `TRIGGER` type, which is a standard requirement for functions intended for trigger execution in PostgreSQL. Upon execution, the function performs a single `DELETE` operation on the `roller_coaster` table. Specifically, it deletes all rows from the `roller_coaster` table where the value in the `Country_ID` column matches the value of `OLD.Country_ID`. `OLD.Country_ID` refers to the `Country_ID` value of the row that has just been deleted from the `country` table, as this function is designed to be an `AFTER DELETE` trigger. After performing the delete, the function returns `NULL`, which is a standard return value for `AFTER` triggers in PostgreSQL, indicating that no further row-level modifications are needed.\n\nFollowing the function definition, a trigger named `country_delete_cascade_trigger` is created. This trigger is configured to activate `AFTER DELETE` operations on the `country` table. The `FOR EACH ROW` clause specifies that the trigger function `delete_related_coasters()` will be executed once for every row that is deleted from the `country` table. The `EXECUTE FUNCTION delete_related_coasters()` clause indicates that the `delete_related_coasters` function is the specific function to be invoked when the trigger conditions are met. Therefore, whenever a row is successfully deleted from the `country` table, this trigger will automatically execute the `delete_related_coasters` function, which in turn will delete all rows from the `roller_coaster` table that have a `Country_ID` matching the `Country_ID` of the deleted country record.",
    "original_ir": "Write a PL/pgSQL trigger function named `delete_related_coasters` that is designed to be executed in response to a data manipulation event, and a trigger named `country_delete_cascade_trigger` that invokes this function. The `delete_related_coasters` function is defined to return `TRIGGER`, indicating its purpose as a trigger function. Upon execution, this function performs a `DELETE` operation on the table named `\"roller_coaster\"`. The `DELETE` operation targets rows in the `\"roller_coaster\"` table where the value in its `\"Country_ID\"` column matches the value of the `\"Country_ID\"` column from the `OLD` record. The `OLD` record represents the row that was deleted from the table on which the trigger is defined. After executing the `DELETE` statement, the function explicitly returns `NULL`, which is the standard return value for `AFTER` row-level triggers in PostgreSQL when no modification to the triggering statement's result is intended. The `country_delete_cascade_trigger` is an `AFTER DELETE` trigger, meaning it activates after a `DELETE` statement has successfully removed one or more rows from the `\"country\"` table. It is defined as a `FOR EACH ROW` trigger, which means the `delete_related_coasters` function will be executed once for each individual row that is deleted from the `\"country\"` table. The trigger's purpose is to `EXECUTE FUNCTION delete_related_coasters()`, thereby invoking the previously described function. This setup ensures that whenever a row is deleted from the `\"country\"` table, all corresponding rows in the `\"roller_coaster\"` table that have a matching `\"Country_ID\"` are also automatically deleted, effectively implementing a cascading delete behavior."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function remove_station_associations that deletes rows from the station_company table where its \"Station_ID\" column matches the \"Station_ID\" from the OLD record.\nSecond, define the trigger trg_remove_station_associations on table gas_station that fires BEFORE DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION remove_station_associations() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM station_company WHERE \"Station_ID\" = OLD.\"Station_ID\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_remove_station_associations\n    BEFORE DELETE ON gas_station\n    FOR EACH ROW\n    EXECUTE FUNCTION remove_station_associations();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM gas_station WHERE \"Station_ID\" = 1;",
      "DELETE FROM gas_station WHERE \"Station_ID\" = 2;",
      "DELETE FROM gas_station WHERE \"Station_ID\" = 3;",
      "DELETE FROM gas_station WHERE \"Location\" = 'Herne Hill';",
      "DELETE FROM gas_station WHERE \"Open_Year\" = 1999;"
    ],
    "summary": "Create a BEFORE DELETE trigger function named remove_station_associations. For each row deleted from the gas_station table, delete rows in the station_company table where Station_ID matches the OLD.Station_ID. Return the OLD record.",
    "natural_language": "Alright, so I need a trigger that fires before a gas station gets deleted. Let's call it \"remove_station_associations\". Every time you wipe a station from the gas_station table, this trigger's gotta clean up the station_company table tooâ€”specifically, nuke any entries there that have a matching Station_ID with the one being deleted. After it's done cleaning, just hand back the OLD station record.",
    "id": 71,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `remove_station_associations` in the `gas_company` database. This function is a PL/pgSQL trigger function that does not accept any explicit parameters, using the implicit `OLD` record variable provided by the trigger mechanism. The function is designed to execute before a `DELETE` operation on the `gas_station` table, for each row being deleted. The primary purpose of this function is to delete all rows from the `station_company` table where the `Station_ID` column matches the `Station_ID` of the row being deleted from the `gas_station` table, which is accessed via `OLD.Station_ID`. This ensures that any associations between the deleted gas station and companies in the `station_company` table are removed, maintaining referential integrity by cleaning up dependent records. After performing the deletion operation on the `station_company` table, the function returns the `OLD` record, representing the gas station row that is about to be deleted, allowing the trigger to proceed with the original delete operation on the `gas_station` table.\n\nSecond, define the trigger named `remove_station_associations` on the `gas_station` table. This trigger is configured to activate `BEFORE DELETE` operations on the `gas_station` table. It is a `FOR EACH ROW` trigger, meaning it will execute the associated function for every individual row that is being deleted. The trigger explicitly `EXECUTE FUNCTION remove_station_associations()`, thereby invoking the previously defined PL/pgSQL function to perform the cleanup of associated records in the `station_company` table before the gas station row is permanently removed from the `gas_station` table.",
    "original_ir": "Write a PostgreSQL trigger function named remove_station_associations that returns a trigger and is executed by a trigger named trg_remove_station_associations, which is defined to fire BEFORE DELETE on the gas_station table for each individual row being deleted; the function performs a DELETE operation on the station_company table, targeting all rows where the column named \"Station_ID\" in the station_company table matches the value of the column named \"Station_ID\" from the OLD record (which represents the gas_station row about to be deleted), and after the deletion, the function returns the OLD row record to the trigger execution context."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function check_creation_year that checks if the NEW.Creation value is less than the year '1900' and returns NULL to cancel the insert if true, otherwise returns NEW.\nSecond, define the trigger creation_year_trigger on table department that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION check_creation_year() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"Creation\" < '1900' THEN\n    RETURN NULL;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER creation_year_trigger\nBEFORE INSERT ON \"department\"\nFOR EACH ROW EXECUTE FUNCTION check_creation_year();",
    "database_name": "department_management",
    "tables": [
      "department"
    ],
    "call_sqls": [
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (10, 'Justice', '1870', 4, 35.2, 113543.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (11, 'Commerce', '1903', 5, 10.5, 45000.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (12, 'Health', '1953', 6, 150.0, 80000.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (13, 'Test Old', '1850', 7, 1.0, 100.0);",
      "INSERT INTO \"department\" (\"Department_ID\", \"Name\", \"Creation\", \"Ranking\", \"Budget_in_Billions\", \"Num_Employees\") VALUES (14, 'Test Ancient', '1200', 8, 0.5, 50.0);"
    ],
    "summary": "Create a PLpgSQL trigger function named check_creation_year that fires BEFORE INSERT on the department table FOR EACH ROW. It checks if the NEW.Creation year is less than 1900. If true, return NULL to prevent the insert. Otherwise, return NEW to allow the insert.",
    "natural_language": "Alright, so we need a trigger function in PLpgSQL called 'check_creation_year'. Set it up to run BEFORE any new row is INSERTed into the department table. For each new row, it's gotta check if the 'Creation year' field is earlier than 1900. If it is, just bail and return NULL to block the insert. If the year is 1900 or later, then it's all goodâ€”just return NEW to let the insert go through.",
    "id": 72,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `check_creation_year` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables such as `NEW` (representing the new row for `INSERT` or `UPDATE` operations) and `OLD` (representing the old row for `UPDATE` or `DELETE` operations). The function's return type is `TRIGGER`, indicating it is intended for use as a trigger function.\n\nThe function's logic begins with a conditional statement: `IF (NEW.Creation::integer) < 1900 THEN`. This condition checks if the value of the `Creation` column in the `NEW` row (the row currently being inserted) is earlier than the year 1900. To perform this comparison, the `Creation` column value, which is stored as `text`, is explicitly cast to an `integer` data type using `::integer`. This conversion allows numerical comparison with the integer value 1900.\n\nIf the condition evaluates to true (i.e., the `Creation` year of the `NEW` row is strictly less than 1900), then the function executes `RETURN NULL;`. This statement returns a `NULL` value, which in the context of a `BEFORE INSERT` trigger causes the insertion of the current row to be aborted. The row is not inserted into the `department` table.\n\nIf the condition evaluates to false (i.e., the `Creation` year of the `NEW` row is 1900 or later), then the function executes `RETURN NEW;`. This statement returns the `NEW` row, allowing the `INSERT` operation to proceed normally with the row data as provided.\n\nThe function does not perform any other SQL operations such as `SELECT`, `UPDATE`, `INSERT`, or `DELETE`. It solely relies on the data in the `NEW` row and the conditional logic described.\n\nFollowing the function definition, a trigger is defined. The trigger is configured to execute `BEFORE INSERT ON department`. This means the trigger will activate before any `INSERT` operation is performed on the `department` table. The `FOR EACH ROW` clause specifies that the trigger function `check_creation_year()` will be executed once for each row that is being inserted. The `EXECUTE FUNCTION check_creation_year()` clause specifies that the previously defined `check_creation_year` function should be invoked when the trigger fires.",
    "original_ir": "Write a PLpgSQL trigger function that is executed before an insert operation on the department table. The function, named check_creation_year, does not take any parameters and is designed to evaluate the Creation column of the row being inserted. It checks if the value in the Creation column of the new row (referred to as NEW) is less than the year 1900. If this condition is true, the function returns NULL, effectively preventing the insertion of the row into the department table. If the Creation year is 1900 or later, the function returns the NEW row, allowing the insertion to proceed. The trigger, named creation_year_trigger, is associated with the department table and is set to fire before each row is inserted, ensuring that the check_creation_year function is executed for every new row being added to the table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function update_warehouse_capacity_on_delete that updates the \"Warehouses\" table by incrementing the \"Capacity\" column by one for the row where the \"Code\" column equals the OLD.\"Warehouse\" value from the deleted \"Boxes\" row. Second, define the trigger trg_boxes_delete_capacity on table \"Boxes\" that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_warehouse_capacity_on_delete() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Warehouses\" SET \"Capacity\" = \"Capacity\" + 1 WHERE \"Code\" = OLD.\"Warehouse\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_boxes_delete_capacity\nAFTER DELETE ON \"Boxes\"\nFOR EACH ROW EXECUTE FUNCTION update_warehouse_capacity_on_delete();",
    "database_name": "warehouse_1",
    "tables": [
      "Boxes",
      "Warehouses"
    ],
    "call_sqls": [
      "DELETE FROM \"Boxes\" WHERE \"Code\" = '0MN7';",
      "DELETE FROM \"Boxes\" WHERE \"Warehouse\" = 3;",
      "DELETE FROM \"Boxes\" WHERE \"Contents\" = 'Rocks';",
      "DELETE FROM \"Boxes\" WHERE \"Value\" < 200;",
      "DELETE FROM \"Boxes\";"
    ],
    "summary": "Create an AFTER DELETE trigger function named `update_warehouse_capacity_on_delete` for the `\"Boxes\"` table. For each deleted row, update the `\"Warehouses\"` table by incrementing the `\"Capacity\"` column by 1 for the warehouse where its `\"Code\"` matches the deleted row's `\"Warehouse\"` value. Return the OLD row.",
    "natural_language": "Create AFTER DELETE trigger `update_warehouse_capacity_on_delete` on `\"Boxes\"`. Increment `\"Capacity\"` in `\"Warehouses\"` by 1 where `\"Code\"` matches deleted `\"Warehouse\"`. Return OLD.",
    "id": 73,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named update_warehouse_capacity_on_delete. This function is defined to return a trigger and uses PL/pgSQL language. It is executed automatically after each row deletion operation on the Boxes table. The function declares no local variables. It performs an UPDATE operation on the Warehouses table, specifically incrementing the Capacity column by the integer value 1 for the row where the Code column in Warehouses matches the Warehouse column value from the deleted row (referenced as OLD.Warehouse). After performing the update, the trigger function returns the OLD row record to the trigger execution context. Second, define the trigger update_warehouse_capacity_on_delete on table Boxes, specifying it to fire AFTER DELETE for each row, and execute the function update_warehouse_capacity_on_delete.",
    "original_ir": "Write a PostgreSQL trigger function named update_warehouse_capacity_on_delete that returns a trigger, which is automatically executed by a database trigger named trg_boxes_delete_capacity after a row is deleted from the \"Boxes\" table for each affected row, and within this function, it performs an update operation on the \"Warehouses\" table, specifically incrementing the value of the \"Capacity\" column by one for the single row in the \"Warehouses\" table where the value of the \"Code\" column is exactly equal to the value that was stored in the \"Warehouse\" column of the recently deleted row from the \"Boxes\" table, which is accessed via the OLD record variable, and the function concludes by returning the OLD record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_service_type that updates the Services table, setting the Service_Type_Code column to the literal string 'Updated' where the Service_ID matches the NEW.Service_ID from the Events table, and then returns the NEW row.\nSecond, define the trigger service_type_update_trigger on table Events that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_service_type() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Services\"\n  SET \"Service_Type_Code\" = 'Updated'\n  WHERE \"Service_ID\" = NEW.\"Service_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER service_type_update_trigger\nAFTER UPDATE ON \"Events\"\nFOR EACH ROW EXECUTE FUNCTION update_service_type();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants",
      "Participants_in_Events",
      "Services"
    ],
    "call_sqls": [
      "UPDATE \"Events\" SET \"Event_Details\" = 'Success' WHERE \"Event_ID\" = 3;",
      "UPDATE \"Events\" SET \"Event_Details\" = 'Fail' WHERE \"Event_ID\" = 8;",
      "UPDATE \"Events\" SET \"Event_Details\" = 'Success' WHERE \"Event_ID\" = 13;",
      "UPDATE \"Events\" SET \"Event_Details\" = 'Fail' WHERE \"Event_ID\" = 3;",
      "UPDATE \"Events\" SET \"Event_Details\" = 'Success' WHERE \"Event_ID\" = 8;"
    ],
    "summary": "Create a trigger function named `update_service_type` that returns a trigger. After a row is updated in the `Events` table, the function updates the `Services` table, setting the `Service_Type_Code` column to 'Updated' for all rows where the `Service_ID` matches the `Service_ID` of the newly updated row (from the NEW record).",
    "natural_language": "Alright, so we need a trigger function called `update_service_type` that spits out a trigger. Here's the deal: whenever a row gets changed in the `Events` table, this function should kick in. It's gotta go into the `Services` table and flip the `Service_Type_Code` to 'Updated' for every service entry that has the same `Service_ID` as the one from the freshly updated event row (that's the NEW record we're talking about).",
    "id": 74,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_service_type that updates the Services table, setting the Service_Type_Code column to the literal string 'Updated' where the Service_ID matches the NEW.Service_ID from the Events table, and then returns the NEW row.\nSecond, define the trigger service_type_update_trigger on table Events that fires AFTER UPDATE and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_service_type that returns a trigger and is invoked automatically after each row update operation on the Events table; this function executes a SQL UPDATE statement on the Services table, specifically setting the value of the Service_Type_Code column to the literal string 'Updated' for every row in the Services table where the value in its Service_ID column is equal to the value of the Service_ID column from the newly updated row (represented by the NEW record) in the Events table; the function then returns the NEW row record to the calling trigger mechanism."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_catalog_revision_date that updates the date_of_latest_revision column in the \"Catalogs\" table to the CURRENT_TIMESTAMP for the row where the catalog_id matches the catalog_id obtained from a subquery on the \"Catalog_Structure\" table, using the condition WHERE catalog_level_number = NEW.catalog_level_number.\nSecond, define the trigger trg_update_catalog_revision on table \"Catalog_Contents\" that fires AFTER INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_catalog_revision_date() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Catalogs\" SET date_of_latest_revision = CURRENT_TIMESTAMP\n    WHERE catalog_id = (SELECT catalog_id FROM \"Catalog_Structure\" WHERE catalog_level_number = NEW.catalog_level_number);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_catalog_revision\n    AFTER INSERT OR UPDATE ON \"Catalog_Contents\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_catalog_revision_date();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (4, 1, 5, 9, 7, 'Cola', '89 cp', 200.78, 159.84, 172.17, '1', '3', '9', '5');",
      "UPDATE \"Catalog_Contents\" SET catalog_entry_name = 'Root beer' WHERE catalog_entry_id = 2;",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (5, 8, 6, 6, 8, 'Cream Soda', '37 hq', 687.59, 590.11, 471.78, '8', '6', '5', '6');",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 360.5 WHERE catalog_entry_id = 3;",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, parent_entry_id, previous_entry_id, next_entry_id, catalog_entry_name, product_stock_number, price_in_dollars, price_in_euros, price_in_pounds, capacity, length, height, width) VALUES (6, 1, 5, 9, 1, 'Lemonade', '52 ee', 360.5, 202.32, 110.32, '5', '9', '7', '8');"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE trigger function for the Catalog_Contents table. For each affected row, update the Catalogs table. Set the date_of_latest_revision column to the current timestamp for the row where catalog_id matches the catalog_id from the Catalog_Structure table, based on the NEW.catalog_level_number. Return NEW.",
    "natural_language": "Create trigger after insert or update on Catalog_Contents. For each row, update Catalogs set date_of_latest_revision to now where catalog_id matches NEW.catalog_level_number in Catalog_Structure. Return NEW.",
    "id": 75,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_catalog_revision_date that updates the date_of_latest_revision column in the \"Catalogs\" table to the CURRENT_TIMESTAMP for the row where the catalog_id matches the catalog_id obtained from a subquery on the \"Catalog_Structure\" table, using the condition WHERE catalog_level_number = NEW.catalog_level_number.\nSecond, define the trigger trg_update_catalog_revision on table \"Catalog_Contents\" that fires AFTER INSERT OR UPDATE for each row and executes the function.",
    "original_ir": "Write a PLpgSQL function that updates the date_of_latest_revision column in the Catalogs table to the current timestamp for the row where the catalog_id matches the catalog_id obtained from the Catalog_Structure table, based on the catalog_level_number of the newly inserted or updated row in the Catalog_Contents table. This function is triggered after any insert or update operation on the Catalog_Contents table, and it uses the NEW keyword to reference the catalog_level_number of the affected row. The trigger named trg_update_catalog_revision is responsible for executing this function for each row that is inserted or updated in the Catalog_Contents table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_validate_photo_references` that checks if a referenced `mountain_id` exists in the `\"mountain\"` table by using a `SELECT 1` query within an `IF NOT EXISTS` condition and raises an exception with the message 'Referenced mountain does not exist' if no match is found, otherwise it returns the `NEW` row.\nSecond, define the trigger `validate_photo_references` on table `\"photos\"` that fires `BEFORE` `INSERT OR UPDATE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_validate_photo_references() RETURNS TRIGGER AS $$\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM \"mountain\" WHERE \"id\" = NEW.\"mountain_id\") THEN\n        RAISE EXCEPTION 'Referenced mountain does not exist';\n    END IF;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_photo_references\nBEFORE INSERT OR UPDATE ON \"photos\"\nFOR EACH ROW EXECUTE FUNCTION trg_validate_photo_references();",
    "database_name": "mountain_photos",
    "tables": [
      "camera_lens",
      "mountain",
      "photos"
    ],
    "call_sqls": [
      "INSERT INTO \"photos\" (id, camera_lens_id, mountain_id, color, name) VALUES (4, 1, 1, 'RBG', 'sunrise');",
      "INSERT INTO \"photos\" (id, camera_lens_id, mountain_id, color, name) VALUES (5, 2, 2, 'Black/White', 'clouds');",
      "UPDATE \"photos\" SET mountain_id = 3 WHERE id = 1;",
      "INSERT INTO \"photos\" (id, camera_lens_id, mountain_id, color, name) VALUES (6, 1, 1, 'RBG', 'forest');",
      "UPDATE \"photos\" SET mountain_id = 2 WHERE id = 2;"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger function named trg_validate_photo_references for the photos table. Validate that the NEW.mountain_id exists in the mountain.id column. If it does not exist, raise an exception 'Referenced mountain does not exist'. Return the NEW record.",
    "natural_language": "Please construct a BEFORE INSERT OR UPDATE row-level trigger function designated as trg_validate_photo_references for the photos table. The function must validate the existence of the NEW.mountain_id value within the id column of the mountain table. Should the referenced mountain_id not be present, the function is to raise an exception with the message 'Referenced mountain does not exist'. Subsequently, the function must return the NEW record.",
    "id": 76,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named trg_validate_photo_references in the mountain_photos database. This function is a PostgreSQL PL/pgSQL trigger function that is automatically executed by a trigger before any insert or update operation on the photos table for each individual row being inserted or updated. The function accepts no explicit parameters but uses the special NEW record variable to access the incoming row data. Within its logic, it performs a validation check to ensure referential integrity by verifying that the NEW.mountain_id value exists in the id column of the mountain table. This is done using a SELECT statement with a WHERE clause that matches mountain.id to NEW.mountain_id. If no row is found, indicating the referenced mountain does not exist, the function raises an exception with the SQLSTATE '23503' (foreign key violation) and the message 'Referenced mountain does not exist'. If the validation passes, the function proceeds to return the NEW record unchanged, allowing the insert or update operation to continue. Second, define the trigger named validate_photo_references_trigger on the photos table, specifying that it fires before each row insert or update and executes the function trg_validate_photo_references.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `trg_validate_photo_references` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it implicitly receives special variables such as `NEW` (representing the new row for `INSERT` or `UPDATE` operations). The function's primary purpose is to validate referential integrity for a `mountain_id` column. Upon execution, it first performs a `SELECT` operation to check for the existence of a record in the `\"mountain\"` table. Specifically, it attempts to select the constant value `1` from the `\"mountain\"` table where the `\"id\"` column of the `\"mountain\"` table matches the value of the `mountain_id` column from the `NEW` row (the row being inserted or updated in the `photos` table). This `SELECT` statement is encapsulated within an `IF NOT EXISTS` conditional block. If the `SELECT` query returns no rows, indicating that no mountain with the specified `mountain_id` exists in the `\"mountain\"` table, then the function executes a `RAISE EXCEPTION` statement, which immediately terminates the current operation and signals an error with the message 'Referenced mountain does not exist'. If, however, the `SELECT` query finds at least one matching record in the `\"mountain\"` table, meaning the referenced mountain exists, the `IF NOT EXISTS` condition evaluates to false, and the exception is not raised. In this case, the function proceeds to the `RETURN NEW` statement, which allows the `INSERT` or `UPDATE` operation on the `photos` table to continue with the `NEW` row.\n\nThis function is then associated with a trigger named `validate_photo_references`. This trigger is configured to execute `BEFORE INSERT OR UPDATE` operations on the `\"photos\"` table. The `FOR EACH ROW` clause specifies that the trigger function `trg_validate_photo_references()` will be executed once for each row that is being inserted or updated in the `\"photos\"` table. The `EXECUTE FUNCTION trg_validate_photo_references()` clause specifies that the `trg_validate_photo_references` function is the one to be invoked by this trigger. Therefore, before any new row is inserted into the `\"photos\"` table or any existing row in the `\"photos\"` table is updated, this trigger will ensure that the `mountain_id` specified in that row correctly references an existing `id` in the `\"mountain\"` table, preventing the creation of orphaned references."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_round_theme` that updates the `Decoration_Theme` column to the string 'Updated Theme' in the `round` table for rows where the `Member_ID` matches the `NEW.Member_ID` from the triggering event and returns the `NEW` row.\nSecond, define the trigger `trigger_update_round_theme` on table `member` that fires `AFTER UPDATE` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION \"update_round_theme\"() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"round\" SET \"Decoration_Theme\" = 'Updated Theme' WHERE \"Member_ID\" = NEW.\"Member_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER \"trigger_update_round_theme\"\nAFTER UPDATE ON \"member\"\nFOR EACH ROW EXECUTE FUNCTION \"update_round_theme\"();",
    "database_name": "decoration_competition",
    "tables": [
      "college",
      "member",
      "round"
    ],
    "call_sqls": [
      "UPDATE \"member\" SET \"Name\" = 'Tiger Woods' WHERE \"Member_ID\" = 1;",
      "UPDATE \"member\" SET \"Country\" = 'United Kingdom' WHERE \"Member_ID\" = 2;",
      "UPDATE \"member\" SET \"College_ID\" = 3 WHERE \"Member_ID\" = 3;",
      "UPDATE \"member\" SET \"Name\" = 'Phil Mickelson', \"Country\" = 'USA' WHERE \"Member_ID\" = 1;",
      "UPDATE \"member\" SET \"College_ID\" = NULL WHERE \"Member_ID\" = 2;"
    ],
    "summary": "Create an AFTER UPDATE trigger on the member table. For each updated row, update the round table's Decoration_Theme to 'Updated Theme' where the Member_ID matches the updated member's Member_ID. Return the NEW row.",
    "natural_language": "Set up a trigger that runs after changes are made to the member table. Whenever a member's details are tweaked, you should also adjust the decoration theme for their associated round table to something like an updated theme, matching on the member ID. Just make sure the new row data comes back.",
    "id": 77,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a trigger function that returns a trigger and is executed automatically as an AFTER UPDATE trigger on the member table in the decoration_competition database. The trigger is configured to activate FOR EACH ROW, meaning it will execute once for every row updated in the member table. The trigger function implicitly receives special record variables: NEW (representing the updated row data after the UPDATE operation) and OLD (representing the original row data before the UPDATE operation). Inside the function, an UPDATE operation is performed on the round table. This UPDATE statement sets the Decoration_Theme column to the string literal value 'updated theme' for every row in the round table where the Member_ID column value matches the Member_ID value from the NEW record of the triggering update on the member table. The function concludes by returning the NEW record, which is a standard requirement for AFTER row-level triggers in PostgreSQL. Second, define the trigger on the member table to invoke this function after any UPDATE operation on the table.",
    "original_ir": "Write a PLpgSQL trigger function that updates the Decoration_Theme column in the round table to the string 'Updated Theme' for any row where the Member_ID matches the Member_ID of the newly updated row in the member table. The function is named update_round_theme and is designed to be executed as a trigger. The trigger, named trigger_update_round_theme, is set to activate after an update operation on the member table. For each row that is updated in the member table, the trigger executes the update_round_theme function, which performs an update operation on the round table. The update operation specifically targets rows in the round table where the Member_ID column matches the Member_ID of the newly updated row in the member table, setting the Decoration_Theme column to 'Updated Theme'. The function returns the NEW row, which represents the state of the row after the update operation in the member table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_adjust_salary` that declares a local variable `v_min_salary` of type numeric, selects the `\"MIN_SALARY\"` from the `\"jobs\"` table where `\"JOB_ID\"` matches the NEW row's `\"JOB_ID\"` into that variable, and then conditionally updates the NEW row's `\"SALARY\"` by multiplying it by 1.1 if it is less than the retrieved minimum.\nSecond, define the trigger `adjust_salary` on table `\"employees\"` that fires BEFORE UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_adjust_salary() RETURNS TRIGGER AS $$\nDECLARE\n  v_min_salary numeric;\nBEGIN\n  -- Ensure all column names are quoted to match the schema's uppercase naming\n  SELECT \"MIN_SALARY\" INTO v_min_salary FROM \"jobs\" WHERE \"JOB_ID\" = NEW.\"JOB_ID\";\n  \n  IF NEW.\"SALARY\" < v_min_salary THEN\n    NEW.\"SALARY\" := NEW.\"SALARY\" * 1.1;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER adjust_salary\nBEFORE UPDATE ON \"employees\" -- Quote table name as well for consistency\nFOR EACH ROW EXECUTE FUNCTION trg_adjust_salary();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "UPDATE \"employees\" SET \"SALARY\" = 18000 WHERE \"EMPLOYEE_ID\" = 100 AND \"JOB_ID\" = 'AD_PRES';",
      "UPDATE \"employees\" SET \"SALARY\" = 14000, \"JOB_ID\" = 'AD_VP' WHERE \"EMPLOYEE_ID\" = 101;",
      "UPDATE \"employees\" SET \"SALARY\" = 2800 WHERE \"JOB_ID\" = 'AD_ASST';",
      "UPDATE \"employees\" SET \"SALARY\" = \"SALARY\" - 5000 WHERE \"DEPARTMENT_ID\" = 90;",
      "UPDATE \"employees\" SET \"SALARY\" = 19000 WHERE \"EMPLOYEE_ID\" = 102 AND \"JOB_ID\" = 'AD_VP';"
    ],
    "summary": "Create a PL/pgSQL trigger function named trg_adjust_salary that executes BEFORE UPDATE on the employees table for each row. It retrieves the MIN_SALARY for the NEW.JOB_ID from the jobs table. If the NEW.SALARY is less than this minimum, it increases the NEW.SALARY by 10%. The function returns the NEW record.",
    "natural_language": "Please construct a PL/pgSQL trigger function designated as 'trg_adjust_salary'. This function is to be executed prior to any update operation on the 'employees' table, acting upon each individual row. Its procedure involves querying the 'jobs' table to ascertain the MIN_SALARY value corresponding to the NEW.JOB_ID. Should the NEW.SALARY value be found inferior to the retrieved minimum, the function shall augment the NEW.SALARY by ten percent. The function must conclude by returning the modified NEW record.",
    "id": 78,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named trg_adjust_salary in the hr_1 database, which is a PostgreSQL PL/pgSQL trigger function that returns a trigger. The function is executed automatically by a trigger before every update operation on the employees table for each row being updated. The function declares a local variable min_salary_val of type numeric to store the minimum salary value retrieved from the jobs table. The function performs a SELECT statement that retrieves the MIN_SALARY column value from the jobs table where the JOB_ID column matches the NEW.JOB_ID value from the updated row in the employees table, storing this result into the min_salary_val variable. Then, the function implements a conditional check: if the NEW.SALARY value from the updated row is less than the min_salary_val variable, it updates the NEW.SALARY value by multiplying it by 1.10, effectively increasing it by ten percent. After this conditional logic, the function returns the NEW row record, which may have been modified if the condition was met. Second, define the trigger trg_adjust_salary_trigger on the employees table to fire before update on each row, executing the trg_adjust_salary function.",
    "original_ir": "Write a PL/pgSQL trigger function named `trg_adjust_salary` that is designed to be executed before an update operation on each row of the `\"employees\"` table. This function declares a local variable `v_min_salary` of type `numeric`. The function begins by executing a `SELECT` statement to retrieve the value of the `\"MIN_SALARY\"` column from the `\"jobs\"` table. This retrieval is conditioned by matching the `\"JOB_ID\"` column in the `\"jobs\"` table with the value of the `\"JOB_ID\"` column from the `NEW` row being updated in the `\"employees\"` table. The retrieved `\"MIN_SALARY\"` value is then assigned to the `v_min_salary` variable. Following this, a conditional check is performed: if the value of the `\"SALARY\"` column in the `NEW` row (representing the updated employee's salary) is less than the `v_min_salary` value obtained from the `\"jobs\"` table, then the `\"SALARY\"` column in the `NEW` row is updated by multiplying its current value by `1.1`. Finally, the function returns the `NEW` row, which contains the potentially adjusted salary, to the calling trigger. This trigger function is associated with a trigger named `adjust_salary`, which is configured to execute `BEFORE UPDATE` operations on the `\"employees\"` table `FOR EACH ROW`, invoking the `trg_adjust_salary()` function."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_catalog_price_in_euros that checks if the NEW.catalog_entry_id is NULL and raises an exception with the message 'catalog_entry_id cannot be NULL' if true; if false, it calculates the NEW.price_in_euros by multiplying NEW.price_in_dollars by 0.85.\nSecond, define the trigger trg_update_catalog_price_in_euros on table \"Catalog_Contents\" that fires BEFORE INSERT OR UPDATE OF price_in_dollars and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_catalog_price_in_euros() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.catalog_entry_id IS NULL THEN\n    RAISE EXCEPTION 'catalog_entry_id cannot be NULL';\n  END IF;\n  NEW.price_in_euros = NEW.price_in_dollars * 0.85;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_catalog_price_in_euros\nBEFORE INSERT OR UPDATE OF price_in_dollars ON \"Catalog_Contents\"\nFOR EACH ROW EXECUTE FUNCTION update_catalog_price_in_euros();",
    "database_name": "product_catalog",
    "tables": [
      "Attribute_Definitions",
      "Catalog_Contents",
      "Catalog_Contents_Additional_Attributes",
      "Catalog_Structure",
      "Catalogs"
    ],
    "call_sqls": [
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, price_in_dollars) VALUES (4, 1, 'Orange Soda', 150.00);",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, price_in_dollars) VALUES (5, 2, 'Grape Soda', 250.00);",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 300.00 WHERE catalog_entry_id = 1;",
      "UPDATE \"Catalog_Contents\" SET price_in_dollars = 400.00 WHERE catalog_entry_id = 2;",
      "INSERT INTO \"Catalog_Contents\" (catalog_entry_id, catalog_level_number, catalog_entry_name, price_in_dollars) VALUES (6, 3, 'Lemon Soda', 180.00);"
    ],
    "summary": "Create a PostgreSQL trigger function named update_catalog_price_in_euros that runs BEFORE INSERT OR UPDATE of price_in_dollars on the Catalog_Contents table. It raises an exception if NEW.catalog_entry_id is NULL. Otherwise, it sets NEW.price_in_euros to NEW.price_in_dollars * 0.85 and returns the NEW row.",
    "natural_language": "Make a trigger function for PostgreSQL called update_catalog_price_in_euros that should fire before adding or changing the price_in_dollars in the Catalog_Contents table. It should complain if the new catalog entry identifier is missing. If it's okay, then just have it figure out the price in euros by taking the dollar amount and multiplying it by a decent conversion rate, and then send back the updated record.",
    "id": 79,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_catalog_price_in_euros that checks if the NEW.catalog_entry_id is NULL and raises an exception with the message 'catalog_entry_id cannot be NULL' if true; if false, it calculates the NEW.price_in_euros by multiplying NEW.price_in_dollars by 0.85.\nSecond, define the trigger trg_update_catalog_price_in_euros on table \"Catalog_Contents\" that fires BEFORE INSERT OR UPDATE OF price_in_dollars and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_catalog_price_in_euros that is executed automatically by a trigger named trg_update_catalog_price_in_euros before any INSERT operation or before any UPDATE operation that modifies the price_in_dollars column on the table named \"Catalog_Contents\" for each affected row, where the function first checks if the NEW record's catalog_entry_id column value is NULL and, if this condition is true, raises an exception with the message 'catalog_entry_id cannot be NULL', but if the condition is false, calculates a new value for the NEW record's price_in_euros column by multiplying the NEW record's price_in_dollars column value by the constant 0.85, and then returns the modified NEW record to the triggering statement."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_customer_details_on_policy_update that updates the \"Customers\" table by setting the \"Customer_Details\" column to its lowercase version using the LOWER function, specifically for the row where the \"Customer_ID\" matches the NEW.\"Customer_ID\" from the trigger.\nSecond, define the trigger trg_update_customer_details_on_policy_update on table \"Customer_Policies\" that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_customer_details_on_policy_update() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Customers\"\n  SET \"Customer_Details\" = LOWER(\"Customer_Details\")\n  WHERE \"Customer_ID\" = NEW.\"Customer_ID\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_customer_details_on_policy_update\nAFTER UPDATE ON \"Customer_Policies\"\nFOR EACH ROW EXECUTE FUNCTION update_customer_details_on_policy_update();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "UPDATE \"Customer_Policies\" SET \"Policy_Type_Code\" = 'Home' WHERE \"Policy_ID\" = 119;",
      "UPDATE \"Customer_Policies\" SET \"Policy_Type_Code\" = 'Health' WHERE \"Policy_ID\" = 141;",
      "UPDATE \"Customer_Policies\" SET \"Policy_Type_Code\" = 'Travel' WHERE \"Policy_ID\" = 143;",
      "UPDATE \"Customer_Policies\" SET \"Start_Date\" = '2019-01-01' WHERE \"Policy_ID\" = 119;",
      "UPDATE \"Customer_Policies\" SET \"End_Date\" = '2020-01-01' WHERE \"Policy_ID\" = 141;"
    ],
    "summary": "Create a PLpgSQL trigger function that runs AFTER UPDATE on the Customer_Policies table. It updates the Customers table, setting the Customer_Details column to lowercase for the row where Customer_ID matches the NEW row's Customer_ID. The function returns the updated NEW row.",
    "natural_language": "Please construct a PL/pgSQL trigger function that executes subsequent to an UPDATE operation on the Customer_Policies table. This function shall modify the Customers table by converting the Customer_Details column to lowercase for the specific record whose Customer_ID corresponds to the Customer_ID value in the NEW row. The function must be defined to return the updated NEW row.",
    "id": 80,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named `update_customer_details_on_policy_update` in the `insurance_policies` database. This function is a PostgreSQL PL/pgSQL trigger function designed to execute after an UPDATE operation on the `Customer_Policies` table. The function implicitly receives the special record variables `NEW` and `OLD`, where `NEW` represents the updated row data and `OLD` represents the original row data before the update. The function does not declare any explicit variables. Within its execution block, it performs a single SQL operation: an UPDATE on the `Customers` table. Specifically, it sets the `Customer_Details` column to the lowercase version of its current value for the row where the `Customer_ID` matches the `Customer_ID` value from the `NEW` record of the `Customer_Policies` table. The lowercase conversion is achieved using the `LOWER()` function. This operation updates exactly one row, assuming the `Customer_ID` in `NEW` corresponds to an existing record in the `Customers` table. After performing the update, the function returns the `NEW` row, which is a standard requirement for row-level triggers in PostgreSQL to allow the operation to proceed. Second, define the trigger on the `Customer_Policies` table. The trigger is configured to activate AFTER any UPDATE operation on the `Customer_Policies` table. The FOR EACH ROW clause specifies that the trigger function executes once for each row updated. The trigger is associated with the function `update_customer_details_on_policy_update`. Therefore, whenever a row in `Customer_Policies` is updated, this trigger automatically updates the corresponding customer's details in the `Customers` table by converting their `Customer_Details` to lowercase.",
    "original_ir": "Write a PLpgSQL function that updates the Customers table by setting the Customer_Details column to its lowercase version for the row where the Customer_ID matches the Customer_ID of the newly updated row in the Customer_Policies table, and returns the newly updated row. This function is executed by a trigger named trg_update_customer_details_on_policy_update, which is fired after any update operation on the Customer_Policies table, ensuring that for each updated row in Customer_Policies, the corresponding Customer_Details in the Customers table is converted to lowercase."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_invoice_line_on_order_item` that performs an INSERT into the table \"Invoice_Line_Items\", using values from the NEW record of the \"Order_Items\" table: set `order_item_id` to NEW.order_item_id, `product_id` to NEW.product_id, `product_title` to the literal string 'Product from Order', `product_quantity` to NEW.product_quantity, `product_price` to the fixed value 100.00, `derived_product_cost` to 50.00, and `derived_total_cost` to 150.00, and then returns NEW.\nSecond, define the trigger `trg_insert_invoice_line` on table \"Order_Items\" that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_invoice_line_on_order_item() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"Invoice_Line_Items\" (order_item_id, product_id, product_title, product_quantity, product_price, derived_product_cost, derived_total_cost) VALUES (NEW.order_item_id, NEW.product_id, 'Product from Order', NEW.product_quantity, 100.00, 50.00, 150.00);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_invoice_line\n    AFTER INSERT ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_invoice_line_on_order_item();",
    "database_name": "customers_and_invoices",
    "tables": [
      "Accounts",
      "Customers",
      "Financial_Transactions",
      "Invoices",
      "Invoice_Line_Items",
      "Order_Items",
      "Orders"
    ],
    "call_sqls": [
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (1, 1, 101, '2');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (2, 1, 102, '1');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (3, 2, 201, '3');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (4, 3, 305, '5');",
      "INSERT INTO \"Order_Items\" (order_item_id, order_id, product_id, product_quantity) VALUES (5, 4, 401, '1');"
    ],
    "summary": "Create a trigger function named insert_invoice_line_on_order_item and a trigger named trg_insert_invoice_line. The function, executed AFTER INSERT on the Order_Items table for each row, inserts a new row into the Invoice_Line_Items table. It populates the columns using values from the new order item (order_item_id, product_id, product_quantity) and sets static values for product_title ('Product from Order'), product_price (100.00), derived_product_cost (50.00), and derived_total_cost (150.00). The function returns NEW.",
    "natural_language": "Alright, so we need a trigger function called insert_invoice_line_on_order_item and a trigger named trg_insert_invoice_line. Here's the deal: every time a new row gets added to the Order_Items table, this function kicks in right after. For each new order item, it'll automatically slap a new row into the Invoice_Line_Items table. It grabs the order_item_id, product_id, and product_quantity from the fresh order item. Then it fills in the rest with some fixed stuff: the product_title is always 'Product from Order', price is set at 100 bucks, cost is 50, and the total cost comes out to 150. Oh, and the function just hands back the NEW record at the end.",
    "id": 81,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration for the customers_and_invoices database. First, create a trigger function named insert_invoice_line_on_order_item that returns a trigger and is executed automatically by a trigger named trg_insert_invoice_line, which is defined to fire AFTER INSERT on the Order_Items table FOR EACH ROW. Within this function, for each newly inserted row in the Order_Items table, a new row is inserted into the Invoice_Line_Items table. The function extracts the order_item_id, product_id, and product_quantity values directly from the NEW record of the Order_Items table. For the remaining columns in the Invoice_Line_Items table, the function assigns fixed values: the product_title column is set to the string literal 'Product from Order', the product_price column is set to the numeric value 100.00, the derived_product_cost column is set to the numeric value 50.00, and the derived_total_cost column is set to the numeric value 150.00. The invoice_number column is left as NULL or default, as it is not specified in the description. The derived_vat_payable column is also not set, implying it remains NULL or default. No conditions or control flow logic are applied; the insertion occurs unconditionally for every new Order_Items row. After performing the insert operation, the function returns the NEW record to allow the trigger to complete. Second, define the trigger trg_insert_invoice_line on the Order_Items table to execute the insert_invoice_line_on_order_item function after each insert operation.",
    "original_ir": "Write a PostgreSQL trigger function named insert_invoice_line_on_order_item that is executed automatically by a trigger named trg_insert_invoice_line, which is defined to fire AFTER an INSERT operation occurs on the table named \"Order_Items\" for each new row added, and this function performs a single INSERT operation into the table named \"Invoice_Line_Items\", populating its columns with specific values: the order_item_id column receives the value from the NEW.order_item_id field of the newly inserted \"Order_Items\" row, the product_id column receives the value from the NEW.product_id field, the product_title column is set to the literal string 'Product from Order', the product_quantity column receives the value from the NEW.product_quantity field, the product_price column is set to the fixed numeric value 100.00, the derived_product_cost column is set to the fixed numeric value 50.00, and the derived_total_cost column is set to the fixed numeric value 150.00, after which the function returns the NEW row record to the trigger execution context."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_rating_stars` that checks the `stars` column of the new row using the `NEW` record variable, raises an exception with the message 'Rating stars must be between 1 and 5' if the value is less than 1 or greater than 5, and otherwise returns `NEW`.\nSecond, define the trigger `validate_rating_stars_trigger` on table `Rating` that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_rating_stars() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"stars\" < 1 OR NEW.\"stars\" > 5 THEN\n    RAISE EXCEPTION 'Rating stars must be between 1 and 5';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER validate_rating_stars_trigger\nBEFORE INSERT OR UPDATE ON \"Rating\"\nFOR EACH ROW EXECUTE FUNCTION validate_rating_stars();",
    "database_name": "movie_1",
    "tables": [
      "Movie",
      "Rating",
      "Reviewer"
    ],
    "call_sqls": [
      "INSERT INTO \"Rating\" (rID, mID, stars, ratingDate) VALUES (203, 101, 3, '2023-01-01');",
      "INSERT INTO \"Rating\" (rID, mID, stars, ratingDate) VALUES (204, 102, 5, '2023-01-02');",
      "UPDATE \"Rating\" SET stars = 1 WHERE rID = 201;",
      "UPDATE \"Rating\" SET stars = 4 WHERE rID = 202;",
      "INSERT INTO \"Rating\" (rID, mID, stars, ratingDate) VALUES (205, 103, 0, '2023-01-03');"
    ],
    "summary": "Create a trigger function named validate_rating_stars that, before inserting or updating a row in the Rating table, checks if the new stars value is between 1 and 5 inclusive. If not, raise an exception 'Rating stars must be between 1 and 5'. Otherwise, allow the operation.",
    "natural_language": "Hey, can you whip up a trigger function called validate_rating_stars? Before any new rating gets added or an existing one is changed in the Rating table, it's gotta check if the stars value is from 1 to 5. If it's not in that range, just throw an error saying 'Rating stars must be between 1 and 5'. If it's all good, then let it slide.",
    "id": 82,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `validate_rating_stars` that checks the `stars` column of the new row using the `NEW` record variable, raises an exception with the message 'Rating stars must be between 1 and 5' if the value is less than 1 or greater than 5, and otherwise returns `NEW`.\nSecond, define the trigger `validate_rating_stars_trigger` on table `Rating` that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named validate_rating_stars that returns a trigger, which is executed by a trigger named validate_rating_stars_trigger defined on the table named Rating, where the trigger is configured to fire BEFORE any INSERT or UPDATE operation on that table for each individual row being processed, and within the function's logic, it accesses the new row data using the NEW record variable to check the value of the column named stars, and if that value is less than 1 OR greater than 5, it raises an exception with the message 'Rating stars must be between 1 and 5', thereby preventing the insert or update operation from completing, but if the stars value is between 1 and 5 inclusive, the function proceeds to return the NEW row record, allowing the triggering INSERT or UPDATE operation to proceed normally."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_championships that checks if the new value of the \"Number_of_Championships\" column is greater than the old value and, if true, updates the \"Joined\" column in the \"Championship\" table for rows where \"Institution_ID\" matches the new row's \"Institution_ID\", setting \"Joined\" to the current year extracted from the current date and cast to a real number.\nSecond, define the trigger update_championships_trigger on table \"Championship\" that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_championships() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.\"Number_of_Championships\" > OLD.\"Number_of_Championships\" THEN\n    UPDATE \"Championship\" SET \"Joined\" = EXTRACT(YEAR FROM CURRENT_DATE)::real WHERE \"Institution_ID\" = NEW.\"Institution_ID\";\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_championships_trigger\nAFTER UPDATE ON \"Championship\"\nFOR EACH ROW EXECUTE FUNCTION update_championships();",
    "database_name": "institution_sports",
    "tables": [
      "Championship"
    ],
    "call_sqls": [
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 2.0 WHERE \"Institution_ID\" = 1;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 1.5 WHERE \"Institution_ID\" = 2;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 3.0 WHERE \"Institution_ID\" = 3;",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = \"Number_of_Championships\" + 1 WHERE \"Nickname\" = 'Terrapins';",
      "UPDATE \"Championship\" SET \"Number_of_Championships\" = 5.0 WHERE \"Institution_ID\" = 2 AND \"Number_of_Championships\" < 5.0;"
    ],
    "summary": "Create a PostgreSQL trigger function named update_championships that fires AFTER UPDATE on the Championship table for each row. If NEW.Number_of_Championships is greater than OLD.Number_of_Championships, it updates the Joined column in the Championship table to the current year (as a REAL) for the row where Institution_ID equals NEW.Institution_ID, then returns the NEW record.",
    "natural_language": "Set up a trigger function called update_championships that runs after changes to the Championship table. When the championship count goes up a bit, it should adjust the Joined date to something more recent for that institution's record, and then give back the updated row.",
    "id": 83,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_championships that checks if the new value of the \"Number_of_Championships\" column is greater than the old value and, if true, updates the \"Joined\" column in the \"Championship\" table for rows where \"Institution_ID\" matches the new row's \"Institution_ID\", setting \"Joined\" to the current year extracted from the current date and cast to a real number.\nSecond, define the trigger update_championships_trigger on table \"Championship\" that fires AFTER UPDATE and executes the function.",
    "original_ir": "Write a PLpgSQL function that is triggered after an update operation on the \"Championship\" table. This function, named update_championships, is designed to execute for each row that is updated. It checks if the new value of the \"Number_of_Championships\" column is greater than the old value of the same column. If this condition is met, the function updates the \"Joined\" column in the \"Championship\" table for the row where the \"Institution_ID\" matches the \"Institution_ID\" of the newly updated row. The \"Joined\" column is set to the current year, extracted from the current date and cast to a real number. The function then returns the new row data. The trigger, named update_championships_trigger, is associated with this function and is set to activate after any update operation on the \"Championship\" table, ensuring that the function is executed for each updated row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `adjust_enrollment_on_height` that updates the `\"Institution\"` table by setting the `\"Enrollment\"` column to the result of the `GREATEST` function, which compares the current `\"Enrollment\"` value with the product of the `NEW.\"Height_feet\"` value from the `\"building\"` table and 10, and applies this update only where the `\"building_id\"` matches `NEW.\"building_id\"`, then returns `NEW`.\nSecond, define the trigger `trg_adjust_enrollment_on_height` on table `\"building\"` that fires `AFTER` `INSERT OR UPDATE OF \"Height_feet\"` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION adjust_enrollment_on_height() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Institution\" SET \"Enrollment\" = GREATEST(\"Enrollment\", NEW.\"Height_feet\" * 10) WHERE \"building_id\" = NEW.\"building_id\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_adjust_enrollment_on_height\nAFTER INSERT OR UPDATE OF \"Height_feet\" ON \"building\"\nFOR EACH ROW EXECUTE FUNCTION adjust_enrollment_on_height();",
    "database_name": "protein_institute",
    "tables": [
      "Institution",
      "building",
      "protein"
    ],
    "call_sqls": [
      "INSERT INTO building (building_id, Name, Street_address, Years_as_tallest, Height_feet, Floors) VALUES ('10', 'New Building 1', '123 Main St', '2023-2024', 100, 10);",
      "UPDATE building SET \"Height_feet\" = 150 WHERE building_id = '1';",
      "INSERT INTO building (building_id, Name, Street_address, Years_as_tallest, Height_feet, Floors) VALUES ('11', 'New Building 2', '456 Oak Ave', '2023-2025', 200, 20);",
      "UPDATE building SET \"Height_feet\" = 250 WHERE building_id = '3';",
      "INSERT INTO building (building_id, Name, Street_address, Years_as_tallest, Height_feet, Floors) VALUES ('12', 'New Building 3', '789 Pine Ln', '2023-2026', 50, 5);"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE OF Height_feet trigger function named adjust_enrollment_on_height for the building table. The function must update the Institution table, setting Enrollment to the greater of its current value or (NEW.Height_feet * 10), where building_id matches NEW.building_id, then return the NEW record.",
    "natural_language": "Create a trigger function named adjust_enrollment_on_height for the building table that fires AFTER INSERT OR UPDATE OF Height_feet. Make it update the Institution table by setting Enrollment to the maximum of its current value or (NEW.Height_feet * 10) where the building_id matches NEW.building_id, and then return the NEW record.",
    "id": 84,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named adjust_enrollment_on_height. This function is designed to be executed as a trigger function and does not take any parameters directly but operates on the implicit NEW record provided by the trigger mechanism. The function updates the Institution table by setting the Enrollment column to the greater of its current value or the result of multiplying the NEW.Height_feet value by 10, specifically for rows where the building_id matches the NEW.building_id from the building table. This is achieved by performing an UPDATE operation on the Institution table, using a WHERE clause that matches the building_id column to the NEW.building_id value. The SET clause uses the GREATEST function to compare the existing Enrollment value with the calculated value (NEW.Height_feet * 10) and assigns the higher of the two to Enrollment. The function concludes by returning the NEW record, which is a standard practice in trigger functions to allow the triggering operation to proceed. The function is written in the PL/pgSQL language. Second, define the trigger trg_adjust_enrollment_on_height on the building table to automatically invoke this function after any INSERT operation or after any UPDATE operation that modifies the Height_feet column, ensuring that the function is executed for each affected row in the building table.",
    "original_ir": "Write a PL/pgSQL trigger function named `adjust_enrollment_on_height` that is designed to be executed in response to specific data manipulation language (DML) events on the `\"building\"` table, and a trigger named `trg_adjust_enrollment_on_height` that invokes this function. The trigger function `adjust_enrollment_on_height` takes no explicit parameters but implicitly receives special record variables `NEW` and `OLD` from the triggering event. The `NEW` record variable represents the new row data for `INSERT` and `UPDATE` operations, while the `OLD` record variable represents the old row data for `UPDATE` and `DELETE` operations. In this specific context, since the trigger is defined for `AFTER INSERT OR UPDATE`, the `NEW` record variable will contain the data of the row that was just inserted or updated. The function's primary purpose is to update the `\"Enrollment\"` column in the `\"Institution\"` table. Specifically, it performs an `UPDATE` operation on the `\"Institution\"` table. For each row in the `\"Institution\"` table, it sets the value of the `\"Enrollment\"` column to the result of the `GREATEST` function. The `GREATEST` function compares two values and returns the larger of the two. The first value provided to `GREATEST` is the current value of the `\"Enrollment\"` column in the `\"Institution\"` table. The second value provided to `GREATEST` is calculated by multiplying the value of the `\"Height_feet\"` column from the `NEW` record (representing the newly inserted or updated row in the `\"building\"` table) by 10. This `UPDATE` operation is conditionally applied only to those rows in the `\"Institution\"` table where the `\"building_id\"` column matches the value of the `\"building_id\"` column from the `NEW` record. After performing this update, the function returns the `NEW` record, which is a standard requirement for `AFTER` row-level triggers in PostgreSQL. The trigger `trg_adjust_enrollment_on_height` is defined to execute `AFTER INSERT OR UPDATE OF \"Height_feet\"` on the `\"building\"` table. This means the trigger will fire after a new row is inserted into the `\"building\"` table, or after an existing row in the `\"building\"` table is updated, but only if the `\"Height_feet\"` column is one of the columns being updated. The `FOR EACH ROW` clause specifies that the trigger function `adjust_enrollment_on_height` will be executed once for each row that is affected by the `INSERT` or `UPDATE` operation. The `EXECUTE FUNCTION adjust_enrollment_on_height()` clause specifies that the `adjust_enrollment_on_height` function should be called when the trigger fires."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `update_order_date_on_item_update` that updates the `Customer_Orders` table by setting its `order_date` column to the current date and time using the `NOW()` function, specifically for rows where the `order_id` matches the `NEW.order_id` value from the updated `Order_Items` row.\nSecond, define the trigger `trg_update_order_date_on_item_update` on table `Order_Items` that fires `AFTER` `UPDATE` for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_order_date_on_item_update() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Customer_Orders\" SET order_date = NOW() WHERE order_id = NEW.order_id;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_date_on_item_update\n    AFTER UPDATE ON \"Order_Items\"\n    FOR EACH ROW\n    EXECUTE FUNCTION update_order_date_on_item_update();",
    "database_name": "department_store",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "UPDATE \"Order_Items\" SET product_id = 10 WHERE order_id = 1;",
      "UPDATE \"Order_Items\" SET product_id = 12 WHERE order_id = 9;",
      "UPDATE \"Order_Items\" SET product_id = 15 WHERE order_id = 5;",
      "UPDATE \"Order_Items\" SET product_id = 1 WHERE order_id = 1;",
      "UPDATE \"Order_Items\" SET product_id = 2 WHERE order_id = 9;"
    ],
    "summary": "Create a PostgreSQL trigger function named `update_order_date_on_item_update` that fires after UPDATE on the `Order_Items` table. For each updated row, update the `Customer_Orders` table, setting `order_date` to `NOW()` where `order_id` matches `NEW.order_id`. Return the `NEW` record.",
    "natural_language": "Hey, can you whip up a PostgreSQL trigger function called `update_order_date_on_item_update`? It should kick in right after someone updates a row in the `Order_Items` table. Basically, whenever an item gets changed, this trigger needs to go into the `Customer_Orders` table and refresh the `order_date` to the current timestamp, but only for the order that matches the `NEW.order_id`. Oh, and make sure it spits back the `NEW` record at the end.",
    "id": 85,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named update_order_date_on_item_update in the department_store database. This function is defined to return a trigger data type. The function declares no explicit variables. The function is executed automatically by a trigger after every UPDATE operation on the Order_Items table for each row that is updated. The function performs an UPDATE operation on the Customer_Orders table. Specifically, it sets the order_date column to the current system timestamp with time zone, obtained via the CURRENT_TIMESTAMP function. This update is applied only to the row in the Customer_Orders table where the order_id column matches the value of the order_id from the newly updated row in the Order_Items table, which is referenced as NEW.order_id. The function concludes by returning the NEW row record to the trigger execution context. Second, define the trigger on the Order_Items table to fire after each row update, executing the update_order_date_on_item_update function.",
    "original_ir": "Write a PostgreSQL trigger function named update_order_date_on_item_update that returns a trigger and is invoked by a trigger named trg_update_order_date_on_item_update, which is defined to fire after any update operation on the Order_Items table for each row that is modified, where the trigger function executes an update on the Customer_Orders table, specifically setting the order_date column to the current date and time returned by the NOW() function for every row in the Customer_Orders table where the order_id column matches the NEW.order_id value from the updated Order_Items row, and finally the trigger function returns the NEW row record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function delete_related_products that deletes rows from the \"Products\" table where the \"Manufacturer\" column matches the OLD.\"Manufacturer\" and the \"Code\" column does not match OLD.\"Code\", then returns the OLD row. Second, define the trigger trg_delete_related_products on table \"Products\" that fires BEFORE DELETE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION delete_related_products() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Products\" WHERE \"Manufacturer\" = OLD.\"Manufacturer\" AND \"Code\" != OLD.\"Code\";\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_delete_related_products\nBEFORE DELETE ON \"Products\"\nFOR EACH ROW EXECUTE FUNCTION delete_related_products();",
    "database_name": "manufactory_1",
    "tables": [
      "Products"
    ],
    "call_sqls": [
      "DELETE FROM \"Products\" WHERE \"Code\" = 1;",
      "DELETE FROM \"Products\" WHERE \"Code\" = 2;",
      "DELETE FROM \"Products\" WHERE \"Manufacturer\" = 5;",
      "DELETE FROM \"Products\" WHERE \"Name\" = 'ZIP drive';",
      "DELETE FROM \"Products\" WHERE \"Price\" = 120;"
    ],
    "summary": "Create a trigger function that, before a row is deleted from the Products table, deletes all other rows from the same table that have the same Manufacturer but a different Code than the deleted row. Return the OLD row. Create a BEFORE DELETE trigger named trg_delete_related_products to execute this function for each deleted row.",
    "natural_language": "Alright, so before we zap a product from the Products table, we gotta set up a trigger function. This function's job is to find and delete any other products from the same manufacturer that have a different product code than the one being removed. After that cleanup, it should hand back the OLD row data. Then, hook up a BEFORE DELETE trigger, call it trg_delete_related_products, to run this function for every row that gets deleted.",
    "id": 86,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named delete_related_products in the manufactory_1 database. This function is designed to be used as a trigger function and operates in the context of a BEFORE DELETE trigger event on the Products table. The function does not take any parameters directly but accesses the OLD record, which represents the row that is about to be deleted from the Products table. Within the function, a DELETE operation is performed on the Products table itself, targeting rows where the Manufacturer column value matches the Manufacturer value from the OLD record, and the Code column value is different from the Code value of the OLD record. This ensures that all other products from the same manufacturer, excluding the one currently being deleted, are removed. After performing this deletion, the function returns the OLD record, which is a standard practice in BEFORE DELETE trigger functions to allow the original deletion to proceed. Second, define the trigger trg_delete_related_products on the Products table, specifying that it should execute the delete_related_products function before each row deletion on the Products table. This setup ensures that whenever a product is deleted, all other products from the same manufacturer are automatically deleted first, and the original deletion then proceeds.",
    "original_ir": "Write a PLpgSQL trigger function that, upon the deletion of a row from the \"Products\" table, deletes all other rows in the same table where the \"Manufacturer\" column matches the \"Manufacturer\" value of the deleted row, but the \"Code\" column does not match the \"Code\" value of the deleted row. The function returns the OLD row data, which is the row being deleted. This function is associated with a trigger named trg_delete_related_products, which is set to execute before a row is deleted from the \"Products\" table. The trigger ensures that whenever a row is deleted, the function is called to perform the specified deletion of related products."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `trg_delete_orphaned_orders` that deletes rows from the `Customer_Orders` table where the `order_id` column matches the `OLD.order_id` from the deleted `Order_Items` row, but only if a `NOT EXISTS` condition is satisfied using a subquery that selects the constant value `1` from the `Order_Items` table where its `order_id` equals `OLD.order_id`. Second, define the trigger `cleanup_orders_after_item_delete` on table `Order_Items` that fires `AFTER` `DELETE` for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_delete_orphaned_orders() RETURNS TRIGGER AS $$\nBEGIN\n    DELETE FROM \"Customer_Orders\" WHERE \"order_id\" = OLD.\"order_id\" AND NOT EXISTS (SELECT 1 FROM \"Order_Items\" WHERE \"order_id\" = OLD.\"order_id\");\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER cleanup_orders_after_item_delete\nAFTER DELETE ON \"Order_Items\"\nFOR EACH ROW EXECUTE FUNCTION trg_delete_orphaned_orders();",
    "database_name": "customers_and_orders",
    "tables": [
      "Customer_Orders",
      "Order_Items"
    ],
    "call_sqls": [
      "DELETE FROM \"Order_Items\" WHERE order_item_id = 1;",
      "DELETE FROM \"Order_Items\" WHERE order_id = 8;",
      "DELETE FROM \"Order_Items\" WHERE product_id = 13;",
      "DELETE FROM \"Order_Items\" WHERE order_quantity = '2';",
      "DELETE FROM \"Order_Items\" WHERE order_item_id IN (2, 3);"
    ],
    "summary": "Create an AFTER DELETE trigger function for the Order_Items table. For each deleted row, delete the corresponding order from the Customer_Orders table where the order_id matches OLD.order_id, but only if no other items for that order_id remain in the Order_Items table.",
    "natural_language": "Set up a trigger that runs after something gets removed from the order items list. Basically, whenever a row is taken out, you should also clear out the matching order from the customer orders if it seems like there aren't really any other items left for that particular order hanging around anymore.",
    "id": 87,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named trg_delete_orphaned_orders that takes no parameters and returns a TRIGGER type. This function is designed to execute after a DELETE operation on the Order_Items table. Within the function, declare a variable to hold the count of remaining order items for the affected order. After a row is deleted from Order_Items, the function performs a SELECT query on the Order_Items table to count the number of rows where the order_id matches the OLD.order_id from the deleted row. This count is stored in the declared variable. Then, using an IF condition, the function checks if this count is zero, indicating that no other items exist for that order. If true, the function executes a DELETE operation on the Customer_Orders table, removing the row where the order_id equals the OLD.order_id. The function concludes by returning the OLD row. Second, define an AFTER DELETE trigger on the Order_Items table that executes the trg_delete_orphaned_orders function for each row affected by the delete operation.",
    "original_ir": "Write a PostgreSQL trigger function named trg_delete_orphaned_orders that returns a trigger, which is invoked by a trigger named cleanup_orders_after_item_delete defined to fire after a delete operation on the Order_Items table for each deleted row, where the function body executes a delete operation on the Customer_Orders table targeting rows where the order_id column matches the OLD.order_id value from the deleted Order_Items row, but only if a condition is satisfied, specifically using a NOT EXISTS clause with a subquery that selects the constant value 1 from the Order_Items table where the order_id column equals the OLD.order_id value, thereby ensuring the deletion from Customer_Orders occurs only when no corresponding rows remain in the Order_Items table for that specific order_id, and the function concludes by returning the OLD row record."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_new_gymnast_in_people` that conditionally inserts a new row into the `people` table after an insert on the `gymnast` table. The function uses the `NEW` record to set `\"People_ID\"` to `NEW.\"Gymnast_ID\"`, `\"Name\"` to 'New Gymnast', `\"Age\"` to 20.0, `\"Height\"` to 1.70, and `\"Hometown\"` to 'Unknown'. The insertion only proceeds if a row with a matching `\"People_ID\"` does not already exist in the `people` table, checked using a `WHERE NOT EXISTS` clause with a subquery (`SELECT 1 FROM people WHERE \"People_ID\" = NEW.\"Gymnast_ID\"`). The function must return `NEW`.\nSecond, define the trigger `trg_insert_new_gymnast_in_people` on table `gymnast` that fires `AFTER INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_new_gymnast_in_people() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO people (\"People_ID\", \"Name\", \"Age\", \"Height\", \"Hometown\") SELECT NEW.\"Gymnast_ID\", 'New Gymnast', 20.0, 1.70, 'Unknown' WHERE NOT EXISTS (SELECT 1 FROM people WHERE \"People_ID\" = NEW.\"Gymnast_ID\");\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_insert_new_gymnast_in_people\n    AFTER INSERT ON gymnast\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_new_gymnast_in_people();",
    "database_name": "gymnast",
    "tables": [
      "gymnast",
      "people"
    ],
    "call_sqls": [
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (3, 9.8, 9.7, 9.6, 9.5, 9.7, 9.8, 58.1);",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (5, 9.6, 9.5, 9.4, 9.3, 9.6, 9.7, 57.1);",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (6, 9.9, 9.8, 9.7, 9.6, 9.8, 9.9, 59.1);",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (7, 9.7, 9.6, 9.5, 9.4, 9.7, 9.8, 58.0);",
      "INSERT INTO gymnast (\"Gymnast_ID\", \"Floor_Exercise_Points\", \"Pommel_Horse_Points\", \"Rings_Points\", \"Vault_Points\", \"Parallel_Bars_Points\", \"Horizontal_Bar_Points\", \"Total_Points\") VALUES (8, 9.5, 9.4, 9.3, 9.2, 9.5, 9.6, 56.5);"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_new_gymnast_in_people for the gymnast table. For each new row, insert a corresponding record into the people table with People_ID set to NEW.Gymnast_ID, Name as 'New Gymnast', Age as 20.0, Height as 1.70, and Hometown as 'Unknown', but only if a record with that People_ID does not already exist. Return the NEW record.",
    "natural_language": "Construct an AFTER INSERT trigger function, which should be named insert_new_gymnast_in_people, specifically for the gymnast table. For every single new row that is successfully inserted, you must carefully insert a corresponding and detailed record into the people table. This new record should meticulously assign the People_ID to the value from NEW.Gymnast_ID, set the Name to the descriptive placeholder 'New Gymnast', specify the Age precisely as 20.0, define the Height exactly as 1.70, and finally, list the Hometown as the generic term 'Unknown'. However, this insertion must only proceed cautiously under the important condition that an existing record with that identical People_ID is not already present in the table. The function should then appropriately return the complete NEW record.",
    "id": 88,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named insert_new_gymnast_in_people in the gymnast database. This function is an AFTER INSERT trigger function that executes automatically after each row insertion into the gymnast table. The function accesses the NEW record representing the inserted gymnast row, specifically the NEW.Gymnast_ID value. It does not declare any local variables. The function performs a conditional INSERT operation into the people table. It checks if a record with a People_ID equal to NEW.Gymnast_ID already exists in the people table. If no such record exists, it inserts a new row into the people table with the following column values: People_ID is set to NEW.Gymnast_ID, Name is set to the literal string 'New Gymnast', Age is set to the numeric value 20.0, Height is set to the numeric value 1.70, and Hometown is set to the literal string 'Unknown'. The function concludes by returning the NEW record. Second, define the trigger insert_new_gymnast_in_people on the gymnast table to execute the function insert_new_gymnast_in_people after each INSERT operation on the table.",
    "original_ir": "Write a PLpgSQL trigger function that automatically inserts a new row into the people table whenever a new row is inserted into the gymnast table. The function is named insert_new_gymnast_in_people and is designed to be executed as a trigger. It operates after an insert event on the gymnast table, for each row that is inserted. The function does not take any parameters directly, but it utilizes the NEW record, which represents the newly inserted row in the gymnast table. The function performs an INSERT operation into the people table, with the following column values: \"People_ID\" is set to the value of NEW.\"Gymnast_ID\" from the gymnast table, \"Name\" is set to the string 'New Gymnast', \"Age\" is set to the numeric value 20.0, \"Height\" is set to the numeric value 1.70, and \"Hometown\" is set to the string 'Unknown'. This insertion is conditional, executed only if there is no existing row in the people table with a \"People_ID\" that matches NEW.\"Gymnast_ID\". This condition is checked using a WHERE NOT EXISTS clause, which performs a subquery to select 1 from the people table where \"People_ID\" equals NEW.\"Gymnast_ID\". If no such row exists, the insertion proceeds. The function returns the NEW record, which is standard practice for trigger functions to allow the triggering operation to continue. The trigger associated with this function is named trg_insert_new_gymnast_in_people, and it is defined to execute the function after an insert operation on the gymnast table, ensuring that the function is called for each new row inserted into the gymnast table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `create_staff_address` that inserts a new record into the `Addresses` table using values from the NEW row of the `Staff` table, specifically setting `address_id` to `NEW.staff_id + 1000`, `line_1_number_building` to 'Default Address', `city` to 'Default City', `zip_postcode` to '00000', `state_province_county` to 'Default State', and `country` to 'USA', and then returns NEW.\nSecond, define the trigger `staff_address_trigger` on table `Staff` that fires BEFORE INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION create_staff_address() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Addresses\" (\"address_id\", \"line_1_number_building\", \"city\", \"zip_postcode\", \"state_province_county\", \"country\") VALUES (NEW.\"staff_id\" + 1000, 'Default Address', 'Default City', '00000', 'Default State', 'USA');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER staff_address_trigger\nBEFORE INSERT ON \"Staff\"\nFOR EACH ROW EXECUTE FUNCTION create_staff_address();",
    "database_name": "driving_school",
    "tables": [
      "Customers",
      "Addresses",
      "Customer_Payments",
      "Lessons",
      "Staff"
    ],
    "call_sqls": [
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (4, 'john.doe', 'John', 'A.', 'Doe', '1990-01-01 00:00:00+00:00', '2023-10-01 00:00:00+00:00');",
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (5, 'jane.smith', 'Jane', 'B.', 'Smith', '1985-05-15 00:00:00+00:00', '2023-10-02 00:00:00+00:00');",
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (6, 'alice.jones', 'Alice', 'C.', 'Jones', '1992-07-20 00:00:00+00:00', '2023-10-03 00:00:00+00:00');",
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (7, 'bob.brown', 'Bob', 'D.', 'Brown', '1988-11-30 00:00:00+00:00', '2023-10-04 00:00:00+00:00');",
      "INSERT INTO \"Staff\" (\"staff_id\", \"nickname\", \"first_name\", \"middle_name\", \"last_name\", \"date_of_birth\", \"date_joined_staff\") VALUES (8, 'charlie.green', 'Charlie', 'E.', 'Green', '1995-03-25 00:00:00+00:00', '2023-10-05 00:00:00+00:00');"
    ],
    "summary": "Create a BEFORE INSERT trigger function named create_staff_address on the Staff table. For each new row, insert a record into the Addresses table where address_id is the new staff_id plus 1000, line_1_number_building is 'Default Address', city is 'Default City', zip_postcode is '00000', state_province_county is 'Default State', and country is 'USA'. Return NEW.",
    "natural_language": "Please implement a BEFORE INSERT trigger function designated as 'create_staff_address' on the Staff table. For every inserted row, it is required to insert a corresponding record into the Addresses table. The 'address_id' shall be derived by adding 1000 to the new 'staff_id'. The fields 'line_1_number_building', 'city', 'zip_postcode', 'state_province_county', and 'country' should be populated with the values 'Default Address', 'Default City', '00000', 'Default State', and 'USA', respectively. The function must conclude by returning the NEW row.",
    "id": 89,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create a function named create_staff_address that is designed to execute before each row insertion into the Staff table. This function will insert a new row into the Addresses table for every row inserted into the Staff table. The function uses the NEW record to access the values of the row being inserted into Staff. It calculates the address_id for the new Addresses record by adding 1000 to the NEW.staff_id value. For the other columns in the Addresses table, it populates them with static default values: line_1_number_building is set to 'Default Address', city is set to 'Default City', zip_postcode is set to '00000', state_province_county is set to 'Default State', and country is set to 'USA'. After performing the INSERT operation into the Addresses table, the function returns the NEW record to allow the original insert operation on the Staff table to proceed. Second, define a trigger named trg_create_staff_address on the Staff table that fires before each row insertion and executes the create_staff_address function.",
    "original_ir": "Write a PostgreSQL trigger function named create_staff_address that returns a trigger, which is automatically executed as a BEFORE INSERT trigger named staff_address_trigger on the \"Staff\" table for each new row being inserted; the function's logic is to insert a single new record into the \"Addresses\" table, where the \"address_id\" column is populated with the value of the NEW.\"staff_id\" from the triggering \"Staff\" row incremented by 1000, the \"line_1_number_building\" column is set to the literal string 'Default Address', the \"city\" column is set to 'Default City', the \"zip_postcode\" column is set to '00000', the \"state_province_county\" column is set to 'Default State', and the \"country\" column is set to 'USA'; after performing this INSERT operation, the function returns the NEW row record to allow the original INSERT operation on the \"Staff\" table to proceed."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_update_customer_type_on_complaint` that checks if the `NEW.complaint_status_code` equals 'Closed' and, if true, updates the `customer_type_code` to 'Reviewed' in the \"Customers\" table where the `customer_id` matches `NEW.customer_id`.\nSecond, define the trigger `update_customer_type_on_complaint` on table \"Complaints\" that fires AFTER UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_customer_type_on_complaint() RETURNS TRIGGER AS $$\nBEGIN\nIF NEW.complaint_status_code = 'Closed' THEN\nUPDATE \"Customers\" SET customer_type_code = 'Reviewed' WHERE customer_id = NEW.customer_id;\nEND IF;\nRETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_customer_type_on_complaint\nAFTER UPDATE ON \"Complaints\"\nFOR EACH ROW EXECUTE FUNCTION trg_update_customer_type_on_complaint();",
    "database_name": "customer_complaints",
    "tables": [
      "Complaints",
      "Customers",
      "Products",
      "Staff"
    ],
    "call_sqls": [
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 1;",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 2;",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 3;",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 1 AND customer_id = 120;",
      "UPDATE \"Complaints\" SET complaint_status_code = 'Closed' WHERE complaint_id = 2 AND customer_id = 113;"
    ],
    "summary": "Create an AFTER UPDATE trigger function named trg_update_customer_type_on_complaint for the Complaints table. If NEW.complaint_status_code equals 'Closed', update the Customers table, setting customer_type_code to 'Reviewed' where customer_id matches NEW.customer_id. Return NEW.",
    "natural_language": "How can I create an AFTER UPDATE trigger function called trg_update_customer_type_on_complaint for the Complaints table that, when NEW.complaint_status_code is 'Closed', updates the Customers table to set customer_type_code to 'Reviewed' for the matching customer_id, and then returns NEW?",
    "id": 90,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_update_customer_type_on_complaint` that checks if the `NEW.complaint_status_code` equals 'Closed' and, if true, updates the `customer_type_code` to 'Reviewed' in the \"Customers\" table where the `customer_id` matches `NEW.customer_id`.\nSecond, define the trigger `update_customer_type_on_complaint` on table \"Complaints\" that fires AFTER UPDATE for each row and executes the function.",
    "original_ir": "Write a PLpgSQL trigger function that is executed after an update operation on the \"Complaints\" table. This function, named trg_update_customer_type_on_complaint, does not take any parameters directly but operates on the NEW record, which represents the new state of a row after an update. The function checks if the complaint_status_code column of the NEW record is equal to 'Closed'. If this condition is true, it performs an update operation on the \"Customers\" table, setting the customer_type_code column to 'Reviewed' for the row where the customer_id matches the customer_id from the NEW record. The function then returns the NEW record. This trigger function is associated with a trigger named update_customer_type_on_complaint, which is defined to fire after an update on each row of the \"Complaints\" table, ensuring that the function is executed for every row that is updated in the \"Complaints\" table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `truncate_event_details` that updates the `Events` table by setting the `Event_Details` column to a text value representing the truncated length of its current text, using the expression `trunc(length(\"Event_Details\")::numeric, 0)::text`, for the row where `Event_ID` matches the `NEW.Event_ID` from the `Participants_in_Events` table and returns the `NEW` row.\nSecond, define the trigger `trg_truncate_event_details` on table `Participants_in_Events` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION truncate_event_details() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE \"Events\" SET \"Event_Details\" = trunc(length(\"Event_Details\")::numeric, 0)::text WHERE \"Event_ID\" = NEW.\"Event_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_truncate_event_details\nAFTER INSERT ON \"Participants_in_Events\"\nFOR EACH ROW EXECUTE FUNCTION truncate_event_details();",
    "database_name": "local_govt_in_alabama",
    "tables": [
      "Events",
      "Participants_in_Events"
    ],
    "call_sqls": [
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 100);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 101);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (13, 102);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (3, 103);",
      "INSERT INTO \"Participants_in_Events\" (\"Event_ID\", \"Participant_ID\") VALUES (8, 104);"
    ],
    "summary": "Create an AFTER INSERT row-level trigger function named `truncate_event_details`. When a row is inserted into the `Participants_in_Events` table, update the `Event_Details` column in the `Events` table, setting it to the truncated length (as text) of its current value for the matching `Event_ID`. Return the NEW row.",
    "natural_language": "Please construct an AFTER INSERT row-level trigger function designated as `truncate_event_details`. Upon the insertion of a row into the `Participants_in_Events` table, this function shall modify the `Event_Details` column within the `Events` table. The modification must set the column's value to a textual representation of its current length, truncated, for the corresponding `Event_ID`. The function is required to return the NEW row.",
    "id": 91,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `truncate_event_details` that updates the `Events` table by setting the `Event_Details` column to a text value representing the truncated length of its current text, using the expression `trunc(length(\"Event_Details\")::numeric, 0)::text`, for the row where `Event_ID` matches the `NEW.Event_ID` from the `Participants_in_Events` table and returns the `NEW` row.\nSecond, define the trigger `trg_truncate_event_details` on table `Participants_in_Events` that fires `AFTER` `INSERT` and executes the function.",
    "original_ir": "Write a PLpgSQL function named truncate_event_details that is designed to be executed as a trigger. This function does not take any parameters directly but operates in conjunction with a trigger on the Participants_in_Events table. The function is triggered after an insert operation on the Participants_in_Events table. It performs an update operation on the Events table, specifically targeting the Event_Details column. The update sets the Event_Details column to a truncated version of its current length, converting the length of the Event_Details text to a numeric value, truncating it to zero decimal places, and then converting it back to text. This operation is applied to the row in the Events table where the Event_ID matches the Event_ID of the newly inserted row in the Participants_in_Events table. The function returns the NEW row, which is the row that was just inserted into the Participants_in_Events table. The trigger named trg_truncate_event_details is defined to execute this function after each row insertion into the Participants_in_Events table, ensuring that the Event_Details in the corresponding Events table row is updated immediately following the insertion."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_product_name that updates the \"Products\" table, setting the \"Name\" column to the literal string 'Updated Product' for every row where the \"Manufacturer\" column value matches the NEW.\"Code\" value from the updated \"Manufacturers\" row.\nSecond, define the trigger update_product_name_trigger on table \"Manufacturers\" that fires AFTER UPDATE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_product_name() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Products\" SET \"Name\" = 'Updated Product' WHERE \"Manufacturer\" = NEW.\"Code\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_product_name_trigger\nAFTER UPDATE ON \"Manufacturers\"\nFOR EACH ROW EXECUTE FUNCTION update_product_name();",
    "database_name": "manufactory_1",
    "tables": [
      "Manufacturers",
      "Products"
    ],
    "call_sqls": [
      "UPDATE \"Manufacturers\" SET \"Name\" = 'New Name 1' WHERE \"Code\" = 1;",
      "UPDATE \"Manufacturers\" SET \"Headquarter\" = 'New HQ 2' WHERE \"Code\" = 2;",
      "UPDATE \"Manufacturers\" SET \"Founder\" = 'New Founder 3' WHERE \"Code\" = 3;",
      "UPDATE \"Manufacturers\" SET \"Revenue\" = 150.0 WHERE \"Code\" = 1;",
      "UPDATE \"Manufacturers\" SET \"Name\" = 'Updated Manufacturer' WHERE \"Code\" = 5;"
    ],
    "summary": "Create an AFTER UPDATE trigger function on the Manufacturers table. For each updated row, update the Products table, setting the Name to 'Updated Product' for all products where the Manufacturer matches the updated manufacturer's Code. Return the NEW record.",
    "natural_language": "How can I create an AFTER UPDATE trigger function on the Manufacturers table that, for each updated row, updates the Products table by setting the Name to 'Updated Product' for all products where the Manufacturer matches the updated manufacturer's Code, and then returns the NEW record?",
    "id": 92,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_product_name that updates the \"Products\" table, setting the \"Name\" column to the literal string 'Updated Product' for every row where the \"Manufacturer\" column value matches the NEW.\"Code\" value from the updated \"Manufacturers\" row.\nSecond, define the trigger update_product_name_trigger on table \"Manufacturers\" that fires AFTER UPDATE and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named update_product_name that returns a trigger and is invoked by a trigger named update_product_name_trigger, which is defined to fire after an update operation on the Manufacturers table for each row that is modified, where the function executes an update on the Products table, setting the Name column to the literal string value 'Updated Product' for every row in the Products table where the Manufacturer column value matches the Code column value from the newly updated row in the Manufacturers table (accessed via the NEW record), and the function concludes by returning the NEW row record to the trigger."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function insert_student_city that inserts rows into the Has_Pet table by selecting the NEW.\"StuID\" from the trigger and all \"PetID\" values from the Pets table where the \"PetType\" column equals 'dog'. Second, define the trigger student_city_insert on table Student that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_student_city() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"Has_Pet\" (\"StuID\", \"PetID\")\n  SELECT NEW.\"StuID\", \"PetID\"\n  FROM \"Pets\"\n  WHERE \"PetType\" = 'dog';\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER student_city_insert\nAFTER INSERT ON \"Student\"\nFOR EACH ROW EXECUTE FUNCTION insert_student_city();",
    "database_name": "pets_1",
    "tables": [
      "Has_Pet",
      "Pets",
      "Student"
    ],
    "call_sqls": [
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1004, 'Brown', 'Charlie', 20, 'M', 601, 1122, 'NYC');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1005, 'Davis', 'Diana', 22, 'F', 602, 7713, 'LAX');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1006, 'Miller', 'Mike', 19, 'M', 603, 7793, 'CHI');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1007, 'Wilson', 'Wendy', 21, 'F', 604, 1124, 'MIA');",
      "INSERT INTO \"Student\" (\"StuID\", \"LName\", \"Fname\", \"Age\", \"Sex\", \"Major\", \"Advisor\", \"city_code\") VALUES (1008, 'Taylor', 'Tom', 23, 'M', 605, 7715, 'DAL');"
    ],
    "summary": "Create an AFTER INSERT trigger function named insert_student_city on the Student table. For each new row, insert into Has_Pet by selecting NEW.StuID and every PetID from Pets where PetType is 'dog'. Return NEW.",
    "natural_language": "Set up a trigger that runs after adding a student. It should link the new student with a bunch of pet IDs, specifically those for pets that are commonly considered dogs. Make sure the new record is processed.",
    "id": 93,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function insert_student_city that inserts rows into the Has_Pet table by selecting the NEW.\"StuID\" from the trigger and all \"PetID\" values from the Pets table where the \"PetType\" column equals 'dog'. Second, define the trigger student_city_insert on table Student that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named insert_student_city that is executed automatically by a trigger named student_city_insert, where the trigger is defined to fire after an insert operation on the Student table for each new row added, and the function's logic is to insert new records into the Has_Pet table by selecting the StuID value from the newly inserted Student row (referenced as NEW.\"StuID\") and pairing it with every PetID value from the Pets table where the PetType column in the Pets table has the exact string value 'dog', thereby creating an association in the Has_Pet table between the new student and all existing pets of type dog."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function normalize_actor_nationality that operates on the NEW record, applies the TRIM function to the nationality column to remove leading and trailing whitespace, then applies the UPPER function to convert the trimmed string to uppercase, and assigns the result back to NEW.nationality before returning NEW. Second, define the trigger trg_normalize_actor_nationality on table actor that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION normalize_actor_nationality() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.nationality = UPPER(TRIM(NEW.nationality));\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_normalize_actor_nationality\nBEFORE INSERT OR UPDATE ON actor\nFOR EACH ROW EXECUTE FUNCTION normalize_actor_nationality();",
    "database_name": "imdb",
    "tables": [
      "tv_series",
      "cast",
      "actor"
    ],
    "call_sqls": [
      "INSERT INTO actor (aid, gender, name, nationality, birth_city, birth_year) VALUES (1, 'Male', 'Tom Hanks', ' american ', 'Concord', 1956);",
      "UPDATE actor SET nationality = '  GERMAN  ' WHERE aid = 1;",
      "INSERT INTO actor (aid, gender, name, nationality, birth_city, birth_year) VALUES (2, 'Female', 'Meryl Streep', '  u.s.a.  ', 'Summit', 1949);",
      "UPDATE actor SET nationality = '  french ' WHERE aid = 2;",
      "INSERT INTO actor (aid, gender, name, nationality, birth_city, birth_year) VALUES (3, 'Male', 'Brad Pitt', ' united states ', 'Shawnee', 1963);"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE trigger function named normalize_actor_nationality. For each row in the actor table, trim leading/trailing spaces from the NEW.nationality value, convert it to uppercase, and assign the result back to NEW.nationality.",
    "natural_language": "Create trigger normalize_actor_nationality. Before insert or update on actor, trim and uppercase NEW.nationality.",
    "id": 94,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function normalize_actor_nationality that operates on the NEW record, applies the TRIM function to the nationality column to remove leading and trailing whitespace, then applies the UPPER function to convert the trimmed string to uppercase, and assigns the result back to NEW.nationality before returning NEW. Second, define the trigger trg_normalize_actor_nationality on table actor that fires BEFORE INSERT OR UPDATE for each row and executes the function.",
    "original_ir": "Write a PostgreSQL trigger function named normalize_actor_nationality that is executed automatically by a trigger named trg_normalize_actor_nationality, which is defined to fire BEFORE any INSERT or UPDATE operation on the actor table for each individual row being processed; the function receives the new row data in a special record variable named NEW and operates on the nationality column within this NEW record, applying the TRIM function to remove any leading or trailing whitespace characters from the incoming NEW.nationality string value and then applying the UPPER function to convert the trimmed string to all uppercase letters, subsequently assigning this transformed value back to the NEW.nationality column, and finally returns the modified NEW record to the triggering INSERT or UPDATE statement to be persisted."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `insert_book_trigger` that inserts a new row into the `\"book\"` table with the following column values: `\"Book_ID\"` set to `NEW.\"Review_ID\" + 1000`, `\"Title\"` set to `'Generated Book'`, `\"Type\"` set to `'Novel'`, `\"Pages\"` set to `300`, `\"Chapters\"` set to `20`, `\"Audio\"` set to `'15h 30m'`, and `\"Release\"` set to `'January 2024'`, then returns `NEW`.\nSecond, define the trigger `create_book_from_review` on table `\"review\"` that fires `AFTER` `INSERT` and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION insert_book_trigger() RETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO \"book\" (\"Book_ID\", \"Title\", \"Type\", \"Pages\", \"Chapters\", \"Audio\", \"Release\") VALUES (NEW.\"Review_ID\" + 1000, 'Generated Book', 'Novel', 300, 20, '15h 30m', 'January 2024');\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER create_book_from_review\n    AFTER INSERT ON \"review\"\n    FOR EACH ROW\n    EXECUTE FUNCTION insert_book_trigger();",
    "database_name": "book_review",
    "tables": [
      "book",
      "review"
    ],
    "call_sqls": [
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (1, 1, 8.5, 5.2, 1);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (2, 2, 7.9, 4.8, 2);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (3, 3, 9.1, 6.1, 3);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (4, 4, 7.2, 3.5, 4);",
      "INSERT INTO \"review\" (\"Review_ID\", \"Book_ID\", \"Rating\", \"Readers_in_Million\", \"Rank\") VALUES (5, 5, 8.8, 5.9, 5);"
    ],
    "summary": "Create a trigger function named insert_book_trigger and a trigger named create_book_from_review. The function, executed AFTER INSERT on the review table for each row, inserts a new book into the book table. The book's ID is the new review's ID plus 1000. Other columns are set to static values: 'Generated Book' for Title, 'Novel' for Type, 300 for Pages, 20 for Chapters, '15h 30m' for Audio, and 'January 2024' for Release. The function returns NEW.",
    "natural_language": "Set up a trigger and its function so that after a new review is added, it sometimes makes a book entry too. The function, called insert_book_trigger, should run after inserts on the review table. For the new book, its ID should be kind of based on the review's ID, maybe by adding a large number like 1000 to it. For the book details, just use some reasonable placeholder values: a generic title like 'Generated Book', set the type to something common like 'Novel', use a typical page count around 300, a moderate number of chapters like 20, a decent audio length such as '15h 30m', and a recent release period like 'January 2024'. The function should end by returning the new record.",
    "id": 95,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function named insert_book_trigger that returns a trigger and is executed automatically by an AFTER INSERT trigger on the review table for each new row. The function performs an insert operation into the book table, generating a new book record only when the newly inserted review's Book_ID does not already exist in the book table. This condition is checked by verifying that the NEW.Book_ID value is not present in the Book_ID column of the book table. If the condition is true, the function inserts a new row into the book table with the following column values: Book_ID is set to the sum of NEW.Review_ID and 1000, Title is set to the literal string 'Generated Book', Type is set to 'Novel', Pages is set to 300, Chapters is set to 20, Audio is set to '15h 30m', and Release is set to 'January 2024'. The function then returns the NEW row record from the review table. Second, define the trigger trg_review_ai_book on the review table to execute the insert_book_trigger function after each insert operation.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `insert_book_trigger` that is designed to be executed in response to data manipulation language (DML) events on a specific table, and a trigger named `create_book_from_review` that invokes this function.\n\nThe `insert_book_trigger` function is defined as `CREATE OR REPLACE FUNCTION insert_book_trigger() RETURNS TRIGGER AS $$ ... $$ LANGUAGE plpgsql;`. This indicates it is a function that returns a `TRIGGER` pseudotype, meaning it is intended to be used as a trigger function. It does not accept any explicit input parameters in its signature, as trigger functions receive their context (like `NEW` and `OLD` records) implicitly.\n\nInside the `insert_book_trigger` function, a single `INSERT` operation is performed. This `INSERT` statement targets the table named `\"book\"`. The `INSERT` statement specifies the columns to be populated: `\"Book_ID\"`, `\"Title\"`, `\"Type\"`, `\"Pages\"`, `\"Chapters\"`, `\"Audio\"`, and `\"Release\"`. The values provided for these columns are as follows:\n- For `\"Book_ID\"`, the value is derived from `NEW.\"Review_ID\" + 1000`. `NEW` refers to the new row that is being inserted into the `review` table (the table on which the trigger is defined). Specifically, it takes the value from the `\"Review_ID\"` column of this new row and adds `1000` to it.\n- For `\"Title\"`, the literal string value `'Generated Book'` is used.\n- For `\"Type\"`, the literal string value `'Novel'` is used.\n- For `\"Pages\"`, the integer literal `300` is used.\n- For `\"Chapters\"`, the integer literal `20` is used.\n- For `\"Audio\"`, the literal string value `'15h 30m'` is used.\n- For `\"Release\"`, the literal string value `'January 2024'` is used.\n\nAfter the `INSERT` operation, the function executes `RETURN NEW;`. In the context of an `AFTER` trigger, `RETURN NEW;` simply indicates that the trigger has completed successfully and does not modify the row that caused the trigger to fire.\n\nThe `create_book_from_review` trigger is defined as `CREATE TRIGGER create_book_from_review AFTER INSERT ON \"review\" FOR EACH ROW EXECUTE FUNCTION insert_book_trigger();`.\n- The trigger is named `create_book_from_review`.\n- It is an `AFTER INSERT` trigger, meaning it will execute after an `INSERT` operation has successfully completed on the table.\n- The trigger is defined `ON \"review\"`, indicating that it will activate whenever a new row is inserted into the table named `\"review\"`.\n- The `FOR EACH ROW` clause specifies that the trigger function (`insert_book_trigger()`) will be executed once for every row that is inserted into the `\"review\"` table.\n- The `EXECUTE FUNCTION insert_book_trigger()` clause specifies that the `insert_book_trigger` function should be called when the trigger fires.\n\nIn summary, whenever a new row is successfully inserted into the `\"review\"` table, this trigger will automatically execute the `insert_book_trigger` function. This function, in turn, will insert a new row into the `\"book\"` table. The `\"Book_ID\"` for this new book will be generated by adding `1000` to the `\"Review_ID\"` of the newly inserted review. The other columns of the new book record (`\"Title\"`, `\"Type\"`, `\"Pages\"`, `\"Chapters\"`, `\"Audio\"`, `\"Release\"`) will be populated with predefined, static literal values."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_new_claim` that declares a local BIGINT variable `next_settlement_id`, calculates its value by selecting `COALESCE(MAX(\"Settlement_ID\"), 0) + 1` from the `\"Settlements\"` table, and then inserts a new row into `\"Settlements\"` using values from the `NEW` record (including calculating `\"Date_Claim_Settled\"` as `NEW.\"Date_Claim_Made\" + INTERVAL '30 days'` and mapping `NEW.\"Policy_ID\"` to the `\"Customer_Policy_ID\"` column) before returning `NEW`.\nSecond, define the trigger `trg_log_new_claim` on table `\"Claims\"` that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION log_new_claim() RETURNS TRIGGER AS $$\nDECLARE\n  next_settlement_id BIGINT;\nBEGIN\n  -- Get the next Settlement_ID safely\n  SELECT COALESCE(MAX(\"Settlement_ID\"), 0) + 1 INTO next_settlement_id FROM \"Settlements\";\n  \n  INSERT INTO \"Settlements\" (\"Settlement_ID\", \"Claim_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\", \"Customer_Policy_ID\")\n  VALUES (\n    next_settlement_id,\n    NEW.\"Claim_ID\",\n    NEW.\"Date_Claim_Made\",\n    NEW.\"Date_Claim_Made\" + INTERVAL '30 days',\n    NEW.\"Amount_Claimed\",\n    NEW.\"Amount_Settled\",\n    NEW.\"Policy_ID\"\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_new_claim\nAFTER INSERT ON \"Claims\"\nFOR EACH ROW EXECUTE FUNCTION log_new_claim();",
    "database_name": "insurance_policies",
    "tables": [
      "Claims",
      "Customer_Policies",
      "Customers",
      "Payments",
      "Settlements"
    ],
    "call_sqls": [
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1001, 744, '2024-01-15', NULL, 50000, NULL);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1002, 552, '2024-02-20', NULL, 75000, 60000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1003, 473, '2024-03-10', '2024-04-10', 30000, 25000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Amount_Claimed\") VALUES (1004, 119, '2024-03-25', 42000);",
      "INSERT INTO \"Claims\" (\"Claim_ID\", \"Policy_ID\", \"Date_Claim_Made\", \"Date_Claim_Settled\", \"Amount_Claimed\", \"Amount_Settled\") VALUES (1005, 141, CURRENT_DATE, NULL, 88000, NULL);"
    ],
    "summary": "Create a PostgreSQL trigger function named `log_new_claim` that, after each insert into the \"Claims\" table, inserts a corresponding record into the \"Settlements\" table. The function must generate a new `Settlement_ID` by incrementing the maximum existing ID (starting from 0 if the table is empty). The new settlement record should use the new claim's `Claim_ID`, `Date_Claim_Made`, `Amount_Claimed`, `Amount_Settled`, and `Policy_ID` (as `Customer_Policy_ID`). Set `Date_Claim_Settled` to 30 days after `Date_Claim_Made`. The function must return the NEW row. Also, create an AFTER INSERT FOR EACH ROW trigger named `trg_log_new_claim` on the \"Claims\" table to execute this function.",
    "natural_language": "Please construct a PostgreSQL trigger function designated as `log_new_claim`. This function is to be invoked subsequent to every insertion into the \"Claims\" table, with the purpose of inserting a corresponding entry into the \"Settlements\" table. The function must generate a novel `Settlement_ID` by incrementing the highest existing ID value, commencing from 0 should the table be devoid of records. The new settlement entry shall incorporate the newly inserted claim's `Claim_ID`, `Date_Claim_Made`, `Amount_Claimed`, `Amount_Settled`, and `Policy_ID` (to be recorded as `Customer_Policy_ID`). The `Date_Claim_Settled` field is to be assigned a value equivalent to 30 days following the `Date_Claim_Made`. The function is required to return the NEW row. Furthermore, establish an AFTER INSERT FOR EACH ROW trigger named `trg_log_new_claim` on the \"Claims\" table to execute the aforementioned function.",
    "id": 96,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `log_new_claim` that declares a local BIGINT variable `next_settlement_id`, calculates its value by selecting `COALESCE(MAX(\"Settlement_ID\"), 0) + 1` from the `\"Settlements\"` table, and then inserts a new row into `\"Settlements\"` using values from the `NEW` record (including calculating `\"Date_Claim_Settled\"` as `NEW.\"Date_Claim_Made\" + INTERVAL '30 days'` and mapping `NEW.\"Policy_ID\"` to the `\"Customer_Policy_ID\"` column) before returning `NEW`.\nSecond, define the trigger `trg_log_new_claim` on table `\"Claims\"` that fires AFTER INSERT and executes the function.",
    "original_ir": "Write a PostgreSQL PL/pgSQL function named `log_new_claim` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `NEW` and `OLD` records representing the new and old row data, respectively, for the triggering event. The function returns a `TRIGGER` type, which is standard for PostgreSQL trigger functions.\n\nInside the function, a local variable named `next_settlement_id` of type `BIGINT` is declared. The first operation performed is a `SELECT` statement to determine the next available `Settlement_ID` for insertion into the `\"Settlements\"` table. This `SELECT` statement queries the `\"Settlements\"` table, specifically selecting the maximum value from the `\"Settlement_ID\"` column. The `COALESCE` function is used to handle cases where the `\"Settlements\"` table might be empty; if `MAX(\"Settlement_ID\")` returns `NULL` (indicating an empty table), `COALESCE` will substitute `0` instead. This result is then incremented by `1` to generate a unique `Settlement_ID` for the new record. The calculated value is stored in the `next_settlement_id` variable.\n\nFollowing this, an `INSERT` statement is executed to add a new record into the `\"Settlements\"` table. The columns targeted for insertion are `\"Settlement_ID\"`, `\"Claim_ID\"`, `\"Date_Claim_Made\"`, `\"Date_Claim_Settled\"`, `\"Amount_Claimed\"`, `\"Amount_Settled\"`, and `\"Customer_Policy_ID\"`. The values provided for these columns are as follows:\n- For `\"Settlement_ID\"`, the value from the `next_settlement_id` variable is used.\n- For `\"Claim_ID\"`, the value is taken from the `\"Claim_ID\"` column of the `NEW` record, which represents the row that just triggered this function.\n- For `\"Date_Claim_Made\"`, the value is taken from the `\"Date_Claim_Made\"` column of the `NEW` record.\n- For `\"Date_Claim_Settled\"`, the value is calculated by adding an `INTERVAL '30 days'` to the `\"Date_Claim_Made\"` column of the `NEW` record. This effectively sets the settlement date to 30 days after the claim was made.\n- For `\"Amount_Claimed\"`, the value is taken from the `\"Amount_Claimed\"` column of the `NEW` record.\n- For `\"Amount_Settled\"`, the value is taken from the `\"Amount_Settled\"` column of the `NEW` record.\n- For `\"Customer_Policy_ID\"`, the value is taken from the `\"Policy_ID\"` column of the `NEW` record.\n\nFinally, the function returns `NEW`, which is required for `AFTER` row-level triggers in PostgreSQL, indicating that the original row that triggered the event should be returned unchanged.\n\nA trigger named `trg_log_new_claim` is created. This trigger is configured to execute `AFTER INSERT` operations on the `\"Claims\"` table. It is a `FOR EACH ROW` trigger, meaning it will execute the associated function once for every row inserted into the `\"Claims\"` table. The function executed by this trigger is `log_new_claim()`. Therefore, whenever a new row is successfully inserted into the `\"Claims\"` table, this trigger will activate, and the `log_new_claim` function will be called to create a corresponding entry in the `\"Settlements\"` table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `handle_station_removal` that deletes rows from the `station_company` table where the `Company_ID` column matches the `OLD.Company_ID` from the deleted company row and the `Rank_of_the_Year` column has a value greater than 5, and then returns the `OLD` row.\nSecond, define the trigger `company_removal_trigger` on table `company` that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION handle_station_removal() RETURNS TRIGGER AS $$\nBEGIN\n  DELETE FROM station_company WHERE \"Company_ID\" = OLD.\"Company_ID\" AND \"Rank_of_the_Year\" > 5;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER company_removal_trigger\nAFTER DELETE ON company\nFOR EACH ROW EXECUTE FUNCTION handle_station_removal();",
    "database_name": "gas_company",
    "tables": [
      "company",
      "gas_station",
      "station_company"
    ],
    "call_sqls": [
      "DELETE FROM company WHERE \"Company_ID\" = 1;",
      "DELETE FROM company WHERE \"Company_ID\" = 3;",
      "DELETE FROM company WHERE \"Company_ID\" = 6;",
      "DELETE FROM company WHERE \"Company_ID\" = 2;",
      "DELETE FROM company WHERE \"Company_ID\" = 4;"
    ],
    "summary": "Create a BEFORE INSERT trigger function named check_customer_exists for the Customer_Events table. If NEW.customer_id does not exist in the Customers table, insert it with customer_details as 'Auto-created Customer'. Then, attempt to insert NEW.resident_id, NEW.property_id, and NEW.date_moved_in into the Residents table with ON CONFLICT DO NOTHING. If the Residents table does not exist, raise an exception stating the constraint cannot be satisfied with the provided values. For any other exception, raise the SQL error. Return NEW.",
    "natural_language": "How can I create a BEFORE INSERT trigger function named check_customer_exists for the Customer_Events table that checks if NEW.customer_id exists in the Customers table, inserts it with 'Auto-created Customer' details if it does not, then attempts to insert NEW.resident_id, NEW.property_id, and NEW.date_moved_in into the Residents table with ON CONFLICT DO NOTHING, raises an exception if the Residents table is missing, raises any other SQL error, and finally returns NEW?",
    "id": 97,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `check_customer_exists` that is designed to be executed as a trigger. This function does not accept any explicit input parameters but implicitly operates on the `NEW` pseudo-record provided by the trigger mechanism. The function returns a `TRIGGER` type, which is standard for PL/pgSQL trigger functions. The primary purpose of this function is to enforce data integrity and handle missing references for new rows being inserted into the `Customer_Events` table.\n\nUpon execution, the function first performs a validation check on the `customer_id` column of the `NEW` record. It verifies the existence of the `customer_id` referenced in the `NEW` record within a separate `Customers` table. This is achieved by executing a `SELECT` statement: `SELECT 1 FROM Customers WHERE customer_id = NEW.customer_id`. The `EXISTS` operator is used to check if any row is returned by this subquery. If the subquery returns no rows, meaning `NOT EXISTS` is true, it indicates that the `customer_id` in the `NEW` record does not correspond to an existing customer in the `Customers` table. In this scenario, the function performs an `INSERT` operation into the `Customers` table. The `INSERT` statement specifies the columns `customer_id`, `customer_name`, and `customer_email` (assuming these are required columns based on typical customer table structure). The values inserted are `NEW.customer_id` for the `customer_id` column, the literal string `'Auto-created Customer'` for the `customer_name` column, and the literal string `'auto-created@example.com'` for the `customer_email` column. This automatically creates a new customer record with placeholder details.\n\nFollowing this, the function proceeds to its second operation. It attempts to insert data into the `Residents` table. The `INSERT` statement specifies the columns `resident_id`, `property_id`, and `date_moved_in`. The values inserted are `NEW.resident_id`, `NEW.property_id`, and `NEW.date_moved_in`, all taken from the `NEW` record. This `INSERT` includes an `ON CONFLICT (resident_id) DO NOTHING` clause. This clause handles cases where a row with the same `resident_id` already exists in the `Residents` table by preventing the insertion and avoiding a duplicate key error, effectively performing no action on conflict.\n\nThe function then includes exception handling using a `BEGIN ... EXCEPTION` block. Within the `EXCEPTION` section, it catches specific SQL errors. First, it catches the `undefined_table` exception, which occurs if the `Residents` table does not exist in the database. When this exception is caught, the function raises a new exception with the message `'Residents table is missing'`. This informs the user that the required table is not present. Second, it catches the `others` exception, which is a catch-all for any other SQL error that might occur during the `INSERT` into the `Residents` table. When this exception is caught, the function re-raises the original error using the `RAISE` statement, propagating the error to the caller for further handling.\n\nIf all operations complete without raising any exceptions, the function concludes by returning the `NEW` record. This signifies that the data in the `NEW` record is considered valid and can proceed with the `INSERT` operation that initiated the trigger.\n\nA trigger named `trg_check_customer_exists` is created to automatically invoke the `check_customer_exists` function. This trigger is configured to execute `BEFORE INSERT ON Customer_Events`. This means that the `check_customer_exists` function will be called before any `INSERT` operation is applied to the `Customer_Events` table. The `FOR EACH ROW` clause specifies that the trigger function will be executed once for each row that is being inserted. The `EXECUTE FUNCTION check_customer_exists()` clause explicitly calls the previously defined function.",
    "original_ir": "Write a PostgreSQL trigger function named handle_station_removal that returns a trigger and is executed by a trigger named company_removal_trigger, where the trigger is defined to fire after a delete operation on the company table for each row that is deleted, and the function performs a delete operation on the station_company table targeting all rows where the column Company_ID matches the OLD.Company_ID value from the deleted company row and the column Rank_of_the_Year has a value greater than 5, and the function concludes by returning the OLD row record to the invoking trigger."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function update_highschooler_grade that updates the \"Highschooler\" table by incrementing the \"grade\" column by one for the row where the \"ID\" column matches the NEW.\"student_id\" from the inserted \"Friend\" row, and then returns NEW.\nSecond, define the trigger grade_update_trigger on table \"Friend\" that fires AFTER INSERT and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION update_highschooler_grade() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE \"Highschooler\" SET \"grade\" = \"grade\" + 1 WHERE \"ID\" = NEW.\"student_id\";\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER grade_update_trigger\nAFTER INSERT ON \"Friend\"\nFOR EACH ROW\nEXECUTE FUNCTION update_highschooler_grade();\n\n-- Insert statement with proper conflict handling\nINSERT INTO \"Friend\" (student_id, friend_id)\nVALUES (1510, 1381)\nON CONFLICT DO NOTHING;",
    "database_name": "network_1",
    "tables": [
      "Friend",
      "Highschooler",
      "Likes"
    ],
    "call_sqls": [
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1510, 1709) ON CONFLICT DO NOTHING;",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1689, 1381) ON CONFLICT DO NOTHING;",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1689, 1709) ON CONFLICT DO NOTHING;",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1381, 1510) ON CONFLICT DO NOTHING;",
      "INSERT INTO \"Friend\" (student_id, friend_id) VALUES (1381, 1689) ON CONFLICT DO NOTHING;"
    ],
    "summary": "Create an AFTER INSERT trigger function for the \"Friend\" table named update_highschooler_grade. The function must increment the \"grade\" column in the \"Highschooler\" table by 1 for the row where its \"ID\" matches NEW.student_id. The function should return NEW. Also, write an INSERT statement for the \"Friend\" table with values (1510, 1381) that uses ON CONFLICT DO NOTHING.",
    "natural_language": "Define an AFTER INSERT trigger function called update_highschooler_grade for the \"Friend\" table. This function must add 1 to the \"grade\" column in the \"Highschooler\" table for the row whose \"ID\" equals NEW.student_id and must return NEW. Then, insert the values (1510, 1381) into the \"Friend\" table, using ON CONFLICT DO NOTHING.",
    "id": 98,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration for the database network_1. First, create a function named update_highschooler_grade with no parameters, returning a trigger type, and written in PL/pgSQL language. This function is designed to execute after each INSERT operation on the Friend table for each individual row being processed. Inside the function, declare no explicit variables. The function performs an UPDATE operation on the Highschooler table, specifically targeting the row where the ID column matches the NEW.student_id value from the inserted Friend row. In this update, the grade column is incremented by 1 using the expression grade = grade + 1. After the update, the function returns the NEW row record to the trigger mechanism. Second, define the trigger trg_update_highschooler_grade on the Friend table, specifying that it should fire after INSERT operations for each row, and it calls the update_highschooler_grade function. Additionally, as part of the overall implementation, an INSERT operation is performed on the Friend table with the values student_id = 1510 and friend_id = 1381, using the ON CONFLICT DO NOTHING clause to handle any conflicts by taking no action.",
    "original_ir": "Write a PostgreSQL trigger function named update_highschooler_grade that returns a trigger, which is then bound to the \"Friend\" table via a trigger named grade_update_trigger configured to fire automatically after every successful insertion of a new row into the \"Friend\" table, and for each such new row, the function executes an update operation on the \"Highschooler\" table, specifically incrementing the value in the \"grade\" column by one for the single row in the \"Highschooler\" table where the \"ID\" column value exactly matches the value of the NEW.\"student_id\" column from the newly inserted \"Friend\" row, after which the function returns the NEW row record, and an accompanying insert statement attempts to add a new record into the \"Friend\" table with a student_id of 1510 and a friend_id of 1381, employing an ON CONFLICT DO NOTHING clause to prevent the insertion and silently skip the operation if a conflict arises on any unique constraint or exclusion constraint violation for the table."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `archive_deleted_country` that inserts a new row into the `\"roller_coaster\"` table using values from the `OLD` record, specifically setting `\"Roller_Coaster_ID\"` to `OLD.\"Country_ID\" + 2000`, `\"Name\"` to 'Archived', `\"Park\"` to 'Archive Park', `\"Country_ID\"` to `OLD.\"Country_ID\"`, `\"Length\"` to 0.0, `\"Height\"` to 0.0, `\"Speed\"` to '0', `\"Opened\"` to 'Archived', and `\"Status\"` to 'Archived', then returns `OLD`. Second, define the trigger `country_archive_trigger` on table `\"country\"` that fires AFTER DELETE and executes the function.",
    "plsql": "CREATE OR REPLACE FUNCTION archive_deleted_country() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO \"roller_coaster\" (\"Roller_Coaster_ID\", \"Name\", \"Park\", \"Country_ID\", \"Length\", \"Height\", \"Speed\", \"Opened\", \"Status\") VALUES (OLD.\"Country_ID\" + 2000, 'Archived', 'Archive Park', OLD.\"Country_ID\", 0.0, 0.0, '0', 'Archived', 'Archived');\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER country_archive_trigger\nAFTER DELETE ON \"country\"\nFOR EACH ROW EXECUTE FUNCTION archive_deleted_country();",
    "database_name": "roller_coaster",
    "tables": [
      "country",
      "roller_coaster"
    ],
    "call_sqls": [
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 1;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 2;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 3;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 4;",
      "DELETE FROM \"country\" WHERE \"Country_ID\" = 5;"
    ],
    "summary": "Create a trigger function named archive_deleted_country that returns TRIGGER. After a row is deleted from the \"country\" table, insert a new row into the \"roller_coaster\" table. Set \"Roller_Coaster_ID\" to OLD.\"Country_ID\" + 2000, \"Name\" to 'Archived', \"Park\" to 'Archive Park', \"Country_ID\" to OLD.\"Country_ID\", \"Length\" to 0.0, \"Height\" to 0.0, \"Speed\" to '0', \"Opened\" to 'Archived', and \"Status\" to 'Archived'. Return the OLD record. Create an AFTER DELETE trigger named country_archive_trigger on the \"country\" table for each row to execute this function.",
    "natural_language": "Define a trigger function called archive_deleted_country that returns TRIGGER. After a row gets deleted from the \"country\" table, insert a new row into the \"roller_coaster\" table. Set the \"Roller_Coaster_ID\" to OLD.\"Country_ID\" plus 2000, \"Name\" to 'Archived', \"Park\" to 'Archive Park', \"Country_ID\" to OLD.\"Country_ID\", \"Length\" to 0.0, \"Height\" to 0.0, \"Speed\" to '0', \"Opened\" to 'Archived', and \"Status\" to 'Archived'. Return the OLD record. Then, create an AFTER DELETE trigger named country_archive_trigger on the \"country\" table for each row to run this function.",
    "id": 99,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration. First, create the function `archive_deleted_country` that inserts a new row into the `\"roller_coaster\"` table using values from the `OLD` record, specifically setting `\"Roller_Coaster_ID\"` to `OLD.\"Country_ID\" + 2000`, `\"Name\"` to 'Archived', `\"Park\"` to 'Archive Park', `\"Country_ID\"` to `OLD.\"Country_ID\"`, `\"Length\"` to 0.0, `\"Height\"` to 0.0, `\"Speed\"` to '0', `\"Opened\"` to 'Archived', and `\"Status\"` to 'Archived', then returns `OLD`. Second, define the trigger `country_archive_trigger` on table `\"country\"` that fires AFTER DELETE and executes the function.",
    "original_ir": "Write a PL/pgSQL function named `archive_deleted_country` that is designed to be executed as a trigger. This function takes no explicit parameters but operates within the context of a trigger, meaning it has access to special `OLD` and `NEW` records representing the row before and after the triggering event, respectively. The function's primary purpose is to insert a new record into the `\"roller_coaster\"` table. The values for this new record are derived as follows: the `\"Roller_Coaster_ID\"` column is populated by adding the integer value 2000 to the value of the `\"Country_ID\"` column from the `OLD` record (the row that was deleted). The `\"Name\"` column is set to the literal string 'Archived'. The `\"Park\"` column is set to the literal string 'Archive Park'. The `\"Country_ID\"` column is populated with the value of the `\"Country_ID\"` column from the `OLD` record. The `\"Length\"` column is set to the floating-point value 0.0. The `\"Height\"` column is set to the floating-point value 0.0. The `\"Speed\"` column is set to the literal string '0'. The `\"Opened\"` column is set to the literal string 'Archived'. The `\"Status\"` column is set to the literal string 'Archived'. After performing this insertion, the function returns the `OLD` record, which is standard behavior for `AFTER DELETE` triggers that do not intend to prevent the deletion.\n\nAdditionally, a trigger named `country_archive_trigger` is created. This trigger is configured to activate `AFTER DELETE` operations on the `\"country\"` table. It is specified to execute `FOR EACH ROW`, meaning that the `archive_deleted_country` function will be invoked once for every row that is deleted from the `\"country\"` table. The trigger executes the `archive_deleted_country` function, which, as described, inserts an archived record into the `\"roller_coaster\"` table based on the details of the deleted country row."
  },
  {
    "ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_update_job_title_on_change` that updates the `JOB_ID` column in the `employees` table to the value from `NEW.JOB_ID` for all rows where the current `JOB_ID` equals `OLD.JOB_ID`, and then returns the `NEW` record.\nSecond, define the trigger `update_job_title_on_change` on table `jobs` that fires AFTER UPDATE of the `JOB_ID` column and executes the function for each row.",
    "plsql": "CREATE OR REPLACE FUNCTION trg_update_job_title_on_change() RETURNS TRIGGER AS $$\nBEGIN\n    UPDATE employees SET \"JOB_ID\" = NEW.\"JOB_ID\" WHERE \"JOB_ID\" = OLD.\"JOB_ID\";\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_job_title_on_change\nAFTER UPDATE OF \"JOB_ID\" ON jobs\nFOR EACH ROW EXECUTE FUNCTION trg_update_job_title_on_change();",
    "database_name": "hr_1",
    "tables": [
      "employees",
      "departments",
      "jobs",
      "job_history"
    ],
    "call_sqls": [
      "UPDATE jobs SET \"JOB_ID\" = 'AD_VP' WHERE \"JOB_ID\" = 'AD_PRES';",
      "UPDATE jobs SET \"JOB_ID\" = 'AD_ASST' WHERE \"JOB_ID\" = 'AD_VP';",
      "UPDATE jobs SET \"JOB_ID\" = 'AD_PRES' WHERE \"JOB_ID\" = 'AD_ASST';",
      "UPDATE jobs SET \"JOB_ID\" = 'AD_VP' WHERE \"JOB_ID\" = 'AD_ASST';",
      "UPDATE jobs SET \"JOB_ID\" = 'AD_ASST' WHERE \"JOB_ID\" = 'AD_PRES';"
    ],
    "summary": "Create an AFTER UPDATE trigger function named trg_update_job_title_on_change for the jobs table, triggered only when the JOB_ID column is updated. For each updated row, update the employees table, setting JOB_ID to NEW.JOB_ID where JOB_ID equals OLD.JOB_ID. Return the NEW record.",
    "natural_language": "Create AFTER UPDATE trigger trg_update_job_title_on_change on jobs for JOB_ID changes. Update employees' JOB_ID from OLD to NEW value. Return NEW.",
    "id": 100,
    "generated_ir": "Write a PL/pgSQL trigger script that includes both a trigger function and a trigger declaration.\nFirst, create the function `trg_update_job_title_on_change` that updates the `JOB_ID` column in the `employees` table to the value from `NEW.JOB_ID` for all rows where the current `JOB_ID` equals `OLD.JOB_ID`, and then returns the `NEW` record.\nSecond, define the trigger `update_job_title_on_change` on table `jobs` that fires AFTER UPDATE of the `JOB_ID` column and executes the function for each row.",
    "original_ir": "Write a PostgreSQL PL/pgSQL trigger function named `trg_update_job_title_on_change` that is designed to be executed in response to data manipulation language (DML) events on a specific table. This function does not accept any explicit input parameters beyond the standard trigger context variables. Upon execution, the function performs a single `UPDATE` operation on the `employees` table. The `UPDATE` statement modifies the `JOB_ID` column within the `employees` table. The new value for the `JOB_ID` column in the `employees` table is derived from the `NEW` record's `JOB_ID` column, which represents the state of the row *after* the DML operation that fired the trigger. This update is applied to rows in the `employees` table where the existing value of the `JOB_ID` column matches the `OLD` record's `JOB_ID` column, which represents the state of the row *before* the DML operation that fired the trigger. After performing this update, the function returns the `NEW` record, indicating that the row that triggered the operation should be processed as modified.\n\nA trigger named `update_job_title_on_change` is defined to execute this function. This trigger is configured to activate `AFTER` an `UPDATE` operation occurs on the `jobs` table. Specifically, the trigger is sensitive only to updates that modify the `JOB_ID` column of the `jobs` table. The trigger is set to execute `FOR EACH ROW` that is affected by such an `UPDATE` statement, meaning the `trg_update_job_title_on_change` function will be invoked once for every row where the `JOB_ID` column in the `jobs` table has been updated."
  }
]