[
  {
    "ir": "Write an Oracle PL/SQL function named get_user_report_summary that accepts a single input parameter user_id of type NUMBER, which represents the unique identifier of a user. The function returns a VARCHAR2 string that summarizes the user's report activity. Within the function, a local variable report_summary of type VARCHAR2 with a maximum length of 255 characters is declared to store the result of a query. The function executes a SELECT statement that concatenates the string 'User: ' with the USER_NAME column from the USERS table, followed by the string ', Reports: ', and the count of REPORT_IDs from the DAILY_REPORTS table. This query involves joining three tables: USERS, DATA_CORRECTIONS, and DAILY_REPORTS. The USERS table is aliased as U, and it is joined with the DATA_CORRECTIONS table, aliased as DC, on the condition that the USER_ID column in USERS matches the CORRECTED_BY column in DATA_CORRECTIONS. Subsequently, the DATA_CORRECTIONS table is joined with the DAILY_REPORTS table, aliased as DR, on the condition that the REPORT_ID column in DATA_CORRECTIONS matches the REPORT_ID column in DAILY_REPORTS. The WHERE clause filters the results to include only the row where the USER_ID column in the USERS table matches the input parameter user_id. The results are grouped by the USER_NAME column to ensure that the count of reports is calculated for each user. The concatenated string is then assigned to the report_summary variable. Finally, the function returns the value of report_summary, which provides a textual summary of the user's name and the total number of reports they have corrected.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_report_summary(user_id IN NUMBER) RETURN VARCHAR2 IS\n  report_summary VARCHAR2(255);\nBEGIN\n  SELECT 'User: ' || U.USER_NAME || ', Reports: ' || COUNT(DR.REPORT_ID)\n  INTO report_summary\n  FROM USERS U\n  JOIN DATA_CORRECTIONS DC ON U.USER_ID = DC.CORRECTED_BY\n  JOIN DAILY_REPORTS DR ON DC.REPORT_ID = DR.REPORT_ID\n  WHERE U.USER_ID = user_id\n  GROUP BY U.USER_NAME;\n  \n  RETURN report_summary;\nEND;",
    "database_name": "covid_1dtaa_576932",
    "tables": [
      "DAILY_REPORTS",
      "DATA_CORRECTIONS",
      "DATA_QUALITY",
      "USERS"
    ],
    "call_sqls": [
      "SELECT get_user_report_summary(0) FROM dual",
      "SELECT get_user_report_summary(1) FROM dual",
      "SELECT get_user_report_summary(2) FROM dual",
      "SELECT get_user_report_summary(3) FROM dual",
      "SELECT get_user_report_summary(4) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_user_report_summary that accepts a user_id and returns a summary string containing the user's name from the USERS table and the count of reports they have corrected, by joining the USERS, DATA_CORRECTIONS, and DAILY_REPORTS tables where the user's USER_ID matches the corrected_by in DATA_CORRECTIONS and the REPORT_ID matches between DATA_CORRECTIONS and DAILY_REPORTS.",
    "natural_language": "Write a Oracle PL/SQL function named get_user_report_summary that, given a user_id, returns a summary string showing the user's name from the USERS table and the total count of reports they have corrected by joining the USERS, DATA_CORRECTIONS, and DAILY_REPORTS tables.",
    "id": 1,
    "generated_ir": "Write an Oracle PL/SQL function named get_user_report_summary that accepts a single input parameter user_id of type NUMBER, which represents the unique identifier of a user. The function returns a VARCHAR2 string that summarizes the user's report activity. Within the function, a local variable report_summary of type VARCHAR2 with a maximum length of 255 characters is declared to store the result of a query. The function executes a SELECT statement that concatenates the string 'User: ' with the USER_NAME column from the USERS table, followed by the string ', Reports: ', and the count of REPORT_IDs from the DAILY_REPORTS table. This query involves joining three tables: USERS, DATA_CORRECTIONS, and DAILY_REPORTS. The USERS table is aliased as U, and it is joined with the DATA_CORRECTIONS table, aliased as DC, on the condition that the USER_ID column in USERS matches the CORRECTED_BY column in DATA_CORRECTIONS. Subsequently, the DATA_CORRECTIONS table is joined with the DAILY_REPORTS table, aliased as DR, on the condition that the REPORT_ID column in DATA_CORRECTIONS matches the REPORT_ID column in DAILY_REPORTS. The WHERE clause filters the results to include only the row where the USER_ID column in the USERS table matches the input parameter user_id. The results are grouped by the USER_NAME column to ensure that the count of reports is calculated for each user. The concatenated string is then assigned to the report_summary variable. Finally, the function returns the value of report_summary, which provides a textual summary of the user's name and the total number of reports they have corrected.",
    "original_summary": "Create a PL/SQL function named get_user_report_summary that accepts a user_id NUMBER and returns a VARCHAR2. It should return a summary string containing the user's name and the count of reports they have corrected, by joining the USERS, DATA_CORRECTIONS, and DAILY_REPORTS tables.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/SQL function designated as 'get_user_report_summary'. This function shall accept a single input parameter of the NUMBER data type, specifically a user_id, and shall return a value of the VARCHAR2 data type. The function's purpose is to generate a summary string that incorporates the user's name and the total count of reports they have corrected. This is to be achieved by performing a join operation across the USERS, DATA_CORRECTIONS, and DAILY_REPORTS tables."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_algorithm_models that accepts three input parameters: algo_name of type VARCHAR2, status_filter of type VARCHAR2, and char_set of type VARCHAR2. The function returns a NUMBER representing the count of models. Within the function, declare a local variable model_count of type NUMBER to store the result of a query. Execute a SELECT statement that performs a COUNT operation on all rows from the MODELS table, aliased as m, joined with the ALGORITHMS table, aliased as a, using the condition that the ALGORITHM column in the MODELS table matches the ALGORITHM_ID column in the ALGORITHMS table. Apply a WHERE clause to filter the results such that the ALGORITHM_NAME column in the ALGORITHMS table, after being converted to the character set specified by the char_set parameter using the CONVERT function, matches the algo_name parameter, and the STATUS column in the MODELS table matches the status_filter parameter. Store the result of this COUNT operation into the model_count variable. Finally, return the value of model_count as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_algorithm_models(algo_name IN VARCHAR2, status_filter IN VARCHAR2, char_set IN VARCHAR2) RETURN NUMBER IS\n  model_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO model_count FROM MODELS m JOIN ALGORITHMS a ON m.ALGORITHM = a.ALGORITHM_ID WHERE a.ALGORITHM_NAME = CONVERT(algo_name, char_set) AND m.STATUS = status_filter;\n  RETURN model_count;\nEND;",
    "database_name": "machine_lmeao_637620",
    "tables": [
      "ALGORITHMS",
      "HYPERPARAMETERS",
      "MODELS",
      "MODEL_EVALUATIONS",
      "EVALUATION_METRICS",
      "MODEL_TYPES",
      "MODEL_VERSIONS"
    ],
    "call_sqls": [
      "SELECT get_algorithm_models('Decision Tree', 'Active', 'WE8ISO8859P1') FROM DUAL",
      "SELECT get_algorithm_models('K-Means', 'Inactive', 'AL32UTF8') FROM DUAL",
      "SELECT get_algorithm_models('Linear Regression', 'Active', 'US7ASCII') FROM DUAL",
      "SELECT get_algorithm_models('Random Forest', 'Pending', 'WE8MSWIN1252') FROM DUAL",
      "SELECT get_algorithm_models('Support Vector Machine', 'Active', 'UTF8') FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_algorithm_models that returns the total count of models from the MODELS table joined with the ALGORITHMS table, where the ALGORITHM_NAME from ALGORITHMS matches a provided algorithm name after converting it using a specified character set, and the STATUS from MODELS matches a provided status filter.",
    "natural_language": "Write a Oracle PL/SQL function named get_algorithm_models that returns a number representing the total count of records. It takes three inputs: an algorithm name (algo_name), a status to filter by (status_filter), and a character set (char_set). The function should count records from the MODELS table joined with the ALGORITHMS table where the ALGORITHM_NAME matches the algo_name after converting it using the provided char_set, and the STATUS in MODELS equals the status_filter.",
    "id": 2,
    "generated_ir": "Write an Oracle PL/SQL function named get_algorithm_models that accepts three input parameters: algo_name of type VARCHAR2, status_filter of type VARCHAR2, and char_set of type VARCHAR2. The function returns a NUMBER representing the count of models. Within the function, declare a local variable model_count of type NUMBER to store the result of a query. Execute a SELECT statement that performs a COUNT operation on all rows from the MODELS table, aliased as m, joined with the ALGORITHMS table, aliased as a, using the condition that the ALGORITHM column in the MODELS table matches the ALGORITHM_ID column in the ALGORITHMS table. Apply a WHERE clause to filter the results such that the ALGORITHM_NAME column in the ALGORITHMS table, after being converted to the character set specified by the char_set parameter using the CONVERT function, matches the algo_name parameter, and the STATUS column in the MODELS table matches the status_filter parameter. Store the result of this COUNT operation into the model_count variable. Finally, return the value of model_count as the output of the function.",
    "original_summary": "Create a PL/SQL function named get_algorithm_models that returns a NUMBER. It accepts parameters algo_name (VARCHAR2), status_filter (VARCHAR2), and char_set (VARCHAR2). It returns the count of rows from the joined MODELS and ALGORITHMS tables where the converted ALGORITHM_NAME matches algo_name (using the specified char_set) and the STATUS matches status_filter.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/SQL function designated as 'get_algorithm_models' that yields a NUMBER data type. This function shall accept three input parameters: 'algo_name' of type VARCHAR2, 'status_filter' of type VARCHAR2, and 'char_set' of type VARCHAR2. Its purpose is to compute and return the total count of records obtained from an inner join of the MODELS and ALGORITHMS tables. The count is to be determined based on the condition where the ALGORITHM_NAME, converted using the provided character set ('char_set'), is equivalent to the 'algo_name' parameter, and where the STATUS column matches the 'status_filter' parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_workclass_occupation` that accepts two input parameters: `p_individual_id` of data type `NUMBER` to identify a specific individual record, and `p_format` of data type `VARCHAR2` (though this parameter is declared, it is not utilized within the current function body). The function is designed to return a single value of data type `VARCHAR2`. Upon execution, the function declares a local variable `v_result` of data type `VARCHAR2` with a maximum length of 500 characters. The core operation involves a `SELECT` statement that retrieves data from three tables: `individuals`, `work_classes`, and `occupations`. The `individuals` table is aliased as `i`, the `work_classes` table as `w`, and the `occupations` table as `o`. The `individuals` table is joined with the `work_classes` table using an inner join condition where the `workclass_id` column from the `individuals` table (`i.workclass_id`) matches the `workclass_id` column from the `work_classes` table (`w.workclass_id`). Subsequently, the result of this join is further joined with the `occupations` table using another inner join condition where the `occupation_id` column from the `individuals` table (`i.occupation_id`) matches the `occupation_id` column from the `occupations` table (`o.occupation_id`). The `WHERE` clause filters the joined records, ensuring that only the row where the `individual_id` column from the `individuals` table (`i.individual_id`) is equal to the value provided in the `p_individual_id` input parameter is considered. From the filtered and joined record, the function concatenates the value of the `workclass_name` column from the `work_classes` table (`w.workclass_name`), followed by a literal string ' - ', and then the value of the `occupation_name` column from the `occupations` table (`o.occupation_name`). This concatenated string is then assigned to the local variable `v_result`. Finally, the function returns the value stored in `v_result`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_workclass_occupation(p_individual_id NUMBER, p_format VARCHAR2) RETURN VARCHAR2 IS\n    v_result VARCHAR2(500);\nBEGIN\n    SELECT w.workclass_name || ' - ' || o.occupation_name INTO v_result\n    FROM individuals i\n    JOIN work_classes w ON i.workclass_id = w.workclass_id\n    JOIN occupations o ON i.occupation_id = o.occupation_id\n    WHERE i.individual_id = p_individual_id;\n    RETURN v_result;\nEND;",
    "database_name": "demographic_aeda_61583",
    "tables": [
      "INDIVIDUALS",
      "MARITAL_STATUSES",
      "OCCUPATIONS",
      "WORK_CLASSES"
    ],
    "call_sqls": [
      "SELECT get_workclass_occupation(1001, 'FULL') FROM dual",
      "SELECT get_workclass_occupation(2045, 'SHORT') FROM dual",
      "SELECT get_workclass_occupation(312, 'DEFAULT') FROM dual",
      "SELECT get_workclass_occupation(5678, NULL) FROM dual",
      "SELECT individual_id, get_workclass_occupation(individual_id, 'FORMATTED') FROM individuals WHERE individual_id = 899"
    ],
    "summary": "Write a Oracle PL/SQL function named `get_workclass_occupation` that, given an individual's ID as input, retrieves from the `individuals`, `work_classes`, and `occupations` tables the corresponding workclass name and occupation name for that individual, concatenates them with a hyphen separator, and returns the combined string.",
    "natural_language": "Write a Oracle PL/SQL function called `get_workclass_occupation` that takes an individual ID and a format parameter (which is not used) and returns a concatenated string of up to 500 characters combining the `workclass_name` from the `work_classes` table and the `occupation_name` from the `occupations` table for the specified individual from the `individuals` table.",
    "id": 3,
    "generated_ir": "Write an Oracle PL/SQL function named `get_workclass_occupation` that accepts two input parameters: `p_individual_id` of data type `NUMBER` to identify a specific individual record, and `p_format` of data type `VARCHAR2` (though this parameter is declared, it is not utilized within the current function body). The function is designed to return a single value of data type `VARCHAR2`. Upon execution, the function declares a local variable `v_result` of data type `VARCHAR2` with a maximum length of 500 characters. The core operation involves a `SELECT` statement that retrieves data from three tables: `individuals`, `work_classes`, and `occupations`. The `individuals` table is aliased as `i`, the `work_classes` table as `w`, and the `occupations` table as `o`. The `individuals` table is joined with the `work_classes` table using an inner join condition where the `workclass_id` column from the `individuals` table (`i.workclass_id`) matches the `workclass_id` column from the `work_classes` table (`w.workclass_id`). Subsequently, the result of this join is further joined with the `occupations` table using another inner join condition where the `occupation_id` column from the `individuals` table (`i.occupation_id`) matches the `occupation_id` column from the `occupations` table (`o.occupation_id`). The `WHERE` clause filters the joined records, ensuring that only the row where the `individual_id` column from the `individuals` table (`i.individual_id`) is equal to the value provided in the `p_individual_id` input parameter is considered. From the filtered and joined record, the function concatenates the value of the `workclass_name` column from the `work_classes` table (`w.workclass_name`), followed by a literal string ' - ', and then the value of the `occupation_name` column from the `occupations` table (`o.occupation_name`). This concatenated string is then assigned to the local variable `v_result`. Finally, the function returns the value stored in `v_result`.",
    "original_summary": "Create a PL/SQL function named `get_workclass_occupation` that accepts a NUMBER parameter `p_individual_id` and an unused VARCHAR2 parameter `p_format`. It returns a VARCHAR2(500). It joins the `individuals`, `work_classes`, and `occupations` tables to retrieve and concatenate the `workclass_name` and `occupation_name` for the specified individual, returning the formatted string.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function called `get_workclass_occupation` that takes a NUMBER parameter named `p_individual_id` and a VARCHAR2 parameter `p_format` which is intentionally not utilized. This function must return a VARCHAR2 value with a maximum length of 500 characters. It should perform a detailed join across three tables—`individuals`, `work_classes`, and `occupations`—to meticulously fetch and then seamlessly concatenate the specific `workclass_name` and `occupation_name` associated with the provided individual identifier, ultimately delivering the neatly formatted concatenated string as its output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_gateway_covar` that accepts no input parameters and returns a `NUMBER` data type. This function is designed to calculate a specific covariance value and then categorize it into one of several predefined numerical ranges.\n\nThe function begins by declaring two local variables: `v_covar` of type `NUMBER` and `v_final` of type `NUMBER`.\n\nThe core operation involves executing a `SELECT` statement to calculate the sample covariance between two specific columns from joined tables. Specifically, it calculates `COVAR_SAMP(p.BASKET_VALUE_CENTS, tf.FEE_AMOUNT_CENTS)`. This calculation is performed by joining three tables:\n1.  `PAYMENTS` (aliased as `p`)\n2.  `TRANSACTION_FEES` (aliased as `tf`)\n3.  `PAYMENT_GATEWAY_INTEGRATIONS` (aliased as `pg`)\n\nThe join conditions are as follows:\n*   `p.PAYMENT_ID = tf.PAYMENT_ID`: This links records from the `PAYMENTS` table to the `TRANSACTION_FEES` table based on a common `PAYMENT_ID`.\n*   `p.GATEWAY_ID = pg.GATEWAY_ID`: This links records from the `PAYMENTS` table to the `PAYMENT_GATEWAY_INTEGRATIONS` table based on a common `GATEWAY_ID`.\n\nAdditionally, a `WHERE` clause filters the joined results, ensuring that only records where `pg.IS_ACTIVE = 1` are included in the covariance calculation. This means only active payment gateway integrations are considered. The result of this `COVAR_SAMP` aggregation is then stored into the local variable `v_covar`.\n\nFollowing the covariance calculation, the function proceeds with a series of conditional checks (`IF-ELSIF-ELSE`) on the value of `v_covar` to determine the final return value, which will be stored in `v_final`:\n*   If `v_covar` is strictly greater than `5000`, then `v_final` is assigned the value `100`.\n*   Else if `v_covar` is strictly greater than `1000` (meaning it's not greater than 5000 but is greater than 1000), then `v_final` is assigned the value `50`.\n*   Else if `v_covar` is `NULL` (meaning the `COVAR_SAMP` function returned no rows or all inputs were `NULL`), then `v_final` is assigned the value `0`.\n*   In all other cases (i.e., `v_covar` is not `NULL`, not greater than 5000, and not greater than 1000, implying `v_covar` is less than or equal to 1000 and not `NULL`), then `v_final` is assigned the value `10`.\n\nFinally, the function returns the value stored in `v_final`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_gateway_covar RETURN NUMBER IS\n    v_covar NUMBER;\n    v_final NUMBER;\nBEGIN\n    SELECT COVAR_SAMP(p.BASKET_VALUE_CENTS, tf.FEE_AMOUNT_CENTS) INTO v_covar FROM PAYMENTS p JOIN TRANSACTION_FEES tf ON p.PAYMENT_ID = tf.PAYMENT_ID JOIN PAYMENT_GATEWAY_INTEGRATIONS pg ON p.GATEWAY_ID = pg.GATEWAY_ID WHERE pg.IS_ACTIVE = 1;\n    IF v_covar > 5000 THEN\n        v_final := 100;\n    ELSIF v_covar > 1000 THEN\n        v_final := 50;\n    ELSIF v_covar IS NULL THEN\n        v_final := 0;\n    ELSE\n        v_final := 10;\n    END IF;\n    RETURN v_final;\nEND;",
    "database_name": "e_cppaf_detection",
    "tables": [
      "PAYMENTS",
      "FRAUD_DETECTION",
      "INSTALLMENT_PLANS",
      "TRANSACTION_FEES",
      "MERCHANT_IDS",
      "PAYMENT_ORIGINS",
      "PAYMENT_GATEWAY_INTEGRATIONS",
      "PAYMENT_METHOD_MANAGEMENT"
    ],
    "call_sqls": [
      "SELECT calculate_gateway_covar FROM DUAL",
      "SELECT calculate_gateway_covar() FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Covariance Result: ' || calculate_gateway_covar);\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := calculate_gateway_covar;\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;",
      "SELECT calculate_gateway_covar AS gateway_covariance_score FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_gateway_covar that returns a NUMBER representing a gateway covariance score. It calculates the sample covariance between BASKET_VALUE_CENTS in the PAYMENTS table and FEE_AMOUNT_CENTS in the TRANSACTION_FEES table, considering only active payment gateways where IS_ACTIVE equals 1 in the PAYMENT_GATEWAY_INTEGRATIONS table. The function returns 100 if the covariance exceeds 5000, 50 if it exceeds 1000, 0 if the covariance is NULL, and 10 otherwise.",
    "natural_language": "Write a Oracle PL/SQL function named calculate_gateway_covar that returns a number representing a mapped score based on the sample covariance between PAYMENTS.BASKET_VALUE_CENTS and TRANSACTION_FEES.FEE_AMOUNT_CENTS for active payment gateways. The function should calculate the covariance from joined data in PAYMENTS, TRANSACTION_FEES, and PAYMENT_GATEWAY_INTEGRATIONS where PAYMENT_GATEWAY_INTEGRATIONS.IS_ACTIVE is 1, then map the result to a return value: if the covariance is greater than 5000, return 100; if greater than 1000, return 50; if null, return 0; otherwise, return 10.",
    "id": 4,
    "generated_ir": "Write an Oracle PL/SQL function named `calculate_gateway_covar` that is designed to compute a sample covariance metric from payment and fee data, and then map that covariance value to a predefined numerical score. The function accepts no input parameters and returns a single output of data type `NUMBER`.\n\nThe function declares several local variables. A variable `v_covariance` of type `NUMBER` is declared to store the computed sample covariance result. A variable `v_return_score` of type `NUMBER` is declared to hold the final mapped score that will be returned by the function.\n\nThe core operation of the function involves executing a `SELECT` statement to calculate the sample covariance between two monetary columns from joined database tables. The calculation uses the `COVAR_SAMP` aggregate function. The first argument to `COVAR_SAMP` is `PAYMENTS.BASKET_VALUE_CENTS`. The second argument is `TRANSACTION_FEES.FEE_AMOUNT_CENTS`.\n\nThis calculation is performed on data retrieved from a join of three tables: `PAYMENTS`, `TRANSACTION_FEES`, and `PAYMENT_GATEWAY_INTEGRATIONS`. The `FROM` clause specifies these three tables. The join conditions are defined in the `WHERE` clause. It is implied that `PAYMENTS` and `TRANSACTION_FEES` are joined on a common key, such as a transaction or payment ID, though the specific join column is not provided in the description. Furthermore, the result is joined to the `PAYMENT_GATEWAY_INTEGRATIONS` table, likely via a gateway identifier present in the `PAYMENTS` or `TRANSACTION_FEES` table. An additional filter is applied in the `WHERE` clause: `PAYMENT_GATEWAY_INTEGRATIONS.IS_ACTIVE` must equal `1`, ensuring only data related to active payment gateways is included in the covariance calculation.\n\nThe result of the `COVAR_SAMP` calculation is selected directly into the local variable `v_covariance`.\n\nFollowing the covariance calculation, the function implements a conditional mapping logic to determine the return value, stored in `v_return_score`. This logic uses a series of `IF` / `ELSIF` / `ELSE` statements. First, it checks if `v_covariance` is `NULL`. If true, `v_return_score` is set to `0`. If `v_covariance` is not null, the function checks if it is greater than `5000`. If true, `v_return_score` is set to `100`. If not, it checks if `v_covariance` is greater than `1000`. If true, `v_return_score` is set to `50`. If none of the previous conditions are met (meaning `v_covariance` is a non-null number less than or equal to 1000), `v_return_score` is set to `10`.\n\nAfter the mapping logic completes, the function returns the value stored in `v_return_score` as its final output.",
    "original_summary": "Create a PL/SQL function named calculate_gateway_covar with no parameters that returns a NUMBER. It calculates the sample covariance between PAYMENTS.BASKET_VALUE_CENTS and TRANSACTION_FEES.FEE_AMOUNT_CENTS for active payment gateways (IS_ACTIVE = 1). Return 100 if covariance > 5000, 50 if covariance > 1000, 0 if covariance is NULL, or 10 otherwise.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the sample covariance between PAYMENTS.BASKET_VALUE_CENTS and TRANSACTION_FEES.FEE_AMOUNT_CENTS for active payment gateways, and how should it be mapped to a return value of 100, 50, 0, or 10?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_employee_full_name that accepts a single input parameter emp_id of the NUMBER data type and returns a value of the VARCHAR2 data type, which constructs and provides the full name of an employee; within the function's execution block, it declares a local variable v_full_name of VARCHAR2(510) to hold the result, then performs a SELECT query on the EMPLOYEES table to retrieve a specific employee record where the EMP_ID column value matches the provided emp_id parameter, and for that matching row, it concatenates the value from the FIRST_NAME column, a single space literal, and the value from the LAST_NAME column using the concatenation operator (||), storing this combined string into the v_full_name variable, and finally returns the content of the v_full_name variable as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_full_name(emp_id NUMBER) RETURN VARCHAR2 IS\n  v_full_name VARCHAR2(510);\nBEGIN\n  SELECT FIRST_NAME || ' ' || LAST_NAME INTO v_full_name FROM EMPLOYEES WHERE EMP_ID = emp_id;\n  RETURN v_full_name;\nEND;",
    "database_name": "human_rmae_tracking",
    "tables": [
      "EMPLOYEES",
      "SALARIES"
    ],
    "call_sqls": [
      "SELECT get_employee_full_name(1) FROM DUAL",
      "SELECT get_employee_full_name(2) FROM DUAL",
      "SELECT get_employee_full_name(3) FROM DUAL",
      "SELECT get_employee_full_name(4) FROM DUAL",
      "SELECT get_employee_full_name(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_employee_full_name that accepts an employee ID and returns the full name as a single string by retrieving and concatenating the FIRST_NAME and LAST_NAME from the EMPLOYEES table for the employee matching the given ID.",
    "natural_language": "Write a Oracle PL/SQL function named get_employee_full_name that takes an employee ID and returns the employee's full name by concatenating the FIRST_NAME and LAST_NAME from the EMPLOYEES table with a space in between.",
    "id": 5,
    "generated_ir": "Write an Oracle PL/SQL function named get_employee_full_name that accepts a single input parameter emp_id of the NUMBER data type and returns a value of the VARCHAR2 data type, which constructs and provides the full name of an employee; within the function's execution block, it declares a local variable v_full_name of VARCHAR2(510) to hold the result, then performs a SELECT query on the EMPLOYEES table to retrieve a specific employee record where the EMP_ID column value matches the provided emp_id parameter, and for that matching row, it concatenates the value from the FIRST_NAME column, a single space literal, and the value from the LAST_NAME column using the concatenation operator (||), storing this combined string into the v_full_name variable, and finally returns the content of the v_full_name variable as the function's output.",
    "original_summary": "Create a PL/SQL function named get_employee_full_name that accepts an employee ID (NUMBER). It returns a VARCHAR2 string by concatenating the FIRST_NAME, a space, and the LAST_NAME from the EMPLOYEES table for the matching employee.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a function get_employee_full_name that takes an employee ID and returns the employee's first and last name concatenated with a space from the EMPLOYEES table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_sales_revenue that accepts a single parameter p_product_id of type NUMBER, which represents the unique identifier of a product. The function is designed to calculate and return the total sales revenue for the specified product. Inside the function, a local variable total_revenue of type NUMBER is declared to store the result of the revenue calculation. The function performs a SELECT operation on the SALES table, specifically targeting the REVENUE column. It uses the SUM function to aggregate the revenue values, converting each REVENUE entry to a NUMBER type using the TO_NUMBER function to ensure numerical operations can be performed. The SELECT statement includes a WHERE clause that filters the rows based on the PRODUCT_ID column, matching it to the value of the input parameter p_product_id. The aggregated sum of the revenue is then stored in the total_revenue variable. Finally, the function returns the value of total_revenue, which represents the total sales revenue for the product identified by p_product_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_sales_revenue(p_product_id NUMBER) RETURN NUMBER IS\n  total_revenue NUMBER;\nBEGIN\n  SELECT SUM(TO_NUMBER(REVENUE))\n  INTO total_revenue\n  FROM SALES\n  WHERE PRODUCT_ID = p_product_id;\n  RETURN total_revenue;\nEND;",
    "database_name": "e_csaim_292568",
    "tables": [
      "PRODUCTS",
      "PRODUCT_TYPES",
      "SUPPLIERS",
      "INVENTORY",
      "LOW_STOCK_ALERTS",
      "REORDERS",
      "SALES",
      "REGIONS"
    ],
    "call_sqls": [
      "SELECT get_product_sales_revenue(0) FROM dual",
      "SELECT get_product_sales_revenue(1) FROM dual",
      "SELECT get_product_sales_revenue(10) FROM dual",
      "SELECT get_product_sales_revenue(100) FROM dual",
      "SELECT get_product_sales_revenue(999) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_product_sales_revenue that, given a product_id, calculates and returns the total revenue for that specific product from the SALES table by summing the REVENUE values.",
    "natural_language": "Write a Oracle PL/SQL function named get_product_sales_revenue that takes a product's ID as input and returns the total revenue for that specific product by summing the REVENUE column in the SALES table.",
    "id": 6,
    "generated_ir": "Write an Oracle PL/SQL function named get_product_sales_revenue that accepts a single parameter p_product_id of type NUMBER, which represents the unique identifier of a product. The function is designed to calculate and return the total sales revenue for the specified product. Inside the function, a local variable total_revenue of type NUMBER is declared to store the result of the revenue calculation. The function performs a SELECT operation on the SALES table, specifically targeting the REVENUE column. It uses the SUM function to aggregate the revenue values, converting each REVENUE entry to a NUMBER type using the TO_NUMBER function to ensure numerical operations can be performed. The SELECT statement includes a WHERE clause that filters the rows based on the PRODUCT_ID column, matching it to the value of the input parameter p_product_id. The aggregated sum of the revenue is then stored in the total_revenue variable. Finally, the function returns the value of total_revenue, which represents the total sales revenue for the product identified by p_product_id.",
    "original_summary": "Create a PL/SQL function named get_product_sales_revenue that returns a NUMBER. It accepts a product_id NUMBER parameter, calculates the total revenue for that product from the SALES table using SUM(TO_NUMBER(REVENUE)), and returns the result.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the total revenue for a specific product, calculated by summing the REVENUE column in the SALES table, and how can I retrieve it using a PL/SQL function that takes the product's ID as input?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named has_garage_capacity that accepts a single input parameter, p_property_id, of type NUMBER, which represents the unique identifier of a property. The function returns a value of type VARCHAR2. Within the function, declare a local variable v_garage_cars of type NUMBER to store the result of a query. Execute a SELECT statement that counts the number of rows in the PROPERTY_FEATURES table where the PROPERTY_ID column matches the input parameter p_property_id and the GARAGE_CARS column has a value greater than or equal to 2. Store the result of this count in the v_garage_cars variable. Following the query, evaluate the value of v_garage_cars using an IF statement. If v_garage_cars is greater than 0, return the string 'SUFFICIENT'. Otherwise, return the string 'INSUFFICIENT'.",
    "plsql": "CREATE OR REPLACE FUNCTION has_garage_capacity(p_property_id NUMBER) RETURN VARCHAR2 IS\n    v_garage_cars NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_garage_cars FROM PROPERTY_FEATURES pf WHERE pf.PROPERTY_ID = p_property_id AND pf.GARAGE_CARS >= 2;\n    IF v_garage_cars > 0 THEN\n        RETURN 'SUFFICIENT';\n    ELSE\n        RETURN 'INSUFFICIENT';\n    END IF;\nEND;",
    "database_name": "real_epaam_956249",
    "tables": [
      "AMENITIES",
      "BASEMENT_INFO",
      "BUILDING_DETAILS",
      "HEATING_INFO",
      "NEIGHBORHOODS",
      "PROPERTIES",
      "PROPERTY_FEATURES",
      "ROOMS_INFO",
      "SALE_HISTORY",
      "USER_ACCOUNTS"
    ],
    "call_sqls": [
      "SELECT has_garage_capacity(0) FROM dual",
      "SELECT has_garage_capacity(1) FROM dual",
      "SELECT has_garage_capacity(2) FROM dual",
      "SELECT has_garage_capacity(3) FROM dual",
      "SELECT has_garage_capacity(4) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named has_garage_capacity that accepts a property ID and returns 'SUFFICIENT' if the PROPERTY_FEATURES table has at least one record for that property where GARAGE_CARS is 2 or more, otherwise returns 'INSUFFICIENT'.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called has_garage_capacity? It should take a property's ID number and spit out 'SUFFICIENT' if the place has room for at least 2 cars in the garage by checking the PROPERTY_FEATURES table for that PROPERTY_ID. If not, just have it say 'INSUFFICIENT'.",
    "id": 7,
    "generated_ir": "Write an Oracle PL/SQL function named has_garage_capacity that accepts a single numeric input parameter p_property_id of type NUMBER, representing a specific property's identifier, and returns a single string value of type VARCHAR2. The function declares a local numeric variable v_garage_capacity to store the garage capacity value retrieved from the database. The function's logic executes a single SQL SELECT statement that queries the PROPERTY_FEATURES table. This SELECT statement retrieves the value from the garage_capacity column for the row where the PROPERTY_ID column matches the input parameter p_property_id. The retrieved value is assigned into the local variable v_garage_capacity using the INTO clause. The function then uses an IF-THEN-ELSE control structure to evaluate the retrieved value. If the value stored in v_garage_capacity is greater than or equal to 2, the function returns the string literal 'SUFFICIENT'. Otherwise, the function returns the string literal 'INSUFFICIENT'. If the SELECT statement finds no matching row for the given property ID, resulting in a NO_DATA_FOUND exception, the function handles this by also returning the string literal 'INSUFFICIENT'.",
    "original_summary": "Create a PL/SQL function named has_garage_capacity that accepts a property ID number and returns 'SUFFICIENT' if the property has at least 2 garage spaces, otherwise returns 'INSUFFICIENT'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called has_garage_capacity? It should take a property's ID number and spit out 'SUFFICIENT' if the place has room for at least 2 cars in the garage. If not, just have it say 'INSUFFICIENT'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_active_size_chart_count that returns a numeric value representing the count of active size charts. The function does not take any input parameters. It declares a local variable v_count of type NUMBER to store the result of the count operation. Within the function body, a SELECT statement is executed to count all rows in the SIZE_CHARTS table where the IS_ACTIVE column has a value of 1, indicating that the size chart is active. The result of this count operation is stored in the v_count variable using the INTO clause. Finally, the function returns the value stored in v_count, which represents the total number of active size charts in the SIZE_CHARTS table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_active_size_chart_count RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM SIZE_CHARTS WHERE IS_ACTIVE = 1;\n    RETURN v_count;\nEND;",
    "database_name": "fashion_scam_standards",
    "tables": [
      "MEASUREMENTS",
      "MEASUREMENT_GUIDELINES",
      "PRODUCT_LINES",
      "SIZE_CHARTS",
      "SIZE_ISSUES",
      "REGIONS"
    ],
    "call_sqls": [
      "SELECT get_active_size_chart_count FROM DUAL",
      "SELECT get_active_size_chart_count() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_active_size_chart_count;\n  DBMS_OUTPUT.PUT_LINE('Active size charts: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Active size charts count: ' || get_active_size_chart_count);\nEND;",
      "SELECT get_active_size_chart_count AS active_charts FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_active_size_chart_count that returns the total number of active size charts by counting all rows in the SIZE_CHARTS table where the IS_ACTIVE column is set to 1.",
    "natural_language": "Write a Oracle PL/SQL function named get_active_size_chart_count that returns the total number of active records from the SIZE_CHARTS table, where the IS_ACTIVE column is set to 1.",
    "id": 8,
    "generated_ir": "Write an Oracle PL/SQL function named get_active_size_chart_count that returns a numeric value representing the count of active size charts. The function does not take any input parameters. It declares a local variable v_count of type NUMBER to store the result of the count operation. Within the function body, a SELECT statement is executed to count all rows in the SIZE_CHARTS table where the IS_ACTIVE column has a value of 1, indicating that the size chart is active. The result of this count operation is stored in the v_count variable using the INTO clause. Finally, the function returns the value stored in v_count, which represents the total number of active size charts in the SIZE_CHARTS table.",
    "original_summary": "Create a PL/SQL function named `get_active_size_chart_count` with no parameters that returns a `NUMBER`. It counts and returns the number of rows in the `SIZE_CHARTS` table where the `IS_ACTIVE` column equals 1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function, which should be named `get_active_size_chart_count`, that accepts no parameters and is designed to return a value of the `NUMBER` data type. This function's purpose is to meticulously calculate and subsequently provide the total count of records existing within the `SIZE_CHARTS` table, specifically targeting those rows where the `IS_ACTIVE` column is explicitly set to the value of 1, indicating an active status."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_match_end_time` that accepts one input parameter: `match_id_in`, which is of data type `NUMBER`. This function is designed to return a `VARCHAR2` value representing the calculated end time of a match. Internally, the function declares two local variables: `start_time_str` and `end_time_str`, both of data type `VARCHAR2` with a maximum length of 255 characters, to temporarily store time-related strings. The function begins by executing a `SELECT` statement to retrieve the `EVENT_TIME` column from the `MATCHES` table. This retrieval is conditional, specifically targeting the row where the `MATCH_ID` column matches the value provided by the `match_id_in` input parameter. The retrieved `EVENT_TIME` value is then stored into the `start_time_str` local variable. Following this data retrieval, the function proceeds with a conditional check: it evaluates whether the `start_time_str` variable is `NOT NULL`. If `start_time_str` contains a value (i.e., it's not null), the function performs a series of operations to calculate the end time. It first converts the `start_time_str` (which is a `VARCHAR2`) into a `TIMESTAMP` data type using the `TO_TIMESTAMP` function, specifying the format mask 'YYYY-MM-DD HH24:MI:SS.FF'. To this `TIMESTAMP` value, it adds a duration of 3 hours using the `NUMTODSINTERVAL` function, where '3' is the numeric value and 'HOUR' specifies the unit. The resulting `TIMESTAMP` (which represents the end time) is then converted back into a `VARCHAR2` string using the `TO_CHAR` function, applying the format mask 'YYYY-MM-DD HH24:MI:SS'. This formatted string is assigned to the `end_time_str` local variable. Finally, the function returns the value stored in `end_time_str`. If, however, the initial conditional check determines that `start_time_str` IS `NULL` (meaning no `EVENT_TIME` was found for the given `match_id_in`), the function immediately returns the literal string 'Invalid start time'.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_match_end_time(match_id_in NUMBER) RETURN VARCHAR2 IS\n  start_time_str VARCHAR2(255);\n  end_time_str VARCHAR2(255);\nBEGIN\n  SELECT EVENT_TIME INTO start_time_str FROM MATCHES WHERE MATCH_ID = match_id_in;\n  IF start_time_str IS NOT NULL THEN\n    end_time_str := TO_CHAR(TO_TIMESTAMP(start_time_str, 'YYYY-MM-DD HH24:MI:SS.FF') + NUMTODSINTERVAL(3, 'HOUR'), 'YYYY-MM-DD HH24:MI:SS');\n    RETURN end_time_str;\n  ELSE\n    RETURN 'Invalid start time';\n  END IF;\nEND;",
    "database_name": "tennis_msa_analytics",
    "tables": [
      "MATCHES"
    ],
    "call_sqls": [
      "SELECT calculate_match_end_time(0) FROM DUAL",
      "SELECT calculate_match_end_time(1) FROM DUAL",
      "SELECT calculate_match_end_time(999) FROM DUAL",
      "SELECT calculate_match_end_time(NULL) FROM DUAL",
      "SELECT calculate_match_end_time(2) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_match_end_time that accepts a match_id_in parameter to identify a match and returns a formatted end time as a string. For the given match ID, retrieve the EVENT_TIME from the MATCHES table; if EVENT_TIME is not null, add 3 hours to it and return the result in the format 'YYYY-MM-DD HH24:MI:SS', but if EVENT_TIME is null, return 'Invalid start time'.",
    "natural_language": "Write a Oracle PL/SQL function named calculate_match_end_time that, given a specific match ID, determines the end time for a match by taking its event start time from the MATCHES table, adding three hours to it, and formatting the result as 'YYYY-MM-DD HH24:MI:SS', returning this formatted end time or 'Invalid start time' if the start time is not found.",
    "id": 9,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_match_end_time that takes a single input parameter p_match_id of type NUMBER and returns a VARCHAR2 string. The function first declares a local variable v_start_time of type DATE to hold the event start time retrieved from the database, and a local variable v_end_time of type VARCHAR2(50) to store the final formatted result. The function's execution logic begins by performing a SELECT operation on the MATCHES table, specifically retrieving the event_start_time column for the row where the match_id column exactly matches the input parameter p_match_id, and storing this value into the v_start_time variable. The function then uses an IF-THEN-ELSE conditional block to evaluate the result of this query. If the v_start_time variable is NULL, indicating no matching row was found in the MATCHES table for the given match_id, the function returns the literal string 'Invalid start time'. If v_start_time is not NULL, the function calculates the end time by adding 3 hours to the v_start_time value using date arithmetic. It then formats this calculated date-time value into a string with the pattern 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function, storing the result in the v_end_time variable. Finally, the function returns the value stored in v_end_time, which represents the formatted end time for the specified match.",
    "original_summary": "Create a PL/SQL function named calculate_match_end_time that accepts a match_id_in NUMBER parameter and returns a VARCHAR2. Retrieve the EVENT_TIME from the MATCHES table for the given ID. If the time is not null, convert it to a TIMESTAMP, add 3 hours, and return the result formatted as 'YYYY-MM-DD HH24:MI:SS'. If the time is null, return 'Invalid start time'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the end time for a match, calculated by taking its event start time, adding three hours, and formatting the result, given a specific match ID?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_loyalty_points that accepts two input parameters: a numeric parameter named p_customer_id and a numeric parameter named p_loyalty_program_id, and returns a single numeric value. The function declares a local numeric variable named v_points_balance. The function's logic executes a SELECT statement that retrieves data from the customer_loyalty table, specifically the value from the points_balance column. The SELECT statement uses a WHERE clause with two conditions joined by an AND operator to filter the results: the first condition checks that the customer_id column in the table matches the input parameter p_customer_id, and the second condition checks that the loyalty_program_id column in the table matches the input parameter p_loyalty_program_id. The value retrieved by the SELECT statement is stored into the local variable v_points_balance. The function then concludes by using a RETURN statement to output the value stored in the v_points_balance variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_loyalty_points(p_customer_id NUMBER, p_loyalty_program_id NUMBER) RETURN NUMBER IS\n    v_points_balance NUMBER;\nBEGIN\n    SELECT points_balance INTO v_points_balance\n    FROM customer_loyalty\n    WHERE customer_id = p_customer_id AND loyalty_program_id = p_loyalty_program_id;\n    RETURN v_points_balance;\nEND;",
    "database_name": "e_csaim_480445",
    "tables": [
      "INVOICES",
      "INVOICE_ITEMS",
      "PRODUCTS",
      "CUSTOMER_LOYALTY",
      "LOYALTY_PROGRAMS",
      "ORDERS"
    ],
    "call_sqls": [
      "SELECT get_customer_loyalty_points(101, 1) FROM DUAL",
      "SELECT get_customer_loyalty_points(102, 2) FROM DUAL",
      "SELECT get_customer_loyalty_points(103, 1) FROM DUAL",
      "SELECT get_customer_loyalty_points(104, 3) FROM DUAL",
      "SELECT get_customer_loyalty_points(105, 2) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_customer_loyalty_points that, given a customer_id and a loyalty_program_id, retrieves and returns the points_balance from the CUSTOMER_LOYALTY table for that specific customer and loyalty program.",
    "natural_language": "Write a Oracle PL/SQL function named get_customer_loyalty_points that returns the points_balance from the customer_loyalty table for a specified customer_id and loyalty_program_id.",
    "id": 10,
    "generated_ir": "Write an Oracle PL/SQL function named get_customer_loyalty_points that accepts two input parameters: a numeric parameter named p_customer_id and a numeric parameter named p_loyalty_program_id, and returns a single numeric value. The function declares a local numeric variable named v_points_balance. The function's logic executes a SELECT statement that retrieves data from the customer_loyalty table, specifically the value from the points_balance column. The SELECT statement uses a WHERE clause with two conditions joined by an AND operator to filter the results: the first condition checks that the customer_id column in the table matches the input parameter p_customer_id, and the second condition checks that the loyalty_program_id column in the table matches the input parameter p_loyalty_program_id. The value retrieved by the SELECT statement is stored into the local variable v_points_balance. The function then concludes by using a RETURN statement to output the value stored in the v_points_balance variable.",
    "original_summary": "Create a function named get_customer_loyalty_points that accepts a customer_id and a loyalty_program_id (both numbers) and returns the points_balance (a number) from the customer_loyalty table for that specific customer and program.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the points_balance for a given customer_id and loyalty_program_id in the customer_loyalty table?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_climate_model_prediction` that accepts a single input parameter, `p_year`, which is of data type `NUMBER`. The function is designed to return a `VARCHAR2` string with a maximum length of 255 characters. Upon execution, the function declares a local variable named `v_prediction` of data type `VARCHAR2` with a maximum length of 255 characters. The core operation of the function involves performing a `SELECT` statement to retrieve data from the `CLIMATE_MODELS` table. Specifically, it concatenates a literal string 'Temperature Change: ' with the character representation of the value from the `PREDICTED_TEMPERATURE_CHANGE` column, which is explicitly converted to a character string using the `TO_CHAR` function. This result is then further concatenated with another literal string ', Sea Level Rise: ' and the character representation of the value from the `PREDICTED_SEA_LEVEL_RISE` column, also converted using the `TO_CHAR` function. The combined concatenated string is then assigned to the local variable `v_prediction`. This `SELECT` operation is filtered by a `WHERE` clause, ensuring that only rows where the value in the `YEAR` column of the `CLIMATE_MODELS` table is equal to the value provided in the input parameter `p_year` are considered. Finally, the function returns the value stored in the `v_prediction` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_climate_model_prediction(p_year NUMBER) RETURN VARCHAR2 IS\n    v_prediction VARCHAR2(255);\nBEGIN\n    SELECT 'Temperature Change: ' || TO_CHAR(PREDICTED_TEMPERATURE_CHANGE) || ', Sea Level Rise: ' || TO_CHAR(PREDICTED_SEA_LEVEL_RISE)\n    INTO v_prediction\n    FROM CLIMATE_MODELS\n    WHERE YEAR = p_year;\n    RETURN v_prediction;\nEND;",
    "database_name": "climate_ciaae_tracking",
    "tables": [
      "CLIMATE_MODELS",
      "EMISSIONS_DATA",
      "EMISSIONS_DATA_SOURCES",
      "EMISSIONS_DATA_USER_ACCESS",
      "EMISSIONS_METRICS",
      "USERS"
    ],
    "call_sqls": [
      "SELECT get_climate_model_prediction(0) FROM DUAL",
      "SELECT get_climate_model_prediction(1) FROM DUAL",
      "SELECT get_climate_model_prediction(10) FROM DUAL",
      "SELECT get_climate_model_prediction(20) FROM DUAL",
      "SELECT get_climate_model_prediction(100) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named `get_climate_model_prediction` that, for a given year, retrieves the corresponding record from the CLIMATE_MODELS table and returns a formatted string combining the PREDICTED_TEMPERATURE_CHANGE and PREDICTED_SEA_LEVEL_RISE values in the pattern 'Temperature Change: [value], Sea Level Rise: [value]'.",
    "natural_language": "Write a Oracle PL/SQL function called `get_climate_model_prediction` that takes a year as input and returns a formatted string. The function should retrieve the PREDICTED_TEMPERATURE_CHANGE and PREDICTED_SEA_LEVEL_RISE from the CLIMATE_MODELS table for the given year and output a string in the format 'Temperature Change: [value], Sea Level Rise: [value]'.",
    "id": 11,
    "generated_ir": "Write an Oracle PL/SQL function named `get_climate_model_prediction` that accepts a single input parameter, `p_year`, which is of data type `NUMBER`. The function is designed to return a `VARCHAR2` string with a maximum length of 255 characters. Upon execution, the function declares a local variable named `v_prediction` of data type `VARCHAR2` with a maximum length of 255 characters. The core operation of the function involves performing a `SELECT` statement to retrieve data from the `CLIMATE_MODELS` table. Specifically, it concatenates a literal string 'Temperature Change: ' with the character representation of the value from the `PREDICTED_TEMPERATURE_CHANGE` column, which is explicitly converted to a character string using the `TO_CHAR` function. This result is then further concatenated with another literal string ', Sea Level Rise: ' and the character representation of the value from the `PREDICTED_SEA_LEVEL_RISE` column, also converted using the `TO_CHAR` function. The combined concatenated string is then assigned to the local variable `v_prediction`. This `SELECT` operation is filtered by a `WHERE` clause, ensuring that only rows where the value in the `YEAR` column of the `CLIMATE_MODELS` table is equal to the value provided in the input parameter `p_year` are considered. Finally, the function returns the value stored in the `v_prediction` variable as its output.",
    "original_summary": "Create a PL/SQL function named `get_climate_model_prediction` that takes a year number as input and returns a VARCHAR2(255). It should query the CLIMATE_MODELS table for the given year and return a concatenated string in the format 'Temperature Change: [value], Sea Level Rise: [value]' using the PREDICTED_TEMPERATURE_CHANGE and PREDICTED_SEA_LEVEL_RISE columns.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called `get_climate_model_prediction` that accepts a year number and outputs a VARCHAR2(255). The function must fetch data from the CLIMATE_MODELS table for the specified year and output a string formatted as 'Temperature Change: [value], Sea Level Rise: [value]' by combining the PREDICTED_TEMPERATURE_CHANGE and PREDICTED_SEA_LEVEL_RISE columns."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_order_total_amount that accepts a single parameter, p_order_id, of type NUMBER, which represents the unique identifier of an order. The function is designed to calculate and return the total monetary amount for the specified order. Inside the function, a local variable v_total_amount of type NUMBER is declared to store the computed total amount. The function performs a SELECT operation on the ORDER_ITEMS table, specifically targeting the FINAL_PRICE column. It uses the SUM function to aggregate the values in the FINAL_PRICE column, converting each value to a NUMBER type using the TO_NUMBER function to ensure numerical operations can be performed. The aggregation is conditioned by the WHERE clause, which filters the rows based on the ORDER_ID column, ensuring that only items belonging to the order specified by the p_order_id parameter are considered. The result of the SUM operation is stored into the v_total_amount variable using the INTO clause. Finally, the function returns the value stored in v_total_amount, which represents the total amount for the order identified by p_order_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_order_total_amount(p_order_id NUMBER) RETURN NUMBER IS\n    v_total_amount NUMBER;\nBEGIN\n    SELECT SUM(TO_NUMBER(FINAL_PRICE)) INTO v_total_amount FROM ORDER_ITEMS WHERE ORDER_ID = p_order_id;\n    RETURN v_total_amount;\nEND;",
    "database_name": "e_coms_348496",
    "tables": [
      "CUSTOMERS",
      "ADDRESSES",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "ORDER_STATUS"
    ],
    "call_sqls": [
      "SELECT get_order_total_amount(0) FROM dual",
      "SELECT get_order_total_amount(1) FROM dual",
      "SELECT get_order_total_amount(2) FROM dual",
      "SELECT get_order_total_amount(3) FROM dual",
      "SELECT get_order_total_amount(4) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_order_total_amount that, given an order ID as input, calculates and returns the total sum of the FINAL_PRICE for all items associated with that order from the ORDER_ITEMS table.",
    "natural_language": "Write a Oracle PL/SQL function called `get_order_total_amount` that calculates and returns the total sum of the `FINAL_PRICE` column from the `ORDER_ITEMS` table for a specific order, using the input parameter `p_order_id` to identify the order.",
    "id": 12,
    "generated_ir": "Write an Oracle PL/SQL function named get_order_total_amount that accepts a single parameter, p_order_id, of type NUMBER, which represents the unique identifier of an order. The function is designed to calculate and return the total monetary amount for the specified order. Inside the function, a local variable v_total_amount of type NUMBER is declared to store the computed total amount. The function performs a SELECT operation on the ORDER_ITEMS table, specifically targeting the FINAL_PRICE column. It uses the SUM function to aggregate the values in the FINAL_PRICE column, converting each value to a NUMBER type using the TO_NUMBER function to ensure numerical operations can be performed. The aggregation is conditioned by the WHERE clause, which filters the rows based on the ORDER_ID column, ensuring that only items belonging to the order specified by the p_order_id parameter are considered. The result of the SUM operation is stored into the v_total_amount variable using the INTO clause. Finally, the function returns the value stored in v_total_amount, which represents the total amount for the order identified by p_order_id.",
    "original_summary": "Create a PL/SQL function named `get_order_total_amount` that calculates and returns the total sum of `FINAL_PRICE` (as a NUMBER) for all items in a specified `p_order_id` from the `ORDER_ITEMS` table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function called `get_order_total_amount` that meticulously computes and then provides as its output the comprehensive numerical sum, specifically the total of the `FINAL_PRICE` column, which must be returned as a NUMBER data type, for every single item entry associated with a particular order identifier, supplied via the parameter `p_order_id`, by querying the records stored within the `ORDER_ITEMS` table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_correction_details that accepts a single input parameter correction_id of type NUMBER, which represents the unique identifier for a correction record. The function returns a VARCHAR2 string containing details about the correction. Within the function, a local variable correction_info of type VARCHAR2 with a maximum length of 255 characters is declared to store the result of the query. The function executes a SELECT statement that retrieves concatenated information from two tables: DATA_CORRECTIONS and USERS. Specifically, it selects the USER_NAME from the USERS table and the CORRECTION_REASON from the DATA_CORRECTIONS table, concatenating them into a string formatted as 'Correction by: [USER_NAME], Reason: [CORRECTION_REASON]'. The USERS table is joined to the DATA_CORRECTIONS table using the condition DC.CORRECTED_BY = U.USER_ID, which links the USER_ID column in the USERS table to the CORRECTED_BY column in the DATA_CORRECTIONS table. The WHERE clause of the SELECT statement filters the DATA_CORRECTIONS table to find the row where the CORRECTION_ID column matches the input parameter correction_id. If the SELECT statement successfully retrieves a single row, the concatenated string is stored in the correction_info variable and returned as the function's result. The function includes exception handling for two specific scenarios: if no data is found that matches the correction_id, the NO_DATA_FOUND exception is triggered, and the function returns the string 'No correction found for ID: ' followed by the correction_id; if more than one row is found, the TOO_MANY_ROWS exception is triggered, and the function returns the string 'Multiple corrections found for ID: ' followed by the correction_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_correction_details(correction_id IN NUMBER) RETURN VARCHAR2 IS\n  correction_info VARCHAR2(255);\nBEGIN\n  SELECT 'Correction by: ' || U.USER_NAME || ', Reason: ' || DC.CORRECTION_REASON\n  INTO correction_info\n  FROM DATA_CORRECTIONS DC\n  JOIN USERS U ON DC.CORRECTED_BY = U.USER_ID\n  WHERE DC.CORRECTION_ID = correction_id;\n  \n  RETURN correction_info;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN 'No correction found for ID: ' || correction_id;\n  WHEN TOO_MANY_ROWS THEN\n    RETURN 'Multiple corrections found for ID: ' || correction_id;\nEND;",
    "database_name": "covid_1dtaa_576932",
    "tables": [
      "DAILY_REPORTS",
      "DATA_CORRECTIONS",
      "DATA_QUALITY",
      "USERS"
    ],
    "call_sqls": [
      "SELECT get_correction_details(0) FROM DUAL",
      "SELECT get_correction_details(1) FROM DUAL",
      "SELECT get_correction_details(999) FROM DUAL",
      "SELECT get_correction_details( (SELECT CORRECTION_ID FROM DATA_CORRECTIONS WHERE CORRECTION_REASON = 'Data entry error' AND ROWNUM = 1) ) FROM DUAL",
      "SELECT get_correction_details( (SELECT CORRECTION_ID FROM DATA_CORRECTIONS WHERE CORRECTED_BY = (SELECT USER_ID FROM USERS WHERE USER_NAME = 'Bob Williams') AND ROWNUM = 1) ) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_correction_details that accepts a correction_id and returns a formatted string. The function should retrieve the corrector's name from the USERS table and the correction reason from the DATA_CORRECTIONS table for the given correction_id, combining them into a single descriptive string. If no matching correction is found, return a message indicating no correction was found for that ID. If multiple corrections are found for the ID, return a message indicating multiple corrections exist for that ID.",
    "natural_language": "Write a Oracle PL/SQL function called get_correction_details that takes a correction_id and returns a string. It should retrieve the corrector's name from the USERS table and the reason from the DATA_CORRECTIONS table, combining them into a formatted message. If no matching correction exists for the given ID, return 'No correction found for ID: [id]'. If multiple corrections are found for the same ID, return 'Multiple corrections found for ID: [id]'.",
    "id": 13,
    "generated_ir": "Write an Oracle PL/SQL function named get_correction_details that accepts a single input parameter correction_id of type NUMBER, which represents the unique identifier for a correction record. The function returns a VARCHAR2 string containing details about the correction. Within the function, a local variable correction_info of type VARCHAR2 with a maximum length of 255 characters is declared to store the result of the query. The function executes a SELECT statement that retrieves concatenated information from two tables: DATA_CORRECTIONS and USERS. Specifically, it selects the USER_NAME from the USERS table and the CORRECTION_REASON from the DATA_CORRECTIONS table, concatenating them into a string formatted as 'Correction by: [USER_NAME], Reason: [CORRECTION_REASON]'. The USERS table is joined to the DATA_CORRECTIONS table using the condition DC.CORRECTED_BY = U.USER_ID, which links the USER_ID column in the USERS table to the CORRECTED_BY column in the DATA_CORRECTIONS table. The WHERE clause of the SELECT statement filters the DATA_CORRECTIONS table to find the row where the CORRECTION_ID column matches the input parameter correction_id. If the SELECT statement successfully retrieves a single row, the concatenated string is stored in the correction_info variable and returned as the function's result. The function includes exception handling for two specific scenarios: if no data is found that matches the correction_id, the NO_DATA_FOUND exception is triggered, and the function returns the string 'No correction found for ID: ' followed by the correction_id; if more than one row is found, the TOO_MANY_ROWS exception is triggered, and the function returns the string 'Multiple corrections found for ID: ' followed by the correction_id.",
    "original_summary": "Create a PL/SQL function named get_correction_details that accepts a correction_id NUMBER and returns a VARCHAR2. It should return a formatted string with the corrector's name and the correction reason by joining DATA_CORRECTIONS and USERS. Handle NO_DATA_FOUND by returning 'No correction found for ID: [id]' and TOO_MANY_ROWS by returning 'Multiple corrections found for ID: [id]'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called get_correction_details that takes a correction_id NUMBER and gives back a VARCHAR2. It should fetch and combine info from the DATA_CORRECTIONS and USERS tables to return a string with the corrector's name and the reason for the correction, kind of formatted together. If nothing comes up for that ID, just say 'No correction found for ID: [id]'. If, for some reason, there are a bunch of entries for the same ID, then return 'Multiple corrections found for ID: [id]'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_region_corruption_score that accepts two input parameters: a string parameter named p_region of type VARCHAR2, which specifies a geographical region, and a numeric parameter named p_year of type NUMBER, which specifies a calendar year, and returns a single numeric value of type NUMBER. The function declares a local variable v_score of type NUMBER to hold the computed result. The function's logic executes a single SQL SELECT statement that performs a SUM aggregation. The query retrieves data by performing an inner join between the COUNTRIES table, aliased as 'co', and the CORRUPTION_METRICS table, aliased as 'c', using the condition that the COUNTRY_ID column from the COUNTRIES table matches the COUNTRY_ID column from the CORRUPTION_METRICS table and that the YEAR column in the CORRUPTION_METRICS table equals the input parameter p_year. The query filters the joined result set with a WHERE clause that requires the REGION column in the COUNTRIES table to be equal to the input parameter p_region. Within the SUM aggregation, the NVL function is applied to the PERCEPTIONS_OF_CORRUPTION column from the CORRUPTION_METRICS table; this function converts any NULL values found in PERCEPTIONS_OF_CORRUPTION to the numeric value 0 before the summation, ensuring that NULLs do not affect the total sum. The result of this SUM aggregation is selected INTO the local variable v_score. Finally, the function returns the value stored in v_score, which represents the total sum of non-null corruption perception scores for all countries within the specified region and year.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_region_corruption_score(p_region VARCHAR2, p_year NUMBER) RETURN NUMBER IS\n    v_score NUMBER;\nBEGIN\n    SELECT SUM(NVL(c.PERCEPTIONS_OF_CORRUPTION, 0))\n    INTO v_score\n    FROM COUNTRIES co\n    JOIN CORRUPTION_METRICS c ON co.COUNTRY_ID = c.COUNTRY_ID AND c.YEAR = p_year\n    WHERE co.REGION = p_region;\n    RETURN v_score;\nEND;",
    "database_name": "global_hawbm_600971",
    "tables": [
      "COUNTRIES",
      "CORRUPTION_METRICS",
      "FREEDOM_METRICS",
      "GDP_METRICS",
      "GENEROSITY_METRICS",
      "HEALTH_EXPECTANCY_METRICS",
      "SOCIAL_SUPPORT_METRICS"
    ],
    "call_sqls": [
      "SELECT calculate_region_corruption_score('Europe', 2023) FROM DUAL",
      "SELECT calculate_region_corruption_score('Asia', 2022) FROM DUAL",
      "SELECT calculate_region_corruption_score('North America', 2021) FROM DUAL",
      "SELECT calculate_region_corruption_score('Africa', 2023) FROM DUAL",
      "SELECT calculate_region_corruption_score('South America', 2020) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_region_corruption_score that returns the total corruption perception score for a given region and year. It takes a region and a year as inputs, retrieves all countries from the COUNTRIES table in that region, joins with the CORRUPTION_METRICS table for the specified year, sums the PERCEPTIONS_OF_CORRUPTION values (treating any NULL values as zero), and returns the total sum.",
    "natural_language": "Write a Oracle PL/SQL function called calculate_region_corruption_score that takes a region and a year and returns a number. It should compute the total corruption perception score for the specified region and year by summing the PERCEPTIONS_OF_CORRUPTION values (treating any NULL as 0) from the CORRUPTION_METRICS table for all countries in that region, using the COUNTRIES table to identify which countries belong to the region.",
    "id": 14,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_region_corruption_score that accepts two parameters: p_region of type VARCHAR2 and p_year of type NUMBER. The function returns a NUMBER representing the total corruption perception score for the specified region and year. The function begins by declaring a local variable v_total_score of type NUMBER, initialized to 0, to store the computed sum. The function then executes a SELECT statement that performs a sum operation with a COALESCE function to treat NULL values as 0. The query selects the sum of COALESCE(cm.PERCEPTIONS_OF_CORRUPTION, 0) from the CORRUPTION_METRICS table, aliased as cm. It joins this table with the COUNTRIES table, aliased as c, on the condition that cm.COUNTRY_ID equals c.COUNTRY_ID. The WHERE clause filters the results to include only rows where c.REGION matches the p_region parameter and cm.YEAR matches the p_year parameter. The result of this aggregation is stored into the v_total_score variable. If no rows match the criteria, the sum will be NULL, so the function includes an exception handling section to catch the NO_DATA_FOUND exception and set v_total_score to 0. Finally, the function returns the value of v_total_score, which represents the total corruption perception score for the given region and year.",
    "original_summary": "Create a PL/SQL function named calculate_region_corruption_score that returns a NUMBER. It accepts a region (VARCHAR2) and a year (NUMBER). It returns the SUM of PERCEPTIONS_OF_CORRUPTION (treating NULL as 0) for all countries in the specified region and year, by joining the COUNTRIES and CORRUPTION_METRICS tables.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called calculate_region_corruption_score that takes a region (VARCHAR2) and a year (NUMBER) and returns a NUMBER. It should compute the SUM of PERCEPTIONS_OF_CORRUPTION (treating NULL as 0) for all countries in the given region and year by joining the COUNTRIES and CORRUPTION_METRICS tables."
  },
  {
    "ir": "Write an Oracle PL/SQL function named classify_director_productivity that accepts a single parameter p_director_id of type NUMBER, which represents the unique identifier of a director. The function is designed to classify the productivity level of a director based on their work on episodes and shows. It begins by declaring three local variables: v_episode_count and v_show_count of type NUMBER, and v_classification of type VARCHAR2 with a maximum length of 50 characters. The function executes a SELECT statement to retrieve the count of episodes and distinct shows directed by the specified director, using the EPISODES table where the DIRECTOR_ID column matches the provided p_director_id. The results are stored into v_episode_count and v_show_count respectively. The function then evaluates the director's productivity using a series of conditional statements. If the director has directed more than 30 episodes and more than 3 distinct shows, v_classification is set to 'HIGHLY PRODUCTIVE'. If the director has directed more than 15 episodes and more than 2 distinct shows, v_classification is set to 'MODERATELY PRODUCTIVE'. If the director has directed more than 5 episodes and more than 1 distinct show, v_classification is set to 'AVERAGE PRODUCTIVITY'. Otherwise, v_classification is set to 'LOW PRODUCTIVITY'. Finally, the function returns the value of v_classification, indicating the productivity classification of the director based on the specified criteria.",
    "plsql": "CREATE OR REPLACE FUNCTION classify_director_productivity(p_director_id NUMBER) RETURN VARCHAR2 IS\n    v_episode_count NUMBER;\n    v_show_count NUMBER;\n    v_classification VARCHAR2(50);\nBEGIN\n    SELECT COUNT(EPISODE_ID), COUNT(DISTINCT SHOW_ID) INTO v_episode_count, v_show_count FROM EPISODES WHERE DIRECTOR_ID = p_director_id;\n    \n    IF v_episode_count > 30 AND v_show_count > 3 THEN\n        v_classification := 'HIGHLY PRODUCTIVE';\n    ELSIF v_episode_count > 15 AND v_show_count > 2 THEN\n        v_classification := 'MODERATELY PRODUCTIVE';\n    ELSIF v_episode_count > 5 AND v_show_count > 1 THEN\n        v_classification := 'AVERAGE PRODUCTIVITY';\n    ELSE\n        v_classification := 'LOW PRODUCTIVITY';\n    END IF;\n    \n    RETURN v_classification;\nEND;",
    "database_name": "television_spav_analytics",
    "tables": [
      "SHOWS",
      "EPISODES",
      "SEASONS",
      "CAST",
      "DIRECTORS",
      "WRITERS",
      "EPISODE_DIRECTORS",
      "EPISODE_WRITERS"
    ],
    "call_sqls": [
      "SELECT classify_director_productivity(1) FROM DUAL",
      "SELECT classify_director_productivity(2) FROM DUAL",
      "SELECT classify_director_productivity(3) FROM DUAL",
      "SELECT classify_director_productivity(4) FROM DUAL",
      "SELECT classify_director_productivity(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named classify_director_productivity that, for a given director_id, returns a productivity classification by counting the total number of episodes and the number of distinct shows from the EPISODES table where the DIRECTOR_ID matches the input, and classifies as 'HIGHLY PRODUCTIVE' if there are more than 30 episodes and more than 3 shows, 'MODERATELY PRODUCTIVE' if more than 15 episodes and more than 2 shows, 'AVERAGE PRODUCTIVITY' if more than 5 episodes and more than 1 show, otherwise 'LOW PRODUCTIVITY'.",
    "natural_language": "Write a Oracle PL/SQL function named classify_director_productivity that, for a given director ID, determines their productivity classification based on the number of episodes they have directed from the EPISODES table and the number of distinct shows they have directed. The classification should be set to 'HIGHLY PRODUCTIVE' if the episode count exceeds 30 and the distinct show count exceeds 3, 'MODERATELY PRODUCTIVE' if the episode count exceeds 15 and the distinct show count exceeds 2, 'AVERAGE PRODUCTIVITY' if the episode count exceeds 5 and the distinct show count exceeds 1, and 'LOW PRODUCTIVITY' otherwise, then return this classification.",
    "id": 15,
    "generated_ir": "Write an Oracle PL/SQL function named classify_director_productivity that accepts a single numeric input parameter, presumably representing a director ID. The function returns a VARCHAR2 classification string. Within the function, declare three local variables: v_episode_count of type NUMBER to store the total number of episodes directed, v_show_count of type NUMBER to store the count of distinct shows directed, and v_classification of type VARCHAR2 (with a sufficient length, e.g., 50) to hold the final productivity classification.\n\nThe function begins by executing a SELECT statement to calculate the total number of episodes directed by the specified director. This query counts all rows in the EPISODES table where the director_id column matches the input parameter, storing the result into v_episode_count. Next, the function executes another SELECT statement to calculate the number of distinct shows directed by the same director. This query counts the distinct values in the show_id column (or a similar column representing the show) from the EPISODES table where the director_id matches the input parameter, storing the result into v_show_count.\n\nFollowing these calculations, the function uses a series of conditional IF-ELSIF-ELSE logic to determine the productivity classification based on the values in v_episode_count and v_show_count. First, it checks if v_episode_count is greater than 30 AND v_show_count is greater than 3; if true, it assigns the string 'HIGHLY PRODUCTIVE' to v_classification. If not, it proceeds to check if v_episode_count is greater than 15 AND v_show_count is greater than 2; if true, it assigns 'MODERATELY PRODUCTIVE' to v_classification. If not, it checks if v_episode_count is greater than 5 AND v_show_count is greater than 1; if true, it assigns 'AVERAGE PRODUCTIVITY' to v_classification. If none of the above conditions are met, it assigns 'LOW PRODUCTIVITY' to v_classification. Finally, the function returns the value stored in v_classification.",
    "original_summary": "Create a function named classify_director_productivity that returns a productivity classification for a given director_id. It counts the episodes and distinct shows directed. Classification is 'HIGHLY PRODUCTIVE' if >30 episodes and >3 shows; 'MODERATELY PRODUCTIVE' if >15 and >2; 'AVERAGE PRODUCTIVITY' if >5 and >1; else 'LOW PRODUCTIVITY'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the productivity classification for a given director, based on the number of episodes and distinct shows they have directed?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_report_type_count that accepts a single input parameter, p_report_type, of type VARCHAR2, which represents the type of report to be counted. The function declares a local variable, v_report_count, of type NUMBER, to store the result of the count operation. Within the function body, a SELECT statement is executed to count the number of rows in the REPORTING table where the REPORT_TYPE column matches the value provided in the p_report_type parameter. The result of this count operation is stored in the v_report_count variable. Finally, the function returns the value of v_report_count, which represents the total number of reports of the specified type in the REPORTING table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_report_type_count(p_report_type VARCHAR2) RETURN NUMBER IS\n  v_report_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO v_report_count\n  FROM REPORTING\n  WHERE REPORT_TYPE = p_report_type;\n  RETURN v_report_count;\nEND;",
    "database_name": "public_hdma_tracking",
    "tables": [
      "ACCESS_LOGS",
      "HEALTH_DATA",
      "REPORTING",
      "ROLES",
      "STATES",
      "USERS"
    ],
    "call_sqls": [
      "SELECT get_report_type_count('Daily Summary') FROM DUAL",
      "SELECT get_report_type_count('Monthly Performance') FROM DUAL",
      "SELECT get_report_type_count('Ad-hoc Analysis') FROM DUAL",
      "SELECT get_report_type_count('System Audit') FROM DUAL",
      "SELECT get_report_type_count('User Activity') FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_report_type_count that accepts a report type as input and returns the total number of rows in the REPORTING table where the REPORT_TYPE matches the provided input.",
    "natural_language": "Write a Oracle PL/SQL function named get_report_type_count that, given a report type as input, returns the total number of rows in the REPORTING table where the REPORT_TYPE matches the provided value.",
    "id": 16,
    "generated_ir": "Write an Oracle PL/SQL function named get_report_type_count that accepts a single input parameter p_report_type of type VARCHAR2, which specifies the report type to be matched. The function returns a value of type NUMBER, representing the total count of rows in the REPORTING table where the REPORT_TYPE column matches the provided p_report_type value. Inside the function, a local variable v_count of type NUMBER is declared. The function performs a SELECT statement with the COUNT(*) aggregate function on the REPORTING table, specifically targeting rows where the REPORT_TYPE column equals the value of p_report_type. The result of this SELECT statement is stored in the v_count variable. Finally, the function returns the value of v_count.",
    "original_summary": "Create a PL/SQL function named `get_report_type_count` that accepts a `p_report_type` (VARCHAR2) and returns a NUMBER. It counts the rows in the `REPORTING` table where `REPORT_TYPE` matches the input parameter and returns the count.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write function `get_report_type_count`(p_report_type VARCHAR2) returning NUMBER to count REPORTING rows with matching REPORT_TYPE."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_unemployment_rate` that accepts a single input parameter, `p_country_name`, which is of data type `VARCHAR2` and represents the name of a country for which the unemployment rate is to be retrieved. This function is designed to return a single numeric value representing the unemployment rate. Upon execution, the function declares a local variable named `v_unemployment_rate` of data type `NUMBER` to temporarily store the retrieved unemployment rate. The core operation of the function involves executing a `SELECT` statement to query data from two tables: `economic_data` (aliased as `e`) and `countries` (aliased as `c`). The `SELECT` statement aims to retrieve the maximum value of the `unemployment_rate` column from the `economic_data` table. This maximum value is then stored into the `v_unemployment_rate` local variable. The `economic_data` and `countries` tables are joined using an `INNER JOIN` operation based on a common column: `e.country_id` from the `economic_data` table is matched with `c.country_id` from the `countries` table. The `WHERE` clause applies two conditions to filter the results: first, it compares the uppercase version of the `country_name` column from the `countries` table (`UPPER(c.country_name)`) with the uppercase version of the input parameter `p_country_name` (`UPPER(p_country_name)`), ensuring a case-insensitive match for the country name; second, it filters records where the `year` column in the `economic_data` table (`e.year`) is exactly equal to `2022`. After the `SELECT` statement has executed and populated `v_unemployment_rate` with the maximum unemployment rate satisfying the specified conditions, the function returns the value stored in `v_unemployment_rate` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_unemployment_rate(p_country_name VARCHAR2) RETURN NUMBER IS\n  v_unemployment_rate NUMBER;\nBEGIN\n  SELECT MAX(e.unemployment_rate) \n  INTO v_unemployment_rate \n  FROM economic_data e \n  JOIN countries c ON e.country_id = c.country_id \n  WHERE UPPER(c.country_name) = UPPER(p_country_name) \n    AND e.year = 2022;\n  \n  RETURN v_unemployment_rate;\nEND;",
    "database_name": "global_haed_analysis",
    "tables": [
      "COUNTRIES",
      "HAPPINESS_DATA",
      "ECONOMIC_DATA",
      "HEALTH_DATA"
    ],
    "call_sqls": [
      "SELECT get_unemployment_rate('Norway') FROM dual",
      "SELECT get_unemployment_rate('Switzerland') FROM dual",
      "SELECT get_unemployment_rate('NOR') FROM dual",
      "SELECT get_unemployment_rate('CHE') FROM dual",
      "SELECT get_unemployment_rate('Western Europe') FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_unemployment_rate that accepts a country name and returns the maximum unemployment rate for the year 2022 from the economic_data table, matching the country by joining with the countries table using a case-insensitive comparison on the country name.",
    "natural_language": "Write a Oracle PL/SQL function called get_unemployment_rate that takes a country name as input and returns a number, where it finds the highest unemployment rate for the year 2022 from the economic_data table for the specified country, matching the country name case-insensitively by joining with the countries table.",
    "id": 17,
    "generated_ir": "Write an Oracle PL/SQL function named `get_unemployment_rate` that accepts a single input parameter, `p_country_name`, which is of data type `VARCHAR2` and represents the name of a country for which the unemployment rate is to be retrieved. This function is designed to return a single numeric value representing the unemployment rate. Upon execution, the function declares a local variable named `v_unemployment_rate` of data type `NUMBER` to temporarily store the retrieved unemployment rate. The core operation of the function involves executing a `SELECT` statement to query data from two tables: `economic_data` (aliased as `e`) and `countries` (aliased as `c`). The `SELECT` statement aims to retrieve the maximum value of the `unemployment_rate` column from the `economic_data` table. This maximum value is then stored into the `v_unemployment_rate` local variable. The `economic_data` and `countries` tables are joined using an `INNER JOIN` operation based on a common column: `e.country_id` from the `economic_data` table is matched with `c.country_id` from the `countries` table. The `WHERE` clause applies two conditions to filter the results: first, it compares the uppercase version of the `country_name` column from the `countries` table (`UPPER(c.country_name)`) with the uppercase version of the input parameter `p_country_name` (`UPPER(p_country_name)`), ensuring a case-insensitive match for the country name; second, it filters records where the `year` column in the `economic_data` table (`e.year`) is exactly equal to `2022`. After the `SELECT` statement has executed and populated `v_unemployment_rate` with the maximum unemployment rate satisfying the specified conditions, the function returns the value stored in `v_unemployment_rate` as its output.",
    "original_summary": "Create a PL/SQL function named get_unemployment_rate that accepts a country name (VARCHAR2) and returns a NUMBER. The function retrieves the maximum unemployment rate for 2022 from the economic_data table by joining with the countries table using a case-insensitive country name match.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "How can I create a PL/SQL function called get_unemployment_rate that takes a country name as a VARCHAR2 input and returns a NUMBER, where the function finds the highest unemployment rate for 2022 by querying the economic_data table joined with the countries table using a case-insensitive match on the country name?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_taxon_access_level that accepts a single parameter, p_taxon_id, of type NUMBER, which represents the identifier of a taxon. The function performs a SELECT operation to count the number of entries in the ACCESS_LOGS table where the TAXON_ID column matches the provided p_taxon_id. The result of this count is stored in a local variable named v_count of type NUMBER. The function then evaluates the value of v_count using an IF statement. If v_count is greater than 5, the function returns the string 'HIGH'. Otherwise, it returns the string 'LOW'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_taxon_access_level(p_taxon_id NUMBER) RETURN VARCHAR2 IS\nv_count NUMBER;\nBEGIN\nSELECT COUNT(*) INTO v_count FROM ACCESS_LOGS WHERE TAXON_ID = p_taxon_id;\nIF v_count > 5 THEN\nRETURN 'HIGH';\nELSE\nRETURN 'LOW';\nEND IF;\nEND;",
    "database_name": "genomic_dmaa_867750",
    "tables": [
      "ACCESS_LOGS",
      "CITATIONS",
      "PUBLICATIONS",
      "TAXONS",
      "USERS",
      "TAXON_CLASSIFICATIONS"
    ],
    "call_sqls": [
      "SELECT get_taxon_access_level(0) FROM DUAL",
      "SELECT get_taxon_access_level(1) FROM DUAL",
      "SELECT get_taxon_access_level(10) FROM DUAL",
      "SELECT t.TAXON_ID, t.SPECIES_NAME, get_taxon_access_level(t.TAXON_ID) AS ACCESS_LEVEL FROM TAXONS t WHERE t.TAXON_ID = 5",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Access Level for Taxon 7: ' || get_taxon_access_level(7));\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL function named get_taxon_access_level that, given a taxon ID as input, determines its access level by checking the ACCESS_LOGS table: if the number of log entries for that TAXON_ID exceeds 5, return 'HIGH'; otherwise, return 'LOW'.",
    "natural_language": "Write a Oracle PL/SQL function named get_taxon_access_level that returns a VARCHAR2 based on a given p_taxon_id number. It should determine the access level by checking the ACCESS_LOGS table: if the count of entries where TAXON_ID matches the provided p_taxon_id exceeds five, return 'HIGH'; otherwise, return 'LOW'.",
    "id": 18,
    "generated_ir": "Write an Oracle PL/SQL function named get_taxon_access_level that accepts a single parameter, p_taxon_id, of type NUMBER, which represents the identifier of a taxon. The function performs a SELECT operation to count the number of entries in the ACCESS_LOGS table where the TAXON_ID column matches the provided p_taxon_id. The result of this count is stored in a local variable named v_count of type NUMBER. The function then evaluates the value of v_count using an IF statement. If v_count is greater than 5, the function returns the string 'HIGH'. Otherwise, it returns the string 'LOW'.",
    "original_summary": "Create a PL/SQL function named get_taxon_access_level that returns a VARCHAR2. It accepts a numeric p_taxon_id. The function counts rows in the ACCESS_LOGS table where TAXON_ID equals p_taxon_id. If the count is greater than 5, return 'HIGH'; otherwise, return 'LOW'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Alright, so we need a PL/SQL function called get_taxon_access_level that spits back a VARCHAR2. You'll give it a number, the p_taxon_id. What it does is check out the ACCESS_LOGS table and count up all the entries where the TAXON_ID matches the one you passed in. If that count goes over five, it should come back as 'HIGH'. If not, just say it's 'LOW'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_disease_summary` that accepts two input parameters: `p_country_id`, which is of data type `NUMBER` and represents the unique identifier for a country, and `p_year`, which is also of data type `NUMBER` and represents a specific year. This function is designed to return a single `VARCHAR2` value, specifically a string of up to 4000 characters, which will contain a summary of disease statistics. Upon execution, the function declares a local variable named `v_summary` of type `VARCHAR2` with a maximum length of 4000 characters to temporarily store the generated summary string. The core operation of the function involves a `SELECT` statement that constructs this summary string. This `SELECT` statement retrieves data from a table named `DISEASES`, aliased as `d`. It concatenates several literal strings with the values from specific columns within the `DISEASES` table. Specifically, it takes the literal string 'Polio: ', appends the character representation of the value from the `POLIO` column (converted to `VARCHAR2` using the `TO_CHAR` function), then appends the literal string ', Diphtheria: ', followed by the character representation of the value from the `DIPHTHERIA` column (also converted using `TO_CHAR`), and finally appends the literal string ', HIV/AIDS: ', followed by the character representation of the value from the `HIV_AIDS` column (again converted using `TO_CHAR`). The result of this concatenation is then assigned to the `v_summary` variable using the `INTO` clause. This data retrieval is filtered by a `WHERE` clause that specifies two conditions: `d.COUNTRY_ID` must be equal to the value provided in the `p_country_id` input parameter, and `d.YEAR` must be equal to the value provided in the `p_year` input parameter. After successfully retrieving and formatting the disease summary into `v_summary`, the function returns the final `v_summary` string as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_disease_summary(p_country_id NUMBER, p_year NUMBER) RETURN VARCHAR2 IS\n    v_summary VARCHAR2(4000);\nBEGIN\n    SELECT 'Polio: ' || TO_CHAR(d.POLIO) || ', Diphtheria: ' || TO_CHAR(d.DIPHTHERIA) || ', HIV/AIDS: ' || TO_CHAR(d.HIV_AIDS)\n    INTO v_summary\n    FROM DISEASES d\n    WHERE d.COUNTRY_ID = p_country_id AND d.YEAR = p_year;\n    RETURN v_summary;\nEND;",
    "database_name": "global_hae_statistics",
    "tables": [
      "COUNTRIES",
      "HEALTH_INDICATORS",
      "DISEASES",
      "HEALTHCARE_EXPENDITURE"
    ],
    "call_sqls": [
      "SELECT get_disease_summary(1, 2000) FROM DUAL",
      "SELECT get_disease_summary(2, 2005) FROM DUAL",
      "SELECT get_disease_summary(3, 2010) FROM DUAL",
      "SELECT get_disease_summary(4, 2015) FROM DUAL",
      "SELECT get_disease_summary(5, 2020) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_disease_summary that, given a country ID and a year, retrieves from the DISEASES table the corresponding values for POLIO, DIPHTHERIA, and HIV_AIDS, and returns them as a single formatted string in the pattern 'Polio: [value], Diphtheria: [value], HIV/AIDS: [value]'.",
    "natural_language": "Write a Oracle PL/SQL function called `get_disease_summary` that returns a formatted summary string for a given country and year. The function should take a country ID and a year as inputs, retrieve the Polio, Diphtheria, and HIV/AIDS values from the DISEASES table for that COUNTRY_ID and YEAR, and output a single string in the format 'Polio: [value], Diphtheria: [value], HIV/AIDS: [value]'.",
    "id": 19,
    "generated_ir": "Write an Oracle PL/SQL function named get_disease_summary that accepts two input parameters: p_country_id of type VARCHAR2 or NUMBER (depending on the actual data type of COUNTRY_ID in the DISEASES table, but typically a string or number identifier), and p_year of type NUMBER, which represents the year for which the disease data is to be summarized. The function returns a VARCHAR2 string that contains a formatted summary of disease values.\n\nWithin the function body, three local variables are declared to store the disease values retrieved from the database: v_polio of type NUMBER, v_diphtheria of type NUMBER, and v_hiv_aids of type NUMBER. These variables will hold the respective values for Polio, Diphtheria, and HIV/AIDS from the DISEASES table.\n\nThe function performs a SELECT operation on the DISEASES table, which is part of the global_hae_statistics database. The SELECT statement queries the columns corresponding to Polio, Diphtheria, and HIV/AIDS (assuming column names such as POLIO, DIPHTHERIA, HIV_AIDS or similar) from the DISEASES table. It uses a WHERE clause to filter the rows based on the input parameters: the COUNTRY_ID column must equal the p_country_id parameter, and the YEAR column must equal the p_year parameter. The SELECT statement retrieves exactly one row (if data exists for that country and year) and stores the values into the declared variables v_polio, v_diphtheria, and v_hiv_aids using the INTO clause.\n\nAfter retrieving the disease values, the function constructs a formatted summary string by concatenating static text with the variable values. The output string is built in the format 'Polio: [value], Diphtheria: [value], HIV/AIDS: [value]', where [value] is replaced with the actual numeric values stored in v_polio, v_diphtheria, and v_hiv_aids, respectively. This concatenation uses the || operator or a similar string concatenation method in PL/SQL.\n\nThe function then returns this formatted string as the result. If no data is found for the given country ID and year (i.e., the SELECT statement returns no rows), the function will handle this by raising a NO_DATA_FOUND exception or returning a default message (though the natural language description does not specify exception handling, so it is assumed the function may rely on default exception propagation or implicit handling). The function does not perform any INSERT, UPDATE, or DELETE operations, and it does not involve any conditional logic beyond the data retrieval based on the input parameters.",
    "original_summary": "Create a PL/SQL function named `get_disease_summary` that returns a VARCHAR2. It accepts a country ID and a year as NUMBER parameters. The function returns a concatenated string in the format 'Polio: [value], Diphtheria: [value], HIV/AIDS: [value]' from the DISEASES table for the matching country and year.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called `get_disease_summary` that returns a VARCHAR2. It should take a country ID and a year as NUMBER inputs. Make the function output a single string formatted as 'Polio: [value], Diphtheria: [value], HIV/AIDS: [value]' by fetching the corresponding data from the DISEASES table for the specified country and year."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_campaign_interaction_count` that accepts a single input parameter, `p_campaign_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement calculates the total number of rows in the `CAMPAIGN_INTERACTIONS` table. The count is determined by applying a `WHERE` clause that filters the rows based on the `CAMPAIGN_ID` column. Specifically, it counts only those rows where the value in the `CAMPAIGN_ID` column is equal to the value provided in the input parameter `p_campaign_id`. The result of this `COUNT(*)` aggregation is then stored into the local variable `v_count`. Finally, the function returns the value currently held in the `v_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_campaign_interaction_count(p_campaign_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM CAMPAIGN_INTERACTIONS WHERE CAMPAIGN_ID = p_campaign_id;\n    RETURN v_count;\nEND;",
    "database_name": "customer_iae_tracking",
    "tables": [
      "CAMPAIGNS",
      "CAMPAIGN_INTERACTIONS",
      "INTERACTIONS"
    ],
    "call_sqls": [
      "SELECT get_campaign_interaction_count(0) FROM DUAL",
      "SELECT get_campaign_interaction_count(1) FROM DUAL",
      "SELECT get_campaign_interaction_count(10) FROM DUAL",
      "SELECT get_campaign_interaction_count(100) FROM DUAL",
      "SELECT get_campaign_interaction_count(NULL) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_campaign_interaction_count that returns the total count of interactions from the CAMPAIGN_INTERACTIONS table for a specified CAMPAIGN_ID input parameter.",
    "natural_language": "Write a Oracle PL/SQL function named get_campaign_interaction_count that provides a rough, not necessarily precise, count of how many interactions a specific campaign has had by retrieving the count from the CAMPAIGN_INTERACTIONS table for a given campaign ID.",
    "id": 20,
    "generated_ir": "Write an Oracle PL/SQL function named `get_campaign_interaction_count` that accepts a single input parameter, `p_campaign_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_count` of data type `NUMBER` to temporarily store the result of a database query. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement calculates the total number of rows in the `CAMPAIGN_INTERACTIONS` table. The count is determined by applying a `WHERE` clause that filters the rows based on the `CAMPAIGN_ID` column. Specifically, it counts only those rows where the value in the `CAMPAIGN_ID` column is equal to the value provided in the input parameter `p_campaign_id`. The result of this `COUNT(*)` aggregation is then stored into the local variable `v_count`. Finally, the function returns the value currently held in the `v_count` variable as its output.",
    "original_summary": "Create a PL/SQL function named `get_campaign_interaction_count` that returns the count of interactions from the `CAMPAIGN_INTERACTIONS` table for a given `CAMPAIGN_ID`.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function to get a rough idea of how many interactions a campaign has had. The function should look at the CAMPAIGN_INTERACTIONS table and give back a count for a specific campaign, but the count might not need to be perfectly precise."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_component_release_year` that accepts a single input parameter, `p_component_id`, which is of data type `NUMBER` and represents the unique identifier for a component. This function is designed to return a single value of data type `NUMBER`, which will be the release year of the specified component. The function declares a local variable named `v_release_year` of data type `NUMBER` to temporarily store the extracted release year. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves data from the `COMPONENTS` table. Specifically, it selects the `RELEASE_DATE` column from this table. Before storing the `RELEASE_DATE`, which is assumed to be stored as a `VARCHAR2` or similar string type in the format 'YYYY-MM-DD', it first converts this string into a `DATE` data type using the `TO_DATE` function with the format mask 'YYYY-MM-DD'. Subsequently, it extracts the year component from this converted `DATE` value using the `EXTRACT` function, specifying `YEAR` as the part to extract. The result of this extraction is then stored into the `v_release_year` local variable. This selection is constrained by a `WHERE` clause, which filters the rows in the `COMPONENTS` table to include only those where the `COMPONENT_ID` column matches the value provided in the input parameter `p_component_id`. Finally, the function returns the value stored in the `v_release_year` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_component_release_year(p_component_id NUMBER) RETURN NUMBER IS\n  v_release_year NUMBER;\nBEGIN\n  SELECT EXTRACT(YEAR FROM TO_DATE(RELEASE_DATE, 'YYYY-MM-DD')) INTO v_release_year\n  FROM COMPONENTS\n  WHERE COMPONENT_ID = p_component_id;\n  RETURN v_release_year;\nEND;",
    "database_name": "electronic_csap_tracking",
    "tables": [
      "COMPONENTS",
      "COMPONENT_CONDITIONS",
      "COMPONENT_PARAMETERS",
      "COMPONENT_TYPES",
      "CONDITIONS",
      "PARAMETERS",
      "DATASHEETS"
    ],
    "call_sqls": [
      "SELECT get_component_release_year(0) FROM DUAL",
      "SELECT get_component_release_year(1) FROM DUAL",
      "SELECT get_component_release_year(10) FROM DUAL",
      "SELECT get_component_release_year(100) FROM DUAL",
      "SELECT get_component_release_year(999) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_component_release_year that, given a component ID as input, retrieves the RELEASE_DATE from the COMPONENTS table for that COMPONENT_ID, extracts the year from the date, and returns the year as a number.",
    "natural_language": "Write a Oracle PL/SQL function named get_component_release_year that, for a given component ID, retrieves the RELEASE_DATE from the COMPONENTS table, converts it to a date, extracts the year, and returns that year as a number.",
    "id": 21,
    "generated_ir": "Write an Oracle PL/SQL function named `get_component_release_year`. This function accepts a single input parameter, which is the component identifier. This parameter is named `p_component_id` and is of data type `NUMBER`. The function is designed to return a single numeric value of data type `NUMBER`, which will represent the year portion of a release date.\n\nInternally, the function declares a local variable named `v_release_year` of data type `NUMBER`. This variable is used to temporarily store the calculated year value before it is returned.\n\nThe core operation of the function involves executing a `SELECT` statement to retrieve and process data from the `COMPONENTS` table within the `electronic_csap_tracking` database. The `SELECT` statement targets a specific column: `RELEASE_DATE`. The data type of the `RELEASE_DATE` column is not specified but is assumed to be a date-compatible type (such as `DATE` or `TIMESTAMP`) or a string that can be converted to a date.\n\nThe retrieval is conditional. A `WHERE` clause is used to filter the `COMPONENTS` table, specifying the condition `component_id = p_component_id`. This ensures the query fetches data only for the row where the `component_id` column matches the value provided in the input parameter `p_component_id`.\n\nThe `SELECT` statement does not simply fetch the `RELEASE_DATE` value. It performs a data transformation directly within the query. It uses the `TO_DATE` function to explicitly convert the value from the `RELEASE_DATE` column into a standard Oracle `DATE` data type. The exact format mask for this conversion is not specified but is implied to be the default or a format matching the stored data.\n\nFollowing this conversion, the `EXTRACT` function is applied to the resulting date. The `EXTRACT` function is used with the `YEAR` field, which isolates and returns the four-digit year component from the `RELEASE_DATE` as a number.\n\nThe result of this operation—the extracted year number—is then directly assigned to the local variable `v_release_year` by the `SELECT INTO` statement.\n\nFinally, the function concludes by returning the value stored in the `v_release_year` variable as its output.",
    "original_summary": "Create a PL/SQL function named get_component_release_year that accepts a NUMBER parameter p_component_id and returns a NUMBER. It retrieves the RELEASE_DATE from the COMPONENTS table where COMPONENT_ID equals p_component_id, converts it to a DATE, extracts the year, and returns it.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write function get_component_release_year(p_component_id NUMBER) returning NUMBER. Fetch RELEASE_DATE from COMPONENTS for given ID, convert to DATE, extract year, and return it."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `process_region_data` that accepts a single input parameter, `p_region_id`, which is of data type `NUMBER` and represents the unique identifier for a specific region. This function is designed to return a `VARCHAR2` string. Internally, the function declares three local variables: `v_region_name` of type `VARCHAR2(255)` to store the name of the region, `v_male_count` of type `NUMBER` to store the aggregated count of males, and `v_female_count` of type `NUMBER` to store the aggregated count of females. It also declares `v_result` of type `VARCHAR2(255)` to store the final computed result string. The function begins by executing a `SELECT` statement to retrieve the `REGION_NAME` from the `REGIONS` table, specifically for the row where the `REGION_ID` column matches the value provided in the `p_region_id` input parameter. The retrieved `REGION_NAME` is then stored into the `v_region_name` variable. Following this, another `SELECT` statement is executed to calculate the `SUM` of the `VALUE` column from the `DEMOGRAPHIC_DATA` table. This sum is filtered by two conditions: the `REGION_ID` column must match the `p_region_id` input parameter, and the `SEX` column must be equal to the string literal 'Male'. The calculated sum is then stored into the `v_male_count` variable. Subsequently, a third `SELECT` statement is executed to calculate the `SUM` of the `VALUE` column from the `DEMOGRAPHIC_DATA` table. This sum is also filtered by two conditions: the `REGION_ID` column must match the `p_region_id` input parameter, and the `SEX` column must be equal to the string literal 'Female'. The calculated sum is then stored into the `v_female_count` variable. After retrieving these counts, the function proceeds with a series of conditional checks (`IF-ELSIF-ELSE`) to determine the demographic dominance of the region. The first condition checks if `v_male_count` is strictly greater than `v_female_count` multiplied by 1.2. If this condition is true, the `v_result` variable is assigned a concatenated string consisting of the `v_region_name`, followed by the string literal '_MALE_DOMINANT_', and then the `v_male_count` converted to a character string using the `TO_CHAR` function. If the first condition is false, the function proceeds to the next `ELSIF` condition, which checks if `v_female_count` is strictly greater than `v_male_count` multiplied by 1.2. If this condition is true, the `v_result` variable is assigned a concatenated string consisting of the `v_region_name`, followed by the string literal '_FEMALE_DOMINANT_', and then the `v_female_count` converted to a character string using the `TO_CHAR` function. If both previous conditions are false, the function proceeds to the next `ELSIF` condition, which checks if `v_male_count` is strictly greater than `v_female_count`. If this condition is true, the `v_result` variable is assigned a concatenated string consisting of the `v_region_name`, followed by the string literal '_MALE_MAJORITY_', and then the difference between `v_male_count` and `v_female_count` converted to a character string using the `TO_CHAR` function. If all preceding conditions are false, the `ELSE` block is executed. In this case, the `v_result` variable is assigned a concatenated string consisting of the `v_region_name`, followed by the string literal '_BALANCED_', and then the sum of `v_male_count` and `v_female_count` converted to a character string using the `TO_CHAR` function. Finally, the function returns the computed `v_result` string.",
    "plsql": "CREATE OR REPLACE FUNCTION process_region_data(p_region_id IN NUMBER) RETURN VARCHAR2 IS\n    v_region_name VARCHAR2(255);\n    v_male_count NUMBER;\n    v_female_count NUMBER;\n    v_result VARCHAR2(255);\nBEGIN\n    SELECT REGION_NAME INTO v_region_name FROM REGIONS WHERE REGION_ID = p_region_id;\n    SELECT SUM(VALUE) INTO v_male_count FROM DEMOGRAPHIC_DATA WHERE REGION_ID = p_region_id AND SEX = 'Male';\n    SELECT SUM(VALUE) INTO v_female_count FROM DEMOGRAPHIC_DATA WHERE REGION_ID = p_region_id AND SEX = 'Female';\n    IF v_male_count > v_female_count * 1.2 THEN\n        v_result := v_region_name || '_MALE_DOMINANT_' || TO_CHAR(v_male_count);\n    ELSIF v_female_count > v_male_count * 1.2 THEN\n        v_result := v_region_name || '_FEMALE_DOMINANT_' || TO_CHAR(v_female_count);\n    ELSIF v_male_count > v_female_count THEN\n        v_result := v_region_name || '_MALE_MAJORITY_' || TO_CHAR(v_male_count - v_female_count);\n    ELSE\n        v_result := v_region_name || '_BALANCED_' || TO_CHAR(v_male_count + v_female_count);\n    END IF;\n    RETURN v_result;\nEND;",
    "database_name": "demographic_dcaa_426928",
    "tables": [
      "ACCESS_LOGS",
      "AGE_GROUPS",
      "DATA_SOURCES",
      "DEMOGRAPHIC_DATA",
      "REGIONS",
      "SEXES",
      "USERS",
      "YEARS"
    ],
    "call_sqls": [
      "SELECT process_region_data(1) FROM DUAL",
      "SELECT process_region_data(2) FROM DUAL",
      "SELECT process_region_data(3) FROM DUAL",
      "SELECT process_region_data(4) FROM DUAL",
      "SELECT process_region_data(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named process_region_data that takes a region ID number and returns a formatted string. It retrieves the REGION_NAME from the REGIONS table for the given ID, sums the VALUE for 'Male' and 'Female' entries in the DEMOGRAPHIC_DATA table for that region, and returns a string combining the region name with a label and a count. The label is 'MALE_DOMINANT_' with the male count if males exceed females by more than 20%, 'FEMALE_DOMINANT_' with the female count if females exceed males by more than 20%, 'MALE_MAJORITY_' with the difference if males are greater but not dominant, or 'BALANCED_' with the total count otherwise.",
    "natural_language": "Write a Oracle PL/SQL function named process_region_data that takes a region ID as input and returns a formatted string. For the given region ID, retrieve the region name from the REGIONS table, sum the male and female values from the DEMOGRAPHIC_DATA table, and produce a string containing the region name, a dominance label (choosing 'MALE_DOMINANT_', 'FEMALE_DOMINANT_', 'MALE_MAJORITY_', or 'BALANCED_' based on whether male or female counts exceed the other by more than 20% or simply outnumber), and the relevant count (dominant count, majority difference, or total count).",
    "id": 22,
    "generated_ir": "Write an Oracle PL/SQL function named `process_region_data` that accepts a single input parameter `p_region_id` of data type `NUMBER` (or the appropriate type matching the `REGIONS` table's `region_id` column) and returns a formatted string of data type `VARCHAR2`. The function's purpose is to process demographic data for a specified region and generate a descriptive label.\n\nThe function begins by declaring several local variables: `v_region_name` of type `VARCHAR2` to store the name of the region retrieved from the `REGIONS` table; `v_male_count` of type `NUMBER` to store the summed value of male individuals; `v_female_count` of type `NUMBER` to store the summed value of female individuals; `v_total_count` of type `NUMBER` to store the sum of both male and female counts; `v_difference` of type `NUMBER` to store the absolute difference between the male and female counts; `v_percentage_difference` of type `NUMBER` to store the calculated percentage difference relative to the total count; and `v_output_string` of type `VARCHAR2` to assemble and hold the final formatted result.\n\nThe function's execution involves two primary SQL `SELECT` operations. First, it queries the `REGIONS` table to retrieve the `region_name` for the row where the `region_id` column equals the input parameter `p_region_id`. The retrieved name is stored into the `v_region_name` variable. Second, it queries the `DEMOGRAPHIC_DATA` table to calculate the sum of the `male` column and the sum of the `female` column for all rows where the `region_id` column matches the input `p_region_id`. These two aggregated sums are stored into the `v_male_count` and `v_female_count` variables, respectively, using a single `SELECT INTO` statement.\n\nFollowing the data retrieval, the function performs a series of calculations. It computes `v_total_count` by adding `v_male_count` and `v_female_count`. It computes `v_difference` as the absolute value of `v_male_count` minus `v_female_count`. It then calculates `v_percentage_difference` by dividing `v_difference` by `v_total_count` and multiplying by 100, provided `v_total_count` is greater than zero to avoid division by zero.\n\nThe core business logic involves evaluating these calculated values to determine a dominance label according to specific rules. The logic uses conditional checks (IF-THEN-ELSIF-ELSE). First, it checks if `v_percentage_difference` is greater than 20. If true, it determines which gender count is higher. If `v_male_count` is greater than `v_female_count`, the label is set to `'MALE_DOMINANT_'` and the relevant count for the output is set to `v_male_count`. If `v_female_count` is greater, the label is set to `'FEMALE_DOMINANT_'` and the relevant count is set to `v_female_count`.\n\nIf the percentage difference is 20 or less, the function then checks if one count simply outnumbers the other (i.e., `v_difference` > 0). If `v_male_count` is greater than `v_female_count`, the label is set to `'MALE_MAJORITY_'` and the relevant count is set to `v_difference` (the majority difference). If `v_female_count` is greater than `v_male_count`, the label is set to `'FEMALE_MAJORITY_'` and the relevant count is set to `v_difference`.\n\nIf neither count is greater than the other (meaning `v_difference` is 0), the label is set to `'BALANCED_'` and the relevant count is set to `v_total_count`.\n\nFinally, the function constructs the `v_output_string` by concatenating the `v_region_name`, a colon and space, the determined dominance label, and the relevant count formatted as a string. This final string is then returned by the function as its output.",
    "original_summary": "Create a PL/SQL function named process_region_data that takes a region ID number and returns a VARCHAR2 result. It retrieves the region name from REGIONS and sums male and female values from DEMOGRAPHIC_DATA. It returns a string with the region name, a dominance label ('MALE_DOMINANT_', 'FEMALE_DOMINANT_', 'MALE_MAJORITY_', or 'BALANCED_'), and a relevant count (dominant count, difference, or total).",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a function process_region_data(region_id NUMBER) returning VARCHAR2. Fetch region name from REGIONS, sum male/female from DEMOGRAPHIC_DATA. Return string: region name, dominance label ('MALE_DOMINANT_', 'FEMALE_DOMINANT_', 'MALE_MAJORITY_', or 'BALANCED_'), and relevant count."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_user_alerts_above_price that accepts two input parameters: user_id_in of type NUMBER, which represents the unique identifier of a user, and price_in of type NUMBER, which specifies a price threshold. The function performs a SELECT operation to count the number of rows in the ALERTS table where the USER_ID column matches the value of user_id_in and the ALERT_PRICE column is greater than the value of price_in. The result of this count is stored in a local variable named alerts_above_price_count of type NUMBER. The function then returns the value of alerts_above_price_count, which represents the number of alerts for the specified user that have a price exceeding the given threshold.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_alerts_above_price(user_id_in NUMBER, price_in NUMBER) RETURN NUMBER IS\n  alerts_above_price_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO alerts_above_price_count\n  FROM ALERTS\n  WHERE USER_ID = user_id_in AND ALERT_PRICE > price_in;\n  RETURN alerts_above_price_count;\nEND;",
    "database_name": "financial_mda_404480",
    "tables": [
      "ALERTS",
      "USERS"
    ],
    "call_sqls": [
      "SELECT get_user_alerts_above_price(0, 80) FROM DUAL",
      "SELECT get_user_alerts_above_price(1, 85) FROM DUAL",
      "SELECT get_user_alerts_above_price(0, 75) FROM DUAL",
      "SELECT get_user_alerts_above_price(1, 90) FROM DUAL",
      "SELECT get_user_alerts_above_price(0, 100) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_user_alerts_above_price that, for a given user identified by user_id_in and a specified price threshold price_in, returns the total count of alerts from the ALERTS table where the USER_ID matches the input user and the ALERT_PRICE is greater than the provided price.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called get_user_alerts_above_price? It should take a user ID and a price as numbers. Basically, it needs to give back how many alerts from the ALERTS table that user has where the ALERT_PRICE is higher than the price we give it.",
    "id": 23,
    "generated_ir": "Write an Oracle PL/SQL function named get_user_alerts_above_price that accepts two numeric input parameters: p_user_id to identify a specific user and p_price to specify a threshold price value, and returns a numeric value representing a count of alert records; the function begins by declaring a local numeric variable v_alert_count; then executes a SELECT statement that calculates the count of all rows from the ALERTS table, applying a filter in the WHERE clause to include only those rows where the USER_ID column is equal to the input parameter p_user_id and the ALERT_PRICE column is greater than the input parameter p_price, storing the result of this count calculation into the local variable v_alert_count; the function then returns the value stored in v_alert_count.",
    "original_summary": "Create a PL/SQL function named get_user_alerts_above_price that accepts a user_id_in NUMBER and a price_in NUMBER, and returns the count of alerts for that user where the ALERT_PRICE is greater than the specified price.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called get_user_alerts_above_price? It should take a user ID and a price as numbers. Basically, it needs to give back how many alerts that user has where the alert price is higher than the price we give it."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_blood_pressure` that accepts a single input parameter, `p_patient_id`, which is of data type `NUMBER` and represents the unique identifier for a patient. This function is designed to return a single value of data type `NUMBER`, representing the maximum systolic blood pressure reading recorded for the specified patient. The function begins its execution by declaring a local variable named `v_max_bp` of data type `NUMBER` to temporarily store the calculated maximum blood pressure value. The core logic of the function involves executing a `SELECT` statement to retrieve data. This `SELECT` statement targets the `HYPERTENSION_DATA` table. Within this `SELECT` statement, the `MAX` aggregate function is applied to a transformed version of the `BLOOD_PRESSURE_READINGS` column. The transformation involves several steps: first, the `INSTR` function is used to locate the position of the forward slash ('/') character within the `BLOOD_PRESSURE_READINGS` string. This position is then used by the `SUBSTR` function to extract a substring from the `BLOOD_PRESSURE_READINGS` column, starting from the first character (position 1) up to, but not including, the forward slash. This extracted substring is expected to represent the systolic blood pressure value. Finally, the `TO_NUMBER` function is applied to this extracted substring to convert it from a string representation to a numerical value, allowing for numerical comparison and the determination of the maximum value. The result of this `MAX` aggregation is then stored into the `v_max_bp` local variable using the `INTO` clause. The `SELECT` statement includes a `WHERE` clause to filter the rows from the `HYPERTENSION_DATA` table. This `WHERE` clause ensures that only rows where the `PATIENT_ID` column matches the value provided in the input parameter `p_patient_id` are considered for the calculation of the maximum blood pressure. After the `SELECT` statement has executed and the maximum blood pressure has been determined and stored in `v_max_bp`, the function concludes by returning the value stored in `v_max_bp` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_blood_pressure(p_patient_id IN NUMBER) RETURN NUMBER IS\n   v_max_bp NUMBER;\nBEGIN\n   SELECT MAX(TO_NUMBER(SUBSTR(BLOOD_PRESSURE_READINGS, 1, INSTR(BLOOD_PRESSURE_READINGS, '/') - 1)))\n   INTO v_max_bp\n   FROM HYPERTENSION_DATA\n   WHERE PATIENT_ID = p_patient_id;\n   RETURN v_max_bp;\nEND;",
    "database_name": "healthcare_daapo_tracking",
    "tables": [
      "CARDIOVASCULAR_DATA",
      "CHRONIC_CONDITIONS",
      "COMORBIDITIES",
      "HYPERTENSION_DATA",
      "MORTALITY_DATA",
      "OBESITY_DATA",
      "AGE_GROUPS"
    ],
    "call_sqls": [
      "SELECT get_max_blood_pressure(1) FROM DUAL",
      "SELECT get_max_blood_pressure(2) FROM DUAL",
      "SELECT get_max_blood_pressure(100) FROM DUAL",
      "SELECT get_max_blood_pressure(500) FROM DUAL",
      "SELECT get_max_blood_pressure(1000) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_max_blood_pressure that accepts a patient ID and returns the highest systolic blood pressure value for that patient from the HYPERTENSION_DATA table, where the systolic value is extracted and converted from the BLOOD_PRESSURE_READINGS string.",
    "natural_language": "Write a Oracle PL/SQL function called get_max_blood_pressure that takes a patient ID as input and returns the highest systolic blood pressure recorded for that patient from the HYPERTENSION_DATA table, extracting the systolic value from the BLOOD_PRESSURE_READINGS column.",
    "id": 24,
    "generated_ir": "Write an Oracle PL/SQL function named `get_max_blood_pressure` that accepts a single input parameter, `p_patient_id`, which is of data type `NUMBER` and represents the unique identifier for a patient. This function is designed to return a single value of data type `NUMBER`, representing the maximum systolic blood pressure reading recorded for the specified patient. The function begins its execution by declaring a local variable named `v_max_bp` of data type `NUMBER` to temporarily store the calculated maximum blood pressure value. The core logic of the function involves executing a `SELECT` statement to retrieve data. This `SELECT` statement targets the `HYPERTENSION_DATA` table. Within this `SELECT` statement, the `MAX` aggregate function is applied to a transformed version of the `BLOOD_PRESSURE_READINGS` column. The transformation involves several steps: first, the `INSTR` function is used to locate the position of the forward slash ('/') character within the `BLOOD_PRESSURE_READINGS` string. This position is then used by the `SUBSTR` function to extract a substring from the `BLOOD_PRESSURE_READINGS` column, starting from the first character (position 1) up to, but not including, the forward slash. This extracted substring is expected to represent the systolic blood pressure value. Finally, the `TO_NUMBER` function is applied to this extracted substring to convert it from a string representation to a numerical value, allowing for numerical comparison and the determination of the maximum value. The result of this `MAX` aggregation is then stored into the `v_max_bp` local variable using the `INTO` clause. The `SELECT` statement includes a `WHERE` clause to filter the rows from the `HYPERTENSION_DATA` table. This `WHERE` clause ensures that only rows where the `PATIENT_ID` column matches the value provided in the input parameter `p_patient_id` are considered for the calculation of the maximum blood pressure. After the `SELECT` statement has executed and the maximum blood pressure has been determined and stored in `v_max_bp`, the function concludes by returning the value stored in `v_max_bp` as its output.",
    "original_summary": "Create a PL/SQL function named get_max_blood_pressure that accepts a NUMBER parameter p_patient_id and returns the maximum systolic blood pressure (extracted and converted from the BLOOD_PRESSURE_READINGS string) for that patient from the HYPERTENSION_DATA table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function called get_max_blood_pressure, which is designed to take a single numeric parameter identified as p_patient_id. This function should meticulously retrieve and return the highest recorded systolic blood pressure value for the specified patient. The value must be intelligently extracted and then properly converted from the textual BLOOD_PRESSURE_READINGS column within the comprehensive HYPERTENSION_DATA table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_region_density` that accepts a single input parameter, `p_region_id`, which is of data type `NUMBER` and represents the unique identifier for a specific region. This function is designed to return a single value of data type `NUMBER`, representing the calculated density of the specified region. The function begins by declaring three local variables: `v_population` of type `NUMBER` to store the population of the region, `v_area` of type `NUMBER` to store the area of the region, and `v_density` of type `NUMBER` to store the final calculated density. The first operation performed is a `SELECT` statement that retrieves the `POPULATION` and `AREA` column values from the `REGIONS` table. These retrieved values are then immediately assigned to the local variables `v_population` and `v_area`, respectively. The `SELECT` statement includes a `WHERE` clause that filters the rows in the `REGIONS` table, ensuring that only the row where the `REGION_ID` column matches the value provided by the input parameter `p_region_id` is selected. Following this data retrieval, the function proceeds with a series of conditional checks using an `IF-ELSIF-ELSIF-ELSE` block to determine the method of density calculation. The first condition checks if the value of `v_area` is strictly greater than `1000`. If this condition is true, `v_density` is calculated by dividing `v_population` by `v_area`. If the first condition is false, the next condition is evaluated, which checks if `v_area` is strictly greater than `100`. If this second condition is true, `v_density` is calculated by dividing `v_population` by `v_area` and then multiplying the result by `1.1`. If both the first and second conditions are false, the third condition is evaluated, which checks if `v_area` is strictly greater than `0`. If this third condition is true, `v_density` is calculated by dividing `v_population` by `v_area` and then multiplying the result by `1.2`. Finally, if none of the preceding conditions are met (meaning `v_area` is less than or equal to `0`), the `ELSE` block is executed, and `v_density` is assigned a value of `0`. After the appropriate density calculation is performed based on the area, the function concludes by returning the final calculated value stored in the `v_density` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_region_density(p_region_id IN NUMBER) RETURN NUMBER IS\n    v_population NUMBER;\n    v_area NUMBER;\n    v_density NUMBER;\nBEGIN\n    SELECT POPULATION, AREA INTO v_population, v_area FROM REGIONS WHERE REGION_ID = p_region_id;\n    IF v_area > 1000 THEN\n        v_density := v_population / v_area;\n    ELSIF v_area > 100 THEN\n        v_density := v_population / v_area * 1.1;\n    ELSIF v_area > 0 THEN\n        v_density := v_population / v_area * 1.2;\n    ELSE\n        v_density := 0;\n    END IF;\n    RETURN v_density;\nEND;",
    "database_name": "demographic_dcaa_426928",
    "tables": [
      "ACCESS_LOGS",
      "AGE_GROUPS",
      "DATA_SOURCES",
      "DEMOGRAPHIC_DATA",
      "REGIONS",
      "SEXES",
      "USERS",
      "YEARS"
    ],
    "call_sqls": [
      "SELECT calculate_region_density(1) FROM DUAL",
      "SELECT calculate_region_density(2) FROM DUAL",
      "SELECT calculate_region_density(3) FROM DUAL",
      "SELECT calculate_region_density(4) FROM DUAL",
      "SELECT calculate_region_density(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_region_density that accepts a region_id and returns a calculated density value. It retrieves the POPULATION and AREA for the specified REGION_ID from the REGIONS table. The density is computed as POPULATION divided by AREA, with adjustments based on the AREA: if AREA is greater than 1000, use the base calculation; if AREA is greater than 100, multiply the result by 1.1; if AREA is greater than 0, multiply by 1.2; and if AREA is less than or equal to 0, return 0.",
    "natural_language": "Write a Oracle PL/SQL function called calculate_region_density that takes a region_id as input and returns a numeric density value. The function should retrieve the POPULATION and AREA from the REGIONS table for the given region_id, calculate density by dividing POPULATION by AREA, and then apply adjustments: if AREA is greater than 1000, use the base calculation; if AREA is greater than 100, multiply the result by 1.1; if AREA is greater than 0, multiply by 1.2; and if AREA is less than or equal to 0, return 0.",
    "id": 25,
    "generated_ir": "Write an Oracle PL/SQL function named `calculate_region_density` that accepts a single input parameter, `p_region_id`, which is of data type `NUMBER` and represents the unique identifier for a specific region. This function is designed to return a single value of data type `NUMBER`, representing the calculated density of the specified region. The function begins by declaring three local variables: `v_population` of type `NUMBER` to store the population of the region, `v_area` of type `NUMBER` to store the area of the region, and `v_density` of type `NUMBER` to store the final calculated density. The first operation performed is a `SELECT` statement that retrieves the `POPULATION` and `AREA` column values from the `REGIONS` table. These retrieved values are then immediately assigned to the local variables `v_population` and `v_area`, respectively. The `SELECT` statement includes a `WHERE` clause that filters the rows in the `REGIONS` table, ensuring that only the row where the `REGION_ID` column matches the value provided by the input parameter `p_region_id` is selected. Following this data retrieval, the function proceeds with a series of conditional checks using an `IF-ELSIF-ELSIF-ELSE` block to determine the method of density calculation. The first condition checks if the value of `v_area` is strictly greater than `1000`. If this condition is true, `v_density` is calculated by dividing `v_population` by `v_area`. If the first condition is false, the next condition is evaluated, which checks if `v_area` is strictly greater than `100`. If this second condition is true, `v_density` is calculated by dividing `v_population` by `v_area` and then multiplying the result by `1.1`. If both the first and second conditions are false, the third condition is evaluated, which checks if `v_area` is strictly greater than `0`. If this third condition is true, `v_density` is calculated by dividing `v_population` by `v_area` and then multiplying the result by `1.2`. Finally, if none of the preceding conditions are met (meaning `v_area` is less than or equal to `0`), the `ELSE` block is executed, and `v_density` is assigned a value of `0`. After the appropriate density calculation is performed based on the area, the function concludes by returning the final calculated value stored in the `v_density` variable.",
    "original_summary": "Create a PL/SQL function named calculate_region_density that accepts a region_id (NUMBER) and returns a NUMBER density. It retrieves the population and area for the region from the REGIONS table. Calculate density as population/area. If area > 1000, use the base calculation. If area > 100, multiply the result by 1.1. If area > 0, multiply by 1.2. If area <= 0, return 0.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function called calculate_region_density, which is designed to take a single numeric input parameter representing a region_id and subsequently provide a numeric density value as its output. This function will first query the REGIONS table to carefully obtain both the population and the specific area measurement associated with the provided region identifier. The core density calculation is performed by dividing the retrieved population figure by the corresponding area. However, the final result is then adjusted through a detailed, conditional logic structure: if the area is found to be greater than 1000, the base calculation is used directly; if the area is instead greater than 100, the computed result is multiplied by a factor of 1.1; if the area is merely greater than 0, the result is then multiplied by 1.2; and finally, in the explicit case where the area is less than or equal to zero, the function will simply return a value of 0."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_quality_score that accepts two parameters: p_data_id of type NUMBER, which specifies the identifier of the data set to be evaluated, and p_weight of type NUMBER, which represents a weighting factor to be applied to the metric values. The function calculates a quality score by executing a SELECT statement that retrieves and sums the product of the METRIC_VALUE column and the p_weight parameter from the DATA_QUALITY table, where the DATA_ID column matches the provided p_data_id parameter. The result of this aggregation is stored in a local variable v_score of type NUMBER. The function then returns the value of v_score, using the NVL function to ensure that a value of 0 is returned if v_score is NULL, thereby handling cases where no matching records are found in the DATA_QUALITY table.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_quality_score(p_data_id NUMBER, p_weight NUMBER) RETURN NUMBER IS\n    v_score NUMBER;\nBEGIN\n    SELECT SUM(METRIC_VALUE * p_weight) INTO v_score FROM DATA_QUALITY WHERE DATA_ID = p_data_id GROUP BY DATA_ID;\n    RETURN NVL(v_score, 0);\nEND;",
    "database_name": "meteorological_dcaa_76430",
    "tables": [
      "ALERT_LOGS",
      "ALERT_RULES",
      "DATA_QUALITY",
      "DATA_REPORTS",
      "DATA_SOURCE_INTEGRATION",
      "WEATHER_CODES",
      "WEATHER_DATA_CODES"
    ],
    "call_sqls": [
      "SELECT calculate_quality_score(1, 0.5) FROM DUAL",
      "SELECT calculate_quality_score(2, 0.75) FROM DUAL",
      "SELECT calculate_quality_score(3, 1.0) FROM DUAL",
      "SELECT calculate_quality_score(4, 0.25) FROM DUAL",
      "SELECT calculate_quality_score(5, 0.9) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_quality_score that, given a data_id and a weight factor, returns the total quality score by summing the product of each METRIC_VALUE from the DATA_QUALITY table for that data_id multiplied by the weight factor, and returns 0 if no matching records are found.",
    "natural_language": "Write a Oracle PL/SQL function named calculate_quality_score that takes a data_id and a weight factor as inputs, calculates the total sum of each METRIC_VALUE multiplied by the given weight for all records in the DATA_QUALITY table matching that data_id, and returns that total; if no records are found for the data_id, it should return zero.",
    "id": 26,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_quality_score that accepts two input parameters: p_data_id of a data type matching the data_id column in the DATA_QUALITY table, and p_weight_factor of a numeric data type such as NUMBER. The function returns a numeric value of type NUMBER. The function's purpose is to compute a weighted sum of metric values for a specific data identifier.\n\nUpon execution, the function declares a local variable v_total_score of type NUMBER, initialized to 0. The core operation is a SELECT statement that queries the DATA_QUALITY table. This SELECT statement uses the SUM aggregate function to calculate the sum of each METRIC_VALUE column multiplied by the input parameter p_weight_factor. The calculation is expressed as SUM(metric_value * p_weight_factor). The selection is filtered by a WHERE clause that ensures only rows where the data_id column exactly matches the value provided in the input parameter p_data_id are included in the aggregation.\n\nThe result of this SUM calculation is then assigned directly to the local variable v_total_score using the INTO clause within the SELECT statement. To handle the scenario where no rows match the given p_data_id—which would cause the SELECT...INTO to raise a NO_DATA_FOUND exception—the function includes an EXCEPTION handling section. Specifically, after the BEGIN block containing the SELECT statement, an EXCEPTION block catches the NO_DATA_FOUND exception. When this exception is caught, the function sets the v_total_score variable to 0 explicitly.\n\nAfter the exception handling, the function returns the value stored in v_total_score as its final output.",
    "original_summary": "Create a PL/SQL function named calculate_quality_score that accepts a data_id and a weight factor. It returns the sum of (metric_value * weight) for the given data_id from the DATA_QUALITY table, or 0 if no records are found.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a comprehensive PL/SQL function, to be named calculate_quality_score, which is designed to receive two distinct input parameters: a specific data_id and a corresponding weight factor. This function should meticulously compute and deliver the cumulative sum derived from multiplying each metric_value by the provided weight for every record associated with the supplied data_id within the DATA_QUALITY table. Importantly, if the function's query finds no matching records for that identifier, it must gracefully and reliably return a default value of zero."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_bug_audit_summary` that accepts a single input parameter, `p_bug_id`, which is of data type `NUMBER` and represents the unique identifier of a bug. This function is designed to return a `VARCHAR2` string, which will contain a concatenated summary of audit descriptions for the specified bug.\n\nUpon invocation, the function first declares a local variable `v_audit_summary` of type `VARCHAR2` with a maximum length of 4000 characters. This variable is intended to store the aggregated audit descriptions.\n\nThe function then proceeds with a conditional check:\n1. It evaluates whether the input parameter `p_bug_id` is `NULL`.\n2. If `p_bug_id` is `NULL`, indicating an invalid bug identifier, the function assigns the literal string 'Invalid Bug ID' to the `v_audit_summary` variable.\n3. If `p_bug_id` is not `NULL`, the function executes a `SELECT` statement to retrieve and aggregate audit descriptions:\n    a. It queries the `BUG_AUDITS` table.\n    b. It filters the rows in `BUG_AUDITS` where the `BUG_ID` column matches the value provided in the `p_bug_id` input parameter.\n    c. For the filtered rows, it uses the `LISTAGG` aggregate function to concatenate the values from the `DESCRIPTION` column into a single string.\n    d. Each `DESCRIPTION` value is separated by a semicolon and a space (`; `).\n    e. The concatenation order is determined by sorting the audit records in ascending order based on the `CHANGE_DATE` column.\n    f. The resulting aggregated string is then stored in the `v_audit_summary` variable.\n    g. Following this `SELECT` operation, another conditional check is performed:\n        i. If `v_audit_summary` is `NULL` (which would occur if no records were found in `BUG_AUDITS` for the given `p_bug_id`), the function assigns the literal string 'No audits found' to `v_audit_summary`.\n\nFinally, after all conditional logic and data retrieval/assignment operations are complete, the function returns the final value stored in the `v_audit_summary` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_bug_audit_summary(p_bug_id NUMBER) RETURN VARCHAR2 IS\n  v_audit_summary VARCHAR2(4000); -- Increased size to accommodate longer aggregated strings\nBEGIN\n  IF p_bug_id IS NULL THEN\n    v_audit_summary := 'Invalid Bug ID';\n  ELSE\n    SELECT LISTAGG(DESCRIPTION, '; ') WITHIN GROUP (ORDER BY CHANGE_DATE)\n    INTO v_audit_summary\n    FROM BUG_AUDITS\n    WHERE BUG_ID = p_bug_id;\n\n    IF v_audit_summary IS NULL THEN\n      v_audit_summary := 'No audits found';\n    END IF;\n  END IF;\n  RETURN v_audit_summary;\nEND;",
    "database_name": "software_bta_security",
    "tables": [
      "BUGS",
      "BUG_AUDITS",
      "USERS"
    ],
    "call_sqls": [
      "SELECT get_bug_audit_summary(0) FROM DUAL",
      "SELECT get_bug_audit_summary(1) FROM DUAL",
      "SELECT get_bug_audit_summary(NULL) FROM DUAL",
      "SELECT get_bug_audit_summary(999) FROM DUAL",
      "SELECT get_bug_audit_summary(BUG_ID) FROM BUGS WHERE BUG_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL function named get_bug_audit_summary that accepts a bug ID and returns a summary text. If the bug ID is null, return 'Invalid Bug ID'. Otherwise, retrieve all DESCRIPTION entries from the BUG_AUDITS table for that bug ID, order them by CHANGE_DATE, and combine them into a single string separated by '; '. If no matching audits exist in BUG_AUDITS, return 'No audits found'.",
    "natural_language": "Write a Oracle PL/SQL function named `get_bug_audit_summary` that takes a bug ID and returns a summary. If the bug ID is NULL, return 'Invalid Bug ID'. For a valid bug ID, retrieve all DESCRIPTION entries from the BUG_AUDITS table for that bug, order them by CHANGE_DATE, and combine them into a single string separated by '; '. If no audits exist for the bug ID, return 'No audits found'.",
    "id": 27,
    "generated_ir": "Write an Oracle PL/SQL function named get_bug_audit_summary that accepts a single parameter p_bug_id of type NUMBER, which represents the unique identifier of a bug. The function returns a VARCHAR2 string containing a summary of audit descriptions for the specified bug. Inside the function, a local variable v_summary of type VARCHAR2 is declared to store the final result string. The function first checks if the input parameter p_bug_id is NULL. If p_bug_id is NULL, the function immediately returns the string 'Invalid Bug ID'. If p_bug_id is not NULL, the function proceeds to execute a SELECT statement. This SELECT statement uses the LISTAGG aggregate function to combine all DESCRIPTION column values from the BUG_AUDITS table. The LISTAGG function concatenates the DESCRIPTION values, separating each value with the delimiter '; '. The concatenation is performed in the order specified by the CHANGE_DATE column, sorted in ascending order. The SELECT statement includes a WHERE clause that filters rows from the BUG_AUDITS table where the BUG_ID column matches the value of the input parameter p_bug_id. The result of the LISTAGG operation is stored directly into the v_summary variable. After the SELECT statement, the function checks if the v_summary variable is NULL. If v_summary is NULL, it indicates that no rows were found in the BUG_AUDITS table for the given bug ID. In this case, the function returns the string 'No audits found'. If v_summary is not NULL, the function returns the value of v_summary, which is the concatenated string of all audit descriptions for the specified bug ID, ordered by change date.",
    "original_summary": "Create a PL/SQL function named `get_bug_audit_summary` that accepts a bug ID (NUMBER) and returns a VARCHAR2 summary. If the ID is NULL, return 'Invalid Bug ID'. Otherwise, query the BUG_AUDITS table to concatenate the DESCRIPTION values for that bug, ordered by CHANGE_DATE, separated by '; '. If no audits are found, return 'No audits found'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Make a function `get_bug_audit_summary` that takes a bug ID and returns a summary. Return 'Invalid Bug ID' for NULL input. For a valid ID, fetch and join all DESCRIPTIONs from BUG_AUDITS for that bug, ordered by CHANGE_DATE and separated by '; '. Return 'No audits found' if none exist."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_households_in_state that accepts a single input parameter named state_name of type VARCHAR2 and returns a value of type NUMBER; within the function, declare a local variable named total_households of type NUMBER; then execute a SELECT statement that retrieves the sum of all values in the TOTAL_HOUSEHOLDS column from the REGIONS table, specifically for rows where the value in the STATE column is equal to the provided state_name parameter value; store the result of this summation into the local variable total_households; finally, return the value contained in the total_households variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_households_in_state(state_name VARCHAR2) RETURN NUMBER IS\n  total_households NUMBER;\nBEGIN\n  SELECT SUM(TOTAL_HOUSEHOLDS)\n  INTO total_households\n  FROM REGIONS\n  WHERE STATE = state_name;\n  RETURN total_households;\nEND;",
    "database_name": "real_emaahd_management",
    "tables": [
      "REGIONS",
      "ECONOMIC_INDICATORS",
      "COMPARATIVE_ANALYSES",
      "ALERTS"
    ],
    "call_sqls": [
      "SELECT get_total_households_in_state('California') FROM dual",
      "SELECT get_total_households_in_state('Texas') FROM dual",
      "SELECT get_total_households_in_state('New York') FROM dual",
      "SELECT get_total_households_in_state('Florida') FROM dual",
      "SELECT get_total_households_in_state('Illinois') FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_total_households_in_state that, given a state_name, returns the total sum of TOTAL_HOUSEHOLDS from the REGIONS table for all records where the STATE matches the provided state_name.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called get_total_households_in_state? It should take a state name as input and return the total number of households from the REGIONS table for that state, all added up.",
    "id": 28,
    "generated_ir": "Write an Oracle PL/SQL function named get_total_households_in_state that accepts a single input parameter named state_name of type VARCHAR2 and returns a value of type NUMBER; within the function, declare a local variable named total_households of type NUMBER; then execute a SELECT statement that retrieves the sum of all values in the TOTAL_HOUSEHOLDS column from the REGIONS table, specifically for rows where the value in the STATE column is equal to the provided state_name parameter value; store the result of this summation into the local variable total_households; finally, return the value contained in the total_households variable as the function's result.",
    "original_summary": "Create a PL/SQL function named get_total_households_in_state that accepts a state_name (VARCHAR2) and returns the sum of TOTAL_HOUSEHOLDS from the REGIONS table for the given state.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called get_total_households_in_state? It should take a state name as input and spit back the total number of households from the REGIONS table for that state, all added up."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_max_forecast_temp` that is designed to return a single numeric value. This function declares a local variable named `v_max_temp` of type `NUMBER` to temporarily store the result of a database query. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement queries the `FORECAST_DATA` table and calculates the maximum value present in the `MAX_TEMP` column across all rows within that table. The result of this aggregation, specifically the single maximum `MAX_TEMP` value, is then immediately assigned to the local variable `v_max_temp` using the `INTO` clause. Finally, the function concludes its execution by returning the value currently held by the `v_max_temp` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_forecast_temp RETURN NUMBER IS\n    v_max_temp NUMBER;\nBEGIN\n    SELECT MAX(MAX_TEMP) INTO v_max_temp FROM FORECAST_DATA;\n    RETURN v_max_temp;\nEND;",
    "database_name": "global_wdcaa_967493",
    "tables": [
      "CITIES",
      "FORECAST_DATA",
      "HISTORICAL_DATA",
      "WEATHER_DATA",
      "WEATHER_OBSERVATIONS",
      "WEATHER_STATIONS",
      "ACCESS_LOGS",
      "USERS"
    ],
    "call_sqls": [
      "SELECT get_max_forecast_temp FROM DUAL",
      "SELECT get_max_forecast_temp() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_max_forecast_temp;\n  DBMS_OUTPUT.PUT_LINE('Max forecast temp: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Maximum forecast temperature is: ' || get_max_forecast_temp);\nEND;",
      "SELECT city_name, max_temp FROM forecast_data fd\nJOIN cities c ON fd.city_id = c.city_id\nWHERE max_temp = get_max_forecast_temp"
    ],
    "summary": "Write a Oracle PL/SQL function named get_max_forecast_temp that returns the highest temperature value from the MAX_TEMP column in the FORECAST_DATA table as a number.",
    "natural_language": "Write a Oracle PL/SQL function named get_max_forecast_temp that returns the maximum value from the MAX_TEMP column in the FORECAST_DATA table.",
    "id": 29,
    "generated_ir": "Write an Oracle PL/SQL function named get_max_forecast_temp that accepts no input parameters and returns a NUMBER. The function declares a local variable v_max_temp of type NUMBER to store the result of a query. The function executes a SELECT statement that retrieves the maximum value from the MAX_TEMP column in the FORECAST_DATA table. The result of this aggregation is stored in the v_max_temp variable. The query includes a FETCH FIRST 1 ROW ONLY clause to limit the result set to a single row, which is redundant for an aggregate function like MAX but ensures a single row is returned. Finally, the function returns the value stored in v_max_temp, which represents the highest temperature recorded in the MAX_TEMP column of the FORECAST_DATA table.",
    "original_summary": "Create a PL/SQL function named get_max_forecast_temp that returns the maximum value of the MAX_TEMP column from the FORECAST_DATA table as a number.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the maximum value in the MAX_TEMP column of the FORECAST_DATA table?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored function named `get_average_home_team_score` that is designed to return a single numerical value representing the average score of the home team across all games recorded in the database. This function does not accept any input parameters. Internally, it declares a local variable named `v_avg_home_score` of data type `NUMBER` to temporarily store the calculated average. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement calculates the average (`AVG`) of the values in the `HOME_TEAM_SCORE` column. The `HOME_TEAM_SCORE` column is retrieved from the `GAMES` table. The result of this average calculation is then immediately stored into the `v_avg_home_score` local variable. Finally, the function returns the value currently held by the `v_avg_home_score` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_home_team_score RETURN NUMBER IS\nv_avg_home_score NUMBER;\nBEGIN\nSELECT AVG(HOME_TEAM_SCORE) INTO v_avg_home_score FROM GAMES;\nRETURN v_avg_home_score;\nEND;",
    "database_name": "sports_tpas_506836",
    "tables": [
      "GAMES",
      "TEAMS",
      "TEAM_STANDINGS"
    ],
    "call_sqls": [
      "SELECT get_average_home_team_score FROM DUAL",
      "SELECT get_average_home_team_score() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_average_home_team_score;\n  DBMS_OUTPUT.PUT_LINE('Average: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Average home team score: ' || get_average_home_team_score);\nEND;",
      "SELECT get_average_home_team_score AS avg_home_score FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_average_home_team_score that returns the average value of the HOME_TEAM_SCORE column from the GAMES table.",
    "natural_language": "Write a Oracle PL/SQL function named get_average_home_team_score that returns the average value of the HOME_TEAM_SCORE column from the GAMES table.",
    "id": 30,
    "generated_ir": "Write an Oracle PL/SQL function named get_average_home_team_score that returns a numeric value representing the average of the HOME_TEAM_SCORE column from the GAMES table. The function does not accept any input parameters. Within the function, it declares a local numeric variable named avg_score to store the computed average. The core operation involves executing a SELECT statement that queries the GAMES table to calculate the average of the HOME_TEAM_SCORE column using the AVG aggregate function. This SELECT statement retrieves the result directly into the avg_score variable. Finally, the function returns the value stored in the avg_score variable as its output.",
    "original_summary": "Create a PL/SQL function named `get_average_home_team_score` that returns a NUMBER. It calculates and returns the average value of the HOME_TEAM_SCORE column from the GAMES table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/SQL function, designated as `get_average_home_team_score`, which shall yield a NUMBER data type. This function is required to compute and provide the arithmetic mean of the values contained within the HOME_TEAM_SCORE column of the GAMES table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_item_total_stock that accepts a single parameter p_item_id of type NUMBER, which represents the identifier of an item. The function calculates the total stock for the specified item by performing a SELECT operation on the item_sizes table. It retrieves the sum of the stock column values for all rows where the item_id column matches the provided p_item_id parameter. The result of this aggregation is stored in a local variable v_total_stock of type NUMBER. The function then returns the value of v_total_stock, which represents the total stock quantity for the given item_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_item_total_stock(p_item_id NUMBER) RETURN NUMBER IS\n    v_total_stock NUMBER;\nBEGIN\n    SELECT SUM(stock) INTO v_total_stock FROM item_sizes WHERE item_id = p_item_id;\n    RETURN v_total_stock;\nEND;",
    "database_name": "clothing_ssaim_738508",
    "tables": [
      "CLOTHING_ITEMS",
      "ITEM_SIZES",
      "SIZES",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "SELECT get_item_total_stock(0) FROM dual",
      "SELECT get_item_total_stock(1) FROM dual",
      "SELECT get_item_total_stock(2) FROM dual",
      "SELECT get_item_total_stock(3) FROM dual",
      "SELECT get_item_total_stock(4) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_item_total_stock that, given a specific item ID as input, calculates and returns the total available stock for that item by summing the stock values from all corresponding entries in the item_sizes table.",
    "natural_language": "Write a Oracle PL/SQL function called `get_item_total_stock` that returns a NUMBER representing the total stock for a given item. It should accept a NUMBER parameter `p_item_id` and calculate the total stock by summing the `stock` column from the `item_sizes` table for all records where the `item_id` matches the provided parameter.",
    "id": 31,
    "generated_ir": "Write an Oracle PL/SQL function named get_item_total_stock that accepts a single parameter p_item_id of type NUMBER, which represents the identifier of an item. The function calculates the total stock for the specified item by performing a SELECT operation on the item_sizes table. It retrieves the sum of the stock column values for all rows where the item_id column matches the provided p_item_id parameter. The result of this aggregation is stored in a local variable v_total_stock of type NUMBER. The function then returns the value of v_total_stock, which represents the total stock quantity for the given item_id.",
    "original_summary": "Create a PL/SQL function named `get_item_total_stock` that returns a NUMBER. It accepts a NUMBER parameter `p_item_id`. The function calculates and returns the sum of the `stock` column from the `item_sizes` table for all rows matching the given `item_id`.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "How can I create a PL/SQL function called `get_item_total_stock` that returns a NUMBER? It should take a NUMBER parameter `p_item_id` and calculate the total stock by summing the `stock` column in the `item_sizes` table for all entries with the matching `item_id`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_high_value_neighborhood that accepts a single input parameter p_neighborhood_id of the NUMBER data type and returns a VARCHAR2 value. The function's purpose is to classify a neighborhood based on the average property value within it. It begins by declaring a local variable v_avg_price of type NUMBER. The function then executes a SELECT statement that calculates the average value of the PROPERTY_VALUE column from the PROPERTIES table, aliased as p, for all rows where the NEIGHBORHOOD_ID column matches the provided input parameter p_neighborhood_id, and stores this computed average into the local variable v_avg_price. Following this data retrieval, the function uses an IF-THEN-ELSE conditional statement to evaluate the value in v_avg_price: if the average property price is greater than 300000, the function returns the string literal 'HIGH'; otherwise, it returns the string literal 'STANDARD'.",
    "plsql": "CREATE OR REPLACE FUNCTION check_high_value_neighborhood(p_neighborhood_id NUMBER) RETURN VARCHAR2 IS\n    v_avg_price NUMBER;\nBEGIN\n    SELECT AVG(p.PROPERTY_VALUE) INTO v_avg_price FROM PROPERTIES p WHERE p.NEIGHBORHOOD_ID = p_neighborhood_id;\n    IF v_avg_price > 300000 THEN\n        RETURN 'HIGH';\n    ELSE\n        RETURN 'STANDARD';\n    END IF;\nEND;",
    "database_name": "real_epaam_956249",
    "tables": [
      "AMENITIES",
      "BASEMENT_INFO",
      "BUILDING_DETAILS",
      "HEATING_INFO",
      "NEIGHBORHOODS",
      "PROPERTIES",
      "PROPERTY_FEATURES",
      "ROOMS_INFO",
      "SALE_HISTORY",
      "USER_ACCOUNTS"
    ],
    "call_sqls": [
      "SELECT check_high_value_neighborhood(0) FROM DUAL",
      "SELECT check_high_value_neighborhood(1) FROM DUAL",
      "SELECT check_high_value_neighborhood(2) FROM DUAL",
      "SELECT check_high_value_neighborhood(3) FROM DUAL",
      "SELECT check_high_value_neighborhood(4) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named check_high_value_neighborhood that accepts a neighborhood ID as input and returns a classification label. It calculates the average PROPERTY_VALUE from the PROPERTIES table for the specified NEIGHBORHOOD_ID. If the average exceeds 300000, the function returns 'HIGH'; otherwise, it returns 'STANDARD'.",
    "natural_language": "Write a Oracle PL/SQL function named check_high_value_neighborhood that, for a given neighborhood ID, calculates the average property value from the PROPERTIES table for that neighborhood and returns 'HIGH' if the average exceeds 300,000, otherwise returns 'STANDARD'.",
    "id": 32,
    "generated_ir": "Write an Oracle PL/SQL function named check_high_value_neighborhood that accepts a single input parameter p_neighborhood_id of the NUMBER data type and returns a VARCHAR2 value. The function's purpose is to classify a neighborhood based on the average property value within it. It begins by declaring a local variable v_avg_price of type NUMBER. The function then executes a SELECT statement that calculates the average value of the PROPERTY_VALUE column from the PROPERTIES table, aliased as p, for all rows where the NEIGHBORHOOD_ID column matches the provided input parameter p_neighborhood_id, and stores this computed average into the local variable v_avg_price. Following this data retrieval, the function uses an IF-THEN-ELSE conditional statement to evaluate the value in v_avg_price: if the average property price is greater than 300000, the function returns the string literal 'HIGH'; otherwise, it returns the string literal 'STANDARD'.",
    "original_summary": "Create a PL/SQL function named check_high_value_neighborhood that accepts a NUMBER parameter p_neighborhood_id and returns a VARCHAR2. Calculate the average PROPERTY_VALUE from the PROPERTIES table for the given neighborhood. If the average is greater than 300000, return 'HIGH'; otherwise, return 'STANDARD'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What should the PL/SQL function named check_high_value_neighborhood return for a given neighborhood ID? The function should calculate the average property value from the PROPERTIES table for that neighborhood and return 'HIGH' if the average exceeds 300,000, otherwise it should return 'STANDARD'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_interaction_label` that accepts a single input parameter, `p_interaction_id`, which is of data type `NUMBER`. The function is designed to return a single value of data type `NUMBER`. Upon execution, the function declares a local variable named `v_label` of data type `NUMBER`. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `LABEL` column of the `INTERACTIONS` table. The retrieved value is then immediately assigned to the local variable `v_label`. The selection of the row from the `INTERACTIONS` table is conditional, based on a `WHERE` clause that specifies `INTERACTION_ID` must be equal to the value provided in the input parameter `p_interaction_id`. After the `SELECT` statement has been executed and the `v_label` variable populated, the function returns the value currently stored in `v_label` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_interaction_label(p_interaction_id NUMBER) RETURN NUMBER IS\n    v_label NUMBER;\nBEGIN\n    SELECT LABEL INTO v_label FROM INTERACTIONS WHERE INTERACTION_ID = p_interaction_id;\n    RETURN v_label;\nEND;",
    "database_name": "customer_iae_tracking",
    "tables": [
      "CAMPAIGNS",
      "CAMPAIGN_INTERACTIONS",
      "INTERACTIONS"
    ],
    "call_sqls": [
      "SELECT get_interaction_label(0) FROM DUAL",
      "SELECT get_interaction_label(1) FROM DUAL",
      "SELECT get_interaction_label(2) FROM DUAL",
      "SELECT get_interaction_label(3) FROM DUAL",
      "SELECT get_interaction_label(4) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_interaction_label that, given an interaction ID as input, retrieves and returns the corresponding LABEL value from the INTERACTIONS table where the INTERACTION_ID matches the provided input.",
    "natural_language": "Write a Oracle PL/SQL function called `get_interaction_label` that takes a `p_interaction_id` parameter and returns the corresponding `LABEL` value from the `INTERACTIONS` table where the `INTERACTION_ID` matches the provided parameter.",
    "id": 33,
    "generated_ir": "Write an Oracle PL/SQL function named get_interaction_label that accepts a single input parameter, p_interaction_id, which is of data type NUMBER. This function is designed to return a VARCHAR2 value representing the LABEL of a specific interaction from the INTERACTIONS table in the customer_iae_tracking database. Upon execution, the function first declares a local variable named v_label of data type VARCHAR2 with a maximum length of 255 characters to temporarily store the retrieved label value. The function then performs a SELECT operation to retrieve the LABEL column from the INTERACTIONS table. This selection is filtered by a WHERE clause, which specifies that only the row where the INTERACTION_ID column matches the value provided in the p_interaction_id input parameter should be considered. The retrieved LABEL value is then immediately assigned to the v_label local variable. Following this data retrieval, the function returns the value stored in the v_label variable.",
    "original_summary": "Create a PL/SQL function named `get_interaction_label` that accepts a NUMBER parameter `p_interaction_id` and returns a NUMBER. It retrieves the `LABEL` value from the `INTERACTIONS` table where `INTERACTION_ID` matches the input parameter and returns it.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called `get_interaction_label` that takes a NUMBER parameter `p_interaction_id` and returns a NUMBER. Fetch the `LABEL` from the `INTERACTIONS` table for the matching `INTERACTION_ID` and return that value."
  },
  {
    "ir": "Write an Oracle PL/SQL function named is_prerequisite_met that accepts two parameters: p_student_id of type NUMBER, representing the unique identifier of a student, and p_course_id of type NUMBER, representing the unique identifier of a course. The function returns a VARCHAR2 value indicating whether the prerequisites for the specified course are met by the student. The function begins by declaring two local variables: v_prerequisite_count and v_completed_count, both of type NUMBER. It first executes a SELECT statement to count the total number of prerequisites for the course identified by p_course_id from the COURSE_PREREQUISITES table, storing the result in v_prerequisite_count. If v_prerequisite_count is zero, indicating that the course has no prerequisites, the function immediately returns 'MET'. Otherwise, the function proceeds to count the number of distinct prerequisite courses that the student, identified by p_student_id, has completed with a passing grade. This is done by performing a SELECT statement with an INNER JOIN between the COURSE_PREREQUISITES table and the ENROLLMENTS table, where the PREREQUISITE_COURSE_ID from COURSE_PREREQUISITES matches the COURSE_ID in ENROLLMENTS, the COURSE_ID in COURSE_PREREQUISITES matches p_course_id, the STUDENT_ID in ENROLLMENTS matches p_student_id, and the GRADE in ENROLLMENTS is one of 'A', 'B', 'C', 'D', or 'P'. The count of these completed prerequisites is stored in v_completed_count. The function then compares v_completed_count with v_prerequisite_count; if they are equal, it returns 'MET', indicating that the student has met all prerequisites. If not, it returns 'NOT_MET'. The function includes exception handling for NO_DATA_FOUND, returning 'NOT_MET' if no data is found, and re-raises any other exceptions.",
    "plsql": "CREATE OR REPLACE FUNCTION is_prerequisite_met(p_student_id NUMBER, p_course_id NUMBER) RETURN VARCHAR2 IS\n    v_prerequisite_count NUMBER;\n    v_completed_count NUMBER;\nBEGIN\n    -- Count total prerequisites for this course\n    SELECT COUNT(*)\n    INTO v_prerequisite_count\n    FROM COURSE_PREREQUISITES\n    WHERE COURSE_ID = p_course_id;\n    \n    -- If no prerequisites, requirement is met\n    IF v_prerequisite_count = 0 THEN\n        RETURN 'MET';\n    END IF;\n    \n    -- Count how many prerequisites the student has completed with a passing grade\n    SELECT COUNT(DISTINCT cp.PREREQUISITE_COURSE_ID)\n    INTO v_completed_count\n    FROM COURSE_PREREQUISITES cp\n    INNER JOIN ENROLLMENTS e ON cp.PREREQUISITE_COURSE_ID = e.COURSE_ID\n    WHERE cp.COURSE_ID = p_course_id\n      AND e.STUDENT_ID = p_student_id\n      AND e.GRADE IN ('A', 'B', 'C', 'D', 'P'); -- Assuming these are passing grades\n    \n    -- Compare completed prerequisites with total prerequisites\n    IF v_completed_count = v_prerequisite_count THEN\n        RETURN 'MET';\n    ELSE\n        RETURN 'NOT_MET';\n    END IF;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN 'NOT_MET';\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "university_cmars_444320",
    "tables": [
      "COURSES",
      "COURSE_MATERIALS",
      "COURSE_PREREQUISITES",
      "ENROLLMENTS",
      "WAITLISTS",
      "MAJORS"
    ],
    "call_sqls": [
      "SELECT is_prerequisite_met(100, 1) FROM dual",
      "SELECT is_prerequisite_met(200, 5) FROM dual",
      "SELECT is_prerequisite_met(150, 3) FROM dual",
      "SELECT is_prerequisite_met(300, 0) FROM dual",
      "SELECT is_prerequisite_met(250, 2) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named is_prerequisite_met that accepts a student ID and a course ID, and returns 'MET' if the student has completed all prerequisites for that course with a passing grade from the ENROLLMENTS table, otherwise returns 'NOT_MET'. The function should check the COURSE_PREREQUISITES table to determine the total prerequisites for the course; if there are none, it returns 'MET'. It then counts how many of those prerequisites the student has completed with a grade of 'A', 'B', 'C', 'D', or 'P' in ENROLLMENTS, and returns 'MET' only if the completed count matches the total prerequisite count.",
    "natural_language": "Write a Oracle PL/SQL function named is_prerequisite_met that takes a student ID and a course ID, and returns 'MET' if the student has passed all prerequisites for that course in the COURSE_PREREQUISITES and ENROLLMENTS tables, otherwise returns 'NOT_MET', handling cases where no data is found.",
    "id": 34,
    "generated_ir": "Write an Oracle PL/SQL function named is_prerequisite_met that accepts two parameters: p_student_id of type NUMBER, representing the unique identifier of a student, and p_course_id of type NUMBER, representing the unique identifier of a course. The function returns a VARCHAR2 value indicating whether the prerequisites for the specified course are met by the student. The function begins by declaring two local variables: v_prerequisite_count and v_completed_count, both of type NUMBER. It first executes a SELECT statement to count the total number of prerequisites for the course identified by p_course_id from the COURSE_PREREQUISITES table, storing the result in v_prerequisite_count. If v_prerequisite_count is zero, indicating that the course has no prerequisites, the function immediately returns 'MET'. Otherwise, the function proceeds to count the number of distinct prerequisite courses that the student, identified by p_student_id, has completed with a passing grade. This is done by performing a SELECT statement with an INNER JOIN between the COURSE_PREREQUISITES table and the ENROLLMENTS table, where the PREREQUISITE_COURSE_ID from COURSE_PREREQUISITES matches the COURSE_ID in ENROLLMENTS, the COURSE_ID in COURSE_PREREQUISITES matches p_course_id, the STUDENT_ID in ENROLLMENTS matches p_student_id, and the GRADE in ENROLLMENTS is one of 'A', 'B', 'C', 'D', or 'P'. The count of these completed prerequisites is stored in v_completed_count. The function then compares v_completed_count with v_prerequisite_count; if they are equal, it returns 'MET', indicating that the student has met all prerequisites. If not, it returns 'NOT_MET'. The function includes exception handling for NO_DATA_FOUND, returning 'NOT_MET' if no data is found, and re-raises any other exceptions.",
    "original_summary": "Create a PL/SQL function named is_prerequisite_met that accepts a student ID and a course ID (both NUMBER) and returns 'MET' if the student has completed all prerequisites for the course with a passing grade, otherwise returns 'NOT_MET'. Handle the NO_DATA_FOUND exception.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Make a function is_prerequisite_met. It takes a student ID and course ID. Return 'MET' if all prerequisites are passed, else 'NOT_MET'. Handle NO_DATA_FOUND."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_party_leader_uppercase that takes no input parameters and returns a single VARCHAR2 value. The function declares a local variable v_party_leader of type VARCHAR2 with a maximum length of 255 characters. The function's execution logic performs a SELECT query on the parties table, specifically retrieving the value from the party_leader column for the row where the party_id column is equal to the numeric literal 0. The retrieved value is passed to the UPPER built-in function, which converts all alphabetic characters in the string to their uppercase equivalents, and the result is stored into the local variable v_party_leader. The function then returns the value stored in v_party_leader. The function includes an EXCEPTION handler to catch the NO_DATA_FOUND exception, which occurs if the SELECT statement finds no rows matching the condition party_id = 0; in this case, the handler executes a RETURN statement that yields a NULL value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_party_leader_uppercase\nRETURN VARCHAR2\nIS\n    v_party_leader VARCHAR2(255);\nBEGIN\n    SELECT UPPER(party_leader)\n    INTO v_party_leader\n    FROM parties\n    WHERE party_id = 0;\n    \n    RETURN v_party_leader;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\nEND;",
    "database_name": "election_ravd_analysis",
    "tables": [
      "CANDIDATES",
      "CANDIDATE_REGION",
      "PARTIES",
      "ELECTIONS",
      "PARTY_PERFORMANCE"
    ],
    "call_sqls": [
      "SELECT get_party_leader_uppercase FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE(get_party_leader_uppercase);\nEND;",
      "DECLARE\n  v_result VARCHAR2(255);\nBEGIN\n  v_result := get_party_leader_uppercase;\nEND;",
      "SELECT get_party_leader_uppercase() FROM DUAL",
      "SELECT party_id, party_name, get_party_leader_uppercase AS leader_uppercase FROM parties WHERE party_id = 0"
    ],
    "summary": "Write a Oracle PL/SQL function named get_party_leader_uppercase that returns the uppercase name of the party leader from the PARTIES table for the specific party with PARTY_ID equal to 0, returning NULL if no such party is found.",
    "natural_language": "Write a Oracle PL/SQL function named get_party_leader_uppercase that takes no parameters and returns the name of the party leader from the PARTIES table for the party with PARTY_ID equal to 0, converting the name to uppercase; if no such party is found, return NULL.",
    "id": 35,
    "generated_ir": "Write an Oracle PL/SQL function named get_party_leader_uppercase that takes no input parameters and returns a single VARCHAR2 value. The function declares a local variable v_party_leader of type VARCHAR2 with a maximum length of 255 characters. The function's execution logic performs a SELECT query on the parties table, specifically retrieving the value from the party_leader column for the row where the party_id column is equal to the numeric literal 0. The retrieved value is passed to the UPPER built-in function, which converts all alphabetic characters in the string to their uppercase equivalents, and the result is stored into the local variable v_party_leader. The function then returns the value stored in v_party_leader. The function includes an EXCEPTION handler to catch the NO_DATA_FOUND exception, which occurs if the SELECT statement finds no rows matching the condition party_id = 0; in this case, the handler executes a RETURN statement that yields a NULL value.",
    "original_summary": "Create a PL/SQL function named `get_party_leader_uppercase` with no parameters that returns the uppercase name of the party leader for party ID 0, returning NULL if the party is not found.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/SQL function, designated as `get_party_leader_uppercase`, which accepts no parameters. Its purpose is to retrieve and return the name of the party leader for the party identified by the value 0, converting the name to uppercase. Should the specified party not be located, the function must return a NULL value."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_employment_status that accepts two input parameters: p_id of type NUMBER, which represents the unique identifier of an employee, and p_wage_threshold of type NUMBER, which specifies a wage threshold value. The function returns a VARCHAR2 value indicating the employment status of the employee. Within the function, a local variable v_status of type VARCHAR2(255) is declared to store the result of the employment status determination. The function executes a SELECT statement to retrieve data from the EMPLOYMENT table, specifically targeting the row where the ID column matches the value of the p_id parameter. The SELECT statement uses a CASE expression to evaluate the employment status based on two conditions: if the EMPLOYED column equals 1 and the WAGE column exceeds the value of p_wage_threshold, the CASE expression assigns the string 'ACTIVE' to v_status; otherwise, it assigns 'INACTIVE'. The result of this evaluation is stored into the v_status variable using the INTO clause. Finally, the function returns the value of v_status, which represents the employment status of the employee as either 'ACTIVE' or 'INACTIVE' based on the specified conditions.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employment_status(p_id NUMBER, p_wage_threshold NUMBER) RETURN VARCHAR2 IS\n    v_status VARCHAR2(255);\nBEGIN\n    SELECT CASE WHEN EMPLOYED = 1 AND WAGE > p_wage_threshold THEN 'ACTIVE'\n                ELSE 'INACTIVE' END\n    INTO v_status\n    FROM EMPLOYMENT\n    WHERE ID = p_id;\n    RETURN v_status;\nEND;",
    "database_name": "demographic_aeda_192071",
    "tables": [
      "DEMOGRAPHICS",
      "EMPLOYMENT",
      "FINANCIAL_AID",
      "HOUSEHOLD"
    ],
    "call_sqls": [
      "SELECT get_employment_status(0, 20) FROM DUAL",
      "SELECT get_employment_status(1, 10) FROM DUAL",
      "SELECT get_employment_status(0, 25) FROM DUAL",
      "SELECT get_employment_status(1, 5) FROM DUAL",
      "SELECT get_employment_status(0, 15) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_employment_status that, given an employee ID and a wage threshold, determines the employment status by checking the EMPLOYMENT table. It returns 'ACTIVE' if the employee's EMPLOYED flag is 1 and their WAGE exceeds the provided threshold; otherwise, it returns 'INACTIVE'.",
    "natural_language": "Write a Oracle PL/SQL function called get_employment_status that returns a status based on an employee's employment and wage. Given an employee ID and a wage cutoff, it checks the EMPLOYMENT table for that ID and returns 'ACTIVE' if the employee is employed (EMPLOYED equals 1) and their WAGE is above the cutoff; otherwise, it returns 'INACTIVE'.",
    "id": 36,
    "generated_ir": "Write an Oracle PL/SQL function named get_employment_status that accepts two input parameters: p_id of type NUMBER, which represents the unique identifier of an employee, and p_wage_threshold of type NUMBER, which specifies a wage threshold value. The function returns a VARCHAR2 value indicating the employment status of the employee. Within the function, a local variable v_status of type VARCHAR2(255) is declared to store the result of the employment status determination. The function executes a SELECT statement to retrieve data from the EMPLOYMENT table, specifically targeting the row where the ID column matches the value of the p_id parameter. The SELECT statement uses a CASE expression to evaluate the employment status based on two conditions: if the EMPLOYED column equals 1 and the WAGE column exceeds the value of p_wage_threshold, the CASE expression assigns the string 'ACTIVE' to v_status; otherwise, it assigns 'INACTIVE'. The result of this evaluation is stored into the v_status variable using the INTO clause. Finally, the function returns the value of v_status, which represents the employment status of the employee as either 'ACTIVE' or 'INACTIVE' based on the specified conditions.",
    "original_summary": "Create a PL/SQL function named get_employment_status that returns a VARCHAR2. It accepts an employee ID and a wage threshold as NUMBER parameters. The function queries the EMPLOYMENT table for the given ID and returns 'ACTIVE' if the employee is employed (EMPLOYED = 1) and their WAGE exceeds the threshold, otherwise returns 'INACTIVE'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called get_employment_status that gives back a VARCHAR2. It takes an employee ID and a sort of wage cutoff as NUMBER inputs. The function should check the EMPLOYMENT table for that ID and give back 'ACTIVE' if the person is basically employed (like when EMPLOYED is set to 1) and their pay is kind of above that cutoff point. If not, it should just return 'INACTIVE'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_lab_test_summary that accepts a single input parameter p_patient_id of type NUMBER, which represents the unique identifier for a patient, and returns a VARCHAR2 string. The function begins by declaring three local variables: v_normal_tests as a NUMBER, v_abnormal_tests as a NUMBER, and v_summary as a VARCHAR2 with a maximum length of 4000 characters. The function's logic first executes a SELECT statement to query the LAB_TESTS table, counting all rows where the PATIENT_ID column equals the input p_patient_id and the RESULT_STATUS column has the exact string value 'normal', and stores this count in the variable v_normal_tests. It then executes a second SELECT statement on the same LAB_TESTS table, counting all rows where the PATIENT_ID column equals the input p_patient_id and the RESULT_STATUS column has the exact string value 'abnormal', storing this count in the variable v_abnormal_tests. Following these queries, the function uses an IF-THEN-ELSE conditional statement to compare the two counts: if v_normal_tests is greater than v_abnormal_tests, it assigns the string 'More Normal Tests. ' to the v_summary variable; otherwise, it assigns the string 'More Abnormal Tests. ' to v_summary. The function then uses a second IF-THEN-ELSE conditional to evaluate the count of abnormal tests: if v_abnormal_tests is greater than 5, it concatenates the string 'High Abnormal Test Count.' to the existing value of v_summary using the concatenation operator; otherwise, it concatenates the string 'Normal Abnormal Test Count.' to the existing v_summary value. Finally, the function returns the fully constructed v_summary string.",
    "plsql": "CREATE OR REPLACE FUNCTION get_lab_test_summary(p_patient_id NUMBER) RETURN VARCHAR2 IS\n    v_normal_tests NUMBER;\n    v_abnormal_tests NUMBER;\n    v_summary VARCHAR2(4000);\nBEGIN\n    SELECT COUNT(*) INTO v_normal_tests FROM LAB_TESTS WHERE PATIENT_ID = p_patient_id AND RESULT_STATUS = 'normal';\n    SELECT COUNT(*) INTO v_abnormal_tests FROM LAB_TESTS WHERE PATIENT_ID = p_patient_id AND RESULT_STATUS = 'abnormal';\n    IF v_normal_tests > v_abnormal_tests THEN\n        v_summary := 'More Normal Tests. ';\n    ELSE\n        v_summary := 'More Abnormal Tests. ';\n    END IF;\n    IF v_abnormal_tests > 5 THEN\n        v_summary := v_summary || 'High Abnormal Test Count.';\n    ELSE\n        v_summary := v_summary || 'Normal Abnormal Test Count.';\n    END IF;\n    RETURN v_summary;\nEND;",
    "database_name": "healthcare_dmadr_assessme",
    "tables": [
      "PATIENTS",
      "APPOINTMENTS",
      "DOCTORS",
      "HEALTH_METRICS",
      "LAB_TESTS",
      "DIABETES_RISK_SCORES"
    ],
    "call_sqls": [
      "SELECT get_lab_test_summary(0) FROM DUAL",
      "SELECT get_lab_test_summary(1) FROM DUAL",
      "SELECT get_lab_test_summary(100) FROM DUAL",
      "SELECT get_lab_test_summary(PATIENT_ID) FROM PATIENTS WHERE PATIENT_ID = 0",
      "SELECT p.PATIENT_ID, get_lab_test_summary(p.PATIENT_ID) AS TEST_SUMMARY FROM PATIENTS p WHERE p.PATIENT_ID = 1"
    ],
    "summary": "Write a Oracle PL/SQL function named get_lab_test_summary that, given a patient ID, returns a summary string based on the patient's lab tests from the LAB_TESTS table. The function should count the number of tests where RESULT_STATUS is 'normal' and where RESULT_STATUS is 'abnormal' for that PATIENT_ID. If the count of normal tests is greater than the count of abnormal tests, the summary should start with 'More Normal Tests. '; otherwise, it should start with 'More Abnormal Tests. '. Then, if the count of abnormal tests exceeds 5, append 'High Abnormal Test Count.' to the summary; otherwise, append 'Normal Abnormal Test Count.'.",
    "natural_language": "Write a Oracle PL/SQL function called get_lab_test_summary that takes a patient ID and returns a summary text. For the given patient ID, count how many lab results from the LAB_TESTS table have a RESULT_STATUS of 'normal' and how many have 'abnormal'. If the normal count is higher, start the summary with 'More Normal Tests.'; otherwise, use 'More Abnormal Tests.'. Then, if the abnormal count is greater than 5, append 'High Abnormal Test Count.'; otherwise, append 'Normal Abnormal Test Count.'.",
    "id": 37,
    "generated_ir": "Write an Oracle PL/SQL function named get_lab_test_summary that accepts a single input parameter p_patient_id of type NUMBER, which represents the unique identifier for a patient, and returns a VARCHAR2 string. The function begins by declaring three local variables: v_normal_tests as a NUMBER, v_abnormal_tests as a NUMBER, and v_summary as a VARCHAR2 with a maximum length of 4000 characters. The function's logic first executes a SELECT statement to query the LAB_TESTS table, counting all rows where the PATIENT_ID column equals the input p_patient_id and the RESULT_STATUS column has the exact string value 'normal', and stores this count in the variable v_normal_tests. It then executes a second SELECT statement on the same LAB_TESTS table, counting all rows where the PATIENT_ID column equals the input p_patient_id and the RESULT_STATUS column has the exact string value 'abnormal', storing this count in the variable v_abnormal_tests. Following these queries, the function uses an IF-THEN-ELSE conditional statement to compare the two counts: if v_normal_tests is greater than v_abnormal_tests, it assigns the string 'More Normal Tests. ' to the v_summary variable; otherwise, it assigns the string 'More Abnormal Tests. ' to v_summary. The function then uses a second IF-THEN-ELSE conditional to evaluate the count of abnormal tests: if v_abnormal_tests is greater than 5, it concatenates the string 'High Abnormal Test Count.' to the existing value of v_summary using the concatenation operator; otherwise, it concatenates the string 'Normal Abnormal Test Count.' to the existing v_summary value. Finally, the function returns the fully constructed v_summary string.",
    "original_summary": "Create a PL/SQL function named get_lab_test_summary that accepts a patient ID number and returns a summary string. Count the patient's normal and abnormal lab tests. If normal tests exceed abnormal, start the summary with 'More Normal Tests.', otherwise 'More Abnormal Tests.'. Then, if abnormal tests exceed 5, append 'High Abnormal Test Count.', otherwise append 'Normal Abnormal Test Count.'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Create a PL/SQL function called get_lab_test_summary that takes a patient ID and gives back a summary text. Figure out roughly how many of the patient's lab results are okay and how many are not so good. If the okay ones seem to be a fair bit higher, start the summary with something like 'More Normal Tests.', otherwise use 'More Abnormal Tests.'. Then, if the not-so-good count looks particularly high, say over 5 or so, tack on 'High Abnormal Test Count.', otherwise just put 'Normal Abnormal Test Count.'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_hyperparameter_value` that accepts a single input parameter, `p_param_name`, which is of data type `VARCHAR2`. This function is designed to return a `VARCHAR2` value representing the most recently created value for a specified hyperparameter. Internally, the function declares a local variable `v_param_value` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the retrieved hyperparameter value. The core operation involves a `SELECT` statement that retrieves the `PARAMETER_VALUE` column from the `HYPERPARAMETERS` table. The selection is filtered by two conditions in the `WHERE` clause. The first condition `LOWER(hp.PARAMETER_NAME) = LOWER(p_param_name)` ensures that the `PARAMETER_NAME` column in the `HYPERPARAMETERS` table, after being converted to lowercase using the `LOWER()` function, matches the input parameter `p_param_name`, also converted to lowercase using the `LOWER()` function, thereby performing a case-insensitive comparison. The second condition `hp.CREATED_AT = (SELECT MAX(CREATED_AT) FROM HYPERPARAMETERS WHERE LOWER(PARAMETER_NAME) = LOWER(p_param_name))` identifies the most recent entry for the matching hyperparameter. This is achieved by a subquery that selects the maximum `CREATED_AT` value from the `HYPERPARAMETERS` table, where the `PARAMETER_NAME` (case-insensitively matched with `p_param_name`) corresponds to the same hyperparameter. The `PARAMETER_VALUE` corresponding to this most recent entry is then assigned to the `v_param_value` variable. Finally, the function returns the value stored in `v_param_value`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_hyperparameter_value(p_param_name IN VARCHAR2) RETURN VARCHAR2 IS\n    v_param_value VARCHAR2(255);\nBEGIN\n    SELECT hp.PARAMETER_VALUE INTO v_param_value\n    FROM HYPERPARAMETERS hp\n    WHERE LOWER(hp.PARAMETER_NAME) = LOWER(p_param_name)\n    AND hp.CREATED_AT = (SELECT MAX(CREATED_AT) FROM HYPERPARAMETERS WHERE LOWER(PARAMETER_NAME) = LOWER(p_param_name));\n    RETURN v_param_value;\nEND;",
    "database_name": "machine_lmo_metrics",
    "tables": [
      "ITERATIONS",
      "HYPERPARAMETERS",
      "PERFORMANCE_METRICS"
    ],
    "call_sqls": [
      "SELECT get_hyperparameter_value('learning_rate') FROM DUAL",
      "SELECT get_hyperparameter_value('batch_size') FROM DUAL",
      "SELECT get_hyperparameter_value('epochs') FROM DUAL",
      "SELECT get_hyperparameter_value('dropout_rate') FROM DUAL",
      "SELECT get_hyperparameter_value('optimizer') FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_hyperparameter_value that accepts a parameter name and returns the most recent parameter value for that name from the HYPERPARAMETERS table, using a case-insensitive comparison on the PARAMETER_NAME column, where the most recent value is determined by the latest CREATED_AT timestamp.",
    "natural_language": "Write a Oracle PL/SQL function named get_hyperparameter_value that returns the most recent PARAMETER_VALUE from the HYPERPARAMETERS table for a given parameter name, performing a case-insensitive comparison on PARAMETER_NAME.",
    "id": 38,
    "generated_ir": "Write an Oracle PL/SQL function named get_hyperparameter_value that accepts an input parameter p_parameter_name of type VARCHAR2 and returns a VARCHAR2. The function queries the HYPERPARAMETERS table to retrieve the most recent PARAMETER_VALUE for a given parameter name. The function performs a case-insensitive comparison on the PARAMETER_NAME column by using the UPPER function to convert both the column value and the input parameter to uppercase, ensuring the match is not sensitive to letter case. To determine the most recent record, the function orders the results by the CREATED_AT column in descending order, assuming this column stores the timestamp of when the record was created. The query uses the FETCH FIRST 1 ROWS ONLY clause to retrieve only the top row, which represents the most recent entry. The retrieved PARAMETER_VALUE is stored into a local variable v_parameter_value of type VARCHAR2 using the INTO clause. If a matching record is found, the function returns the value of v_parameter_value. If no records are found for the specified parameter name, the NO_DATA_FOUND exception is caught, and the function returns NULL. The function operates within the machine_lmo_metrics database.",
    "original_summary": "Create a function named get_hyperparameter_value that accepts a parameter name (VARCHAR2) and returns the most recent parameter value (VARCHAR2) for that name from the HYPERPARAMETERS table, using a case-insensitive comparison.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the most recent parameter value for a given name from the HYPERPARAMETERS table, using a case-insensitive comparison?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_author_h_index` that accepts a single input parameter, `p_author_id`, which is of data type `NUMBER` and represents the unique identifier for an author. This function is designed to return a single value of data type `NUMBER`, which will be the H-index of the specified author.\n\nUpon execution, the function declares a local variable named `v_h_index` of data type `NUMBER` to temporarily store the retrieved H-index value. The core operation involves a `SELECT` statement that attempts to retrieve the value from the `H_INDEX` column. This retrieval is performed from the `AUTHORS` table. The selection is conditional, specifically targeting rows where the value in the `AUTHOR_ID` column of the `AUTHORS` table exactly matches the value provided in the input parameter `p_author_id`. The retrieved `H_INDEX` value is then immediately assigned to the local variable `v_h_index`.\n\nFollowing the successful retrieval and assignment, the function proceeds to return the value currently stored in `v_h_index` as its output.\n\nThe function also incorporates an exception handling block. Specifically, it includes a `WHEN NO_DATA_FOUND THEN` clause. This clause is activated if the `SELECT` statement fails to find any rows in the `AUTHORS` table that satisfy the condition `AUTHOR_ID = p_author_id`. In such an event, meaning no author with the given `p_author_id` exists in the `AUTHORS` table, the function will return a `NULL` value as its output, indicating that an H-index could not be found for the specified author.",
    "plsql": "CREATE OR REPLACE FUNCTION get_author_h_index(p_author_id NUMBER) RETURN NUMBER IS\n    v_h_index NUMBER;\nBEGIN\n    SELECT H_INDEX INTO v_h_index FROM AUTHORS WHERE AUTHOR_ID = p_author_id;\n    RETURN v_h_index;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\nEND;",
    "database_name": "academic_rpmac_tracking",
    "tables": [
      "AUTHORS",
      "CITATIONS",
      "CITATION_METRICS",
      "PUBLICATIONS"
    ],
    "call_sqls": [
      "SELECT get_author_h_index(0) FROM dual",
      "SELECT get_author_h_index(1) FROM dual",
      "SELECT get_author_h_index(2) FROM dual",
      "SELECT get_author_h_index(3) FROM dual",
      "SELECT get_author_h_index(4) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_author_h_index that accepts an author ID and returns the H-index value directly from the H_INDEX column in the AUTHORS table for that author, returning NULL if no author with the given ID exists.",
    "natural_language": "Write a Oracle PL/SQL function named get_author_h_index that, given an author ID as input, retrieves and returns the H-index value from the H_INDEX column in the AUTHORS table for that author. If the author ID does not exist in the AUTHORS table, the function should return NULL.",
    "id": 39,
    "generated_ir": "Write an Oracle PL/SQL function named `get_author_h_index` that accepts a single input parameter, `p_author_id`, which is of data type `NUMBER` and represents the unique identifier for an author. This function is designed to return a single value of data type `NUMBER`, which will be the H-index of the specified author.\n\nUpon execution, the function declares a local variable named `v_h_index` of data type `NUMBER` to temporarily store the retrieved H-index value. The core operation involves a `SELECT` statement that attempts to retrieve the value from the `H_INDEX` column. This retrieval is performed from the `AUTHORS` table. The selection is conditional, specifically targeting rows where the value in the `AUTHOR_ID` column of the `AUTHORS` table exactly matches the value provided in the input parameter `p_author_id`. The retrieved `H_INDEX` value is then immediately assigned to the local variable `v_h_index`.\n\nFollowing the successful retrieval and assignment, the function proceeds to return the value currently stored in `v_h_index` as its output.\n\nThe function also incorporates an exception handling block. Specifically, it includes a `WHEN NO_DATA_FOUND THEN` clause. This clause is activated if the `SELECT` statement fails to find any rows in the `AUTHORS` table that satisfy the condition `AUTHOR_ID = p_author_id`. In such an event, meaning no author with the given `p_author_id` exists in the `AUTHORS` table, the function will return a `NULL` value as its output, indicating that an H-index could not be found for the specified author.",
    "original_summary": "Create a PL/SQL function named get_author_h_index that accepts an author ID (NUMBER) and returns the H-index (NUMBER) directly from the H_INDEX column in the AUTHORS table. Return NULL if the author is not found.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function, to be named get_author_h_index, which will accept a single input parameter—specifically an author ID provided as a NUMBER—and will then directly retrieve and return the corresponding H-index value, also as a NUMBER, by querying the H_INDEX column within the AUTHORS table. It is important that the function gracefully handles cases where the provided author ID does not exist, returning a NULL value in such instances."
  },
  {
    "ir": "Write an Oracle PL/SQL function named check_traffic_incident that accepts a single parameter, p_incident_id, which is of type NUMBER and represents the unique identifier of an incident. The function returns a VARCHAR2 value. Within the function, a local variable v_result of type VARCHAR2 with a maximum length of 255 characters is declared to store the result of a query operation. The function performs a SELECT statement that retrieves data from the INCIDENTS table, specifically targeting the row where the INCIDENT_ID column matches the value provided in the p_incident_id parameter. The SELECT statement uses a CASE expression to evaluate the IS_TRAFFIC column of the INCIDENTS table. If the value of IS_TRAFFIC is equal to 1, the CASE expression assigns the string 'Traffic Incident' to the v_result variable; otherwise, it assigns the string 'Non-Traffic Incident'. The result of this evaluation is stored in the v_result variable. Finally, the function returns the value stored in v_result, which indicates whether the specified incident is classified as a traffic incident or a non-traffic incident based on the IS_TRAFFIC column's value.",
    "plsql": "CREATE OR REPLACE FUNCTION check_traffic_incident(p_incident_id NUMBER) RETURN VARCHAR2 IS v_result VARCHAR2(255); BEGIN SELECT CASE WHEN i.IS_TRAFFIC = 1 THEN 'Traffic Incident' ELSE 'Non-Traffic Incident' END INTO v_result FROM INCIDENTS i WHERE i.INCIDENT_ID = p_incident_id; RETURN v_result; END;",
    "database_name": "crime_iraa_893763",
    "tables": [
      "INCIDENTS",
      "OFFENSES",
      "OFFENSE_CATEGORIES",
      "OFFENSE_TYPES",
      "INCIDENT_UPDATES"
    ],
    "call_sqls": [
      "SELECT check_traffic_incident(0) FROM dual",
      "SELECT check_traffic_incident(1) FROM dual",
      "SELECT check_traffic_incident(2) FROM dual",
      "SELECT check_traffic_incident(3) FROM dual",
      "SELECT check_traffic_incident(4) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named check_traffic_incident that, given an incident ID, returns 'Traffic Incident' if the IS_TRAFFIC column in the INCIDENTS table for that incident ID equals 1, otherwise returns 'Non-Traffic Incident'.",
    "natural_language": "Write a Oracle PL/SQL function called check_traffic_incident that takes an incident ID and returns either 'Traffic Incident' or 'Non-Traffic Incident' based on the IS_TRAFFIC column in the INCIDENTS table for the given incident ID.",
    "id": 40,
    "generated_ir": "Write an Oracle PL/SQL function named check_traffic_incident that accepts a single input parameter, a numeric or string parameter representing an incident ID, and returns a VARCHAR2 string. The function declares a local variable to hold the value of the IS_TRAFFIC column from the INCIDENTS table. It executes a SELECT statement that retrieves the IS_TRAFFIC column from the INCIDENTS table specifically for the row where the incident ID column matches the input parameter value. The result is stored into the local variable. The function then evaluates the retrieved value: if the IS_TRAFFIC column equals a condition indicating a traffic incident (typically a value like 'Y', 1, or a specific string, though the exact value should be inferred from common practice as 'Y' or 1 if not specified), the function returns the string 'Traffic Incident'. Otherwise, it returns the string 'Non-Traffic Incident'. If no row is found for the given incident ID, the function handles the exception by returning a default value such as 'Incident not found' or allowing an exception to propagate, though the description does not specify this, so it is assumed standard exception handling is applied.",
    "original_summary": "Create a PL/SQL function named check_traffic_incident that accepts an incident ID (NUMBER) and returns 'Traffic Incident' or 'Non-Traffic Incident' (VARCHAR2) based on the IS_TRAFFIC column value in the INCIDENTS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called check_traffic_incident that takes an incident ID (NUMBER) and outputs 'Traffic Incident' or 'Non-Traffic Incident' (VARCHAR2) depending on the IS_TRAFFIC column in the INCIDENTS table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_merchant_fraud_ratio that accepts a single input parameter p_mid of type VARCHAR2, representing a merchant identifier, and returns a NUMBER. The function first queries the PAYMENTS table to count all rows where the MID column equals the provided p_mid, storing this count in a local variable v_total_payments. If this total count is zero, the function immediately returns a ratio of zero. Otherwise, it proceeds to query the PAYMENTS table again, this time performing an inner join with the FRAUD_DETECTION table on the condition that the PAYMENT_ID column from PAYMENTS matches the PAYMENT_ID column in FRAUD_DETECTION. From this joined result set, it counts the rows where the PAYMENTS.MID column equals p_mid and the FRAUD_DETECTION.IS_FRAUDULENT column equals the numeric value 1, storing this fraud count in a local variable v_fraud_payments. If the fraud count is zero, the function returns a ratio of zero. If the fraud count is not zero, the function calculates the ratio by dividing the v_fraud_payments value by the v_total_payments value and returns this computed ratio.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_merchant_fraud_ratio(p_mid VARCHAR2) RETURN NUMBER IS\n    v_total_payments NUMBER;\n    v_fraud_payments NUMBER;\n    v_ratio NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_payments FROM PAYMENTS WHERE MID = p_mid;\n    IF v_total_payments = 0 THEN\n        v_ratio := 0;\n    ELSE\n        SELECT COUNT(*) INTO v_fraud_payments FROM PAYMENTS p JOIN FRAUD_DETECTION fd ON p.PAYMENT_ID = fd.PAYMENT_ID WHERE p.MID = p_mid AND fd.IS_FRAUDULENT = 1;\n        IF v_fraud_payments = 0 THEN\n            v_ratio := 0;\n        ELSE\n            v_ratio := v_fraud_payments / v_total_payments;\n        END IF;\n    END IF;\n    RETURN v_ratio;\nEND;",
    "database_name": "e_cppaf_detection",
    "tables": [
      "PAYMENTS",
      "FRAUD_DETECTION",
      "INSTALLMENT_PLANS",
      "TRANSACTION_FEES",
      "MERCHANT_IDS",
      "PAYMENT_ORIGINS",
      "PAYMENT_GATEWAY_INTEGRATIONS",
      "PAYMENT_METHOD_MANAGEMENT"
    ],
    "call_sqls": [
      "SELECT calculate_merchant_fraud_ratio('1') FROM DUAL",
      "SELECT calculate_merchant_fraud_ratio('2') FROM DUAL",
      "SELECT calculate_merchant_fraud_ratio('3') FROM DUAL",
      "SELECT calculate_merchant_fraud_ratio('4') FROM DUAL",
      "SELECT calculate_merchant_fraud_ratio('5') FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_merchant_fraud_ratio that accepts a merchant ID parameter p_mid and returns the ratio of fraudulent payments to total payments for that merchant from the PAYMENTS table, joining with the FRAUD_DETECTION table on PAYMENT_ID where IS_FRAUDULENT equals 1; if the total payments count is zero or no fraudulent payments are found, return 0.",
    "natural_language": "Write a Oracle PL/SQL function named calculate_merchant_fraud_ratio that, for a given merchant ID (p_mid), returns the ratio of fraudulent payments to total payments for that merchant from the PAYMENTS and FRAUD_DETECTION tables, ensuring it returns 0 when there are no total payments in PAYMENTS or no fraudulent transactions linked via PAYMENT_ID where IS_FRAUDULENT is 1.",
    "id": 41,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_merchant_fraud_ratio that accepts a single input parameter p_mid of type VARCHAR2, representing a merchant identifier, and returns a NUMBER. The function first queries the PAYMENTS table to count all rows where the MID column equals the provided p_mid, storing this count in a local variable v_total_payments. If this total count is zero, the function immediately returns a ratio of zero. Otherwise, it proceeds to query the PAYMENTS table again, this time performing an inner join with the FRAUD_DETECTION table on the condition that the PAYMENT_ID column from PAYMENTS matches the PAYMENT_ID column in FRAUD_DETECTION. From this joined result set, it counts the rows where the PAYMENTS.MID column equals p_mid and the FRAUD_DETECTION.IS_FRAUDULENT column equals the numeric value 1, storing this fraud count in a local variable v_fraud_payments. If the fraud count is zero, the function returns a ratio of zero. If the fraud count is not zero, the function calculates the ratio by dividing the v_fraud_payments value by the v_total_payments value and returns this computed ratio.",
    "original_summary": "Create a PL/SQL function named calculate_merchant_fraud_ratio that accepts a VARCHAR2 parameter p_mid. It calculates the ratio of fraudulent payments to total payments for the merchant. Return 0 if total payments is 0 or if no fraudulent payments are found; otherwise, return the calculated ratio.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the ratio of fraudulent payments to total payments for a specific merchant, and how can I create a PL/SQL function named calculate_merchant_fraud_ratio that accepts a merchant ID (p_mid) to return this value, ensuring it returns 0 when there are no total payments or no fraudulent transactions?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_calculated_value that accepts a single parameter p_data_id of type NUMBER, which serves as an identifier for data records. The function calculates the total sum of values from the CALCULATED_VALUE column in the CALCULATED_PERCENTAGES table, where the DATA_ID column matches the provided p_data_id parameter. It performs a SELECT operation to aggregate the CALCULATED_VALUE entries using the SUM function, storing the result into a local variable v_total of type NUMBER. The function then returns the computed total as a NUMBER.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_calculated_value(p_data_id NUMBER) RETURN NUMBER IS\n  v_total NUMBER;\nBEGIN\n  SELECT SUM(CALCULATED_VALUE) INTO v_total FROM CALCULATED_PERCENTAGES WHERE DATA_ID = p_data_id;\n  RETURN v_total;\nEND;",
    "database_name": "demographic_dcaa_801780",
    "tables": [
      "CALCULATED_PERCENTAGES",
      "DEFINITIONS",
      "ERROR_MARGINS",
      "LABELS",
      "DEMOGRAPHIC_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_total_calculated_value(1) FROM DUAL",
      "SELECT get_total_calculated_value(2) FROM DUAL",
      "SELECT get_total_calculated_value(3) FROM DUAL",
      "SELECT get_total_calculated_value(4) FROM DUAL",
      "SELECT get_total_calculated_value(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_total_calculated_value that, given a data ID, retrieves the sum of the CALCULATED_VALUE column from the CALCULATED_PERCENTAGES table for all records where the DATA_ID matches the provided ID, and returns that total sum.",
    "natural_language": "Write a Oracle PL/SQL function named get_total_calculated_value that returns the total sum of CALCULATED_VALUE from the CALCULATED_PERCENTAGES table for a given DATA_ID, and returns that total as a NUMBER.",
    "id": 42,
    "generated_ir": "Write an Oracle PL/SQL function named get_total_calculated_value that accepts a single parameter p_data_id of type NUMBER, which serves as an identifier for data records. The function calculates the total sum of values from the CALCULATED_VALUE column in the CALCULATED_PERCENTAGES table, where the DATA_ID column matches the provided p_data_id parameter. It performs a SELECT operation to aggregate the CALCULATED_VALUE entries using the SUM function, storing the result into a local variable v_total of type NUMBER. The function then returns the computed total as a NUMBER.",
    "original_summary": "Create a PL/SQL function named get_total_calculated_value that returns a NUMBER. It accepts a data ID (NUMBER). Calculate and return the sum of the CALCULATED_VALUE column from the CALCULATED_PERCENTAGES table where DATA_ID matches the provided ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the total calculated value for a given data ID, and how can I retrieve it as a PL/SQL function that returns a NUMBER?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_region_sales_count that accepts a single input parameter p_region_id of the NUMBER data type and returns a value of the NUMBER data type, which is the count of sales records for the specified region. The function declares a local variable sales_count of type NUMBER to hold the result. The function's logic executes a SELECT statement that queries the SALES table, using the COUNT(*) aggregate function to calculate the total number of rows. The WHERE clause of this SELECT statement filters the rows from the SALES table, including only those rows where the value in the REGION_ID column is exactly equal to the value provided in the input parameter p_region_id. The result of the COUNT(*) operation is then stored into the local variable sales_count using the INTO clause. Finally, the function returns the value stored in the sales_count variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_sales_count(p_region_id NUMBER) RETURN NUMBER IS\n  sales_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO sales_count\n  FROM SALES\n  WHERE REGION_ID = p_region_id;\n  RETURN sales_count;\nEND;",
    "database_name": "e_csaim_292568",
    "tables": [
      "PRODUCTS",
      "PRODUCT_TYPES",
      "SUPPLIERS",
      "INVENTORY",
      "LOW_STOCK_ALERTS",
      "REORDERS",
      "SALES",
      "REGIONS"
    ],
    "call_sqls": [
      "SELECT get_region_sales_count(0) FROM DUAL",
      "SELECT get_region_sales_count(1) FROM DUAL",
      "SELECT get_region_sales_count(2) FROM DUAL",
      "SELECT get_region_sales_count(100) FROM DUAL",
      "SELECT get_region_sales_count(999) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_region_sales_count that, given a region_id, returns the total number of sales records from the SALES table where the REGION_ID matches the provided input.",
    "natural_language": "Write a Oracle PL/SQL function named get_region_sales_count that, given a region_id, returns the total number of sales records from the SALES table where the REGION_ID matches the provided identifier.",
    "id": 43,
    "generated_ir": "Write an Oracle PL/SQL function named get_region_sales_count that accepts a single input parameter p_region_id of the NUMBER data type and returns a value of the NUMBER data type, which is the count of sales records for the specified region. The function declares a local variable sales_count of type NUMBER to hold the result. The function's logic executes a SELECT statement that queries the SALES table, using the COUNT(*) aggregate function to calculate the total number of rows. The WHERE clause of this SELECT statement filters the rows from the SALES table, including only those rows where the value in the REGION_ID column is exactly equal to the value provided in the input parameter p_region_id. The result of the COUNT(*) operation is then stored into the local variable sales_count using the INTO clause. Finally, the function returns the value stored in the sales_count variable as its output.",
    "original_summary": "Create a PL/SQL function named get_region_sales_count that returns a NUMBER. It accepts a region_id NUMBER parameter, counts the sales records for that region from the SALES table, and returns the count.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function, which should be named get_region_sales_count, that is designed to return a value of the NUMBER data type. This function must accept a single input parameter, specifically a region_id that is also of the NUMBER type. Its primary purpose is to meticulously count all the pertinent sales records that are associated with the provided region identifier from the comprehensive SALES table, and then reliably return the final tally as the output."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_category_product_count that accepts a single input parameter named p_category_id of the NUMBER data type, which represents a specific product category identifier, and returns a single value of the NUMBER data type; the function declares a local variable v_count of type NUMBER to hold the result; the function's execution logic consists of a single SQL SELECT statement that queries the PRODUCTS table, using the COUNT(*) aggregate function to calculate the total number of rows, and retrieves this count into the local variable v_count, applying a condition in the WHERE clause that filters the rows to only those where the value in the CATEGORY_ID column is exactly equal to the value supplied in the input parameter p_category_id; the function then concludes by using a RETURN statement to output the calculated value stored in v_count.",
    "plsql": "CREATE OR REPLACE FUNCTION get_category_product_count(p_category_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM PRODUCTS WHERE CATEGORY_ID = p_category_id;\n    RETURN v_count;\nEND;",
    "database_name": "e_coma_analytics",
    "tables": [
      "CATEGORIES",
      "ORDERS",
      "ORDER_ITEMS",
      "PAYMENTS",
      "PRODUCTS",
      "SHIPPING"
    ],
    "call_sqls": [
      "SELECT get_category_product_count(0) FROM DUAL",
      "SELECT get_category_product_count(1) FROM DUAL",
      "SELECT get_category_product_count(10) FROM DUAL",
      "SELECT CATEGORY_ID, CATEGORY_NAME, get_category_product_count(CATEGORY_ID) AS PRODUCT_COUNT FROM CATEGORIES WHERE CATEGORY_ID = 0",
      "SELECT CATEGORY_ID, CATEGORY_NAME, get_category_product_count(CATEGORY_ID) AS PRODUCT_COUNT FROM CATEGORIES WHERE IS_ACTIVE = 1"
    ],
    "summary": "Write a Oracle PL/SQL function named get_category_product_count that accepts a category ID, counts how many products in the PRODUCTS table have that CATEGORY_ID, and returns the total count.",
    "natural_language": "Write a Oracle PL/SQL function called get_category_product_count that takes a category ID, counts the products in that category from the PRODUCTS table, and returns the total count.",
    "id": 44,
    "generated_ir": "Write an Oracle PL/SQL function named get_category_product_count that accepts a single input parameter p_category_id of type NUMBER and returns a NUMBER value, which declares a local variable v_product_count of type NUMBER to temporarily store the count of products, then executes a SELECT statement on the PRODUCTS table to count the number of rows where the category_id column matches the provided p_category_id parameter, using the COUNT aggregate function, stores this computed count in the v_product_count variable, and finally returns the value of v_product_count as the function's output.",
    "original_summary": "Create a function named get_category_product_count that accepts a category ID, counts the number of products in that category from the PRODUCTS table, and returns the count.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a function called get_category_product_count that takes a category ID, counts the products in that category from the PRODUCTS table, and returns the total count."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_district_incident_count that accepts a single input parameter p_district_id of the NUMBER data type and returns a value of the NUMBER data type, where the function's execution body declares a local variable v_count of the NUMBER data type, then performs a SELECT statement querying the INCIDENTS table to count all rows using the COUNT(*) aggregate function, storing the result into the v_count variable, with the query condition that the DISTRICT_ID column value must be exactly equal to the provided input parameter p_district_id, and finally returns the value stored in the v_count variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_district_incident_count(p_district_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM INCIDENTS WHERE DISTRICT_ID = p_district_id;\n  RETURN v_count;\nEND;",
    "database_name": "crime_iraa_893763",
    "tables": [
      "INCIDENTS",
      "INCIDENT_REPORTS",
      "INCIDENT_UPDATES",
      "OFFENSE_CATEGORIES",
      "OFFENSE_TYPES",
      "DISTRICTS"
    ],
    "call_sqls": [
      "SELECT get_district_incident_count(0) FROM DUAL",
      "SELECT get_district_incident_count(1) FROM DUAL",
      "SELECT get_district_incident_count(10) FROM DUAL",
      "SELECT get_district_incident_count(99) FROM DUAL",
      "SELECT get_district_incident_count(NULL) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_district_incident_count that returns the total number of incidents from the INCIDENTS table for a specified district, using the input parameter p_district_id to identify the district.",
    "natural_language": "Write a Oracle PL/SQL function called `get_district_incident_count` that returns the total number of incidents from the `INCIDENTS` table for a specified `p_district_id`.",
    "id": 45,
    "generated_ir": "Write an Oracle PL/SQL function named get_district_incident_count that accepts one input parameter: a NUMBER parameter named p_district_id which represents the unique identifier for a district, and returns a NUMBER data type; this function declares a local NUMBER variable named v_incident_count; the function executes a SELECT statement that performs a COUNT(*) aggregation on the INCIDENTS table, counting all rows where the district_id column value is equal to the input parameter p_district_id; the result of this COUNT(*) operation is stored into the local variable v_incident_count; the function then returns the value of the v_incident_count variable.",
    "original_summary": "Create a PL/SQL function named `get_district_incident_count` that returns the count of incidents (NUMBER) for a given `p_district_id` (NUMBER) from the `INCIDENTS` table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called `get_district_incident_count` that gives you a rough idea of how many incidents, as a NUMBER, are associated with a certain `p_district_id` (also a NUMBER) from the `INCIDENTS` table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_campaign_active` that accepts a single input parameter, `p_campaign_id`, which is of data type `NUMBER` and represents the unique identifier for a marketing campaign. The function is designed to return a `VARCHAR2` string, indicating whether the specified campaign is currently active or inactive.\n\nUpon execution, the function declares three local variables: `v_start_date` of type `VARCHAR2(255)` to store the campaign's start date, `v_end_date` of type `VARCHAR2(255)` to store the campaign's end date, and `v_status` of type `VARCHAR2(20)` to store the determined activity status.\n\nThe core logic begins by performing a `SELECT` operation on the `MARKETING_CAMPAIGNS` table. It retrieves the values from the `START_DATE` and `END_DATE` columns for the row where the `CAMPAIGN_ID` column matches the value provided in the input parameter `p_campaign_id`. These retrieved values are then assigned to the local variables `v_start_date` and `v_end_date`, respectively.\n\nFollowing the data retrieval, the function proceeds with a conditional check using an `IF` statement. It evaluates whether the `CURRENT_DATE` (representing the current system date) falls inclusively between the `v_start_date` and `v_end_date`. To perform this comparison correctly, both `v_start_date` and `v_end_date` are explicitly converted from their `VARCHAR2` data type to `DATE` data type using the `TO_DATE` function, with the format mask `'YYYY-MM-DD'` specified to ensure proper interpretation of the date strings.\n\nIf the `CURRENT_DATE` is found to be within the range defined by the converted `v_start_date` and `v_end_date`, the `v_status` variable is assigned the string literal `'Active'`. Otherwise, if the `CURRENT_DATE` is outside this range, the `v_status` variable is assigned the string literal `'Inactive'`.\n\nFinally, the function returns the value stored in the `v_status` variable, which will be either `'Active'` or `'Inactive'`, indicating the activity status of the campaign identified by `p_campaign_id`.",
    "plsql": "CREATE OR REPLACE FUNCTION check_campaign_active(p_campaign_id NUMBER)\nRETURN VARCHAR2\nIS\n    v_start_date VARCHAR2(255);\n    v_end_date VARCHAR2(255);\n    v_status VARCHAR2(20);\nBEGIN\n    SELECT START_DATE, END_DATE INTO v_start_date, v_end_date FROM MARKETING_CAMPAIGNS WHERE CAMPAIGN_ID = p_campaign_id;\n    IF CURRENT_DATE BETWEEN TO_DATE(v_start_date, 'YYYY-MM-DD') AND TO_DATE(v_end_date, 'YYYY-MM-DD') THEN\n        v_status := 'Active';\n    ELSE\n        v_status := 'Inactive';\n    END IF;\n    RETURN v_status;\nEND;",
    "database_name": "customer_rmadt_130963",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_INTERACTIONS",
      "MARKETING_CAMPAIGNS"
    ],
    "call_sqls": [
      "SELECT check_campaign_active(100) FROM DUAL",
      "SELECT check_campaign_active(200) FROM DUAL",
      "SELECT check_campaign_active(300) FROM DUAL",
      "SELECT check_campaign_active(400) FROM DUAL",
      "SELECT check_campaign_active(500) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named check_campaign_active that accepts a campaign_id and returns a status of 'Active' or 'Inactive' by checking if the current date falls between the START_DATE and END_DATE for the given CAMPAIGN_ID in the MARKETING_CAMPAIGNS table.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called check_campaign_active? It should take a campaign_id and return a status as either 'Active' or 'Inactive'. Basically, it needs to retrieve the START_DATE and END_DATE from the MARKETING_CAMPAIGNS table for the given campaign_id. If the current date falls between those start and end dates (converting them from 'YYYY-MM-DD' format), then return 'Active'; otherwise, return 'Inactive'.",
    "id": 46,
    "generated_ir": "Write an Oracle PL/SQL function named `check_campaign_active` that accepts a single input parameter, `p_campaign_id`, which is of data type `NUMBER` and represents the unique identifier for a marketing campaign. The function is designed to return a `VARCHAR2` string, indicating whether the specified campaign is currently active or inactive.\n\nUpon execution, the function declares three local variables: `v_start_date` of type `VARCHAR2(255)` to store the campaign's start date, `v_end_date` of type `VARCHAR2(255)` to store the campaign's end date, and `v_status` of type `VARCHAR2(20)` to store the determined activity status.\n\nThe core logic begins by performing a `SELECT` operation on the `MARKETING_CAMPAIGNS` table. It retrieves the values from the `START_DATE` and `END_DATE` columns for the row where the `CAMPAIGN_ID` column matches the value provided in the input parameter `p_campaign_id`. These retrieved values are then assigned to the local variables `v_start_date` and `v_end_date`, respectively.\n\nFollowing the data retrieval, the function proceeds with a conditional check using an `IF` statement. It evaluates whether the `CURRENT_DATE` (representing the current system date) falls inclusively between the `v_start_date` and `v_end_date`. To perform this comparison correctly, both `v_start_date` and `v_end_date` are explicitly converted from their `VARCHAR2` data type to `DATE` data type using the `TO_DATE` function, with the format mask `'YYYY-MM-DD'` specified to ensure proper interpretation of the date strings.\n\nIf the `CURRENT_DATE` is found to be within the range defined by the converted `v_start_date` and `v_end_date`, the `v_status` variable is assigned the string literal `'Active'`. Otherwise, if the `CURRENT_DATE` is outside this range, the `v_status` variable is assigned the string literal `'Inactive'`.\n\nFinally, the function returns the value stored in the `v_status` variable, which will be either `'Active'` or `'Inactive'`, indicating the activity status of the campaign identified by `p_campaign_id`.",
    "original_summary": "Create a PL/SQL function named check_campaign_active that accepts a campaign_id (NUMBER) and returns a VARCHAR2 indicating 'Active' or 'Inactive'. It retrieves the campaign's start and end dates from the MARKETING_CAMPAIGNS table. If the current date is between the start and end dates (converted from VARCHAR2 to DATE using 'YYYY-MM-DD' format), return 'Active'; otherwise, return 'Inactive'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called check_campaign_active? It should take a campaign_id (as a NUMBER) and spit back a VARCHAR2 saying either 'Active' or 'Inactive'. Basically, it needs to grab the start and end dates from the MARKETING_CAMPAIGNS table. If today's date falls between those start and end dates (you'll have to convert those strings to dates using the 'YYYY-MM-DD' format), then it's 'Active'. If not, just say 'Inactive'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_average_metric_value` that accepts a single input parameter, `p_experiment_id`, which is of data type `NUMBER` and represents the unique identifier for a specific experiment. This function is designed to return a single value of data type `NUMBER`, which will be the calculated average metric value. Upon execution, the function declares a local variable named `v_avg_metric_value` of data type `NUMBER` to temporarily store the result of a database query. The core operation of the function involves executing a `SELECT` statement against the `EXPERIMENT_RESULTS` table. This `SELECT` statement calculates the average of the `METRIC_VALUE` column. The calculation is performed only for those rows in the `EXPERIMENT_RESULTS` table where the value in the `EXPERIMENT_ID` column precisely matches the value provided by the input parameter `p_experiment_id`. The computed average `METRIC_VALUE` is then stored into the local variable `v_avg_metric_value`. Finally, the function returns the value currently held in `v_avg_metric_value` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_metric_value(p_experiment_id IN NUMBER) RETURN NUMBER IS\n    v_avg_metric_value NUMBER;\nBEGIN\n    SELECT AVG(METRIC_VALUE)\n    INTO v_avg_metric_value\n    FROM EXPERIMENT_RESULTS\n    WHERE EXPERIMENT_ID = p_experiment_id;\n    RETURN v_avg_metric_value;\nEND;",
    "database_name": "machine_lmpm_582732",
    "tables": [
      "EXPERIMENTS",
      "MODELS",
      "HYPERPARAMETERS",
      "EXPERIMENT_RESULTS",
      "PERFORMANCE_METRICS"
    ],
    "call_sqls": [
      "SELECT get_average_metric_value(1) FROM DUAL",
      "SELECT get_average_metric_value(2) FROM DUAL",
      "SELECT get_average_metric_value(3) FROM DUAL",
      "SELECT get_average_metric_value(4) FROM DUAL",
      "SELECT get_average_metric_value(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_average_metric_value that accepts a parameter for an EXPERIMENT_ID and returns the average METRIC_VALUE from the EXPERIMENT_RESULTS table for that specific experiment.",
    "natural_language": "Write a Oracle PL/SQL function named get_average_metric_value that, for a given experiment ID, calculates and returns the average METRIC_VALUE from the EXPERIMENT_RESULTS table.",
    "id": 47,
    "generated_ir": "Write an Oracle PL/SQL function named `get_average_metric_value` that accepts a single input parameter, `p_experiment_id`, which is of data type `NUMBER` and represents the unique identifier for a specific experiment. This function is designed to return a single value of data type `NUMBER`, which will be the calculated average metric value. Upon execution, the function declares a local variable named `v_avg_metric_value` of data type `NUMBER` to temporarily store the result of a database query. The core operation of the function involves executing a `SELECT` statement against the `EXPERIMENT_RESULTS` table. This `SELECT` statement calculates the average of the `METRIC_VALUE` column. The calculation is performed only for those rows in the `EXPERIMENT_RESULTS` table where the value in the `EXPERIMENT_ID` column precisely matches the value provided by the input parameter `p_experiment_id`. The computed average `METRIC_VALUE` is then stored into the local variable `v_avg_metric_value`. Finally, the function returns the value currently held in `v_avg_metric_value` as its output.",
    "original_summary": "Create a PL/SQL function named get_average_metric_value that accepts a NUMBER parameter p_experiment_id and returns a NUMBER. It calculates the average of METRIC_VALUE from the EXPERIMENT_RESULTS table where EXPERIMENT_ID matches the input.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write function get_average_metric_value(p_experiment_id NUMBER) returning NUMBER to average METRIC_VALUE from EXPERIMENT_RESULTS for the given ID."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_inventory_quantity` that is designed to retrieve the current stock quantity for a specific inventory item based on its unique identifier and associated size. This function accepts two input parameters: `p_inventory_id`, which is a `NUMBER` type representing the unique identifier of the inventory item, and `p_size_id`, which is also a `NUMBER` type representing the unique identifier for the size variant of the inventory item. The function is declared to return a `NUMBER` type, which will be the retrieved quantity. Internally, the function declares a local variable `v_quantity` of `NUMBER` type to temporarily store the quantity value fetched from the database. The core operation involves executing a `SELECT` statement to query the `INVENTORY` table. This `SELECT` statement retrieves the value from the `QUANTITY` column. The retrieval is conditional, specifically targeting rows where the `INVENTORY_ID` column matches the value provided by the `p_inventory_id` input parameter AND the `SIZE_ID` column matches the value provided by the `p_size_id` input parameter. The retrieved `QUANTITY` value is then immediately stored into the `v_quantity` local variable. Finally, the function returns the value stored in `v_quantity` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_inventory_quantity(p_inventory_id NUMBER, p_size_id NUMBER) RETURN NUMBER IS\n    v_quantity NUMBER;\nBEGIN\n    SELECT QUANTITY INTO v_quantity FROM INVENTORY WHERE INVENTORY_ID = p_inventory_id AND SIZE_ID = p_size_id;\n    RETURN v_quantity;\nEND;",
    "database_name": "garment_maim_826182",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "GARMENT_TYPES",
      "SIZES",
      "INVENTORY",
      "SHIPMENTS"
    ],
    "call_sqls": [
      "SELECT get_inventory_quantity(0, 0) FROM DUAL",
      "SELECT get_inventory_quantity(1, 0) FROM DUAL",
      "SELECT get_inventory_quantity(0, 1) FROM DUAL",
      "SELECT get_inventory_quantity(1, 1) FROM DUAL",
      "SELECT get_inventory_quantity(99, 99) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_inventory_quantity that, given an inventory ID and a size ID, retrieves and returns the QUANTITY from the INVENTORY table for the matching INVENTORY_ID and SIZE_ID.",
    "natural_language": "Write a Oracle PL/SQL function named get_inventory_quantity that returns the numeric QUANTITY from the INVENTORY table for a given numeric inventory ID and numeric size ID.",
    "id": 48,
    "generated_ir": "Write an Oracle PL/SQL function named `get_inventory_quantity` that is designed to retrieve the current stock quantity for a specific inventory item based on its unique identifier and associated size. This function accepts two input parameters: `p_inventory_id`, which is a `NUMBER` type representing the unique identifier of the inventory item, and `p_size_id`, which is also a `NUMBER` type representing the unique identifier for the size variant of the inventory item. The function is declared to return a `NUMBER` type, which will be the retrieved quantity. Internally, the function declares a local variable `v_quantity` of `NUMBER` type to temporarily store the quantity value fetched from the database. The core operation involves executing a `SELECT` statement to query the `INVENTORY` table. This `SELECT` statement retrieves the value from the `QUANTITY` column. The retrieval is conditional, specifically targeting rows where the `INVENTORY_ID` column matches the value provided by the `p_inventory_id` input parameter AND the `SIZE_ID` column matches the value provided by the `p_size_id` input parameter. The retrieved `QUANTITY` value is then immediately stored into the `v_quantity` local variable. Finally, the function returns the value stored in `v_quantity` as its output.",
    "original_summary": "Create a PL/SQL function named get_inventory_quantity that accepts a numeric inventory ID and a numeric size ID. It returns the numeric QUANTITY from the INVENTORY table where the INVENTORY_ID and SIZE_ID match the input parameters.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the numeric QUANTITY in the INVENTORY table for a given numeric inventory ID and numeric size ID?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_energy_ratio that accepts a single input parameter p_job_id of type NUMBER, which is used to identify a specific record, and returns a value of type NUMBER; the function begins by declaring a local variable v_ratio of type NUMBER; the function's executable section performs a SELECT query on the JOBS table, retrieving the result of dividing the ACTUAL_ENERGY_USAGE column by the ENERGY_USAGE column for the single row where the JOB_ID column equals the input parameter p_job_id, and stores this computed quotient into the local variable v_ratio; following this data retrieval, the function evaluates a conditional IF statement: if the value of v_ratio is greater than 1.0, the function returns the result of multiplying v_ratio by 100; otherwise, if v_ratio is less than or equal to 1.0, the function returns the result of multiplying v_ratio by 50.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_energy_ratio(p_job_id NUMBER) RETURN NUMBER IS\n  v_ratio NUMBER;\nBEGIN\n  SELECT ACTUAL_ENERGY_USAGE / ENERGY_USAGE INTO v_ratio FROM JOBS WHERE JOB_ID = p_job_id;\n  IF v_ratio > 1.0 THEN RETURN v_ratio * 100; ELSE RETURN v_ratio * 50; END IF;\nEND;",
    "database_name": "job_sar_management",
    "tables": [
      "JOBS",
      "JOB_EXECUTION",
      "JOB_TYPES",
      "MACHINES"
    ],
    "call_sqls": [
      "SELECT calculate_energy_ratio(1) FROM DUAL",
      "SELECT calculate_energy_ratio(2) FROM DUAL",
      "SELECT calculate_energy_ratio(3) FROM DUAL",
      "SELECT calculate_energy_ratio(4) FROM DUAL",
      "SELECT calculate_energy_ratio(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_energy_ratio that, for a given job ID, retrieves the ACTUAL_ENERGY_USAGE and ENERGY_USAGE from the JOBS table, calculates the ratio of ACTUAL_ENERGY_USAGE to ENERGY_USAGE, and returns that ratio multiplied by 100 if it exceeds 1.0, otherwise returns the ratio multiplied by 50.",
    "natural_language": "Write a Oracle PL/SQL function named calculate_energy_ratio that accepts a job ID as input and returns a number, where it retrieves the ACTUAL_ENERGY_USAGE and ENERGY_USAGE from the JOBS table for that job ID, calculates their ratio, and returns that ratio multiplied by 100 if the ratio exceeds 1.0, or multiplied by 50 otherwise.",
    "id": 49,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_energy_ratio that accepts a single input parameter p_job_id of type NUMBER, which is used to identify a specific record, and returns a value of type NUMBER; the function begins by declaring a local variable v_ratio of type NUMBER; the function's executable section performs a SELECT query on the JOBS table, retrieving the result of dividing the ACTUAL_ENERGY_USAGE column by the ENERGY_USAGE column for the single row where the JOB_ID column equals the input parameter p_job_id, and stores this computed quotient into the local variable v_ratio; following this data retrieval, the function evaluates a conditional IF statement: if the value of v_ratio is greater than 1.0, the function returns the result of multiplying v_ratio by 100; otherwise, if v_ratio is less than or equal to 1.0, the function returns the result of multiplying v_ratio by 50.",
    "original_summary": "Create a PL/SQL function named calculate_energy_ratio that accepts a NUMBER parameter p_job_id and returns a NUMBER. The function should calculate the ratio of ACTUAL_ENERGY_USAGE to ENERGY_USAGE from the JOBS table for the given job ID. If the ratio is greater than 1.0, return the ratio multiplied by 100; otherwise, return the ratio multiplied by 50.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What PL/SQL function, named calculate_energy_ratio, can be created to accept a NUMBER parameter p_job_id and return a NUMBER, where it calculates the ratio of ACTUAL_ENERGY_USAGE to ENERGY_USAGE from the JOBS table for the given job ID, returning the ratio multiplied by 100 if it exceeds 1.0, or multiplied by 50 otherwise?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_margin_value that accepts a single parameter p_data_id of type NUMBER, which represents the identifier of a data record. The function retrieves a numeric value from the ERROR_MARGINS table, specifically from the MARGIN_VALUE column, where the DATA_ID column matches the provided p_data_id parameter. The function stores this retrieved value in a local variable v_margin of type NUMBER. After successfully obtaining the margin value, the function returns the value stored in v_margin. The function performs a SELECT operation to extract the MARGIN_VALUE from the ERROR_MARGINS table based on the condition that the DATA_ID column equals the input parameter p_data_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_margin_value(p_data_id NUMBER) RETURN NUMBER IS\n  v_margin NUMBER;\nBEGIN\n  SELECT MARGIN_VALUE INTO v_margin FROM ERROR_MARGINS WHERE DATA_ID = p_data_id;\n  RETURN v_margin;\nEND;",
    "database_name": "demographic_dcaa_801780",
    "tables": [
      "CALCULATED_PERCENTAGES",
      "DEFINITIONS",
      "ERROR_MARGINS",
      "LABELS",
      "DEMOGRAPHIC_CATEGORIES"
    ],
    "call_sqls": [
      "SELECT get_margin_value(1) FROM DUAL",
      "SELECT get_margin_value(2) FROM DUAL",
      "SELECT get_margin_value(3) FROM DUAL",
      "SELECT get_margin_value(4) FROM DUAL",
      "SELECT get_margin_value(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_margin_value that accepts a parameter p_data_id representing a data identifier and returns the corresponding MARGIN_VALUE from the ERROR_MARGINS table for the matching DATA_ID.",
    "natural_language": "Write a Oracle PL/SQL function called get_margin_value that takes a p_data_id parameter and returns a NUMBER, which retrieves the MARGIN_VALUE from the ERROR_MARGINS table where the DATA_ID matches the provided p_data_id.",
    "id": 50,
    "generated_ir": "Write an Oracle PL/SQL function named get_margin_value that accepts a single parameter p_data_id of type NUMBER, which represents the identifier of a data record. The function retrieves a numeric value from the ERROR_MARGINS table, specifically from the MARGIN_VALUE column, where the DATA_ID column matches the provided p_data_id parameter. The function stores this retrieved value in a local variable v_margin of type NUMBER. After successfully obtaining the margin value, the function returns the value stored in v_margin. The function performs a SELECT operation to extract the MARGIN_VALUE from the ERROR_MARGINS table based on the condition that the DATA_ID column equals the input parameter p_data_id.",
    "original_summary": "Create a PL/SQL function named get_margin_value that accepts a NUMBER parameter p_data_id and returns a NUMBER. It retrieves the MARGIN_VALUE from the ERROR_MARGINS table where DATA_ID equals p_data_id.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "How can I create a PL/SQL function called get_margin_value that takes a NUMBER parameter p_data_id and returns a NUMBER, which retrieves the MARGIN_VALUE from the ERROR_MARGINS table for the matching DATA_ID?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_user_count that returns a numeric value representing the total number of records in the USERS table. The function does not take any input parameters. Inside the function, declare a local variable v_count of type NUMBER to store the result of the query. Execute a SELECT statement that counts all rows in the USERS table using the COUNT(*) aggregate function, and store the result into the v_count variable. Finally, return the value of v_count, which represents the total number of users in the USERS table.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_count RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO v_count\n  FROM USERS;\n  RETURN v_count;\nEND;",
    "database_name": "weather_dcaa_574729",
    "tables": [
      "ACCESS_LOGS",
      "REPORTS",
      "REPORT_GENERATION_LOGS",
      "USERS",
      "WEATHER_STATIONS"
    ],
    "call_sqls": [
      "SELECT get_user_count FROM DUAL",
      "SELECT get_user_count() FROM DUAL",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_user_count;\n  DBMS_OUTPUT.PUT_LINE('User count: ' || v_result);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total users: ' || get_user_count);\nEND;",
      "SELECT 'Current user count is: ' || get_user_count AS message FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_user_count that returns the total number of rows in the USERS table.",
    "natural_language": "Write a Oracle PL/SQL function called get_user_count that returns the total number of records in the USERS table.",
    "id": 51,
    "generated_ir": "Write an Oracle PL/SQL function named get_user_count that returns a numeric value representing the total number of records in the USERS table. The function does not take any input parameters. Inside the function, declare a local variable v_count of type NUMBER to store the result of the query. Execute a SELECT statement that counts all rows in the USERS table using the COUNT(*) aggregate function, and store the result into the v_count variable. Finally, return the value of v_count, which represents the total number of users in the USERS table.",
    "original_summary": "Create a PL/SQL function named get_user_count that returns the total number of rows in the USERS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/SQL function, designated as 'get_user_count', which shall return the aggregate count of records present within the USERS table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_team_with_most_wins that returns a VARCHAR2 value representing the name of the team with the most wins. The function does not take any parameters. It begins by declaring a local variable v_team_name of type VARCHAR2 with a maximum length of 255 characters to store the name of the team with the most wins. The function then executes a SELECT statement to retrieve the TEAM_NAME from the TEAMS table, where the TEAM_ID matches the result of a subquery. This subquery selects the GAME_WINNER_ID from the GAMES table, groups the results by GAME_WINNER_ID, and orders them in descending order based on the count of occurrences for each GAME_WINNER_ID. The subquery uses the FETCH FIRST 1 ROWS ONLY clause to limit the result to the first row, which corresponds to the team with the highest number of wins. The TEAM_NAME corresponding to this TEAM_ID is then stored in the v_team_name variable. Finally, the function returns the value of v_team_name, which is the name of the team with the most wins.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_with_most_wins RETURN VARCHAR2 IS\n  v_team_name VARCHAR2(255);\nBEGIN\n  SELECT t.TEAM_NAME\n  INTO v_team_name\n  FROM TEAMS t\n  WHERE t.TEAM_ID = (SELECT GAME_WINNER_ID FROM GAMES GROUP BY GAME_WINNER_ID ORDER BY COUNT(*) DESC FETCH FIRST 1 ROWS ONLY);\n  RETURN v_team_name;\nEND;",
    "database_name": "basketball_ppats_549881",
    "tables": [
      "GAMES",
      "GAME_STATISTICS",
      "PLAYERS",
      "PLAYER_CONTRACTS",
      "PLAYER_SEASONS",
      "TEAMS"
    ],
    "call_sqls": [
      "SELECT get_team_with_most_wins FROM DUAL",
      "SELECT get_team_with_most_wins() FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Team with most wins: ' || get_team_with_most_wins);\nEND;",
      "DECLARE\n  v_result VARCHAR2(255);\nBEGIN\n  v_result := get_team_with_most_wins;\n  DBMS_OUTPUT.PUT_LINE(v_result);\nEND;",
      "SELECT t.TEAM_NAME, get_team_with_most_wins AS top_team FROM TEAMS t WHERE t.TEAM_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL function named get_team_with_most_wins with no parameters that returns the TEAM_NAME from the TEAMS table for the team that has the most wins, determined by identifying the GAME_WINNER_ID with the highest count in the GAMES table and matching it to the TEAM_ID in the TEAMS table.",
    "natural_language": "Write a Oracle PL/SQL function named get_team_with_most_wins that returns the TEAM_NAME from the TEAMS table for the team with the highest number of wins, where a win is determined by matching the TEAM_ID in TEAMS to the GAME_WINNER_ID in the GAMES table and counting occurrences.",
    "id": 52,
    "generated_ir": "Write an Oracle PL/SQL function named get_team_with_most_wins that returns a VARCHAR2 value representing the name of the team with the most wins. The function does not take any parameters. It begins by declaring a local variable v_team_name of type VARCHAR2 with a maximum length of 255 characters to store the name of the team with the most wins. The function then executes a SELECT statement to retrieve the TEAM_NAME from the TEAMS table, where the TEAM_ID matches the result of a subquery. This subquery selects the GAME_WINNER_ID from the GAMES table, groups the results by GAME_WINNER_ID, and orders them in descending order based on the count of occurrences for each GAME_WINNER_ID. The subquery uses the FETCH FIRST 1 ROWS ONLY clause to limit the result to the first row, which corresponds to the team with the highest number of wins. The TEAM_NAME corresponding to this TEAM_ID is then stored in the v_team_name variable. Finally, the function returns the value of v_team_name, which is the name of the team with the most wins.",
    "original_summary": "Create a PL/SQL function named get_team_with_most_wins with no parameters that returns a VARCHAR2. The function should return the TEAM_NAME of the team with the most wins by finding the GAME_WINNER_ID with the highest count in the GAMES table and matching it to the TEAM_ID in the TEAMS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the name of the team that has the most wins, based on the highest count of GAME_WINNER_ID in the GAMES table matched to TEAM_ID in the TEAMS table?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_trend_score_sum that accepts a single input parameter p_trend_type of type VARCHAR2 and returns a NUMBER. The function declares a local variable v_sum of type NUMBER. The function's logic begins with a conditional IF statement that checks if the input parameter p_trend_type is exactly equal to the string literal 'increasing'. If this condition is true, the function executes a SELECT statement that retrieves data from the TREND_ANALYSIS table. This SELECT statement uses the SQL aggregate function SUM to calculate the total sum of all values in the TREND_SCORE column, but only for rows where the TREND_TYPE column's value is exactly equal to the string 'increasing'. The result of this SUM operation is stored into the local variable v_sum. If the initial condition is false, meaning p_trend_type is not equal to 'increasing', the function's ELSE branch executes, which assigns the value 0 directly to the variable v_sum. After the conditional logic completes, the function executes a RETURN statement to output the final value stored in v_sum.",
    "plsql": "CREATE OR REPLACE FUNCTION get_trend_score_sum(p_trend_type VARCHAR2) RETURN NUMBER IS\nv_sum NUMBER;\nBEGIN\nIF p_trend_type = 'increasing' THEN\nSELECT SUM(TREND_SCORE) INTO v_sum FROM TREND_ANALYSIS WHERE TREND_TYPE = 'increasing';\nELSE\nv_sum := 0;\nEND IF;\nRETURN v_sum;\nEND;",
    "database_name": "time_sdaaa_detection",
    "tables": [
      "ANOMALY_DETECTION",
      "SENSORS",
      "TREND_ANALYSIS"
    ],
    "call_sqls": [
      "SELECT get_trend_score_sum('increasing') FROM DUAL",
      "SELECT get_trend_score_sum('decreasing') FROM DUAL",
      "SELECT get_trend_score_sum('increasing') AS increasing_sum FROM DUAL",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Sum: ' || get_trend_score_sum('increasing'));\nEND;",
      "DECLARE\n  v_result NUMBER;\nBEGIN\n  v_result := get_trend_score_sum('increasing');\n  DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL function named get_trend_score_sum that accepts a trend type as input and returns the total trend score. If the input trend type is 'increasing', calculate and return the sum of all TREND_SCORE values from the TREND_ANALYSIS table where the TREND_TYPE is 'increasing'. For any other input trend type, return 0.",
    "natural_language": "Write a Oracle PL/SQL function named get_trend_score_sum that takes a trend type as input and returns the total trend score. If the input trend type is 'increasing', calculate and return the sum of TREND_SCORE from the TREND_ANALYSIS table where TREND_TYPE is 'increasing'. For any other input, return 0.",
    "id": 53,
    "generated_ir": "Write an Oracle PL/SQL function named get_trend_score_sum that accepts a single input parameter p_trend_type of type VARCHAR2 and returns a NUMBER representing the total sum of trend scores. The function begins by declaring a local variable v_total_score of type NUMBER to store the result of the sum operation. It then checks the value of the input parameter p_trend_type using a conditional IF statement. If p_trend_type is exactly equal to the string 'increasing', the function executes a SELECT statement on the TREND_ANALYSIS table. This SELECT statement uses the SUM aggregate function to calculate the total of the TREND_SCORE column for all rows where the TREND_TYPE column is equal to 'increasing'. The result of the SUM operation is stored into the v_total_score variable using the INTO clause. If the SELECT statement finds no matching rows, the SUM function returns NULL, which is stored in v_total_score. After the SELECT operation, the function returns the value of v_total_score. If the input parameter p_trend_type is not equal to 'increasing', the function skips the SELECT statement and directly returns 0. The function handles the case where v_total_score might be NULL after the SELECT by returning that NULL value, which effectively returns NULL if no rows match the condition. The function operates within the database time_sdaaa_detection.",
    "original_summary": "Create a function named get_trend_score_sum that accepts a VARCHAR2 parameter p_trend_type and returns a NUMBER. If p_trend_type is 'increasing', return the SUM of TREND_SCORE from the TREND_ANALYSIS table where TREND_TYPE is 'increasing'. Otherwise, return 0.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Define a function called get_trend_score_sum that takes a VARCHAR2 parameter p_trend_type and returns a NUMBER. For an 'increasing' p_trend_type, calculate and return the SUM of TREND_SCORE from the TREND_ANALYSIS table where TREND_TYPE matches 'increasing'. For any other input, return 0."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_user_status` that accepts a single input parameter, `p_user_id`, which is of data type `NUMBER`. This function is designed to return a value of data type `VARCHAR2`. Upon execution, the function declares a local variable named `v_status` of data type `VARCHAR2` with a maximum length of 255 characters. The core operation of this function involves performing a `SELECT` statement. Specifically, it retrieves the value from the `USER_STATUS` column from the table named `USERS`. The retrieved value is then immediately assigned to the local variable `v_status`. This selection is conditional, meaning only rows where the value in the `USER_ID` column of the `USERS` table exactly matches the value provided in the input parameter `p_user_id` are considered. After successfully executing the `SELECT` statement and populating `v_status`, the function then returns the current value stored in the `v_status` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_status(p_user_id NUMBER) RETURN VARCHAR2 IS\n    v_status VARCHAR2(255);\nBEGIN\n    SELECT USER_STATUS INTO v_status FROM USERS WHERE USER_ID = p_user_id;\n    RETURN v_status;\nEND;",
    "database_name": "basketball_ppat_statistic",
    "tables": [
      "USERS",
      "USER_ACCESS_LOGS"
    ],
    "call_sqls": [
      "SELECT get_user_status(1001) FROM DUAL",
      "SELECT get_user_status(2045) FROM DUAL",
      "SELECT get_user_status(789) FROM DUAL",
      "SELECT get_user_status(5000) FROM DUAL",
      "SELECT get_user_status(1) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_user_status that retrieves the USER_STATUS from the USERS table for a given USER_ID provided as input and returns that status value.",
    "natural_language": "Write a Oracle PL/SQL function called get_user_status that returns a VARCHAR2 status. It should accept a NUMBER parameter named p_user_id, retrieve the USER_STATUS from the USERS table where the USER_ID matches the provided p_user_id, and then return that status value.",
    "id": 54,
    "generated_ir": "Write an Oracle PL/SQL function named `get_user_status` that accepts a single input parameter, `p_user_id`, which is of data type `NUMBER`. This function is designed to return a value of data type `VARCHAR2`. Upon execution, the function declares a local variable named `v_status` of data type `VARCHAR2` with a maximum length of 255 characters. The core operation of this function involves performing a `SELECT` statement. Specifically, it retrieves the value from the `USER_STATUS` column from the table named `USERS`. The retrieved value is then immediately assigned to the local variable `v_status`. This selection is conditional, meaning only rows where the value in the `USER_ID` column of the `USERS` table exactly matches the value provided in the input parameter `p_user_id` are considered. After successfully executing the `SELECT` statement and populating `v_status`, the function then returns the current value stored in the `v_status` variable as its output.",
    "original_summary": "Create a PL/SQL function named get_user_status that returns a VARCHAR2. It accepts a NUMBER parameter p_user_id. The function selects the USER_STATUS from the USERS table where USER_ID equals p_user_id and returns the value.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "How can I create a PL/SQL function called get_user_status that returns a VARCHAR2? It should take a NUMBER parameter named p_user_id, select the USER_STATUS from the USERS table where the USER_ID matches p_user_id, and then return that status value."
  },
  {
    "ir": "Write an Oracle PL/SQL function named translate_marital_status that accepts a single input parameter p_employee_id of type NUMBER, which is used to identify a specific employee record, and returns a VARCHAR2 string; within the function, a local variable v_translated_status of type VARCHAR2 with a maximum length of 255 characters is declared, then a SELECT statement queries the MARITAL_STATUS column from the EMPLOYEES table for the row where the ID column exactly equals the provided p_employee_id parameter, and the built-in TRANSLATE function is applied to the retrieved MARITAL_STATUS value, instructing it to replace each occurrence of the character 'S' with 'S', 'i' with 'o', 'n' with 'l', 'g' with 'o', 'l' with 'C', 'e' with 'a', 'M' with 's', 'a' with 'a', 'r' with 'd', 'r' with 'o', 'i' with null, 'e' with null, and 'd' with null, effectively mapping the full string 'Single' to 'Solo' and 'Married' to 'Casado' based on the positional correspondence of characters in the 'from_string' and 'to_string' arguments; the result of this TRANSLATE operation is stored into the variable v_translated_status, which is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION translate_marital_status(p_employee_id NUMBER) RETURN VARCHAR2 IS\n    v_translated_status VARCHAR2(255);\nBEGIN\n    SELECT TRANSLATE(MARITAL_STATUS, 'SingleMarried', 'SoloCasado') INTO v_translated_status FROM EMPLOYEES WHERE ID = p_employee_id;\n    RETURN v_translated_status;\nEND;",
    "database_name": "human_rmaes_tracking",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "USERS",
      "BENEFITS",
      "PAYROLL",
      "PERFORMANCE_REVIEWS",
      "TERMINATIONS"
    ],
    "call_sqls": [
      "SELECT translate_marital_status(0) FROM DUAL",
      "SELECT translate_marital_status(1) FROM DUAL",
      "SELECT translate_marital_status(2) FROM DUAL",
      "SELECT translate_marital_status(3) FROM DUAL",
      "SELECT translate_marital_status(4) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named translate_marital_status that accepts an employee ID and returns a translated marital status string by retrieving the MARITAL_STATUS from the EMPLOYEES table for that employee ID, converting 'Single' to 'Solo' and 'Married' to 'Casado'.",
    "natural_language": "Write a Oracle PL/SQL function named translate_marital_status that takes an employee identifier as input and returns a translated marital status. It should retrieve the MARITAL_STATUS from the EMPLOYEES table for the given employee ID, then convert 'Single' to 'Solo' and 'Married' to 'Casado' before returning the result.",
    "id": 55,
    "generated_ir": "Write an Oracle PL/SQL function named translate_marital_status that accepts a single input parameter p_employee_id of type NUMBER, which is used to identify a specific employee record, and returns a VARCHAR2 string; within the function, a local variable v_translated_status of type VARCHAR2 with a maximum length of 255 characters is declared, then a SELECT statement queries the MARITAL_STATUS column from the EMPLOYEES table for the row where the ID column exactly equals the provided p_employee_id parameter, and the built-in TRANSLATE function is applied to the retrieved MARITAL_STATUS value, instructing it to replace each occurrence of the character 'S' with 'S', 'i' with 'o', 'n' with 'l', 'g' with 'o', 'l' with 'C', 'e' with 'a', 'M' with 's', 'a' with 'a', 'r' with 'd', 'r' with 'o', 'i' with null, 'e' with null, and 'd' with null, effectively mapping the full string 'Single' to 'Solo' and 'Married' to 'Casado' based on the positional correspondence of characters in the 'from_string' and 'to_string' arguments; the result of this TRANSLATE operation is stored into the variable v_translated_status, which is then returned as the function's output.",
    "original_summary": "Create a PL/SQL function named translate_marital_status that accepts an employee ID (NUMBER). It returns a VARCHAR2 string by querying the employee's MARITAL_STATUS from the EMPLOYEES table and using the TRANSLATE function to convert 'Single' to 'Solo' and 'Married' to 'Casado'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/SQL function designated as 'translate_marital_status'. This function should accept a single input parameter of the NUMBER data type, representing an employee identifier. Its purpose is to return a value of the VARCHAR2 data type. The function must retrieve the MARITAL_STATUS value for the specified employee from the EMPLOYEES table. Subsequently, it shall employ the TRANSLATE function to convert the string 'Single' to 'Solo' and the string 'Married' to 'Casado' before returning the result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_discount_rate` that accepts a single input parameter, `p_total_cost`, which is of the `NUMBER` data type. The purpose of this function is to determine and return a discount rate, also of the `NUMBER` data type, based on the value of `p_total_cost`. The function implements a series of conditional checks to establish the appropriate discount rate. Specifically, it first evaluates if the value of `p_total_cost` is greater than or equal to `1000`. If this condition is true, the function immediately returns a fixed discount rate of `0.15`. If the first condition is false, the function proceeds to evaluate the next condition, checking if `p_total_cost` is greater than or equal to `500`. If this second condition is true, the function returns a fixed discount rate of `0.10`. If both the first and second conditions are false, the function then evaluates a third condition, checking if `p_total_cost` is greater than or equal to `100`. If this third condition is true, the function returns a fixed discount rate of `0.05`. Finally, if none of the preceding conditions are met (meaning `p_total_cost` is less than `100`), the function executes the `ELSE` block and returns a fixed discount rate of `0.00`. The function does not perform any data manipulation language (DML) operations such as inserts, updates, or deletes, nor does it query any tables. It solely performs conditional logic based on its input parameter to compute and return a numerical value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_discount_rate(p_total_cost NUMBER) RETURN NUMBER IS\nBEGIN\n  IF p_total_cost >= 1000 THEN\n    RETURN 0.15;\n  ELSIF p_total_cost >= 500 THEN\n    RETURN 0.10;\n  ELSIF p_total_cost >= 100 THEN\n    RETURN 0.05;\n  ELSE\n    RETURN 0.00;\n  END IF;\nEND;",
    "database_name": "customer_rmadt_130963",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT calculate_discount_rate(1200) FROM DUAL",
      "SELECT calculate_discount_rate(750) FROM DUAL",
      "SELECT calculate_discount_rate(200) FROM DUAL",
      "SELECT calculate_discount_rate(50) FROM DUAL",
      "SELECT calculate_discount_rate(TO_NUMBER(TOTAL_COST)) FROM ORDERS WHERE ORDER_ID = 1"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_discount_rate that takes a total cost as input and returns a discount rate based on the cost: 0.15 if the cost is 1000 or more, 0.10 if the cost is 500 or more but less than 1000, 0.05 if the cost is 100 or more but less than 500, and 0.00 otherwise.",
    "natural_language": "Write a Oracle PL/SQL function called calculate_discount_rate that takes a total cost as input and returns a discount rate based on the cost: give a 0.15 discount for costs of 1000 or more, a 0.10 discount for costs of 500 or more but less than 1000, a 0.05 discount for costs of 100 or more but less than 500, and a 0.00 discount for costs below 100.",
    "id": 56,
    "generated_ir": "Write an Oracle PL/SQL function named `calculate_discount_rate` that accepts a single input parameter, `p_total_cost`, which is of the `NUMBER` data type. The purpose of this function is to determine and return a discount rate, also of the `NUMBER` data type, based on the value of `p_total_cost`. The function implements a series of conditional checks to establish the appropriate discount rate. Specifically, it first evaluates if the value of `p_total_cost` is greater than or equal to `1000`. If this condition is true, the function immediately returns a fixed discount rate of `0.15`. If the first condition is false, the function proceeds to evaluate the next condition, checking if `p_total_cost` is greater than or equal to `500`. If this second condition is true, the function returns a fixed discount rate of `0.10`. If both the first and second conditions are false, the function then evaluates a third condition, checking if `p_total_cost` is greater than or equal to `100`. If this third condition is true, the function returns a fixed discount rate of `0.05`. Finally, if none of the preceding conditions are met (meaning `p_total_cost` is less than `100`), the function executes the `ELSE` block and returns a fixed discount rate of `0.00`. The function does not perform any data manipulation language (DML) operations such as inserts, updates, or deletes, nor does it query any tables. It solely performs conditional logic based on its input parameter to compute and return a numerical value.",
    "original_summary": "Create a function named calculate_discount_rate that takes a total cost number and returns a discount rate number: 0.15 for cost >= 1000, 0.10 for cost >= 500, 0.05 for cost >= 100, and 0.00 otherwise.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a function called calculate_discount_rate, which should accept a numerical value representing the total cost and subsequently provide a numerical discount rate as its output. This function will apply a generous discount rate of 0.15 whenever the total cost is equal to or surpasses 1000. For costs that are at least 500 but less than 1000, a moderate discount rate of 0.10 will be granted. When the total cost reaches a minimum of 100 but remains below 500, a smaller discount rate of 0.05 will be applied. In all other cases, where the cost falls below 100, no discount will be given, resulting in a rate of 0.00."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_employee_status that accepts a single input parameter emp_id of the NUMBER data type and returns a value of the VARCHAR2 data type, which executes a SELECT statement to query the STATUS column from the EMPLOYEES table, specifically retrieving the STATUS value for the row where the EMP_ID column value is exactly equal to the provided emp_id input parameter, storing the retrieved value into a local variable v_status of VARCHAR2(255), and then returns the content of this v_status variable as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_status(emp_id NUMBER) RETURN VARCHAR2 IS\n  v_status VARCHAR2(255);\nBEGIN\n  SELECT STATUS INTO v_status FROM EMPLOYEES WHERE EMP_ID = emp_id;\n  RETURN v_status;\nEND;",
    "database_name": "human_rmae_tracking",
    "tables": [
      "EMPLOYEES",
      "SALARIES"
    ],
    "call_sqls": [
      "SELECT get_employee_status(1) FROM dual",
      "SELECT get_employee_status(2) FROM dual",
      "SELECT get_employee_status(3) FROM dual",
      "SELECT get_employee_status(4) FROM dual",
      "SELECT get_employee_status(5) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_employee_status that accepts an employee ID and returns the STATUS from the EMPLOYEES table for that specific employee.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called get_employee_status that takes an employee's ID number, looks them up in the EMPLOYEES table, and spits back their STATUS?",
    "id": 57,
    "generated_ir": "Write an Oracle PL/SQL function named get_employee_status that accepts a single input parameter emp_id of the NUMBER data type and returns a value of the VARCHAR2 data type, which executes a SELECT statement to query the STATUS column from the EMPLOYEES table, specifically retrieving the STATUS value for the row where the EMP_ID column value is exactly equal to the provided emp_id input parameter, storing the retrieved value into a local variable v_status of VARCHAR2(255), and then returns the content of this v_status variable as the function's output.",
    "original_summary": "Create a function named get_employee_status that accepts an employee ID number and returns the status from the EMPLOYEES table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a function called get_employee_status? It should take an employee's ID number, look them up in the EMPLOYEES table, and spit back their status."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_player_points that accepts two input parameters: a numeric parameter named p_player_id representing a player's unique identifier and a second numeric parameter named p_game_id representing a game's unique identifier, and returns a single numeric value; the function's logic begins by declaring a local numeric variable named v_points to hold the result, then executes a SELECT statement to query the PLAYER_PERFORMANCE table, specifically retrieving the value from the POINTS_SCORED column for the single table row where the PLAYER_ID column value is equal to the input parameter p_player_id and simultaneously the GAME_ID column value is equal to the input parameter p_game_id, storing the retrieved value directly into the local variable v_points, and finally concludes by returning the value contained in the v_points variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_points(p_player_id NUMBER, p_game_id NUMBER) RETURN NUMBER IS\nv_points NUMBER;\nBEGIN\nSELECT POINTS_SCORED INTO v_points FROM PLAYER_PERFORMANCE WHERE PLAYER_ID = p_player_id AND GAME_ID = p_game_id;\nRETURN v_points;\nEND;",
    "database_name": "sports_tpas_818815",
    "tables": [
      "GAMES",
      "PLAYERS",
      "PLAYER_PERFORMANCE",
      "SEASONS",
      "TEAM_PERFORMANCE"
    ],
    "call_sqls": [
      "SELECT get_player_points(1, 1) FROM DUAL",
      "SELECT get_player_points(2, 1) FROM DUAL",
      "SELECT get_player_points(1, 2) FROM DUAL",
      "SELECT get_player_points(3, 1) FROM DUAL",
      "SELECT get_player_points(2, 2) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_player_points that, given a player ID and a game ID, retrieves and returns the POINTS_SCORED value from the PLAYER_PERFORMANCE table for the matching PLAYER_ID and GAME_ID.",
    "natural_language": "Write a Oracle PL/SQL function called get_player_points that takes a player ID and a game ID, retrieves the POINTS_SCORED from the PLAYER_PERFORMANCE table for that specific player and game, and returns the points scored.",
    "id": 58,
    "generated_ir": "Write an Oracle PL/SQL function named get_player_points that accepts two input parameters: a numeric parameter named p_player_id representing a player's unique identifier and a second numeric parameter named p_game_id representing a game's unique identifier, and returns a single numeric value; the function's logic begins by declaring a local numeric variable named v_points to hold the result, then executes a SELECT statement to query the PLAYER_PERFORMANCE table, specifically retrieving the value from the POINTS_SCORED column for the single table row where the PLAYER_ID column value is equal to the input parameter p_player_id and simultaneously the GAME_ID column value is equal to the input parameter p_game_id, storing the retrieved value directly into the local variable v_points, and finally concludes by returning the value contained in the v_points variable as the function's result.",
    "original_summary": "Create a PL/SQL function named get_player_points that accepts a player ID and a game ID, queries the PLAYER_PERFORMANCE table for the POINTS_SCORED column where PLAYER_ID and GAME_ID match, and returns the numeric points value.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called get_player_points that takes a player ID and a game ID, looks up the PLAYER_PERFORMANCE table for roughly the POINTS_SCORED amount when the IDs are about right, and gives back the number of points."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_combined_profile` that accepts two input parameters: `p_individual_id` of data type `NUMBER`, which represents the unique identifier for an individual, and `p_separator` of data type `VARCHAR2`, which is a string used to concatenate different profile attributes. This function is designed to return a single `VARCHAR2` string representing a combined profile for the specified individual. The function declares a local variable `v_profile` of type `VARCHAR2` with a maximum length of 1000 characters to temporarily store the combined profile string. The core operation of the function involves a `SELECT` statement that retrieves data from three tables: `individuals` (aliased as `i`), `work_classes` (aliased as `w`), and `occupations` (aliased as `o`). The `individuals` table is joined with the `work_classes` table using an inner join condition where `i.workclass_id` from the `individuals` table matches `w.workclass_id` from the `work_classes` table. Simultaneously, the `individuals` table is also joined with the `occupations` table using an inner join condition where `i.occupation_id` from the `individuals` table matches `o.occupation_id` from the `occupations` table. The `SELECT` statement constructs a single string by concatenating the `education` column from the `individuals` table, followed by the value of the `p_separator` parameter, then the `workclass_name` column from the `work_classes` table, followed again by the value of the `p_separator` parameter, and finally the `occupation_name` column from the `occupations` table. The result of this concatenation is then stored into the `v_profile` local variable. This data retrieval is filtered by a `WHERE` clause that ensures only the record where the `individual_id` column from the `individuals` table matches the input parameter `p_individual_id` is considered. After successfully retrieving and concatenating the profile information into `v_profile`, the function then applies the `LOWER()` function to the `v_profile` string, converting all characters in the combined profile to lowercase, and returns this lowercase string as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_combined_profile(p_individual_id NUMBER, p_separator VARCHAR2) RETURN VARCHAR2 IS\n    v_profile VARCHAR2(1000);\nBEGIN\n    SELECT i.education || p_separator || w.workclass_name || p_separator || o.occupation_name INTO v_profile\n    FROM individuals i\n    JOIN work_classes w ON i.workclass_id = w.workclass_id\n    JOIN occupations o ON i.occupation_id = o.occupation_id\n    WHERE i.individual_id = p_individual_id;\n    RETURN LOWER(v_profile);\nEND;",
    "database_name": "demographic_aeda_61583",
    "tables": [
      "INDIVIDUALS",
      "MARITAL_STATUSES",
      "OCCUPATIONS",
      "WORK_CLASSES"
    ],
    "call_sqls": [
      "SELECT get_combined_profile(1001, ' | ') FROM dual",
      "SELECT get_combined_profile(205, ' - ') FROM dual",
      "SELECT get_combined_profile(500, ', ') FROM dual",
      "SELECT get_combined_profile(789, '; ') FROM dual",
      "SELECT get_combined_profile(42, ' -> ') FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_combined_profile that, for a given individual ID, retrieves the education from the INDIVIDUALS table, the workclass_name from the WORK_CLASSES table, and the occupation_name from the OCCUPATIONS table, then returns these three values as a single lowercase string concatenated with a provided separator.",
    "natural_language": "Write a Oracle PL/SQL function named get_combined_profile that returns a single string combining an individual's education level, workclass name, and occupation name in lowercase, separated by a user-provided separator, based on a given individual ID by retrieving data from the individuals, work_classes, and occupations tables.",
    "id": 59,
    "generated_ir": "Write an Oracle PL/SQL function named get_combined_profile that accepts two input parameters: p_individual_id of type NUMBER, which represents the unique identifier of an individual, and p_separator of type VARCHAR2, which represents the string used to separate the combined values. The function returns a single VARCHAR2 string that concatenates an individual's education level, workclass name, and occupation name in lowercase, separated by the user-provided separator. The function declares a local variable v_combined_string of type VARCHAR2 to store the final concatenated result. It also declares three additional local variables to temporarily hold the fetched data: v_education_level of type VARCHAR2, v_workclass_name of type VARCHAR2, and v_occupation_name of type VARCHAR2. The function executes a SELECT statement that retrieves data from three tables: the individuals table, the work_classes table, and the occupations table. The SELECT statement fetches the education_level column from the individuals table, the workclass_name column from the work_classes table, and the occupation_name column from the occupations table. The individuals table is joined with the work_classes table using the workclass_id column as the joining key, and the individuals table is also joined with the occupations table using the occupation_id column as the joining key. The SELECT statement includes a WHERE clause that filters the results to only include the row where the individual_id column in the individuals table matches the value of the p_individual_id parameter. The retrieved values are stored into the three local variables v_education_level, v_workclass_name, and v_occupation_name using the INTO clause. After fetching the data, the function constructs the combined string by concatenating the lowercase version of v_education_level, the lowercase version of v_workclass_name, and the lowercase version of v_occupation_name, with each component separated by the p_separator parameter. This concatenation is performed using the LOWER function to convert each string to lowercase and the concatenation operator to join them with the separator. The resulting string is assigned to the v_combined_string variable. Finally, the function returns the value of v_combined_string, which represents the combined profile information for the specified individual.",
    "original_summary": "Create a PL/SQL function named get_combined_profile that returns a VARCHAR2(1000). It accepts an individual ID (NUMBER) and a separator string (VARCHAR2). For the given ID, query the individuals, work_classes, and occupations tables. Return a lowercase string concatenating the individual's education, workclass_name, and occupation_name, separated by the provided separator.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Construct a PL/SQL function, to be named get_combined_profile, which must yield a VARCHAR2(1000) as its return value. This function should be designed to accept two distinct parameters: an individual's unique identifier, which is a NUMBER, and a separator string, defined as a VARCHAR2. For the specified individual ID, you must meticulously query and retrieve relevant data from three separate tables: individuals, work_classes, and occupations. The function's ultimate output should be a single, lowercase string that elegantly concatenates the individual's education level, the associated workclass name, and the corresponding occupation name, with each of these three elements being distinctly separated by the user-provided separator character or string."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `GET_MAX_STOCK_QUANTITY` that is designed to return a single numeric value representing the highest stock quantity found within a specific database table. This function does not accept any input parameters. Upon execution, the function declares a local variable named `v_max_stock` of data type `NUMBER` to temporarily store the result of its primary operation. The core operation involves executing a `SELECT` statement to retrieve the maximum value from the `STOCK_QUANTITY` column within the `PRODUCTS` table. The result of this aggregation, which is the single highest `STOCK_QUANTITY` found across all rows in the `PRODUCTS` table, is then immediately assigned to the `v_max_stock` variable. Finally, the function returns the value currently held by the `v_max_stock` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION GET_MAX_STOCK_QUANTITY RETURN NUMBER IS\n    v_max_stock NUMBER;\nBEGIN\n    SELECT MAX(STOCK_QUANTITY) INTO v_max_stock FROM PRODUCTS;\n    RETURN v_max_stock;\nEND;",
    "database_name": "apparel_saim_730443",
    "tables": [
      "PRODUCTS",
      "CATEGORIES",
      "SIZES",
      "SUPPLIER_PRODUCTS"
    ],
    "call_sqls": [
      "SELECT GET_MAX_STOCK_QUANTITY FROM DUAL",
      "SELECT GET_MAX_STOCK_QUANTITY() FROM DUAL",
      "DECLARE\n  v_max_qty NUMBER;\nBEGIN\n  v_max_qty := GET_MAX_STOCK_QUANTITY;\n  DBMS_OUTPUT.PUT_LINE('Max Stock: ' || v_max_qty);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Maximum stock quantity is: ' || GET_MAX_STOCK_QUANTITY);\nEND;",
      "SELECT p.PRODUCT_NAME, p.STOCK_QUANTITY\nFROM PRODUCTS p\nWHERE p.STOCK_QUANTITY = GET_MAX_STOCK_QUANTITY"
    ],
    "summary": "Write a Oracle PL/SQL function named GET_MAX_STOCK_QUANTITY that returns the highest value found in the STOCK_QUANTITY column of the PRODUCTS table.",
    "natural_language": "Write a Oracle PL/SQL function named GET_MAX_STOCK_QUANTITY that returns the highest STOCK_QUANTITY from the PRODUCTS table.",
    "id": 60,
    "generated_ir": "Write an Oracle PL/SQL function named GET_MAX_STOCK_QUANTITY. This function does not accept any input parameters. It is designed to return a single numeric value of type NUMBER, representing the highest stock quantity found in the PRODUCTS table.\n\nThe function declares a local variable v_max_stock_quantity of type NUMBER to store the result of the database query.\n\nThe function performs a single SQL SELECT operation. It queries the PRODUCTS table to retrieve the maximum value from the STOCK_QUANTITY column. This is achieved using the aggregate function MAX on the STOCK_QUANTITY column. The query does not include a WHERE clause, meaning it scans all rows in the PRODUCTS table to compute the aggregate.\n\nThe result of this SELECT MAX(STOCK_QUANTITY) operation is fetched directly into the local variable v_max_stock_quantity.\n\nAfter the query executes, the function returns the value stored in v_max_stock_quantity. This returned value is the highest STOCK_QUANTITY present in the entire PRODUCTS table. If the PRODUCTS table is empty, the MAX function will return NULL, and the function will consequently return NULL.",
    "original_summary": "Create a PL/SQL function named `GET_MAX_STOCK_QUANTITY` with no parameters that returns the maximum stock quantity from the STOCK_QUANTITY column in the PRODUCTS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write function GET_MAX_STOCK_QUANTITY to return highest PRODUCTS.STOCK_QUANTITY."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_course_utilization_score that accepts a single input parameter p_course_id of type NUMBER and returns a NUMBER value, which calculates a utilization score for a specified course based on data from the COURSE_OFFERINGS and COURSES tables. The function first declares six local NUMBER variables: v_offerings_count, v_unique_faculty, v_avg_capacity, v_total_years, v_course_credits, and v_utilization_score, and a seventh variable v_year_span. It then performs a series of six independent SELECT queries. The first query counts the total number of rows in the COURSE_OFFERINGS table where the COURSE_ID column equals the input p_course_id, storing the result in v_offerings_count. The second query counts the distinct number of FACULTY_ID values from the COURSE_OFFERINGS table for the same p_course_id, storing the result in v_unique_faculty. The third query calculates the average COURSE_CAPACITY from the COURSES table for the row where COURSE_ID equals p_course_id, storing the result in v_avg_capacity. The fourth query counts the distinct number of YEAR values from the COURSE_OFFERINGS table for the given p_course_id, storing the result in v_total_years. The fifth query retrieves the single COURSE_CREDIT_HOURS value from the COURSES table for the specified p_course_id, storing it in v_course_credits. The sixth query calculates the span of years by subtracting the minimum YEAR from the maximum YEAR in the COURSE_OFFERINGS table for the given p_course_id, storing the result in v_year_span. Following these data retrievals, the function uses a conditional IF-ELSIF-ELSE block to compute the final v_utilization_score. If v_offerings_count is greater than 5, the score is calculated as (v_offerings_count multiplied by 2) plus (v_unique_faculty multiplied by 3) plus (v_avg_capacity multiplied by 0.1). If v_offerings_count is between 2 and 5 inclusive, the score is calculated as (v_offerings_count multiplied by 1.5) plus (v_unique_faculty multiplied by 2) plus (v_year_span multiplied by 0.5). For all other cases (where v_offerings_count is 0 or 1), the score is calculated as v_course_credits multiplied by v_avg_capacity. The function concludes by returning the computed v_utilization_score value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_course_utilization_score(p_course_id NUMBER) RETURN NUMBER IS\n    v_offerings_count NUMBER := 0;\n    v_unique_faculty NUMBER := 0;\n    v_avg_capacity NUMBER := 0;\n    v_total_years NUMBER := 0;\n    v_course_credits NUMBER := 0;\n    v_utilization_score NUMBER := 0;\n    v_year_span NUMBER := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_offerings_count\n    FROM COURSE_OFFERINGS\n    WHERE COURSE_ID = p_course_id;\n    \n    SELECT COUNT(DISTINCT FACULTY_ID) INTO v_unique_faculty\n    FROM COURSE_OFFERINGS\n    WHERE COURSE_ID = p_course_id;\n    \n    SELECT AVG(COURSE_CAPACITY) INTO v_avg_capacity\n    FROM COURSES\n    WHERE COURSE_ID = p_course_id;\n    \n    SELECT COUNT(DISTINCT YEAR) INTO v_total_years\n    FROM COURSE_OFFERINGS\n    WHERE COURSE_ID = p_course_id;\n    \n    SELECT COURSE_CREDIT_HOURS INTO v_course_credits\n    FROM COURSES\n    WHERE COURSE_ID = p_course_id;\n    \n    SELECT MAX(YEAR) - MIN(YEAR) INTO v_year_span\n    FROM COURSE_OFFERINGS\n    WHERE COURSE_ID = p_course_id;\n    \n    IF v_offerings_count > 5 THEN\n        v_utilization_score := (v_offerings_count * 2) + (v_unique_faculty * 3) + (v_avg_capacity * 0.1);\n    ELSIF v_offerings_count BETWEEN 2 AND 5 THEN\n        v_utilization_score := (v_offerings_count * 1.5) + (v_unique_faculty * 2) + (v_year_span * 0.5);\n    ELSE\n        v_utilization_score := v_course_credits * v_avg_capacity;\n    END IF;\n    \n    RETURN v_utilization_score;\nEND;",
    "database_name": "academic_farm_681390",
    "tables": [
      "COURSES",
      "COURSE_OFFERINGS",
      "FACULTY_MEMBERS"
    ],
    "call_sqls": [
      "SELECT calculate_course_utilization_score(101) FROM DUAL",
      "SELECT calculate_course_utilization_score(102) FROM DUAL",
      "SELECT calculate_course_utilization_score(103) FROM DUAL",
      "SELECT calculate_course_utilization_score(104) FROM DUAL",
      "SELECT calculate_course_utilization_score(105) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_course_utilization_score that takes a course ID as input and returns a numeric utilization score based on data from the COURSE_OFFERINGS and COURSES tables. The function calculates the score by retrieving the number of offerings, count of distinct FACULTY_ID, average COURSE_CAPACITY, total distinct YEAR, COURSE_CREDIT_HOURS, and the year span (difference between maximum and minimum YEAR) for the given course. If the offerings count is greater than 5, compute the score as (offerings * 2) + (distinct faculty * 3) + (average capacity * 0.1). If offerings are between 2 and 5, compute as (offerings * 1.5) + (distinct faculty * 2) + (year span * 0.5). If offerings are 0 or 1, compute as course credits multiplied by average capacity.",
    "natural_language": "Write a Oracle PL/SQL function called calculate_course_utilization_score that accepts a course ID and returns a numeric utilization score. The function should compute the score based on the count of offerings from the COURSE_OFFERINGS table, the number of unique FACULTY_ID who taught it from COURSE_OFFERINGS, the average COURSE_CAPACITY from the COURSES table, the total distinct YEAR from COURSE_OFFERINGS, the year span (difference between max and min YEAR) from COURSE_OFFERINGS, and the COURSE_CREDIT_HOURS from the COURSES table. Apply one formula if the offerings count exceeds 5, a different formula if the offerings count is between 2 and 5, and another if the offerings count is 0 or 1.",
    "id": 61,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_course_utilization_score that accepts a single input parameter p_course_id of type NUMBER and returns a NUMBER value, which calculates a utilization score for a specified course based on data from the COURSE_OFFERINGS and COURSES tables. The function first declares six local NUMBER variables: v_offerings_count, v_unique_faculty, v_avg_capacity, v_total_years, v_course_credits, and v_utilization_score, and a seventh variable v_year_span. It then performs a series of six independent SELECT queries. The first query counts the total number of rows in the COURSE_OFFERINGS table where the COURSE_ID column equals the input p_course_id, storing the result in v_offerings_count. The second query counts the distinct number of FACULTY_ID values from the COURSE_OFFERINGS table for the same p_course_id, storing the result in v_unique_faculty. The third query calculates the average COURSE_CAPACITY from the COURSES table for the row where COURSE_ID equals p_course_id, storing the result in v_avg_capacity. The fourth query counts the distinct number of YEAR values from the COURSE_OFFERINGS table for the given p_course_id, storing the result in v_total_years. The fifth query retrieves the single COURSE_CREDIT_HOURS value from the COURSES table for the specified p_course_id, storing it in v_course_credits. The sixth query calculates the span of years by subtracting the minimum YEAR from the maximum YEAR in the COURSE_OFFERINGS table for the given p_course_id, storing the result in v_year_span. Following these data retrievals, the function uses a conditional IF-ELSIF-ELSE block to compute the final v_utilization_score. If v_offerings_count is greater than 5, the score is calculated as (v_offerings_count multiplied by 2) plus (v_unique_faculty multiplied by 3) plus (v_avg_capacity multiplied by 0.1). If v_offerings_count is between 2 and 5 inclusive, the score is calculated as (v_offerings_count multiplied by 1.5) plus (v_unique_faculty multiplied by 2) plus (v_year_span multiplied by 0.5). For all other cases (where v_offerings_count is 0 or 1), the score is calculated as v_course_credits multiplied by v_avg_capacity. The function concludes by returning the computed v_utilization_score value.",
    "original_summary": "Create a PL/SQL function named calculate_course_utilization_score that takes a course ID as input and returns a numeric utilization score. The score is calculated based on the number of offerings, unique faculty who taught it, average capacity, total distinct years offered, year span, and course credits. Use different formulas if offerings >5, if offerings are between 2 and 5, or if offerings are 0 or 1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called calculate_course_utilization_score that accepts a course ID and outputs a numeric utilization score. Compute the score using the count of offerings, the number of unique faculty who taught it, the average capacity, the total distinct years offered, the year span, and the course credits. Apply one formula if offerings exceed 5, a different formula if offerings are between 2 and 5, and another if offerings are 0 or 1."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_total_training_time that accepts two input parameters: a numeric parameter named p_model_id and a numeric parameter named p_min_accuracy, and returns a single numeric value; the function declares a local numeric variable named v_total_time; the function's logic executes a SELECT query that retrieves data from the MODEL_VERSIONS table, specifically performing a SUM aggregation on the TRAINING_TIME_MINUTES column; this query includes a WHERE clause with two conditions joined by an AND operator, requiring that the MODEL_ID column value equals the input parameter p_model_id and that the VALIDATION_ACCURACY column value is greater than or equal to the input parameter p_min_accuracy; the result of this SUM aggregation is stored into the local variable v_total_time; the function then concludes by returning the value stored in v_total_time.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_training_time(p_model_id NUMBER, p_min_accuracy NUMBER) RETURN NUMBER IS\n  v_total_time NUMBER;\nBEGIN\n  SELECT SUM(TRAINING_TIME_MINUTES) INTO v_total_time FROM MODEL_VERSIONS WHERE MODEL_ID = p_model_id AND VALIDATION_ACCURACY >= p_min_accuracy;\n  RETURN v_total_time;\nEND;",
    "database_name": "machine_lmpm_404685",
    "tables": [
      "MODEL_VERSIONS",
      "PERFORMANCE_METRICS"
    ],
    "call_sqls": [
      "SELECT get_total_training_time(1, 0.85) FROM dual",
      "SELECT get_total_training_time(2, 0.90) FROM dual",
      "SELECT get_total_training_time(3, 0.75) FROM dual",
      "SELECT get_total_training_time(4, 0.80) FROM dual",
      "SELECT get_total_training_time(5, 0.95) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_total_training_time that, for a given MODEL_ID and a minimum VALIDATION_ACCURACY threshold, calculates and returns the total sum of TRAINING_TIME_MINUTES from the MODEL_VERSIONS table where the MODEL_ID matches the provided input and the VALIDATION_ACCURACY meets or exceeds the specified threshold.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called get_total_training_time that returns a NUMBER? It needs to take in two NUMBER inputs: p_model_id and p_min_accuracy. Basically, it should calculate the total TRAINING_TIME_MINUTES from the MODEL_VERSIONS table for all rows where the MODEL_ID matches the given p_model_id and the VALIDATION_ACCURACY is at least the provided p_min_accuracy.",
    "id": 62,
    "generated_ir": "Write an Oracle PL/SQL function named get_total_training_time that accepts two input parameters: a numeric parameter named p_model_id and a numeric parameter named p_min_accuracy, and returns a single numeric value; the function declares a local numeric variable named v_total_time; the function's logic executes a SELECT query that retrieves data from the MODEL_VERSIONS table, specifically performing a SUM aggregation on the TRAINING_TIME_MINUTES column; this query includes a WHERE clause with two conditions joined by an AND operator, requiring that the MODEL_ID column value equals the input parameter p_model_id and that the VALIDATION_ACCURACY column value is greater than or equal to the input parameter p_min_accuracy; the result of this SUM aggregation is stored into the local variable v_total_time; the function then concludes by returning the value stored in v_total_time.",
    "original_summary": "Create a PL/SQL function named get_total_training_time that returns a NUMBER. It accepts two NUMBER parameters: p_model_id and p_min_accuracy. The function returns the sum of TRAINING_TIME_MINUTES from the MODEL_VERSIONS table where MODEL_ID equals p_model_id and VALIDATION_ACCURACY is greater than or equal to p_min_accuracy.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called get_total_training_time that spits back a NUMBER? It needs to take in two NUMBER inputs: p_model_id and p_min_accuracy. Basically, it should add up all the TRAINING_TIME_MINUTES from the MODEL_VERSIONS table, but only for rows where the MODEL_ID matches the p_model_id we give it and the VALIDATION_ACCURACY is at least as good as the p_min_accuracy we're asking for."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_avg_victims_by_category` that accepts a single input parameter, `p_category_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `NUMBER`. The function's primary purpose is to compute the average number of victims for incidents belonging to a specific offense category. Inside the function's executable block, a local variable named `v_avg` of data type `NUMBER` is declared to temporarily store the calculated average. The function then executes a `SELECT` statement to retrieve data. This `SELECT` statement calculates the average (`AVG`) of the `VICTIM_COUNT` column from the `INCIDENTS` table. The result of this average calculation is then stored into the `v_avg` variable. The `SELECT` statement includes a `WHERE` clause that filters the rows from the `INCIDENTS` table, ensuring that only those incidents where the `OFFENSE_CATEGORY_ID` column matches the value provided in the input parameter `p_category_id` are considered for the average calculation. Finally, the function returns the value stored in the `v_avg` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_avg_victims_by_category(p_category_id NUMBER) RETURN NUMBER IS\n  v_avg NUMBER;\nBEGIN\n  SELECT AVG(VICTIM_COUNT) INTO v_avg FROM INCIDENTS WHERE OFFENSE_CATEGORY_ID = p_category_id;\n  RETURN v_avg;\nEND;",
    "database_name": "crime_iraa_893763",
    "tables": [
      "INCIDENTS",
      "INCIDENT_REPORTS",
      "INCIDENT_UPDATES",
      "OFFENSE_CATEGORIES",
      "OFFENSE_TYPES",
      "DISTRICTS"
    ],
    "call_sqls": [
      "SELECT calculate_avg_victims_by_category(0) FROM DUAL",
      "SELECT calculate_avg_victims_by_category(1) FROM DUAL",
      "SELECT calculate_avg_victims_by_category(2) FROM DUAL",
      "SELECT calculate_avg_victims_by_category(3) FROM DUAL",
      "SELECT calculate_avg_victims_by_category(4) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_avg_victims_by_category that, for a given OFFENSE_CATEGORY_ID, returns the average VICTIM_COUNT from the INCIDENTS table for that specific category.",
    "natural_language": "Write a Oracle PL/SQL function called `calculate_avg_victims_by_category` that returns the average `VICTIM_COUNT` from the `INCIDENTS` table for a given `OFFENSE_CATEGORY_ID`.",
    "id": 63,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_avg_victims_by_category that accepts a single parameter p_offense_category_id, which represents the offense category identifier for which the average victim count is to be calculated. The function returns a value of type NUMBER, which is the average VICTIM_COUNT of incidents associated with the specified offense category. Within the function, a local variable v_avg_victims of type NUMBER is declared to store the result of the average calculation. The function performs a SELECT operation to compute the average of the VICTIM_COUNT column from the INCIDENTS table, which contains data about crime incidents. The WHERE clause filters the results to include only those rows where the OFFENSE_CATEGORY_ID column in the INCIDENTS table matches the value of the input parameter p_offense_category_id. The computed average victim count is stored in the v_avg_victims variable using the INTO clause, which is then returned as the function's output.",
    "original_summary": "Create a PL/SQL function named `calculate_avg_victims_by_category` that returns the average `VICTIM_COUNT` from the `INCIDENTS` table for a given `OFFENSE_CATEGORY_ID`.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called `calculate_avg_victims_by_category` to return the average `VICTIM_COUNT` from the `INCIDENTS` table for a specified `OFFENSE_CATEGORY_ID`."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_total_citations` that does not accept any input parameters. This function is designed to return a single numeric value representing the total count of records within the `CITATIONS` table. Internally, the function declares a local variable named `total_citations` of type `NUMBER` to temporarily store the result of the database query. The core operation involves executing a `SELECT` statement that uses the `COUNT(*)` aggregate function to count all rows in the `CITATIONS` table. The result of this count operation is then immediately assigned to the `total_citations` local variable using the `INTO` clause. Finally, the function returns the value stored in the `total_citations` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_citations\nRETURN NUMBER\nIS\n    total_citations NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO total_citations FROM CITATIONS;\n    RETURN total_citations;\nEND;",
    "database_name": "genomic_dmaa_867750",
    "tables": [
      "TAXONS",
      "CLASSIFICATIONS",
      "TAXON_CLASSIFICATIONS",
      "PUBLICATIONS",
      "CITATIONS",
      "TAXON_SOURCES",
      "ACCESS_LOGS"
    ],
    "call_sqls": [
      "SELECT get_total_citations FROM DUAL",
      "SELECT get_total_citations() FROM DUAL",
      "DECLARE\n  v_total NUMBER;\nBEGIN\n  v_total := get_total_citations;\n  DBMS_OUTPUT.PUT_LINE('Total citations: ' || v_total);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Total citations: ' || get_total_citations);\nEND;",
      "SELECT get_total_citations AS total_citation_count FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_total_citations that returns the total count of all records in the CITATIONS table.",
    "natural_language": "Write a Oracle PL/SQL function named get_total_citations that accepts no input parameters and returns the total count of all records in the CITATIONS table.",
    "id": 64,
    "generated_ir": "Write an Oracle PL/SQL function named get_total_citations that accepts no input parameters and returns a NUMBER value representing the total count of all records in the CITATIONS table. The function first declares a local variable v_total_citations of type NUMBER to store the result of the count operation. The function logic executes a SQL SELECT statement that calculates the count of all rows in the CITATIONS table, using the COUNT(*) aggregation function. The result of this count is stored in the v_total_citations variable. The function then returns the value stored in v_total_citations, which represents the total number of records in the CITATIONS table.",
    "original_summary": "Create a PL/SQL function named get_total_citations with no parameters that returns the total number of records in the CITATIONS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a comprehensive PL/SQL function, which should be named get_total_citations, that accepts no input parameters and is designed to meticulously calculate and return the complete and total count of all existing records stored within the CITATIONS table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_customer_review_count that accepts a single parameter, p_customer_id, which is of type NUMBER and represents the unique identifier of a customer. The function is designed to return a NUMBER that indicates the total count of reviews associated with the specified customer. Within the function, a local variable v_count of type NUMBER is declared to store the result of the count operation. The function executes a SELECT statement that counts all rows in the customer_reviews table where the customer_id column matches the value provided in the p_customer_id parameter. The COUNT(*) function is used to determine the number of rows that meet this condition, and the result is stored in the v_count variable. Finally, the function returns the value of v_count, which represents the total number of reviews for the given customer.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_review_count(p_customer_id NUMBER) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM customer_reviews WHERE customer_id = p_customer_id;\n    RETURN v_count;\nEND;",
    "database_name": "apparel_sma_conversion",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_REVIEWS",
      "CUSTOMER_SIZES",
      "PRODUCTS",
      "RETURNS",
      "SIZE_CHARTS",
      "RECOMMENDATIONS"
    ],
    "call_sqls": [
      "SELECT get_customer_review_count(0) FROM DUAL",
      "SELECT get_customer_review_count(1) FROM DUAL",
      "SELECT get_customer_review_count(99) FROM DUAL",
      "SELECT get_customer_review_count(\n    (SELECT CUSTOMER_ID FROM CUSTOMERS WHERE FIRST_NAME = 'Alice' AND ROWNUM = 1)\n) FROM DUAL",
      "SELECT get_customer_review_count(\n    (SELECT CUSTOMER_ID FROM CUSTOMER_REVIEWS ORDER BY CREATED_AT DESC FETCH FIRST 1 ROW ONLY)\n) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_customer_review_count that accepts a customer ID and returns the total number of reviews for that customer by counting all matching rows in the customer_reviews table where the customer_id matches the provided ID.",
    "natural_language": "Write a Oracle PL/SQL function named get_customer_review_count that returns the total number of reviews a customer has by counting all rows in the customer_reviews table for the given customer ID.",
    "id": 65,
    "generated_ir": "Write an Oracle PL/SQL function named get_customer_review_count that accepts a single input parameter p_customer_id of type NUMBER, representing the unique identifier of a customer, and returns a NUMBER value. The function begins by declaring a local NUMBER variable v_review_count. It then executes a SELECT statement to query the customer_reviews table, counting all rows where the customer_id column matches the input p_customer_id, and stores this count in v_review_count. The function then returns the value of v_review_count.",
    "original_summary": "Create a PL/SQL function named get_customer_review_count that accepts a NUMBER parameter p_customer_id and returns a NUMBER. It counts all rows in the customer_reviews table where customer_id matches the input parameter.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write function get_customer_review_count(p_customer_id NUMBER) returning NUMBER to count customer_reviews rows for that ID."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_player_status that accepts a single parameter, para_player_id, of type NUMBER, which represents the unique identifier of a player. The function returns a value of type VARCHAR2, which indicates the status of the player. Within the function, declare three local variables: v_retired_year of type NUMBER, v_current_team_id of type NUMBER, and v_status of type VARCHAR2 with a maximum length of 255 characters. The function begins by executing a SELECT statement to retrieve the RETIRED_YEAR and CURRENT_TEAM_ID columns from the PLAYERS table for the row where PLAYER_ID matches the input parameter para_player_id. The retrieved values are stored in the local variables v_retired_year and v_current_team_id, respectively. Following the data retrieval, the function evaluates the value of v_retired_year using an IF conditional statement. If v_retired_year is not NULL, indicating the player has a retirement year recorded, the function assigns the string 'Retired' to the v_status variable. If v_retired_year is NULL, the function proceeds to an ELSIF condition to check if v_current_team_id is not NULL, which would imply the player is currently associated with a team. In this case, the function assigns 'Active' to v_status. If both v_retired_year and v_current_team_id are NULL, the ELSE condition is triggered, and the function assigns 'Free Agent' to v_status, indicating the player is not retired and not currently associated with any team. Finally, the function returns the value stored in v_status, which represents the player's status based on the conditions evaluated.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_status(para_player_id NUMBER) RETURN VARCHAR2 IS\n  v_retired_year NUMBER;\n  v_current_team_id NUMBER;\n  v_status VARCHAR2(255);\nBEGIN\n  SELECT RETIRED_YEAR, CURRENT_TEAM_ID INTO v_retired_year, v_current_team_id\n  FROM PLAYERS\n  WHERE PLAYER_ID = para_player_id;\n\n  IF v_retired_year IS NOT NULL THEN\n    v_status := 'Retired';\n  ELSIF v_current_team_id IS NOT NULL THEN\n    v_status := 'Active';\n  ELSE\n    v_status := 'Free Agent';\n  END IF;\n\n  RETURN v_status;\nEND;",
    "database_name": "basketball_ppat_statistic",
    "tables": [
      "PLAYERS",
      "TEAMS",
      "TEAM_SCHEDULE",
      "TEAM_STANDINGS"
    ],
    "call_sqls": [
      "SELECT get_player_status(1) FROM DUAL",
      "SELECT get_player_status(2) FROM DUAL",
      "SELECT get_player_status(3) FROM DUAL",
      "SELECT get_player_status(4) FROM DUAL",
      "SELECT get_player_status(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_player_status that takes a player ID and returns a status as text by retrieving the player's RETIRED_YEAR and CURRENT_TEAM_ID from the PLAYERS table; if RETIRED_YEAR is present, return 'Retired', otherwise if CURRENT_TEAM_ID is present, return 'Active', and if neither is present, return 'Free Agent'.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called get_player_status? It should take a player's ID and return a status as text. Here's the deal: retrieve the player's RETIRED_YEAR and CURRENT_TEAM_ID from the PLAYERS table using the provided player ID. If RETIRED_YEAR has a value, the status is 'Retired'. If RETIRED_YEAR is empty but CURRENT_TEAM_ID has a value, the status is 'Active'. If both RETIRED_YEAR and CURRENT_TEAM_ID are empty, the status is 'Free Agent'.",
    "id": 66,
    "generated_ir": "Write an Oracle PL/SQL function named get_player_status that accepts a single parameter, para_player_id, of type NUMBER, which represents the unique identifier of a player. The function returns a value of type VARCHAR2, which indicates the status of the player. Within the function, declare three local variables: v_retired_year of type NUMBER, v_current_team_id of type NUMBER, and v_status of type VARCHAR2 with a maximum length of 255 characters. The function begins by executing a SELECT statement to retrieve the RETIRED_YEAR and CURRENT_TEAM_ID columns from the PLAYERS table for the row where PLAYER_ID matches the input parameter para_player_id. The retrieved values are stored in the local variables v_retired_year and v_current_team_id, respectively. Following the data retrieval, the function evaluates the value of v_retired_year using an IF conditional statement. If v_retired_year is not NULL, indicating the player has a retirement year recorded, the function assigns the string 'Retired' to the v_status variable. If v_retired_year is NULL, the function proceeds to an ELSIF condition to check if v_current_team_id is not NULL, which would imply the player is currently associated with a team. In this case, the function assigns 'Active' to v_status. If both v_retired_year and v_current_team_id are NULL, the ELSE condition is triggered, and the function assigns 'Free Agent' to v_status, indicating the player is not retired and not currently associated with any team. Finally, the function returns the value stored in v_status, which represents the player's status based on the conditions evaluated.",
    "original_summary": "Create a PL/SQL function named get_player_status that takes a player ID (NUMBER) and returns a VARCHAR2 status. Retrieve the player's RETIRED_YEAR and CURRENT_TEAM_ID. If RETIRED_YEAR is not null, return 'Retired'. Else, if CURRENT_TEAM_ID is not null, return 'Active'. Otherwise, return 'Free Agent'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called get_player_status? It should take a player's ID (as a NUMBER) and spit back a VARCHAR2 status. Here's the deal: grab the player's RETIRED_YEAR and CURRENT_TEAM_ID. If RETIRED_YEAR is filled in, just say 'Retired'. If not, but CURRENT_TEAM_ID has a value, then they're 'Active'. If neither of those pans out, then the status is 'Free Agent'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_show_count_by_country` that is designed to return a single numeric value. This function accepts one input parameter: `p_country`, which is of data type `VARCHAR2`. The purpose of the `p_country` parameter is to specify the country for which the count of shows is to be determined. Inside the function, a local variable named `v_count` is declared, also of data type `NUMBER`, to temporarily store the result of the counting operation. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which calculates the total number of rows in the `SHOWS` table. The result of this count is then immediately stored into the `v_count` variable. The `SELECT` statement includes a `WHERE` clause that filters the rows from the `SHOWS` table. The condition in the `WHERE` clause is `COUNTRY = p_country`, which means that only those rows where the value in the `COUNTRY` column of the `SHOWS` table exactly matches the value provided in the `p_country` input parameter will be included in the count. Finally, the function returns the numeric value stored in the `v_count` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_show_count_by_country(p_country VARCHAR2) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count\n  FROM SHOWS\n  WHERE COUNTRY = p_country;\n  RETURN v_count;\nEND;",
    "database_name": "media_cma_tracking",
    "tables": [
      "RATINGS",
      "SHOWS"
    ],
    "call_sqls": [
      "SELECT get_show_count_by_country('United States') FROM dual",
      "SELECT get_show_count_by_country('United Kingdom') FROM dual",
      "SELECT get_show_count_by_country('Canada') FROM dual",
      "SELECT get_show_count_by_country('Australia') FROM dual",
      "SELECT get_show_count_by_country('India') FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_show_count_by_country that takes a country name as input and returns the total number of shows from the SHOWS table where the COUNTRY column matches the provided country.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called `get_show_count_by_country`? It should take a country name and return the total number of shows from the SHOWS table that match that country.",
    "id": 67,
    "generated_ir": "Write an Oracle PL/SQL function named get_show_count_by_country that accepts a single parameter p_country_name of type VARCHAR2, which represents the name of a country. The function returns a NUMBER type value, indicating the total count of shows associated with the specified country. Within the function, a local variable v_show_count of type NUMBER is declared to store the result of the query. The function executes a SELECT statement that counts the number of rows in the SHOWS table where the country column matches the value of the p_country_name parameter. The COUNT(*) function is used in the SELECT statement to calculate the total number of shows, and the result is stored into the local variable v_show_count using the INTO clause. After the SELECT operation, the function returns the value stored in v_show_count, which represents the total number of shows for the given country. The function does not involve any additional operations such as updates, inserts, or deletes, nor does it include any conditional logic or control flow structures.",
    "original_summary": "Create a PL/SQL function named `get_show_count_by_country` that takes a country name as a VARCHAR2 input and returns a NUMBER. The function counts and returns the number of shows in the SHOWS table where the COUNTRY column matches the input parameter.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called `get_show_count_by_country`? It should take a country name (as a VARCHAR2) and spit back a NUMBER. Basically, it just needs to count up all the shows in the SHOWS table that are from that country."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_property_maintenance_summary that accepts a single input parameter p_property_id of type NUMBER, which identifies a specific property, and returns a CLOB data type containing a textual summary. The function begins by declaring local variables: v_summary as a CLOB to hold the final result, v_request_count as a NUMBER to store the count of maintenance requests, v_upgrade_cost as a NUMBER to store the total cost of upgrades, and v_inspection_count as a NUMBER to store the count of inspections. The function's logic first queries the MAINTENANCE_REQUESTS table, counting all rows where the PROPERTY_ID column equals the input p_property_id, and stores this count in v_request_count. It then queries the PROPERTY_UPGRADES table, calculating the sum of the UPGRADE_COST column for rows where PROPERTY_ID equals p_property_id, using the NVL function to convert any NULL sum result to 0, and stores this value in v_upgrade_cost. Next, it queries the PROPERTY_INSPECTIONS table, counting all rows where the PROPERTY_ID column equals p_property_id, and stores this count in v_inspection_count. Following these data retrievals, the function uses a conditional IF-ELSIF-ELSE block to construct the summary string. If v_request_count is greater than 5, it builds a string using the TO_CLOB function, concatenating the literal 'High maintenance property with ', the v_request_count value, the literal ' requests and $', the v_upgrade_cost value, and the literal ' in upgrades', assigning it to v_summary. Otherwise, if the first condition is false and v_upgrade_cost is greater than 10000, it builds a string concatenating 'Heavily upgraded property with $', the v_upgrade_cost value, ' invested and ', the v_inspection_count value, and ' inspections', assigning it to v_summary. Otherwise, if the first two conditions are false and v_inspection_count is greater than 3, it builds a string concatenating 'Frequently inspected property with ', the v_inspection_count value, ' inspections and ', the v_request_count value, and ' maintenance requests', assigning it to v_summary. If none of the preceding conditions are true, it assigns the literal string 'Standard property with minimal maintenance activity' to v_summary. Finally, the function returns the value stored in the v_summary variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_property_maintenance_summary(p_property_id NUMBER) RETURN CLOB IS\n    v_summary CLOB;\n    v_request_count NUMBER;\n    v_upgrade_cost NUMBER;\n    v_inspection_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_request_count FROM MAINTENANCE_REQUESTS WHERE PROPERTY_ID = p_property_id;\n    SELECT NVL(SUM(UPGRADE_COST), 0) INTO v_upgrade_cost FROM PROPERTY_UPGRADES WHERE PROPERTY_ID = p_property_id;\n    SELECT COUNT(*) INTO v_inspection_count FROM PROPERTY_INSPECTIONS WHERE PROPERTY_ID = p_property_id;\n    \n    IF v_request_count > 5 THEN\n        v_summary := TO_CLOB('High maintenance property with ' || v_request_count || ' requests and $' || v_upgrade_cost || ' in upgrades');\n    ELSIF v_upgrade_cost > 10000 THEN\n        v_summary := TO_CLOB('Heavily upgraded property with $' || v_upgrade_cost || ' invested and ' || v_inspection_count || ' inspections');\n    ELSIF v_inspection_count > 3 THEN\n        v_summary := TO_CLOB('Frequently inspected property with ' || v_inspection_count || ' inspections and ' || v_request_count || ' maintenance requests');\n    ELSE\n        v_summary := TO_CLOB('Standard property with minimal maintenance activity');\n    END IF;\n    \n    RETURN v_summary;\nEND;",
    "database_name": "real_epmaa_773860",
    "tables": [
      "PROPERTIES",
      "MAINTENANCE_REQUESTS",
      "PROPERTY_INSPECTIONS",
      "PROPERTY_HISTORY",
      "PROPERTY_UPGRADES",
      "TENANTS"
    ],
    "call_sqls": [
      "SELECT get_property_maintenance_summary(1) FROM DUAL",
      "SELECT get_property_maintenance_summary(0) FROM DUAL",
      "SELECT get_property_maintenance_summary(100) FROM DUAL",
      "SELECT p.PROPERTY_ID, get_property_maintenance_summary(p.PROPERTY_ID) AS SUMMARY FROM PROPERTIES p WHERE p.PROPERTY_ID = 5",
      "SELECT p.PROPERTY_ID, p.PROPERTY_STATUS, get_property_maintenance_summary(p.PROPERTY_ID) AS MAINTENANCE_SUMMARY FROM PROPERTIES p WHERE p.PROPERTY_STATUS = 'rented' AND ROWNUM <= 1"
    ],
    "summary": "Write a Oracle PL/SQL function named get_property_maintenance_summary that accepts a property ID and returns a CLOB summary categorizing the property based on its maintenance activity. The function should retrieve the total number of maintenance requests from the MAINTENANCE_REQUESTS table, the total upgrade cost from the PROPERTY_UPGRADES table, and the total number of inspections from the PROPERTY_INSPECTIONS table for the given property ID. It should then generate a descriptive summary: if the request count exceeds 5, indicate a high maintenance property with the request count and upgrade cost; if the upgrade cost exceeds $10,000, indicate a heavily upgraded property with the cost and inspection count; if the inspection count exceeds 3, indicate a frequently inspected property with the inspection count and request count; otherwise, indicate a standard property with minimal activity.",
    "natural_language": "Write a Oracle PL/SQL function called get_property_maintenance_summary that takes a property ID number as input and returns a CLOB summary. For the given PROPERTY_ID, retrieve the total number of maintenance requests from MAINTENANCE_REQUESTS, the total upgrade cost from PROPERTY_UPGRADES, and the total number of inspections from PROPERTY_INSPECTIONS. Then, categorize the property based on these values: if the request count exceeds 5, describe it as high maintenance; if the upgrade cost is over $10,000, describe it as heavily upgraded; if the inspection count is more than 3, describe it as frequently inspected; otherwise, label it as standard with minimal activity. The summary should include the relevant counts and costs in its descriptive text.",
    "id": 68,
    "generated_ir": "Write an Oracle PL/SQL function named `get_property_maintenance_summary` that accepts one input parameter, `p_property_id`, which is of data type `NUMBER`. This function is designed to return a single value of data type `CLOB`. Internally, the function declares four local variables: `v_request_count` of data type `NUMBER`, intended to store the total number of maintenance requests; `v_upgrade_cost` of data type `NUMBER`, intended to store the total cost of property upgrades; `v_inspection_count` of data type `NUMBER`, intended to store the total number of inspections; and `v_summary` of data type `CLOB`, intended to store the final formatted summary text.\n\nThe function's logic begins by executing three separate `SELECT` statements to retrieve the required data from the database tables. The first `SELECT` statement queries the `MAINTENANCE_REQUESTS` table. It uses the `COUNT(*)` aggregate function to calculate the total number of rows. This `SELECT` statement includes a `WHERE` clause that filters the rows based on the `PROPERTY_ID` column, specifically selecting only those rows where the value in the `PROPERTY_ID` column is equal to the value provided in the input parameter `p_property_id`. The result of this count is stored in the local variable `v_request_count`.\n\nThe second `SELECT` statement queries the `PROPERTY_UPGRADES` table. It uses the `SUM` aggregate function to calculate the total of the `UPGRADE_COST` column. This `SELECT` statement includes a `WHERE` clause that filters the rows based on the `PROPERTY_ID` column, specifically selecting only those rows where the value in the `PROPERTY_ID` column is equal to the value provided in the input parameter `p_property_id`. The result of this sum is stored in the local variable `v_upgrade_cost`. If no rows match the condition, the `SUM` function will return `NULL`, which is handled by the variable assignment.\n\nThe third `SELECT` statement queries the `PROPERTY_INSPECTIONS` table. It uses the `COUNT(*)` aggregate function to calculate the total number of rows. This `SELECT` statement includes a `WHERE` clause that filters the rows based on the `PROPERTY_ID` column, specifically selecting only those rows where the value in the `PROPERTY_ID` column is equal to the value provided in the input parameter `p_property_id`. The result of this count is stored in the local variable `v_inspection_count`.\n\nFollowing the data retrieval, the function constructs the summary text in the `v_summary` CLOB variable. The construction involves a series of conditional checks to categorize the property. The function first initializes the `v_summary` with a base string that includes the retrieved numerical values, formatted as: \"Property Summary: [v_request_count] maintenance requests, $[v_upgrade_cost] in upgrade costs, [v_inspection_count] inspections. Categorization: \".\n\nThen, it evaluates three independent conditions to append descriptive labels. It checks if the value in `v_request_count` is greater than 5. If true, it appends the phrase \"high maintenance\" to the categorization section in `v_summary`. It checks if the value in `v_upgrade_cost` is greater than 10000. If true, it appends the phrase \"heavily upgraded\" to the categorization section. It checks if the value in `v_inspection_count` is greater than 3. If true, it appends the phrase \"frequently inspected\" to the categorization section. If none of the three conditions (`v_request_count > 5`, `v_upgrade_cost > 10000`, `v_inspection_count > 3`) are true, the function appends the phrase \"standard with minimal activity\" to the categorization section. The logic ensures that if multiple conditions are true, their corresponding labels are concatenated within the categorization text. Finally, the function returns the fully constructed CLOB value stored in the `v_summary` variable as its output.",
    "original_summary": "Create a PL/SQL function named get_property_maintenance_summary that accepts a property ID number and returns a CLOB summary. The summary categorizes the property based on maintenance request count, upgrade cost, and inspection count, with different descriptive text for each scenario.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called get_property_maintenance_summary that takes a property ID number as input and returns a CLOB summary. Categorize the property by its maintenance request count, upgrade cost, and inspection count, and provide distinct descriptive text for each possible scenario."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_player_college_name that accepts a single input parameter, p_player_id, of type NUMBER, which represents the unique identifier of a player. The function returns a value of type VARCHAR2, which is intended to be the name of the college associated with the specified player. Within the function, declare a local variable v_college_name of type VARCHAR2 with a maximum length of 255 characters to temporarily store the college name. The function begins by executing a SELECT statement that retrieves the COLLEGE_NAME from the COLLEGES table. This retrieval is performed by joining the PLAYERS table with the COLLEGES table on the condition that the COLLEGE_ID column in the PLAYERS table matches the COLLEGE_ID column in the COLLEGES table. The SELECT statement includes a WHERE clause that filters the results to only include the row where the PLAYER_ID column in the PLAYERS table matches the value of the input parameter p_player_id. The result of the SELECT statement, which is the college name, is stored into the local variable v_college_name. Finally, the function returns the value stored in v_college_name, which is the name of the college associated with the player identified by the input parameter p_player_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_college_name(p_player_id NUMBER)\nRETURN VARCHAR2\nIS\n    v_college_name VARCHAR2(255);\nBEGIN\n    SELECT C.COLLEGE_NAME INTO v_college_name \n    FROM PLAYERS P JOIN COLLEGES C ON P.COLLEGE_ID = C.COLLEGE_ID \n    WHERE P.PLAYER_ID = p_player_id;\n    RETURN v_college_name;\nEND;",
    "database_name": "nba_psa_information",
    "tables": [
      "PLAYERS",
      "COLLEGES",
      "DRAFTS",
      "POSITIONS",
      "TEAMS",
      "ALL_STAR_GAMES"
    ],
    "call_sqls": [
      "SELECT get_player_college_name(101) FROM DUAL",
      "SELECT get_player_college_name(205) FROM DUAL",
      "SELECT get_player_college_name(312) FROM DUAL",
      "SELECT get_player_college_name(418) FROM DUAL",
      "SELECT get_player_college_name(529) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_player_college_name that, given a player ID number, retrieves and returns the corresponding college name from the COLLEGES table by joining it with the PLAYERS table where the PLAYER_ID matches the input.",
    "natural_language": "Write a Oracle PL/SQL function called get_player_college_name that takes a player ID number as input and returns the full college name as a string by retrieving the corresponding college name from the COLLEGES table for the specified player in the PLAYERS table.",
    "id": 69,
    "generated_ir": "Write an Oracle PL/SQL function named `get_player_college_name` that is designed to retrieve the full college name for a specific player from a database. This function accepts one input parameter: `p_player_id`, which is of data type `NUMBER`. The purpose of `p_player_id` is to uniquely identify the player whose college name is to be retrieved. The function is declared to return a value of data type `VARCHAR2`. Internally, the function declares a local variable named `v_college_name` of data type `VARCHAR2` with a sufficient maximum length, such as 100 characters. This variable is intended to temporarily store the college name retrieved from the database. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement queries the `COLLEGES` table by joining it with the `PLAYERS` table. Specifically, it selects the value from the `college_name` column in the `COLLEGES` table. The retrieved `college_name` value is then immediately stored into the `v_college_name` local variable using the `INTO` clause. The selection is constrained by a `WHERE` clause that specifies the join condition: the `college_id` column in the `PLAYERS` table must equal the `college_id` column in the `COLLEGES` table. An additional condition in the `WHERE` clause ensures that only the row where the `player_id` column in the `PLAYERS` table matches the value provided in the input parameter `p_player_id` is considered. After successfully executing the `SELECT` statement and populating `v_college_name` with the corresponding college name, the function then returns the value stored in `v_college_name` as its output. If no matching row is found, the function will handle the `NO_DATA_FOUND` exception implicitly by not assigning a value to `v_college_name`, but in a typical implementation, it would return `NULL` in such a case.",
    "original_summary": "Create a function named get_player_college_name that accepts a player ID number and returns the college name string by joining the PLAYERS and COLLEGES tables.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Construct a function called get_player_college_name which is designed to take a specific player ID number as its input parameter and, through a detailed join operation between the comprehensive PLAYERS table and the extensive COLLEGES table, meticulously returns the corresponding full college name as a complete string."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_latest_data_set_version that accepts a single input parameter p_data_set_id of type NUMBER, which represents the identifier of a data set. The function is designed to return a value of type VARCHAR2. Within the function, a local variable v_version of type VARCHAR2 with a maximum length of 255 characters is declared to store the result of a query. The function executes a SELECT statement that retrieves the maximum value of the VERSION_NUMBER column from the DATA_VERSIONS table, where the DATA_SET_ID column matches the input parameter p_data_set_id. The NVL function is used to handle cases where no matching records are found; it substitutes the string 'No Version' if the MAX function returns a NULL value. The result of this query is stored in the v_version variable. Finally, the function returns the value of v_version, which represents the latest version number of the specified data set or 'No Version' if no versions exist for the given data set ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_latest_data_set_version(p_data_set_id IN NUMBER) RETURN VARCHAR2 IS\n    v_version VARCHAR2(255);\nBEGIN\n    SELECT NVL(MAX(dv.VERSION_NUMBER), 'No Version') INTO v_version\n    FROM DATA_VERSIONS dv\n    WHERE dv.DATA_SET_ID = p_data_set_id;\n    RETURN v_version;\nEND;",
    "database_name": "demographic_asda_428440",
    "tables": [
      "DATA_SETS",
      "DATA_SOURCES",
      "DATA_VERSIONS",
      "INDIVIDUALS",
      "RESEARCH_TEAMS"
    ],
    "call_sqls": [
      "SELECT get_latest_data_set_version(0) FROM DUAL",
      "SELECT get_latest_data_set_version(1) FROM DUAL",
      "SELECT ds.DATA_SET_NAME, get_latest_data_set_version(ds.DATA_SET_ID) AS LATEST_VERSION FROM DATA_SETS ds WHERE ds.DATA_SET_ID = 0",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Latest Version: ' || get_latest_data_set_version(1));\nEND;",
      "SELECT DATA_SET_ID, get_latest_data_set_version(DATA_SET_ID) FROM DATA_SETS WHERE DATA_SET_ID IN (0, 1)"
    ],
    "summary": "Write a Oracle PL/SQL function named get_latest_data_set_version that takes a data set ID and returns the latest VERSION_NUMBER from the DATA_VERSIONS table for that ID, returning 'No Version' if no version exists.",
    "natural_language": "Write a Oracle PL/SQL function named get_latest_data_set_version that accepts a data set identifier and returns the most recent VERSION_NUMBER from the DATA_VERSIONS table for that identifier; if no version exists, return 'No Version'.",
    "id": 70,
    "generated_ir": "Write an Oracle PL/SQL function named get_latest_data_set_version that accepts one input parameter: p_data_set_id, which is of the NUMBER data type. The function returns a VARCHAR2 value. Within the function, a local variable v_latest_version of type VARCHAR2(255) is declared to store the most recent version number. The function performs a SELECT operation on the DATA_VERSIONS table, specifically retrieving the maximum value from the VERSION_NUMBER column for the rows where the DATA_SET_ID column matches the input parameter p_data_set_id. This is achieved using the MAX aggregate function. The retrieved maximum version number is stored in the v_latest_version variable. If no matching rows are found (i.e., the SELECT statement returns NULL), the function uses an IF-THEN-ELSE control structure to check for this condition and assigns the string 'No Version' to v_latest_version. Finally, the function returns the value stored in v_latest_version, which is either the most recent VERSION_NUMBER for the given data set identifier or the string 'No Version' if no version exists.",
    "original_summary": "Create a function named get_latest_data_set_version that takes a data set ID (NUMBER) and returns the latest VERSION_NUMBER (VARCHAR2) from the DATA_VERSIONS table for that ID. If no version exists, return 'No Version'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a function designated as 'get_latest_data_set_version'. This function shall accept a single input parameter, specifically a data set identifier of the NUMBER data type. Its purpose is to retrieve the most recent VERSION_NUMBER, defined as VARCHAR2, from the DATA_VERSIONS table corresponding to the provided identifier. In the event that no version record is found for the given identifier, the function must return the string 'No Version'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_team_contract_variance that accepts a single parameter p_team_id of type NUMBER, which represents the unique identifier of a team. The function calculates and returns the statistical variance of contract values for all players belonging to the specified team. Inside the function, a local variable v_variance of type NUMBER is declared to store the result of the variance calculation. The function performs a SELECT operation to compute the variance of the CONTRACT_VALUE column from the CONTRACTS table. This calculation is done by joining the CONTRACTS table with the PLAYERS table on the PLAYER_ID column, ensuring that the contract values considered are only those associated with players whose TEAM_ID matches the provided p_team_id parameter. The result of the variance calculation is stored in the v_variance variable, which is then returned as the output of the function. The function does not include any conditional statements or special operations beyond the variance calculation and the table join.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_contract_variance(p_team_id NUMBER) RETURN NUMBER IS\n    v_variance NUMBER;\nBEGIN\n    SELECT VARIANCE(c.CONTRACT_VALUE) INTO v_variance FROM CONTRACTS c JOIN PLAYERS p ON c.PLAYER_ID = p.PLAYER_ID WHERE p.TEAM_ID = p_team_id;\n    RETURN v_variance;\nEND;",
    "database_name": "nba_tsap_trackin",
    "tables": [
      "AWARDS",
      "COACHES",
      "CONTRACTS",
      "GAMES",
      "GAME_STATISTICS",
      "INJURIES",
      "PLAYERS",
      "TEAMS"
    ],
    "call_sqls": [
      "SELECT get_team_contract_variance(0) FROM DUAL",
      "SELECT get_team_contract_variance(1) FROM DUAL",
      "SELECT get_team_contract_variance(10) FROM DUAL",
      "SELECT get_team_contract_variance( (SELECT TEAM_ID FROM TEAMS WHERE TEAM_NAME = 'San Antonio Spurs') ) FROM DUAL",
      "SELECT TEAM_ID, TEAM_NAME, get_team_contract_variance(TEAM_ID) AS CONTRACT_VARIANCE FROM TEAMS"
    ],
    "summary": "Write a Oracle PL/SQL function named `get_team_contract_variance` that accepts a team ID and returns the statistical variance of the CONTRACT_VALUE from the CONTRACTS table for all players whose TEAM_ID in the PLAYERS table matches the given team ID.",
    "natural_language": "Write a Oracle PL/SQL function called `get_team_contract_variance` that takes a team identifier as input and returns the statistical variance of the `CONTRACT_VALUE` from the `CONTRACTS` table for all players whose `TEAM_ID` in the `PLAYERS` table matches the given team identifier.",
    "id": 71,
    "generated_ir": "Write an Oracle PL/SQL function named `get_team_contract_variance` that accepts a single input parameter, `p_team_id`, of data type `NUMBER` (or the appropriate data type matching the `TEAM_ID` column in the `PLAYERS` table). This function is designed to return a `NUMBER` value representing the statistical variance of the `CONTRACT_VALUE` for all players belonging to the specified team.\n\nThe function will operate on the `nba_tsap_trackin` database. Internally, the function declares a local variable named `v_variance` of data type `NUMBER` to store the calculated variance result.\n\nThe core operation involves a single `SELECT` statement that calculates the variance of the `CONTRACT_VALUE` column from the `CONTRACTS` table. This calculation uses the Oracle `VARIANCE` aggregate function. The `SELECT` statement includes a `WHERE` clause to filter the contracts considered in the variance calculation. This filtering is based on a subquery or a join condition that ensures only contracts for players associated with the input team identifier are included.\n\nSpecifically, the `SELECT` statement will join the `CONTRACTS` table (likely aliased as `c`) with the `PLAYERS` table (likely aliased as `p`). The join condition will be that the `PLAYER_ID` column in the `CONTRACTS` table matches the `PLAYER_ID` column in the `PLAYERS` table (`c.PLAYER_ID = p.PLAYER_ID`). The `WHERE` clause will then filter the joined result set so that only rows where the `TEAM_ID` column in the `PLAYERS` table equals the value provided by the input parameter `p_team_id` (`p.TEAM_ID = p_team_id`) are considered for the variance calculation.\n\nThe calculated variance value from this `SELECT` statement is directly fetched into the local variable `v_variance`. Finally, the function returns the value stored in `v_variance`. If no players are found for the given `TEAM_ID`, the `VARIANCE` function will return `NULL`, which the function will consequently return.",
    "original_summary": "Create a PL/SQL function named `get_team_contract_variance` that accepts a `NUMBER` parameter `p_team_id` and returns a `NUMBER`. It should calculate and return the variance of `CONTRACT_VALUE` from the `CONTRACTS` table for players whose `TEAM_ID` in the `PLAYERS` table matches the input.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function called `get_team_contract_variance` which is designed to take a single numeric input parameter, specifically `p_team_id`, and subsequently provide a numeric return value. This function's essential purpose is to meticulously compute and then deliver the statistical variance of the `CONTRACT_VALUE` column. It performs this calculation by carefully selecting relevant data from the `CONTRACTS` table, but only for those players whose associated `TEAM_ID`, as recorded in the detailed `PLAYERS` table, precisely corresponds to the team identifier supplied as the input argument."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_team_losses that accepts two input parameters: p_team_id of type NUMBER, which represents the unique identifier of a team, and p_season_id of type NUMBER, which represents the unique identifier of a season. The function is designed to return a value of type NUMBER. Within the function, declare a local variable v_losses of type NUMBER to store the result of a query. The function begins by executing a SELECT statement that retrieves the value from the LOSSES column in the TEAM_PERFORMANCE table, where the TEAM_ID column matches the value of the p_team_id parameter and the SEASON_ID column matches the value of the p_season_id parameter. The retrieved value is stored in the v_losses variable. Finally, the function returns the value stored in v_losses, which represents the number of losses for the specified team in the specified season.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_losses(p_team_id NUMBER, p_season_id NUMBER) RETURN NUMBER IS\nv_losses NUMBER;\nBEGIN\nSELECT LOSSES INTO v_losses FROM TEAM_PERFORMANCE WHERE TEAM_ID = p_team_id AND SEASON_ID = p_season_id;\nRETURN v_losses;\nEND;",
    "database_name": "sports_tpas_818815",
    "tables": [
      "GAMES",
      "PLAYERS",
      "PLAYER_PERFORMANCE",
      "SEASONS",
      "TEAM_PERFORMANCE"
    ],
    "call_sqls": [
      "SELECT get_team_losses(1, 1) FROM dual",
      "SELECT get_team_losses(2, 1) FROM dual",
      "SELECT get_team_losses(1, 2) FROM dual",
      "SELECT get_team_losses(2, 2) FROM dual",
      "SELECT get_team_losses(0, 0) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_team_losses that, given a TEAM_ID and a SEASON_ID, retrieves the corresponding LOSSES value from the TEAM_PERFORMANCE table and returns it as a numeric count of losses.",
    "natural_language": "Write a Oracle PL/SQL function named get_team_losses that returns the numeric losses for a specified team and season by retrieving the LOSSES value from the TEAM_PERFORMANCE table where TEAM_ID and SEASON_ID match the given inputs.",
    "id": 72,
    "generated_ir": "Write an Oracle PL/SQL function named get_team_losses that accepts two input parameters: p_team_id of type NUMBER, representing the unique identifier of a team, and p_season_id of type NUMBER, representing the unique identifier of a season. The function returns a value of type NUMBER, which corresponds to the losses count for the specified team and season. Within the function, a local variable v_losses of type NUMBER is declared to store the retrieved value. The function performs a SELECT operation on the TEAM_PERFORMANCE table within the sports_tpas_818815 database. It retrieves the value from the LOSSES column where the TEAM_ID column equals the input parameter p_team_id and the SEASON_ID column equals the input parameter p_season_id. This retrieved value is stored into the local variable v_losses. The function then returns the value of v_losses. The function does not contain any conditional logic, loops, or data manipulation operations such as INSERT, UPDATE, or DELETE; it solely executes a SELECT query to fetch the required data.",
    "original_summary": "Create a PL/SQL function named get_team_losses that accepts a team ID and a season ID, queries the TEAM_PERFORMANCE table for the LOSSES column where TEAM_ID and SEASON_ID match, and returns the numeric loss count.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a function get_team_losses returning numeric losses for a given team and season."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_vehicle_count_by_model that accepts a single input parameter p_model_name of type VARCHAR2 and returns a value of type NUMBER; the function declares a local variable v_count of type NUMBER; the function's logic executes a SELECT statement that performs an INNER JOIN between the VEHICLES table (aliased as v) and the VEHICLE_MODELS table (aliased as vm) using the condition that the MODEL column from the VEHICLES table matches the MODEL_NAME column from the VEHICLE_MODELS table; within this joined result set, the function applies a WHERE clause filter to include only those rows where the MODEL_NAME column from the VEHICLE_MODELS table is exactly equal to the value of the input parameter p_model_name; the function then uses the COUNT(*) aggregate function to calculate the total number of rows that satisfy this join and filter condition; the result of this count is stored into the local variable v_count using the INTO clause; finally, the function returns the value stored in v_count as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_vehicle_count_by_model(p_model_name VARCHAR2) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM VEHICLES v\n    JOIN VEHICLE_MODELS vm ON v.MODEL = vm.MODEL_NAME\n    WHERE vm.MODEL_NAME = p_model_name;\n    RETURN v_count;\nEND;",
    "database_name": "automotive_dma_operations",
    "tables": [
      "DEALERSHIPS",
      "VEHICLES",
      "VEHICLE_MODELS"
    ],
    "call_sqls": [
      "SELECT get_vehicle_count_by_model('Civic') FROM DUAL",
      "SELECT get_vehicle_count_by_model('F-150') FROM DUAL",
      "SELECT get_vehicle_count_by_model('Model 3') FROM DUAL",
      "SELECT get_vehicle_count_by_model('Camry') FROM DUAL",
      "SELECT get_vehicle_count_by_model('Wrangler') FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_vehicle_count_by_model that accepts a model name and returns the total count of vehicles from the VEHICLES table that match that model, by joining with the VEHICLE_MODELS table where VEHICLES.MODEL equals VEHICLE_MODELS.MODEL_NAME.",
    "natural_language": "Write a Oracle PL/SQL function named get_vehicle_count_by_model that takes a model name and returns the total number of vehicles from the VEHICLES table that match the given model name, based on a join with the VEHICLE_MODELS table.",
    "id": 73,
    "generated_ir": "Write an Oracle PL/SQL function named get_vehicle_count_by_model that accepts a single input parameter p_model_name of type VARCHAR2, which represents the name of a vehicle model. The function is designed to return a value of type NUMBER, specifically the total count of vehicles associated with the given model name. Within the function, declare a local variable v_vehicle_count of type NUMBER to temporarily store the computed count. The function begins by executing a SELECT statement that performs an aggregation to count the number of vehicle records. This is achieved by performing an INNER JOIN between the VEHICLES table, aliased as 'v', and the VEHICLE_MODELS table, aliased as 'vm'. The join condition is that the model_id column in the VEHICLES table matches the model_id column in the VEHICLE_MODELS table. The WHERE clause of the SELECT statement filters the results to include only rows where the model_name column in the VEHICLE_MODELS table equals the input parameter p_model_name. The result of this COUNT aggregation query is stored into the local variable v_vehicle_count. The function then returns the value of v_vehicle_count. The function includes exception handling to manage potential runtime errors: if the SELECT statement does not find any matching rows, the NO_DATA_FOUND exception is caught, and the function returns 0; if any other unexpected exception occurs, it is caught in a generic WHEN OTHERS exception handler, and the function also returns 0.",
    "original_summary": "Create a PL/SQL function named get_vehicle_count_by_model that accepts a VARCHAR2 model name parameter and returns a NUMBER. The function should count vehicles from the VEHICLES table that have a model matching the input parameter, using an INNER JOIN with the VEHICLE_MODELS table on MODEL = MODEL_NAME.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a function get_vehicle_count_by_model that takes a model name and returns the count of matching vehicles from VEHICLES joined with VEHICLE_MODELS."
  },
  {
    "ir": "Write an Oracle PL/SQL function named validate_email_format that accepts a single input parameter p_email of type VARCHAR2 and returns a NUMBER. The function evaluates the format of the provided email string by checking for the presence and relative position of the '@' and '.' characters using the INSTRC function. The logic flow is as follows: first, it checks if the '@' character exists at any position greater than zero and if the '.' character exists at a position after the '@' character; if both conditions are true, the function returns the value 1. If the '@' character exists but the '.' character is not found at all, the function returns the value 2. If the '@' character is not found but the '.' character is present, the function returns the value 3. For all other cases, including when neither character is found, the function returns the value 0.",
    "plsql": "CREATE OR REPLACE FUNCTION validate_email_format(p_email VARCHAR2) RETURN NUMBER IS\nBEGIN\n  IF INSTRC(p_email, '@') > 0 AND INSTRC(p_email, '.') > INSTRC(p_email, '@') THEN\n    RETURN 1;\n  ELSIF INSTRC(p_email, '@') > 0 AND INSTRC(p_email, '.') = 0 THEN\n    RETURN 2;\n  ELSIF INSTRC(p_email, '@') = 0 AND INSTRC(p_email, '.') > 0 THEN\n    RETURN 3;\n  ELSE\n    RETURN 0;\n  END IF;\nEND;",
    "database_name": "customer_rmadt_130963",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "SELECT validate_email_format('test@example.com') FROM DUAL",
      "SELECT validate_email_format('invalid-email') FROM DUAL",
      "SELECT validate_email_format('user@domain') FROM DUAL",
      "SELECT validate_email_format('domain.com') FROM DUAL",
      "SELECT CUSTOMER_ID, EMAIL, validate_email_format(EMAIL) AS EMAIL_VALIDATION FROM CUSTOMERS WHERE ROWNUM <= 5"
    ],
    "summary": "Write a Oracle PL/SQL function named validate_email_format that takes an email string and returns a number indicating its format: return 1 if the email contains '@' and a '.' appears after '@', return 2 if it contains '@' but no '.', return 3 if it contains '.' but no '@', and return 0 for all other cases.",
    "natural_language": "Write a Oracle PL/SQL function named validate_email_format that takes an email string as input and returns a number indicating its format: return 1 if the email contains an '@' and a dot after the '@', return 2 if it contains an '@' but no dot anywhere, return 3 if it has no '@' but does have a dot, and return 0 for any other case.",
    "id": 74,
    "generated_ir": "Write an Oracle PL/SQL function named `validate_email_format` that accepts a single input parameter, `p_email`, which is of data type `VARCHAR2`. This function is designed to return a single value of data type `NUMBER`. The function's execution begins by declaring three local variables: `v_at_position` of data type `NUMBER`, `v_dot_position` of data type `NUMBER`, and `v_dot_after_at_position` of data type `NUMBER`. The function does not perform any SQL operations such as `SELECT`, `INSERT`, `UPDATE`, or `DELETE` on database tables; it operates solely on the input string using built-in string functions.\n\nThe business logic proceeds as follows: First, the function uses the `INSTR` function to find the position of the '@' character within the input string `p_email`. The `INSTR` function is called with two arguments: the string `p_email` and the substring `'@'`. The result, which is the numeric position of the first occurrence of '@' (or 0 if '@' is not found), is stored in the variable `v_at_position`.\n\nSecond, the function uses the `INSTR` function again to find the position of the '.' character within the input string `p_email`. The `INSTR` function is called with two arguments: the string `p_email` and the substring `'.'`. The result, which is the numeric position of the first occurrence of '.' (or 0 if '.' is not found), is stored in the variable `v_dot_position`.\n\nThird, the function checks if an '@' character was found (i.e., if `v_at_position` is greater than 0). If true, it then uses the `INSTR` function a third time to find the position of the '.' character, but this search starts *after* the position of the '@' character. The `INSTR` function is called with three arguments: the string `p_email`, the substring `'.'`, and the starting position for the search, which is `v_at_position + 1`. The result, which is the numeric position of the first '.' occurring after the '@' (or 0 if no '.' is found after '@'), is stored in the variable `v_dot_after_at_position`.\n\nThe control flow then evaluates a series of conditional statements (`IF` and `ELSIF`) to determine the return value based on the positions found.\n\nThe first condition checks if `v_at_position` is greater than 0 (meaning '@' exists) AND `v_dot_after_at_position` is greater than 0 (meaning a '.' exists somewhere after the '@' character). If both conditions are true, the function returns the number `1`.\n\nIf the first condition is false, the function evaluates a second condition: if `v_at_position` is greater than 0 (meaning '@' exists) AND `v_dot_position` equals 0 (meaning no '.' exists anywhere in the string). If this condition is true, the function returns the number `2`.\n\nIf the second condition is false, the function evaluates a third condition: if `v_at_position` equals 0 (meaning '@' does not exist) AND `v_dot_position` is greater than 0 (meaning a '.' does exist). If this condition is true, the function returns the number `3`.\n\nIf none of the above three conditions are true, the function executes an `ELSE` block and returns the number `0`.\n\nThe return value is a numeric code: `1` for a valid format with '@' and a dot after it, `2` for an email with '@' but no dot at all, `3` for a string with no '@' but with a dot, and `0` for any other combination (e.g., a string with neither '@' nor '.', or a string where the dot appears before the '@').",
    "original_summary": "Create a function named validate_email_format that takes an email string and returns a number: 1 if '@' exists and '.' appears after '@', 2 if '@' exists but '.' is absent, 3 if '@' is absent but '.' exists, and 0 for all other cases.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Alright, so I need you to write a function called validate_email_format. You'll feed it an email string, and it'll spit back a number. Here's the deal: if the email's got an '@' and a dot comes after that '@', return 1. If it's got an '@' but no dot anywhere, give me a 2. If there's no '@' at all but there is a dot, that's a 3. For anything else that doesn't fit those rules, just return 0."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_product_line_count that takes no input parameters and returns a single numeric value; within its execution block, it declares a local numeric variable v_count, then performs a SELECT statement that queries the PRODUCT_LINES table to count all rows where the IS_ACTIVE column has a value equal to 1, storing the result of this COUNT(*) aggregation into the v_count variable, and finally returns the value stored in v_count as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_line_count RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM PRODUCT_LINES WHERE IS_ACTIVE = 1;\n    RETURN v_count;\nEND;",
    "database_name": "fashion_scam_standards",
    "tables": [
      "MEASUREMENTS",
      "MEASUREMENT_GUIDELINES",
      "PRODUCT_LINES",
      "SIZE_CHARTS",
      "SIZE_ISSUES",
      "REGIONS"
    ],
    "call_sqls": [
      "SELECT get_product_line_count FROM DUAL",
      "SELECT get_product_line_count() FROM DUAL",
      "DECLARE\n  v_count NUMBER;\nBEGIN\n  v_count := get_product_line_count;\n  DBMS_OUTPUT.PUT_LINE('Count: ' || v_count);\nEND;",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Active product lines: ' || get_product_line_count);\nEND;",
      "SELECT get_product_line_count AS active_product_line_count FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_product_line_count that returns the total number of active product lines by counting all rows in the PRODUCT_LINES table where the IS_ACTIVE column equals 1.",
    "natural_language": "Write a Oracle PL/SQL function called get_product_line_count that returns the total number of active product lines by counting all rows in the PRODUCT_LINES table where the IS_ACTIVE column equals 1.",
    "id": 75,
    "generated_ir": "Write an Oracle PL/SQL function named `get_product_line_count` that returns a numeric value representing the total count of active product lines. This function does not accept any input parameters. Within the function, a local variable `v_count` of data type `NUMBER` is declared to store the result of a database query. The function executes a `SELECT` statement against the `PRODUCT_LINES` table, which resides in the `fashion_scam_standards` database. The query uses the `COUNT(*)` aggregate function to calculate the total number of rows. A `WHERE` clause filters the rows, specifying that only rows where the `IS_ACTIVE` column equals the numeric literal `1` should be included in the count. The result of this count operation is retrieved and stored into the local variable `v_count` using the `INTO` clause. Finally, the function returns the value stored in `v_count`, which represents the total number of product lines marked as active in the `PRODUCT_LINES` table. No `INSERT`, `UPDATE`, or `DELETE` operations are performed, and no other tables are accessed or joined.",
    "original_summary": "Create a PL/SQL function named get_product_line_count with no parameters that returns the count of rows from the PRODUCT_LINES table where the IS_ACTIVE column equals 1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function called get_product_line_count, which accepts no input parameters, to meticulously calculate and return the precise number of entries found within the PRODUCT_LINES table, specifically targeting those rows where the IS_ACTIVE column is explicitly set to the value of 1."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_high_priority_tasks that accepts two parameters: p_project_id of type NUMBER, representing the identifier of a project, and p_user_id of type NUMBER, representing the identifier of a user. The function returns a NUMBER, which is the count of tasks that are considered high priority for the specified project and assigned to the specified user. Within the function, a local variable v_task_count of type NUMBER is declared to store the result of the query. The function executes a SELECT statement that performs a COUNT operation to determine the number of rows in the TASKS table that meet specific criteria. The TASKS table is joined with the TASK_ASSIGNMENTS table using the TASK_ID column, ensuring that only tasks assigned to users are considered. The WHERE clause filters the results to include only those tasks where the PROJECT_ID column in the TASKS table matches the p_project_id parameter, and the USER_ID column in the TASK_ASSIGNMENTS table matches the p_user_id parameter. Additionally, the TASK_PRIORITY column in the TASKS table is checked to ensure it is equal to 'HIGH', using the UPPER function to convert the priority to uppercase and the TRIM function to remove any leading or trailing spaces. The COUNT result is stored in the v_task_count variable, which is then returned as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_high_priority_tasks(p_project_id NUMBER, p_user_id NUMBER) RETURN NUMBER IS\n   v_task_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_task_count FROM TASKS t JOIN TASK_ASSIGNMENTS ta ON t.TASK_ID = ta.TASK_ID WHERE t.PROJECT_ID = p_project_id AND ta.USER_ID = p_user_id AND UPPER(TRIM(t.TASK_PRIORITY)) = 'HIGH';\n   RETURN v_task_count;\nEND;",
    "database_name": "project_matt_832311",
    "tables": [
      "PROJECTS",
      "TASKS",
      "TASK_ASSIGNMENTS",
      "TASK_DEPENDENCIES",
      "TASK_PROGRESS",
      "USERS"
    ],
    "call_sqls": [
      "SELECT get_high_priority_tasks(0, 0) FROM DUAL",
      "SELECT get_high_priority_tasks(1, 1) FROM DUAL",
      "SELECT get_high_priority_tasks(0, 1) FROM DUAL",
      "SELECT PROJECT_ID, USER_ID, get_high_priority_tasks(PROJECT_ID, USER_ID) AS high_priority_count FROM (SELECT 0 AS PROJECT_ID, 0 AS USER_ID FROM DUAL)",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('High priority tasks: ' || get_high_priority_tasks(1, 0));\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL function named get_high_priority_tasks that accepts a project ID and a user ID, and returns the count of tasks from the TASKS and TASK_ASSIGNMENTS tables where the task is assigned to the given user for the given project and the TASK_PRIORITY is exactly 'HIGH' (case-insensitive and trimmed of spaces).",
    "natural_language": "Write a Oracle PL/SQL function called get_high_priority_tasks that takes a project ID and a user ID (both as numbers) and returns a number representing the count of tasks from the TASKS and TASK_ASSIGNMENTS tables that are assigned to that user for that project and have a task priority exactly equal to 'HIGH' (case-insensitive and trimmed).",
    "id": 76,
    "generated_ir": "Write an Oracle PL/SQL function named get_high_priority_tasks that accepts two parameters: p_project_id of type NUMBER, representing the identifier of a project, and p_user_id of type NUMBER, representing the identifier of a user. The function returns a NUMBER, which is the count of tasks that are considered high priority for the specified project and assigned to the specified user. Within the function, a local variable v_task_count of type NUMBER is declared to store the result of the query. The function executes a SELECT statement that performs a COUNT operation to determine the number of rows in the TASKS table that meet specific criteria. The TASKS table is joined with the TASK_ASSIGNMENTS table using the TASK_ID column, ensuring that only tasks assigned to users are considered. The WHERE clause filters the results to include only those tasks where the PROJECT_ID column in the TASKS table matches the p_project_id parameter, and the USER_ID column in the TASK_ASSIGNMENTS table matches the p_user_id parameter. Additionally, the TASK_PRIORITY column in the TASKS table is checked to ensure it is equal to 'HIGH', using the UPPER function to convert the priority to uppercase and the TRIM function to remove any leading or trailing spaces. The COUNT result is stored in the v_task_count variable, which is then returned as the function's output.",
    "original_summary": "Create a PL/SQL function named get_high_priority_tasks that accepts a project ID and user ID (both NUMBER) and returns the count of high-priority tasks assigned to that user for that project from the TASKS and TASK_ASSIGNMENTS tables.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called get_high_priority_tasks that takes a project ID and a user ID (both as numbers) and gives back a number representing roughly how many of the more urgent tasks from the TASKS and TASK_ASSIGNMENTS tables are linked to that person for that particular project."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_player_assists that accepts two parameters: p_player_id of type NUMBER, which represents the unique identifier of a player, and p_game_id of type NUMBER, which represents the unique identifier of a game. The function retrieves the number of assists made by the specified player in the specified game from the PLAYER_PERFORMANCE table. It performs a SELECT operation to fetch the value from the ASSISTS column where the PLAYER_ID column matches the value of p_player_id and the GAME_ID column matches the value of p_game_id. The retrieved assists value is stored in a local variable v_assists of type NUMBER. The function then returns the value of v_assists, which represents the number of assists made by the player in the game.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_assists(p_player_id NUMBER, p_game_id NUMBER) RETURN NUMBER IS\nv_assists NUMBER;\nBEGIN\nSELECT ASSISTS INTO v_assists FROM PLAYER_PERFORMANCE WHERE PLAYER_ID = p_player_id AND GAME_ID = p_game_id;\nRETURN v_assists;\nEND;",
    "database_name": "sports_tpas_818815",
    "tables": [
      "GAMES",
      "PLAYERS",
      "PLAYER_PERFORMANCE",
      "SEASONS",
      "TEAM_PERFORMANCE"
    ],
    "call_sqls": [
      "SELECT get_player_assists(1, 1) FROM DUAL",
      "SELECT get_player_assists(2, 2) FROM DUAL",
      "SELECT get_player_assists(1, 2) FROM DUAL",
      "SELECT get_player_assists(2, 1) FROM DUAL",
      "SELECT get_player_assists(0, 0) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_player_assists that, given a player ID and a game ID, retrieves the number of assists from the ASSISTS column in the PLAYER_PERFORMANCE table for the matching PLAYER_ID and GAME_ID, and returns that numeric assists value.",
    "natural_language": "Write a Oracle PL/SQL function called get_player_assists that takes a player's ID and a game ID, then retrieves the number from the ASSISTS column in the PLAYER_PERFORMANCE table where the PLAYER_ID and GAME_ID match, and returns that assists number.",
    "id": 77,
    "generated_ir": "Write an Oracle PL/SQL function named get_player_assists that accepts two input parameters: p_player_id and p_game_id, both of type NUMBER, which are used to identify a specific player and a specific game, respectively, and returns a NUMBER representing the assists count; within the function, a local variable v_assists of type NUMBER is declared to temporarily hold the retrieved assists value, then a SELECT statement is executed to query the PLAYER_PERFORMANCE table, specifically retrieving the ASSISTS column for the row where the PLAYER_ID column matches the provided p_player_id input parameter and the GAME_ID column matches the provided p_game_id input parameter, and storing the result into the local variable v_assists, which is then returned as the function's output.",
    "original_summary": "Create a PL/SQL function named get_player_assists that accepts a player ID and a game ID, queries the PLAYER_PERFORMANCE table for the ASSISTS column where PLAYER_ID and GAME_ID match, and returns the numeric assists value.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called get_player_assists? It should take a player's ID and a game ID, then check the PLAYER_PERFORMANCE table to grab the number from the ASSISTS column where both the PLAYER_ID and GAME_ID line up. Just have it spit back that assists number."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_report_validation_status` that accepts a single input parameter, `p_report_id`, which is of data type `NUMBER` and represents the unique identifier for a specific report. This function is designed to return a `VARCHAR2` value, specifically a string of up to 255 characters, representing the validation status of the most recent validation for the report identified by `p_report_id`. Upon execution, the function declares a local variable named `v_validation_status` of type `VARCHAR2(255)` to temporarily store the retrieved validation status. The core operation involves a `SELECT` statement that queries the `DATA_QUALITY` table. This `SELECT` statement retrieves the value from the `VALIDATION_STATUS` column and stores it into the `v_validation_status` variable. The selection of the row from the `DATA_QUALITY` table is governed by two conditions in the `WHERE` clause. The first condition, `REPORT_ID = p_report_id`, filters the rows to include only those associated with the report ID provided as the input parameter `p_report_id`. The second condition, `VALIDATION_DATE = (SELECT MAX(VALIDATION_DATE) FROM DATA_QUALITY WHERE REPORT_ID = p_report_id)`, further refines the selection to ensure that only the row corresponding to the maximum (most recent) `VALIDATION_DATE` for that specific `REPORT_ID` is chosen. This nested `SELECT` statement effectively identifies the latest validation record for the given report. After successfully retrieving the `VALIDATION_STATUS` for the most recent validation, the function then returns the value stored in the `v_validation_status` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_report_validation_status(p_report_id NUMBER) RETURN VARCHAR2 IS\n  v_validation_status VARCHAR2(255);\nBEGIN\n  SELECT VALIDATION_STATUS\n  INTO v_validation_status\n  FROM DATA_QUALITY\n  WHERE REPORT_ID = p_report_id\n  AND VALIDATION_DATE = (SELECT MAX(VALIDATION_DATE) FROM DATA_QUALITY WHERE REPORT_ID = p_report_id);\n  \n  RETURN v_validation_status;\nEND;",
    "database_name": "covid_1dtaa_576932",
    "tables": [
      "DAILY_REPORTS",
      "ACCESS_LOGS",
      "USERS",
      "DATA_CORRECTIONS",
      "DATA_QUALITY"
    ],
    "call_sqls": [
      "SELECT get_report_validation_status(0) FROM DUAL",
      "SELECT get_report_validation_status(1) FROM DUAL",
      "SELECT get_report_validation_status(10) FROM DUAL",
      "SELECT get_report_validation_status(REPORT_ID) FROM DAILY_REPORTS WHERE COUNTRY_CODE = '0'",
      "SELECT d.REPORT_ID, get_report_validation_status(d.REPORT_ID) AS VALIDATION_STATUS FROM DAILY_REPORTS d WHERE d.DATE_STAMP = '2020-03-16'"
    ],
    "summary": "Write a Oracle PL/SQL function named get_report_validation_status that, for a given report ID, retrieves the most recent VALIDATION_STATUS from the DATA_QUALITY table based on the latest VALIDATION_DATE for that REPORT_ID and returns that status.",
    "natural_language": "Write a Oracle PL/SQL function named get_report_validation_status that, for a given report ID, returns the latest VALIDATION_STATUS from the DATA_QUALITY table based on the most recent VALIDATION_DATE.",
    "id": 78,
    "generated_ir": "Write an Oracle PL/SQL function named get_report_validation_status that accepts a single input parameter p_report_id of type NUMBER, which represents the unique identifier of a report. The function returns a VARCHAR2 type value, specifically the latest VALIDATION_STATUS from the DATA_QUALITY table. Within the function, a local variable v_validation_status of type VARCHAR2 is declared to store the result of a query operation. The function performs a SELECT statement on the DATA_QUALITY table, targeting the VALIDATION_STATUS column. It filters the records where the REPORT_ID column matches the input parameter p_report_id. To determine the most recent entry, the query orders the results by the VALIDATION_DATE column in descending order and uses the ROWNUM pseudo-column to limit the result to the first row, effectively retrieving the latest status based on the highest VALIDATION_DATE. The selected VALIDATION_STATUS is stored into the v_validation_status variable using the INTO clause. Finally, the function returns the value stored in v_validation_status, which represents the latest validation status for the given report ID from the DATA_QUALITY table.",
    "original_summary": "Create a PL/SQL function named `get_report_validation_status` that returns the most recent `VALIDATION_STATUS` (VARCHAR2) for a given `p_report_id` (NUMBER) from the `DATA_QUALITY` table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write function get_report_validation_status(p_report_id NUMBER) to return latest VALIDATION_STATUS from DATA_QUALITY."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_policy_coverage_limit that accepts a single parameter p_policy_id of type NUMBER, which represents the unique identifier of a policy. The function is designed to return a NUMBER that represents the coverage limit for the specified policy. Within the function, declare a local variable v_coverage_limit of type NUMBER to temporarily store the coverage limit value retrieved from the database. The function begins by executing a SELECT statement to fetch the POLICY_COVERAGE_LIMIT from the POLICIES table where the POLICY_ID matches the input parameter p_policy_id. The result of this query is stored in the v_coverage_limit variable. Following the data retrieval, the function evaluates a conditional statement: if the value of v_coverage_limit is greater than 200,000, the function returns the value of v_coverage_limit multiplied by 1.1, effectively increasing the coverage limit by 10%. If the condition is not met, the function simply returns the original value of v_coverage_limit without any modification.",
    "plsql": "CREATE OR REPLACE FUNCTION get_policy_coverage_limit(p_policy_id NUMBER) RETURN NUMBER IS\n  v_coverage_limit NUMBER;\nBEGIN\n  SELECT POLICY_COVERAGE_LIMIT INTO v_coverage_limit FROM POLICIES WHERE POLICY_ID = p_policy_id;\n  IF v_coverage_limit > 200000 THEN\n    RETURN v_coverage_limit * 1.1;\n  ELSE\n    RETURN v_coverage_limit;\n  END IF;\nEND;",
    "database_name": "insurance_cap_management",
    "tables": [
      "POLICIES"
    ],
    "call_sqls": [
      "SELECT get_policy_coverage_limit(0) FROM DUAL",
      "SELECT get_policy_coverage_limit(1) FROM DUAL",
      "SELECT get_policy_coverage_limit(100) FROM DUAL",
      "SELECT get_policy_coverage_limit(999) FROM DUAL",
      "SELECT get_policy_coverage_limit(500) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named `get_policy_coverage_limit` that takes a policy ID as input, retrieves the POLICY_COVERAGE_LIMIT for that policy from the POLICIES table, and returns the limit increased by 10% if it is greater than 200,000, otherwise returns the original limit unchanged.",
    "natural_language": "Write a Oracle PL/SQL function named get_policy_coverage_limit that, for a given policy ID, retrieves the coverage limit from the POLICIES table and returns it, but if the limit exceeds 200,000, it returns the limit increased by 10%.",
    "id": 79,
    "generated_ir": "Write an Oracle PL/SQL function named `get_policy_coverage_limit`. This function accepts a single input parameter named `p_policy_id` of type `NUMBER`, which represents the unique identifier of an insurance policy. The function returns a value of type `NUMBER`, which will be the calculated coverage limit.\n\nThe function begins by declaring a local variable named `v_coverage_limit` of data type `NUMBER`. This variable is used to temporarily store the coverage limit value retrieved from the database.\n\nThe core operation of the function is a `SELECT` statement that queries the `POLICIES` table. The `SELECT` statement retrieves the value from the `coverage_limit` column. This retrieved value is then stored into the local variable `v_coverage_limit` using the `INTO` clause. The selection of the specific row from the `POLICIES` table is governed by a condition in the `WHERE` clause: the `policy_id` column in the `POLICIES` table must be equal to the value provided by the `p_policy_id` input parameter.\n\nAfter successfully retrieving the coverage limit, the function proceeds to evaluate its value using an `IF` statement. The condition of the `IF` statement checks if the value stored in `v_coverage_limit` is greater than 200,000. If this condition is true, the function performs a calculation: it multiplies the value in `v_coverage_limit` by 1.10 (which represents a 10% increase). The result of this calculation is then assigned back to the `v_coverage_limit` variable, effectively updating it to the increased amount. If the condition is false (meaning the coverage limit is 200,000 or less), the `v_coverage_limit` variable retains its originally retrieved value without any modification.\n\nFinally, the function concludes its execution by returning the value stored in the `v_coverage_limit` variable as its output.",
    "original_summary": "Create a PL/SQL function named `get_policy_coverage_limit` that takes a policy ID as input, retrieves its coverage limit from the POLICIES table, and returns the limit increased by 10% if it is greater than 200,000, otherwise returns the original limit.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the coverage limit for a given policy ID, and how is it adjusted if it exceeds 200,000?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_feature_value` that accepts a single input parameter, `p_value_id`, of data type `NUMBER`. This function is designed to retrieve a specific feature value from the `FEATURE_VALUES` table based on the provided `p_value_id` and return it as a `NUMBER`. The function begins by declaring a local variable `v_value` of data type `NUMBER` to temporarily store the retrieved value. It then executes a `SELECT` statement to fetch the `VALUE` column from the `FEATURE_VALUES` table. The result of this `SELECT` statement is immediately stored into the local variable `v_value`. The `SELECT` statement includes a `WHERE` clause that filters the rows based on the condition `VALUE_ID = p_value_id`, ensuring that only the row where the `VALUE_ID` column matches the input parameter `p_value_id` is considered. After successfully retrieving the value, the function returns the content of the `v_value` variable. The function includes an exception handling block to manage potential errors during the data retrieval process. If a `NO_DATA_FOUND` exception occurs, which indicates that no row in the `FEATURE_VALUES` table matched the provided `p_value_id`, the function returns `NULL`. If a `TOO_MANY_ROWS` exception occurs, meaning that more than one row in the `FEATURE_VALUES` table matched the `p_value_id` (which would violate the implicit assumption of a unique `VALUE_ID`), the function raises an application-specific error with the error code `-20001` and a descriptive error message: 'Multiple values found for VALUE_ID: ' concatenated with the value of `p_value_id`. For any other unhandled exceptions, the `OTHERS` exception handler catches the error and re-raises the original exception, allowing it to propagate up the call stack.",
    "plsql": "CREATE OR REPLACE FUNCTION get_feature_value(p_value_id NUMBER) RETURN NUMBER IS\n    v_value NUMBER;\nBEGIN\n    SELECT VALUE \n    INTO v_value\n    FROM FEATURE_VALUES \n    WHERE VALUE_ID = p_value_id;\n    \n    RETURN v_value;\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RETURN NULL;\n    WHEN TOO_MANY_ROWS THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Multiple values found for VALUE_ID: ' || p_value_id);\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "genomic_faa_statistics",
    "tables": [
      "FEATURE_VALUES",
      "GENOMIC_FEATURES",
      "DECISION_TREES"
    ],
    "call_sqls": [
      "SELECT get_feature_value(0) FROM DUAL",
      "SELECT get_feature_value(1) FROM DUAL",
      "SELECT get_feature_value(999) FROM DUAL",
      "SELECT get_feature_value( (SELECT VALUE_ID FROM FEATURE_VALUES WHERE ROWNUM = 1 AND VALUE_ID IS NOT NULL) ) FROM DUAL",
      "SELECT get_feature_value( (SELECT MAX(VALUE_ID) FROM FEATURE_VALUES) ) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named `get_feature_value` that retrieves the VALUE from the FEATURE_VALUES table for a specified VALUE_ID, returning the VALUE if exactly one matching row exists, returning NULL if no matching row is found, and raising an application error if multiple rows are found for the given VALUE_ID.",
    "natural_language": "Write a Oracle PL/SQL function named `get_feature_value` that retrieves a single numeric VALUE from the FEATURE_VALUES table for a given VALUE_ID parameter, returning the value if found, returning NULL if no matching record exists, and raising a custom application error if multiple rows are found for the same VALUE_ID.",
    "id": 80,
    "generated_ir": "Write an Oracle PL/SQL function named `get_feature_value` that accepts a single input parameter, `p_value_id`, of data type `NUMBER`. This function is designed to retrieve a specific feature value from the `FEATURE_VALUES` table based on the provided `p_value_id` and return it as a `NUMBER`. The function begins by declaring a local variable `v_value` of data type `NUMBER` to temporarily store the retrieved value. It then executes a `SELECT` statement to fetch the `VALUE` column from the `FEATURE_VALUES` table. The result of this `SELECT` statement is immediately stored into the local variable `v_value`. The `SELECT` statement includes a `WHERE` clause that filters the rows based on the condition `VALUE_ID = p_value_id`, ensuring that only the row where the `VALUE_ID` column matches the input parameter `p_value_id` is considered. After successfully retrieving the value, the function returns the content of the `v_value` variable. The function includes an exception handling block to manage potential errors during the data retrieval process. If a `NO_DATA_FOUND` exception occurs, which indicates that no row in the `FEATURE_VALUES` table matched the provided `p_value_id`, the function returns `NULL`. If a `TOO_MANY_ROWS` exception occurs, meaning that more than one row in the `FEATURE_VALUES` table matched the `p_value_id` (which would violate the implicit assumption of a unique `VALUE_ID`), the function raises an application-specific error with the error code `-20001` and a descriptive error message: 'Multiple values found for VALUE_ID: ' concatenated with the value of `p_value_id`. For any other unhandled exceptions, the `OTHERS` exception handler catches the error and re-raises the original exception, allowing it to propagate up the call stack.",
    "original_summary": "Create a PL/SQL function named `get_feature_value` that returns the VALUE (NUMBER) from the FEATURE_VALUES table for a given VALUE_ID (p_value_id NUMBER). Return NULL if no row is found. Raise an application error (-20001) if multiple rows are found.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function, which should be named `get_feature_value`, that is designed to retrieve and return a single numeric VALUE from the FEATURE_VALUES table, specifically corresponding to a provided VALUE_ID parameter (p_value_id NUMBER). In the detailed scenario where no matching record is located, the function must gracefully return a NULL value. However, if the query unexpectedly finds multiple rows for the given identifier, it must explicitly raise a custom application error with the code -20001 to signal this ambiguous condition."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_agent_avg_sale_price that accepts a single parameter p_agent_id of type NUMBER, which represents the identifier of an agent. The function calculates the average sale price of properties sold by the specified agent. It begins by declaring a local variable v_avg_sale_price of type NUMBER to store the result of the average calculation. The function then executes a SELECT statement to retrieve the average value of the SOLD_PRICE column from the SALES_TRANSACTIONS table, where the AGENT_ID column matches the value of the input parameter p_agent_id. The result of this query is stored in the v_avg_sale_price variable. Following the SELECT operation, the function checks if the v_avg_sale_price variable is NULL, which would indicate that there are no sales transactions for the given agent. If v_avg_sale_price is NULL, it assigns a value of 0 to v_avg_sale_price to ensure the function returns a numeric value. Finally, the function returns the value of v_avg_sale_price, which represents the average sale price for the specified agent, defaulting to 0 if no transactions are found.",
    "plsql": "CREATE OR REPLACE FUNCTION get_agent_avg_sale_price(p_agent_id NUMBER) RETURN NUMBER IS\n    v_avg_sale_price NUMBER;\nBEGIN\n    SELECT AVG(SOLD_PRICE)\n    INTO v_avg_sale_price\n    FROM SALES_TRANSACTIONS\n    WHERE AGENT_ID = p_agent_id;\n\n    IF v_avg_sale_price IS NULL THEN\n        v_avg_sale_price := 0;\n    END IF;\n\n    RETURN v_avg_sale_price;\nEND;",
    "database_name": "real_esama_221588",
    "tables": [
      "PROPERTIES",
      "SALES_TRANSACTIONS",
      "AGENTS",
      "BUYERS"
    ],
    "call_sqls": [
      "SELECT get_agent_avg_sale_price(101) FROM DUAL",
      "SELECT get_agent_avg_sale_price(102) FROM DUAL",
      "SELECT get_agent_avg_sale_price(103) FROM DUAL",
      "SELECT get_agent_avg_sale_price(104) FROM DUAL",
      "SELECT get_agent_avg_sale_price(105) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_agent_avg_sale_price that, given an agent ID, calculates and returns the average SOLD_PRICE for that agent from the SALES_TRANSACTIONS table, returning 0 if no transactions are found for that agent.",
    "natural_language": "Write a Oracle PL/SQL function named get_agent_avg_sale_price that returns the average SOLD_PRICE from the SALES_TRANSACTIONS table for a given agent ID, and returns 0 if there are no sales for that agent.",
    "id": 81,
    "generated_ir": "Write an Oracle PL/SQL function named get_agent_avg_sale_price that accepts a single input parameter, which is the agent ID, and returns a numeric value representing the average sale price. The function's signature includes an input parameter named p_agent_id, which is of type NUMBER or VARCHAR2 depending on the data type of the AGENT_ID column in the SALES_TRANSACTIONS table, and the function returns a value of type NUMBER. The function declares a local variable v_avg_price of type NUMBER to store the computed average. The function executes a SELECT statement that calculates the average value of the SOLD_PRICE column from the SALES_TRANSACTIONS table for all rows where the AGENT_ID column matches the provided input parameter p_agent_id, using the AVG aggregate function, and stores the result into the local variable v_avg_price. The function then uses a conditional IF statement to check if the value of v_avg_price is NOT NULL; if this condition is true, the function returns the value stored in v_avg_price, but if the condition is false, meaning the average calculation resulted in a NULL value due to no sales found for the given agent, the function instead returns the number 0.",
    "original_summary": "Create a PL/SQL function named `get_agent_avg_sale_price` that accepts an agent ID and returns the average SOLD_PRICE for that agent from the SALES_TRANSACTIONS table. Return 0 if no transactions are found.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Function `get_agent_avg_sale_price` returns average SOLD_PRICE for given agent ID from SALES_TRANSACTIONS. Return 0 if none."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_machine_status` that accepts a single input parameter, `p_machine_id`, which is of data type `NUMBER` and represents the unique identifier for a machine. This function is designed to return a `VARCHAR2` value, indicating the operational status of the specified machine. Upon execution, the function first declares a local variable named `v_status` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the machine's status. The core operation involves performing a `SELECT` statement to retrieve the value from the `MACHINE_STATUS` column of the `MACHINES` table. This retrieval is conditional, specifically targeting the row where the `MACHINE_ID` column matches the value provided by the input parameter `p_machine_id`. The retrieved `MACHINE_STATUS` value is then immediately stored into the `v_status` local variable. Following this data retrieval, the function proceeds with a conditional logic check: it evaluates if the value stored in `v_status` is exactly equal to the string literal 'ACTIVE'. If this condition is met (i.e., `v_status` is 'ACTIVE'), the function immediately returns the string literal 'OPERATIONAL'. Conversely, if the condition is not met (i.e., `v_status` is anything other than 'ACTIVE'), the function returns the string literal 'DOWN'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_machine_status(p_machine_id NUMBER) RETURN VARCHAR2 IS\n  v_status VARCHAR2(255);\nBEGIN\n  SELECT MACHINE_STATUS INTO v_status FROM MACHINES WHERE MACHINE_ID = p_machine_id;\n  IF v_status = 'ACTIVE' THEN RETURN 'OPERATIONAL'; ELSE RETURN 'DOWN'; END IF;\nEND;",
    "database_name": "job_sar_management",
    "tables": [
      "JOBS",
      "JOB_EXECUTION",
      "JOB_TYPES",
      "MACHINES"
    ],
    "call_sqls": [
      "SELECT get_machine_status(1) FROM DUAL",
      "SELECT get_machine_status(2) FROM DUAL",
      "SELECT get_machine_status(3) FROM DUAL",
      "SELECT get_machine_status(4) FROM DUAL",
      "SELECT get_machine_status(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_machine_status that accepts a machine ID and returns a status description by retrieving the MACHINE_STATUS from the MACHINES table for that ID; if the status is 'ACTIVE', return 'OPERATIONAL', otherwise return 'DOWN'.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called get_machine_status? It needs to take in a number for the machine ID and spit back some text. Basically, go look in the MACHINES table and grab the MACHINE_STATUS for that specific ID. If the status says 'ACTIVE', then just return 'OPERATIONAL'. For any other status, we'll say the machine is 'DOWN'.",
    "id": 82,
    "generated_ir": "Write an Oracle PL/SQL function named `get_machine_status` that accepts a single input parameter, `p_machine_id`, which is of data type `NUMBER` and represents the unique identifier for a machine. This function is designed to return a `VARCHAR2` value, indicating the operational status of the specified machine. Upon execution, the function first declares a local variable named `v_status` of data type `VARCHAR2` with a maximum length of 255 characters to temporarily store the machine's status. The core operation involves performing a `SELECT` statement to retrieve the value from the `MACHINE_STATUS` column of the `MACHINES` table. This retrieval is conditional, specifically targeting the row where the `MACHINE_ID` column matches the value provided by the input parameter `p_machine_id`. The retrieved `MACHINE_STATUS` value is then immediately stored into the `v_status` local variable. Following this data retrieval, the function proceeds with a conditional logic check: it evaluates if the value stored in `v_status` is exactly equal to the string literal 'ACTIVE'. If this condition is met (i.e., `v_status` is 'ACTIVE'), the function immediately returns the string literal 'OPERATIONAL'. Conversely, if the condition is not met (i.e., `v_status` is anything other than 'ACTIVE'), the function returns the string literal 'DOWN'.",
    "original_summary": "Create a PL/SQL function named get_machine_status that accepts a NUMBER parameter p_machine_id and returns a VARCHAR2. The function should retrieve the MACHINE_STATUS from the MACHINES table for the given ID. If the status is 'ACTIVE', return 'OPERATIONAL'; otherwise, return 'DOWN'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called get_machine_status? It needs to take in a number for the machine ID and spit back some text. Basically, go look in the MACHINES table and grab the MACHINE_STATUS for that specific ID. If the status says 'ACTIVE', then just return 'OPERATIONAL'. For any other status, we'll say the machine is 'DOWN'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_coach_win_percentage that accepts a single parameter p_coach_id of type NUMBER, which represents the unique identifier of a coach. The function calculates and returns the win percentage of the specified coach as a NUMBER. Inside the function, declare three local variables: v_wins, v_losses, and v_percentage, all of type NUMBER. Begin by executing a SELECT statement that counts the number of games won and lost by the coach's team. This is achieved by joining the GAMES table with the COACHES table on the TEAM_ID column, ensuring that the TEAM_ID from the GAMES table matches the TEAM_ID from the COACHES table. The SELECT statement uses two COUNT functions with CASE expressions to count the occurrences of 'win' and 'loss' in the GAME_RESULT column of the GAMES table. The results are stored in the v_wins and v_losses variables, respectively. The WHERE clause filters the results to include only those rows where the COACH_ID column in the COACHES table matches the input parameter p_coach_id. After obtaining the win and loss counts, calculate the win percentage by dividing v_wins by the sum of v_wins and v_losses, using the NULLIF function to prevent division by zero by returning NULL if the sum is zero. Assign the result to the v_percentage variable. Finally, return the value of v_percentage as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_coach_win_percentage(p_coach_id NUMBER) RETURN NUMBER IS\n    v_wins NUMBER;\n    v_losses NUMBER;\n    v_percentage NUMBER;\nBEGIN\n    SELECT COUNT(CASE WHEN GAME_RESULT = 'win' THEN 1 END), COUNT(CASE WHEN GAME_RESULT = 'loss' THEN 1 END) INTO v_wins, v_losses FROM GAMES g JOIN COACHES c ON g.TEAM_ID = c.TEAM_ID WHERE c.COACH_ID = p_coach_id;\n    v_percentage := v_wins / NULLIF(v_wins + v_losses, 0);\n    RETURN v_percentage;\nEND;",
    "database_name": "nba_tsap_trackin",
    "tables": [
      "AWARDS",
      "COACHES",
      "CONTRACTS",
      "GAMES",
      "GAME_STATISTICS",
      "INJURIES",
      "PLAYERS",
      "TEAMS"
    ],
    "call_sqls": [
      "SELECT get_coach_win_percentage(0) FROM DUAL",
      "SELECT get_coach_win_percentage(1) FROM DUAL",
      "SELECT get_coach_win_percentage(2) FROM DUAL",
      "SELECT get_coach_win_percentage(3) FROM DUAL",
      "SELECT get_coach_win_percentage(4) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named `get_coach_win_percentage` that calculates a coach's win percentage based on their team's game results. The function takes a coach ID as input, retrieves the count of wins and losses for that coach's team from the GAMES table by joining with the COACHES table on TEAM_ID, and returns the win percentage calculated as wins divided by the total games (wins plus losses), handling division by zero to avoid errors.",
    "natural_language": "Write a Oracle PL/SQL function called `get_coach_win_percentage` that takes a `p_coach_id` parameter and returns a number representing a coach's win percentage. The function should calculate this by counting wins and losses from the `GAMES` table for the coach's team, using `NULLIF` to prevent division by zero.",
    "id": 83,
    "generated_ir": "Write an Oracle PL/SQL function named get_coach_win_percentage that accepts a single input parameter p_coach_id of type NUMBER and returns a value of type NUMBER. The function's purpose is to calculate the win percentage for a specified coach based on game results stored in the GAMES table. The function declares two local variables: v_wins of type NUMBER to store the count of games won, and v_losses of type NUMBER to store the count of games lost. The core logic involves two separate SELECT operations on the GAMES table. The first SELECT uses the COUNT aggregate function to calculate the total number of games where the coach's team, identified by the TEAM_ID column, is the winning team, indicated by the WINNING_TEAM_ID column. This count is stored in the v_wins variable. The selection is filtered by a WHERE clause that specifies the COACH_ID column must equal the input parameter p_coach_id. The second SELECT operation similarly uses the COUNT aggregate function to calculate the total number of games where the coach's team is the losing team. This is determined by selecting rows where the COACH_ID matches p_coach_id and the TEAM_ID does not equal the WINNING_TEAM_ID, implying the team lost that game. This count is stored in the v_losses variable. After obtaining the win and loss counts, the function calculates the win percentage. This calculation is performed by dividing the number of wins (v_wins) by the total number of games (the sum of v_wins and v_losses). To prevent a division by zero error in cases where a coach has no recorded games (resulting in both v_wins and v_losses being zero), the divisor (v_wins + v_losses) is wrapped in a NULLIF function. If the sum is zero, NULLIF returns NULL, making the entire division expression NULL. The function then returns the result of this percentage calculation. If the calculation yields NULL, the function returns NULL, representing an undefined win percentage for a coach with no games.",
    "original_summary": "Create a PL/SQL function named `get_coach_win_percentage` that accepts a `NUMBER` parameter `p_coach_id` and returns a `NUMBER`. It should calculate a coach's win percentage by counting wins and losses from the `GAMES` table for the coach's team, using `NULLIF` to handle division by zero.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "How can I create a PL/SQL function called `get_coach_win_percentage` that takes a `NUMBER` parameter `p_coach_id` and returns a `NUMBER` to calculate a coach's win percentage by counting wins and losses from the `GAMES` table for their team, while using `NULLIF` to prevent division by zero?"
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_country_health_summary that accepts two mandatory input parameters: a numeric parameter p_country_id representing a country identifier and a numeric parameter p_year representing a specific year, and returns a VARCHAR2 string. The function declares a local VARCHAR2 variable v_summary with a maximum length of 4000 characters. The function executes a single SQL SELECT statement that performs an inner join between the HEALTH_INDICATORS table (aliased as hi) and the HEALTHCARE_EXPENDITURE table (aliased as he) based on the join condition that the COUNTRY_ID column in HEALTH_INDICATORS must equal the COUNTRY_ID column in HEALTHCARE_EXPENDITURE and the YEAR column in HEALTH_INDICATORS must equal the YEAR column in HEALTHCARE_EXPENDITURE. The SELECT statement filters the joined result set with a WHERE clause requiring that the COUNTRY_ID column from the HEALTH_INDICATORS table matches the input parameter p_country_id and the YEAR column from the HEALTH_INDICATORS table matches the input parameter p_year. For the single row retrieved, the SELECT statement constructs a concatenated string using the TO_CHAR function to convert the numeric LIFE_EXPECTANCY column from the HEALTH_INDICATORS table and the numeric TOTAL_EXPENDITURE column from the HEALTHCARE_EXPENDITURE table into character strings, and combines them with the literal strings 'Life Expectancy: ', ', Total Expenditure: '. This constructed string is selected INTO the local variable v_summary. The function then returns the value stored in v_summary.",
    "plsql": "CREATE OR REPLACE FUNCTION get_country_health_summary(p_country_id NUMBER, p_year NUMBER) RETURN VARCHAR2 IS\n    v_summary VARCHAR2(4000);\nBEGIN\n    SELECT 'Life Expectancy: ' || TO_CHAR(hi.LIFE_EXPECTANCY) || ', Total Expenditure: ' || TO_CHAR(he.TOTAL_EXPENDITURE)\n    INTO v_summary\n    FROM HEALTH_INDICATORS hi\n    JOIN HEALTHCARE_EXPENDITURE he ON hi.COUNTRY_ID = he.COUNTRY_ID AND hi.YEAR = he.YEAR\n    WHERE hi.COUNTRY_ID = p_country_id AND hi.YEAR = p_year;\n    RETURN v_summary;\nEND;",
    "database_name": "global_hae_statistics",
    "tables": [
      "COUNTRIES",
      "HEALTH_INDICATORS",
      "DISEASES",
      "HEALTHCARE_EXPENDITURE"
    ],
    "call_sqls": [
      "SELECT get_country_health_summary(1, 2020) FROM DUAL",
      "SELECT get_country_health_summary(2, 2021) FROM DUAL",
      "SELECT get_country_health_summary(3, 2022) FROM DUAL",
      "SELECT get_country_health_summary(4, 2023) FROM DUAL",
      "SELECT get_country_health_summary(5, 2019) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_country_health_summary that accepts a country ID and a year, and returns a summary string. The function should retrieve the life expectancy from the HEALTH_INDICATORS table and the total healthcare expenditure from the HEALTHCARE_EXPENDITURE table for the specified country ID and year, combining them into a single formatted string that displays both values.",
    "natural_language": "Write a Oracle PL/SQL function named get_country_health_summary that takes a country identifier and a year as inputs and returns a summary string. The function should retrieve the life expectancy from the HEALTH_INDICATORS table and the total healthcare expenditure from the HEALTHCARE_EXPENDITURE table for the given country and year, combining them into a single formatted summary string.",
    "id": 84,
    "generated_ir": "Write an Oracle PL/SQL function named get_country_health_summary that accepts two input parameters: p_country_id of type VARCHAR2, representing the unique identifier of a country, and p_year of type NUMBER, representing the specific year for which the health summary is requested. The function is designed to return a value of type VARCHAR2, which will be a formatted summary string containing health-related data for the specified country and year.\n\nWithin the function, three local variables are declared. The first variable, v_life_expectancy, is of type NUMBER, used to store the life expectancy value retrieved from the database. The second variable, v_total_expenditure, is also of type NUMBER, used to store the total healthcare expenditure value. The third variable, v_summary_string, is of type VARCHAR2 with a sufficient maximum length (e.g., 4000 characters), used to construct and hold the final formatted output string.\n\nThe function executes two separate SELECT statements to fetch the required data from two different tables in the global_hae_statistics database. The first SELECT statement queries the HEALTH_INDICATORS table to retrieve the life_expectancy column. It includes a WHERE clause that filters the results to only those rows where the country_id column matches the input parameter p_country_id and the year column matches the input parameter p_year. The retrieved life_expectancy value is stored into the local variable v_life_expectancy.\n\nThe second SELECT statement queries the HEALTHCARE_EXPENDITURE table to retrieve the total_expenditure column. It also includes a WHERE clause that filters the results to only those rows where the country_id column matches the input parameter p_country_id and the year column matches the input parameter p_year. The retrieved total_expenditure value is stored into the local variable v_total_expenditure.\n\nAfter both values are successfully retrieved, the function constructs the summary string. It uses string concatenation and formatting (e.g., using the TO_CHAR function for numeric formatting) to combine the values into a single, readable string. The format of the summary string is: \"For country [p_country_id] in year [p_year]: Life Expectancy = [v_life_expectancy] years, Total Healthcare Expenditure = [v_total_expenditure] units.\" The exact formatting details (like number of decimal places) are implied by standard practices unless otherwise specified.\n\nThe function then returns the value stored in the v_summary_string variable as its output. If either of the SELECT statements finds no matching row for the given country_id and year, a NO_DATA_FOUND exception will be raised. The function must handle this scenario. A common approach is to use exception handling: within a BEGIN...EXCEPTION block, if a NO_DATA_FOUND exception is caught, the function can set the corresponding variable (v_life_expectancy or v_total_expenditure) to NULL and proceed to construct the summary string with NULL values, or it can return a specific message indicating missing data. The description implies data retrieval and combination, so the IR assumes the function proceeds, potentially including NULL in the output string if data is missing for one indicator.",
    "original_summary": "Create a PL/SQL function named get_country_health_summary that accepts a country ID and a year (both NUMBER) and returns a VARCHAR2 string. The function constructs a summary string showing life expectancy and total healthcare expenditure by joining the HEALTH_INDICATORS and HEALTHCARE_EXPENDITURE tables for the specified country and year.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/SQL function designated as `get_country_health_summary`. This function shall accept two parameters of the NUMBER data type: a country identifier and a year. It is required to return a summary string of the VARCHAR2 type. The function's logic must generate this string by presenting the life expectancy and the aggregate healthcare expenditure. This data is to be retrieved by performing a join operation between the HEALTH_INDICATORS and HEALTHCARE_EXPENDITURE tables, specifically for the provided country identifier and year."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_total_salary_cost that accepts a single input parameter p_department_id of type NUMBER, which is used to identify a specific department, and returns a single NUMBER value representing the total calculated salary cost. The function declares a local variable v_total_salary of type NUMBER to hold the computed result. The core logic executes a SELECT statement that queries data from two tables: the PAYROLL table, aliased as 'p', and the EMPLOYEES table, aliased as 'e'. It performs an INNER JOIN between these tables using the condition that the EMPLOYEE_ID column from the PAYROLL table matches the ID column from the EMPLOYEES table. The query filters the result set to include only those rows where the DEPARTMENT_ID column from the EMPLOYEES table is equal to the provided input parameter p_department_id. For the resulting filtered and joined rows, the query uses the SUM aggregation function to calculate the total sum of salary values. Within the SUM function, it applies the TO_NUMBER conversion function to the SALARY column from the PAYROLL table to explicitly convert its values to the NUMBER data type before summation. The result of this SUM operation is then stored into the local variable v_total_salary using the SELECT INTO syntax. Finally, the function returns the value contained in the v_total_salary variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_salary_cost(p_department_id NUMBER) RETURN NUMBER IS\n    v_total_salary NUMBER;\nBEGIN\n    SELECT SUM(TO_NUMBER(p.SALARY)) INTO v_total_salary FROM PAYROLL p JOIN EMPLOYEES e ON p.EMPLOYEE_ID = e.ID WHERE e.DEPARTMENT_ID = p_department_id;\n    RETURN v_total_salary;\nEND;",
    "database_name": "human_rmaes_tracking",
    "tables": [
      "EMPLOYEES",
      "DEPARTMENTS",
      "USERS",
      "BENEFITS",
      "PAYROLL",
      "PERFORMANCE_REVIEWS",
      "TERMINATIONS"
    ],
    "call_sqls": [
      "SELECT calculate_total_salary_cost(1) FROM DUAL",
      "SELECT calculate_total_salary_cost(2) FROM DUAL",
      "SELECT calculate_total_salary_cost(10) FROM DUAL",
      "SELECT calculate_total_salary_cost(20) FROM DUAL",
      "SELECT calculate_total_salary_cost(30) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_total_salary_cost that accepts a department ID and returns the total salary cost for that department by summing the salary values from the PAYROLL table for employees in the EMPLOYEES table where the DEPARTMENT_ID matches the given input.",
    "natural_language": "Write a Oracle PL/SQL function called calculate_total_salary_cost that takes a department ID and returns the total salary cost for that department by summing the SALARY values from the PAYROLL table for all employees in the EMPLOYEES table who belong to the specified DEPARTMENT_ID.",
    "id": 85,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_total_salary_cost that accepts a single input parameter p_department_id of type NUMBER, which is used to identify a specific department, and returns a single NUMBER value representing the total calculated salary cost. The function declares a local variable v_total_salary of type NUMBER to hold the computed result. The core logic executes a SELECT statement that queries data from two tables: the PAYROLL table, aliased as 'p', and the EMPLOYEES table, aliased as 'e'. It performs an INNER JOIN between these tables using the condition that the EMPLOYEE_ID column from the PAYROLL table matches the ID column from the EMPLOYEES table. The query filters the result set to include only those rows where the DEPARTMENT_ID column from the EMPLOYEES table is equal to the provided input parameter p_department_id. For the resulting filtered and joined rows, the query uses the SUM aggregation function to calculate the total sum of salary values. Within the SUM function, it applies the TO_NUMBER conversion function to the SALARY column from the PAYROLL table to explicitly convert its values to the NUMBER data type before summation. The result of this SUM operation is then stored into the local variable v_total_salary using the SELECT INTO syntax. Finally, the function returns the value contained in the v_total_salary variable as its output.",
    "original_summary": "Create a PL/SQL function named calculate_total_salary_cost that accepts a department ID (NUMBER) and returns the total salary cost (NUMBER) for that department. It sums the TO_NUMBER converted salary from the PAYROLL table for employees in the EMPLOYEES table where DEPARTMENT_ID matches the input.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function called calculate_total_salary_cost, which is designed to take a single numeric department ID as its input parameter and subsequently compute and deliver back a numeric value representing the aggregate salary expenditure. This function achieves its purpose by meticulously summing up the salaries, after converting them to a numeric format using TO_NUMBER, for all personnel listed in the EMPLOYEES table who are affiliated with the specified department, by cross-referencing and matching the DEPARTMENT_ID with the provided input within the associated PAYROLL table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_student_waitlist_position` that accepts two input parameters: `p_student_id` of data type `NUMBER`, representing the unique identifier for a student, and `p_course_id` of data type `NUMBER`, representing the unique identifier for a course. This function is designed to return a single value of data type `NUMBER`, which will represent the waitlist position of a specific student for a particular course. Upon execution, the function declares a local variable named `v_position` of data type `NUMBER` to temporarily store the retrieved waitlist position. The core operation of the function involves a `SELECT` statement that queries the `WAITLISTS` table. This `SELECT` statement retrieves the value from the `POSITION` column. The retrieved `POSITION` value is then immediately stored into the local variable `v_position`. The selection of the specific row from the `WAITLISTS` table is determined by a `WHERE` clause that applies two conditions: first, the `STUDENT_ID` column in the `WAITLISTS` table must exactly match the value provided in the `p_student_id` input parameter; and second, the `COURSE_ID` column in the `WAITLISTS` table must exactly match the value provided in the `p_course_id` input parameter. After successfully executing the `SELECT` statement and populating `v_position`, the function concludes by returning the value currently held in the `v_position` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_student_waitlist_position(p_student_id NUMBER, p_course_id NUMBER) RETURN NUMBER IS\n    v_position NUMBER;\nBEGIN\n    SELECT POSITION INTO v_position FROM WAITLISTS WHERE STUDENT_ID = p_student_id AND COURSE_ID = p_course_id;\n    RETURN v_position;\nEND;",
    "database_name": "university_cmars_444320",
    "tables": [
      "COURSES",
      "COURSE_MATERIALS",
      "COURSE_PREREQUISITES",
      "ENROLLMENTS",
      "WAITLISTS",
      "MAJORS"
    ],
    "call_sqls": [
      "SELECT get_student_waitlist_position(101, 500) FROM dual",
      "SELECT get_student_waitlist_position(102, 501) FROM dual",
      "SELECT get_student_waitlist_position(103, 500) FROM dual",
      "SELECT get_student_waitlist_position(104, 502) FROM dual",
      "SELECT get_student_waitlist_position(105, 501) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_student_waitlist_position that, given a student ID and a course ID, retrieves and returns the student's current waitlist position from the WAITLISTS table where the STUDENT_ID and COURSE_ID match the provided inputs.",
    "natural_language": "Write a Oracle PL/SQL function called get_student_waitlist_position that takes a student ID and a course ID as inputs and returns the student's waitlist position from the WAITLISTS table.",
    "id": 86,
    "generated_ir": "Write an Oracle PL/SQL function named `get_student_waitlist_position` that accepts two input parameters: `p_student_id` of data type `NUMBER`, representing the unique identifier for a student, and `p_course_id` of data type `NUMBER`, representing the unique identifier for a course. This function is designed to return a single value of data type `NUMBER`, which will represent the waitlist position of a specific student for a particular course. Upon execution, the function declares a local variable named `v_position` of data type `NUMBER` to temporarily store the retrieved waitlist position. The core operation of the function involves a `SELECT` statement that queries the `WAITLISTS` table. This `SELECT` statement retrieves the value from the `POSITION` column. The retrieved `POSITION` value is then immediately stored into the local variable `v_position`. The selection of the specific row from the `WAITLISTS` table is determined by a `WHERE` clause that applies two conditions: first, the `STUDENT_ID` column in the `WAITLISTS` table must exactly match the value provided in the `p_student_id` input parameter; and second, the `COURSE_ID` column in the `WAITLISTS` table must exactly match the value provided in the `p_course_id` input parameter. After successfully executing the `SELECT` statement and populating `v_position`, the function concludes by returning the value currently held in the `v_position` variable as its output.",
    "original_summary": "Create a PL/SQL function named get_student_waitlist_position that accepts a student ID and a course ID (both NUMBER) and returns the student's waitlist position (NUMBER) for that course from the WAITLISTS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called get_student_waitlist_position that takes a student ID and a course ID as NUMBER inputs and returns the student's waitlist position as a NUMBER from the WAITLISTS table."
  },
  {
    "ir": "Write an Oracle PL/SQL function named calculate_publication_age that accepts a single input parameter p_pub_id of type NUMBER, which represents the publication ID. The function calculates the age of a publication by first declaring a local variable v_age of type NUMBER to store the result. It then performs a SELECT operation to retrieve the year of the publication from the \"PUBLICATIONS\" table, specifically from the column named \"YEAR\", where the \"PUB_ID\" column matches the input parameter p_pub_id. The function calculates the age by subtracting the retrieved year from the current year, obtained using the EXTRACT function with the YEAR field from the CURRENT_DATE. The result of this calculation is stored in the v_age variable. Finally, the function returns the value of v_age, which represents the age of the publication in years.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_publication_age(p_pub_id NUMBER) RETURN NUMBER IS\n    v_age NUMBER;\nBEGIN\n    SELECT EXTRACT(YEAR FROM CURRENT_DATE) - \"YEAR\"\n    INTO v_age\n    FROM \"PUBLICATIONS\"\n    WHERE \"PUB_ID\" = p_pub_id;\n\n    RETURN v_age;\nEND;",
    "database_name": "academic_rpmac_tracking",
    "tables": [
      "AUTHORS",
      "CITATIONS",
      "CITATION_METRICS",
      "PUBLICATIONS"
    ],
    "call_sqls": [
      "SELECT calculate_publication_age(0) FROM DUAL",
      "SELECT calculate_publication_age(1) FROM DUAL",
      "SELECT calculate_publication_age(2) FROM DUAL",
      "SELECT calculate_publication_age(3) FROM DUAL",
      "SELECT calculate_publication_age(4) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_publication_age that accepts a publication ID and returns the age in years of that publication by subtracting its publication year from the current year, using the YEAR column from the PUBLICATIONS table where the PUB_ID matches the input.",
    "natural_language": "Write a Oracle PL/SQL function called `calculate_publication_age` that takes a publication ID, retrieves the publication's year from the PUBLICATIONS table where PUB_ID matches the input, calculates the age in years by subtracting that year from the current year, and returns the calculated age.",
    "id": 87,
    "generated_ir": "Write an Oracle PL/SQL function named calculate_publication_age that accepts a single input parameter p_pub_id of type NUMBER, which represents the publication ID. The function calculates the age of a publication by first declaring a local variable v_age of type NUMBER to store the result. It then performs a SELECT operation to retrieve the year of the publication from the \"PUBLICATIONS\" table, specifically from the column named \"YEAR\", where the \"PUB_ID\" column matches the input parameter p_pub_id. The function calculates the age by subtracting the retrieved year from the current year, obtained using the EXTRACT function with the YEAR field from the CURRENT_DATE. The result of this calculation is stored in the v_age variable. Finally, the function returns the value of v_age, which represents the age of the publication in years.",
    "original_summary": "Create a PL/SQL function named `calculate_publication_age` that accepts a publication ID and returns its age in years by subtracting its publication year from the current year.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function called `calculate_publication_age` that takes a publication ID, calculates the publication's age in years by subtracting its publication year from the current year, and returns the result."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_max_auc that accepts two input parameters: a numeric parameter p_version_id and a numeric parameter p_threshold, and returns a single numeric value. The function declares a local numeric variable v_max_auc. The function's logic executes a single SQL SELECT statement that queries the PERFORMANCE_METRICS table. The SELECT statement uses the MAX aggregate function on the AUC column to find the highest AUC value from all rows in the table that satisfy two conditions specified in the WHERE clause: the VERSION_ID column must exactly equal the input parameter p_version_id, and the THRESHOLDS column must be greater than or equal to the input parameter p_threshold. The result of this MAX(AUC) calculation is retrieved and stored into the local variable v_max_auc using an INTO clause. The function then concludes by returning the value stored in v_max_auc as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_auc(p_version_id NUMBER, p_threshold NUMBER) RETURN NUMBER IS\n  v_max_auc NUMBER;\nBEGIN\n  SELECT MAX(AUC) INTO v_max_auc FROM PERFORMANCE_METRICS WHERE VERSION_ID = p_version_id AND THRESHOLDS >= p_threshold;\n  RETURN v_max_auc;\nEND;",
    "database_name": "machine_lmpm_404685",
    "tables": [
      "MODEL_VERSIONS",
      "PERFORMANCE_METRICS"
    ],
    "call_sqls": [
      "SELECT get_max_auc(100, 0.5) FROM DUAL",
      "SELECT get_max_auc(200, 0.7) FROM DUAL",
      "SELECT get_max_auc(150, 0.3) FROM DUAL",
      "SELECT get_max_auc(300, 0.6) FROM DUAL",
      "SELECT get_max_auc(250, 0.8) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_max_auc that returns the maximum AUC value from the PERFORMANCE_METRICS table for a given VERSION_ID and where THRESHOLDS are at or above a specified threshold.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called get_max_auc that returns a NUMBER? It should take two NUMBER inputs: p_version_id and p_threshold. The function needs to find and return the maximum AUC value from the PERFORMANCE_METRICS table where the VERSION_ID matches the given p_version_id and the THRESHOLDS is greater than or equal to the provided p_threshold.",
    "id": 88,
    "generated_ir": "Write an Oracle PL/SQL function named get_max_auc that accepts two numeric input parameters: p_version_id and p_threshold, both of type NUMBER, and returns a NUMBER data type. Within the function, a local variable v_max_auc of type NUMBER is declared. The function executes a SELECT statement that queries the PERFORMANCE_METRICS table, applying the MAX aggregate function to the AUC column. The query includes a WHERE clause with two conditions: the VERSION_ID column must be equal to the input parameter p_version_id, and the THRESHOLDS column must be greater than or equal to the input parameter p_threshold. The result of this SELECT statement is stored directly into the local variable v_max_auc. Finally, the function returns the value stored in v_max_auc as its output.",
    "original_summary": "Create a PL/SQL function named get_max_auc that returns a NUMBER. It accepts two NUMBER parameters: p_version_id and p_threshold. The function returns the maximum AUC value from the PERFORMANCE_METRICS table where VERSION_ID equals p_version_id and THRESHOLDS is greater than or equal to p_threshold.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called get_max_auc that spits back a NUMBER? It should take in two NUMBER inputs: p_version_id and p_threshold. Basically, it needs to fetch the biggest AUC value from the PERFORMANCE_METRICS table where the VERSION_ID matches the p_version_id we give it and the THRESHOLDS is at least as high as the p_threshold."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_total_inventory` that accepts three input parameters: `p_brand_id` of data type `NUMBER`, representing the unique identifier of a product brand; `p_category` of data type `VARCHAR2`, representing the product category; and `p_active_only` of data type `NUMBER`, which acts as a boolean flag (typically 1 for active, 0 for inactive) to filter products based on their active status. This function is designed to return a single `NUMBER` value, which will be the calculated total inventory quantity.\n\nUpon execution, the function initializes a local variable `v_total_inventory` of data type `NUMBER` to a default value of 0. It then proceeds to execute a `SELECT` statement to retrieve data from the `PRODUCTS` table. The `SELECT` statement calculates the sum of the `STOCK_QUANTITY` column. The `NVL` function is applied to this sum, ensuring that if `SUM(STOCK_QUANTITY)` results in a `NULL` value (which would happen if no rows match the `WHERE` clause criteria), the `NVL` function will substitute 0 instead of `NULL`. The result of this aggregation is then stored into the `v_total_inventory` variable.\n\nThe `SELECT` statement includes a `WHERE` clause to filter the rows from the `PRODUCTS` table. This `WHERE` clause applies three conditions:\n1. `BRAND_ID = p_brand_id`: This condition matches rows where the value in the `BRAND_ID` column is equal to the value passed in the `p_brand_id` input parameter.\n2. `CATEGORY = p_category`: This condition matches rows where the value in the `CATEGORY` column is equal to the value passed in the `p_category` input parameter.\n3. `IS_ACTIVE = p_active_only`: This condition matches rows where the value in the `IS_ACTIVE` column is equal to the value passed in the `p_active_only` input parameter.\n\nAfter the `SELECT` statement completes, the function returns the final value stored in the `v_total_inventory` variable.\n\nThe function also includes an exception handling block.\n1. `WHEN NO_DATA_FOUND THEN RETURN 0;`: This exception handler is specifically designed to catch the `NO_DATA_FOUND` exception. However, in the context of a `SELECT SUM(...) INTO ...` statement, `NO_DATA_FOUND` will not be raised if no rows match the `WHERE` clause; instead, `SUM` will return `NULL`, which is then handled by `NVL(SUM(...), 0)`. Therefore, this specific `NO_DATA_FOUND` handler will practically never be executed in this particular code structure.\n2. `WHEN OTHERS THEN RETURN 0;`: This is a generic exception handler that catches any other unhandled exceptions that might occur during the execution of the `BEGIN...END` block. If any such exception occurs, the function will return a value of 0, indicating that an error prevented the calculation of the total inventory.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_inventory(p_brand_id NUMBER, p_category VARCHAR2, p_active_only NUMBER) RETURN NUMBER IS\n  v_total_inventory NUMBER := 0;\nBEGIN\n  SELECT NVL(SUM(STOCK_QUANTITY), 0)\n  INTO v_total_inventory\n  FROM PRODUCTS\n  WHERE BRAND_ID = p_brand_id \n    AND CATEGORY = p_category \n    AND IS_ACTIVE = p_active_only;\n    \n  RETURN v_total_inventory;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RETURN 0;\n  WHEN OTHERS THEN\n    RETURN 0;\nEND;",
    "database_name": "fashion_scam_tracking",
    "tables": [
      "BRANDS",
      "PRODUCTS",
      "PRODUCT_SIZES",
      "SIZE_CONVERSIONS",
      "USER_PROFILES"
    ],
    "call_sqls": [
      "SELECT calculate_total_inventory(0, 'tops', 1) FROM DUAL",
      "SELECT calculate_total_inventory(0, 'dresses', 1) FROM DUAL",
      "SELECT calculate_total_inventory(1, 'tops', 1) FROM DUAL",
      "SELECT calculate_total_inventory(0, 'tops', 0) FROM DUAL",
      "SELECT calculate_total_inventory(1, 'dresses', 0) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_total_inventory that returns the total stock quantity from the PRODUCTS table for a given BRAND_ID and CATEGORY, optionally filtered by IS_ACTIVE status based on an active-only flag, and returns 0 if no matching products are found or if any error occurs.",
    "natural_language": "Write a Oracle PL/SQL function named calculate_total_inventory that calculates the total stock quantity from the PRODUCTS table for a specified BRAND_ID, CATEGORY, and IS_ACTIVE flag, returning 0 if no data is found or if any errors occur.",
    "id": 89,
    "generated_ir": "Write an Oracle PL/SQL function named `calculate_total_inventory` that accepts three input parameters: `p_brand_id` of data type `NUMBER`, representing the unique identifier of a product brand; `p_category` of data type `VARCHAR2`, representing the product category; and `p_active_only` of data type `NUMBER`, which acts as a boolean flag (typically 1 for active, 0 for inactive) to filter products based on their active status. This function is designed to return a single `NUMBER` value, which will be the calculated total inventory quantity.\n\nUpon execution, the function initializes a local variable `v_total_inventory` of data type `NUMBER` to a default value of 0. It then proceeds to execute a `SELECT` statement to retrieve data from the `PRODUCTS` table. The `SELECT` statement calculates the sum of the `STOCK_QUANTITY` column. The `NVL` function is applied to this sum, ensuring that if `SUM(STOCK_QUANTITY)` results in a `NULL` value (which would happen if no rows match the `WHERE` clause criteria), the `NVL` function will substitute 0 instead of `NULL`. The result of this aggregation is then stored into the `v_total_inventory` variable.\n\nThe `SELECT` statement includes a `WHERE` clause to filter the rows from the `PRODUCTS` table. This `WHERE` clause applies three conditions:\n1. `BRAND_ID = p_brand_id`: This condition matches rows where the value in the `BRAND_ID` column is equal to the value passed in the `p_brand_id` input parameter.\n2. `CATEGORY = p_category`: This condition matches rows where the value in the `CATEGORY` column is equal to the value passed in the `p_category` input parameter.\n3. `IS_ACTIVE = p_active_only`: This condition matches rows where the value in the `IS_ACTIVE` column is equal to the value passed in the `p_active_only` input parameter.\n\nAfter the `SELECT` statement completes, the function returns the final value stored in the `v_total_inventory` variable.\n\nThe function also includes an exception handling block.\n1. `WHEN NO_DATA_FOUND THEN RETURN 0;`: This exception handler is specifically designed to catch the `NO_DATA_FOUND` exception. However, in the context of a `SELECT SUM(...) INTO ...` statement, `NO_DATA_FOUND` will not be raised if no rows match the `WHERE` clause; instead, `SUM` will return `NULL`, which is then handled by `NVL(SUM(...), 0)`. Therefore, this specific `NO_DATA_FOUND` handler will practically never be executed in this particular code structure.\n2. `WHEN OTHERS THEN RETURN 0;`: This is a generic exception handler that catches any other unhandled exceptions that might occur during the execution of the `BEGIN...END` block. If any such exception occurs, the function will return a value of 0, indicating that an error prevented the calculation of the total inventory.",
    "original_summary": "Create a PL/SQL function named calculate_total_inventory that accepts parameters for brand ID, category, and an active-only flag. It returns the total stock quantity (sum of STOCK_QUANTITY) from the PRODUCTS table where brand_id, category, and is_active match the inputs. Use NVL to return 0 if the sum is NULL. Include exception handling to return 0 for any errors.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a function calculate_total_inventory that sums STOCK_QUANTITY from PRODUCTS for given brand ID, category, and active flag. Return 0 for null or errors."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_user_full_name that accepts a single parameter p_user_id of type NUMBER, which represents the unique identifier of a user. The function returns a value of type VARCHAR2. Within the function, declare a local variable v_full_name of type VARCHAR2 with a maximum length of 511 characters. The function performs a SELECT operation on the USERS table, specifically retrieving the FIRST_NAME and LAST_NAME columns for the row where the USER_ID column matches the value of the input parameter p_user_id. The SELECT statement concatenates the FIRST_NAME and LAST_NAME values with a space in between, and applies the TRIM function to remove any leading or trailing spaces from the resulting string. The concatenated and trimmed full name is then stored in the local variable v_full_name. Finally, the function returns the value of v_full_name, which contains the full name of the user corresponding to the provided user ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_full_name(p_user_id NUMBER) RETURN VARCHAR2 IS\n    v_full_name VARCHAR2(511);\nBEGIN\n    SELECT TRIM(FIRST_NAME || ' ' || LAST_NAME) INTO v_full_name FROM USERS WHERE USER_ID = p_user_id;\n    RETURN v_full_name;\nEND;",
    "database_name": "basketball_ppat_statistic",
    "tables": [
      "USERS",
      "USER_ACCESS_LOGS"
    ],
    "call_sqls": [
      "SELECT get_user_full_name(1) FROM DUAL",
      "SELECT get_user_full_name(2) FROM DUAL",
      "SELECT get_user_full_name(3) FROM DUAL",
      "SELECT get_user_full_name(4) FROM DUAL",
      "SELECT get_user_full_name(5) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_user_full_name that accepts a user ID number and returns the trimmed, concatenated first and last name of that user from the USERS table.",
    "natural_language": "Write a Oracle PL/SQL function named get_user_full_name that, given a user's ID, retrieves their first and last names from the USERS table, combines them into a single full name with a space in between, and ensures the result is trimmed of any extra spaces.",
    "id": 90,
    "generated_ir": "Write an Oracle PL/SQL function named get_user_full_name that accepts a single input parameter, p_user_id, which is of data type NUMBER and represents the unique identifier for a user. This function is designed to return a VARCHAR2 string, which will contain the user's full name.\n\nUpon execution, the function first declares two local variables: v_first_name of type VARCHAR2(255) to store the user's first name, and v_last_name of type VARCHAR2(255) to store the user's last name.\n\nThe function then proceeds to retrieve data from the USERS table. It selects the first_name and last_name columns from the USERS table and stores these values into the v_first_name and v_last_name local variables, respectively. This selection is performed for the row where the user_id column matches the value provided in the input parameter p_user_id.\n\nFollowing this data retrieval, the function constructs a VARCHAR2 string by concatenating the value stored in v_first_name, a single space character, and the value stored in v_last_name. It then applies the TRIM function to this concatenated string to remove any leading or trailing spaces, ensuring the result is a clean full name.\n\nFinally, the function returns this trimmed concatenated string as the function's result.",
    "original_summary": "Create a PL/SQL function named get_user_full_name that accepts a user ID number and returns the trimmed, concatenated first and last name of that user from the USERS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/SQL function that, given a user's ID, fetches and combines their first and last names from the USERS table, making sure the result is neat and doesn't have extra spaces."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_model_size that accepts two mandatory input parameters: a numeric parameter named p_version_id and a second numeric parameter named p_model_id, and returns a single numeric value; within the function, it declares a local numeric variable named v_model_size, then executes a SELECT statement that queries the MODEL_VERSIONS table to retrieve the value from the MODEL_SIZE_MB column for the specific row where the VERSION_ID column equals the input parameter p_version_id and the MODEL_ID column equals the input parameter p_model_id, storing the retrieved value directly into the local variable v_model_size, and finally returns the value stored in v_model_size as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_model_size(p_version_id NUMBER, p_model_id NUMBER) RETURN NUMBER IS\n  v_model_size NUMBER;\nBEGIN\n  SELECT MODEL_SIZE_MB INTO v_model_size FROM MODEL_VERSIONS WHERE VERSION_ID = p_version_id AND MODEL_ID = p_model_id;\n  RETURN v_model_size;\nEND;",
    "database_name": "machine_lmpm_404685",
    "tables": [
      "MODEL_VERSIONS",
      "PERFORMANCE_METRICS"
    ],
    "call_sqls": [
      "SELECT get_model_size(1, 101) FROM dual",
      "SELECT get_model_size(2, 102) FROM dual",
      "SELECT get_model_size(3, 103) FROM dual",
      "SELECT get_model_size(4, 104) FROM dual",
      "SELECT get_model_size(5, 105) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_model_size that returns the MODEL_SIZE_MB from the MODEL_VERSIONS table for a specific row identified by matching the input parameters p_version_id to VERSION_ID and p_model_id to MODEL_ID.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called get_model_size that returns a NUMBER? It needs to take in p_version_id and p_model_id. Basically, it's gotta look in the MODEL_VERSIONS table and fetch the MODEL_SIZE_MB for the specific entry that matches those version and model IDs.",
    "id": 91,
    "generated_ir": "Write an Oracle PL/SQL function named get_model_size that returns a NUMBER value. The function accepts two input parameters: p_version_id of type NUMBER, which represents the version identifier, and p_model_id of type NUMBER, which represents the model identifier. The function begins by declaring a local variable v_model_size_mb of type NUMBER to store the retrieved model size value. It then executes a SELECT statement to retrieve the MODEL_SIZE_MB column from the MODEL_VERSIONS table where the VERSION_ID column matches the provided p_version_id and the MODEL_ID column matches the provided p_model_id. This SELECT statement fetches a single row and stores the MODEL_SIZE_MB value into the v_model_size_mb variable. Finally, the function returns the value of v_model_size_mb. The function includes an EXCEPTION handler for the NO_DATA_FOUND exception, which returns a NULL value to handle the scenario where no matching entry is found in the MODEL_VERSIONS table for the given version and model IDs.",
    "original_summary": "Create a PL/SQL function named get_model_size that returns a NUMBER. It accepts parameters p_version_id and p_model_id. It queries the MODEL_VERSIONS table to return the MODEL_SIZE_MB value for the row matching the given VERSION_ID and MODEL_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called get_model_size that spits back a NUMBER? It needs to take in p_version_id and p_model_id. Basically, it's gotta look in the MODEL_VERSIONS table and fetch the MODEL_SIZE_MB for the specific entry that matches those version and model IDs."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_generation_count_for_user that accepts a single input parameter p_user_id of the NUMBER data type and returns a value of the NUMBER data type; the function declares a local variable v_count of the NUMBER data type; the function's logic begins by checking if the input parameter p_user_id is not null; if this condition is true, the function executes a SELECT statement that queries the REPORT_GENERATION_LOGS table, using the COUNT(*) aggregate function to calculate the total number of rows where the USER_ID column value is equal to the provided p_user_id parameter value, and stores the resulting count into the local variable v_count; the function then returns the value stored in the v_count variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_generation_count_for_user(p_user_id NUMBER) RETURN NUMBER IS\n  v_count NUMBER;\nBEGIN\n  IF p_user_id IS NOT NULL THEN\n    SELECT COUNT(*) INTO v_count FROM REPORT_GENERATION_LOGS WHERE USER_ID = p_user_id;\n  END IF;\n  RETURN v_count;\nEND;",
    "database_name": "weather_dcaa_574729",
    "tables": [
      "REPORTS",
      "REPORT_GENERATION_LOGS"
    ],
    "call_sqls": [
      "SELECT get_generation_count_for_user(1) FROM dual",
      "SELECT get_generation_count_for_user(2) FROM dual",
      "SELECT get_generation_count_for_user(3) FROM dual",
      "SELECT get_generation_count_for_user(4) FROM dual",
      "SELECT get_generation_count_for_user(5) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_generation_count_for_user that, given a user_id, returns the total number of entries in the REPORT_GENERATION_LOGS table associated with that specific user_id, but only if the user_id is provided and not null.",
    "natural_language": "Write a Oracle PL/SQL function named get_generation_count_for_user that takes a user_id and returns the total number of rows in the REPORT_GENERATION_LOGS table for that specific user, but only if the user_id is provided.",
    "id": 92,
    "generated_ir": "Write an Oracle PL/SQL function named get_generation_count_for_user that accepts a single input parameter p_user_id, which is of type VARCHAR2 or NUMBER (the exact type should match the data type of the user_id column in the REPORT_GENERATION_LOGS table). The function returns a numeric value of type NUMBER, representing the total count of rows associated with the given user. Within the function, a local variable v_count of type NUMBER is declared to store the computed row count. The function performs a SELECT operation with the COUNT(*) aggregate function on the REPORT_GENERATION_LOGS table. The SELECT statement includes a WHERE clause that filters rows where the user_id column in the REPORT_GENERATION_LOGS table equals the input parameter p_user_id. This ensures the count is specific to the provided user. The retrieved count is stored in the v_count variable. The function then returns the value of v_count as the output. The function does not include any conditional logic beyond the WHERE clause in the SELECT statement, and it assumes the user_id is always provided as per the requirement. No joins are necessary as the operation involves only the REPORT_GENERATION_LOGS table.",
    "original_summary": "Create a PL/SQL function named get_generation_count_for_user that accepts a user_id (NUMBER) and returns a NUMBER. If the user_id is not null, query the REPORT_GENERATION_LOGS table and return the count of rows for that user.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Function get_generation_count_for_user: takes user_id (NUMBER), returns NUMBER. If user_id not null, count rows for that user in REPORT_GENERATION_LOGS."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `calculate_team_streak` that accepts a single input parameter, `p_team_id`, which is of data type `NUMBER` and represents the unique identifier of a specific team. This function is designed to return a single value of data type `NUMBER`, representing a calculated \"streak\" for the given team.\n\nUpon execution, the function declares a local variable `v_streak` of data type `NUMBER` to store an intermediate calculation result. The function then proceeds to execute a `SELECT` statement to determine the value of `v_streak`. This `SELECT` statement counts the number of rows from the `GAMES` table. The counting is subject to two conditions connected by a logical `AND` operator. The first condition requires that the `GAME_WINNER_ID` column in the `GAMES` table (`g.GAME_WINNER_ID`) must be equal to the value provided in the input parameter `p_team_id`. The second condition requires that the `GAME_DATE` column in the `GAMES` table (`g.GAME_DATE`) must be equal to the maximum `GAME_DATE` found in the `GAMES` table where either the `HOME_TEAM_ID` column is equal to `p_team_id` or the `AWAY_TEAM_ID` column is equal to `p_team_id`. This subquery effectively identifies the most recent game date in which the specified team (`p_team_id`) participated, either as the home team or the away team. The result of this `COUNT(*)` operation is then stored into the `v_streak` variable.\n\nFollowing the `SELECT` statement, the function enters a conditional block (`IF v_streak > 0 THEN ... ELSE ... END IF;`). If the value of `v_streak` is greater than 0, indicating that the team won at least one game on its most recent game date, then `v_streak` is updated by applying the `MOD` (modulo) operator. Specifically, `v_streak` is set to the remainder of `v_streak` divided by 10 (`MOD(v_streak, 10)`). If, however, `v_streak` is not greater than 0 (meaning it is 0 or negative, though a count cannot be negative), then `v_streak` is explicitly set to -1.\n\nFinally, the function returns the final value of `v_streak`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_team_streak(p_team_id NUMBER) RETURN NUMBER IS\n    v_streak NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_streak\n    FROM GAMES g\n    WHERE (g.GAME_WINNER_ID = p_team_id)\n    AND g.GAME_DATE = (SELECT MAX(GAME_DATE) FROM GAMES WHERE HOME_TEAM_ID = p_team_id OR AWAY_TEAM_ID = p_team_id);\n\n    IF v_streak > 0 THEN\n        v_streak := MOD(v_streak, 10);\n    ELSE\n        v_streak := -1;\n    END IF;\n\n    RETURN v_streak;\nEND;",
    "database_name": "basketball_ppats_549881",
    "tables": [
      "TEAMS",
      "PLAYERS",
      "GAMES",
      "GAME_STATISTICS",
      "PLAYER_SEASONS",
      "TEAM_SEASONS"
    ],
    "call_sqls": [
      "SELECT calculate_team_streak(0) FROM DUAL",
      "SELECT calculate_team_streak(1) FROM DUAL",
      "SELECT TEAM_ID, TEAM_NAME, calculate_team_streak(TEAM_ID) AS CURRENT_STREAK FROM TEAMS WHERE TEAM_ID = 0",
      "SELECT T.TEAM_ID, T.TEAM_NAME, calculate_team_streak(T.TEAM_ID) AS STREAK FROM TEAMS T WHERE T.CONFERENCE = 'Western'",
      "BEGIN\n  DBMS_OUTPUT.PUT_LINE('Team 0 Streak: ' || calculate_team_streak(0));\n  DBMS_OUTPUT.PUT_LINE('Team 1 Streak: ' || calculate_team_streak(1));\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL function named calculate_team_streak that, given a team ID number, returns a number representing a streak. It determines the streak by counting how many games the team won (where GAME_WINNER_ID equals the input team ID) on its most recent game date (the maximum GAME_DATE from the GAMES table where the team is either the HOME_TEAM_ID or AWAY_TEAM_ID). If the count is greater than zero, return the remainder when that count is divided by 10; otherwise, return -1.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL function called calculate_team_streak? It should take a team's ID number and spit back a number. Basically, it figures out the team's current win streak by checking how many games they won on their very last game date from the GAMES table, using GAME_WINNER_ID, HOME_TEAM_ID, and AWAY_TEAM_ID. If they won any, give back that win count mod 10. If they didn't win any, just return -1.",
    "id": 93,
    "generated_ir": "Write an Oracle PL/SQL function named `calculate_team_streak` that accepts a single input parameter, `p_team_id`, which is of data type `NUMBER` and represents the unique identifier of a specific team. This function is designed to return a single value of data type `NUMBER`, representing a calculated \"streak\" for the given team.\n\nUpon execution, the function declares a local variable `v_streak` of data type `NUMBER` to store an intermediate calculation result. The function then proceeds to execute a `SELECT` statement to determine the value of `v_streak`. This `SELECT` statement counts the number of rows from the `GAMES` table. The counting is subject to two conditions connected by a logical `AND` operator. The first condition requires that the `GAME_WINNER_ID` column in the `GAMES` table (`g.GAME_WINNER_ID`) must be equal to the value provided in the input parameter `p_team_id`. The second condition requires that the `GAME_DATE` column in the `GAMES` table (`g.GAME_DATE`) must be equal to the maximum `GAME_DATE` found in the `GAMES` table where either the `HOME_TEAM_ID` column is equal to `p_team_id` or the `AWAY_TEAM_ID` column is equal to `p_team_id`. This subquery effectively identifies the most recent game date in which the specified team (`p_team_id`) participated, either as the home team or the away team. The result of this `COUNT(*)` operation is then stored into the `v_streak` variable.\n\nFollowing the `SELECT` statement, the function enters a conditional block (`IF v_streak > 0 THEN ... ELSE ... END IF;`). If the value of `v_streak` is greater than 0, indicating that the team won at least one game on its most recent game date, then `v_streak` is updated by applying the `MOD` (modulo) operator. Specifically, `v_streak` is set to the remainder of `v_streak` divided by 10 (`MOD(v_streak, 10)`). If, however, `v_streak` is not greater than 0 (meaning it is 0 or negative, though a count cannot be negative), then `v_streak` is explicitly set to -1.\n\nFinally, the function returns the final value of `v_streak`.",
    "original_summary": "Create a PL/SQL function named calculate_team_streak that accepts a team ID number and returns a number. It calculates a streak by counting how many games the team won on its most recent game date. If the count is greater than 0, return the count modulo 10. Otherwise, return -1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/SQL function called calculate_team_streak? It should take a team's ID number and spit back a number. Basically, it figures out the team's current win streak by checking how many games they won on their very last game date. If they won any, give back that win count mod 10. If they didn't win any, just return -1."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `check_user_exists` that accepts three input parameters: `p_email` of type `VARCHAR2`, representing the email address to be checked; `p_role` of type `VARCHAR2`, representing the user role to be checked; and `p_status` of type `VARCHAR2`, representing the user status to be checked. This function is designed to return a `NUMBER` value. Upon execution, the function declares a local variable `v_count` of type `NUMBER`. The core operation involves performing a `SELECT` statement to count the number of rows in the `USERS` table. The `COUNT(*)` aggregate function is used to determine the total number of rows that satisfy the specified conditions. The conditions for row selection are as follows: the `EMAIL` column in the `USERS` table must exactly match the value provided in the `p_email` input parameter, AND the `ROLE` column in the `USERS` table must exactly match the value provided in the `p_role` input parameter, AND the `STATUS` column in the `USERS` table must exactly match the value provided in the `p_status` input parameter. The result of this `COUNT(*)` operation is then stored into the `v_count` local variable. Finally, the function returns the value currently held by the `v_count` variable, which represents the total number of users found in the `USERS` table that precisely match the provided email, role, and status.",
    "plsql": "CREATE OR REPLACE FUNCTION check_user_exists(p_email VARCHAR2, p_role VARCHAR2, p_status VARCHAR2) RETURN NUMBER IS\n    v_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM USERS WHERE EMAIL = p_email AND ROLE = p_role AND STATUS = p_status;\n    RETURN v_count;\nEND;",
    "database_name": "real_emaap_465379",
    "tables": [
      "USERS"
    ],
    "call_sqls": [
      "SELECT check_user_exists('alice.johnson@example.com', 'data analyst', 'active') FROM DUAL",
      "SELECT check_user_exists('bob.williams@example.com', 'researcher', 'active') FROM DUAL",
      "SELECT check_user_exists('test.user@example.com', 'admin', 'inactive') FROM DUAL",
      "SELECT check_user_exists('alice.johnson@example.com', 'researcher', 'active') FROM DUAL",
      "SELECT check_user_exists('unknown@example.com', 'data analyst', 'active') FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named check_user_exists that returns the number of users in the USERS table where the EMAIL, ROLE, and STATUS columns exactly match the provided input values for email, role, and status.",
    "natural_language": "Write a Oracle PL/SQL function called check_user_exists that takes an email, a role, and a status as inputs, and returns the exact count of matching records from the USERS table where the EMAIL, ROLE, and STATUS columns correspond exactly to the provided values.",
    "id": 94,
    "generated_ir": "Write an Oracle PL/SQL function named check_user_exists that accepts three input parameters: p_email of type VARCHAR2, p_role of type VARCHAR2, and p_status of type VARCHAR2. The function returns a NUMBER value representing the exact count of matching records. It declares a local variable v_user_count of type NUMBER to store the intermediate result. The function executes a SELECT query on the USERS table to count the number of rows where the EMAIL column exactly matches the input parameter p_email, the ROLE column exactly matches the input parameter p_role, and the STATUS column exactly matches the input parameter p_status. This count is stored in the v_user_count variable. The function then returns the value of v_user_count as the output.",
    "original_summary": "Create a PL/SQL function named check_user_exists that accepts p_email, p_role, and p_status (all VARCHAR2). It returns a NUMBER count of rows from the USERS table where EMAIL, ROLE, and STATUS match the input parameters.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a PL/SQL function called check_user_exists that takes three VARCHAR2 parameters: p_email, p_role, and p_status. This function should meticulously query the USERS table, carefully counting and returning the precise number of rows where the EMAIL column exactly matches the provided email, the ROLE column aligns perfectly with the specified role, and the STATUS column corresponds accurately to the given status."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_jobs_by_company_size that accepts a single input parameter p_size_category of type VARCHAR2, which represents a company size classification, and returns a value of type NUMBER. The function declares a local variable v_job_count of type NUMBER to store the result. The function's logic executes a SELECT statement that performs an INNER JOIN between the JOB_MARKET_DATA table, aliased as jmd, and the COMPANY_SIZES table, aliased as cs, using the condition that the COMPANY_SIZE column from the JOB_MARKET_DATA table matches the SIZE_CATEGORY column from the COMPANY_SIZES table. The SELECT statement uses the COUNT(*) aggregate function to calculate the total number of rows. The query includes a WHERE clause that filters the joined result set to only include rows where the SIZE_CATEGORY column from the COMPANY_SIZES table is equal to the value provided in the input parameter p_size_category. The result of the COUNT(*) operation is retrieved into the local variable v_job_count using the INTO clause. Finally, the function returns the value stored in v_job_count, which represents the total count of job records associated with companies of the specified size category.",
    "plsql": "CREATE OR REPLACE FUNCTION get_jobs_by_company_size(p_size_category VARCHAR2) RETURN NUMBER IS\n    v_job_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_job_count\n    FROM JOB_MARKET_DATA jmd\n    JOIN COMPANY_SIZES cs ON jmd.COMPANY_SIZE = cs.SIZE_CATEGORY\n    WHERE cs.SIZE_CATEGORY = p_size_category;\n    RETURN v_job_count;\nEND;",
    "database_name": "job_mdaae_trends",
    "tables": [
      "JOB_MARKET_DATA",
      "COMPANY_LOCATIONS",
      "COMPANY_SIZES",
      "JOB_TITLES",
      "EXPERIENCE_LEVELS",
      "EMPLOYMENT_TYPES",
      "REMOTE_WORK_OPTIONS"
    ],
    "call_sqls": [
      "SELECT get_jobs_by_company_size('S') FROM DUAL",
      "SELECT get_jobs_by_company_size('M') FROM DUAL",
      "SELECT get_jobs_by_company_size('L') FROM DUAL",
      "SELECT get_jobs_by_company_size('Small') FROM DUAL",
      "SELECT get_jobs_by_company_size('Large') FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_jobs_by_company_size that accepts a company size category as input and returns the total number of jobs from the JOB_MARKET_DATA table for companies of that size, where the company size is matched with the SIZE_CATEGORY in the COMPANY_SIZES table.",
    "natural_language": "Write a Oracle PL/SQL function named get_jobs_by_company_size that accepts a size category as input and returns the total number of job listings from the JOB_MARKET_DATA table, joined with the COMPANY_SIZES table where COMPANY_SIZE matches SIZE_CATEGORY, counting only those records where the SIZE_CATEGORY equals the provided input.",
    "id": 95,
    "generated_ir": "Write an Oracle PL/SQL function named get_jobs_by_company_size that accepts a single input parameter named size_category of a string data type, such as VARCHAR2, and returns a numeric value of type NUMBER representing the total count of job listings. The function is designed to query the job_mdaae_trends database, specifically the JOB_MARKET_DATA table and the COMPANY_SIZES table. Within the function, a local variable named total_count of type NUMBER is declared to temporarily store the result of the count operation.\n\nThe function executes a SELECT statement that performs a count of records. It uses the COUNT(*) aggregate function to calculate the total number of rows that meet the specified conditions. The data is retrieved from a join between the JOB_MARKET_DATA table and the COMPANY_SIZES table. The join condition is that the COMPANY_SIZE column from the JOB_MARKET_DATA table must match the SIZE_CATEGORY column from the COMPANY_SIZES table. This establishes a relationship between job listings and their corresponding company size categories.\n\nA WHERE clause is applied to filter the joined results. The condition specifies that the SIZE_CATEGORY column from the COMPANY_SIZES table must be exactly equal to the value provided in the input parameter size_category. This ensures that only job listings associated with the specified company size category are included in the count.\n\nThe result of the COUNT(*) operation is then assigned to the local variable total_count using the INTO clause. After the query execution, the function returns the value stored in total_count, which represents the total number of job listings for the given company size category. The function does not include any loops, conditional blocks beyond the WHERE clause, or additional data transformations; its sole purpose is to perform the join, apply the filter, and return the count.",
    "original_summary": "Create a PL/SQL function named get_jobs_by_company_size that accepts a VARCHAR2 parameter p_size_category. It returns the count of jobs from JOB_MARKET_DATA joined with COMPANY_SIZES on COMPANY_SIZE = SIZE_CATEGORY, filtered where SIZE_CATEGORY matches the parameter.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Develop a comprehensive PL/SQL function, to be named get_jobs_by_company_size, which is designed to accept a single VARCHAR2 input parameter designated as p_size_category. This function should meticulously calculate and return the precise numerical count of job listings. This count is derived from the JOB_MARKET_DATA table, which must be thoughtfully joined with the COMPANY_SIZES table based on the condition that the COMPANY_SIZE column corresponds exactly to the SIZE_CATEGORY column. The entire operation must be carefully filtered so that only those records where the SIZE_CATEGORY perfectly aligns with the provided input parameter are included in the final tally."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_parameter_type that accepts a single input parameter p_parameter_id of type NUMBER. The function is designed to retrieve and return a value of type VARCHAR2, specifically the parameter type associated with the given parameter ID. Inside the function, a local variable v_parameter_type of type VARCHAR2 with a maximum length of 255 characters is declared to temporarily store the result of a database query. The function executes a SELECT statement to fetch the PARAMETER_TYPE column from the PARAMETERS table, where the condition is that the PARAMETER_ID column matches the input parameter p_parameter_id. The result of this query is stored into the local variable v_parameter_type. Finally, the function returns the value stored in v_parameter_type, which represents the type of the parameter identified by the provided parameter ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_parameter_type(p_parameter_id NUMBER) RETURN VARCHAR2 IS\n  v_parameter_type VARCHAR2(255);\nBEGIN\n  SELECT PARAMETER_TYPE INTO v_parameter_type\n  FROM PARAMETERS\n  WHERE PARAMETER_ID = p_parameter_id;\n  RETURN v_parameter_type;\nEND;",
    "database_name": "electronic_csap_tracking",
    "tables": [
      "COMPONENTS",
      "COMPONENT_CONDITIONS",
      "COMPONENT_PARAMETERS",
      "COMPONENT_TYPES",
      "CONDITIONS",
      "PARAMETERS",
      "DATASHEETS"
    ],
    "call_sqls": [
      "SELECT get_parameter_type(0) FROM DUAL",
      "SELECT get_parameter_type(1) FROM DUAL",
      "SELECT get_parameter_type(PARAMETER_ID) FROM PARAMETERS WHERE PARAMETER_NAME = 'Storage Temperature'",
      "SELECT get_parameter_type(PARAMETER_ID) FROM PARAMETERS WHERE PARAMETER_TYPE = 'thermal'",
      "SELECT get_parameter_type(999) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_parameter_type that, given a parameter ID, retrieves and returns the associated PARAMETER_TYPE from the PARAMETERS table.",
    "natural_language": "Write a Oracle PL/SQL function named get_parameter_type that, given a parameter ID, retrieves and returns the corresponding PARAMETER_TYPE from the PARAMETERS table.",
    "id": 96,
    "generated_ir": "Write an Oracle PL/SQL function named get_parameter_type that accepts a single input parameter named p_parameter_id of data type NUMBER, representing the unique identifier of a parameter. This function is designed to return a single value of data type VARCHAR2, specifically the PARAMETER_TYPE associated with the provided parameter ID. The function operates within the electronic_csap_tracking database and interacts with the PARAMETERS table. Upon execution, the function declares a local variable named v_parameter_type of data type VARCHAR2 to temporarily store the retrieved PARAMETER_TYPE value. The core operation of the function involves executing a SELECT statement. This SELECT statement retrieves the value from the PARAMETER_TYPE column. The data is sourced from the table named PARAMETERS. The selection of the specific row from the PARAMETERS table is governed by a single condition: the value in the PARAMETER_ID column of the PARAMETERS table must be equal to the value provided in the input parameter p_parameter_id. The single value retrieved from the PARAMETER_TYPE column based on this condition is then stored into the local variable v_parameter_type. Finally, the function returns the value currently held by the v_parameter_type variable as its output.",
    "original_summary": "Create a PL/SQL function named `get_parameter_type` that accepts a parameter ID (NUMBER) and returns the corresponding PARAMETER_TYPE (VARCHAR2(255)) from the PARAMETERS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/SQL function, designated as `get_parameter_type`, which shall receive a parameter ID of the NUMBER data type as its input. This function is to query the PARAMETERS table and return the associated PARAMETER_TYPE, defined as a VARCHAR2(255)."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_model_version_number that accepts a single input parameter, p_version_id, of type NUMBER, which represents the unique identifier for a version in the MODEL_VERSIONS table. The function is designed to retrieve and return the VERSION_NUMBER, a VARCHAR2 data type with a maximum length of 255 characters, associated with the specified VERSION_ID. Within the function, a SELECT statement is executed to fetch the VERSION_NUMBER from the MODEL_VERSIONS table where the VERSION_ID column matches the value provided in the p_version_id parameter. The retrieved VERSION_NUMBER is stored in a local variable named v_version_number, which is then returned as the function's result. The function does not perform any updates, inserts, or deletes, and it does not include any conditional logic or special operations such as function calls or transformations.",
    "plsql": "CREATE OR REPLACE FUNCTION get_model_version_number(p_version_id NUMBER) RETURN VARCHAR2 IS\n  v_version_number VARCHAR2(255);\nBEGIN\n  SELECT VERSION_NUMBER INTO v_version_number FROM MODEL_VERSIONS WHERE VERSION_ID = p_version_id;\n  RETURN v_version_number;\nEND;",
    "database_name": "machine_lmear_tracking",
    "tables": [
      "USERS",
      "ROLES",
      "USER_ROLES",
      "MODELS",
      "MODEL_VERSIONS",
      "DATASETS",
      "EVALUATIONS"
    ],
    "call_sqls": [
      "SELECT get_model_version_number(0) FROM DUAL",
      "SELECT get_model_version_number(1) FROM DUAL",
      "SELECT get_model_version_number(10) FROM DUAL",
      "SELECT get_model_version_number(p_version_id => 5) FROM DUAL",
      "SELECT VERSION_ID, get_model_version_number(VERSION_ID) FROM MODEL_VERSIONS WHERE MODEL_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL function named get_model_version_number that accepts a version_id and returns the corresponding version_number from the MODEL_VERSIONS table.",
    "natural_language": "Write a Oracle PL/SQL function named get_model_version_number that, for a given version_id, retrieves and returns the corresponding version_number (as a VARCHAR2) from the MODEL_VERSIONS table.",
    "id": 97,
    "generated_ir": "Write an Oracle PL/SQL function named get_model_version_number that accepts one input parameter: p_version_id of type NUMBER to specify a version identifier, and returns a value of type VARCHAR2, which is the version_number corresponding to the given version_id from the MODEL_VERSIONS table. Inside the function, a local variable v_version_number of type VARCHAR2 is declared to store the retrieved version number. The function executes a single SQL SELECT statement to query the MODEL_VERSIONS table, selecting the version_number column from the row where the version_id column exactly matches the provided p_version_id parameter. The result of this SELECT operation is stored into the v_version_number variable using the INTO clause. Finally, the function returns the value stored in v_version_number as the function's result.",
    "original_summary": "Create a function named get_model_version_number that accepts a version_id (NUMBER) and returns the corresponding version_number (VARCHAR2) from the MODEL_VERSIONS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "What is the version_number (VARCHAR2) from the MODEL_VERSIONS table for a given version_id (NUMBER)? Create a function named get_model_version_number to return it."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_user_role_name that accepts a single input parameter p_user_id of the NUMBER data type and returns a value of the VARCHAR2 data type with a maximum length of 255 characters; within the function's execution block, it declares a local variable v_role_name of the VARCHAR2(255) data type, then performs a SELECT query that retrieves a single value from the ROLE_NAME column of the USER_ROLES table by joining the USERS table to the USER_ROLES table using the condition that the ROLE_ID column in the USERS table is equal to the ROLE_ID column in the USER_ROLES table, and further filters the result set with the condition that the USER_ID column in the USERS table must exactly match the value provided in the input parameter p_user_id; the result of this query is assigned into the local variable v_role_name, and the function concludes by returning the value stored in v_role_name.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_role_name(p_user_id IN NUMBER) RETURN VARCHAR2 IS\n    v_role_name VARCHAR2(255);\nBEGIN\n    SELECT ur.ROLE_NAME INTO v_role_name FROM USERS u JOIN USER_ROLES ur ON u.ROLE_ID = ur.ROLE_ID WHERE u.USER_ID = p_user_id;\n    RETURN v_role_name;\nEND;",
    "database_name": "mobile_dsa_analytics",
    "tables": [
      "USERS",
      "USER_ROLES",
      "DEVICE_ACCESS_LOGS"
    ],
    "call_sqls": [
      "SELECT get_user_role_name(0) FROM DUAL",
      "SELECT get_user_role_name(1) FROM DUAL",
      "SELECT get_user_role_name(USER_ID) FROM USERS WHERE USER_NAME = 'Alice Smith'",
      "SELECT get_user_role_name(USER_ID) FROM USERS WHERE EMAIL = 'bob.johnson@example.com'",
      "SELECT get_user_role_name(USER_ID) FROM DEVICE_ACCESS_LOGS WHERE ACCESS_ID = 0"
    ],
    "summary": "Write a Oracle PL/SQL function named get_user_role_name that accepts a user ID and returns the corresponding role name as a string by retrieving the ROLE_NAME from the USER_ROLES table for the user with the given USER_ID from the USERS table, based on matching ROLE_ID.",
    "natural_language": "Write a Oracle PL/SQL function called get_user_role_name that takes a user ID and returns the corresponding role name as text by retrieving it from the USERS and USER_ROLES tables for that specific user.",
    "id": 98,
    "generated_ir": "Write an Oracle PL/SQL function named get_user_role_name that accepts a single input parameter p_user_id of the NUMBER data type and returns a value of the VARCHAR2 data type with a maximum length of 255 characters; within the function's execution block, it declares a local variable v_role_name of the VARCHAR2(255) data type, then performs a SELECT query that retrieves a single value from the ROLE_NAME column of the USER_ROLES table by joining the USERS table to the USER_ROLES table using the condition that the ROLE_ID column in the USERS table is equal to the ROLE_ID column in the USER_ROLES table, and further filters the result set with the condition that the USER_ID column in the USERS table must exactly match the value provided in the input parameter p_user_id; the result of this query is assigned into the local variable v_role_name, and the function concludes by returning the value stored in v_role_name.",
    "original_summary": "Create a function named get_user_role_name that accepts a user ID number and returns the role name as a string by joining the USERS and USER_ROLES tables.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Make a function called get_user_role_name that takes a user ID and gives back the role name as text. It should figure this out by looking at the USERS and USER_ROLES tables in a general way, pulling the role for that particular user."
  },
  {
    "ir": "Write an Oracle PL/SQL function named get_taxon_activity_status that accepts a single input parameter, p_taxon_id, of type NUMBER, which represents the identifier of a taxon. The function returns a value of type VARCHAR2. Within the function, declare a local variable v_recent_access of type NUMBER to store the count of recent accesses. Execute a SELECT statement to count the number of entries in the ACCESS_LOGS table where the TAXON_ID column matches the input parameter p_taxon_id and the ACCESS_DATE column is on or after January 1, 2023. Store the result of this count in the v_recent_access variable. Implement a conditional statement to evaluate whether the value of v_recent_access is greater than 3. If this condition is true, return the string 'Active'. Otherwise, return the string 'Inactive'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_taxon_activity_status(p_taxon_id NUMBER) RETURN VARCHAR2 IS\nv_recent_access NUMBER;\nBEGIN\nSELECT COUNT(*) INTO v_recent_access FROM ACCESS_LOGS WHERE TAXON_ID = p_taxon_id AND ACCESS_DATE >= '2023-01-01';\nIF v_recent_access > 3 THEN\nRETURN 'Active';\nELSE\nRETURN 'Inactive';\nEND IF;\nEND;",
    "database_name": "genomic_dmaa_867750",
    "tables": [
      "ACCESS_LOGS",
      "CITATIONS",
      "PUBLICATIONS",
      "TAXONS",
      "USERS",
      "TAXON_CLASSIFICATIONS"
    ],
    "call_sqls": [
      "SELECT get_taxon_activity_status(0) FROM dual",
      "SELECT get_taxon_activity_status(1) FROM dual",
      "SELECT get_taxon_activity_status(2) FROM dual",
      "SELECT get_taxon_activity_status(3) FROM dual",
      "SELECT get_taxon_activity_status(4) FROM dual"
    ],
    "summary": "Write a Oracle PL/SQL function named get_taxon_activity_status that determines the activity status of a taxon based on its recent access logs. Given a taxon ID as input, the function checks the ACCESS_LOGS table for entries where the TAXON_ID matches the provided ID and the ACCESS_DATE is on or after January 1, 2023. If the count of such recent entries exceeds 3, the function returns 'Active'; otherwise, it returns 'Inactive'.",
    "natural_language": "Write a Oracle PL/SQL function called `get_taxon_activity_status` that takes a taxon ID number and returns a status string. It should check the ACCESS_LOGS table for entries where the TAXON_ID matches the given ID and the ACCESS_DATE is on or after January 1, 2023. If there are more than three such recent entries, return 'Active'; otherwise, return 'Inactive'.",
    "id": 99,
    "generated_ir": "Write an Oracle PL/SQL function named get_taxon_activity_status that accepts a single input parameter, p_taxon_id, of type NUMBER, which represents the unique identifier of a taxon. The function returns a value of type VARCHAR2. Inside the function, declare a local variable v_recent_access_count of type NUMBER to store the count of recent access log entries for the specified taxon. Also, declare a local variable v_status of type VARCHAR2(255) to hold the final status string that will be returned by the function. The function begins by executing a SELECT statement with the COUNT aggregate function on the ACCESS_LOGS table. The query counts the number of rows where the TAXON_ID column matches the input parameter p_taxon_id and the ACCESS_DATE column is greater than or equal to the date '01-JAN-2023'. The result of this count operation is stored in the variable v_recent_access_count. Following the data retrieval, a conditional IF statement is used to evaluate the value of v_recent_access_count. If v_recent_access_count is greater than 3, the function assigns the string 'Active' to the v_status variable. If v_recent_access_count is less than or equal to 3, the function assigns the string 'Inactive' to the v_status variable. Finally, the function returns the value of v_status, which indicates whether the taxon is considered active or inactive based on the count of recent access log entries in the database.",
    "original_summary": "Create a PL/SQL function named `get_taxon_activity_status` that accepts a `p_taxon_id` (NUMBER) and returns a VARCHAR2. It counts recent entries in the `ACCESS_LOGS` table where `TAXON_ID` equals `p_taxon_id` and `ACCESS_DATE` is on or after January 1, 2023. If the count is greater than 3, return 'Active'. Otherwise, return 'Inactive'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Alright, so we need a PL/SQL function called `get_taxon_activity_status`. It's gonna take a number, `p_taxon_id`, and spit back a string. Here's the deal: it checks the ACCESS_LOGS table for that specific taxon ID, but only for logs from January 1st, 2023, or later. If it finds more than three recent entries, it should say 'Active'. If not, just mark it as 'Inactive'."
  },
  {
    "ir": "Write an Oracle PL/SQL function named `get_weather_impact` that accepts a single input parameter, `match_id_in`, of data type `NUMBER`. This function is designed to return a `VARCHAR2` value. Internally, the function declares two local variables: `weather_cond` of type `VARCHAR2(255)` and `surface_type` of type `VARCHAR2(255)`. The function's execution begins by performing a `SELECT` operation on the `MATCHES` table. This `SELECT` statement retrieves the values from the `WEATHER_CONDITIONS` column and the `SURFACE` column. The retrieved value from `WEATHER_CONDITIONS` is assigned to the local variable `weather_cond`, and the retrieved value from `SURFACE` is assigned to the local variable `surface_type`. This data retrieval is conditional, specifically targeting rows where the `MATCH_ID` column in the `MATCHES` table is equal to the value provided by the input parameter `match_id_in`. Following the data retrieval, the function proceeds with a conditional `IF` statement. This `IF` statement evaluates whether the value stored in the `weather_cond` variable is exactly equal to the string literal 'Rain' AND, simultaneously, whether the value stored in the `surface_type` variable is exactly equal to the string literal 'CLAY'. If both of these conditions are true, the function will immediately `RETURN` the string literal 'Playable with delay'. If either or both of these conditions are false, the `ELSE` branch of the `IF` statement is executed, and the function will then `RETURN` the string literal 'Normal conditions'.",
    "plsql": "CREATE OR REPLACE FUNCTION get_weather_impact(match_id_in NUMBER) RETURN VARCHAR2 IS\n  weather_cond VARCHAR2(255);\n  surface_type VARCHAR2(255);\nBEGIN\n  SELECT WEATHER_CONDITIONS, SURFACE INTO weather_cond, surface_type FROM MATCHES WHERE MATCH_ID = match_id_in;\n  IF weather_cond = 'Rain' AND surface_type = 'CLAY' THEN\n    RETURN 'Playable with delay';\n  ELSE\n    RETURN 'Normal conditions';\n  END IF;\nEND;",
    "database_name": "tennis_msa_analytics",
    "tables": [
      "MATCHES"
    ],
    "call_sqls": [
      "SELECT get_weather_impact(0) FROM DUAL",
      "SELECT get_weather_impact(1) FROM DUAL",
      "SELECT get_weather_impact(100) FROM DUAL",
      "SELECT get_weather_impact(50) FROM DUAL",
      "SELECT get_weather_impact(25) FROM DUAL"
    ],
    "summary": "Write a Oracle PL/SQL function named get_weather_impact that, given a match ID as input, retrieves the WEATHER_CONDITIONS and SURFACE from the MATCHES table for that ID and returns a status message: if the weather is 'Rain' and the surface is 'CLAY', it returns 'Playable with delay'; otherwise, it returns 'Normal conditions'.",
    "natural_language": "Write a Oracle PL/SQL function named get_weather_impact that, given a match ID, retrieves the WEATHER_CONDITIONS and SURFACE from the MATCHES table for that ID and returns 'Playable with delay' if the weather is 'Rain' and the surface is 'CLAY', otherwise returns 'Normal conditions'.",
    "id": 100,
    "generated_ir": "Write an Oracle PL/SQL function named get_weather_impact that accepts a single input parameter p_match_id of type NUMBER, representing the identifier of a match in the MATCHES table, and returns a VARCHAR2 value. The function begins by declaring two local variables: v_weather_conditions of type VARCHAR2(255) to store the weather conditions retrieved from the MATCHES table, and v_surface of type VARCHAR2(255) to store the surface type retrieved from the same table. It then executes a SELECT query on the MATCHES table, specifically retrieving the WEATHER_CONDITIONS and SURFACE columns for the row where the match ID column (assumed to be named match_id) equals the input parameter p_match_id, and stores these values into the v_weather_conditions and v_surface variables using the INTO clause. After fetching the data, the function evaluates a conditional statement: if v_weather_conditions is exactly equal to the string 'Rain' and v_surface is exactly equal to the string 'CLAY', it returns the string 'Playable with delay'. Otherwise, for any other combination of weather conditions and surface, it returns the string 'Normal conditions'.",
    "original_summary": "Create a PL/SQL function named get_weather_impact that accepts a match_id_in NUMBER parameter and returns a VARCHAR2. Retrieve the WEATHER_CONDITIONS and SURFACE from the MATCHES table for the given ID. If the weather is 'Rain' and the surface is 'CLAY', return 'Playable with delay'. Otherwise, return 'Normal conditions'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "function",
    "original_natural_language": "Write function get_weather_impact(match_id_in NUMBER) returning VARCHAR2. Fetch WEATHER_CONDITIONS and SURFACE from MATCHES for that ID. Return 'Playable with delay' if weather is 'Rain' and surface is 'CLAY', else 'Normal conditions'."
  }
]