[
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_game_outcome` that accepts a single input parameter. This parameter is named `game_id_input` and is of the `bigint` data type; its purpose is to identify a specific game record. The function is designed to return a value of the `text` data type, representing the outcome of the identified game. Upon execution, the function declares a local variable named `outcome` of the `text` data type to temporarily store the retrieved game outcome. The core operation of the function involves performing a `SELECT` statement. This `SELECT` statement retrieves the value from the `game_outcome` column. The data is sourced from the table named `games`. The retrieval is conditional, specifically targeting rows where the value in the `game_id` column of the `games` table is exactly equal to the value provided by the `game_id_input` parameter. The value retrieved from the `game_outcome` column for the matching row is then assigned to the local variable `outcome`. Finally, the function returns the value currently stored in the `outcome` variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_game_outcome(game_id_input bigint)\nRETURNS text AS $$\nDECLARE\n    outcome text;\nBEGIN\n    SELECT game_outcome INTO outcome\n    FROM games\n    WHERE game_id = game_id_input;\n    RETURN outcome;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "basketball_player_performance_and_team_statistics_758396",
    "tables": [
      "games",
      "player_game_stats",
      "players"
    ],
    "call_sqls": [
      "SELECT get_game_outcome(0);",
      "SELECT get_game_outcome(1);",
      "SELECT get_game_outcome(2);",
      "SELECT get_game_outcome(3);",
      "SELECT get_game_outcome(4);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_game_outcome` that, given a `game_id_input`, retrieves and returns the corresponding `game_outcome` from the `games` table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `get_game_outcome` that, given a `game_id_input`, retrieves and returns the corresponding `game_outcome` from the `games` table where the `game_id` matches the input.",
    "id": 1,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_game_outcome` that accepts a single input parameter. This parameter is named `game_id_input` and is of the `bigint` data type; its purpose is to identify a specific game record. The function is designed to return a value of the `text` data type, representing the outcome of the identified game. Upon execution, the function declares a local variable named `outcome` of the `text` data type to temporarily store the retrieved game outcome. The core operation of the function involves performing a `SELECT` statement. This `SELECT` statement retrieves the value from the `game_outcome` column. The data is sourced from the table named `games`. The retrieval is conditional, specifically targeting rows where the value in the `game_id` column of the `games` table is exactly equal to the value provided by the `game_id_input` parameter. The value retrieved from the `game_outcome` column for the matching row is then assigned to the local variable `outcome`. Finally, the function returns the value currently stored in the `outcome` variable as its result.",
    "original_summary": "Create a PL/pgSQL function named `get_game_outcome` that takes a `bigint` parameter `game_id_input` and returns a `text` value. The function should select the `game_outcome` from the `games` table where `game_id` equals the input parameter and return that value.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "How can I write a PL/pgSQL function called `get_game_outcome` that accepts a `bigint` parameter named `game_id_input` and returns a `text` value by selecting the `game_outcome` from the `games` table where the `game_id` matches the provided input?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_course_materials_by_type that returns a table structure with three columns: material_id of type bigint, material_description of type text, and file_path of type text, and accepts two input parameters: p_course_id of type bigint, which specifies the unique identifier of a course, and p_material_type of type text, which specifies the category or type of the learning material; the function's body executes a single SQL query that selects the material_id, material_description, and file_path columns from the course_materials table, aliased as cm, where the course_id column from the table exactly matches the provided p_course_id parameter and the material_type column from the table exactly matches the provided p_material_type parameter, and then returns the complete result set of this query directly as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_course_materials_by_type(p_course_id bigint, p_material_type text)\nRETURNS TABLE(material_id bigint, material_description text, file_path text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT cm.material_id, cm.material_description, cm.file_path\n    FROM course_materials cm\n    WHERE cm.course_id = p_course_id AND cm.material_type = p_material_type;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_course_management_and_registration_system_444320",
    "tables": [
      "courses",
      "instructors",
      "enrollments",
      "course_prerequisites",
      "course_materials",
      "course_feedback",
      "waitlists"
    ],
    "call_sqls": [
      "SELECT * FROM get_course_materials_by_type(1, 'Textbook');",
      "SELECT * FROM get_course_materials_by_type(1, 'Article');",
      "SELECT * FROM get_course_materials_by_type(0, 'Textbook');",
      "SELECT * FROM get_course_materials_by_type(0, 'Article');",
      "SELECT * FROM get_course_materials_by_type(1, 'Video');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_course_materials_by_type that, given a course_id and a material_type, retrieves and returns the material_id, material_description, and file_path from the course_materials table for all materials that match both the specified course and material type.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_course_materials_by_type that takes a course identifier and a material type description, and returns a list of materials from the course_materials table with their ID, description, and file path, but only for those matching both the specified course and material type.",
    "id": 2,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_course_materials_by_type that accepts two input parameters: p_course_id of type bigint, which specifies the unique identifier of a course, and p_material_type of type text, which specifies the type of material to filter by. The function returns a table with three columns: material_id of type bigint, material_description of type text, and file_path of type text, representing a list of course materials.\n\nThe function begins by executing a SELECT statement that queries the course_materials table. It selects three columns from this table: material_id, material_description, and file_path. The query includes a WHERE clause with two conditions joined by the AND logical operator. The first condition filters rows where the course_id column in the course_materials table equals the input parameter p_course_id. The second condition filters rows where the material_type column in the course_materials table equals the input parameter p_material_type. This ensures only materials belonging to the specified course and matching the specified material type are retrieved.\n\nThe result set of this query is directly returned by the function as a table, providing the list of materials with their ID, description, and file path for the given course and material type.",
    "original_summary": "Create a PL/pgSQL function named get_course_materials_by_type that accepts a course_id (bigint) and a material_type (text) and returns a table of material_id, material_description, and file_path (bigint, text, text) for materials matching both criteria.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function called get_course_materials_by_type that takes a course identifier and a vague description of a material category. It should give back a list with details like the material's ID, a general description of it, and where to find the file, but only for stuff that sort of fits both the course and that type of material."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_publication_age_score that accepts a single input parameter pub_id_input of type bigint, representing the unique identifier of a publication, and returns a real number as a final score. The function begins by declaring local variables: pub_year and current_year as bigint to store year values, age_years as bigint for the calculated age, and citation_score and final_score as real numbers. It first queries the publications table, selecting the year column value into the pub_year variable for the row where the pub_id column matches the input parameter pub_id_input. If the retrieved pub_year is not null, the function proceeds to calculate the current year by calling the CURRENT_DATE function, converting the result to a string in 'YYYY' format using TO_CHAR, and then converting that string to a number using to_number with the '9999' format mask, storing the result in current_year. It then computes age_years by subtracting pub_year from current_year. If age_years is greater than zero, the function queries the citation_metrics table, selecting the citation_impact_score column value into the citation_score variable for the row where the pub_id column equals pub_id_input. If citation_score is not null, a conditional block evaluates age_years: if age_years is greater than 10, final_score is set to citation_score divided by age_years; if age_years is greater than 5 (but 10 or less), final_score is set to citation_score multiplied by 0.8; otherwise (for age_years 5 or less), final_score is set to citation_score multiplied by 1.2. If the citation_score from the citation_metrics table is null, final_score is set to 0. If age_years is not greater than zero (i.e., zero or negative), final_score is set to 0. If the initial query to the publications table returns a null pub_year, final_score is also set to 0. The function concludes by returning the calculated final_score value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_publication_age_score(pub_id_input bigint) RETURNS real AS $$\nDECLARE\n    pub_year bigint;\n    current_year bigint;\n    age_years bigint;\n    citation_score real;\n    final_score real;\nBEGIN\n    SELECT year INTO pub_year FROM publications WHERE pub_id = pub_id_input;\n    IF pub_year IS NOT NULL THEN\n        current_year := to_number(TO_CHAR(CURRENT_DATE, 'YYYY'), '9999');\n        age_years := current_year - pub_year;\n        IF age_years > 0 THEN\n            SELECT citation_impact_score INTO citation_score FROM citation_metrics WHERE pub_id = pub_id_input;\n            IF citation_score IS NOT NULL THEN\n                IF age_years > 10 THEN\n                    final_score := citation_score / age_years;\n                ELSIF age_years > 5 THEN\n                    final_score := citation_score * 0.8;\n                ELSE\n                    final_score := citation_score * 1.2;\n                END IF;\n            ELSE\n                final_score := 0;\n            END IF;\n        ELSE\n            final_score := 0;\n        END IF;\n    ELSE\n        final_score := 0;\n    END IF;\n    RETURN final_score;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "academic_research_publication_management_and_citation_tracking",
    "tables": [
      "authors",
      "citation_metrics",
      "citations",
      "publications"
    ],
    "call_sqls": [
      "SELECT calculate_publication_age_score(0);",
      "SELECT calculate_publication_age_score(1);",
      "SELECT calculate_publication_age_score(100);",
      "SELECT pub_id, calculate_publication_age_score(pub_id) FROM publications WHERE year > 2015 LIMIT 5;",
      "SELECT calculate_publication_age_score(p.pub_id) FROM publications p JOIN citation_metrics c ON p.pub_id = c.pub_id WHERE c.citation_impact_score > 3.0;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `calculate_publication_age_score` that takes a publication ID and returns a real score by calculating the publication's age from its year in the publications table, retrieving the citation impact score from the citation_metrics table, and applying business rules: if the age is greater than 10, divide the citation score by the age; if the age is greater than 5, multiply the citation score by 0.8; otherwise multiply by 1.2, returning 0 if the publication year is missing, the age is not positive, or the citation impact score is not found.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `calculate_publication_age_score` that takes a publication ID and returns a real number score. For the given publication ID, retrieve its publication year from the publications table and the citation impact score from the citation_metrics table. If the publication year is valid and the age calculated from the current year is positive, and if a citation impact score exists, compute the final score based on the age: if the age is over ten years, divide the citation score by the age; if the age is over five years, multiply the citation score by 0.8; otherwise, multiply the citation score by 1.2. If the publication year is missing, the age is not positive, or the citation impact score is unavailable, return zero.",
    "id": 3,
    "generated_ir": "Write a PLpgSQL function named calculate_publication_age_score that accepts a single input parameter pub_id_input of type bigint, representing the unique identifier of a publication, and returns a real number as a final score. The function begins by declaring local variables: pub_year and current_year as bigint to store year values, age_years as bigint for the calculated age, and citation_score and final_score as real numbers. It first queries the publications table, selecting the year column value into the pub_year variable for the row where the pub_id column matches the input parameter pub_id_input. If the retrieved pub_year is not null, the function proceeds to calculate the current year by calling the CURRENT_DATE function, converting the result to a string in 'YYYY' format using TO_CHAR, and then converting that string to a number using to_number with the '9999' format mask, storing the result in current_year. It then computes age_years by subtracting pub_year from current_year. If age_years is greater than zero, the function queries the citation_metrics table, selecting the citation_impact_score column value into the citation_score variable for the row where the pub_id column equals pub_id_input. If citation_score is not null, a conditional block evaluates age_years: if age_years is greater than 10, final_score is set to citation_score divided by age_years; if age_years is greater than 5 (but 10 or less), final_score is set to citation_score multiplied by 0.8; otherwise (for age_years 5 or less), final_score is set to citation_score multiplied by 1.2. If the citation_score from the citation_metrics table is null, final_score is set to 0. If age_years is not greater than zero (i.e., zero or negative), final_score is set to 0. If the initial query to the publications table returns a null pub_year, final_score is also set to 0. The function concludes by returning the calculated final_score value.",
    "original_summary": "Create a PL/pgSQL function named `calculate_publication_age_score` that takes a publication ID and returns a real score. It calculates the publication's age from its year. If age > 0 and a citation impact score exists, it calculates a final score: age >10 divides the citation score by age; age >5 multiplies by 0.8; otherwise multiplies by 1.2. Returns 0 for invalid data.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/pgSQL function designated as `calculate_publication_age_score`. This function should accept a publication ID as its input parameter and yield a real number as a score. The procedure involves determining the publication's age based on its year of publication. Provided the age is greater than zero and a citation impact score is available for the record, a final score shall be computed according to the following logic: if the age exceeds ten years, the citation score is to be divided by the age; if the age is greater than five years, the citation score is to be multiplied by 0.8; otherwise, the citation score is to be multiplied by 1.2. The function must return a value of zero in cases of invalid or missing data."
  },
  {
    "ir": "Write a PLpgSQL function named get_role_permissions that returns a table with two columns, role_id of type bigint and permissions of type text, and accepts a single input parameter p_role_id of type bigint, which is used to filter and retrieve a specific role's data; the function's logic begins by checking if the provided p_role_id is not null, and if this condition is true, it executes a query that selects the role_id column and the permissions column from a table named roles, aliased as r, specifically returning the row where the role_id column in the roles table exactly matches the value of the input parameter p_role_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_role_permissions(p_role_id bigint)\nRETURNS TABLE(role_id bigint, permissions text)\nAS $$\nBEGIN\n    IF p_role_id IS NOT NULL THEN\n        RETURN QUERY\n        SELECT\n            r.role_id,\n            r.permissions\n        FROM roles r\n        WHERE r.role_id = p_role_id;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "public_health_data_management_and_tracking",
    "tables": [
      "users",
      "roles",
      "access_logs",
      "health_data",
      "states"
    ],
    "call_sqls": [
      "SELECT * FROM get_role_permissions(0);",
      "SELECT * FROM get_role_permissions(1);",
      "SELECT * FROM get_role_permissions(2);",
      "SELECT * FROM get_role_permissions(NULL);",
      "SELECT role_id, permissions FROM get_role_permissions(3);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_role_permissions` that, given a specific `p_role_id`, retrieves and returns the matching `role_id` and `permissions` from the `roles` table; if the input `p_role_id` is not provided (null), the function returns no rows.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_role_permissions that returns a table containing a role identifier and its permissions text, taking a role identifier as input; if a specific role identifier is provided, retrieve the corresponding role and its permissions from the roles table, otherwise handle it appropriately.",
    "id": 4,
    "generated_ir": "Write a PLpgSQL function named get_role_permissions that returns a table with two columns, role_id of type bigint and permissions of type text, and accepts a single input parameter p_role_id of type bigint, which is used to filter and retrieve a specific role's data; the function's logic begins by checking if the provided p_role_id is not null, and if this condition is true, it executes a query that selects the role_id column and the permissions column from a table named roles, aliased as r, specifically returning the row where the role_id column in the roles table exactly matches the value of the input parameter p_role_id.",
    "original_summary": "Create a PL/pgSQL function named `get_role_permissions` that returns a table with columns `role_id` (bigint) and `permissions` (text). It accepts a `p_role_id` (bigint) parameter. If the parameter is not null, return the `role_id` and `permissions` from the `roles` table where `role_id` matches the input parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function called `get_role_permissions` that gives back a table with a role identifier and its permissions text. It should take a role identifier as an input. If you provide a specific role identifier, fetch the matching role and its permissions from the roles table. If you don't specify one clearly, just handle it in a sensible way."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_trial_id of type bigint and returns a bigint representing the total number of participants associated with a specific trial. The function executes a SELECT statement that counts all rows in the participants table where the trial_id column matches the provided p_trial_id parameter. The function does not perform any updates, inserts, or deletes, and it does not involve any conditional logic or special operations beyond the COUNT aggregate function. The result of the COUNT operation is returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_participants_by_trial(p_trial_id bigint) RETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM participants WHERE trial_id = p_trial_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "medical_research_and_clinical_trials",
    "tables": [
      "participants",
      "adverse_events",
      "concomitant_medications",
      "visits"
    ],
    "call_sqls": [
      "SELECT get_total_participants_by_trial(0);",
      "SELECT get_total_participants_by_trial(1);",
      "SELECT get_total_participants_by_trial(99);",
      "SELECT get_total_participants_by_trial(NULL);",
      "SELECT get_total_participants_by_trial(2);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_total_participants_by_trial that takes a trial ID as input and returns the total number of participants from the participants table associated with that specific trial ID.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_total_participants_by_trial that, given a trial ID, returns the total count of participants from the PARTICIPANTS table associated with that specific trial.",
    "id": 5,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_total_participants_by_trial that accepts one input parameter p_trial_id of type BIGINT and returns a BIGINT value representing the total count of participants associated with the specified trial ID. The function first declares a local variable total_count of type BIGINT initialized to 0. The function then executes a SELECT statement that counts the number of rows from the participants table where the trial_id column matches the input parameter p_trial_id. The COUNT function is used to aggregate the rows, and the result is assigned to the total_count variable. The function finally returns the value of total_count.",
    "original_summary": "Create a function that takes a trial ID and returns the count of participants associated with that trial.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Make a function that, given a trial ID, gives back a rough number of people involved with that particular trial."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves a substring of the title from the manuscripts table, taking two parameters: p_manuscript_id of type bigint, which specifies the unique identifier of the manuscript, and p_length of type integer, which determines the number of characters to extract from the beginning of the title. The function returns a text value, which is the substring of the title starting from the first character up to the length specified by p_length. It performs a SELECT operation on the manuscripts table, specifically targeting the title column, and applies the SUBSTR function to extract the desired portion of the title. The selection is filtered by the condition that the manuscript_id column must match the provided p_manuscript_id parameter.",
    "plsql": "CREATE OR REPLACE FUNCTION get_manuscript_title_substr(p_manuscript_id bigint, p_length integer)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN (SELECT SUBSTR(title, 1, p_length) FROM manuscripts WHERE manuscript_id = p_manuscript_id);\nEND;\n$$;",
    "database_name": "academic_journal_management_and_publication",
    "tables": [
      "manuscripts",
      "referee_invitations",
      "reviewers"
    ],
    "call_sqls": [
      "SELECT get_manuscript_title_substr(0, 10);",
      "SELECT get_manuscript_title_substr(1, 15);",
      "SELECT get_manuscript_title_substr(0, 5);",
      "SELECT get_manuscript_title_substr(1, 20);",
      "SELECT get_manuscript_title_substr(0, 25);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_manuscript_title_substr that, given a manuscript_id and a length, retrieves the title from the manuscripts table for the specified manuscript and returns the first N characters of the title, where N is the provided length.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_manuscript_title_substr that, given a manuscript identifier and a desired character length, retrieves the title from the manuscripts table for that manuscript and returns a substring containing only the first N characters of the title, where N is the specified length.",
    "id": 6,
    "generated_ir": "Write a PLpgSQL function that retrieves a substring of the title from the manuscripts table, taking two parameters: p_manuscript_id of type bigint, which specifies the unique identifier of the manuscript, and p_length of type integer, which determines the number of characters to extract from the beginning of the title. The function returns a text value, which is the substring of the title starting from the first character up to the length specified by p_length. It performs a SELECT operation on the manuscripts table, specifically targeting the title column, and applies the SUBSTR function to extract the desired portion of the title. The selection is filtered by the condition that the manuscript_id column must match the provided p_manuscript_id parameter.",
    "original_summary": "Create a PL/pgSQL function that returns a substring of a manuscript's title. It takes a manuscript_id (bigint) and a length (integer) as parameters. It selects the title from the manuscripts table and returns the first N characters, where N is the provided length.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Develop a comprehensive PL/pgSQL function that, when provided with a specific manuscript identifier as a bigint and a desired character length as an integer, meticulously retrieves the corresponding title from the manuscripts table and subsequently returns a precisely truncated substring consisting of the initial N characters, where N is definitively determined by the supplied length parameter."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_team_win_shares` that accepts two input parameters: `p_team_id` of type `bigint` representing the unique identifier for a team, and `p_season_year` of type `text` representing the specific year of a season. This function is designed to return a single value of type `real`, which will represent the total sum of \"win shares\" for a given team in a specified season. Upon execution, the function declares a local variable named `v_win_shares` of type `real` to temporarily store the calculated sum. The core operation involves executing a `SELECT` statement to retrieve data from the `player_seasons` table. This `SELECT` statement calculates the `SUM` of the values in the `win_shares` column. The aggregation is performed subject to two conditions specified in the `WHERE` clause: first, the `team_id` column in the `player_seasons` table must exactly match the value provided by the `p_team_id` input parameter; and second, the `season_year` column in the `player_seasons` table must exactly match the value provided by the `p_season_year` input parameter. The result of this `SUM` aggregation is then assigned to the local variable `v_win_shares`. Finally, the function returns the value stored in `v_win_shares` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_win_shares(p_team_id bigint, p_season_year text) RETURNS real AS $$\nDECLARE\n    v_win_shares real;\nBEGIN\n    SELECT SUM(win_shares) INTO v_win_shares\n    FROM player_seasons\n    WHERE team_id = p_team_id AND season_year = p_season_year;\n    RETURN v_win_shares;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "basketball_player_performance_and_team_statistics_549881",
    "tables": [
      "players",
      "player_contracts",
      "player_injuries",
      "player_seasons",
      "teams"
    ],
    "call_sqls": [
      "SELECT get_team_win_shares(1, '2023');",
      "SELECT get_team_win_shares(0, '2023');",
      "SELECT get_team_win_shares(1, '2022');",
      "SELECT get_team_win_shares(0, '2022');",
      "SELECT get_team_win_shares(1, '2021');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_team_win_shares that takes a team_id and a season_year, and returns the total win_shares from the player_seasons table for that specific team and season.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_team_win_shares that, given a team_id and a season_year, calculates and returns the total win shares for that team in that season by summing the win_shares from the player_seasons table where the team_id and season_year match the provided parameters.",
    "id": 7,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_team_win_shares` that accepts two input parameters: `team_id` of data type `bigint` and `season_year` of data type `text`. The function returns a single value of data type `real`. The function's purpose is to compute the aggregate sum of win shares for a specified team during a specified season. The function begins by declaring a local variable named `total_win_shares` of data type `real`. The core operation involves executing a `SELECT` statement with an aggregation function. This `SELECT` statement queries the `player_seasons` table. It uses the `SUM` aggregate function to calculate the total of the `win_shares` column. The `WHERE` clause filters the rows in the `player_seasons` table, ensuring that only rows where the `team_id` column matches the value of the input parameter `team_id` and the `season_year` column matches the value of the input parameter `season_year` are included in the summation. The result of this summation is then stored into the local variable `total_win_shares`. Finally, the function returns the value stored in the `total_win_shares` variable as its output.",
    "original_summary": "Create a function named get_team_win_shares that takes a team_id (bigint) and a season_year (text), returning a real. It sums and returns the win_shares from the player_seasons table for the specified team and season.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the total win shares for a specified team and season, which should be returned by a function called get_team_win_shares that accepts a team_id (bigint) and a season_year (text) as parameters?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_max_pollutant_value that accepts a single input parameter p_county_id of type bigint, which represents the unique identifier for a county, and returns a single real number value; within the function, a local variable v_max_value of type real is declared to hold the result; the function's logic executes a SELECT statement that queries the pollutant_measurements table, specifically applying the MAX aggregate function to the value column to calculate the highest numeric measurement, and the query includes a WHERE clause condition that filters rows to only those where the county_id column exactly matches the provided input parameter p_county_id; the result of this MAX(value) aggregation is then stored into the local variable v_max_value using the INTO clause; finally, the function concludes by returning the contents of the v_max_value variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_pollutant_value(p_county_id bigint)\nRETURNS real AS $$\nDECLARE\n    v_max_value real;\nBEGIN\n    SELECT MAX(value) INTO v_max_value\n    FROM pollutant_measurements\n    WHERE county_id = p_county_id;\n    \n    RETURN v_max_value;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "air_quality_monitoring_and_environmental_impact_assessment",
    "tables": [
      "pollutant_measurements"
    ],
    "call_sqls": [
      "SELECT get_max_pollutant_value(0);",
      "SELECT get_max_pollutant_value(1);",
      "SELECT get_max_pollutant_value(100);",
      "SELECT get_max_pollutant_value(5);",
      "SELECT get_max_pollutant_value(999);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_max_pollutant_value` that, given a county ID, retrieves and returns the highest pollutant measurement value from the pollutant_measurements table for that specific county as a real number.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_max_pollutant_value that returns the highest pollutant measurement value, as a real number, from the pollutant_measurements table for a specified county ID.",
    "id": 8,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_max_pollutant_value that accepts a single input parameter p_county_id of type bigint, which represents the unique identifier for a county, and returns a single real number value; within the function, a local variable v_max_value of type real is declared to hold the result; the function's logic executes a SELECT statement that queries the pollutant_measurements table, specifically applying the MAX aggregate function to the value column to calculate the highest numeric measurement, and the query includes a WHERE clause condition that filters rows to only those where the county_id column exactly matches the provided input parameter p_county_id; the result of this MAX(value) aggregation is then stored into the local variable v_max_value using the INTO clause; finally, the function concludes by returning the contents of the v_max_value variable as its output.",
    "original_summary": "Create a PL/pgSQL function named `get_max_pollutant_value` that takes a county ID and returns the maximum pollutant measurement value for that county as a real number.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the maximum pollutant measurement value, returned as a real number, for a given county ID?"
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the minimum value of a pollutant measurement from the pollutant_measurements table for a specified pollutant. The function is named find_min_pollutant_value and accepts a single parameter, p_pollutant_id, which is of type bigint and represents the unique identifier of the pollutant whose minimum measurement value is to be found. Within the function, a local variable v_min_value of type real is declared to store the result of the query operation. The function performs a SELECT operation to determine the minimum value from the value column in the pollutant_measurements table, where the pollutant_id column matches the provided p_pollutant_id parameter. The result of this query is stored into the v_min_value variable using the INTO clause. Finally, the function returns the v_min_value, which represents the smallest measurement value recorded for the specified pollutant.",
    "plsql": "CREATE OR REPLACE FUNCTION find_min_pollutant_value(p_pollutant_id bigint)\nRETURNS real AS $$\nDECLARE\n    v_min_value real;\nBEGIN\n    SELECT MIN(value) INTO v_min_value\n    FROM pollutant_measurements\n    WHERE pollutant_id = p_pollutant_id;\n    \n    RETURN v_min_value;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "air_quality_monitoring_and_environmental_impact_assessment",
    "tables": [
      "pollutant_measurements"
    ],
    "call_sqls": [
      "SELECT find_min_pollutant_value(0);",
      "SELECT find_min_pollutant_value(1);",
      "SELECT find_min_pollutant_value(2);",
      "SELECT find_min_pollutant_value(100);",
      "SELECT find_min_pollutant_value(999999);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `find_min_pollutant_value` that, given a pollutant ID, retrieves and returns the smallest value recorded in the `pollutant_measurements` table for that specific `pollutant_id`.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `find_min_pollutant_value` that, given a pollutant ID, retrieves the minimum value recorded for that pollutant from the `pollutant_measurements` table and returns it as a real number.",
    "id": 9,
    "generated_ir": "Write a PLpgSQL function that retrieves the minimum value of a pollutant measurement from the pollutant_measurements table for a specified pollutant. The function is named find_min_pollutant_value and accepts a single parameter, p_pollutant_id, which is of type bigint and represents the unique identifier of the pollutant whose minimum measurement value is to be found. Within the function, a local variable v_min_value of type real is declared to store the result of the query operation. The function performs a SELECT operation to determine the minimum value from the value column in the pollutant_measurements table, where the pollutant_id column matches the provided p_pollutant_id parameter. The result of this query is stored into the v_min_value variable using the INTO clause. Finally, the function returns the v_min_value, which represents the smallest measurement value recorded for the specified pollutant.",
    "original_summary": "Create a PL/pgSQL function named `find_min_pollutant_value` that takes a `bigint` pollutant ID and returns a `real` value. The function should find and return the minimum `value` from the `pollutant_measurements` table for the specified `pollutant_id`.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called `find_min_pollutant_value` that needs a pollutant ID (a bigint) and gives back a real number. It should look through the `pollutant_measurements` table and return the smallest reading it can find for that particular pollutant."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_average_life_expectancy` that accepts a single input parameter, `p_region`, which is of type `text`. This function is designed to return a single value of type `real`, representing the calculated average life expectancy. The function begins by declaring a local variable named `avg_life_expectancy`, also of type `real`, to store the result of the aggregation. The core operation involves a `SELECT` statement that calculates the average of the `life_expectancy` column. This calculation is performed on data retrieved from two tables: `countries` and `health_indicators`. These two tables are joined using an `INNER JOIN` operation, where the join condition specifies that the `country_id` column from the `countries` table must be equal to the `country_id` column from the `health_indicators` table. A `WHERE` clause is applied to filter the joined results, ensuring that only rows where the `region` column in the `countries` table matches the value provided by the input parameter `p_region` are considered for the average calculation. The computed average value is then stored into the `avg_life_expectancy` local variable. Finally, the function returns the value stored in the `avg_life_expectancy` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_life_expectancy(p_region text)\nRETURNS real AS $$\nDECLARE\n    avg_life_expectancy real;\nBEGIN\n    SELECT AVG(hi.life_expectancy) INTO avg_life_expectancy\n    FROM countries c\n    JOIN health_indicators hi ON c.country_id = hi.country_id\n    WHERE c.region = p_region;\n    RETURN avg_life_expectancy;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "global_health_and_economic_statistics",
    "tables": [
      "countries",
      "diseases",
      "economic_indicators",
      "education",
      "health_indicators",
      "healthcare_expenditure",
      "access_logs"
    ],
    "call_sqls": [
      "SELECT calculate_average_life_expectancy('Asia');",
      "SELECT calculate_average_life_expectancy('Europe');",
      "SELECT calculate_average_life_expectancy('South Asia');",
      "SELECT calculate_average_life_expectancy('Southern Europe');",
      "SELECT calculate_average_life_expectancy('Africa');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_average_life_expectancy that takes a region name and returns the average life expectancy from the health_indicators table for all countries in that region by joining with the countries table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named calculate_average_life_expectancy that returns the average life expectancy for all countries in a specified region, based on data from the health_indicators and countries tables.",
    "id": 10,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `calculate_average_life_expectancy` that accepts a single input parameter, `p_region`, which is of type `text`. This function is designed to return a single value of type `real`, representing the calculated average life expectancy. The function begins by declaring a local variable named `avg_life_expectancy`, also of type `real`, to store the result of the aggregation. The core operation involves a `SELECT` statement that calculates the average of the `life_expectancy` column. This calculation is performed on data retrieved from two tables: `countries` and `health_indicators`. These two tables are joined using an `INNER JOIN` operation, where the join condition specifies that the `country_id` column from the `countries` table must be equal to the `country_id` column from the `health_indicators` table. A `WHERE` clause is applied to filter the joined results, ensuring that only rows where the `region` column in the `countries` table matches the value provided by the input parameter `p_region` are considered for the average calculation. The computed average value is then stored into the `avg_life_expectancy` local variable. Finally, the function returns the value stored in the `avg_life_expectancy` variable as its output.",
    "original_summary": "Create a PL/pgSQL function named calculate_average_life_expectancy that returns a real value. It takes a region name. Calculate and return the average life expectancy from the health_indicators table for all countries in the specified region by joining with the countries table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the average life expectancy for all countries in a specified region, calculated by joining the health_indicators and countries tables?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_sector_average_weight that takes no input parameters and returns a single real number value, which is computed by executing a SELECT query on the sectors table to calculate the arithmetic mean of all values contained in the sector_weight column, using the SQL aggregate function AVG on that column, and then returning that computed average value directly as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_sector_average_weight()\nRETURNS real AS $$\nBEGIN\n    RETURN (SELECT AVG(sector_weight) FROM sectors);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "economic_data_analysis_and_reporting_564662",
    "tables": [
      "economic_indicators",
      "indicator_sectors",
      "sectors"
    ],
    "call_sqls": [
      "SELECT get_sector_average_weight();",
      "SELECT * FROM get_sector_average_weight();",
      "SELECT get_sector_average_weight() AS avg_sector_weight;",
      "SELECT sector_name, sector_weight, (SELECT get_sector_average_weight()) AS overall_avg FROM sectors;",
      "SELECT get_sector_average_weight() FROM sectors LIMIT 1;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_sector_average_weight that calculates and returns the average sector_weight from the sectors table as a real number.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_sector_average_weight that calculates and returns the average value of the sector_weight column from the sectors table as a real number.",
    "id": 11,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_sector_average_weight that takes no input parameters and returns a single real number value, which is computed by executing a SELECT query on the sectors table to calculate the arithmetic mean of all values contained in the sector_weight column, using the SQL aggregate function AVG on that column, and then returning that computed average value directly as the function's result.",
    "original_summary": "Create a function named get_sector_average_weight that returns the average value of the sector_weight column from the sectors table as a real number.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the average value of the sector_weight column in the sectors table, and how can I create a function named get_sector_average_weight to return it as a real number?"
  },
  {
    "ir": "Write a PLpgSQL function named get_version_count that accepts a single input parameter p_model_id of type bigint, which represents the identifier of a model, and returns a value of type bigint. The function declares a local variable v_count of type bigint to store the result. The function's logic executes a SELECT statement that queries the versions table, using the COUNT(*) aggregate function to calculate the total number of rows where the model_id column value is exactly equal to the provided input parameter p_model_id. The result of this count operation is stored into the local variable v_count using the INTO clause. The function then concludes by returning the value stored in v_count, which is the total count of version records associated with the specified model identifier.",
    "plsql": "CREATE OR REPLACE FUNCTION get_version_count(p_model_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    v_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_count FROM versions WHERE model_id = p_model_id;\n    RETURN v_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "machine_learning_model_performance_metrics_773034",
    "tables": [
      "models",
      "performances",
      "versions"
    ],
    "call_sqls": [
      "SELECT get_version_count(0);",
      "SELECT get_version_count(1);",
      "SELECT get_version_count(2);",
      "SELECT get_version_count(100);",
      "SELECT get_version_count(NULL);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_version_count` that, given a model ID, returns the total number of records in the `versions` table where the `model_id` matches the provided ID.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named `get_version_count` that, for a given model ID, returns the total number of entries in the `versions` table associated with that specific model ID.",
    "id": 12,
    "generated_ir": "Write a PLpgSQL function named get_version_count that accepts a single input parameter p_model_id of type bigint, which represents the identifier of a model, and returns a value of type bigint. The function declares a local variable v_count of type bigint to store the result. The function's logic executes a SELECT statement that queries the versions table, using the COUNT(*) aggregate function to calculate the total number of rows where the model_id column value is exactly equal to the provided input parameter p_model_id. The result of this count operation is stored into the local variable v_count using the INTO clause. The function then concludes by returning the value stored in v_count, which is the total count of version records associated with the specified model identifier.",
    "original_summary": "Create a function named `get_version_count` that takes a `bigint` model ID and returns a `bigint`. It counts and returns the number of records in the `versions` table for the given model ID.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Make a function called `get_version_count` that, for a given model ID (a big integer), gives back a big integer. It should figure out roughly how many entries are in the `versions` table that seem to be associated with that particular model."
  },
  {
    "ir": "Write a PLpgSQL function that returns a table consisting of columns sale_id, vehicle_id, and sale_price. The function is named get_dealership_sales and accepts a single parameter p_dealership_id of type bigint, which represents the unique identifier of a dealership. The function executes a SQL query that selects the sale_id, vehicle_id, and sale_price columns from the sales table, aliased as s. It performs an inner join operation between the sales table and the vehicles table, aliased as v, using the vehicle_id column from both tables as the joining condition. The query filters the results to include only those rows where the dealership_id column in the vehicles table matches the value of the input parameter p_dealership_id. The function is defined using the PLpgSQL language and utilizes the RETURN QUERY statement to return the result set directly from the executed query.",
    "plsql": "CREATE OR REPLACE FUNCTION get_dealership_sales(p_dealership_id bigint)\nRETURNS TABLE(sale_id bigint, vehicle_id bigint, sale_price real) AS $$\nBEGIN\n    RETURN QUERY SELECT s.sale_id, s.vehicle_id, s.sale_price FROM sales s JOIN vehicles v ON s.vehicle_id = v.vehicle_id WHERE v.dealership_id = p_dealership_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "automotive_dealerships_management_and_operations",
    "tables": [
      "customers",
      "dealerships",
      "employees",
      "sales",
      "vehicles",
      "vehicle_inventories",
      "feedback"
    ],
    "call_sqls": [
      "SELECT * FROM get_dealership_sales(1);",
      "SELECT * FROM get_dealership_sales(5);",
      "SELECT * FROM get_dealership_sales(10);",
      "SELECT sale_id, vehicle_id FROM get_dealership_sales(15);",
      "SELECT * FROM get_dealership_sales(20) WHERE sale_price > 25000;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_dealership_sales that, given a dealership ID as input, retrieves all sales records from the SALES table for vehicles associated with that specific dealership by joining the SALES and VEHICLES tables on vehicle_id, and returns a table with sale_id, vehicle_id, and sale_price.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_dealership_sales that, for a given dealership ID, returns the sale ID, vehicle ID, and sale price by combining data from the sales and vehicles tables where the vehicles.dealership_id matches the provided dealership ID.",
    "id": 13,
    "generated_ir": "Write a PLpgSQL function that returns a table consisting of columns sale_id, vehicle_id, and sale_price. The function is named get_dealership_sales and accepts a single parameter p_dealership_id of type bigint, which represents the unique identifier of a dealership. The function executes a SQL query that selects the sale_id, vehicle_id, and sale_price columns from the sales table, aliased as s. It performs an inner join operation between the sales table and the vehicles table, aliased as v, using the vehicle_id column from both tables as the joining condition. The query filters the results to include only those rows where the dealership_id column in the vehicles table matches the value of the input parameter p_dealership_id. The function is defined using the PLpgSQL language and utilizes the RETURN QUERY statement to return the result set directly from the executed query.",
    "original_summary": "Create a PL/pgSQL function named get_dealership_sales that returns a table with columns sale_id, vehicle_id, and sale_price. It joins the sales and vehicles tables on vehicle_id and filters where the vehicles.dealership_id equals the input bigint parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "List the sale ID, vehicle ID, and sale price by joining the sales and vehicles tables where the vehicles.dealership_id matches the provided bigint parameter."
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the age-to-weight ratio for a participant by taking a single parameter, p_participant_id, which is of type bigint and represents the unique identifier of a participant. The function performs a SELECT operation on the participants table, specifically retrieving the age and wt columns for the row where the participant_id matches the provided p_participant_id. It then computes the ratio by casting the age value to a real type and dividing it by the wt value, ensuring the result is a real number. The function returns this computed ratio as a real type.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_participant_age_weight_ratio(p_participant_id bigint) RETURNS real AS $$\nBEGIN\n    RETURN (SELECT CAST(age AS real) / wt FROM participants WHERE participant_id = p_participant_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "medical_research_and_clinical_trials",
    "tables": [
      "participants",
      "adverse_events",
      "concomitant_medications",
      "visits"
    ],
    "call_sqls": [
      "SELECT calculate_participant_age_weight_ratio(0);",
      "SELECT calculate_participant_age_weight_ratio(1);",
      "SELECT calculate_participant_age_weight_ratio( (SELECT participant_id FROM participants ORDER BY RANDOM() LIMIT 1) );",
      "SELECT calculate_participant_age_weight_ratio( (SELECT participant_id FROM participants WHERE age > 60 LIMIT 1) );",
      "SELECT calculate_participant_age_weight_ratio( (SELECT participant_id FROM participants WHERE wt < 100 LIMIT 1) );"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_participant_age_weight_ratio that takes a participant ID and returns a real number representing the participant's age divided by their weight, calculated from the participants table where the participant_id matches the input.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named calculate_participant_age_weight_ratio that, for a given participant ID, returns the participant's age divided by their weight as a real number from the participants table.",
    "id": 14,
    "generated_ir": "Write a PLpgSQL function that calculates and returns the age-to-weight ratio for a participant by taking a single parameter, p_participant_id, which is of type bigint and represents the unique identifier of a participant. The function performs a SELECT operation on the participants table, specifically retrieving the age and wt columns for the row where the participant_id matches the provided p_participant_id. It then computes the ratio by casting the age value to a real type and dividing it by the wt value, ensuring the result is a real number. The function returns this computed ratio as a real type.",
    "original_summary": "Create a function that takes a participant ID and returns the participant's age divided by weight as a real number.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Calculate the participant's age divided by their weight as a real number for a given participant ID."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter, input_league_id of type bigint, and returns a bigint value representing the count of games that went into overtime within a specified league. The function performs a SELECT operation to count the number of records in the game_outcomes table, aliased as go, which are joined with the games table, aliased as g, on the condition that the game_id column in game_outcomes matches the game_id column in games. The WHERE clause filters the results to include only those rows where the league_id column in the games table matches the input_league_id parameter and the overtime column in the game_outcomes table has a value greater than 0, indicating that the game went into overtime. The function uses the COUNT(*) aggregate function to determine the total number of such games and returns this count as the result.",
    "plsql": "CREATE OR REPLACE FUNCTION count_overtime_games_in_league(input_league_id bigint) RETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM game_outcomes go JOIN games g ON go.game_id = g.game_id WHERE g.league_id = input_league_id AND go.overtime > 0);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "sports_data_analysis_and_statistics",
    "tables": [
      "games",
      "game_outcomes",
      "teams",
      "leagues"
    ],
    "call_sqls": [
      "SELECT count_overtime_games_in_league(1);",
      "SELECT count_overtime_games_in_league(2);",
      "SELECT count_overtime_games_in_league(3);",
      "SELECT count_overtime_games_in_league(4);",
      "SELECT count_overtime_games_in_league(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named count_overtime_games_in_league that takes a league ID as input and returns the total number of games from the games table for that specific league that went into overtime, based on the overtime column in the game_outcomes table being greater than zero.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named count_overtime_games_in_league that counts how many games in a specified league, identified by input_league_id, went into overtime based on the overtime column in the game_outcomes table being greater than zero.",
    "id": 15,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named count_overtime_games_in_league that accepts a single input parameter input_league_id of type bigint and returns a bigint value. The function declares a local variable overtime_count of type bigint. It then executes a SELECT query with a COUNT aggregation on the game_outcomes table, joining it with the games table using the game_id column as the join condition. The join is an inner join, ensuring only games present in both tables are considered. The WHERE clause filters the results to include only rows where the games.league_id column matches the input parameter input_league_id and the game_outcomes.overtime column is greater than zero. This COUNT operation calculates the total number of games in the specified league that went into overtime. The result of this count is stored in the overtime_count variable. Finally, the function returns the value stored in overtime_count. The function does not include any conditional control flow, updates, inserts, or deletes; it solely performs the select, count, and return operations.",
    "original_summary": "Create a PL/pgSQL function that takes a league ID and returns the count of overtime games for that league by joining the game_outcomes and games tables, filtering where the overtime column is greater than 0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Count overtime games for a league."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_instrument_growth` that accepts four input parameters: `p_instrument_id` of type `bigint`, `p_start_year` of type `bigint`, `p_end_year` of type `bigint`, and `p_quarter_name` of type `text`. This function is designed to calculate and return the growth rate of a financial instrument between a specified start year and end year for a particular quarter.\n\nThe function begins by declaring three local variables: `v_start_value` of type `numeric`, `v_end_value` of type `numeric`, and `v_growth` of type `numeric`.\n\nThe first operation is a `SELECT` statement that retrieves the financial value for the instrument at the `p_start_year` and `p_quarter_name`. Specifically, it selects the `value` column from the `financial_values` table, aliased as `fv`. This `value` is then explicitly cast to a `numeric` data type and stored into the `v_start_value` variable. This selection is performed by joining the `financial_values` table (`fv`) with the `quarters` table (`q`) on the condition that `fv.quarter` equals `q.quarter_id`. The filtering conditions for this `SELECT` statement are: `fv.instrument_id` must be equal to the input parameter `p_instrument_id`, `fv.year` must be equal to the input parameter `p_start_year`, and `q.quarter_name` must be equal to the input parameter `p_quarter_name`.\n\nThe second operation is another `SELECT` statement, similar to the first, but it retrieves the financial value for the instrument at the `p_end_year` and `p_quarter_name`. It selects the `value` column from the `financial_values` table, aliased as `fv`, casts it to `numeric`, and stores it into the `v_end_value` variable. This selection also involves joining the `financial_values` table (`fv`) with the `quarters` table (`q`) on the condition that `fv.quarter` equals `q.quarter_id`. The filtering conditions for this `SELECT` statement are: `fv.instrument_id` must be equal to the input parameter `p_instrument_id`, `fv.year` must be equal to the input parameter `p_end_year`, and `q.quarter_name` must be equal to the input parameter `p_quarter_name`.\n\nFollowing these data retrievals, the function proceeds with a conditional block (`IF` statement). This block checks three conditions:\n1. If `v_start_value` is not `NULL`.\n2. If `v_end_value` is not `NULL`.\n3. If `v_start_value` is not equal to `0`.\n\nIf all three of these conditions are met (i.e., both start and end values are present and the start value is not zero to prevent division by zero), the function calculates the growth rate. The calculation is performed by subtracting `v_start_value` from `v_end_value`, and then dividing the result by `v_start_value`. This calculated growth rate is assigned to the `v_growth` variable. After the calculation, the function immediately returns the `v_growth` value.\n\nIf any of the conditions in the `IF` statement are not met (i.e., either `v_start_value` or `v_end_value` is `NULL`, or `v_start_value` is `0`), the function executes the `ELSE` block and returns `NULL`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_instrument_growth(p_instrument_id bigint, p_start_year bigint, p_end_year bigint, p_quarter_name text)\nRETURNS numeric\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_start_value numeric;\n    v_end_value numeric;\n    v_growth numeric;\nBEGIN\n    SELECT CAST(value AS numeric) INTO v_start_value\n    FROM financial_values fv\n    JOIN quarters q ON fv.quarter = q.quarter_id\n    WHERE fv.instrument_id = p_instrument_id\n      AND fv.year = p_start_year\n      AND q.quarter_name = p_quarter_name;\n\n    SELECT CAST(value AS numeric) INTO v_end_value\n    FROM financial_values fv\n    JOIN quarters q ON fv.quarter = q.quarter_id\n    WHERE fv.instrument_id = p_instrument_id\n      AND fv.year = p_end_year\n      AND q.quarter_name = p_quarter_name;\n\n    IF v_start_value IS NOT NULL AND v_end_value IS NOT NULL AND v_start_value != 0 THEN\n        v_growth := (v_end_value - v_start_value) / v_start_value;\n        RETURN v_growth;\n    ELSE\n        RETURN NULL;\n    END IF;\nEND;\n$$;",
    "database_name": "banking_and_financial_management_95020",
    "tables": [
      "financial_reports",
      "financial_instruments",
      "financial_values",
      "report_details",
      "categories",
      "quarters",
      "users"
    ],
    "call_sqls": [
      "SELECT calculate_instrument_growth(0, 1, 0, 'Dec');",
      "SELECT calculate_instrument_growth(0, 0, 1, 'Sep');",
      "SELECT calculate_instrument_growth(1, 2007, 2008, 'Dec');",
      "SELECT calculate_instrument_growth(0, 2007, 2007, 'Dec');",
      "SELECT calculate_instrument_growth(1, 2006, 2007, 'Sep');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `calculate_instrument_growth` that calculates the growth rate for a specified financial instrument from the `financial_values` table between a given start year and end year for a specific quarter, using the `quarters` table to match the quarter by `quarter_name`. It retrieves the instrument's `value` for the start year and quarter and for the end year and quarter, and if both values exist and the start value is not zero, it returns the growth rate as (end value - start value) / start value; otherwise, it returns NULL.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called `calculate_instrument_growth`? It needs to figure out the growth rate for a specific financial instrument between two years for a given quarter. So, it grabs the instrument's value from the financial_values table for the starting year and quarter, and then again for the ending year and quarter, joining with the quarters table to match the quarter_name. If both numbers are there and the starting value isn't zero, it should spit out the growth rate. Otherwise, just give back NULL.",
    "id": 16,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `calculate_instrument_growth` that accepts four input parameters: `p_instrument_id` of type `bigint`, `p_start_year` of type `bigint`, `p_end_year` of type `bigint`, and `p_quarter_name` of type `text`. This function is designed to calculate and return the growth rate of a financial instrument between a specified start year and end year for a particular quarter.\n\nThe function begins by declaring three local variables: `v_start_value` of type `numeric`, `v_end_value` of type `numeric`, and `v_growth` of type `numeric`.\n\nThe first operation is a `SELECT` statement that retrieves the financial value for the instrument at the `p_start_year` and `p_quarter_name`. Specifically, it selects the `value` column from the `financial_values` table, aliased as `fv`. This `value` is then explicitly cast to a `numeric` data type and stored into the `v_start_value` variable. This selection is performed by joining the `financial_values` table (`fv`) with the `quarters` table (`q`) on the condition that `fv.quarter` equals `q.quarter_id`. The filtering conditions for this `SELECT` statement are: `fv.instrument_id` must be equal to the input parameter `p_instrument_id`, `fv.year` must be equal to the input parameter `p_start_year`, and `q.quarter_name` must be equal to the input parameter `p_quarter_name`.\n\nThe second operation is another `SELECT` statement, similar to the first, but it retrieves the financial value for the instrument at the `p_end_year` and `p_quarter_name`. It selects the `value` column from the `financial_values` table, aliased as `fv`, casts it to `numeric`, and stores it into the `v_end_value` variable. This selection also involves joining the `financial_values` table (`fv`) with the `quarters` table (`q`) on the condition that `fv.quarter` equals `q.quarter_id`. The filtering conditions for this `SELECT` statement are: `fv.instrument_id` must be equal to the input parameter `p_instrument_id`, `fv.year` must be equal to the input parameter `p_end_year`, and `q.quarter_name` must be equal to the input parameter `p_quarter_name`.\n\nFollowing these data retrievals, the function proceeds with a conditional block (`IF` statement). This block checks three conditions:\n1. If `v_start_value` is not `NULL`.\n2. If `v_end_value` is not `NULL`.\n3. If `v_start_value` is not equal to `0`.\n\nIf all three of these conditions are met (i.e., both start and end values are present and the start value is not zero to prevent division by zero), the function calculates the growth rate. The calculation is performed by subtracting `v_start_value` from `v_end_value`, and then dividing the result by `v_start_value`. This calculated growth rate is assigned to the `v_growth` variable. After the calculation, the function immediately returns the `v_growth` value.\n\nIf any of the conditions in the `IF` statement are not met (i.e., either `v_start_value` or `v_end_value` is `NULL`, or `v_start_value` is `0`), the function executes the `ELSE` block and returns `NULL`.",
    "original_summary": "Create a PL/pgSQL function named `calculate_instrument_growth` that calculates and returns the growth rate for a specified financial instrument between a start year and an end year for a given quarter. It retrieves the instrument's value for the start year and quarter, and for the end year and quarter. If both values exist and the start value is not zero, it returns the calculated growth rate; otherwise, it returns NULL.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/pgSQL function called `calculate_instrument_growth`? It needs to figure out the growth rate for a specific financial instrument between two years for a given quarter. So, it grabs the instrument's value for the starting year and quarter, and then again for the ending year and quarter. If both numbers are there and the starting value isn't zero, it should spit out the growth rate. Otherwise, just give back NULL."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_order_summary that accepts two input parameters: a BIGINT parameter named input_order_id which identifies a specific order, and a NUMERIC parameter named tax_rate which represents a decimal tax rate to be applied. The function returns a table with two columns: total_items of type BIGINT and final_amount of type NUMERIC. The function begins by declaring two local variables: items_count of type BIGINT and subtotal of type NUMERIC. It then executes a SELECT query on the order_items table, using the input_order_id parameter in a WHERE clause to filter rows where the order_id column matches the provided value. This query calculates two aggregate values: the COUNT of all matching rows is stored into the items_count variable, and the COALESCE of the SUM of the product of the price_each column (cast to NUMERIC) and the quantity column is stored into the subtotal variable, with a default value of 0 if the SUM result is NULL. After the query, the function assigns the value of the items_count variable to the output column total_items, and calculates the final_amount output column by multiplying the subtotal variable by the expression (1 + tax_rate). Finally, the function uses RETURN NEXT to return the computed row containing the total_items and final_amount values.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_order_summary(\n    input_order_id BIGINT,\n    tax_rate NUMERIC\n)\nRETURNS TABLE(\n    total_items BIGINT,\n    final_amount NUMERIC\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    items_count BIGINT;\n    subtotal NUMERIC;\nBEGIN\n    SELECT COUNT(*), COALESCE(SUM(CAST(price_each AS NUMERIC) * quantity), 0)\n    INTO items_count, subtotal\n    FROM order_items\n    WHERE order_id = input_order_id;\n    \n    total_items := items_count;\n    final_amount := subtotal * (1 + tax_rate);\n    \n    RETURN NEXT;\nEND;\n$$;",
    "database_name": "e_commerce_order_management_and_analytics",
    "tables": [
      "orders",
      "order_items",
      "products",
      "payments",
      "shipping"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_order_summary(0, 0.05);",
      "SELECT * FROM calculate_order_summary(1, 0.08);",
      "SELECT * FROM calculate_order_summary(100, 0.07);",
      "SELECT * FROM calculate_order_summary(2, 0.06);",
      "SELECT * FROM calculate_order_summary(3, 0.09);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_order_summary that, for a given order identified by input_order_id, retrieves all items from the order_items table, counts the total number of items as total_items, sums their total value based on price_each and quantity, and then applies the provided tax_rate to calculate the final_amount, returning both values.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_order_summary that, given an input_order_id and a tax_rate, returns a table with total_items and final_amount by counting the items and summing their total value from the order_items table for that order, then applying the tax rate to compute the final amount.",
    "id": 17,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named calculate_order_summary that accepts two input parameters: a BIGINT parameter named input_order_id which identifies a specific order, and a NUMERIC parameter named tax_rate which represents a decimal tax rate to be applied. The function returns a table with two columns: total_items of type BIGINT and final_amount of type NUMERIC. The function begins by declaring two local variables: items_count of type BIGINT and subtotal of type NUMERIC. It then executes a SELECT query on the order_items table, using the input_order_id parameter in a WHERE clause to filter rows where the order_id column matches the provided value. This query calculates two aggregate values: the COUNT of all matching rows is stored into the items_count variable, and the COALESCE of the SUM of the product of the price_each column (cast to NUMERIC) and the quantity column is stored into the subtotal variable, with a default value of 0 if the SUM result is NULL. After the query, the function assigns the value of the items_count variable to the output column total_items, and calculates the final_amount output column by multiplying the subtotal variable by the expression (1 + tax_rate). Finally, the function uses RETURN NEXT to return the computed row containing the total_items and final_amount values.",
    "original_summary": "Create a function named `calculate_order_summary` that takes a `BIGINT` parameter `input_order_id` and a `NUMERIC` parameter `tax_rate`. It returns a table with columns `total_items` (BIGINT) and `final_amount` (NUMERIC). For the given order, it counts the items and sums their total value, then applies the tax rate to calculate the final amount.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function called `calculate_order_summary` that accepts a `BIGINT` parameter `input_order_id` and a `NUMERIC` parameter `tax_rate`. Have it return a table containing the columns `total_items` (BIGINT) and `final_amount` (NUMERIC). For the specified order, count the items and sum their total value, then apply the provided tax rate to compute the final amount."
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the average amount of unit_price for all records in the order_items table where the order_id matches the provided parameter p_order_id. The function takes a single parameter, p_order_id, which is of type bigint and represents the identifier of the order for which the average unit price is to be calculated. The function performs a SELECT operation to compute the average of the unit_price column, converting each unit_price value to a numeric type using the TO_NUMBER function with the format '999999.99', ensuring that the unit_price values are correctly interpreted as numbers. The SELECT query filters the records by the condition that the order_id column in the order_items table must equal the input parameter p_order_id. The result of this SELECT query, which is the average unit price for the specified order, is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_order_average_amount(p_order_id bigint)\nRETURNS numeric AS $$\nBEGIN\n    RETURN (SELECT AVG(TO_NUMBER(unit_price, '999999.99')) FROM order_items WHERE order_id = p_order_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_commerce_order_management_and_sales_tracking_345211",
    "tables": [
      "customers",
      "orders",
      "order_items",
      "payments",
      "payment_methods",
      "products"
    ],
    "call_sqls": [
      "SELECT calculate_order_average_amount(0);",
      "SELECT calculate_order_average_amount(1);",
      "SELECT calculate_order_average_amount(100);",
      "SELECT calculate_order_average_amount(2);",
      "SELECT calculate_order_average_amount(50);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_order_average_amount that takes an order ID and returns the average unit price, as a numeric value, for all items in the order_items table associated with that specific order ID.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named calculate_order_average_amount that, given a specific order identifier, calculates and returns the average unit price as a numeric value for all items in the order_items table that match the provided order_id.",
    "id": 18,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_order_average_amount that accepts one input parameter: p_order_id of type bigint representing the specific order identifier for which the average unit price is to be calculated, and returns a single numeric value representing the computed average. The function executes a query that selects from the order_items table, filtering the rows to only include those where the order_id column matches the provided p_order_id parameter. For these filtered rows, the function calculates the average unit price by applying the AVG aggregate function to the unit_price column, which is of type text in the schema but must be converted to a numeric type for arithmetic operations. Specifically, the unit_price values are cast to numeric using the CAST function or the ::numeric syntax to ensure proper numerical averaging. The result of this AVG calculation is returned directly as the function's output. If no matching rows are found for the given order_id, the AVG function will return NULL, which the function will consequently return as NULL. The function does not involve any joins with other tables, as it operates solely on the order_items table using the provided order identifier.",
    "original_summary": "Create a PL/pgSQL function that takes a BIGINT order_id and returns the average unit price (converted to numeric) for all items in the order_items table with that order_id.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Construct a PL/pgSQL function which, when provided with a specific BIGINT order identifier, meticulously calculates and returns the precise average unit priceexplicitly cast to a numeric data typefor every single item entry meticulously listed within the comprehensive order_items table that corresponds exactly to the supplied order_id."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_patient_allergies` that accepts a single input parameter named `input_patient_id` of data type `bigint`. This function is designed to return a set of rows, effectively acting as a table, with each row containing two columns: `allergy` of data type `text` and `reaction` of data type `text`. The primary operation performed by this function is a data retrieval (SELECT) query. Specifically, it selects the `allergy` column and the `reaction` column from the table named `patient_allergies`. The selection of rows from the `patient_allergies` table is filtered by a `WHERE` clause, which specifies that only those rows where the value in the `patient_id` column of the `patient_allergies` table is exactly equal to the value provided in the `input_patient_id` parameter will be included in the result set. The `RETURN QUERY` statement is used to execute this `SELECT` query and return its entire result set as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_patient_allergies(input_patient_id bigint) RETURNS TABLE(allergy text, reaction text) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT pa.allergy, pa.reaction\n  FROM patient_allergies pa\n  WHERE pa.patient_id = input_patient_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "healthcare_and_medical_diagnosis_536770",
    "tables": [
      "patients",
      "appointments",
      "diagnoses",
      "patient_medical_history",
      "patient_allergies",
      "medical_staff"
    ],
    "call_sqls": [
      "SELECT * FROM get_patient_allergies(1);",
      "SELECT * FROM get_patient_allergies(0);",
      "SELECT allergy, reaction FROM get_patient_allergies(100);",
      "SELECT * FROM get_patient_allergies((SELECT patient_id FROM patients WHERE patient_id = 1));",
      "SELECT * FROM get_patient_allergies((SELECT patient_id FROM appointments WHERE appointment_id = 0));"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_patient_allergies` that, given an `input_patient_id`, retrieves all allergy records for that patient from the `patient_allergies` table, returning a table with the `allergy` and `reaction` details for each matching record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_patient_allergies that, for a given patient ID, lists all allergies and their corresponding reactions from the patient_allergies table.",
    "id": 19,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_patient_allergies` that accepts a single input parameter named `input_patient_id` of data type `bigint`. This function is designed to return a set of rows, effectively acting as a table, with each row containing two columns: `allergy` of data type `text` and `reaction` of data type `text`. The primary operation performed by this function is a data retrieval (SELECT) query. Specifically, it selects the `allergy` column and the `reaction` column from the table named `patient_allergies`. The selection of rows from the `patient_allergies` table is filtered by a `WHERE` clause, which specifies that only those rows where the value in the `patient_id` column of the `patient_allergies` table is exactly equal to the value provided in the `input_patient_id` parameter will be included in the result set. The `RETURN QUERY` statement is used to execute this `SELECT` query and return its entire result set as the output of the function.",
    "original_summary": "Create a PL/pgSQL function named `get_patient_allergies` that returns a table with columns `allergy` (text) and `reaction` (text). The function accepts an `input_patient_id` (bigint) parameter and returns all records from the `patient_allergies` table where the `patient_id` matches the input parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "List all allergies and their corresponding reactions for the patient with the specified ID."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_customer_total_orders` that accepts a single input parameter, `p_customer_id`, which is of data type `bigint`. This function is designed to return a single value of data type `bigint`. Upon execution, the function performs a `SELECT` operation to count the total number of records in the `orders` table. The counting operation is subject to a `WHERE` clause condition, which filters the records such that only those rows where the `customer_id` column's value is equal to the value provided in the `p_customer_id` input parameter are included in the count. The result of this `COUNT(*)` aggregation, representing the total number of orders for the specified customer, is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_total_orders(p_customer_id bigint)\nRETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM orders WHERE customer_id = p_customer_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_commerce_order_management_and_sales_tracking_345211",
    "tables": [
      "customers",
      "orders",
      "order_items",
      "payments",
      "payment_methods",
      "products"
    ],
    "call_sqls": [
      "SELECT get_customer_total_orders(0);",
      "SELECT get_customer_total_orders(1);",
      "SELECT get_customer_total_orders(10);",
      "SELECT get_customer_total_orders(100);",
      "SELECT get_customer_total_orders(12345);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_customer_total_orders that takes a customer_id and returns the total number of orders for that customer from the ORDERS table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_customer_total_orders that, given a customer's unique identifier, returns the total number of orders placed by that customer from the orders table.",
    "id": 20,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_customer_total_orders` that accepts a single input parameter, `p_customer_id`, which is of data type `bigint`. This function is designed to return a single value of data type `bigint`. Upon execution, the function performs a `SELECT` operation to count the total number of records in the `orders` table. The counting operation is subject to a `WHERE` clause condition, which filters the records such that only those rows where the `customer_id` column's value is equal to the value provided in the `p_customer_id` input parameter are included in the count. The result of this `COUNT(*)` aggregation, representing the total number of orders for the specified customer, is then returned as the output of the function.",
    "original_summary": "Create a PL/pgSQL function named get_customer_total_orders that takes a BIGINT customer_id and returns a BIGINT count of all orders for that customer from the orders table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Construct a PL/pgSQL function, which should be named get_customer_total_orders, that will accept a single BIGINT parameter representing a specific customer's unique identifier and will meticulously return, as a BIGINT value, the comprehensive and total count of every single order ever placed by that particular customer, as meticulously recorded within the extensive orders table."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `analyze_country_performance` that accepts three input parameters: `country_name_input` of type `TEXT`, `start_year` of type `BIGINT`, and `end_year` of type `BIGINT`. This function is designed to calculate and return the average happiness score for a specified country within a given range of years. The function declares two local variables: `v_country_id` of type `BIGINT` to store the internal identifier of the country, and `v_avg_score` of type `REAL` to store the calculated average happiness score.\n\nThe function begins by attempting to retrieve the `country_id` from the `countries` table. It performs a `SELECT` operation to fetch the `country_id` column and store its value into the `v_country_id` variable. This selection is filtered by a `WHERE` clause, matching the `country_name` column in the `countries` table with the value provided in the `country_name_input` parameter.\n\nFollowing this initial data retrieval, a conditional `IF` statement evaluates whether `v_country_id` is `NOT NULL`. This check determines if a country matching the `country_name_input` was found in the `countries` table.\n\nIf `v_country_id` is `NOT NULL` (meaning the country was found), the function proceeds to calculate the average happiness score. It executes another `SELECT` operation to compute the `AVG` (average) of the `happiness_score` column from the `happiness_scores` table. This average is then stored into the `v_avg_score` variable. This `SELECT` statement involves a `JOIN` operation between the `happiness_scores` table (aliased as `hs`) and the `years` table (aliased as `y`) on the condition that `hs.year_id` equals `y.year_id`. Further filtering is applied using a `WHERE` clause: `hs.country_id` must match the `v_country_id` obtained earlier, and the `year` column from the `years` table (`y.year`) must fall inclusively `BETWEEN` the `start_year` and `end_year` parameters provided to the function.\n\nIf `v_country_id` IS `NULL` (meaning no country matching the `country_name_input` was found), the `ELSE` block of the conditional statement is executed. In this case, the `v_avg_score` variable is explicitly assigned a value of `0`.\n\nFinally, regardless of whether a country was found or not, the function concludes by returning the value stored in the `v_avg_score` variable, which is of type `REAL`.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_country_performance(\n    country_name_input TEXT,\n    start_year BIGINT,\n    end_year BIGINT\n)\nRETURNS REAL\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_country_id BIGINT;\n    v_avg_score REAL;\nBEGIN\n    SELECT country_id INTO v_country_id\n    FROM countries\n    WHERE country_name = country_name_input;\n    \n    IF v_country_id IS NOT NULL THEN\n        SELECT AVG(hs.happiness_score) INTO v_avg_score\n        FROM happiness_scores hs\n        JOIN years y ON hs.year_id = y.year_id\n        WHERE hs.country_id = v_country_id \n          AND y.year BETWEEN start_year AND end_year;\n    ELSE\n        v_avg_score := 0;\n    END IF;\n    \n    RETURN v_avg_score;\nEND;\n$$;",
    "database_name": "global_happiness_and_quality_of_life_metrics",
    "tables": [
      "countries",
      "happiness_scores",
      "regions",
      "years",
      "predictions",
      "metrics"
    ],
    "call_sqls": [
      "SELECT analyze_country_performance('Switzerland', 2015, 2020);",
      "SELECT analyze_country_performance('Iceland', 2016, 2022);",
      "SELECT analyze_country_performance('United States', 2018, 2023);",
      "SELECT analyze_country_performance('Japan', 2015, 2021);",
      "SELECT analyze_country_performance('Brazil', 2017, 2022);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named analyze_country_performance that, given a country_name_input, a start_year, and an end_year, returns the average happiness_score from the happiness_scores table for that country within the specified year range by looking up the country_id from the countries table; if the country is not found, it returns 0.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named analyze_country_performance that takes a country name as text, a start year, and an end year as inputs, and returns a real number representing the average happiness score. It should first retrieve the country_id from the countries table using the provided country name. If the country exists, calculate the average happiness score from the happiness_scores and years tables for that country between the start and end years. If the country is not found, return zero.",
    "id": 21,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `analyze_country_performance` that accepts three input parameters: `country_name_input` of type `text`, `start_year_input` of type `bigint`, and `end_year_input` of type `bigint`. The function returns a value of type `real`. The function is designed to compute the average happiness score for a specified country over a given range of years.\n\nThe function begins by declaring two local variables: `v_country_id` of type `bigint` to store the retrieved country identifier, and `v_avg_happiness_score` of type `real` to store the calculated average happiness score.\n\nThe function then executes a `SELECT` statement to retrieve the `country_id` from the `countries` table. The selection is based on the condition that the `country_name` column matches the input parameter `country_name_input`. The result of this query is stored into the `v_country_id` variable.\n\nFollowing this retrieval, the function enters a conditional block (`IF-ELSE`) to check if a country was found:\n1. **Condition (`IF` block):** If the `v_country_id` variable is not `NULL` (indicating a country was found), the function proceeds to calculate the average happiness score. It executes a `SELECT` statement that computes the average of the `happiness_score` column from the `happiness_scores` table. This calculation involves an inner join with the `years` table on the condition that `happiness_scores.year_id` equals `years.year_id`. The average is computed only for records where the `happiness_scores.country_id` matches the retrieved `v_country_id` AND the `years.year` column value is between the `start_year_input` and `end_year_input` parameters (inclusive). The result of this average calculation is stored into the `v_avg_happiness_score` variable. Finally, the function returns the value stored in `v_avg_happiness_score`.\n2. **Default Action (`ELSE` block):** If the `v_country_id` variable is `NULL` (indicating no country was found with the provided name), the function returns the real number `0`.",
    "original_summary": "Create a PL/pgSQL function named analyze_country_performance with parameters country_name_input (TEXT), start_year (BIGINT), and end_year (BIGINT). It returns a REAL value. The function first gets the country_id for the given country_name. If found, it calculates the average happiness_score for that country within the specified year range by joining happiness_scores with the years table. If the country is not found, it returns 0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Alright, so I need you to whip up a PL/pgSQL function called 'analyze_country_performance'. It's gonna take three things: the country's name as text, a start year, and an end year (both as big integers). It'll spit out a real number. Here's the deal: first, it's gotta look up the country_id using the name we give it. If it finds the country, it then figures out the average happiness score for that place between the start and end years. It does this by pulling data from the happiness_scores and years tables and joining them. If the country isn't in the system at all, just have it return a zero."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_region_comparison_metric` that accepts two input parameters: `p_region_id_a` of type `bigint` and `p_region_id_b` of type `bigint`. The purpose of `p_region_id_a` is to represent the identifier of the first region for comparison, and the purpose of `p_region_id_b` is to represent the identifier of the second region for comparison. This function is designed to return a value of type `text`.\n\nUpon execution, the function declares a local variable named `v_comparison_metric` of type `text`. The function then proceeds to perform a `SELECT` operation. This `SELECT` statement retrieves the value from the `comparison_metric` column of the `comparative_analyses` table. The retrieved value is then assigned to the local variable `v_comparison_metric`. The `SELECT` operation is constrained by a `WHERE` clause that specifies two conditions connected by an `AND` logical operator. The first condition requires that the value in the `region_id_a` column of the `comparative_analyses` table must be equal to the value provided in the `p_region_id_a` input parameter. The second condition requires that the value in the `region_id_b` column of the `comparative_analyses` table must be equal to the value provided in the `p_region_id_b` input parameter.\n\nFollowing the `SELECT` operation, the function executes an `IF` conditional statement. This `IF` statement checks whether the value stored in the `v_comparison_metric` variable `IS NOT NULL`. If this condition evaluates to true, meaning a comparison metric was successfully retrieved from the `comparative_analyses` table, the function immediately returns the current value of `v_comparison_metric`.\n\nIf the condition in the `IF` statement evaluates to false, meaning `v_comparison_metric` is `NULL` (which would occur if no matching row was found in the `comparative_analyses` table for the given `p_region_id_a` and `p_region_id_b`), the function then proceeds to the next statement. This statement returns the literal string value `'No comparison available'`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_region_comparison_metric(p_region_id_a bigint, p_region_id_b bigint)\nRETURNS text AS $$\nDECLARE\n    v_comparison_metric text;\nBEGIN\n    SELECT comparison_metric INTO v_comparison_metric \n    FROM comparative_analyses \n    WHERE region_id_a = p_region_id_a AND region_id_b = p_region_id_b;\n    \n    IF v_comparison_metric IS NOT NULL THEN\n        RETURN v_comparison_metric;\n    END IF;\n    \n    RETURN 'No comparison available';\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "real_estate_market_analysis_and_housing_data_management",
    "tables": [
      "regions",
      "economic_indicators",
      "comparative_analyses",
      "market_trends"
    ],
    "call_sqls": [
      "SELECT get_region_comparison_metric(1, 2);",
      "SELECT get_region_comparison_metric(3, 4);",
      "SELECT get_region_comparison_metric(5, 6);",
      "SELECT get_region_comparison_metric(10, 11);",
      "SELECT get_region_comparison_metric(1, 3);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_region_comparison_metric` that, for two given region IDs, retrieves the corresponding `comparison_metric` text from the `comparative_analyses` table where `region_id_a` and `region_id_b` match the inputs; if no matching record exists, it returns the string 'No comparison available'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_region_comparison_metric that retrieves the comparison metric from the comparative_analyses table for two specified region IDs, provided as inputs p_region_id_a and p_region_id_b. If a matching record exists, return the comparison_metric text; otherwise, return 'No comparison available'.",
    "id": 22,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_region_comparison_metric that accepts two input parameters: p_region_id_a of type bigint and p_region_id_b of type bigint, representing the unique identifiers of two regions to be compared. The function returns a single text value, which is the comparison metric for the specified region pair.\n\nThe function begins by declaring a local variable v_comparison_metric of type text to store the retrieved comparison metric from the database.\n\nIt then executes a SELECT statement to query the comparative_analyses table. The SELECT statement retrieves the value from the comparison_metric column. The query includes a WHERE clause with a compound condition to find a record where the region_id_a column matches the input parameter p_region_id_a AND the region_id_b column matches the input parameter p_region_id_b. The result of this query is stored into the local variable v_comparison_metric.\n\nFollowing the SELECT, the function uses conditional logic to determine its return value. It checks if the v_comparison_metric variable is NOT NULL, meaning a matching record was successfully found and a value was retrieved. If this condition is true, the function returns the value stored in v_comparison_metric. If the condition is false, meaning v_comparison_metric is NULL (which occurs when no matching record exists in the comparative_analyses table for the given region IDs), the function returns the literal string 'No comparison available'.",
    "original_summary": "Create a PL/pgSQL function named `get_region_comparison_metric` that retrieves the `comparison_metric` text for two specified region IDs from the `comparative_analyses` table. The function takes `p_region_id_a` and `p_region_id_b` (both bigint) as input. If a matching record is found, return the metric. If no match is found, return the string 'No comparison available'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Retrieve the comparison metric for two specified region IDs from the comparative_analyses table. Use the function get_region_comparison_metric with inputs p_region_id_a and p_region_id_b. If a match exists, return the metric text; otherwise, return 'No comparison available'."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_player_injury_count` that accepts a single input parameter, `p_player_id`, which is of type `bigint` and represents the unique identifier for a player. This function is designed to return a single value of type `bigint`, representing the total number of injuries associated with the specified player. Internally, the function declares a local variable named `v_injury_count` of type `bigint` to temporarily store the computed count. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows that satisfy the specified conditions. The data for this count is retrieved from the `player_injuries` table. The `WHERE` clause of the `SELECT` statement filters these rows, ensuring that only those records where the `player_id` column in the `player_injuries` table is exactly equal to the value provided by the input parameter `p_player_id` are included in the count. The result of this `COUNT(*)` operation is then assigned to the local variable `v_injury_count`. Finally, the function returns the value stored in `v_injury_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_injury_count(p_player_id bigint) RETURNS bigint AS $$\nDECLARE\n    v_injury_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_injury_count\n    FROM player_injuries\n    WHERE player_id = p_player_id;\n    RETURN v_injury_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "basketball_player_performance_and_team_statistics_549881",
    "tables": [
      "players",
      "player_contracts",
      "player_injuries",
      "player_seasons",
      "teams"
    ],
    "call_sqls": [
      "SELECT get_player_injury_count(1);",
      "SELECT get_player_injury_count(0);",
      "SELECT get_player_injury_count(99);",
      "SELECT get_player_injury_count( (SELECT player_id FROM players ORDER BY player_id DESC LIMIT 1) );",
      "SELECT get_player_injury_count( (SELECT player_id FROM player_injuries ORDER BY player_id ASC LIMIT 1) );"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_player_injury_count that, for a given player_id, returns the total number of injury records associated with that player from the player_injuries table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_player_injury_count that, given a player_id, returns the total number of injury records for that player from the player_injuries table.",
    "id": 23,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_player_injury_count` that accepts a single input parameter, `p_player_id`, which is of type `bigint` and represents the unique identifier for a player. This function is designed to return a single value of type `bigint`, representing the total number of injuries associated with the specified player. Internally, the function declares a local variable named `v_injury_count` of type `bigint` to temporarily store the computed count. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement performs a `COUNT(*)` aggregation, which counts all rows that satisfy the specified conditions. The data for this count is retrieved from the `player_injuries` table. The `WHERE` clause of the `SELECT` statement filters these rows, ensuring that only those records where the `player_id` column in the `player_injuries` table is exactly equal to the value provided by the input parameter `p_player_id` are included in the count. The result of this `COUNT(*)` operation is then assigned to the local variable `v_injury_count`. Finally, the function returns the value stored in `v_injury_count` as its output.",
    "original_summary": "Create a function named get_player_injury_count that takes a player_id (bigint) and returns a bigint. It counts and returns the number of injury records for the given player from the player_injuries table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Count the number of injury records for a specified player from the player_injuries table. Implement this as a function called get_player_injury_count that accepts a player_id (bigint) and returns the total count as a bigint."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter input_user_id of type BIGINT and returns a TEXT value. The function retrieves the permissions associated with a user by performing a SELECT operation. It joins the users table, aliased as u, with the user_roles table, aliased as ur, on the condition that the role_id column in the users table matches the role_id column in the user_roles table. The function filters the results to include only the row where the user_id column in the users table matches the input_user_id parameter. The permissions column from the resulting joined table is returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_permissions(input_user_id BIGINT) RETURNS TEXT AS $$\nBEGIN\n    RETURN (SELECT permissions FROM users u JOIN user_roles ur ON u.role_id = ur.role_id WHERE u.user_id = input_user_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "mobile_device_specifications_and_analytics",
    "tables": [
      "users",
      "user_roles"
    ],
    "call_sqls": [
      "SELECT get_user_permissions(0);",
      "SELECT get_user_permissions(1);",
      "SELECT get_user_permissions(2);",
      "SELECT get_user_permissions(100);",
      "SELECT get_user_permissions(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_user_permissions that, given a specific user ID as input, retrieves and returns the permissions associated with that user by joining the users and user_roles tables on role_id where the user_id matches the provided input.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_user_permissions that, given a user_id as input, retrieves the permissions from the users table by joining it with the user_roles table on role_id where the user_id matches the provided input, and returns those permissions as TEXT.",
    "id": 24,
    "generated_ir": "Write a PL/pgSQL function named `get_user_permissions` that returns a single `TEXT` value. The function accepts one input parameter named `user_id` of type `bigint`. The function operates on the database `mobile_device_specifications_and_analytics` and uses the tables `users` and `user_roles`. It begins by declaring a variable `permissions_text` of type `TEXT` to store the result. The core operation is a `SELECT INTO` statement that retrieves the `permissions` column from the `user_roles` table. To do this, it performs an inner join between the `users` table and the `user_roles` table using the condition `users.role_id = user_roles.role_id`. The join is filtered with a `WHERE` clause that specifies `users.user_id = input_user_id`, ensuring only the record for the provided user identifier is selected. The retrieved `permissions` value is assigned to the variable `permissions_text`. Finally, the function returns the value stored in `permissions_text` as its output. If no matching user is found, the variable will be `NULL`, and the function returns `NULL`.",
    "original_summary": "Create a PL/pgSQL function that takes BIGINT parameter input_user_id and returns TEXT. Return permissions column from join of users and user_roles tables on role_id where user_id equals input_user_id.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function returning TEXT from a BIGINT user_id. Join users and user_roles on role_id, select permissions where user_id matches the input."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter team_id_input of type bigint and returns an integer. The function calculates the total number of championships won by a team with the specified team_id_input. It declares a local variable championships_count of type integer to store the result. The function performs a SELECT operation on the team_history table, specifically summing the values in the championships column for all rows where the team_id column matches the provided team_id_input. The result of this aggregation is stored in the championships_count variable. Finally, the function returns the value of championships_count, which represents the total number of championships associated with the given team_id_input.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_championships(team_id_input bigint)\nRETURNS integer AS $$\nDECLARE\n    championships_count integer;\nBEGIN\n    SELECT SUM(championships) INTO championships_count\n    FROM team_history\n    WHERE team_id = team_id_input;\n\n    RETURN championships_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "basketball_player_performance_and_team_statistics",
    "tables": [
      "teams",
      "players",
      "player_contracts",
      "player_injuries",
      "team_finances",
      "team_standings",
      "team_history"
    ],
    "call_sqls": [
      "SELECT get_team_championships(1);",
      "SELECT get_team_championships(2);",
      "SELECT get_team_championships(3);",
      "SELECT get_team_championships(4);",
      "SELECT get_team_championships(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_team_championships that takes a team ID and returns the total championships won by that team by summing the championships column from the team_history table for the specified team.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_team_championships that, for a given team identified by team_id_input, calculates and returns the total number of championships won by summing the championships column in the team_history table.",
    "id": 25,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_team_championships that accepts a single input parameter named team_id_input of data type bigint, representing the unique identifier of a team. The function is designed to return a value of data type bigint, which will be the total number of championships won by the specified team. The function begins by declaring a local variable named total_championships of type bigint, which will store the computed sum. The function then executes a SELECT statement that performs an aggregation. It retrieves the sum of the values in the championships column from the table named team_history. The selection is filtered by a WHERE clause, which specifies that only rows where the value in the team_id column matches the value provided in the team_id_input parameter should be considered for the summation. The result of this SUM aggregation is stored into the total_championships variable. If no rows match the condition, the SUM function returns NULL, which will be stored as NULL in the variable. The function then returns the value stored in the total_championships variable as its final result.",
    "original_summary": "Create a function that takes a team ID and returns the total number of championships won by that team, calculated by summing the championships column in the team_history table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the total number of championships won by a given team, based on summing the championships column in the team_history table?"
  },
  {
    "ir": "Write a PLpgSQL function that takes a parameter p_garment_id of type bigint, representing the identifier of a garment type, and returns a text value indicating the availability of sizes for that garment type. The function begins by declaring two local variables: v_size_count of type bigint to store the count of distinct sizes available, and v_result of type text to store the result message. It then executes a SELECT statement to count the number of distinct size names from the sizes table, which is joined with the inventory table on the size_id column. The WHERE clause filters the inventory records to include only those with a garment_type_id matching the input parameter p_garment_id and a quantity greater than zero, indicating that the size is in stock. The result of this count is stored in the v_size_count variable. The function then evaluates a conditional statement: if v_size_count is greater than or equal to 3, it assigns the text 'Full Range Available' to v_result; otherwise, it assigns 'Limited Sizes'. Finally, the function returns the trimmed value of v_result, ensuring no leading or trailing spaces are present in the output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_size_availability(p_garment_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_size_count bigint;\n    v_result text;\nBEGIN\n    SELECT COUNT(DISTINCT s.size_name) INTO v_size_count \n    FROM sizes s JOIN inventory i ON s.size_id = i.size_id \n    WHERE i.garment_type_id = p_garment_id AND i.quantity > 0;\n    IF v_size_count >= 3 THEN\n        v_result := 'Full Range Available';\n    ELSE\n        v_result := 'Limited Sizes';\n    END IF;\n    RETURN TRIM(v_result);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "garment_measurement_and_inventory_management_826182",
    "tables": [
      "customers",
      "orders",
      "order_items",
      "garment_types",
      "sizes",
      "inventory"
    ],
    "call_sqls": [
      "SELECT get_size_availability(1);",
      "SELECT get_size_availability(2);",
      "SELECT get_size_availability(3);",
      "SELECT get_size_availability(4);",
      "SELECT get_size_availability(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_size_availability that, given a garment type ID, returns a text message indicating size availability by counting the distinct in-stock sizes for that garment type from the sizes and inventory tables where quantity is greater than zero; if the count is three or more, return 'Full Range Available', otherwise return 'Limited Sizes', ensuring the result is trimmed of any spaces.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_size_availability that, given a garment type ID, checks the availability of sizes by counting distinct in-stock sizes from the sizes and inventory tables where quantity is positive, and returns a trimmed message: 'Full Range Available' if three or more sizes are available, otherwise 'Limited Sizes'.",
    "id": 26,
    "generated_ir": "Write a PLpgSQL function that takes a parameter p_garment_id of type bigint, representing the identifier of a garment type, and returns a text value indicating the availability of sizes for that garment type. The function begins by declaring two local variables: v_size_count of type bigint to store the count of distinct sizes available, and v_result of type text to store the result message. It then executes a SELECT statement to count the number of distinct size names from the sizes table, which is joined with the inventory table on the size_id column. The WHERE clause filters the inventory records to include only those with a garment_type_id matching the input parameter p_garment_id and a quantity greater than zero, indicating that the size is in stock. The result of this count is stored in the v_size_count variable. The function then evaluates a conditional statement: if v_size_count is greater than or equal to 3, it assigns the text 'Full Range Available' to v_result; otherwise, it assigns 'Limited Sizes'. Finally, the function returns the trimmed value of v_result, ensuring no leading or trailing spaces are present in the output.",
    "original_summary": "Create a function that takes a garment type ID and returns a text message about size availability. It counts the distinct in-stock sizes for that garment type. If the count is 3 or more, return 'Full Range Available'. Otherwise, return 'Limited Sizes'. Trim any spaces from the result.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Function: input garment type ID, output message on size availability. Count distinct in-stock sizes. Return 'Full Range Available' for 3 or more, else 'Limited Sizes'. Trim spaces."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_player_career_high_score that accepts a single input parameter called player_id_input of type bigint, which represents the unique identifier for a player, and returns a single bigint value; the function declares a local variable named v_career_high_score of type bigint to store the result; the function's logic executes a SELECT query that retrieves the value from the career_high_score column of the players table, using the alias p for the table, and assigns that value into the v_career_high_score variable by matching the player_id column from the players table to the provided player_id_input parameter in the WHERE clause condition; the function then concludes by returning the value stored in the v_career_high_score variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_career_high_score(player_id_input bigint)\nRETURNS bigint AS $$\nDECLARE\n    v_career_high_score bigint; -- Renamed variable to avoid ambiguity\nBEGIN\n    SELECT p.career_high_score INTO v_career_high_score\n    FROM players p\n    WHERE p.player_id = player_id_input;\n\n    RETURN v_career_high_score;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "basketball_player_performance_and_team_statistics",
    "tables": [
      "teams",
      "players",
      "player_contracts",
      "player_injuries",
      "team_finances",
      "team_standings",
      "team_history"
    ],
    "call_sqls": [
      "SELECT get_player_career_high_score(101);",
      "SELECT get_player_career_high_score(205);",
      "SELECT get_player_career_high_score(178);",
      "SELECT get_player_career_high_score(342);",
      "SELECT get_player_career_high_score(567);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_player_career_high_score that takes a player ID and returns the career high score for that player by retrieving the career_high_score column from the players table where the player_id matches the input.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_player_career_high_score that, given a player's identifier, retrieves their top performance record from the players data, returning the figure that represents their peak achievement.",
    "id": 27,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_player_career_high_score that accepts a single input parameter called player_id_input of type bigint, which represents the unique identifier for a player, and returns a single bigint value; the function declares a local variable named v_career_high_score of type bigint to store the result; the function's logic executes a SELECT query that retrieves the value from the career_high_score column of the players table, using the alias p for the table, and assigns that value into the v_career_high_score variable by matching the player_id column from the players table to the provided player_id_input parameter in the WHERE clause condition; the function then concludes by returning the value stored in the v_career_high_score variable.",
    "original_summary": "Create a function that takes a player ID and returns the player's career high score by selecting the career_high_score column from the players table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Make a function that, given a player's identifier, fetches their top performance record from the players data, pulling the figure that represents their peak achievement."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter input_team_id of type bigint and returns a bigint value. The function retrieves the founded_year from the teams table for the row where the team_id column matches the input_team_id parameter. The function performs a SELECT operation to obtain the founded_year, which is then returned as the output of the function. The function is defined using the PL/pgSQL language and does not include any conditional logic or additional operations beyond the SELECT statement.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_founded_year(input_team_id bigint) RETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT founded_year FROM teams WHERE team_id = input_team_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "sports_data_analysis_and_statistics",
    "tables": [
      "games",
      "game_outcomes",
      "teams",
      "leagues"
    ],
    "call_sqls": [
      "SELECT get_team_founded_year(1);",
      "SELECT get_team_founded_year(2);",
      "SELECT get_team_founded_year(3);",
      "SELECT get_team_founded_year(4);",
      "SELECT get_team_founded_year(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_team_founded_year that takes a team ID and returns the founded_year for that specific team from the teams table.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function named get_team_founded_year that, when I give it a team's ID, spits back the year that team was founded from the teams table?",
    "id": 28,
    "generated_ir": "Write a PLpgSQL function that takes a single parameter input_team_id of type bigint and returns a bigint value. The function retrieves the founded_year from the teams table for the row where the team_id column matches the input_team_id parameter. The function performs a SELECT operation to obtain the founded_year, which is then returned as the output of the function. The function is defined using the PL/pgSQL language and does not include any conditional logic or additional operations beyond the SELECT statement.",
    "original_summary": "Create a PL/pgSQL function that takes a team ID and returns the founded_year for that team from the teams table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a function in PL/pgSQL that, when I give it a team's ID, spits back the year that team was founded from the teams table?"
  },
  {
    "ir": "Write a PLpgSQL function named calculate_total_payments that accepts a single parameter p_loan_id of type bigint, which represents the unique identifier of a loan. The function is designed to compute the total sum of all payment amounts associated with the specified loan. It begins by declaring a local variable v_total of type real to store the result of the computation. The function then executes a SQL SELECT statement that calculates the sum of the payment_amount column from the payments table, filtering the rows where the loan_id column matches the provided p_loan_id parameter. The result of this aggregation is stored into the v_total variable. Finally, the function returns the value of v_total, which represents the total payments made for the loan identified by p_loan_id.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_payments(p_loan_id bigint)\nRETURNS real AS $$\nDECLARE\n    v_total real;\nBEGIN\n    SELECT SUM(payment_amount) INTO v_total FROM payments WHERE loan_id = p_loan_id;\n    RETURN v_total;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "loan_management_and_financial_analytics",
    "tables": [
      "borrowers",
      "loan_officers",
      "loan_status",
      "loans",
      "payments",
      "recoveries",
      "users"
    ],
    "call_sqls": [
      "SELECT calculate_total_payments(0);",
      "SELECT calculate_total_payments(1);",
      "SELECT calculate_total_payments(100);",
      "SELECT calculate_total_payments(5);",
      "SELECT calculate_total_payments(999);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_total_payments that, given a loan_id, calculates and returns the total sum of all payment amounts from the payments table for that specific loan.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_total_payments that takes a loan_id and returns the total sum of payment_amount from the payments table for that specific loan.",
    "id": 29,
    "generated_ir": "Write a PLpgSQL function named calculate_total_payments that accepts a single parameter p_loan_id of type bigint, which represents the unique identifier of a loan. The function is designed to compute the total sum of all payment amounts associated with the specified loan. It begins by declaring a local variable v_total of type real to store the result of the computation. The function then executes a SQL SELECT statement that calculates the sum of the payment_amount column from the payments table, filtering the rows where the loan_id column matches the provided p_loan_id parameter. The result of this aggregation is stored into the v_total variable. Finally, the function returns the value of v_total, which represents the total payments made for the loan identified by p_loan_id.",
    "original_summary": "Create a PLpgSQL function named calculate_total_payments that accepts a loan_id (bigint). It calculates and returns the total sum of all payment amounts from the payments table for the specified loan.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PLpgSQL function called calculate_total_payments that takes a loan_id. It should figure out and give back the overall total of payment amounts from the payments records for that particular loan."
  },
  {
    "ir": "Write a PLpgSQL function named get_total_fatalities that accepts two mandatory input parameters: a bigint parameter named p_region_id to identify a specific geographical region, and a bigint parameter named p_year to specify a calendar year, and returns a single bigint value representing the computed total. The function declares a local bigint variable named v_total_fatalities to hold the result of its calculation. The core logic executes a SELECT query on the climate_data table, using the COALESCE function to ensure a result of zero if the SUM aggregation yields NULL. The query sums the values from the fatalities column for all rows in the climate_data table where the region_id column exactly matches the input parameter p_region_id and the year column exactly matches the input parameter p_year. The result of this summation is stored into the local variable v_total_fatalities. The function concludes by returning the value contained in the v_total_fatalities variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_total_fatalities(p_region_id bigint, p_year bigint)\nRETURNS bigint AS $$\nDECLARE\n    v_total_fatalities bigint;\nBEGIN\n    SELECT COALESCE(SUM(fatalities), 0) INTO v_total_fatalities\n    FROM climate_data\n    WHERE region_id = p_region_id AND year = p_year;\n    RETURN v_total_fatalities;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "climate_data_analysis_and_prediction",
    "tables": [
      "climate_data",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_total_fatalities(0, 2023);",
      "SELECT get_total_fatalities(1, 2022);",
      "SELECT get_total_fatalities(0, 2021);",
      "SELECT get_total_fatalities(1, 2023);",
      "SELECT get_total_fatalities(0, 2020);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_total_fatalities that calculates the total number of fatalities from the climate_data table for a specified region_id and year, returning the sum as a bigint total, or 0 if no data exists for that region and year.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_total_fatalities that calculates the total number of fatalities for a specified region and year, returning the sum from the climate_data table for the given region_id and year, or zero if there are none.",
    "id": 30,
    "generated_ir": "Write a PLpgSQL function named get_total_fatalities that accepts two mandatory input parameters: a bigint parameter named p_region_id to identify a specific geographical region, and a bigint parameter named p_year to specify a calendar year, and returns a single bigint value representing the computed total. The function declares a local bigint variable named v_total_fatalities to hold the result of its calculation. The core logic executes a SELECT query on the climate_data table, using the COALESCE function to ensure a result of zero if the SUM aggregation yields NULL. The query sums the values from the fatalities column for all rows in the climate_data table where the region_id column exactly matches the input parameter p_region_id and the year column exactly matches the input parameter p_year. The result of this summation is stored into the local variable v_total_fatalities. The function concludes by returning the value contained in the v_total_fatalities variable.",
    "original_summary": "Create a PL/pgSQL function named get_total_fatalities that takes a bigint region_id and a bigint year as input and returns a bigint total. The function sums the fatalities from the climate_data table for the given region and year. If no data is found, return 0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the total number of fatalities for a specified region and year, and how can I create a function to calculate it?"
  },
  {
    "ir": "Write a PLpgSQL function named analyze_lab_results that accepts a single parameter, patient_id_input of type bigint, and returns a table with columns test_category of type text and abnormal_count of type bigint. The function begins by declaring a boolean variable has_diabetes. It then performs a SELECT operation on the health_metrics table to check if there exists any record where the patient_id matches the input parameter patient_id_input and the outcome column equals 1, indicating the presence of diabetes. The result of this query is stored in the has_diabetes variable. The function then uses an IF statement to determine the flow of execution based on the value of has_diabetes. If has_diabetes is true, the function executes a RETURN QUERY statement that selects data from the lab_results table. It categorizes the tests into 'Diabetes Tests' if the test_name column contains the substring 'HbA1c' or 'Glucose', otherwise categorizes them as 'Other Tests'. It counts the number of records where the result_value column is greater than 100, casting the count to bigint, and groups the results by test_category. If has_diabetes is false, the function executes a different RETURN QUERY statement that selects data from the lab_results table, categorizing all tests as 'General Tests'. It counts the number of records where the result_value column is greater than 150, casting the count to bigint, and groups the results by test_category. The function uses the plpgsql language for its implementation.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_lab_results(patient_id_input bigint) RETURNS TABLE(test_category text, abnormal_count bigint) AS $$\nDECLARE\n    has_diabetes boolean;\nBEGIN\n    SELECT EXISTS(SELECT 1 FROM health_metrics WHERE patient_id = patient_id_input AND outcome = 1) INTO has_diabetes;\n    \n    IF has_diabetes THEN\n        RETURN QUERY \n        SELECT CASE \n                 WHEN lr.test_name LIKE '%HbA1c%' THEN 'Diabetes Tests'\n                 WHEN lr.test_name LIKE '%Glucose%' THEN 'Diabetes Tests'\n                 ELSE 'Other Tests'\n               END as test_category,\n               COUNT(CASE WHEN lr.result_value > 100 THEN 1 END)::bigint as abnormal_count\n        FROM lab_results lr\n        WHERE lr.patient_id = patient_id_input\n        GROUP BY test_category;\n    ELSE\n        RETURN QUERY \n        SELECT 'General Tests'::text as test_category,\n               COUNT(CASE WHEN lr.result_value > 150 THEN 1 END)::bigint as abnormal_count\n        FROM lab_results lr\n        WHERE lr.patient_id = patient_id_input\n        GROUP BY test_category;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "healthcare_data_analysis_and_patient_outcomes",
    "tables": [
      "patients",
      "doctors",
      "health_metrics",
      "lab_results",
      "treatments"
    ],
    "call_sqls": [
      "SELECT * FROM analyze_lab_results(0);",
      "SELECT * FROM analyze_lab_results(1);",
      "SELECT * FROM analyze_lab_results(2);",
      "SELECT * FROM analyze_lab_results(3);",
      "SELECT * FROM analyze_lab_results(4);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `analyze_lab_results` that, for a given patient ID, returns a table with columns `test_category` and `abnormal_count`. The function first checks if the patient has diabetes by verifying if their record in the `health_metrics` table has an outcome of 1. If the patient has diabetes, it retrieves all lab results for that patient from the `lab_results` table, categorizes tests with names containing 'HbA1c' or 'Glucose' as 'Diabetes Tests' and all others as 'Other Tests', and counts how many results have a value greater than 100 per category. If the patient does not have diabetes, it categorizes all their lab results as 'General Tests' and counts how many have a value greater than 150.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `analyze_lab_results` that, given a patient's ID, returns a table with columns `test_category` and `abnormal_count`. First, check if the patient has diabetes by seeing if their 'outcome' is 1 in the `health_metrics` table. If they do, then from the `lab_results` table, categorize tests containing 'HbA1c' or 'Glucose' in the test name as 'Diabetes Tests' and all others as 'Other Tests', and count how many of their results exceed 100. If the patient does not have diabetes, label all their tests as 'General Tests' and count how many results are above 150.",
    "id": 31,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named analyze_lab_results that accepts one input parameter: a bigint parameter named patient_id representing the unique identifier for a patient. The function returns a table with two columns: test_category of type text and abnormal_count of type bigint. The function determines whether the specified patient has diabetes by querying the health_metrics table. It performs a SELECT statement to retrieve the outcome column from the health_metrics table for the given patient_id, specifically fetching the most recent record based on the measurement_date and measurement_time columns, ordering by measurement_date descending and measurement_time descending, and limiting the result to one row. The function stores the retrieved outcome value in a local variable named has_diabetes of type bigint. If no record is found, the has_diabetes variable remains NULL.\n\nThe function then uses a conditional IF statement to evaluate the has_diabetes variable. If has_diabetes equals 1, indicating the patient has diabetes, the function executes a query to analyze the patient's lab results from the lab_results table. This query categorizes each test based on its test_name: if the test_name contains the substring 'HbA1c' or 'Glucose' (case-insensitive, using the ILIKE operator with pattern matching), it assigns the category 'Diabetes Tests'; otherwise, it assigns 'Other Tests'. For each category, it counts the number of results where the result_value exceeds 100.0. The query groups the results by the derived category and returns the aggregated counts.\n\nIf has_diabetes is not equal to 1 (i.e., it is 0, NULL, or any other value), the function executes an alternative query. This query labels all tests for the patient as 'General Tests' and counts the number of results where the result_value exceeds 150.0. Since all rows are grouped under the single category 'General Tests', the query returns one row with the total abnormal count.\n\nThe function returns the result set from the appropriate query based on the diabetes condition. The returned table includes rows for each test category with the corresponding count of abnormal results. If no lab results exist for the patient, the function returns an empty result set. The function operates within the healthcare_data_analysis_and_patient_outcomes database and interacts with the health_metrics and lab_results tables, leveraging the relationship via patient_id.",
    "original_summary": "Create a PLpgSQL function named `analyze_lab_results` that returns a table with columns `test_category` (text) and `abnormal_count` (bigint). It accepts a `bigint` patient ID. The function first checks if the patient has diabetes (outcome = 1 in `health_metrics`). If true, it queries the `lab_results` table, categorizing tests containing 'HbA1c' or 'Glucose' as 'Diabetes Tests' and others as 'Other Tests', and counts results greater than 100. If the patient does not have diabetes, it categorizes all tests as 'General Tests' and counts results greater than 150.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Alright, so I need you to write a PLpgSQL function called `analyze_lab_results`. It's gotta spit out a table with two columns: `test_category` (as text) and `abnormal_count` (as a bigint). The function takes one input, which is the patient's ID (a bigint). Here's the deal: first, check if this patient's got diabetes. You can tell by looking in the `health_metrics` tableif their 'outcome' is set to 1, then yep, they have it. If they do have diabetes, then go into the `lab_results` table. Any test with 'HbA1c' or 'Glucose' in its name gets labeled as 'Diabetes Tests', and everything else is just 'Other Tests'. For those, count up how many results are over 100. If the patient doesn't have diabetes, then it's simpler: just label all their tests as 'General Tests' and count how many results are above 150. That's the whole thing."
  },
  {
    "ir": "Write a PLpgSQL function named analyze_missed_deadlines that accepts two parameters: user_input of type BIGINT and min_duration of type REAL. The function is designed to analyze missed deadlines for a specific user within a jobs table. It begins by declaring three local variables: total_missed of type INTEGER, avg_missed_time of type REAL, and analysis_result of type TEXT. The function executes a SELECT statement to count the number of rows and calculate the average missed_time from the jobs table where the user_id matches the user_input parameter, the estimated_duration exceeds the min_duration parameter, and the missed_time is not NULL. The results of this query are stored in the total_missed and avg_missed_time variables. The function then evaluates a conditional statement: if total_missed is greater than zero, it constructs a string in the analysis_result variable indicating the number of deadlines missed by the user and the average time by which they were missed. If no deadlines were missed, it assigns a message to analysis_result stating that no missed deadlines were found for the user. Finally, the function returns the analysis_result string.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_missed_deadlines(user_input BIGINT, min_duration REAL)\nRETURNS TEXT\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_missed INTEGER;\n    avg_missed_time REAL;\n    analysis_result TEXT;\nBEGIN\n    SELECT COUNT(*), AVG(missed_time) INTO total_missed, avg_missed_time\n    FROM jobs\n    WHERE user_id = user_input AND estimated_duration > min_duration AND missed_time IS NOT NULL;\n    \n    IF total_missed > 0 THEN\n        analysis_result := 'User ' || user_input || ' missed ' || total_missed || ' deadlines with average miss time: ' || avg_missed_time;\n    ELSE\n        analysis_result := 'No missed deadlines found for user ' || user_input;\n    END IF;\n    \n    RETURN analysis_result;\nEND;\n$$;",
    "database_name": "job_scheduling_and_resource_management",
    "tables": [
      "jobs",
      "job_types",
      "urgency_levels"
    ],
    "call_sqls": [
      "SELECT analyze_missed_deadlines(1, 5.0);",
      "SELECT analyze_missed_deadlines(2, 10.0);",
      "SELECT analyze_missed_deadlines(3, 15.0);",
      "SELECT analyze_missed_deadlines(4, 20.0);",
      "SELECT analyze_missed_deadlines(5, 25.0);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named analyze_missed_deadlines that, for a given user_id and a specified minimum duration, analyzes the user's jobs from the jobs table where the estimated_duration exceeds the minimum duration and missed_time is not null. It returns a text message stating the total count of missed deadlines and the average missed_time if any are found; otherwise, it returns a message indicating no missed deadlines were found for that user.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called analyze_missed_deadlines that takes a user identifier and a minimum duration threshold, examines the user's records in the jobs table where the estimated_duration exceeds the threshold and missed_time is not null, counts all such missed deadlines and calculates the average missed time, then returns a message stating the total count and average if any are found, or a message indicating no missed deadlines meeting the criteria were identified for the user if none exist.",
    "id": 32,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `analyze_missed_deadlines` that accepts two input parameters: `p_user_id` of type `BIGINT`, representing the unique identifier of a user, and `p_min_duration_threshold` of type `REAL`, representing the minimum estimated duration threshold. The function returns a value of type `TEXT`, which is a formatted message summarizing the analysis results.\n\nWithin the function, declare the following local variables: `v_missed_count` of type `BIGINT`, initialized to `0`, to store the total count of missed deadlines meeting the criteria; `v_avg_missed_time` of type `REAL`, initialized to `NULL`, to store the calculated average missed time; and `v_result_message` of type `TEXT`, to hold the final output message.\n\nThe core logic begins with a `SELECT` statement that performs an aggregation query on the `jobs` table. The query selects two aggregated values: the count of rows and the average of the `missed_time` column. It filters rows where the `user_id` column matches the input parameter `p_user_id`, the `estimated_duration` column is greater than the input parameter `p_min_duration_threshold`, and the `missed_time` column is not `NULL`. The results of this query are stored directly into the variables `v_missed_count` and `v_avg_missed_time` using an `INTO` clause.\n\nFollowing the query, a conditional `IF` statement checks if the value of `v_missed_count` is greater than `0`. If the condition evaluates to `TRUE`, indicating that at least one missed deadline record was found, the function constructs the `v_result_message` by concatenating the literal string `'Total missed deadlines: '` with the value of `v_missed_count` cast to `TEXT`, then the literal string `', Average missed time: '` with the value of `v_avg_missed_time` cast to `TEXT`. If the condition evaluates to `FALSE`, meaning `v_missed_count` is `0`, the function sets `v_result_message` to the literal string `'No missed deadlines meeting the criteria were identified for the user.'`.\n\nFinally, the function returns the value of the `v_result_message` variable.",
    "original_summary": "Create a PLpgSQL function named analyze_missed_deadlines that accepts a user_id (BIGINT) and a minimum duration (REAL). It counts the total missed deadlines and calculates the average missed time for that user's jobs where the estimated duration exceeds the minimum and missed_time is not null. Return a text message stating the count and average if any are found, otherwise return a message stating no missed deadlines were found.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Develop a PLpgSQL function called analyze_missed_deadlines which takes a user identifier of type BIGINT and a minimum duration threshold of type REAL as its parameters. This function should meticulously examine the user's job records, specifically targeting those where the estimated job duration surpasses the provided minimum and where the missed_time field contains a non-null value. It must then perform a comprehensive count of all such missed deadlines and compute the precise average of the missed time durations. Finally, the function should craft a detailed textual response: if any qualifying missed deadlines are discovered, it must return a message clearly stating the total count and the calculated average missed time; conversely, if no such records are found, it must return a distinct message explicitly indicating that no missed deadlines meeting the criteria were identified for the specified user."
  },
  {
    "ir": "Write a PLpgSQL function named get_latest_model_version that accepts a single input parameter p_model_id of type bigint, which represents the unique identifier for a model, and returns a value of type text; the function's logic is to query the model_versions table, specifically selecting the version_number column from rows where the model_id column matches the provided p_model_id parameter, then ordering all matching rows in descending order based on the version_date column to place the most recent date first, and finally applying a limit of 1 to retrieve only the topmost row, thereby returning the version_number text value associated with the most recent version_date for the specified model.",
    "plsql": "CREATE OR REPLACE FUNCTION get_latest_model_version(p_model_id bigint)\nRETURNS text AS $$\nBEGIN\n    RETURN (\n        SELECT mv.version_number\n        FROM model_versions mv\n        WHERE mv.model_id = p_model_id\n        ORDER BY mv.version_date DESC\n        LIMIT 1\n    );\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "machine_learning_model_performance_metrics_310382",
    "tables": [
      "models",
      "model_versions",
      "evaluations",
      "users"
    ],
    "call_sqls": [
      "SELECT get_latest_model_version(1);",
      "SELECT get_latest_model_version(0);",
      "SELECT get_latest_model_version(10);",
      "SELECT get_latest_model_version((SELECT model_id FROM models WHERE model_name = 'Model A'));",
      "SELECT get_latest_model_version((SELECT model_id FROM models LIMIT 1));"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_latest_model_version that, given a model_id, retrieves and returns the most recent version_number from the model_versions table for that specific model_id, based on the latest version_date.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_latest_model_version that, for a given model ID, returns the most recent version number from the model_versions table based on the version_date.",
    "id": 33,
    "generated_ir": "Write a PLpgSQL function named get_latest_model_version that accepts a single input parameter p_model_id of type bigint, which represents the unique identifier for a model, and returns a value of type text; the function's logic is to query the model_versions table, specifically selecting the version_number column from rows where the model_id column matches the provided p_model_id parameter, then ordering all matching rows in descending order based on the version_date column to place the most recent date first, and finally applying a limit of 1 to retrieve only the topmost row, thereby returning the version_number text value associated with the most recent version_date for the specified model.",
    "original_summary": "Create a function named get_latest_model_version that takes a bigint model_id and returns text. It queries the model_versions table for the version_number where model_id matches, orders the results by version_date in descending order, and returns the first (most recent) version_number.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the most recent version number for a given model ID, based on the version date in the model_versions table?"
  },
  {
    "ir": "Write a PLpgSQL function named get_patients_with_family_history that accepts two input parameters: a bigint parameter named p_family_history representing a value to match against the family history of diabetes, and a text parameter named p_smoking_status representing a smoking status string to match. The function returns a single bigint value. The function declares a local bigint variable named v_count. The function's logic executes a SELECT statement that queries the patients table, performing a COUNT(*) aggregation to calculate the total number of rows. The count is filtered using a WHERE clause with two conditions joined by a logical AND operator. The first condition checks if the family_history_diabetes column in the patients table is exactly equal to the input parameter p_family_history. The second condition compares the processed smoking_status column from the patients table to the processed input parameter p_smoking_status: for both sides, the TRIM function is applied to remove any leading or trailing whitespace characters, and then the LOWER function is applied to convert the resulting string to all lowercase letters, ensuring a case-insensitive and whitespace-insensitive comparison for equality. The result of the COUNT(*) aggregation is stored into the local variable v_count using the INTO clause. Finally, the function returns the value stored in the v_count variable, which represents the total number of patient records that have both the specified family history of diabetes value and the specified smoking status.",
    "plsql": "CREATE OR REPLACE FUNCTION get_patients_with_family_history(p_family_history bigint, p_smoking_status text)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_count bigint;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM patients\n    WHERE family_history_diabetes = p_family_history AND LOWER(TRIM(smoking_status)) = LOWER(TRIM(p_smoking_status));\n    RETURN v_count;\nEND;\n$$;",
    "database_name": "healthcare_data_management_and_diabetes_risk_assessment",
    "tables": [
      "diabetes_risk_scores",
      "patients"
    ],
    "call_sqls": [
      "SELECT get_patients_with_family_history(1, 'former');",
      "SELECT get_patients_with_family_history(0, 'never');",
      "SELECT get_patients_with_family_history(1, 'current');",
      "SELECT get_patients_with_family_history(0, 'former');",
      "SELECT get_patients_with_family_history(1, 'never');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_patients_with_family_history that counts patients from the patients table where the family_history_diabetes matches the provided family history value and the smoking_status, after trimming whitespace and converting to lowercase, matches the provided smoking status value, and returns the total count as a big integer.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_patients_with_family_history that returns the total number of patients from the patients table as a bigint, based on two criteria: it must count only those patients where the family_history_diabetes column equals the provided p_family_history parameter and where the smoking_status column, after trimming spaces and converting to lowercase, matches the similarly processed p_smoking_status parameter.",
    "id": 34,
    "generated_ir": "Write a PLpgSQL function named get_patients_with_family_history that accepts two input parameters: a bigint parameter named p_family_history representing a value to match against the family history of diabetes, and a text parameter named p_smoking_status representing a smoking status string to match. The function returns a single bigint value. The function declares a local bigint variable named v_count. The function's logic executes a SELECT statement that queries the patients table, performing a COUNT(*) aggregation to calculate the total number of rows. The count is filtered using a WHERE clause with two conditions joined by a logical AND operator. The first condition checks if the family_history_diabetes column in the patients table is exactly equal to the input parameter p_family_history. The second condition compares the processed smoking_status column from the patients table to the processed input parameter p_smoking_status: for both sides, the TRIM function is applied to remove any leading or trailing whitespace characters, and then the LOWER function is applied to convert the resulting string to all lowercase letters, ensuring a case-insensitive and whitespace-insensitive comparison for equality. The result of the COUNT(*) aggregation is stored into the local variable v_count using the INTO clause. Finally, the function returns the value stored in the v_count variable, which represents the total number of patient records that have both the specified family history of diabetes value and the specified smoking status.",
    "original_summary": "Create a function named get_patients_with_family_history that returns a bigint. It accepts a bigint parameter p_family_history and a text parameter p_smoking_status. The function counts patients from the patients table where family_history_diabetes equals p_family_history and the trimmed, lowercased smoking_status matches the processed p_smoking_status. Return the count.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Construct a function called get_patients_with_family_history, which is designed to yield a bigint value. This function requires two specific parameters: a bigint parameter named p_family_history and a text parameter designated as p_smoking_status. Its primary purpose is to meticulously calculate and return the total number of patients listed within the patients table. This count is derived by carefully filtering records where the family_history_diabetes column precisely matches the provided p_family_history parameter, and simultaneously, where the smoking_status fieldafter being thoroughly trimmed of any extraneous spaces and converted entirely to lowercaseexactly corresponds to the similarly processed and lowercased p_smoking_status input."
  },
  {
    "ir": "Write a PLpgSQL function that returns a table with columns vaccine_name of type text and total_doses of type bigint. This function, named get_vaccine_distribution, does not take any input parameters. It executes a SQL query that selects data from two tables: vaccines and vaccinations. The function performs an inner join operation between these tables on the condition that the vaccine_name column from the vaccines table matches the vaccine_type column from the vaccinations table. For each unique vaccine_name, it calculates the sum of the dose_number column from the vaccinations table, casting the result to a bigint type. The query groups the results by the vaccine_name column, ensuring that the sum is calculated separately for each distinct vaccine. The function then returns the result set, which consists of each vaccine_name and the corresponding total_doses, representing the total number of doses administered for each vaccine type.",
    "plsql": "CREATE OR REPLACE FUNCTION get_vaccine_distribution()\nRETURNS TABLE(vaccine_name text, total_doses bigint) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT v.vaccine_name, SUM(vac.dose_number)::bigint\n    FROM vaccines v\n    JOIN vaccinations vac ON v.vaccine_name = vac.vaccine_type\n    GROUP BY v.vaccine_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "covid_19_case_management_and_tracking",
    "tables": [
      "cases",
      "districts",
      "states",
      "health_resources",
      "vaccinations",
      "vaccines"
    ],
    "call_sqls": [
      "SELECT * FROM get_vaccine_distribution();",
      "SELECT vaccine_name, total_doses FROM get_vaccine_distribution();",
      "SELECT * FROM get_vaccine_distribution() WHERE vaccine_name = 'Pfizer';",
      "SELECT vaccine_name FROM get_vaccine_distribution() ORDER BY total_doses DESC;",
      "SELECT SUM(total_doses) AS grand_total_doses FROM get_vaccine_distribution();"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_vaccine_distribution that returns a table with vaccine_name and total_doses, calculating the total number of doses distributed for each vaccine by summing the dose_number from the vaccinations table for matching vaccine_type, grouped by vaccine_name from the vaccines table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_vaccine_distribution that returns the vaccine_name from the vaccines table and the total_doses calculated by summing the dose_number from the vaccinations table for each vaccine, joining the vaccines and vaccinations tables on vaccine_name and vaccine_type, and grouping the results by vaccine_name.",
    "id": 35,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_vaccine_distribution that returns a table with two columns: vaccine_name of type text and total_doses of type bigint. The function begins by executing a SELECT statement that performs an INNER JOIN between the vaccines table and the vaccinations table on the condition that the vaccine_name column from the vaccines table matches the vaccine_type column from the vaccinations table. From these joined tables, it selects the vaccine_name column from the vaccines table and calculates the total_doses by summing the dose_number column from the vaccinations table for each distinct vaccine_name. The results are grouped by the vaccine_name column from the vaccines table. The function concludes by returning the result set of this query, which includes each vaccine name along with the corresponding total sum of doses administered.",
    "original_summary": "Create a function named get_vaccine_distribution that returns a table with columns vaccine_name (text) and total_doses (bigint). It performs an inner join between the vaccines and vaccinations tables on vaccine_name and vaccine_type, groups by vaccine_name, and sums the dose_number for each vaccine.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Function get_vaccine_distribution returns vaccine_name and total_doses. Join vaccines and vaccinations on vaccine_name and vaccine_type, group by vaccine_name, sum dose_number."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_order_discount that accepts a single input parameter p_order_id of type bigint, which represents the unique identifier for an order record, and returns a numeric value representing a calculated discount amount. The function begins by declaring a local variable v_quantity of type bigint to store the quantity value retrieved from the database. It then executes a SELECT statement to query the orders table, specifically retrieving the value from the quantity column for the row where the order_id column matches the provided input parameter p_order_id, and assigns this retrieved value into the local variable v_quantity. Following this data retrieval, the function evaluates a conditional IF statement to check if the value stored in v_quantity is greater than or equal to 10. If this condition is true, the function performs a multiplication operation, calculating the product of v_quantity and 0.15, and returns this resulting numeric value as the function's output. If the condition in the IF statement evaluates to false, meaning v_quantity is less than 10, the function bypasses the conditional block and proceeds to return the numeric constant 0 as the function's output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_order_discount(p_order_id bigint)\nRETURNS numeric AS $$\nDECLARE\n    v_quantity bigint;\nBEGIN\n    SELECT quantity INTO v_quantity FROM orders WHERE order_id = p_order_id;\n    IF v_quantity >= 10 THEN\n        RETURN v_quantity * 0.15;\n    END IF;\n    RETURN 0;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "apparel_size_measurement_and_conversion",
    "tables": [
      "customers",
      "orders",
      "products",
      "returns"
    ],
    "call_sqls": [
      "SELECT calculate_order_discount(1);",
      "SELECT calculate_order_discount(2);",
      "SELECT calculate_order_discount(3);",
      "SELECT calculate_order_discount(4);",
      "SELECT calculate_order_discount(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_order_discount that, given an order_id, returns a numeric discount by retrieving the quantity from the ORDERS table for that order; if the quantity is 10 or more, the discount is calculated as the quantity multiplied by 0.15, otherwise the discount is 0.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named calculate_order_discount that, given an order ID, retrieves the quantity from the ORDERS table for that order and returns a discount amount: if the quantity is 10 or more, calculate the discount as 15% of the quantity; otherwise, return no discount (zero).",
    "id": 36,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_order_discount that accepts a single input parameter p_order_id of type bigint, which represents the unique identifier for an order record, and returns a numeric value representing a calculated discount amount. The function begins by declaring a local variable v_quantity of type bigint to store the quantity value retrieved from the database. It then executes a SELECT statement to query the orders table, specifically retrieving the value from the quantity column for the row where the order_id column matches the provided input parameter p_order_id, and assigns this retrieved value into the local variable v_quantity. Following this data retrieval, the function evaluates a conditional IF statement to check if the value stored in v_quantity is greater than or equal to 10. If this condition is true, the function performs a multiplication operation, calculating the product of v_quantity and 0.15, and returns this resulting numeric value as the function's output. If the condition in the IF statement evaluates to false, meaning v_quantity is less than 10, the function bypasses the conditional block and proceeds to return the numeric constant 0 as the function's output.",
    "original_summary": "Create a function named calculate_order_discount that takes an order_id (bigint) and returns a numeric discount. Retrieve the order quantity. If the quantity is 10 or more, return quantity multiplied by 0.15. Otherwise, return 0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Function calculate_order_discount(order_id bigint) returns numeric. Get order quantity. If quantity >= 10, return quantity * 0.15, else return 0."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_cosine_of_inventory that accepts a single parameter p_product_id of type bigint, which represents the unique identifier of a product. The function begins by declaring two local variables: v_total_quantity of type bigint, which will store the total quantity of the specified product, and v_cosine_value of type real, which will store the cosine of the total quantity. The function executes a SELECT statement to calculate the sum of the quantity column from the product_inventories table, where the product_id column matches the input parameter p_product_id. If no rows are found, the COALESCE function ensures that v_total_quantity is set to 0. The result of this aggregation is stored in the v_total_quantity variable. Next, the function calculates the cosine of v_total_quantity by converting it to a numeric type and applying the cos function, storing the result in v_cosine_value. Finally, the function returns the value of v_cosine_value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_cosine_of_inventory(p_product_id bigint)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total_quantity bigint;\n    v_cosine_value real;\nBEGIN\n    SELECT COALESCE(SUM(quantity), 0) INTO v_total_quantity\n    FROM product_inventories\n    WHERE product_id = p_product_id;\n\n    v_cosine_value := cos(v_total_quantity::numeric);\n    RETURN v_cosine_value;\nEND;\n$$;",
    "database_name": "e_commerce_product_management_and_cataloging_604967",
    "tables": [
      "orders",
      "order_items",
      "products",
      "product_inventories",
      "warehouses",
      "shipments",
      "logistics_providers",
      "addresses"
    ],
    "call_sqls": [
      "SELECT calculate_cosine_of_inventory(1001);",
      "SELECT calculate_cosine_of_inventory(1002);",
      "SELECT calculate_cosine_of_inventory(1003);",
      "SELECT calculate_cosine_of_inventory(1004);",
      "SELECT calculate_cosine_of_inventory(1005);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_cosine_of_inventory that, for a given product ID, retrieves the total inventory quantity from the product_inventories table, sums the quantity values for that product (treating missing entries as zero), calculates the cosine of that total sum, and returns the cosine value.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_cosine_of_inventory that, given a product ID, calculates the total inventory quantity from the product_inventories table for that product and returns the cosine of that total quantity.",
    "id": 37,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_cosine_of_inventory that accepts one input parameter named product_id of type bigint, which represents the unique identifier for a product, and returns a value of type real; this function declares a local bigint variable named total_quantity and a local real variable named cosine_result, then executes a SELECT statement that queries the product_inventories table, specifically targeting the quantity column, and applies the SUM aggregate function to calculate the total sum of all quantity values found in rows where the product_id column matches the provided product_id parameter, storing this aggregated total into the total_quantity variable; if no matching rows are found, the total_quantity will be NULL, which is handled implicitly. Subsequently, the function computes the cosine of the total_quantity value using the COS mathematical function, which operates on a numeric input (the total_quantity is implicitly cast to numeric for the calculation), and stores the resulting cosine value into the cosine_result variable. Finally, the function returns the value of cosine_result as the function's output.",
    "original_summary": "Create a function named calculate_cosine_of_inventory that takes a product ID, calculates its total inventory quantity, and returns the cosine of that total.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the command to create a function called 'calculate_cosine_of_inventory' that accepts a product ID, computes the total inventory quantity for it, and then returns the cosine of that total?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_measurement_guideline_description` that accepts a single input parameter. This parameter is named `p_guideline_id` and is of the `bigint` data type; its purpose is to uniquely identify a specific measurement guideline. The function is designed to return a single value of type `text`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `description` column. The data is sourced from the table named `measurement_guidelines`. The selection of the specific row from the `measurement_guidelines` table is determined by a `WHERE` clause. This `WHERE` clause specifies a condition where the value in the `guideline_id` column of the `measurement_guidelines` table must be equal to the value provided by the input parameter `p_guideline_id`. The single `description` value retrieved by this `SELECT` statement is then returned as the result of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_measurement_guideline_description(p_guideline_id bigint)\nRETURNS text AS $$\nBEGIN\n    RETURN (\n        SELECT description\n        FROM measurement_guidelines\n        WHERE guideline_id = p_guideline_id\n    );\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "fashion_size_chart_and_measurement_standards",
    "tables": [
      "countries",
      "measurement_guidelines",
      "measurements",
      "product_lines",
      "regions",
      "size_charts",
      "size_issues"
    ],
    "call_sqls": [
      "SELECT get_measurement_guideline_description(0);",
      "SELECT get_measurement_guideline_description(1);",
      "SELECT get_measurement_guideline_description(999);",
      "SELECT get_measurement_guideline_description((SELECT guideline_id FROM measurement_guidelines WHERE description = 'Measure bust at the fullest po...' LIMIT 1));",
      "SELECT get_measurement_guideline_description((SELECT guideline_id FROM measurement_guidelines ORDER BY created_at DESC LIMIT 1));"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_measurement_guideline_description that, given a specific guideline_id, retrieves and returns the corresponding description from the measurement_guidelines table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_measurement_guideline_description that, given a specific guideline_id, retrieves and returns the corresponding description from the measurement_guidelines table.",
    "id": 38,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_measurement_guideline_description` that accepts a single input parameter. This parameter is named `p_guideline_id` and is of the `bigint` data type; its purpose is to uniquely identify a specific measurement guideline. The function is designed to return a single value of type `text`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `description` column. The data is sourced from the table named `measurement_guidelines`. The selection of the specific row from the `measurement_guidelines` table is determined by a `WHERE` clause. This `WHERE` clause specifies a condition where the value in the `guideline_id` column of the `measurement_guidelines` table must be equal to the value provided by the input parameter `p_guideline_id`. The single `description` value retrieved by this `SELECT` statement is then returned as the result of the function.",
    "original_summary": "Create a function named get_measurement_guideline_description that takes a bigint guideline_id and returns text. It retrieves and returns the description from the measurement_guidelines table where the guideline_id matches the input.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the description for the measurement guideline with a specific guideline_id, and how can I retrieve it using a function called get_measurement_guideline_description?"
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_user_department that accepts a single input parameter p_user_id of type bigint, which represents the unique identifier for a user, and returns a value of type text. The function declares a local variable department_name of type text to store the result. The function's logic executes a SELECT query on the users table, specifically retrieving the value from the department column for the single row where the user_id column exactly matches the provided input parameter p_user_id, and assigns the retrieved value into the local variable department_name. The function then concludes by returning the value stored in the department_name variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_department(p_user_id bigint)\nRETURNS text AS $$\nDECLARE\n    department_name text;\nBEGIN\n    SELECT department INTO department_name\n    FROM users\n    WHERE user_id = p_user_id;\n    \n    RETURN department_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "demographic_and_employment_data_analysis_192071",
    "tables": [
      "access_logs",
      "individuals",
      "users"
    ],
    "call_sqls": [
      "SELECT get_user_department(0);",
      "SELECT get_user_department(1);",
      "SELECT get_user_department(2);",
      "SELECT get_user_department(100);",
      "SELECT get_user_department(999);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_user_department that, given a user ID, retrieves and returns the corresponding department from the users table.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called get_user_department? It should take a user's ID and spit back which department they're in as text by looking up the info in the users table.",
    "id": 39,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named get_user_department that accepts a single input parameter p_user_id of type bigint, which represents the unique identifier for a user, and returns a value of type text. The function declares a local variable department_name of type text to store the result. The function's logic executes a SELECT query on the users table, specifically retrieving the value from the department column for the single row where the user_id column exactly matches the provided input parameter p_user_id, and assigns the retrieved value into the local variable department_name. The function then concludes by returning the value stored in the department_name variable.",
    "original_summary": "Create a function named get_user_department that takes a user ID (bigint) and returns the user's department (text) by querying the users table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a function called get_user_department? It should take a user's ID (as a bigint) and spit back which department they're in (as text). Just have it look up the info in the users table."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_average_income_by_occupation that accepts a single input parameter named occupation_input of type text and returns a table with a single column named average_income of type numeric; the function's purpose is to compute the arithmetic mean of income values for a specific occupation by first declaring three local variables: total_income and count_records as bigint types initialized to zero, and record as a record type variable to hold rows from a cursor; the function then opens a FOR loop that iterates over each row returned by a SELECT query on the demographic_data table (aliased as dd), where the query specifically retrieves the income column value from rows where the occupation column exactly matches the provided occupation_input parameter; for each fetched row stored in the record variable, the function attempts to add the income value to a running total and increment a counter within a BEGIN block that includes an EXCEPTION handler for the invalid_text_representation error; inside the block, it converts the record.income value to numeric, applies the floor function to it to round down to the nearest integer, adds the result to the total_income variable, and increments the count_records variable by one; if the conversion of record.income to numeric fails because the string contains non-numeric characters (such as '>50K'), the EXCEPTION handler catches the invalid_text_representation error and executes a CONTINUE statement, which skips the current loop iteration and proceeds to the next row without adding to the total or count; after the loop completes, the function checks if the count_records variable is greater than zero; if true, it executes a RETURN QUERY statement that selects the result of casting total_income to numeric and dividing it by count_records, thereby returning the calculated average income; if false (meaning no valid records were processed), it executes a RETURN QUERY statement that selects the numeric value zero as the average_income.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_income_by_occupation(occupation_input text) RETURNS TABLE(average_income numeric) AS $$\nDECLARE\n    total_income bigint := 0;\n    count_records bigint := 0;\n    record RECORD; -- Declare record variable\nBEGIN\n    FOR record IN\n        SELECT dd.income\n        FROM demographic_data dd\n        WHERE dd.occupation = occupation_input\n    LOOP\n        -- Assuming income can be cast to numeric. If it contains non-numeric strings like \">50K\", this will fail.\n        -- For this exercise, we assume it's a numeric string.\n        BEGIN\n            total_income := total_income + floor(record.income::numeric);\n            count_records := count_records + 1;\n        EXCEPTION\n            WHEN invalid_text_representation THEN\n                -- Handle cases where income is not a valid number (e.g., '>50K')\n                -- For this problem, we'll just skip such records or log an error.\n                -- For simplicity, we'll skip.\n                CONTINUE;\n        END;\n    END LOOP;\n\n    IF count_records > 0 THEN\n        RETURN QUERY SELECT total_income::numeric / count_records;\n    ELSE\n        RETURN QUERY SELECT 0::numeric;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "demographic_and_socioeconomic_data_analysis_317338",
    "tables": [
      "demographic_data",
      "data_sources",
      "metadata",
      "education_levels",
      "occupations"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_average_income_by_occupation('Exec-managerial');",
      "SELECT * FROM calculate_average_income_by_occupation('Prof-specialty');",
      "SELECT * FROM calculate_average_income_by_occupation('Craft-repair');",
      "SELECT * FROM calculate_average_income_by_occupation('Other-service');",
      "SELECT * FROM calculate_average_income_by_occupation('Sales');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_average_income_by_occupation that takes an occupation as input and returns the average income as a numeric value by retrieving all income values from the demographic_data table for that occupation, summing only the valid numeric income values after flooring them while skipping any non-numeric entries like '>50K', and then calculating the average if records exist; otherwise, it returns 0.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_average_income_by_occupation that accepts an occupation as text and returns the average income as a number. The function should retrieve all income values from the demographic_data table for the specified occupation, sum the valid numeric incomes after flooring them, ignore non-numeric entries like '>50K', and then compute and return the average. If no matching records are found, return 0.",
    "id": 40,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_average_income_by_occupation that accepts one input parameter: p_occupation, which is of type TEXT and represents the occupation to filter by. The function returns a value of type NUMERIC, representing the calculated average income.\n\nThe function begins by declaring two local variables: total_income of type NUMERIC, initialized to 0, and record_count of type INTEGER, initialized to 0. It also declares a loop variable rec of type RECORD to iterate over query results.\n\nThe function then executes a FOR loop, iterating over each row returned by a SELECT query on the demographic_data table. The query selects the income column for all rows where the occupation column exactly matches the input parameter p_occupation.\n\nInside the loop, for each record, the function attempts to convert the income value from TEXT to NUMERIC using a CAST operation. This conversion is wrapped in a BEGIN...EXCEPTION block to handle invalid numeric formats gracefully. If the CAST succeeds and the resulting numeric value is not NULL, the function proceeds: it applies the FLOOR function to this numeric income value to round it down to the nearest integer, adds this floored value to the total_income variable, and increments the record_count variable by 1. If the CAST fails (for example, if the income value is a string like '>50K' that cannot be converted to a number) or if the converted value is NULL, the EXCEPTION block catches the error and does nothing, effectively ignoring that record.\n\nAfter the loop completes, the function checks if the record_count variable is greater than 0. If it is, the function returns the average income calculated as total_income divided by record_count. If record_count is 0 (meaning no valid numeric income records were found for the specified occupation), the function returns 0.",
    "original_summary": "Create a function named calculate_average_income_by_occupation that takes an occupation as text input and returns the average income as a numeric value. It sums valid numeric income values (flooring them) for the specified occupation, skipping non-numeric entries like '>50K'. It returns the average if records exist, otherwise returns 0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function called calculate_average_income_by_occupation that accepts an occupation as text and outputs the average income as a number. The function should sum the valid numeric income values (after flooring them) for the given occupation, ignore non-numeric entries such as '>50K', and then return the calculated average. If no records are found, return 0."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_size_chart_by_product_line` that accepts a single input parameter, `p_product_line_id`, which is of type `bigint`. This function is designed to return a set of records, effectively acting as a table, with each record containing two columns: `chart_id` of type `bigint` and `size_label` of type `text`. The core operation of this function involves executing a `SELECT` statement to retrieve specific data. Specifically, it selects the `chart_id` column and the `size_label` column from the table named `size_charts`. The selection of rows from the `size_charts` table is filtered by a `WHERE` clause, which specifies that only those rows where the value in the `product_line_id` column of the `size_charts` table is equal to the value provided in the `p_product_line_id` input parameter should be included in the result set. The `RETURN QUERY` statement then returns the entire result set generated by this `SELECT` query as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_size_chart_by_product_line(p_product_line_id bigint)\nRETURNS TABLE(chart_id bigint, size_label text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT sc.chart_id, sc.size_label\n    FROM size_charts sc\n    WHERE sc.product_line_id = p_product_line_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "fashion_size_chart_and_measurement_standards",
    "tables": [
      "countries",
      "measurement_guidelines",
      "measurements",
      "product_lines",
      "regions",
      "size_charts",
      "size_issues"
    ],
    "call_sqls": [
      "SELECT * FROM get_size_chart_by_product_line(0);",
      "SELECT * FROM get_size_chart_by_product_line(1);",
      "SELECT * FROM get_size_chart_by_product_line(100);",
      "SELECT * FROM get_size_chart_by_product_line((SELECT line_id FROM product_lines WHERE line_name = 'Women''s Apparel'));",
      "SELECT * FROM get_size_chart_by_product_line((SELECT line_id FROM product_lines WHERE line_name = 'Men''s Apparel'));"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_size_chart_by_product_line that, given a product_line_id, retrieves and returns all corresponding chart_id and size_label values from the size_charts table where the product_line_id matches the provided input.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_size_chart_by_product_line that, given a product_line_id, retrieves and returns all size chart records from the size_charts table where the product_line_id matches the provided input, with each record including the chart_id and size_label.",
    "id": 41,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_size_chart_by_product_line` that accepts a single input parameter, `product_line_id`, which is of type `BIGINT`. This function is designed to return a set of records from the `size_charts` table, specifically the `chart_id` and `size_label` columns, for all size chart entries associated with the given product line. The function's return type is a table with two columns: `chart_id` of type `BIGINT` and `size_label` of type `TEXT`.\n\nThe function executes a SQL query that selects the `chart_id` and `size_label` columns from the `size_charts` table. It filters the results by applying a condition where the `product_line_id` column in the `size_charts` table must exactly match the input parameter `product_line_id` provided to the function. This ensures that only size chart records linked to the specified product line are retrieved. The query returns all matching rows, and the function yields each row as part of its result set. No additional transformations, calculations, or joins are performed; the function simply returns the raw data from the specified columns based on the filter condition.",
    "original_summary": "Create a function named get_size_chart_by_product_line that takes a bigint product_line_id and returns a table of bigint chart_id and text size_label. It returns all rows from the size_charts table where the product_line_id matches the input.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Please construct a function designated as 'get_size_chart_by_product_line'. This function should accept a single parameter of type bigint, specifically a product_line_id. Its purpose is to return a result set comprising two columns: chart_id (bigint) and size_label (text). The function logic must retrieve and return all records from the 'size_charts' table for which the product_line_id column corresponds to the provided input argument."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_price_deviation that accepts a single parameter p_instrument_id of type BIGINT, which represents the identifier of a financial instrument. The function performs two SELECT operations on the market_data table. First, it calculates the average of the close_price column for all rows where the instrument_id matches the provided p_instrument_id, storing the result in a local variable v_avg_price of type REAL. Second, it retrieves the most recent close_price value for the same instrument_id, determined by ordering the rows in descending order based on trade_date and trade_time, and stores this value in another local variable v_current_price of type REAL. The function then checks if either v_avg_price or v_current_price is NULL, and if so, it returns NULL. If both values are non-null, it calculates the absolute difference between v_current_price and v_avg_price, rounds this difference to two decimal places, and returns the result as a REAL type.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_price_deviation(p_instrument_id BIGINT) RETURNS REAL AS $$\nDECLARE\n    v_avg_price REAL;\n    v_current_price REAL;\nBEGIN\n    SELECT AVG(close_price) INTO v_avg_price FROM market_data WHERE instrument_id = p_instrument_id;\n    SELECT close_price INTO v_current_price FROM market_data WHERE instrument_id = p_instrument_id ORDER BY trade_date DESC, trade_time DESC LIMIT 1;\n    \n    IF v_avg_price IS NULL OR v_current_price IS NULL THEN\n        RETURN NULL;\n    END IF;\n    \n    RETURN (ROUND(ABS(v_current_price - v_avg_price)::numeric, 2))::real;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "financial_market_data_analysis_404480",
    "tables": [
      "alerts",
      "instruments",
      "market_data"
    ],
    "call_sqls": [
      "SELECT calculate_price_deviation(0);",
      "SELECT calculate_price_deviation(1);",
      "SELECT calculate_price_deviation(100);",
      "SELECT calculate_price_deviation(NULL);",
      "SELECT calculate_price_deviation(2);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_price_deviation that takes an instrument_id and returns the absolute difference, rounded to two decimals, between the most recent close price and the average close price from the market_data table for that instrument, returning NULL if either value is not available.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_price_deviation that accepts an instrument_id and determines the average closing price from the market_data table and the most recent closing price for that instrument. If both values exist, return the absolute difference between them rounded to two decimal places; otherwise, return nothing.",
    "id": 42,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_price_deviation that accepts a single input parameter p_instrument_id of type bigint and returns a numeric value with two decimal places, which declares two local variables: v_avg_close_price of type numeric and v_recent_close_price of type numeric. The function first executes a SELECT query on the market_data table to calculate the average of the close_price column for all rows where the instrument_id column matches the input parameter p_instrument_id, and stores the result in v_avg_close_price. Then, it executes another SELECT query on the market_data table to retrieve the most recent closing price for the same instrument by selecting the close_price column from the row where instrument_id equals p_instrument_id, ordering the results by the trade_date column in descending order and the trade_time column in descending order to ensure the latest timestamp is first, and limiting the result to one row, storing the value in v_recent_close_price. After obtaining both values, the function checks if both v_avg_close_price and v_recent_close_price are not null using an IF condition. If both are not null, it calculates the absolute difference between v_recent_close_price and v_avg_close_price using the ABS function, rounds the result to two decimal places using the ROUND function, and returns this numeric value. If either v_avg_close_price or v_recent_close_price is null, the function returns null. The function operates within the financial_market_data_analysis_404480 database and interacts with the market_data table, specifically using the instrument_id, close_price, trade_date, and trade_time columns.",
    "original_summary": "Create a PLpgSQL function named calculate_price_deviation that takes an instrument_id (BIGINT). It calculates the average close price and the most recent close price for the instrument. If both values are not NULL, it returns the absolute difference between them, rounded to two decimals. Otherwise, it returns NULL.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PLpgSQL function called calculate_price_deviation that accepts an instrument_id. It figures out the typical closing price and the latest closing figure for that instrument. If both of those numbers are available, give back the absolute gap between them, kind of rounded to a couple of decimal places. If not, just return nothing."
  },
  {
    "ir": "Write a PLpgSQL function named get_user_role that accepts a single input parameter p_user_id of type bigint and returns a value of type text, where the function first declares a local variable user_role of type text, then checks if the provided p_user_id parameter is not null, and if this condition is true, executes a SELECT statement to query the user_management table, specifically retrieving the value from the role column and assigning it into the local variable user_role, but only for the row where the user_id column exactly matches the provided p_user_id parameter value, whereas if the p_user_id parameter is null, the function instead assigns the literal string 'unknown' to the user_role variable, and finally, the function returns the value contained in the user_role variable as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_role(p_user_id bigint)\nRETURNS text AS $$\nDECLARE\n    user_role text;\nBEGIN\n    IF p_user_id IS NOT NULL THEN\n        SELECT role INTO user_role FROM user_management WHERE user_id = p_user_id;\n    ELSE\n        user_role := 'unknown';\n    END IF;\n    RETURN user_role;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_purchase_and_discount_tracking",
    "tables": [
      "customers",
      "discounts",
      "order_items",
      "orders",
      "products",
      "user_management"
    ],
    "call_sqls": [
      "SELECT get_user_role(0);",
      "SELECT get_user_role(1);",
      "SELECT get_user_role(2);",
      "SELECT get_user_role(3);",
      "SELECT get_user_role(4);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_user_role that returns a text value representing a user's role from the user_management table for a specified user_id; if the provided user_id is null or does not exist in the table, the function should return the string 'unknown'.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called get_user_role? It should spit out a user's role (as text) from the user_management table when you give it a user_id. If the user_id is null or there's no user with that ID in user_management, just have it say 'unknown'.",
    "id": 43,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_user_role that accepts a single input parameter user_id_input of type bigint, which represents the identifier of the user whose role is to be retrieved. The function returns a text value representing the user's role. The function first checks if the input parameter user_id_input is NULL. If it is NULL, the function immediately returns the text 'unknown'. If user_id_input is not NULL, the function queries the user_management table to retrieve the role column for the row where the user_id column matches the provided user_id_input. This is done using a SELECT INTO statement that stores the retrieved role value into a local variable, say v_role, of type text. If a matching user is found, the function returns the value stored in v_role. If no matching user is found (i.e., the SELECT statement returns no rows), the function handles this by catching the NO_DATA_FOUND exception and returns the text 'unknown'. The function is designed to operate within the customer_purchase_and_discount_tracking database and interacts solely with the user_management table, specifically the user_id and role columns.",
    "original_summary": "Create a PL/pgSQL function named get_user_role that returns a user's role (text) for a given user_id. If the user_id is null or not found, return the string 'unknown'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/pgSQL function called get_user_role? It should spit out a user's role (as text) when you give it a user_id. If the user_id is null or there's no user with that ID, just have it say 'unknown'."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named classify_land_use that takes a single input parameter p_land_use_id of type bigint, which is used to identify a specific record in the land_use table, and returns a text value. The function begins by declaring four local variables v_is_residential, v_is_commercial, v_is_industrial, and v_is_mixed_use, all of type bigint, to hold column values from the database, and a variable v_result of type text to store the final classification. It executes a SELECT statement that retrieves the is_residential, is_commercial, is_industrial, and is_mixed_use columns from the land_use table for the row where the land_use_id column exactly matches the provided p_land_use_id parameter, storing these retrieved values into the corresponding local variables. The function then uses a conditional IF-ELSIF-ELSE block to determine the classification: if the retrieved v_is_mixed_use value equals 1, the v_result is set to the text 'Mixed Use'; otherwise, if v_is_residential equals 1 and v_is_commercial equals 0, v_result is set to 'Residential'; otherwise, if v_is_commercial equals 1 and v_is_residential equals 0, v_result is set to 'Commercial'; if none of these conditions are met, v_result is set to 'Other'. The function concludes by returning the value stored in v_result.",
    "plsql": "CREATE OR REPLACE FUNCTION classify_land_use(p_land_use_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_is_residential bigint;\n    v_is_commercial bigint;\n    v_is_industrial bigint;\n    v_is_mixed_use bigint;\n    v_result text;\nBEGIN\n    SELECT is_residential, is_commercial, is_industrial, is_mixed_use INTO v_is_residential, v_is_commercial, v_is_industrial, v_is_mixed_use FROM land_use WHERE land_use_id = p_land_use_id;\n    \n    IF v_is_mixed_use = 1 THEN\n        v_result := 'Mixed Use';\n    ELSIF v_is_residential = 1 AND v_is_commercial = 0 THEN\n        v_result := 'Residential';\n    ELSIF v_is_commercial = 1 AND v_is_residential = 0 THEN\n        v_result := 'Commercial';\n    ELSE\n        v_result := 'Other';\n    END IF;\n    \n    RETURN v_result;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "real_estate_market_analysis_and_prediction_465379",
    "tables": [
      "education",
      "highway_access",
      "land_use",
      "locations",
      "property_types",
      "taxation",
      "zoning"
    ],
    "call_sqls": [
      "SELECT classify_land_use(0);",
      "SELECT classify_land_use(1);",
      "SELECT classify_land_use(2);",
      "SELECT classify_land_use(3);",
      "SELECT classify_land_use(4);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named classify_land_use that takes a land use ID as input and returns a text classification based on the land_use table. For the given ID, retrieve the is_residential, is_commercial, is_industrial, and is_mixed_use columns, then return 'Mixed Use' if is_mixed_use is 1, 'Residential' if only is_residential is 1, 'Commercial' if only is_commercial is 1, and 'Other' for any other combination.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named classify_land_use that, given a land use ID, returns a text label indicating its classification by checking the land_use table for that ID's is_residential, is_commercial, is_industrial, and is_mixed_use flags. If the is_mixed_use flag is set to 1, return 'Mixed Use'; if only the is_residential flag is 1 and is_commercial is 0, return 'Residential'; if only the is_commercial flag is 1 and is_residential is 0, return 'Commercial'; and in all other cases, return 'Other'.",
    "id": 44,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named classify_land_use that accepts a single input parameter p_land_use_id of type bigint, which represents the unique identifier of a land use record, and returns a text value indicating the classification of the specified land use. The function performs a SELECT query on the land_use table to retrieve the is_residential, is_commercial, is_industrial, and is_mixed_use column values for the row where the land_use_id column matches the input p_land_use_id. Based on these retrieved flag values, the function uses conditional logic to determine the classification label. Specifically, it checks if the is_mixed_use flag equals 1; if true, it returns the string 'Mixed Use'. If the is_mixed_use flag is not 1, it then checks if the is_residential flag equals 1 and the is_commercial flag equals 0; if true, it returns the string 'Residential'. If that condition is false, it checks if the is_commercial flag equals 1 and the is_residential flag equals 0; if true, it returns the string 'Commercial'. If none of the preceding conditions are met, meaning the flags do not match any of the specified patterns (e.g., both is_residential and is_commercial are 1, or both are 0, or is_industrial is 1, or other combinations), the function returns the string 'Other'. The function does not declare any local variables; it directly returns the result of the conditional evaluation based on the retrieved flag values.",
    "original_summary": "Create a PL/pgSQL function named classify_land_use that takes a bigint parameter p_land_use_id and returns text. Fetch the is_residential, is_commercial, is_industrial, and is_mixed_use columns for the given ID from the land_use table. Return 'Mixed Use' if is_mixed_use is 1, 'Residential' if only is_residential is 1, 'Commercial' if only is_commercial is 1, otherwise return 'Other'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Given a land use ID, how can I determine its classification? I need a function that takes a land use ID and returns a text label. It should check the land_use table for that ID's residential, commercial, industrial, and mixed-use flags. What should it return if the mixed-use flag is set? What should it return if only the residential flag is set? What about if only the commercial flag is set? And what should it return in all other cases?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named check_return_eligibility that accepts a single input parameter p_order_id of type bigint, which represents the unique identifier of an order, and returns a boolean value indicating eligibility; the function begins by declaring a local text variable v_order_date to store a date value, then executes a SELECT query to retrieve the order_date column from the orders table specifically for the row where the order_id column matches the provided p_order_id parameter, storing the result into v_order_date; subsequently, it uses a conditional IF statement to evaluate whether the year component extracted from the v_order_date valueafter an explicit cast to the date data type using the ::date operatoris equal to the year component extracted from the current system date provided by the CURRENT_DATE function; if this condition is true, the function returns the boolean value true, and if the condition is false, the function proceeds to the next statement which returns the boolean value false.",
    "plsql": "CREATE OR REPLACE FUNCTION check_return_eligibility(p_order_id bigint)\nRETURNS boolean AS $$\nDECLARE\n    v_order_date text;\nBEGIN\n    SELECT order_date INTO v_order_date FROM orders WHERE order_id = p_order_id;\n    IF EXTRACT(YEAR FROM v_order_date::date) = EXTRACT(YEAR FROM CURRENT_DATE) THEN\n        RETURN true;\n    END IF;\n    RETURN false;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "apparel_size_measurement_and_conversion",
    "tables": [
      "customers",
      "orders",
      "products",
      "returns"
    ],
    "call_sqls": [
      "SELECT check_return_eligibility(1001);",
      "SELECT check_return_eligibility(2045);",
      "SELECT check_return_eligibility(order_id) FROM orders WHERE order_status = 'delivered' LIMIT 1;",
      "SELECT check_return_eligibility(789) AS is_eligible;",
      "SELECT order_id, check_return_eligibility(order_id) FROM orders WHERE customer_id = 500 LIMIT 3;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named check_return_eligibility that determines if an order is eligible for return based on its order date, returning true if the order's year matches the current year and false otherwise, using the order_id to retrieve the order_date from the ORDERS table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called check_return_eligibility that takes an order_id and returns a boolean indicating whether the order is eligible for return, specifically by checking if the order_date from the ORDERS table matches the current year.",
    "id": 45,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named check_return_eligibility that accepts a single input parameter p_order_id of type bigint, which represents the unique identifier of an order, and returns a boolean value indicating eligibility; the function begins by declaring a local text variable v_order_date to store a date value, then executes a SELECT query to retrieve the order_date column from the orders table specifically for the row where the order_id column matches the provided p_order_id parameter, storing the result into v_order_date; subsequently, it uses a conditional IF statement to evaluate whether the year component extracted from the v_order_date valueafter an explicit cast to the date data type using the ::date operatoris equal to the year component extracted from the current system date provided by the CURRENT_DATE function; if this condition is true, the function returns the boolean value true, and if the condition is false, the function proceeds to the next statement which returns the boolean value false.",
    "original_summary": "Create a function named check_return_eligibility that takes an order_id (bigint) and returns a boolean. Retrieve the order's date. Return true if the order's year matches the current year, otherwise return false.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "How can I create a function called check_return_eligibility that accepts an order_id as a bigint and returns a boolean, where it retrieves the order's date and returns true if the order's year is the same as the current year, otherwise returning false?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_recent_access_logs` that accepts a single input parameter, `p_user_id`, which is of data type `bigint`. This function is designed to return a set of records, effectively acting as a table-like result. The structure of the returned table consists of three columns: `access_date` of type `text`, `access_type` of type `text`, and `ip_address` of type `text`. The core operation of this function is to execute a `SELECT` statement. This `SELECT` statement retrieves data from a table named `access_logs`, which is aliased as `al` for brevity within the query. Specifically, it selects the `access_date` column, the `access_type` column, and the `ip_address` column from the `access_logs` table. The selection of rows is filtered by a `WHERE` clause, which specifies that only those records where the `user_id` column in the `access_logs` table (`al.user_id`) is equal to the value provided by the input parameter `p_user_id` should be considered. The retrieved rows are then sorted in descending order based on the `created_at` column of the `access_logs` table (`al.created_at`), meaning the most recently created access logs will appear first. Finally, the query applies a `LIMIT 10` clause, which restricts the output to only the top 10 rows after sorting. The `RETURN QUERY` statement then returns the result set of this `SELECT` query as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_recent_access_logs(p_user_id bigint)\nRETURNS TABLE(access_date text, access_type text, ip_address text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT al.access_date, al.access_type, al.ip_address\n    FROM access_logs al\n    WHERE al.user_id = p_user_id\n    ORDER BY al.created_at DESC\n    LIMIT 10;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "global_health_and_economic_statistics",
    "tables": [
      "countries",
      "diseases",
      "economic_indicators",
      "education",
      "health_indicators",
      "healthcare_expenditure",
      "access_logs"
    ],
    "call_sqls": [
      "SELECT * FROM get_recent_access_logs(0);",
      "SELECT * FROM get_recent_access_logs(1);",
      "SELECT * FROM get_recent_access_logs(100);",
      "SELECT * FROM get_recent_access_logs(5);",
      "SELECT * FROM get_recent_access_logs(999);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_recent_access_logs that, for a given user ID, retrieves the 10 most recent access logs from the ACCESS_LOGS table, returning the ACCESS_DATE, ACCESS_TYPE, and IP_ADDRESS for each log, ordered from newest to oldest based on CREATED_AT.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_recent_access_logs that takes a user ID as input and returns a table with the columns access_date, access_type, and ip_address as text, retrieving the ten most recent access entries for that user from the access_logs table, ordered from newest to oldest based on created_at.",
    "id": 46,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_recent_access_logs` that accepts a single input parameter, `p_user_id`, which is of data type `bigint`. This function is designed to return a set of records, effectively acting as a table-like result. The structure of the returned table consists of three columns: `access_date` of type `text`, `access_type` of type `text`, and `ip_address` of type `text`. The core operation of this function is to execute a `SELECT` statement. This `SELECT` statement retrieves data from a table named `access_logs`, which is aliased as `al` for brevity within the query. Specifically, it selects the `access_date` column, the `access_type` column, and the `ip_address` column from the `access_logs` table. The selection of rows is filtered by a `WHERE` clause, which specifies that only those records where the `user_id` column in the `access_logs` table (`al.user_id`) is equal to the value provided by the input parameter `p_user_id` should be considered. The retrieved rows are then sorted in descending order based on the `created_at` column of the `access_logs` table (`al.created_at`), meaning the most recently created access logs will appear first. Finally, the query applies a `LIMIT 10` clause, which restricts the output to only the top 10 rows after sorting. The `RETURN QUERY` statement then returns the result set of this `SELECT` query as the output of the function.",
    "original_summary": "Create a function named get_recent_access_logs that accepts a bigint parameter p_user_id and returns a table with columns access_date (text), access_type (text), and ip_address (text). The function should return the 10 most recent access logs for the given user_id, ordered by created_at descending.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Create a function called get_recent_access_logs that takes a bigint parameter for a user and gives back a table. The columns should be access_date, access_type, and ip_address, all as text. It should fetch a handful of the latest access entries for that user, focusing on the more recent ones that seem important, and order them so the newest ones appear first."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_range_type` that accepts a single input parameter named `price_range` of data type `numrange`. This function is designed to determine and return a textual description of whether the lower bound of the provided numeric range is inclusive or exclusive. The function's execution begins by evaluating a conditional expression. Specifically, it calls the built-in PostgreSQL function `lower_inc()` on the `price_range` parameter. The `lower_inc()` function checks if the lower bound of the `numrange` value is inclusive (i.e., includes the lower boundary value). If the `lower_inc()` function returns `TRUE`, indicating that the lower bound of the `price_range` is inclusive, the function will return the string literal 'Inclusive'. Conversely, if `lower_inc()` returns `FALSE`, indicating that the lower bound of the `price_range` is exclusive, the function will return the string literal 'Exclusive'. The function's return type is `text`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_range_type(price_range numrange)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN CASE WHEN lower_inc(price_range) THEN 'Inclusive' ELSE 'Exclusive' END;\nEND;\n$$;",
    "database_name": "machine_learning_model_evaluation_and_results_tracking",
    "tables": [],
    "call_sqls": [
      "SELECT get_range_type(numrange(10, 20));",
      "SELECT get_range_type(numrange(0, 100, '(]'));",
      "SELECT get_range_type(numrange(50, 75, '[]'));",
      "SELECT get_range_type(numrange(25.5, 30.5, '()'));",
      "SELECT get_range_type(numrange(NULL, 50));"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_range_type that takes a numrange parameter representing a price range and returns a text value indicating whether the lower bound of the range is inclusive or exclusive, returning 'Inclusive' if it is inclusive and 'Exclusive' if it is not.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_range_type that takes a numrange parameter named price_range and returns a text value indicating whether the range is 'Inclusive' if the lower bound is inclusive or 'Exclusive' otherwise.",
    "id": 47,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_range_type that accepts a single input parameter price_range of type numrange (a numeric range type) and returns a single text value. The function determines whether the lower bound of the input range is inclusive or exclusive. It uses the built-in PostgreSQL range function lower_inc to check if the lower bound is inclusive: if lower_inc(price_range) returns true, the function returns the string 'Inclusive'; otherwise, it returns the string 'Exclusive'. The function performs no database table operations, as it solely relies on the input parameter and built-in range functions to compute the result.",
    "original_summary": "Create a PL/pgSQL function named get_range_type that takes a numrange parameter and returns text. The function returns 'Inclusive' if lower_inc() on the parameter returns true, otherwise returns 'Exclusive'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "How can I create a PL/pgSQL function called get_range_type that accepts a numrange parameter and outputs text, such that it returns 'Inclusive' when lower_inc() on the parameter is true and 'Exclusive' otherwise?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_location_name_by_id` that accepts a single input parameter named `loc_id` of data type `bigint`. The purpose of this function is to retrieve the `location_name` from the `locations` table based on a provided `location_id`. Inside the function, a local variable named `loc_name` of data type `text` is declared to temporarily store the retrieved location name. The core operation involves executing a `SELECT` statement. This `SELECT` statement queries the `locations` table. It selects the value from the `location_name` column and attempts to store it into the `loc_name` variable. The selection is filtered by a `WHERE` clause, which specifies that the `location_id` column in the `locations` table must be equal to the absolute value of the input parameter `loc_id`. The `abs()` function is used to ensure that even if a negative `loc_id` is passed, it is treated as its positive counterpart for comparison with the `location_id` column. After the `SELECT` statement is executed and the `loc_name` variable is populated, the function returns the value stored in the `loc_name` variable as its output. The return type of the function is `text`.",
    "plsql": "CREATE OR REPLACE FUNCTION get_location_name_by_id(loc_id bigint) RETURNS text AS $$\nDECLARE\n    loc_name text;\nBEGIN\n    SELECT location_name INTO loc_name FROM locations WHERE location_id = abs(loc_id);\n    RETURN loc_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "automobile_sales_and_inventory_management_70043",
    "tables": [
      "locations"
    ],
    "call_sqls": [
      "SELECT get_location_name_by_id(0);",
      "SELECT get_location_name_by_id(1);",
      "SELECT get_location_name_by_id(-1);",
      "SELECT get_location_name_by_id(123);",
      "SELECT get_location_name_by_id(-456);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_location_name_by_id` that retrieves the `location_name` from the `locations` table for a given `loc_id` by finding the row where `location_id` matches the absolute value of the input `loc_id`, and returns that location name as text.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named `get_location_name_by_id` that returns the `location_name` from the `locations` table for a given `location_id`, where the `location_id` is matched to the absolute value of the input `loc_id`.",
    "id": 48,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_location_name_by_id` that accepts a single input parameter named `loc_id` of data type `bigint`. The purpose of this function is to retrieve the `location_name` from the `locations` table based on a provided `location_id`. Inside the function, a local variable named `loc_name` of data type `text` is declared to temporarily store the retrieved location name. The core operation involves executing a `SELECT` statement. This `SELECT` statement queries the `locations` table. It selects the value from the `location_name` column and attempts to store it into the `loc_name` variable. The selection is filtered by a `WHERE` clause, which specifies that the `location_id` column in the `locations` table must be equal to the absolute value of the input parameter `loc_id`. The `abs()` function is used to ensure that even if a negative `loc_id` is passed, it is treated as its positive counterpart for comparison with the `location_id` column. After the `SELECT` statement is executed and the `loc_name` variable is populated, the function returns the value stored in the `loc_name` variable as its output. The return type of the function is `text`.",
    "original_summary": "Create a PL/pgSQL function named `get_location_name_by_id` that returns a text value. It takes a `loc_id` (bigint) as input, selects the `location_name` from the `locations` table where `location_id` equals the absolute value of `loc_id`, and returns the result.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function `get_location_name_by_id` returning text. Input: bigint `loc_id`. Return `location_name` from `locations` where `location_id` = ABS(`loc_id`)."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter input_team_id of type bigint, and returns a bigint representing the total number of wins for the team specified by input_team_id. The function performs a SELECT operation on the game_outcomes table, specifically counting the number of rows where the winner_id column matches the input_team_id parameter. The function uses a subquery within the RETURN statement to execute the COUNT(*) aggregate function, which calculates the total number of occurrences where the condition winner_id = input_team_id is true, thereby determining the total wins for the specified team.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_total_wins(input_team_id bigint) RETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM game_outcomes WHERE winner_id = input_team_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "sports_data_analysis_and_statistics",
    "tables": [
      "games",
      "game_outcomes",
      "teams",
      "leagues"
    ],
    "call_sqls": [
      "SELECT get_team_total_wins(1);",
      "SELECT get_team_total_wins(42);",
      "SELECT get_team_total_wins(100);",
      "SELECT get_team_total_wins(team_id) FROM teams WHERE team_name = 'Lakers';",
      "SELECT team_id, team_name, get_team_total_wins(team_id) AS total_wins FROM teams ORDER BY total_wins DESC;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_team_total_wins that takes a team ID and returns the total number of wins for that team by counting all rows in the game_outcomes table where the winner_id matches the provided team ID.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_team_total_wins that, given a specific team ID, calculates the total number of wins for that team by counting how many records in the game_outcomes table have that team as the winner_id.",
    "id": 49,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_team_total_wins that accepts a single input parameter p_team_id of type bigint, which is used to identify a specific team in the teams table, and returns a value of type bigint representing the total count of wins. The function begins by declaring a local variable v_total_wins of type bigint. It then executes a SELECT statement with a COUNT aggregation on the game_outcomes table. The COUNT function counts all rows where the winner_id column matches the provided p_team_id parameter. This count result is stored directly into the variable v_total_wins. Finally, the function returns the value stored in the v_total_wins variable.",
    "original_summary": "Create a PL/pgSQL function that takes a team ID and returns the total number of wins for that team by counting rows in the game_outcomes table where winner_id matches the input.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the total number of wins for a specific team, based on its ID, by counting the relevant records in the game_outcomes table?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `count_papers_by_author` that accepts one input parameter, `p_author_id`, which is of type `BIGINT`. This function is designed to return an `INTEGER` value. Upon execution, the function declares a local variable named `paper_count` of type `INTEGER`. The core operation involves performing a `SELECT` statement to `COUNT(*)` the total number of rows in the `papers` table. The result of this count is then assigned to the `paper_count` variable. This counting operation is subject to a `WHERE` clause condition: `papers.author_id = p_author_id`. This condition filters the rows in the `papers` table, ensuring that only those rows where the value in the `author_id` column matches the value provided in the `p_author_id` input parameter are included in the count. Finally, the function returns the calculated `paper_count` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION count_papers_by_author(p_author_id BIGINT) RETURNS INTEGER AS $$\nDECLARE\n    paper_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO paper_count FROM papers WHERE papers.author_id = p_author_id;\n    RETURN paper_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "academic_research_and_publication_management_450452",
    "tables": [
      "authors",
      "citations",
      "paper_authors",
      "paper_files",
      "papers",
      "reviews",
      "tracks"
    ],
    "call_sqls": [
      "SELECT count_papers_by_author(1);",
      "SELECT count_papers_by_author(2);",
      "SELECT count_papers_by_author(3);",
      "SELECT count_papers_by_author(4);",
      "SELECT count_papers_by_author(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named count_papers_by_author that, given an author ID, returns the total number of papers in the papers table where the author_id matches the provided ID.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called count_papers_by_author that, given an author's unique identifier, returns the total number of records in the papers table where the author_id matches the provided identifier.",
    "id": 50,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named count_papers_by_author that accepts a single input parameter named author_id of type bigint, which corresponds to the unique identifier of an author. The function returns a single value of type bigint, representing the total count of papers associated with the given author. The function operates within the academic_research_and_publication_management_450452 database.\n\nThe function declares no local variables. Its core logic consists of executing a single SQL SELECT query that performs a COUNT operation. Specifically, the query counts all rows from the papers table where the author_id column in the papers table exactly matches the input parameter author_id provided to the function. This COUNT operation yields the total number of paper records linked to that specific author. The function then returns this computed count as its result.",
    "original_summary": "Create a function named count_papers_by_author that takes an author ID (BIGINT) and returns an INTEGER. The function should count and return the number of rows in the papers table where the author_id matches the input parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Develop a function called count_papers_by_author, which is designed to accept a single input parameter of type BIGINT representing an author's unique identifier. This function should meticulously calculate and then return, as an INTEGER, the precise total count of all records existing within the papers table where the author_id column corresponds exactly to the provided author ID parameter."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_total_inventory that accepts a single mandatory input parameter p_product_id of type bigint, which is used to identify a specific product, and returns a single bigint value representing the computed total inventory quantity; within the function's execution block, it declares a local variable total_quantity of type bigint to hold the result, then performs a SELECT query on the product_inventories table to calculate the sum of all values in the quantity column for rows where the product_id column exactly matches the provided input parameter p_product_id, using the COALESCE function to convert any NULL result from the SUM aggregation, which occurs when no matching rows are found, into the integer 0, and stores this computed value into the total_quantity variable, and finally returns the value stored in the total_quantity variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_inventory(p_product_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    total_quantity bigint;\nBEGIN\n    SELECT COALESCE(SUM(quantity), 0) INTO total_quantity\n    FROM product_inventories\n    WHERE product_id = p_product_id;\n    \n    RETURN total_quantity;\nEND;\n$$;",
    "database_name": "e_commerce_product_management_and_cataloging_604967",
    "tables": [
      "orders",
      "order_items",
      "products",
      "product_inventories",
      "warehouses",
      "shipments",
      "logistics_providers",
      "addresses"
    ],
    "call_sqls": [
      "SELECT calculate_total_inventory(1);",
      "SELECT calculate_total_inventory(2);",
      "SELECT calculate_total_inventory(3);",
      "SELECT calculate_total_inventory(4);",
      "SELECT calculate_total_inventory(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_total_inventory that, given a product ID, returns the total inventory quantity for that product from the product_inventories table, returning 0 if no inventory is found.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called calculate_total_inventory? It should take a product ID, add up all the stock we've got for that item from the product_inventories table, and spit out the total. If there's nothing in the warehouse for it, just give us a zero.",
    "id": 51,
    "generated_ir": "Write a PLpgSQL function named calculate_total_inventory that accepts a single mandatory input parameter p_product_id of type bigint, which is used to identify a specific product, and returns a single bigint value representing the computed total inventory quantity; within the function's execution block, it declares a local variable total_quantity of type bigint to hold the result, then performs a SELECT query on the product_inventories table to calculate the sum of all values in the quantity column for rows where the product_id column exactly matches the provided input parameter p_product_id, using the COALESCE function to convert any NULL result from the SUM aggregation, which occurs when no matching rows are found, into the integer 0, and stores this computed value into the total_quantity variable, and finally returns the value stored in the total_quantity variable as the function's result.",
    "original_summary": "Create a function named calculate_total_inventory that takes a product ID and returns the total sum of its inventory quantity, returning 0 if no inventory is found.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a function called calculate_total_inventory? It should take a product ID, add up all the stock we've got for that item, and spit out the total. If there's nothing in the warehouse for it, just give us a zero."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named analyze_project_health that takes a single BIGINT input parameter named project_id_input and returns a table with three columns: metric_name of type TEXT, metric_value of type REAL, and health_status of type TEXT; the function begins by declaring three local variables: avg_accuracy as REAL, total_issues as INTEGER, and budget_usage as REAL; the function then performs three separate SELECT queries: the first query calculates the average validation_accuracy from the model_versions table by joining the models table on model_id where the project_id from the models table equals the provided project_id_input, using the COALESCE function to return 0 if the average is NULL, and stores the result in avg_accuracy; the second query counts the total number of unresolved issues by joining the models table to model_versions on model_id, then joining model_issues on version_id, where the project_id from models equals project_id_input and the status column in model_issues is not equal to the string 'RESOLVED', using COALESCE to return 0 if the count is NULL, and stores the result in total_issues; the third query computes a budget usage metric by summing a calculated value for each model version, where the calculation is model_size_mb multiplied by 0.5 plus training_time_minutes multiplied by 0.1, from the model_versions table joined with models on model_id where the project_id equals project_id_input, using COALESCE to return 0 if the sum is NULL, and stores the result in budget_usage; the function then uses an IF-ELSIF-ELSE conditional block to determine a health_status string based on the calculated variables: if avg_accuracy is greater than 0.85 and total_issues is less than 5, health_status is set to 'HEALTHY'; otherwise, if avg_accuracy is less than 0.7 or total_issues is greater than 20, health_status is set to 'CRITICAL'; otherwise, if budget_usage is greater than 1000, health_status is set to 'OVER_BUDGET'; if none of the previous conditions are met, health_status is set to 'WARNING'; finally, the function returns three rows of result data using RETURN QUERY: the first row has metric_name 'AVG_ACCURACY', metric_value avg_accuracy, and the determined health_status; the second row has metric_name 'OPEN_ISSUES', metric_value total_issues cast to REAL, and the same health_status; the third row has metric_name 'BUDGET_USAGE', metric_value budget_usage, and the same health_status.",
    "plsql": "CREATE OR REPLACE FUNCTION analyze_project_health(project_id_input BIGINT) RETURNS TABLE(metric_name TEXT, metric_value REAL, health_status TEXT) AS $$\nDECLARE\n    avg_accuracy REAL;\n    total_issues INTEGER;\n    budget_usage REAL;\nBEGIN\n    SELECT COALESCE(AVG(mv.validation_accuracy), 0) INTO avg_accuracy FROM models m JOIN model_versions mv ON m.model_id = mv.model_id WHERE m.project_id = project_id_input;\n    SELECT COALESCE(COUNT(*), 0) INTO total_issues FROM models m JOIN model_versions mv ON m.model_id = mv.model_id JOIN model_issues mi ON mv.version_id = mi.version_id WHERE m.project_id = project_id_input AND mi.status != 'RESOLVED';\n    SELECT COALESCE(SUM(mv.model_size_mb * 0.5 + mv.training_time_minutes * 0.1), 0) INTO budget_usage FROM models m JOIN model_versions mv ON m.model_id = mv.model_id WHERE m.project_id = project_id_input;\n    IF avg_accuracy > 0.85 AND total_issues < 5 THEN\n        health_status := 'HEALTHY';\n    ELSIF avg_accuracy < 0.7 OR total_issues > 20 THEN\n        health_status := 'CRITICAL';\n    ELSIF budget_usage > 1000 THEN\n        health_status := 'OVER_BUDGET';\n    ELSE\n        health_status := 'WARNING';\n    END IF;\n    RETURN QUERY SELECT 'AVG_ACCURACY'::TEXT, avg_accuracy, health_status;\n    RETURN QUERY SELECT 'OPEN_ISSUES'::TEXT, total_issues::REAL, health_status;\n    RETURN QUERY SELECT 'BUDGET_USAGE'::TEXT, budget_usage, health_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "machine_learning_model_performance_metrics_404685",
    "tables": [
      "model_contributions",
      "model_issues",
      "model_versions",
      "models",
      "performance_metrics",
      "users",
      "projects"
    ],
    "call_sqls": [
      "SELECT * FROM analyze_project_health(1);",
      "SELECT * FROM analyze_project_health(2);",
      "SELECT * FROM analyze_project_health(3);",
      "SELECT * FROM analyze_project_health(4);",
      "SELECT * FROM analyze_project_health(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named analyze_project_health that, for a given project ID, retrieves the average model accuracy from the models and model_versions tables, counts unresolved issues from the models, model_versions, and model_issues tables, and calculates a budget usage metric based on model size and training time. It then determines a single health status: 'HEALTHY' if accuracy is greater than 0.85 and issues are fewer than 5, 'CRITICAL' if accuracy is below 0.7 or issues exceed 20, 'OVER_BUDGET' if budget usage is over 1000, otherwise 'WARNING'. The function returns a table with rows for each metric (AVG_ACCURACY, OPEN_ISSUES, BUDGET_USAGE) showing its value and the overall health status.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named analyze_project_health that, for a given project ID, calculates the overall average accuracy of its models from the models and model_versions tables, counts the total unresolved issues from the models, model_versions, and model_issues tables, and computes a budget usage metric based on model size and training time. Then, determine a health status: assign 'HEALTHY' if the average accuracy is above 0.85 and open issues are fewer than 5, 'CRITICAL' if the accuracy is below 0.7 or open issues exceed 20, 'OVER_BUDGET' if the budget usage exceeds 1000, otherwise set it to 'WARNING'. Return a list with each calculated metricaverage accuracy, open issues count, and budget usagealongside the final health status.",
    "id": 52,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `analyze_project_health` that takes a single input parameter `project_id_param` of type `bigint` and returns a table with four columns: `average_accuracy` of type `real`, `open_issues_count` of type `bigint`, `budget_usage` of type `real`, and `health_status` of type `text`. The function calculates three key metrics for the specified project and determines a health status based on those metrics.\n\nThe function begins by declaring four local variables: `avg_accuracy` of type `real` to store the overall average validation accuracy of the project's models, `open_issues` of type `bigint` to store the total count of unresolved issues for the project, `budget_metric` of type `real` to store the computed budget usage metric, and `status` of type `text` to store the final health status.\n\nThe first operation calculates the `avg_accuracy`. It performs a `SELECT` statement that uses the `AVG()` aggregate function on the `validation_accuracy` column from the `model_versions` table. This query involves an inner join between the `models` table (aliased as `m`) and the `model_versions` table (aliased as `mv`) on the condition `m.model_id = mv.model_id`. A `WHERE` clause filters the results to only include rows where `m.project_id` equals the input parameter `project_id_param`. The result of this average calculation is stored into the `avg_accuracy` variable. If no matching rows are found, `avg_accuracy` is set to `NULL`.\n\nThe second operation calculates the `open_issues`. It performs a `SELECT` statement that uses the `COUNT(*)` aggregate function to count rows from the `model_issues` table (aliased as `mi`). This query involves a series of inner joins: first, joining `model_issues` to `model_versions` (aliased as `mv`) on `mi.version_id = mv.version_id`; second, joining `model_versions` to `models` (aliased as `m`) on `mv.model_id = m.model_id`. A `WHERE` clause applies two conditions: `m.project_id` must equal the input parameter `project_id_param`, and `mi.status` must not equal the string `'RESOLVED'` (to count only unresolved issues). The resulting count is stored into the `open_issues` variable. If no matching rows are found, `open_issues` is set to `0`.\n\nThe third operation calculates the `budget_metric`. It performs a `SELECT` statement that uses the `SUM()` aggregate function on an expression: for each model version, it multiplies the `model_size_mb` column (a `real` value) by the `training_time_minutes` column (a `bigint` value). This calculation is performed on rows from the `model_versions` table (aliased as `mv`). The query involves an inner join with the `models` table (aliased as `m`) on `mv.model_id = m.model_id`. A `WHERE` clause filters the results to only include rows where `m.project_id` equals the input parameter `project_id_param`. The sum of these products is stored into the `budget_metric` variable. If no matching rows are found, `budget_metric` is set to `0`.\n\nAfter calculating the three metrics, the function determines the `health_status` using a series of conditional checks. First, it checks if `avg_accuracy` is greater than `0.85` and `open_issues` is less than `5`. If both conditions are true, `status` is set to the string `'HEALTHY'`. If not, it checks if `avg_accuracy` is less than `0.7` or `open_issues` is greater than `20`. If either condition is true, `status` is set to the string `'CRITICAL'`. If neither of the previous sets of conditions is met, it checks if `budget_metric` is greater than `1000`. If true, `status` is set to the string `'OVER_BUDGET'`. If none of the above conditions are satisfied, `status` is set to the string `'WARNING'`.\n\nFinally, the function returns a single-row table containing the four calculated values: `avg_accuracy` as `average_accuracy`, `open_issues` as `open_issues_count`, `budget_metric` as `budget_usage`, and `status` as `health_status`.",
    "original_summary": "Create a function that returns a project's health metrics. Calculate average model accuracy, count of unresolved issues, and a budget usage metric (based on model size and training time). Determine a single health status: 'HEALTHY' if accuracy > 0.85 and issues < 5, 'CRITICAL' if accuracy < 0.7 or issues > 20, 'OVER_BUDGET' if usage > 1000, else 'WARNING'. Return rows for each metric with the status.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function to get a project's overall health. It should figure out the general average accuracy of the models, how many issues are still hanging around, and a rough budget usage number based on model scale and how long training took. Then, decide on one status: call it 'HEALTHY' if the accuracy is pretty high and there aren't many open issues, 'CRITICAL' if the accuracy is too low or there are a lot of problems, 'OVER_BUDGET' if the spending metric is way over, otherwise mark it as 'WARNING'. Give back a list with each of those calculated metrics alongside the final status."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves alerts for a specific instrument by taking a parameter p_instrument_id of type BIGINT, which represents the unique identifier of the instrument. The function returns a table with columns alert_id of type BIGINT, alert_price of type REAL, and alert_type of type TEXT. The function performs a SELECT operation on the alerts table, specifically selecting the alert_id, alert_price, and alert_type columns from rows where the instrument_id column matches the provided p_instrument_id parameter and the is_active column is equal to 1, indicating that the alert is currently active. The function uses the RETURN QUERY statement to return the result set directly from the SELECT operation.",
    "plsql": "CREATE OR REPLACE FUNCTION get_instrument_alerts(p_instrument_id BIGINT) RETURNS TABLE(alert_id BIGINT, alert_price REAL, alert_type TEXT) AS $$\nBEGIN\n    RETURN QUERY SELECT a.alert_id, a.alert_price, a.alert_type FROM alerts a WHERE a.instrument_id = p_instrument_id AND a.is_active = 1;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "financial_market_data_analysis_404480",
    "tables": [
      "alerts",
      "instruments",
      "market_data"
    ],
    "call_sqls": [
      "SELECT * FROM get_instrument_alerts(0);",
      "SELECT * FROM get_instrument_alerts(1);",
      "SELECT * FROM get_instrument_alerts(100);",
      "SELECT * FROM get_instrument_alerts(NULL);",
      "SELECT * FROM get_instrument_alerts(2);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_instrument_alerts that, for a given instrument_id, retrieves and returns all active alerts from the alerts table where is_active equals 1, providing the alert_id, alert_price, and alert_type for each alert.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_instrument_alerts that returns a table with columns alert_id, alert_price, and alert_type for a specific instrument, retrieving only the active alerts where is_active is set to 1 for that instrument.",
    "id": 53,
    "generated_ir": "Write a PLpgSQL function named get_instrument_alerts that returns a table with three columns: alert_id of type bigint, alert_price of type real, and alert_type of type text. The function takes one input parameter, p_instrument_id of type bigint, which specifies the instrument for which to retrieve alerts. The function begins by declaring no local variables, as it directly returns a query result. It executes a SELECT statement that retrieves data from the alerts table. The SELECT statement fetches the alert_id, alert_price, and alert_type columns. The FROM clause specifies the alerts table. The WHERE clause includes two conditions: first, the instrument_id column in the alerts table must equal the input parameter p_instrument_id; second, the is_active column in the alerts table must equal 1, indicating that only active alerts are selected. The function returns the result set of this query as a table with the specified columns, providing all active alerts for the given instrument.",
    "original_summary": "Create a PLpgSQL function that returns a table (alert_id BIGINT, alert_price REAL, alert_type TEXT) for a given instrument_id (BIGINT). The function selects active alerts (is_active = 1) for that instrument.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PLpgSQL function that gives back a table with columns like alert_id, alert_price, and alert_type for a specific instrument. It should pull out the active alerts for that instrument, focusing on the ones that are currently turned on."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named calculate_country_mortality_stats that returns a table with three columns: cause_name of type text, total_deaths of type bigint, and avg_incidence of type real, and accepts three input parameters: p_country_name of type text to specify a country, p_start_year of type bigint to define the beginning of a year range, and p_end_year of type bigint to define the end of a year range; the function's body executes a RETURN QUERY statement that performs a SELECT query joining three tables: the country_cause_of_death_data table (aliased as ccd), the causes_of_death table (aliased as cd) on the condition that ccd.cause_of_death_id equals cd.cause_of_death_id, and the countries table (aliased as c) on the condition that ccd.country_id equals c.country_id; the query filters the joined dataset with a WHERE clause requiring that the country_name column from the countries table matches the input parameter p_country_name and that the year column from the country_cause_of_death_data table is between the input parameters p_start_year and p_end_year inclusive; the filtered rows are then aggregated using a GROUP BY clause on the cause_of_death_name column from the causes_of_death table; for each group, the query calculates the sum of the number_of_deaths column from the country_cause_of_death_data table, casting the result to bigint and aliasing it as total_deaths, and calculates the average of the incidence_rate column from the country_cause_of_death_data table, casting the result to real and aliasing it as avg_incidence; the final result set is ordered in descending order based on the computed sum of the number_of_deaths column for each cause group.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_country_mortality_stats(p_country_name text, p_start_year bigint, p_end_year bigint)\nRETURNS TABLE(cause_name text, total_deaths bigint, avg_incidence real) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT cd.cause_of_death_name AS cause_name,\n         SUM(ccd.number_of_deaths)::bigint AS total_deaths,\n         AVG(ccd.incidence_rate)::real AS avg_incidence\n  FROM country_cause_of_death_data ccd\n  JOIN causes_of_death cd ON ccd.cause_of_death_id = cd.cause_of_death_id\n  JOIN countries c ON ccd.country_id = c.country_id\n  WHERE c.country_name = p_country_name\n    AND ccd.year BETWEEN p_start_year AND p_end_year\n  GROUP BY cd.cause_of_death_name\n  ORDER BY SUM(ccd.number_of_deaths) DESC;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "global_health_statistics_and_trends",
    "tables": [
      "countries",
      "causes_of_death",
      "country_cause_of_death_data",
      "demographics",
      "data_source_links"
    ],
    "call_sqls": [
      "SELECT * FROM calculate_country_mortality_stats('China', 2007, 2008);",
      "SELECT * FROM calculate_country_mortality_stats('United States', 2007, 2008);",
      "SELECT * FROM calculate_country_mortality_stats('China', 2007, 2007);",
      "SELECT * FROM calculate_country_mortality_stats('United States', 2008, 2008);",
      "SELECT * FROM calculate_country_mortality_stats('China', 2008, 2008);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_country_mortality_stats that, given a country_name, start_year, and end_year, retrieves from the countries, country_cause_of_death_data, and causes_of_death tables the aggregated death statistics for that country within the specified year range, grouping by cause_of_death_name to return each cause_name with its total_deaths (sum of number_of_deaths) and avg_incidence (average incidence_rate), ordered by total_deaths descending.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_country_mortality_stats that returns a table with cause_name, total_deaths, and avg_incidence for a specified country between a start year and an end year, grouping the results by cause and ordering them so the highest total deaths appear first.",
    "id": 54,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named calculate_country_mortality_stats that returns a table with three columns: cause_name of type text, total_deaths of type bigint, and avg_incidence of type real, and accepts three input parameters: p_country_name of type text to specify a country, p_start_year of type bigint to define the beginning of a year range, and p_end_year of type bigint to define the end of a year range; the function's body executes a RETURN QUERY statement that performs a SELECT query joining three tables: the country_cause_of_death_data table (aliased as ccd), the causes_of_death table (aliased as cd) on the condition that ccd.cause_of_death_id equals cd.cause_of_death_id, and the countries table (aliased as c) on the condition that ccd.country_id equals c.country_id; the query filters the joined dataset with a WHERE clause requiring that the country_name column from the countries table matches the input parameter p_country_name and that the year column from the country_cause_of_death_data table is between the input parameters p_start_year and p_end_year inclusive; the filtered rows are then aggregated using a GROUP BY clause on the cause_of_death_name column from the causes_of_death table; for each group, the query calculates the sum of the number_of_deaths column from the country_cause_of_death_data table, casting the result to bigint and aliasing it as total_deaths, and calculates the average of the incidence_rate column from the country_cause_of_death_data table, casting the result to real and aliasing it as avg_incidence; the final result set is ordered in descending order based on the computed sum of the number_of_deaths column for each cause group.",
    "original_summary": "Create a function named calculate_country_mortality_stats that returns a table with columns cause_name (text), total_deaths (bigint), and avg_incidence (real). It accepts parameters for country_name, start_year, and end_year. The function returns aggregated death data (sum of deaths and average incidence rate) for the specified country and year range, grouped by cause and ordered by total deaths descending.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Create a function called calculate_country_mortality_stats that gives back a table with cause_name, total_deaths, and avg_incidence. It needs a country name, a start year, and an end year. The function should pull together and return the death info for that country over roughly that period, grouping by cause and sorting so the biggest numbers are on top."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_total_pollutant` that accepts a single input parameter. This parameter, named `p_county_id`, is of the `bigint` data type and is intended to represent a unique identifier for a specific county. The function is designed to return a single value of the `real` data type, which will represent the aggregated total of pollutant measurements. Internally, the function declares a local variable named `v_total` of the `real` data type to temporarily store the calculated sum. The core operation of the function involves executing a `SELECT` statement to retrieve data from the `pollutant_measurements` table. Specifically, it calculates the `SUM` of the `value` column from this table. This summation is performed under a specific condition: only rows where the `county_id` column matches the value provided by the input parameter `p_county_id` are included in the sum. The result of this `SUM` aggregation is then assigned to the local variable `v_total`. Finally, the function returns the value stored in `v_total` as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_pollutant(p_county_id bigint)\nRETURNS real AS $$\nDECLARE\n    v_total real;\nBEGIN\n    SELECT SUM(value) INTO v_total\n    FROM pollutant_measurements\n    WHERE county_id = p_county_id;\n    \n    RETURN v_total;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "air_quality_monitoring_and_environmental_impact_assessment",
    "tables": [
      "pollutant_measurements"
    ],
    "call_sqls": [
      "SELECT calculate_total_pollutant(0);",
      "SELECT calculate_total_pollutant(1);",
      "SELECT calculate_total_pollutant(10);",
      "SELECT calculate_total_pollutant(100);",
      "SELECT calculate_total_pollutant(99999);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `calculate_total_pollutant` that, for a given county ID, returns the total pollutant amount by summing the `value` column from the `pollutant_measurements` table for all rows where the `county_id` matches the provided county ID.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called `calculate_total_pollutant`? It needs to take a county ID and spit back a real number. Basically, it should just add up all the numbers in the `value` column from the `pollutant_measurements` table for that specific county.",
    "id": 55,
    "generated_ir": "Write a PLpgSQL function named calculate_total_pollutant that accepts a single parameter p_county_id of type bigint and returns a value of type real. The function begins by declaring a local variable v_total_pollutant of type real, initialized to zero. It then executes a SELECT query that performs a SUM aggregation on the value column from the pollutant_measurements table, specifically for rows where the county_id column matches the input parameter p_county_id. The result of this aggregation is stored into the variable v_total_pollutant. If no rows match the condition, the SUM function returns NULL, which the function handles by using COALESCE to convert NULL to zero, ensuring the total is always a real number. Finally, the function returns the value contained in v_total_pollutant as the function's result.",
    "original_summary": "Create a PL/pgSQL function named `calculate_total_pollutant` that takes a `bigint` county ID and returns a `real` value. The function should sum the `value` column from the `pollutant_measurements` table for all rows matching the given `county_id`.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/pgSQL function called `calculate_total_pollutant`? It needs to take a county ID (as a `bigint`) and spit back a `real` number. Basically, it should just add up all the numbers in the `value` column from the `pollutant_measurements` table for that specific county."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_tenant_maintenance_summary` that accepts a single input parameter, `p_tenant_id`, which is of type `bigint` and represents the unique identifier for a tenant. This function is designed to return a set of records, effectively acting as a table, with each record containing four columns: `property_id` (of type `bigint`), `pending_requests` (of type `bigint`), `completed_requests` (of type `bigint`), and `last_inspection_date` (of type `text`). The function's primary operation is to query and aggregate data from three tables: `tenants`, `maintenance_requests`, and `property_inspections`.\n\nThe function begins by initiating a `SELECT` statement to retrieve the desired summary information. It selects the `property_id` directly from the `tenants` table. It then calculates `pending_requests` by counting the occurrences where the `resolution_date` column in the `maintenance_requests` table is `NULL`, indicating an unresolved request. This count is explicitly cast to `bigint`. Concurrently, it calculates `completed_requests` by counting the occurrences where the `resolution_date` column in the `maintenance_requests` table is `NOT NULL`, indicating a resolved request. This count is also explicitly cast to `bigint`. Finally, it determines the `last_inspection_date` by finding the maximum value of the `inspection_date` column from the `property_inspections` table.\n\nThese selections are performed by joining the tables. A `LEFT JOIN` is established between the `tenants` table (aliased as `t`) and the `maintenance_requests` table (aliased as `mr`) on the condition that `t.property_id` matches `mr.property_id`. Another `LEFT JOIN` is then established between the `tenants` table (aliased as `t`) and the `property_inspections` table (aliased as `pi`) on the condition that `t.property_id` matches `pi.property_id`.\n\nThe entire query is filtered by a `WHERE` clause, ensuring that only records from the `tenants` table where `t.tenant_id` is equal to the input parameter `p_tenant_id` are considered. After filtering, the results are grouped by `t.property_id` to aggregate the counts and the maximum inspection date for each distinct property associated with the specified tenant. The aggregated results are then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_tenant_maintenance_summary(p_tenant_id bigint)\nRETURNS TABLE(property_id bigint, pending_requests bigint, completed_requests bigint, last_inspection_date text)\nAS $$\nBEGIN\n    RETURN QUERY\n    SELECT t.property_id,\n           COUNT(CASE WHEN mr.resolution_date IS NULL THEN 1 END)::bigint,\n           COUNT(CASE WHEN mr.resolution_date IS NOT NULL THEN 1 END)::bigint,\n           MAX(pi.inspection_date)\n    FROM tenants t\n    LEFT JOIN maintenance_requests mr ON t.property_id = mr.property_id\n    LEFT JOIN property_inspections pi ON t.property_id = pi.property_id\n    WHERE t.tenant_id = p_tenant_id\n    GROUP BY t.property_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "real_estate_property_management_and_analytics_773860",
    "tables": [
      "properties",
      "maintenance_requests",
      "property_inspections",
      "tenants"
    ],
    "call_sqls": [
      "SELECT * FROM get_tenant_maintenance_summary(1);",
      "SELECT * FROM get_tenant_maintenance_summary(5);",
      "SELECT * FROM get_tenant_maintenance_summary(10);",
      "SELECT * FROM get_tenant_maintenance_summary(15);",
      "SELECT * FROM get_tenant_maintenance_summary(20);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_tenant_maintenance_summary` that, for a given tenant identified by `p_tenant_id`, retrieves a summary of maintenance and inspection data per property. It returns a table with columns for `property_id`, the count of `pending_requests` (where `resolution_date` is null), the count of `completed_requests` (where `resolution_date` is not null), and the most recent `last_inspection_date` from the `property_inspections` table, by joining the `tenants`, `maintenance_requests`, and `property_inspections` tables and grouping the results by `property_id`.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `get_tenant_maintenance_summary` that returns a summary table with columns `property_id`, `pending_requests`, `completed_requests`, and `last_inspection_date` for a specified tenant, using the `tenants`, `maintenance_requests`, and `property_inspections` tables, where it aggregates counts of unresolved and resolved maintenance requests and finds the most recent inspection date per property, based on the input parameter `p_tenant_id`.",
    "id": 56,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_tenant_maintenance_summary` that takes a single input parameter `p_tenant_id` of type `bigint`. The function returns a table with four columns: `property_id` (bigint), `pending_requests` (bigint), `completed_requests` (bigint), and `last_inspection_date` (text). The function is designed to generate a maintenance summary for a specified tenant by querying the `tenants`, `maintenance_requests`, and `property_inspections` tables.\n\nFirst, the function retrieves the `property_id` associated with the given `p_tenant_id` from the `tenants` table. This ensures the summary is specific to the tenant's property.\n\nNext, the function aggregates data from the `maintenance_requests` table for that property. It counts the number of pending maintenance requests, defined as those where the `resolution_date` is NULL or an empty string, and stores this count in the `pending_requests` column. It also counts the number of completed maintenance requests, defined as those where the `resolution_date` is NOT NULL and not an empty string, and stores this count in the `completed_requests` column.\n\nSimultaneously, the function queries the `property_inspections` table to find the most recent inspection date for the property. It selects the maximum `inspection_date` where the `property_id` matches, and stores this value in the `last_inspection_date` column. If no inspections exist for the property, `last_inspection_date` is set to NULL.\n\nThe function uses a single SQL query that joins the `tenants` table with the `maintenance_requests` and `property_inspections` tables via left joins on `property_id`. This query groups the results by `tenants.property_id` to aggregate the counts and the maximum inspection date. The `WHERE` clause filters the results to only include rows where `tenants.tenant_id` equals the input `p_tenant_id`.\n\nFinally, the function returns the resulting row as a table with the specified columns, providing a summary of pending and completed maintenance requests along with the last inspection date for the tenant's property.",
    "original_summary": "Create a PostgreSQL function named `get_tenant_maintenance_summary` that returns a table with `property_id`, `pending_requests`, `completed_requests`, and `last_inspection_date` columns. It takes a `bigint` parameter `p_tenant_id`, joins the `tenants`, `maintenance_requests`, and `property_inspections` tables, and aggregates counts and dates for the specified tenant, grouped by property.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Construct a PostgreSQL function called `get_tenant_maintenance_summary` that meticulously returns a comprehensive table, which includes the detailed columns `property_id`, `pending_requests`, `completed_requests`, and the critically important `last_inspection_date`. This function must accept a single `bigint` parameter, specifically named `p_tenant_id`. To achieve its purpose, it must intricately join the `tenants`, `maintenance_requests`, and `property_inspections` tables, and then carefully aggregate the various counts and the most recent dates, all specifically for the designated tenant, and finally group the entire result set neatly by property."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_size_stock` that accepts two input parameters: `p_item_id`, which is of type `bigint` and represents the unique identifier for an item, and `p_size_id`, which is also of type `bigint` and represents the unique identifier for a specific size. This function is designed to return a single value of type `bigint`. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `item_sizes` table. Specifically, it attempts to fetch the value from the `stock` column. The selection criteria for this `SELECT` statement are based on two conditions: the `item_id` column in the `item_sizes` table must be equal to the value provided by the `p_item_id` input parameter, AND the `size_id` column in the `item_sizes` table must be equal to the value provided by the `p_size_id` input parameter. To handle cases where no matching row is found or the `stock` column for a matching row contains a `NULL` value, the `COALESCE` function is applied to the `stock` column. The `COALESCE` function returns the first non-null expression in its argument list; in this context, if the `stock` value is `NULL`, it will return `0` instead. The result of this `SELECT` statement (either the `stock` value or `0`) is then returned as the output of the `get_size_stock` function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_size_stock(p_item_id bigint, p_size_id bigint)\nRETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COALESCE(stock, 0) FROM item_sizes WHERE item_id = p_item_id AND size_id = p_size_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "clothing_size_standardization_and_inventory_management_738508",
    "tables": [
      "clothing_items",
      "customers",
      "item_sizes",
      "order_items",
      "orders",
      "regions",
      "size_equivalents",
      "sizes"
    ],
    "call_sqls": [
      "SELECT get_size_stock(1, 0);",
      "SELECT get_size_stock(1, 1);",
      "SELECT get_size_stock(0, 0);",
      "SELECT get_size_stock(0, 1);",
      "SELECT get_size_stock(999, 999);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_size_stock that, given an item ID and a size ID, retrieves the corresponding stock quantity from the item_sizes table, returning 0 if the stock value is NULL or no matching record exists.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_size_stock that, given an item identifier and a size identifier, returns the stock quantity from the item_sizes table for that specific item and size, ensuring a return of 0 if the stock is NULL or no matching record exists.",
    "id": 57,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_size_stock` that accepts two input parameters: `p_item_id`, which is of type `bigint` and represents the unique identifier for an item, and `p_size_id`, which is also of type `bigint` and represents the unique identifier for a specific size. This function is designed to return a single value of type `bigint`. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `item_sizes` table. Specifically, it attempts to fetch the value from the `stock` column. The selection criteria for this `SELECT` statement are based on two conditions: the `item_id` column in the `item_sizes` table must be equal to the value provided by the `p_item_id` input parameter, AND the `size_id` column in the `item_sizes` table must be equal to the value provided by the `p_size_id` input parameter. To handle cases where no matching row is found or the `stock` column for a matching row contains a `NULL` value, the `COALESCE` function is applied to the `stock` column. The `COALESCE` function returns the first non-null expression in its argument list; in this context, if the `stock` value is `NULL`, it will return `0` instead. The result of this `SELECT` statement (either the `stock` value or `0`) is then returned as the output of the `get_size_stock` function.",
    "original_summary": "Create a function named get_size_stock that takes an item ID (bigint) and a size ID (bigint) and returns a stock quantity (bigint). Select the stock value from the item_sizes table where item_id and size_id match the inputs. Use COALESCE to return 0 if the stock is NULL or no row is found.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Please construct a function designated as 'get_size_stock'. This function shall accept two parameters: an item identifier of type bigint and a size identifier, also of type bigint. Its purpose is to return a stock quantity as a bigint value. The implementation must query the 'item_sizes' table to retrieve the stock value where the provided item_id and size_id correspond to the table's respective columns. It is required to employ the COALESCE function within the selection to ensure a return value of 0 in instances where the stock is NULL or a matching record is not located."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named get_active_discount that returns a table with two columns: discount_id of type bigint and discount_value of type text, and within its body, first checks for the existence of at least one record in the discounts table where a date range constructed from the table's start_date and end_date columns, cast to date and formed as an inclusive range using the '[]' bounds specification, has an infinite upper bound as determined by the upper_inf function, and if such a record exists, the function executes and returns the result of a query that selects the discount_id and discount_value columns from the discounts table for all rows meeting that same condition where the upper_inf function returns true for the daterange built from start_date::date and end_date::date with inclusive bounds.",
    "plsql": "CREATE OR REPLACE FUNCTION get_active_discount()\nRETURNS TABLE(discount_id bigint, discount_value text) AS $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM discounts WHERE upper_inf(daterange(start_date::date, end_date::date, '[]'))) THEN\n        RETURN QUERY SELECT discount_id, discount_value FROM discounts WHERE upper_inf(daterange(start_date::date, end_date::date, '[]'));\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_purchase_and_discount_tracking",
    "tables": [
      "customers",
      "discounts",
      "order_items",
      "orders",
      "products",
      "user_management"
    ],
    "call_sqls": [
      "SELECT * FROM get_active_discount();",
      "SELECT discount_id, discount_value FROM get_active_discount();",
      "SELECT discount_id FROM get_active_discount();",
      "SELECT discount_value FROM get_active_discount();",
      "SELECT * FROM get_active_discount() WHERE discount_value::numeric > 15;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_active_discount` that returns a table with `discount_id` and `discount_value` from the `discounts` table, selecting only those discounts where the date range defined by `start_date` and `end_date` has no upper bound, meaning the discount is active indefinitely.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called `get_active_discount` that returns a table with `discount_id` and `discount_value`? It should retrieve all active discounts from the `discounts` table where the discount period has no real end datemeaning the date range from `start_date` to `end_date` is effectively open-ended or infinite.",
    "id": 58,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named get_active_discount that returns a table with two columns: discount_id of type bigint and discount_value of type text, and within its body, first checks for the existence of at least one record in the discounts table where a date range constructed from the table's start_date and end_date columns, cast to date and formed as an inclusive range using the '[]' bounds specification, has an infinite upper bound as determined by the upper_inf function, and if such a record exists, the function executes and returns the result of a query that selects the discount_id and discount_value columns from the discounts table for all rows meeting that same condition where the upper_inf function returns true for the daterange built from start_date::date and end_date::date with inclusive bounds.",
    "original_summary": "Create a function named `get_active_discount` that returns a table of `discount_id` (bigint) and `discount_value` (text). It should select from the `discounts` table where the date range formed by `start_date` and `end_date` (cast to date) has an infinite upper bound.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a function called `get_active_discount` that spits out a table with `discount_id` (as a bigint) and `discount_value` (as text)? It needs to pull from the `discounts` table, but only grab the deals where the end date is basically foreverlike, the range from the start date to the end date (cast as dates) doesn't have a real closing date."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_education_level_count` that accepts one input parameter and returns a single value. The input parameter is named `p_education`, is of data type `TEXT`, and represents the specific education level for which a count is desired. The function is designed to return a value of data type `BIGINT`, which will represent the total number of records found. The core operation of this function involves executing a `SELECT` statement to retrieve data. Specifically, it performs a `COUNT(*)` aggregation, which calculates the total number of rows that satisfy a given condition. This count is performed on the `demographic_data` table. The condition for counting rows is applied to the `education` column within the `demographic_data` table. Before comparison, the value in the `education` column from the table is converted to uppercase using the `UPPER()` function. This uppercase value is then compared for equality with the uppercase version of the input parameter `p_education`, which is also converted to uppercase using the `UPPER()` function. The result of this `COUNT(*)` aggregation, representing the number of rows where the uppercase `education` column matches the uppercase `p_education` parameter, is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_education_level_count(p_education TEXT)\nRETURNS BIGINT AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM demographic_data WHERE UPPER(education) = UPPER(p_education));\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "demographic_and_socioeconomic_data_analysis_317338",
    "tables": [
      "demographic_data",
      "marital_statuses",
      "occupations",
      "relationships"
    ],
    "call_sqls": [
      "SELECT get_education_level_count('Bachelors');",
      "SELECT get_education_level_count('HS-grad');",
      "SELECT get_education_level_count('Masters');",
      "SELECT get_education_level_count('Doctorate');",
      "SELECT get_education_level_count('Some-college');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_education_level_count that takes an education text parameter and returns the total count as a bigint, where it counts all rows in the demographic_data table where the uppercase value of the education column matches the uppercase value of the input parameter.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_education_level_count that counts how many rows in the demographic_data table have an education column value that matches the provided education parameter, ignoring case differences, and returns the total count as a bigint.",
    "id": 59,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_education_level_count that accepts a single input parameter named education of type text and returns a value of type bigint. The function declares a local variable named total_count of type bigint. The function performs a SELECT COUNT(*) operation on the demographic_data table, counting all rows where the value in the education column, converted to lowercase using the LOWER function, is exactly equal to the input parameter education value, also converted to lowercase using the LOWER function, thereby performing a case-insensitive comparison. The result of this count is stored into the total_count variable. The function then returns the value of the total_count variable as the result.",
    "original_summary": "Create a function named get_education_level_count that takes an education text parameter and returns a bigint count. Count and return the number of rows in the demographic_data table where the uppercase education column equals the uppercase input parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Count the rows in the demographic_data table where the uppercase education column matches the uppercase input parameter and return the total as a bigint. Name this function get_education_level_count."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_waitlist_position` that accepts two input parameters: `course_id` of type `bigint` and `student_id` of type `bigint`. This function is designed to retrieve and return the waitlist position of a specific student for a particular course. Upon execution, the function declares a local variable named `position` of type `bigint`. It then performs a `SELECT` operation to fetch a single value into this `position` variable. The `SELECT` statement targets the `waitlists` table, aliased as `w`. Specifically, it selects the value from the `position` column of the `waitlists` table. The selection is filtered by a `WHERE` clause that applies two conditions: first, the `course_id` column of the `waitlists` table (`w.course_id`) must be equal to the value provided by the first input parameter (`$1`, which corresponds to `course_id`); and second, the `student_id` column of the `waitlists` table (`w.student_id`) must be equal to the value provided by the second input parameter (`$2`, which corresponds to `student_id`). After successfully retrieving the `position` value based on these conditions, the function returns this `position` value as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_waitlist_position(course_id bigint, student_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    position bigint;\nBEGIN\n    SELECT w.position INTO position\n    FROM waitlists w\n    WHERE w.course_id = $1 AND w.student_id = $2;\n    RETURN position;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "university_course_management_and_registration_system_444320",
    "tables": [
      "courses",
      "instructors",
      "enrollments",
      "course_prerequisites",
      "course_materials",
      "course_feedback",
      "waitlists"
    ],
    "call_sqls": [
      "SELECT get_waitlist_position(1, 1);",
      "SELECT get_waitlist_position(0, 0);",
      "SELECT get_waitlist_position(1, 0);",
      "SELECT get_waitlist_position(0, 1);",
      "SELECT get_waitlist_position(99, 99);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_waitlist_position that, given a course_id and a student_id, retrieves and returns the waitlist position from the waitlists table for that specific student in the specified course.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_waitlist_position that, given a course identifier and a student identifier, retrieves and returns the exact position of that student on the waitlist for the specified course from the WAITLISTS table.",
    "id": 60,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_waitlist_position that takes two input parameters: a course identifier of type bigint and a student identifier of type bigint, and returns a bigint value representing the waitlist position. The function declares a local variable named waitlist_position of type bigint. It then executes a SELECT query on the waitlists table, specifically retrieving the position column for the row where the course_id column matches the input course identifier and the student_id column matches the input student identifier. The retrieved value is stored into the waitlist_position variable. Finally, the function returns the value of the waitlist_position variable, which is the exact position of the specified student on the waitlist for the specified course. If no matching row is found, the function will return NULL.",
    "original_summary": "Create a PL/pgSQL function named get_waitlist_position that accepts a course_id and a student_id (both bigint) and returns the waitlist position (bigint) for that student in the specified course.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Design a PL/pgSQL function called get_waitlist_position which takes two bigint parameters, specifically a course identifier and a student identifier, and then meticulously calculates and returns as a bigint the precise numerical position of that particular student on the waitlist for the explicitly specified course."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `calculate_adjusted_efficiency` that accepts a single input parameter, `p_stat_id`, which is of type `bigint` and represents a unique identifier for a player's statistics record. This function is designed to return a value of type `real`, representing an adjusted efficiency score. The core logic of the function is implemented using a `CASE` statement, which evaluates multiple conditions sequentially to determine the appropriate calculation for the adjusted efficiency.\n\nThe first condition checked by the `CASE` statement is whether a record exists in the `player_statistics` table where the `stat_id` column matches the input parameter `p_stat_id` AND the `field_goal_percentage` column is greater than `0.5`. This existence check is performed using a `SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage > 0.5` subquery. If this condition is true, the function proceeds to calculate the adjusted efficiency by selecting the product of the `pts` (points) column and the tangent of the `field_goal_percentage` column from the `player_statistics` table, specifically for the record where `stat_id` matches `p_stat_id`. The tangent function `tan()` is applied to the `field_goal_percentage`.\n\nIf the first condition is false, the `CASE` statement then evaluates its second condition: whether a record exists in the `player_statistics` table where the `stat_id` column matches the input parameter `p_stat_id` AND the `field_goal_percentage` column is between `0.3` and `0.5` (inclusive of both `0.3` and `0.5`). This existence check is performed using a `SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage BETWEEN 0.3 AND 0.5` subquery. If this second condition is true, the function calculates the adjusted efficiency by selecting the product of the `pts` column and the constant value `1.2` from the `player_statistics` table, specifically for the record where `stat_id` matches `p_stat_id`.\n\nIf both the first and second conditions are false, the `CASE` statement proceeds to evaluate its third condition: whether a record exists in the `player_statistics` table where the `stat_id` column matches the input parameter `p_stat_id` AND the `field_goal_percentage` column is less than `0.3`. This existence check is performed using a `SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage < 0.3` subquery. If this third condition is true, the function calculates the adjusted efficiency by selecting the product of the `pts` column and the constant value `0.8` from the `player_statistics` table, specifically for the record where `stat_id` matches `p_stat_id`.\n\nFinally, if none of the preceding conditions in the `CASE` statement are met (i.e., no record is found matching `p_stat_id` or the `field_goal_percentage` does not fall into any of the specified ranges), the `ELSE` clause of the `CASE` statement is executed, and the function returns the constant value `0`. The function concludes by returning the calculated or default adjusted efficiency value.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_adjusted_efficiency(p_stat_id bigint)\nRETURNS real AS $$\nBEGIN\n    RETURN CASE \n        WHEN EXISTS(SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage > 0.5) THEN (SELECT pts * tan(field_goal_percentage) FROM player_statistics WHERE stat_id = p_stat_id)\n        WHEN EXISTS(SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage BETWEEN 0.3 AND 0.5) THEN (SELECT pts * 1.2 FROM player_statistics WHERE stat_id = p_stat_id)\n        WHEN EXISTS(SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage < 0.3) THEN (SELECT pts * 0.8 FROM player_statistics WHERE stat_id = p_stat_id)\n        ELSE 0\n    END;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "basketball_game_statistics_and_performance_tracking",
    "tables": [
      "games",
      "player_statistics",
      "players"
    ],
    "call_sqls": [
      "SELECT calculate_adjusted_efficiency(0);",
      "SELECT calculate_adjusted_efficiency(1);",
      "SELECT calculate_adjusted_efficiency(100);",
      "SELECT calculate_adjusted_efficiency(stat_id) FROM player_statistics WHERE game_id = 0;",
      "SELECT player_name, calculate_adjusted_efficiency(stat_id) AS adjusted_efficiency FROM players p JOIN player_statistics ps ON p.player_id = ps.player_id WHERE ps.field_goal_percentage > 0.4;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_adjusted_efficiency that takes a stat_id and returns a real adjusted efficiency value by retrieving the pts and field_goal_percentage from the player_statistics table for the given stat_id, where if the field_goal_percentage is greater than 0.5, it returns pts multiplied by the tangent of field_goal_percentage; if between 0.3 and 0.5 inclusive, it returns pts multiplied by 1.2; if less than 0.3, it returns pts multiplied by 0.8; otherwise, it returns 0.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named calculate_adjusted_efficiency that takes a stat_id and returns a real number representing an adjusted efficiency metric by retrieving the field_goal_percentage and pts from the player_statistics table for that stat_id, then applying these business rules: if the field_goal_percentage is greater than 0.5, return pts multiplied by the tangent of field_goal_percentage; if it is between 0.3 and 0.5 inclusive, return pts multiplied by 1.2; if it is less than 0.3, return pts multiplied by 0.8; otherwise, return 0.",
    "id": 61,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `calculate_adjusted_efficiency` that accepts a single input parameter, `p_stat_id`, which is of type `bigint` and represents a unique identifier for a player's statistics record. This function is designed to return a value of type `real`, representing an adjusted efficiency score. The core logic of the function is implemented using a `CASE` statement, which evaluates multiple conditions sequentially to determine the appropriate calculation for the adjusted efficiency.\n\nThe first condition checked by the `CASE` statement is whether a record exists in the `player_statistics` table where the `stat_id` column matches the input parameter `p_stat_id` AND the `field_goal_percentage` column is greater than `0.5`. This existence check is performed using a `SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage > 0.5` subquery. If this condition is true, the function proceeds to calculate the adjusted efficiency by selecting the product of the `pts` (points) column and the tangent of the `field_goal_percentage` column from the `player_statistics` table, specifically for the record where `stat_id` matches `p_stat_id`. The tangent function `tan()` is applied to the `field_goal_percentage`.\n\nIf the first condition is false, the `CASE` statement then evaluates its second condition: whether a record exists in the `player_statistics` table where the `stat_id` column matches the input parameter `p_stat_id` AND the `field_goal_percentage` column is between `0.3` and `0.5` (inclusive of both `0.3` and `0.5`). This existence check is performed using a `SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage BETWEEN 0.3 AND 0.5` subquery. If this second condition is true, the function calculates the adjusted efficiency by selecting the product of the `pts` column and the constant value `1.2` from the `player_statistics` table, specifically for the record where `stat_id` matches `p_stat_id`.\n\nIf both the first and second conditions are false, the `CASE` statement proceeds to evaluate its third condition: whether a record exists in the `player_statistics` table where the `stat_id` column matches the input parameter `p_stat_id` AND the `field_goal_percentage` column is less than `0.3`. This existence check is performed using a `SELECT 1 FROM player_statistics WHERE stat_id = p_stat_id AND field_goal_percentage < 0.3` subquery. If this third condition is true, the function calculates the adjusted efficiency by selecting the product of the `pts` column and the constant value `0.8` from the `player_statistics` table, specifically for the record where `stat_id` matches `p_stat_id`.\n\nFinally, if none of the preceding conditions in the `CASE` statement are met (i.e., no record is found matching `p_stat_id` or the `field_goal_percentage` does not fall into any of the specified ranges), the `ELSE` clause of the `CASE` statement is executed, and the function returns the constant value `0`. The function concludes by returning the calculated or default adjusted efficiency value.",
    "original_summary": "Create a PL/pgSQL function named calculate_adjusted_efficiency that takes a bigint stat_id and returns a real value. It uses a CASE statement to calculate adjusted efficiency based on field_goal_percentage from the player_statistics table: if >0.5, return pts * tan(field_goal_percentage); if between 0.3 and 0.5, return pts * 1.2; if <0.3, return pts * 0.8; else return 0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/pgSQL function designated as 'calculate_adjusted_efficiency' which accepts a parameter of type bigint named 'stat_id' and yields a real number as its output. The function's logic shall employ a CASE statement to compute an adjusted efficiency metric. This computation must query the 'field_goal_percentage' from the 'player_statistics' table for the provided identifier. The stipulated conditions are as follows: if the percentage exceeds 0.5, the result shall be the product of 'pts' and the tangent of 'field_goal_percentage'; if the percentage falls within the inclusive range of 0.3 to 0.5, the result shall be 'pts' multiplied by 1.2; if the percentage is below 0.3, the result shall be 'pts' multiplied by 0.8; in all other cases, the function must return 0."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_customer_order_count` that accepts a single input parameter, `p_customer_id`, which is of type `bigint`. This function is designed to return a single value of type `bigint`. Upon execution, the function declares a local variable named `order_count` of type `bigint` to store the calculated count of orders. The function then proceeds with a conditional check: it evaluates whether the input parameter `p_customer_id` is not `NULL`. If `p_customer_id` is determined to be not `NULL`, the function executes a `SELECT` statement. This `SELECT` statement calculates the count of `order_id` values from the `orders` table. The counting operation is filtered by a `WHERE` clause, which specifies that only rows where the `customer_id` column in the `orders` table matches the value of the input parameter `p_customer_id` should be included in the count. The result of this `COUNT` aggregation is then assigned to the `order_count` local variable. Conversely, if the initial conditional check determines that `p_customer_id` is `NULL`, the function bypasses the `SELECT` statement and directly assigns the integer value `0` to the `order_count` local variable. Finally, regardless of the path taken through the conditional logic, the function returns the final value stored in the `order_count` local variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_order_count(p_customer_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    order_count bigint;\nBEGIN\n    IF p_customer_id IS NOT NULL THEN\n        SELECT COUNT(order_id) INTO order_count FROM orders WHERE customer_id = p_customer_id;\n    ELSE\n        order_count := 0;\n    END IF;\n    RETURN order_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_purchase_and_discount_tracking",
    "tables": [
      "customers",
      "discounts",
      "order_items",
      "orders",
      "products",
      "user_management"
    ],
    "call_sqls": [
      "SELECT get_customer_order_count(0);",
      "SELECT get_customer_order_count(1);",
      "SELECT get_customer_order_count(NULL);",
      "SELECT get_customer_order_count(100);",
      "SELECT get_customer_order_count(2);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_customer_order_count` that, given a `customer_id`, returns the total number of orders associated with that customer from the ORDERS table; if the provided `customer_id` is NULL, the function should return 0.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_customer_order_count that counts the orders for a specified customer, taking the customer's ID as input and returning the total number of their orders from the ORDERS table; if the provided customer ID is NULL, return 0.",
    "id": 62,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_customer_order_count` that accepts a single input parameter, `p_customer_id`, which is of type `bigint`. This function is designed to return a single value of type `bigint`. Upon execution, the function declares a local variable named `order_count` of type `bigint` to store the calculated count of orders. The function then proceeds with a conditional check: it evaluates whether the input parameter `p_customer_id` is not `NULL`. If `p_customer_id` is determined to be not `NULL`, the function executes a `SELECT` statement. This `SELECT` statement calculates the count of `order_id` values from the `orders` table. The counting operation is filtered by a `WHERE` clause, which specifies that only rows where the `customer_id` column in the `orders` table matches the value of the input parameter `p_customer_id` should be included in the count. The result of this `COUNT` aggregation is then assigned to the `order_count` local variable. Conversely, if the initial conditional check determines that `p_customer_id` is `NULL`, the function bypasses the `SELECT` statement and directly assigns the integer value `0` to the `order_count` local variable. Finally, regardless of the path taken through the conditional logic, the function returns the final value stored in the `order_count` local variable as its output.",
    "original_summary": "Create a function named `get_customer_order_count` that takes a `customer_id` (bigint) and returns the count of their orders (as bigint). If the input `customer_id` is NULL, return 0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Count the orders for a specified customer. Provide the customer's ID as a bigint, and the function will return the total number of their orders as a bigint. If the given customer ID is NULL, return 0."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_brand_budget_total` that accepts a single input parameter named `brand_id_param` of data type `bigint`. This function is designed to calculate and return the total budget allocated to all campaigns associated with the specified brand. The function's return type is `real`, which is a single-precision floating-point number. The core operation of this function involves executing a `SELECT` statement to retrieve data from the `campaigns` table. Within this `SELECT` statement, the `SUM` aggregate function is applied to the `budget` column. The `SUM` function calculates the total sum of all values in the `budget` column for the rows that satisfy a specific condition. The condition for selecting these rows is `brand_id = brand_id_param`, meaning only campaigns where the value in the `brand_id` column matches the value provided in the `brand_id_param` input parameter will be included in the sum calculation. To handle cases where no campaigns are found for the given `brand_id_param` (which would result in `SUM` returning `NULL`), the `COALESCE` function is used. `COALESCE(SUM(budget), 0)` ensures that if the `SUM(budget)` operation yields `NULL`, the function will instead return `0`. The result of this `SELECT` statement, which is either the calculated sum of budgets or `0`, is then returned as the output of the `get_brand_budget_total` function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_brand_budget_total(brand_id_param bigint) RETURNS real AS $$\nBEGIN\n    RETURN (SELECT COALESCE(SUM(budget), 0) FROM campaigns WHERE brand_id = brand_id_param);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "social_media_influencer_metrics_and_profile_information",
    "tables": [
      "brands",
      "campaigns",
      "campaign_performance",
      "influencers"
    ],
    "call_sqls": [
      "SELECT get_brand_budget_total(0);",
      "SELECT get_brand_budget_total(1);",
      "SELECT get_brand_budget_total(999);",
      "SELECT get_brand_budget_total( (SELECT brand_id FROM brands WHERE brand_name = 'Sporty Gear Inc.') );",
      "SELECT get_brand_budget_total( (SELECT brand_id FROM brands WHERE brand_name = 'Tech Innovations') );"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_brand_budget_total that takes a brand ID as input and returns the total budget as a real number by summing the budget column from the campaigns table for all campaigns associated with that brand ID, returning 0 if no campaigns are found.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_brand_budget_total that calculates and returns the total budget from the campaigns table for a specified brand ID, using the brand_id_param input; if no campaigns exist for that brand, output 0.",
    "id": 63,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_brand_budget_total that accepts a single input parameter named brand_id_param of type bigint, which specifies the unique identifier for a brand; the function returns a real value representing the total budget. The function begins by declaring a local real variable named total_budget. It then executes a SELECT query on the campaigns table to calculate the sum of the budget column for all rows where the brand_id column exactly matches the input parameter brand_id_param. The result of this aggregation is stored into the local variable total_budget. Following this, a conditional check is performed: if the value of total_budget is NULL, which occurs when no matching rows are found in the campaigns table for the given brand_id_param, the function sets the total_budget variable to 0. Finally, the function returns the value of the total_budget variable.",
    "original_summary": "Create a PL/pgSQL function named get_brand_budget_total that takes a brand ID (bigint) as input and returns a real number. It should return the sum of the budget column from the campaigns table for the given brand ID. If no campaigns are found, return 0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Calculate and return the total budget from the campaigns table for a specified brand ID. If no campaigns exist for that brand, output 0."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named generate_faculty_research_profile that accepts a single input parameter p_faculty_id of type bigint, which represents the unique identifier for a faculty member, and returns a formatted text string summarizing the faculty member's research profile. The function begins by declaring multiple local variables: v_faculty_name, v_department_name, v_field_name, v_group_name, v_position_level (initialized to 'Faculty'), v_career_stage (initialized to 'Early'), v_research_focus (initialized to 'General'), v_collaboration_level (initialized to 'Individual'), v_publication_trend (initialized to 'Stable'), v_funding_status (initialized to 'Unfunded'), v_leadership_role (initialized to 'Member'), v_academic_age (initialized to 0), v_recent_pubs (initialized to 0), v_total_pubs (initialized to 0), v_active_projects (initialized to 0), v_total_funding (initialized to 0.0), and v_profile_text (initialized to an empty string). The function first queries the faculty_members table, joining with the departments table on department_id, the fields_of_specialization table on field_of_specialization_id to field_id, and the research_groups table on research_group_id to group_id, to retrieve the faculty member's name, department name, field of specialization name, research group name, and academic age (calculated by subtracting the year extracted from the hiring_date string from 2024) for the specific p_faculty_id, storing these results into the corresponding variables. It then queries the publications table to count the total number of publications and the number of recent publications (where the year extracted from the publication_date string is 2021 or later) for the same faculty_id, storing the counts into v_total_pubs and v_recent_pubs. Next, it queries the research_projects table to count the number of active projects and sum their funding_amount for rows where the principal_investigator_id matches p_faculty_id and the project's end_date year is 2024 or later, storing the count into v_active_projects and the sum (or 0 if null) into v_total_funding. The function then uses conditional logic to reassign the v_career_stage variable: if v_academic_age is greater than 15, it becomes 'Senior'; if greater than 7, it becomes 'Mid-Career'. It reassigns v_publication_trend based on v_recent_pubs: if greater than 8, it becomes 'Highly Active'; if greater than 4, it becomes 'Active'; if greater than 1, it becomes 'Moderate'. It reassigns v_funding_status based on v_total_funding: if greater than 1,000,000, it becomes 'Well-Funded'; if greater than 250,000, it becomes 'Adequately Funded'; if greater than 0, it becomes 'Modestly Funded'. The function checks for leadership roles using EXISTS subqueries: it sets v_leadership_role to 'Dean' if the faculty_id exists as dean_id in the schools table, to 'Department Head' if it exists as department_head_id in the departments table, or to 'Research Group Leader' if it exists as leader_id in the research_groups table. It reassigns v_collaboration_level: if v_group_name is not null and v_active_projects is greater than 2, it becomes 'Highly Collaborative'; if either v_group_name is not null or v_active_projects is greater than 0, it becomes 'Collaborative'. It sets v_research_focus to the first 20 characters of v_field_name using the SUBSTR function, or to 'Interdisciplinary' if v_field_name is null. Finally, the function constructs the v_profile_text return string by concatenating the variables and literal strings, including v_faculty_name, v_career_stage, v_leadership_role, v_department_name, v_research_focus, v_publication_trend, v_total_pubs, v_recent_pubs, v_funding_status, the ceiling value of v_total_funding using the CEIL function, v_collaboration_level, and v_academic_age, and returns this constructed text.",
    "plsql": "CREATE OR REPLACE FUNCTION generate_faculty_research_profile(p_faculty_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_faculty_name text := '';\n    v_department_name text := '';\n    v_field_name text := '';\n    v_group_name text := '';\n    v_position_level text := 'Faculty';\n    v_career_stage text := 'Early';\n    v_research_focus text := 'General';\n    v_collaboration_level text := 'Individual';\n    v_publication_trend text := 'Stable';\n    v_funding_status text := 'Unfunded';\n    v_leadership_role text := 'Member';\n    v_academic_age integer := 0;\n    v_recent_pubs integer := 0;\n    v_total_pubs integer := 0;\n    v_active_projects integer := 0;\n    v_total_funding real := 0;\n    v_profile_text text := '';\nBEGIN\n    SELECT f.name, d.department_name, fs.field_name, rg.group_name, (2024 - SUBSTR(f.hiring_date, 1, 4)::INTEGER)\n    INTO v_faculty_name, v_department_name, v_field_name, v_group_name, v_academic_age\n    FROM faculty_members f\n    LEFT JOIN departments d ON f.department_id = d.department_id\n    LEFT JOIN fields_of_specialization fs ON f.field_of_specialization_id = fs.field_id\n    LEFT JOIN research_groups rg ON f.research_group_id = rg.group_id\n    WHERE f.faculty_id = p_faculty_id;\n\n    SELECT COUNT(*), COUNT(CASE WHEN SUBSTR(publication_date, 1, 4)::INTEGER >= 2021 THEN 1 END)\n    INTO v_total_pubs, v_recent_pubs\n    FROM publications\n    WHERE faculty_id = p_faculty_id;\n\n    SELECT COUNT(*), COALESCE(SUM(funding_amount), 0)\n    INTO v_active_projects, v_total_funding\n    FROM research_projects\n    WHERE principal_investigator_id = p_faculty_id AND SUBSTR(end_date, 1, 4)::INTEGER >= 2024;\n\n    IF v_academic_age > 15 THEN\n        v_career_stage := 'Senior';\n    ELSIF v_academic_age > 7 THEN\n        v_career_stage := 'Mid-Career';\n    END IF;\n\n    IF v_recent_pubs > 8 THEN\n        v_publication_trend := 'Highly Active';\n    ELSIF v_recent_pubs > 4 THEN\n        v_publication_trend := 'Active';\n    ELSIF v_recent_pubs > 1 THEN\n        v_publication_trend := 'Moderate';\n    END IF;\n\n    IF v_total_funding > 1000000 THEN\n        v_funding_status := 'Well-Funded';\n    ELSIF v_total_funding > 250000 THEN\n        v_funding_status := 'Adequately Funded';\n    ELSIF v_total_funding > 0 THEN\n        v_funding_status := 'Modestly Funded';\n    END IF;\n\n    IF EXISTS(SELECT 1 FROM schools WHERE dean_id = p_faculty_id) THEN\n        v_leadership_role := 'Dean';\n    ELSIF EXISTS(SELECT 1 FROM departments WHERE department_head_id = p_faculty_id) THEN\n        v_leadership_role := 'Department Head';\n    ELSIF EXISTS(SELECT 1 FROM research_groups WHERE leader_id = p_faculty_id) THEN\n        v_leadership_role := 'Research Group Leader';\n    END IF;\n\n    IF v_group_name IS NOT NULL AND v_active_projects > 2 THEN\n        v_collaboration_level := 'Highly Collaborative';\n    ELSIF v_group_name IS NOT NULL OR v_active_projects > 0 THEN\n        v_collaboration_level := 'Collaborative';\n    END IF;\n\n    v_research_focus := COALESCE(SUBSTR(v_field_name, 1, 20), 'Interdisciplinary');\n\n    v_profile_text := v_faculty_name || ' (' || v_career_stage || ' ' || v_leadership_role || ') - ' || v_department_name || ' | Focus: ' || v_research_focus || ' | Publications: ' || v_publication_trend || ' (' || v_total_pubs || ' total, ' || v_recent_pubs || ' recent) | Funding: ' || v_funding_status || ' ($' || CEIL(v_total_funding) || ') | Collaboration: ' || v_collaboration_level || ' | Academic Age: ' || v_academic_age || ' years';\n\n    RETURN v_profile_text;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "academic_faculty_and_research_management_681390",
    "tables": [
      "academic_milestones",
      "faculty_members",
      "departments",
      "fields_of_specialization",
      "publications",
      "research_groups",
      "research_projects",
      "schools"
    ],
    "call_sqls": [
      "SELECT generate_faculty_research_profile(1);",
      "SELECT generate_faculty_research_profile(2);",
      "SELECT generate_faculty_research_profile(3);",
      "SELECT generate_faculty_research_profile(4);",
      "SELECT generate_faculty_research_profile(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named generate_faculty_research_profile that takes a faculty ID and returns a formatted text summary, which includes the faculty's name, department, field, group, and academic age from the faculty_members, departments, fields_of_specialization, and research_groups tables; counts total and recent publications from the publications table; counts active projects and sums total funding from the research_projects table; determines career stage based on academic age, publication trend based on recent publications, funding status based on total funding, leadership role by checking the schools, departments, and research_groups tables, collaboration level based on group membership and active projects, and research focus from the field; and concatenates all these elements into a single profile string.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called 'generate_faculty_research_profile' that, given a faculty ID, returns a formatted summary profile. It should retrieve the faculty member's name, department, field of specialization, research group, and academic age from the faculty_members, departments, fields_of_specialization, and research_groups tables. Then, calculate their total publications and recent publications from the publications table, and count their active projects and total funding from the research_projects table. Based on this data, determine their career stage (Early, Mid-Career, or Senior) using academic age, publication trend (Moderate, Active, or Highly Active) using recent publications, funding status (Modestly Funded, Adequately Funded, Well-Funded, or Unfunded) using total funding, leadership role (Member, Research Group Leader, Department Head, or Dean) by checking the schools, departments, and research_groups tables, collaboration level (Individual, Collaborative, or Highly Collaborative) based on research group and active projects, and a condensed research focus. Finally, combine all these details into a single text string and return it.",
    "id": 64,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named generate_faculty_research_profile that accepts a single input parameter p_faculty_id of type bigint, which represents the unique identifier for a faculty member, and returns a formatted text string summarizing the faculty member's research profile. The function begins by declaring multiple local variables: v_faculty_name, v_department_name, v_field_name, v_group_name, v_position_level (initialized to 'Faculty'), v_career_stage (initialized to 'Early'), v_research_focus (initialized to 'General'), v_collaboration_level (initialized to 'Individual'), v_publication_trend (initialized to 'Stable'), v_funding_status (initialized to 'Unfunded'), v_leadership_role (initialized to 'Member'), v_academic_age (initialized to 0), v_recent_pubs (initialized to 0), v_total_pubs (initialized to 0), v_active_projects (initialized to 0), v_total_funding (initialized to 0.0), and v_profile_text (initialized to an empty string). The function first queries the faculty_members table, joining with the departments table on department_id, the fields_of_specialization table on field_of_specialization_id to field_id, and the research_groups table on research_group_id to group_id, to retrieve the faculty member's name, department name, field of specialization name, research group name, and academic age (calculated by subtracting the year extracted from the hiring_date string from 2024) for the specific p_faculty_id, storing these results into the corresponding variables. It then queries the publications table to count the total number of publications and the number of recent publications (where the year extracted from the publication_date string is 2021 or later) for the same faculty_id, storing the counts into v_total_pubs and v_recent_pubs. Next, it queries the research_projects table to count the number of active projects and sum their funding_amount for rows where the principal_investigator_id matches p_faculty_id and the project's end_date year is 2024 or later, storing the count into v_active_projects and the sum (or 0 if null) into v_total_funding. The function then uses conditional logic to reassign the v_career_stage variable: if v_academic_age is greater than 15, it becomes 'Senior'; if greater than 7, it becomes 'Mid-Career'. It reassigns v_publication_trend based on v_recent_pubs: if greater than 8, it becomes 'Highly Active'; if greater than 4, it becomes 'Active'; if greater than 1, it becomes 'Moderate'. It reassigns v_funding_status based on v_total_funding: if greater than 1,000,000, it becomes 'Well-Funded'; if greater than 250,000, it becomes 'Adequately Funded'; if greater than 0, it becomes 'Modestly Funded'. The function checks for leadership roles using EXISTS subqueries: it sets v_leadership_role to 'Dean' if the faculty_id exists as dean_id in the schools table, to 'Department Head' if it exists as department_head_id in the departments table, or to 'Research Group Leader' if it exists as leader_id in the research_groups table. It reassigns v_collaboration_level: if v_group_name is not null and v_active_projects is greater than 2, it becomes 'Highly Collaborative'; if either v_group_name is not null or v_active_projects is greater than 0, it becomes 'Collaborative'. It sets v_research_focus to the first 20 characters of v_field_name using the SUBSTR function, or to 'Interdisciplinary' if v_field_name is null. Finally, the function constructs the v_profile_text return string by concatenating the variables and literal strings, including v_faculty_name, v_career_stage, v_leadership_role, v_department_name, v_research_focus, v_publication_trend, v_total_pubs, v_recent_pubs, v_funding_status, the ceiling value of v_total_funding using the CEIL function, v_collaboration_level, and v_academic_age, and returns this constructed text.",
    "original_summary": "Create a PL/pgSQL function named generate_faculty_research_profile that takes a faculty ID (bigint) and returns a formatted text summary. It retrieves the faculty's name, department, field, group, and academic age. It counts total and recent publications, active projects, and total funding. It determines career stage, publication trend, funding status, leadership role, collaboration level, and research focus based on the data. The return string concatenates all these profile elements.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Alright, so I need you to whip up a PL/pgSQL function called 'generate_faculty_research_profile'. You'll feed it a faculty ID (that's a bigint number) and it'll spit back a nice, formatted summary. Basically, it's gotta go and grab the professor's name, their department, what field they're in, their research group, and how long they've been in the game (academic age). Then, it needs to tally up their total publications, recent ones, any active projects they're running, and the total cash they've pulled in (funding). Based on all that info, the function figures out stuff like what career stage they're at (early, mid, late), if their publication numbers are going up or down, their funding situation, if they're a big shot with a leadership role, how much they play with others (collaboration level), and what their main research jam is. Finally, it just mashes all these bits together into one big text string and hands it back."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_manuscript_id of type bigint and returns a bigint value representing the count of rows in the referee_invitations table where the manuscript_id column matches the provided p_manuscript_id parameter and the status column is equal to the string 'accepted'. The function executes a SELECT COUNT(*) operation to determine the number of such rows, effectively counting how many invitations have been accepted for the specified manuscript.",
    "plsql": "CREATE OR REPLACE FUNCTION get_accepted_invitations_count(p_manuscript_id bigint)\nRETURNS bigint\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM referee_invitations WHERE manuscript_id = p_manuscript_id AND status = 'accepted');\nEND;\n$$;",
    "database_name": "academic_journal_management_and_publication",
    "tables": [
      "manuscripts",
      "referee_invitations",
      "reviewers"
    ],
    "call_sqls": [
      "SELECT get_accepted_invitations_count(0);",
      "SELECT get_accepted_invitations_count(1);",
      "SELECT get_accepted_invitations_count(999);",
      "SELECT get_accepted_invitations_count( (SELECT manuscript_id FROM manuscripts ORDER BY RANDOM() LIMIT 1) );",
      "SELECT get_accepted_invitations_count( (SELECT manuscript_id FROM referee_invitations WHERE status = 'accepted' ORDER BY RANDOM() LIMIT 1) );"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_accepted_invitations_count that, for a given manuscript_id, returns the total number of accepted invitations from the referee_invitations table where the status is 'accepted'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_accepted_invitations_count that, for a given manuscript identifier, returns the count of accepted referee invitations from the referee_invitations table.",
    "id": 65,
    "generated_ir": "Write a PLpgSQL function that takes a single parameter p_manuscript_id of type bigint and returns a bigint value representing the count of rows in the referee_invitations table where the manuscript_id column matches the provided p_manuscript_id parameter and the status column is equal to the string 'accepted'. The function executes a SELECT COUNT(*) operation to determine the number of such rows, effectively counting how many invitations have been accepted for the specified manuscript.",
    "original_summary": "Create a PL/pgSQL function that takes a manuscript_id (bigint) and returns bigint. It counts and returns the number of accepted invitations (status = 'accepted') in the referee_invitations table for the given manuscript_id.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function that, for a given manuscript identifier, gives back a count of roughly the more positive responses from referees, focusing on those that seem to have been accepted, from the invitation records."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_employee_details` that accepts a single input parameter, `p_employee_id`, which is of data type `bigint`. This function is designed to return a set of rows, effectively acting as a table-like result. The structure of the returned table consists of three columns: `first_name` of type `text`, `last_name` of type `text`, and `role` of type `text`. The core operation performed by this function is a `SELECT` statement. Specifically, it queries the `employees` table. From this table, it retrieves the values from the `first_name` column, the `last_name` column, and the `role` column. The selection of rows is filtered by a `WHERE` clause, which specifies that only those rows where the value in the `employee_id` column of the `employees` table is equal to the value provided in the `p_employee_id` input parameter should be included in the result set. The `RETURN QUERY` statement then outputs the results of this `SELECT` query as the function's return value.",
    "plsql": "CREATE OR REPLACE FUNCTION get_employee_details(p_employee_id bigint)\nRETURNS TABLE(first_name text, last_name text, role text) AS $$\nBEGIN\n    RETURN QUERY SELECT employees.first_name, employees.last_name, employees.role FROM employees WHERE employees.employee_id = p_employee_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "automotive_dealerships_management_and_operations",
    "tables": [
      "customers",
      "dealerships",
      "employees",
      "sales",
      "vehicles",
      "vehicle_inventories",
      "feedback"
    ],
    "call_sqls": [
      "SELECT * FROM get_employee_details(1);",
      "SELECT * FROM get_employee_details(2);",
      "SELECT * FROM get_employee_details(3);",
      "SELECT * FROM get_employee_details(4);",
      "SELECT * FROM get_employee_details(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_employee_details that returns the first_name, last_name, and role from the employees table for a specific employee identified by an employee_id input parameter.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_employee_details that returns a table with columns first_name, last_name, and role, retrieving the first name, last name, and role from the employees table for the employee whose employee_id matches the provided bigint parameter.",
    "id": 66,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_employee_details that returns a table containing three columns: first_name, last_name, and role, all of type text. The function accepts a single input parameter named p_employee_id of type bigint, which represents the unique identifier of the employee whose details are to be retrieved. The function declares a variable named result of type RECORD to temporarily store the data fetched from the employees table. The function executes a SELECT statement to fetch the first_name, last_name, and role columns from the employees table where the employee_id column matches the value of the input parameter p_employee_id. The result of this query is stored into the result variable. Subsequently, the function returns a query that selects the first_name, last_name, and role fields from the result variable, effectively outputting these specific details of the employee whose ID was provided as input.",
    "original_summary": "Create a PL/pgSQL function named get_employee_details that returns a table with columns first_name, last_name, and role (all text) from the employees table where employee_id equals the input bigint parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function get_employee_details returning table(first_name text, last_name text, role text). Filter employees table where employee_id matches the given bigint parameter."
  },
  {
    "ir": "Write a PLpgSQL function named get_user_activity_summary that accepts a single parameter p_user_id of type bigint. This function returns a table with columns: username of type text, total_logs of type bigint, last_activity of type text, and active_locations of type bigint. The function's logic is structured with conditional statements to handle different scenarios based on the value of p_user_id. If p_user_id equals 0, the function executes a query that selects the username from the users table, counts the number of log entries from the access_logs table where the user_id matches p_user_id, finds the maximum access_time from the same table, and counts distinct point_id values from the monitoring_points table where the status is 'active'. These results are grouped by username. If p_user_id equals 1, the function performs a similar query but includes an additional condition that filters monitoring_points by the timezone 'America/New_York'. For any other value of p_user_id, the function executes a query that selects the username, counts the log entries, finds the maximum access_time, and counts distinct point_id values without additional conditions on the monitoring_points table. In all cases, the results are grouped by username. The function uses LEFT JOIN operations to combine data from the users, access_logs, and monitoring_points tables based on matching user_id and point_id columns, ensuring that all users are included even if they have no corresponding logs or monitoring points.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_activity_summary(p_user_id bigint)\nRETURNS TABLE(username text, total_logs bigint, last_activity text, active_locations bigint) AS $$\nBEGIN\n    IF p_user_id = 0 THEN\n        RETURN QUERY SELECT u.username, COUNT(al.log_id), MAX(al.access_time), COUNT(DISTINCT mp.point_id)\n                     FROM users u\n                     LEFT JOIN access_logs al ON u.user_id = al.user_id\n                     LEFT JOIN monitoring_points mp ON al.point_id = mp.point_id\n                     WHERE u.user_id = p_user_id AND mp.status = 'active'\n                     GROUP BY u.username;\n    ELSIF p_user_id = 1 THEN\n        RETURN QUERY SELECT u.username, COUNT(al.log_id), MAX(al.access_time), COUNT(DISTINCT mp.point_id)\n                     FROM users u\n                     LEFT JOIN access_logs al ON u.user_id = al.user_id\n                     LEFT JOIN monitoring_points mp ON al.point_id = mp.point_id\n                     WHERE u.user_id = p_user_id AND mp.timezone = 'America/New_York'\n                     GROUP BY u.username;\n    ELSE\n        RETURN QUERY SELECT u.username, COUNT(al.log_id), MAX(al.access_time), COUNT(DISTINCT mp.point_id)\n                     FROM users u\n                     LEFT JOIN access_logs al ON u.user_id = al.user_id\n                     LEFT JOIN monitoring_points mp ON al.point_id = mp.point_id\n                     WHERE u.user_id = p_user_id\n                     GROUP BY u.username;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "meteorological_data_collection_and_analysis_823099",
    "tables": [
      "access_logs",
      "monitoring_points",
      "users"
    ],
    "call_sqls": [
      "SELECT * FROM get_user_activity_summary(0);",
      "SELECT * FROM get_user_activity_summary(1);",
      "SELECT * FROM get_user_activity_summary(2);",
      "SELECT * FROM get_user_activity_summary(3);",
      "SELECT * FROM get_user_activity_summary(4);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_user_activity_summary that accepts a parameter p_user_id to identify a user and returns a table with columns username, total_logs, last_activity, and active_locations, summarizing user activity from the users, access_logs, and monitoring_points tables. If p_user_id is 0, include only active monitoring points; if p_user_id is 1, include only monitoring points in the 'America/New_York' timezone; otherwise, summarize without filtering by monitoring point status or timezone. For the specified user, retrieve the username, count all access logs as total_logs, find the most recent access_time as last_activity, and count distinct monitoring points as active_locations.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_user_activity_summary that takes a bigint parameter p_user_id and returns a table with columns username (text), total_logs (bigint), last_activity (text), and active_locations (bigint). The function should retrieve a summary from the users, access_logs, and monitoring_points tables, grouped by username. If p_user_id is 0, include only active monitoring points; if it is 1, include only monitoring points in the 'America/New_York' timezone; for any other p_user_id, return the summary without these filters.",
    "id": 67,
    "generated_ir": "Write a PLpgSQL function named get_user_activity_summary that accepts a single input parameter p_user_id of type bigint, which is used to identify a specific user, and returns a table with four columns: username of type text, total_logs of type bigint, last_activity of type text, and active_locations of type bigint. The function begins by declaring a variable v_filter_condition of type text to store a dynamic WHERE clause condition based on the input parameter p_user_id. The function then constructs and executes a dynamic SQL query that selects data from the users, access_logs, and monitoring_points tables. The query joins the users table with the access_logs table on the condition users.user_id = access_logs.user_id, and joins the access_logs table with the monitoring_points table on the condition access_logs.point_id = monitoring_points.point_id. The function groups the results by users.username. For each group, it calculates the total number of access logs as total_logs using the COUNT aggregate function on access_logs.log_id, determines the most recent access time as last_activity using the MAX aggregate function on access_logs.access_time, and counts the distinct monitoring points accessed as active_locations using the COUNT(DISTINCT monitoring_points.point_id) aggregate function. The function applies a filter condition based on the value of p_user_id: if p_user_id is 0, it includes only rows where monitoring_points.status is 'active'; if p_user_id is 1, it includes only rows where monitoring_points.timezone is 'America/New_York'; for any other p_user_id value, it applies no additional filter on monitoring_points. The dynamic SQL query is executed using the EXECUTE statement, and the results are returned as a table.",
    "original_summary": "Create a PLpgSQL function named get_user_activity_summary that accepts a bigint parameter p_user_id and returns a table with columns username (text), total_logs (bigint), last_activity (text), and active_locations (bigint). Use conditional logic: if p_user_id is 0, summarize user activity from access_logs and active monitoring points; if p_user_id is 1, include only monitoring points in the 'America/New_York' timezone; otherwise, summarize without the timezone filter. Join users, access_logs, and monitoring_points, grouping by username.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Alright, so I need you to whip up a PLpgSQL function called get_user_activity_summary. It's gotta take in a bigint parameter, let's call it p_user_id, and spit back a table with these columns: username (as text), total_logs (bigint), last_activity (text), and active_locations (bigint). Here's the deal with the logic: if the p_user_id is exactly 0, we're gonna pull a summary of all user activity from the access_logs and active monitoring points. If it's 1, then we only wanna include monitoring points that are in the 'America/New_York' timezone. For any other user ID, just give me the summary without that timezone filter. You'll have to join the users, access_logs, and monitoring_points tables, and group everything by the username."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_user_id of type bigint and returns an integer representing the count of evaluations associated with the given user ID. The function begins by declaring a local variable evaluation_count of type integer to store the result of the count operation. It then performs a SELECT statement to count the number of rows in the evaluations table where the evaluator_id column matches the provided p_user_id parameter. The COUNT function is used to determine the total number of evaluations, and the result is stored into the evaluation_count variable using the INTO clause. Finally, the function returns the value of evaluation_count, which represents the total number of evaluations conducted by the user specified by p_user_id.",
    "plsql": "CREATE OR REPLACE FUNCTION get_user_evaluation_count(p_user_id bigint)\nRETURNS integer AS $$\nDECLARE\n    evaluation_count integer;\nBEGIN\n    SELECT COUNT(e.evaluation_id) INTO evaluation_count\n    FROM evaluations e\n    WHERE e.evaluator_id = p_user_id;\n    \n    RETURN evaluation_count;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "machine_learning_model_performance_metrics_310382",
    "tables": [
      "models",
      "model_versions",
      "evaluations",
      "users"
    ],
    "call_sqls": [
      "SELECT get_user_evaluation_count(1);",
      "SELECT get_user_evaluation_count(0);",
      "SELECT get_user_evaluation_count(100);",
      "SELECT get_user_evaluation_count((SELECT user_id FROM users WHERE user_name = 'Alice Johnson'));",
      "SELECT get_user_evaluation_count((SELECT evaluator_id FROM evaluations ORDER BY evaluation_date DESC LIMIT 1));"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_user_evaluation_count that takes a user ID and returns the total number of evaluations from the EVALUATIONS table where the user is the evaluator, based on matching the evaluator_id.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function named get_user_evaluation_count that, given a user's ID, spits back how many times they were the one doing the evaluating by counting their evaluations from the evaluations table where they are the evaluator?",
    "id": 68,
    "generated_ir": "Write a PLpgSQL function that takes a single parameter p_user_id of type bigint and returns an integer representing the count of evaluations associated with the given user ID. The function begins by declaring a local variable evaluation_count of type integer to store the result of the count operation. It then performs a SELECT statement to count the number of rows in the evaluations table where the evaluator_id column matches the provided p_user_id parameter. The COUNT function is used to determine the total number of evaluations, and the result is stored into the evaluation_count variable using the INTO clause. Finally, the function returns the value of evaluation_count, which represents the total number of evaluations conducted by the user specified by p_user_id.",
    "original_summary": "Create a function that takes a user ID and returns the count of evaluations where the user is the evaluator.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a function that, given a user's ID, spits back how many times they were the one doing the evaluating?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_team_winning_percentage` that accepts two input parameters: `p_team_id` of type `bigint` representing the unique identifier for a team, and `p_season_id` of type `bigint` representing the unique identifier for a specific season. This function is designed to return a `real` number, which will be the calculated winning percentage for the specified team in the given season. The function initializes a local variable named `winning_percentage` of type `real`. The core logic of the function begins with a conditional check: it evaluates whether both `p_team_id` and `p_season_id` are not `NULL`. If both parameters are indeed not `NULL`, the function proceeds to execute a `SELECT` statement. This `SELECT` statement retrieves data from the `team_performance` table. Specifically, it calculates the winning percentage by dividing the `wins` column (cast to `real` to ensure floating-point division) by the `games_played` column. A `NULLIF` function is applied to `games_played` to prevent division by zero; if `games_played` is 0, `NULLIF` returns `NULL`, which then causes the entire division operation to result in `NULL`. The `COALESCE` function is then used to handle this potential `NULL` result from the division; if the division results in `NULL` (meaning `games_played` was 0), `COALESCE` substitutes `0.0` as the winning percentage. The calculated winning percentage is then stored into the `winning_percentage` local variable. This `SELECT` operation is filtered by a `WHERE` clause that matches rows where the `team_id` column equals the input parameter `p_team_id` AND the `season_id` column equals the input parameter `p_season_id`. If, however, the initial conditional check determines that either `p_team_id` or `p_season_id` (or both) are `NULL`, the `ELSE` block is executed, and the `winning_percentage` local variable is explicitly assigned the value `0.0`. Finally, regardless of the path taken through the conditional logic, the function returns the value stored in the `winning_percentage` local variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_team_winning_percentage(p_team_id bigint, p_season_id bigint)\nRETURNS real AS $$\nDECLARE\n    winning_percentage real;\nBEGIN\n    IF p_team_id IS NOT NULL AND p_season_id IS NOT NULL THEN\n        SELECT COALESCE(wins::real / NULLIF(games_played, 0), 0.0) INTO winning_percentage\n        FROM team_performance\n        WHERE team_id = p_team_id AND season_id = p_season_id;\n    ELSE\n        winning_percentage := 0.0;\n    END IF;\n    RETURN winning_percentage;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "sports_team_performance_and_statistics_818815",
    "tables": [
      "coaches",
      "games",
      "leagues",
      "player_performance",
      "players",
      "seasons",
      "team_performance",
      "teams",
      "users"
    ],
    "call_sqls": [
      "SELECT get_team_winning_percentage(1, 1);",
      "SELECT get_team_winning_percentage(2, 2);",
      "SELECT get_team_winning_percentage(1, 2);",
      "SELECT get_team_winning_percentage(2, 1);",
      "SELECT get_team_winning_percentage(NULL, 1);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_team_winning_percentage` that, given a team ID and a season ID, returns the team's winning percentage for that season from the `team_performance` table, calculated as wins divided by games_played, returning 0.0 if the inputs are null, games_played is zero, or no data is found.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `get_team_winning_percentage` that takes a team ID and a season ID and returns a real number representing the team's winning percentage for that season. It should calculate this by retrieving the wins and games_played from the `team_performance` table for the given team_id and season_id, then dividing wins by games_played. If there are no games played, the inputs are null, or no matching record exists, it should return 0.0.",
    "id": 69,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_team_winning_percentage` that accepts two input parameters: `p_team_id` of type `bigint` representing the unique identifier for a team, and `p_season_id` of type `bigint` representing the unique identifier for a specific season. This function is designed to return a `real` number, which will be the calculated winning percentage for the specified team in the given season. The function initializes a local variable named `winning_percentage` of type `real`. The core logic of the function begins with a conditional check: it evaluates whether both `p_team_id` and `p_season_id` are not `NULL`. If both parameters are indeed not `NULL`, the function proceeds to execute a `SELECT` statement. This `SELECT` statement retrieves data from the `team_performance` table. Specifically, it calculates the winning percentage by dividing the `wins` column (cast to `real` to ensure floating-point division) by the `games_played` column. A `NULLIF` function is applied to `games_played` to prevent division by zero; if `games_played` is 0, `NULLIF` returns `NULL`, which then causes the entire division operation to result in `NULL`. The `COALESCE` function is then used to handle this potential `NULL` result from the division; if the division results in `NULL` (meaning `games_played` was 0), `COALESCE` substitutes `0.0` as the winning percentage. The calculated winning percentage is then stored into the `winning_percentage` local variable. This `SELECT` operation is filtered by a `WHERE` clause that matches rows where the `team_id` column equals the input parameter `p_team_id` AND the `season_id` column equals the input parameter `p_season_id`. If, however, the initial conditional check determines that either `p_team_id` or `p_season_id` (or both) are `NULL`, the `ELSE` block is executed, and the `winning_percentage` local variable is explicitly assigned the value `0.0`. Finally, regardless of the path taken through the conditional logic, the function returns the value stored in the `winning_percentage` local variable.",
    "original_summary": "Create a PL/pgSQL function named `get_team_winning_percentage` that accepts a team ID and a season ID (both bigint) and returns a real number. The function calculates the team's winning percentage (wins / games_played) for the specified season from the `team_performance` table, handling division by zero and null parameters by returning 0.0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called `get_team_winning_percentage` that takes a team ID and a season ID (both as bigint) and gives back a real number. It should figure out how well a team did in a given season by looking at the `team_performance` table, working out the wins divided by the total games. Make sure it deals with cases where there are no games or the inputs are nothing by just returning 0.0."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_risk_score_difference that accepts two input parameters: a bigint parameter named p_patient_id representing a specific patient's identifier, and a text parameter named p_date representing a specific assessment date, and returns a real number value; within the function, it declares a local real variable named v_risk_difference to hold the calculation result, then executes a SELECT statement that queries the diabetes_risk_scores table, specifically retrieving the difference between the maximum value and the minimum value found in the risk_score column for all rows where the patient_id column exactly matches the provided p_patient_id parameter and the assessment_date column exactly matches the provided p_date parameter, storing this calculated difference into the v_risk_difference variable, and finally returns the value contained in the v_risk_difference variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_risk_score_difference(p_patient_id bigint, p_date text)\nRETURNS real\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_risk_difference real;\nBEGIN\n    SELECT MAX(risk_score) - MIN(risk_score) INTO v_risk_difference\n    FROM diabetes_risk_scores\n    WHERE patient_id = p_patient_id AND assessment_date = p_date;\n    RETURN v_risk_difference;\nEND;\n$$;",
    "database_name": "healthcare_data_management_and_diabetes_risk_assessment",
    "tables": [
      "diabetes_risk_scores",
      "patients"
    ],
    "call_sqls": [
      "SELECT calculate_risk_score_difference(1, '2023-01-15');",
      "SELECT calculate_risk_score_difference(1, '2023-01-16');",
      "SELECT calculate_risk_score_difference(1, '2023-01-17');",
      "SELECT calculate_risk_score_difference(1, '2023-01-18');",
      "SELECT calculate_risk_score_difference(1, '2023-01-19');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_risk_score_difference that, for a given p_patient_id and p_date, retrieves the difference between the maximum and minimum risk_score from the diabetes_risk_scores table where the patient_id and assessment_date match the inputs, and returns this calculated difference as a real number.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_risk_score_difference that, for a specified p_patient_id and p_date, returns the difference between the highest and lowest risk_score from the diabetes_risk_scores table where the patient_id and assessment_date match the given inputs.",
    "id": 70,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_risk_score_difference that accepts two input parameters: p_patient_id of type bigint, representing the unique identifier of a patient, and p_date of type text, representing a specific assessment date. The function returns a value of type real, which is the calculated difference between the highest and lowest risk scores for the given patient on the specified date. The function begins by declaring a local variable v_score_difference of type real to store the computed result. The core operation involves executing a SELECT statement that queries the diabetes_risk_scores table. Specifically, it calculates the difference between the maximum value and the minimum value from the risk_score column. This calculation is performed only for those rows in the diabetes_risk_scores table where the patient_id column exactly matches the input parameter p_patient_id and the assessment_date column exactly matches the input parameter p_date. The result of this calculation is directly assigned to the v_score_difference variable. Finally, the function returns the value stored in v_score_difference, which represents the range between the highest and lowest risk scores for the specified patient on the given assessment date. If no matching rows exist, the function will return NULL.",
    "original_summary": "Create a function named calculate_risk_score_difference that returns a real number. It accepts a bigint parameter p_patient_id and a text parameter p_date. The function calculates the difference between the maximum and minimum risk_score from the diabetes_risk_scores table for the specified patient_id and assessment_date. Return the calculated difference.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Develop a function called calculate_risk_score_difference, which is designed to output a real number value. This function should take two specific parameters: a bigint parameter named p_patient_id and a text parameter designated as p_date. Its primary purpose is to meticulously compute the precise difference, by performing a subtraction, between the highest maximum and the lowest minimum risk_score values retrieved from the diabetes_risk_scores table, carefully filtered for the given patient_id and the exact assessment_date. Finally, the function must return this calculated numerical difference."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_model_evaluation_summary` that accepts a single input parameter, `p_model_id`, which is of type `bigint`. This function is designed to return a set of records, specifically a table with two columns: `version_number` of type `text` and `evaluation_count` of type `integer`. The function's primary operation is to query data from two tables: `model_versions` (aliased as `mv`) and `evaluations` (aliased as `e`). It performs an `INNER JOIN` operation between these two tables. The join condition specifies that records from `model_versions` and `evaluations` are linked when the `version_id` column in the `model_versions` table matches the `version_id` column in the `evaluations` table. After joining, the query filters the results using a `WHERE` clause, retaining only those records where the `model_id` column in the `model_versions` table is equal to the value provided by the input parameter `p_model_id`. Following the filtering, the results are grouped by the `version_number` column from the `model_versions` table. For each distinct `version_number` group, the query selects the `version_number` itself and calculates the count of `evaluation_id` values from the `evaluations` table within that group. This count is then explicitly cast to an `integer` type. The function then returns this aggregated set of `version_number` and `evaluation_count` pairs as its result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_model_evaluation_summary(p_model_id bigint)\nRETURNS TABLE(version_number text, evaluation_count integer) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT mv.version_number, COUNT(e.evaluation_id)::integer\n    FROM model_versions mv\n    JOIN evaluations e ON mv.version_id = e.version_id\n    WHERE mv.model_id = p_model_id\n    GROUP BY mv.version_number;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "machine_learning_model_performance_metrics_310382",
    "tables": [
      "models",
      "model_versions",
      "evaluations",
      "users"
    ],
    "call_sqls": [
      "SELECT * FROM get_model_evaluation_summary(0);",
      "SELECT * FROM get_model_evaluation_summary(1);",
      "SELECT * FROM get_model_evaluation_summary(2);",
      "SELECT * FROM get_model_evaluation_summary(100);",
      "SELECT * FROM get_model_evaluation_summary(NULL);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_model_evaluation_summary that, for a given model_id, retrieves from the model_versions and evaluations tables the version_number for each version and the total number of evaluations associated with that version, returning these results as a table with text version_number and integer evaluation_count.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_model_evaluation_summary that, for a given model_id, returns a summary table with version_number and evaluation_count by joining model_versions and evaluations on version_id, filtering for the specified model_id, grouping by version_number, and counting the evaluations for each version.",
    "id": 71,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_model_evaluation_summary` that accepts a single input parameter, `p_model_id`, which is of type `bigint`. This function is designed to return a set of records, specifically a table with two columns: `version_number` of type `text` and `evaluation_count` of type `integer`. The function's primary operation is to query data from two tables: `model_versions` (aliased as `mv`) and `evaluations` (aliased as `e`). It performs an `INNER JOIN` operation between these two tables. The join condition specifies that records from `model_versions` and `evaluations` are linked when the `version_id` column in the `model_versions` table matches the `version_id` column in the `evaluations` table. After joining, the query filters the results using a `WHERE` clause, retaining only those records where the `model_id` column in the `model_versions` table is equal to the value provided by the input parameter `p_model_id`. Following the filtering, the results are grouped by the `version_number` column from the `model_versions` table. For each distinct `version_number` group, the query selects the `version_number` itself and calculates the count of `evaluation_id` values from the `evaluations` table within that group. This count is then explicitly cast to an `integer` type. The function then returns this aggregated set of `version_number` and `evaluation_count` pairs as its result.",
    "original_summary": "Create a function named get_model_evaluation_summary that takes a bigint model_id and returns a table with text version_number and integer evaluation_count. It performs an inner join between model_versions and evaluations on version_id, filters by the given model_id, groups by version_number, and counts the evaluations for each version.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Function get_model_evaluation_summary(model_id bigint) returns table(version_number text, evaluation_count integer). Join model_versions and evaluations on version_id, filter by model_id, group by version_number, count evaluations."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_owner_contact_info` that accepts a single input parameter, `p_owner_id`, which is of type `bigint`. This function is designed to return a set of rows, effectively acting as a table, with each row containing two columns: `owner_name` of type `text` and `contact_info` of type `text`. The primary operation performed by this function is a data retrieval (SELECT) query. Specifically, it selects the `owner_name` column and the `contact_info` column from the table named `owners`. The selection of rows from the `owners` table is filtered by a condition: `owners.owner_id` must be equal to the value provided in the input parameter `p_owner_id`. The results of this SELECT query, which include the `owner_name` and `contact_info` for all owners matching the specified `owner_id`, are then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_owner_contact_info(p_owner_id bigint)\nRETURNS TABLE(owner_name text, contact_info text) AS $$\nBEGIN\n    RETURN QUERY SELECT owners.owner_name, owners.contact_info\n    FROM owners\n    WHERE owners.owner_id = p_owner_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "real_estate_property_assessment_and_valuation",
    "tables": [
      "neighborhoods",
      "owners",
      "sales"
    ],
    "call_sqls": [
      "SELECT * FROM get_owner_contact_info(0);",
      "SELECT * FROM get_owner_contact_info(1);",
      "SELECT * FROM get_owner_contact_info(100);",
      "SELECT owner_name FROM get_owner_contact_info(5);",
      "SELECT contact_info FROM get_owner_contact_info(10);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_owner_contact_info` that, given an owner ID as input, retrieves the corresponding owner's name and contact information from the `owners` table and returns them as a table with columns `owner_name` and `contact_info`.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named `get_owner_contact_info` that, given a specific `p_owner_id`, retrieves the corresponding `owner_name` and `contact_info` from the `owners` table and returns them as a table.",
    "id": 72,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_owner_contact_info` that accepts a single input parameter, `p_owner_id`, which is of type `bigint`. This function is designed to return a set of rows, effectively acting as a table, with each row containing two columns: `owner_name` of type `text` and `contact_info` of type `text`. The primary operation performed by this function is a data retrieval (SELECT) query. Specifically, it selects the `owner_name` column and the `contact_info` column from the table named `owners`. The selection of rows from the `owners` table is filtered by a condition: `owners.owner_id` must be equal to the value provided in the input parameter `p_owner_id`. The results of this SELECT query, which include the `owner_name` and `contact_info` for all owners matching the specified `owner_id`, are then returned as the output of the function.",
    "original_summary": "Create a PostgreSQL function named `get_owner_contact_info` that returns a table with `owner_name` and `contact_info` columns. It takes a `bigint` parameter `p_owner_id` and selects the matching record from the `owners` table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "How can I create a PostgreSQL function named `get_owner_contact_info` that returns a table with `owner_name` and `contact_info` columns, taking a `bigint` parameter `p_owner_id` to select the matching record from the `owners` table?"
  },
  {
    "ir": "Write a PLpgSQL function that calculates and returns the population density of a city by taking a single parameter p_city_id of type bigint, which represents the unique identifier of a city. The function declares a variable v_density of type real to store the calculated density. It performs a SELECT operation on the cities table to retrieve the values of city_population and city_area_sqmi for the row where the city_id matches the provided p_city_id. The function computes the density by dividing the city_population by city_area_sqmi and assigns the result to v_density. Finally, the function returns the value of v_density as the output.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_city_density(p_city_id bigint)\nRETURNS real AS $$\nDECLARE\n    v_density real;\nBEGIN\n    SELECT city_population / city_area_sqmi INTO v_density\n    FROM cities\n    WHERE city_id = p_city_id;\n    \n    RETURN v_density;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "real_estate_market_analysis_292300",
    "tables": [
      "cities",
      "metros",
      "regions"
    ],
    "call_sqls": [
      "SELECT calculate_city_density(0);",
      "SELECT calculate_city_density(1);",
      "SELECT calculate_city_density( (SELECT city_id FROM cities WHERE city_name = 'Akron' LIMIT 1) );",
      "SELECT calculate_city_density( (SELECT city_id FROM cities WHERE city_name = 'Cleveland' LIMIT 1) );",
      "SELECT calculate_city_density( (SELECT city_id FROM cities ORDER BY city_population DESC LIMIT 1) );"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_city_density that takes a city ID and returns the population density for that city by dividing its city_population by its city_area_sqmi from the cities table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named calculate_city_density that accepts a city identifier as input and returns the population density as a real number for that city by retrieving its population from city_population and its area from city_area_sqmi in the cities table, then dividing the population by the area.",
    "id": 73,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_city_density that accepts a single input parameter, p_city_id, of type BIGINT, which specifies the unique identifier of the city for which the population density is to be calculated. The function returns a single value of type REAL, representing the computed population density.\n\nThe function begins by declaring a variable v_population of type BIGINT to store the city's population and a variable v_area of type REAL to store the city's area in square miles. It then executes a SELECT statement to query the cities table, specifically retrieving the city_population and city_area_sqmi columns for the row where the city_id column matches the provided p_city_id input parameter. The retrieved values are assigned into the v_population and v_area variables, respectively.\n\nAfter retrieving the data, the function performs a calculation to determine the population density by dividing the v_population (population) by the v_area (area). This division yields a REAL number. The function then returns this calculated density value as its output.\n\nIf no matching city is found for the given p_city_id (i.e., the SELECT statement returns no rows), the variables v_population and v_area will remain NULL. In this case, the division operation would also result in NULL. The function is designed to handle this by returning NULL when no data is found, as there is no explicit logic to substitute a default value.",
    "original_summary": "Create a PL/pgSQL function that takes a city ID (bigint) and returns its population density (real) by dividing the city's population by its area from the cities table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/pgSQL function that accepts a city identifier of type bigint as an input parameter. This function shall compute and return the population density, expressed as a real number, for the specified city. The calculation is to be performed by retrieving the city's population and its area from the cities table and then dividing the population value by the area value."
  },
  {
    "ir": "Write a PLpgSQL function that returns an integer representing the length of the maximum price value in the clothing_items table. The function, named get_max_price_length, does not take any parameters. It executes a SELECT statement to determine the maximum value in the price column of the clothing_items table, converts this maximum price value to a text representation using the ::text type cast, and then calculates the length of this text representation using the LENGTH() function. The result of this LENGTH() function call, which is an integer, is returned as the output of the function. The function is defined using the plpgsql language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_max_price_length()\nRETURNS integer AS $$\nBEGIN\n    RETURN (SELECT LENGTH(MAX(price)::text) FROM clothing_items);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "fashion_and_apparel_sizing_guide",
    "tables": [
      "inventory",
      "clothing_items"
    ],
    "call_sqls": [
      "SELECT get_max_price_length();",
      "SELECT * FROM get_max_price_length();",
      "SELECT get_max_price_length() AS max_price_length;",
      "DO $$\nDECLARE\n    result INTEGER;\nBEGIN\n    result := get_max_price_length();\n    RAISE NOTICE 'Maximum price length: %', result;\nEND $$;",
      "SELECT get_max_price_length() INTO TEMP TABLE temp_result;"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_max_price_length that returns an integer representing the character length of the highest price value found in the clothing_items table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_max_price_length that returns an integer representing the character length of the text representation of the maximum price value found in the clothing_items table.",
    "id": 74,
    "generated_ir": "Write a PLpgSQL function that returns an integer representing the length of the maximum price value in the clothing_items table. The function, named get_max_price_length, does not take any parameters. It executes a SELECT statement to determine the maximum value in the price column of the clothing_items table, converts this maximum price value to a text representation using the ::text type cast, and then calculates the length of this text representation using the LENGTH() function. The result of this LENGTH() function call, which is an integer, is returned as the output of the function. The function is defined using the plpgsql language.",
    "original_summary": "Create a PL/pgSQL function named get_max_price_length that returns an integer. It finds the maximum price from the clothing_items table, converts it to text, and returns the length of that text string.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called get_max_price_length that returns an integer. It should calculate the maximum price in the clothing_items table, convert that value to text, and then return the length of that text string."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves a set of records from a PostgreSQL database, specifically returning a table with columns feature_id, feature_name, value, and p_val1. The function accepts a single parameter, p_tree_id, of type bigint, which is used to filter the results based on the tree_id column in the feature_values table. The function performs a SELECT operation that joins three tables: feature_values, genomic_features, and statistical_values. It selects the feature_id and feature_name from the genomic_features table, the value from the feature_values table, and the p_val1 from the statistical_values table. The join between feature_values and genomic_features is an inner join based on the feature_id column, ensuring that only matching records from both tables are included. The join between feature_values and statistical_values is a left join based on the value_id column, allowing for the inclusion of all records from feature_values even if there is no corresponding record in statistical_values. The WHERE clause filters the results to include only those records where the tree_id in the feature_values table matches the provided p_tree_id parameter. The function is defined using the PLpgSQL language and returns the result set directly using the RETURN QUERY statement.",
    "plsql": "CREATE OR REPLACE FUNCTION get_tree_features_with_stats(p_tree_id bigint)\nRETURNS TABLE(feature_id bigint, feature_name text, value real, p_val1 real) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT gf.feature_id, gf.feature_name, fv.value, sv.p_val1\n    FROM feature_values fv\n    JOIN genomic_features gf ON fv.feature_id = gf.feature_id\n    LEFT JOIN statistical_values sv ON fv.value_id = sv.value_id\n    WHERE fv.tree_id = p_tree_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "genomic_feature_analysis_and_statistics",
    "tables": [
      "feature_values",
      "genomic_features",
      "decision_trees",
      "statistical_values",
      "study_features"
    ],
    "call_sqls": [
      "SELECT * FROM get_tree_features_with_stats(1);",
      "SELECT * FROM get_tree_features_with_stats(2);",
      "SELECT * FROM get_tree_features_with_stats(3);",
      "SELECT feature_id, feature_name, value FROM get_tree_features_with_stats(1) WHERE p_val1 < 0.05;",
      "SELECT * FROM get_tree_features_with_stats(0);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_tree_features_with_stats that returns a table with feature details and statistical values for a specified tree, taking a tree identifier as input. The function retrieves the feature_id and feature_name from the genomic_features table, the value from the feature_values table, and the p_val1 from the statistical_values table, filtering the results where the tree_id in feature_values matches the provided input. It returns all matching features with their values and includes statistical data where available.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_tree_features_with_stats that returns a table with columns feature_id, feature_name, value, and p_val1, based on a provided bigint input parameter p_tree_id. The function should retrieve data by joining the genomic_features, feature_values, and statistical_values tables, filtering where the tree_id in feature_values matches p_tree_id, and output all matching rows.",
    "id": 75,
    "generated_ir": "Write a PLpgSQL function that retrieves a set of records from a PostgreSQL database, specifically returning a table with columns feature_id, feature_name, value, and p_val1. The function accepts a single parameter, p_tree_id, of type bigint, which is used to filter the results based on the tree_id column in the feature_values table. The function performs a SELECT operation that joins three tables: feature_values, genomic_features, and statistical_values. It selects the feature_id and feature_name from the genomic_features table, the value from the feature_values table, and the p_val1 from the statistical_values table. The join between feature_values and genomic_features is an inner join based on the feature_id column, ensuring that only matching records from both tables are included. The join between feature_values and statistical_values is a left join based on the value_id column, allowing for the inclusion of all records from feature_values even if there is no corresponding record in statistical_values. The WHERE clause filters the results to include only those records where the tree_id in the feature_values table matches the provided p_tree_id parameter. The function is defined using the PLpgSQL language and returns the result set directly using the RETURN QUERY statement.",
    "original_summary": "Create a PL/pgSQL function that returns a table with columns feature_id, feature_name, value, and p_val1. It takes a bigint parameter p_tree_id. The function selects from a join of the genomic_features, feature_values, and statistical_values tables, filtering where feature_values.tree_id equals p_tree_id. Use an inner join between feature_values and genomic_features on feature_id, and a left join between feature_values and statistical_values on value_id. Return the result set using RETURN QUERY.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Construct a PL/pgSQL function that meticulously returns a comprehensive table containing the specific columns feature_id, feature_name, value, and p_val1. This function must accept a single bigint input parameter designated as p_tree_id. The core operation involves a detailed selection from a carefully joined combination of the genomic_features, feature_values, and statistical_values tables, applying a precise filter where the tree_id column within the feature_values table exactly matches the provided p_tree_id parameter. You are to implement an inner join, linking the feature_values and genomic_features tables seamlessly on their common feature_id column, and additionally perform a left join, connecting the feature_values table to the statistical_values table gracefully using the value_id column. Finally, the function should elegantly output the complete result set by employing the RETURN QUERY command."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_subject_contrast that accepts a single input parameter called subject_id_input of type BIGINT, which is used to identify a specific subject record, and returns a value of type TEXT; the function declares a local TEXT variable named result_contrast to hold the retrieved value; the function's logic consists of a single SQL SELECT statement that queries the subjects table, specifically retrieving the value from the contrast_group column for the row where the subject_id column exactly matches the provided subject_id_input parameter value, and stores this retrieved value into the result_contrast variable; the function then concludes by returning the contents of the result_contrast variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_subject_contrast(subject_id_input BIGINT) RETURNS TEXT AS $$\nDECLARE\n    result_contrast TEXT;\nBEGIN\n    SELECT subjects.contrast_group INTO result_contrast\n    FROM subjects\n    WHERE subjects.subject_id = subject_id_input;\n    RETURN result_contrast;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "psychological_experiment_data_management_639848",
    "tables": [
      "experiments",
      "blocks",
      "responses",
      "subjects"
    ],
    "call_sqls": [
      "SELECT get_subject_contrast(0);",
      "SELECT get_subject_contrast(1);",
      "SELECT get_subject_contrast(100);",
      "SELECT get_subject_contrast(NULL);",
      "SELECT get_subject_contrast(2);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_subject_contrast that, given a subject_id_input, retrieves and returns the contrast_group from the subjects table for the subject where the subject_id matches the provided input.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_subject_contrast that, given a subject ID as input, retrieves and returns the contrast_group value from the subjects table for the matching subject_id.",
    "id": 76,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_subject_contrast that accepts a single input parameter called subject_id_input of type BIGINT, which is used to identify a specific subject record, and returns a value of type TEXT; the function declares a local TEXT variable named result_contrast to hold the retrieved value; the function's logic consists of a single SQL SELECT statement that queries the subjects table, specifically retrieving the value from the contrast_group column for the row where the subject_id column exactly matches the provided subject_id_input parameter value, and stores this retrieved value into the result_contrast variable; the function then concludes by returning the contents of the result_contrast variable as its output.",
    "original_summary": "Create a PL/pgSQL function named get_subject_contrast that accepts a BIGINT subject_id_input parameter and returns TEXT. The function retrieves the contrast_group from the subjects table for the row where subject_id matches the input parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Please construct a PL/pgSQL function designated as 'get_subject_contrast'. This function shall accept a single parameter of type BIGINT, named 'subject_id_input', and shall return a value of type TEXT. Its operational logic is to query the 'subjects' table to retrieve the value of the 'contrast_group' column from the record whose 'subject_id' corresponds precisely to the provided input parameter."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `assess_device_data_quality` that accepts a single input parameter, `p_device_id`, which is of type `bigint`. This function is designed to return a `text` value indicating the quality assessment of a specific device's data. Upon execution, the function first declares a local variable named `poor_quality_count` of type `int` to store the count of data entries identified as 'poor' quality. It then performs a `SELECT` operation to count the number of rows in the `sensor_data` table. This count is specifically for rows where the `device_id` column matches the value provided in the `p_device_id` input parameter AND the `data_quality` column has a value exactly equal to the string literal 'poor'. The result of this count is stored into the `poor_quality_count` variable. Following this data retrieval, the function proceeds with a series of conditional checks. If the value stored in `poor_quality_count` is strictly greater than 100, the function immediately returns the string literal 'degraded'. Otherwise, if the previous condition is not met, it checks if `poor_quality_count` is strictly greater than 50. If this condition is true, the function returns the string literal 'warning'. If neither of the preceding conditions is met (meaning `poor_quality_count` is 50 or less), the function returns the string literal 'good'.",
    "plsql": "CREATE OR REPLACE FUNCTION assess_device_data_quality(p_device_id bigint)\nRETURNS text AS $$\nDECLARE\n    poor_quality_count int;\nBEGIN\n    SELECT COUNT(*) INTO poor_quality_count FROM sensor_data WHERE device_id = p_device_id AND data_quality = 'poor';\n\n    IF poor_quality_count > 100 THEN\n        RETURN 'degraded';\n    ELSIF poor_quality_count > 50 THEN\n        RETURN 'warning';\n    ELSE\n        RETURN 'good';\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "sensor_data_collection_and_analysis_for_iot_devices_465978",
    "tables": [
      "devices",
      "sensor_data",
      "metadata",
      "alerts",
      "device_calibrations"
    ],
    "call_sqls": [
      "SELECT assess_device_data_quality(1001);",
      "SELECT assess_device_data_quality(1002);",
      "SELECT assess_device_data_quality(1003);",
      "SELECT assess_device_data_quality(2001);",
      "SELECT assess_device_data_quality(2002);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `assess_device_data_quality` that, for a given `p_device_id`, evaluates the data quality by counting how many rows in the `sensor_data` table have a `data_quality` of 'poor' for that device, then returns a text assessment: 'degraded' if the count exceeds 100, 'warning' if it exceeds 50, or 'good' otherwise.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `assess_device_data_quality` that takes a device ID and returns a text assessment of data quality. Count how many records in the `sensor_data` table are associated with that device and have a `data_quality` of 'poor'. If the count exceeds 100, return 'degraded'; if it exceeds 50, return 'warning'; otherwise, return 'good'.",
    "id": 77,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named assess_device_data_quality that accepts a single input parameter p_device_id of type bigint and returns a text value representing the data quality assessment. The function declares a local variable poor_count of type integer to store the count of sensor data records with poor quality. It executes a SELECT query on the sensor_data table to count the number of rows where the device_id column matches the input parameter p_device_id and the data_quality column equals the string 'poor'. This count is stored in the poor_count variable. The function then uses conditional logic to determine the assessment: if poor_count is greater than 100, it returns the string 'degraded'; if poor_count is greater than 50, it returns the string 'warning'; otherwise, it returns the string 'good'. This provides a text-based evaluation of data quality for the specified device based on the number of poor-quality sensor data records.",
    "original_summary": "Create a PL/pgSQL function named `assess_device_data_quality` that takes a `bigint` parameter `p_device_id` and returns a `text` assessment. Count rows in `sensor_data` where `device_id` matches and `data_quality` is 'poor', storing it in `poor_quality_count`. Return 'degraded' if count > 100, 'warning' if count > 50, otherwise return 'good'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called `assess_device_data_quality` that needs a `bigint` input for the device ID and gives back a `text` result. Figure out roughly how many entries in the `sensor_data` table are linked to that device and have somewhat questionable data quality marked as 'poor', putting that number somewhere. If that number seems pretty high, like over a hundred, return 'degraded'. If it's more than a moderate amount, say over fifty, return 'warning'. If it's not really that many, just return 'good'."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named calculate_faculty_productivity_score that accepts a single input parameter p_faculty_id of type bigint, representing the unique identifier of a faculty member, and returns a real number value. The function begins by declaring multiple local variables: v_publication_count, v_project_count, v_milestone_count, and v_temp_count as integers; v_years_experience, v_hiring_year, v_current_year, v_tenure_status, v_is_group_leader, v_is_department_head, and v_is_dean as integers; and v_tenure_bonus, v_leadership_bonus, v_base_score, v_experience_multiplier, and v_final_score as real numbers, with v_experience_multiplier initialized to 1.0 and v_current_year set to 2024. It first queries the publications table to count all rows where the faculty_id column equals the input p_faculty_id, storing the result in v_publication_count. It then queries the research_projects table to count rows where the principal_investigator_id column equals p_faculty_id, storing the result in v_project_count. Next, it queries the academic_milestones table to count rows where the faculty_id column equals p_faculty_id, storing the result in v_milestone_count. It then retrieves data from the faculty_members table for the row where faculty_id equals p_faculty_id, extracting the year portion from the hiring_date column by using SUBSTR to get the first four characters, casting that substring to an INTEGER, and storing it in v_hiring_year, while also storing the tenure_status column value directly into v_tenure_status. The function calculates v_years_experience by subtracting v_hiring_year from v_current_year. It computes a v_base_score as the sum of: v_publication_count multiplied by 3.5, v_project_count multiplied by 2.8, and v_milestone_count multiplied by 1.2. A conditional block then sets the v_experience_multiplier based on v_years_experience: if greater than 20, it is set to 1.5; if greater than 10, it is set to 1.3; if greater than 5, it is set to 1.1. Another conditional checks if v_tenure_status equals 1, and if true, calculates v_tenure_bonus as v_base_score multiplied by 0.15. The function then queries the research_groups table to count rows where the leader_id column equals p_faculty_id, storing the count in v_temp_count; if this count is greater than 0, it sets v_is_group_leader to 1. It repeats this pattern for the departments table, counting rows where department_head_id equals p_faculty_id and setting v_is_department_head to 1 if the count is positive, and for the schools table, counting rows where dean_id equals p_faculty_id and setting v_is_dean to 1 if the count is positive. It then calculates v_leadership_bonus as the sum of: v_is_group_leader multiplied by 5.0, v_is_department_head multiplied by 8.0, and v_is_dean multiplied by 12.0. The v_final_score is computed as the product of v_base_score and v_experience_multiplier, plus v_tenure_bonus, plus v_leadership_bonus. Finally, the function returns the v_final_score after applying the CEIL function to v_final_score multiplied by 100, then dividing the result by 100.0, effectively rounding up to two decimal places.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_faculty_productivity_score(p_faculty_id bigint)\nRETURNS real AS $$\nDECLARE\n    v_publication_count integer := 0;\n    v_project_count integer := 0;\n    v_milestone_count integer := 0;\n    v_years_experience integer := 0;\n    v_tenure_bonus real := 0;\n    v_leadership_bonus real := 0;\n    v_base_score real := 0;\n    v_experience_multiplier real := 1.0;\n    v_final_score real := 0;\n    v_hiring_year integer := 0;\n    v_current_year integer := 2024;\n    v_tenure_status integer := 0;\n    v_is_group_leader integer := 0;\n    v_is_department_head integer := 0;\n    v_is_dean integer := 0;\n    v_temp_count integer := 0;\nBEGIN\n    SELECT COUNT(*) INTO v_publication_count FROM publications WHERE faculty_id = p_faculty_id;\n    SELECT COUNT(*) INTO v_project_count FROM research_projects WHERE principal_investigator_id = p_faculty_id;\n    SELECT COUNT(*) INTO v_milestone_count FROM academic_milestones WHERE faculty_id = p_faculty_id;\n    SELECT CAST(SUBSTR(hiring_date, 1, 4) AS INTEGER), tenure_status INTO v_hiring_year, v_tenure_status FROM faculty_members WHERE faculty_id = p_faculty_id;\n    v_years_experience := v_current_year - v_hiring_year;\n    v_base_score := (v_publication_count * 3.5) + (v_project_count * 2.8) + (v_milestone_count * 1.2);\n    IF v_years_experience > 20 THEN\n        v_experience_multiplier := 1.5;\n    ELSIF v_years_experience > 10 THEN\n        v_experience_multiplier := 1.3;\n    ELSIF v_years_experience > 5 THEN\n        v_experience_multiplier := 1.1;\n    END IF;\n    IF v_tenure_status = 1 THEN\n        v_tenure_bonus := v_base_score * 0.15;\n    END IF;\n    SELECT COUNT(*) INTO v_temp_count FROM research_groups WHERE leader_id = p_faculty_id;\n    IF v_temp_count > 0 THEN\n        v_is_group_leader := 1;\n    END IF;\n    SELECT COUNT(*) INTO v_temp_count FROM departments WHERE department_head_id = p_faculty_id;\n    IF v_temp_count > 0 THEN\n        v_is_department_head := 1;\n    END IF;\n    SELECT COUNT(*) INTO v_temp_count FROM schools WHERE dean_id = p_faculty_id;\n    IF v_temp_count > 0 THEN\n        v_is_dean := 1;\n    END IF;\n    v_leadership_bonus := (v_is_group_leader * 5.0) + (v_is_department_head * 8.0) + (v_is_dean * 12.0);\n    v_final_score := (v_base_score * v_experience_multiplier) + v_tenure_bonus + v_leadership_bonus;\n    RETURN CEIL(v_final_score * 100) / 100.0;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "academic_faculty_and_research_management_681390",
    "tables": [
      "academic_milestones",
      "faculty_members",
      "departments",
      "fields_of_specialization",
      "publications",
      "research_groups",
      "research_projects",
      "schools"
    ],
    "call_sqls": [
      "SELECT calculate_faculty_productivity_score(1);",
      "SELECT calculate_faculty_productivity_score(2);",
      "SELECT calculate_faculty_productivity_score(3);",
      "SELECT calculate_faculty_productivity_score(4);",
      "SELECT calculate_faculty_productivity_score(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_faculty_productivity_score that, for a given faculty ID, returns a real number representing a productivity score by retrieving the faculty member's publication count from the publications table, project count from the research_projects table, and milestone count from the academic_milestones table, calculating a base score using weights of 3.5, 2.8, and 1.2 respectively, applying an experience multiplier based on years of experience from the hiring_date in the faculty_members table (1.1 for over 5 years, 1.3 for over 10, 1.5 for over 20), adding a 15% tenure bonus if the tenure_status in faculty_members is 1, adding leadership bonuses (5 if the faculty is a leader in research_groups, 8 if a department head in departments, 12 if a dean in schools), and rounding the final score up to two decimal places.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named calculate_faculty_productivity_score that calculates a productivity score for a given faculty ID by retrieving their publication count from the publications table, project count from the research_projects table, and milestone count from the academic_milestones table, then computing a base score using the formula: multiply publication count by 3.5, project count by 2.8, and milestone count by 1.2. Apply an experience multiplier based on years from the hiring_date in the faculty_members table (1.1 for over 5 years, 1.3 for over 10, 1.5 for over 20), add a 15% tenure bonus if tenure_status is 1, include leadership bonuses (5 if the faculty is a leader in the research_groups table, 8 if department_head_id in the departments table, 12 if dean_id in the schools table), and finally round the total score up to two decimal places.",
    "id": 78,
    "generated_ir": "Write a PLpgSQL function named calculate_faculty_productivity_score that accepts a single parameter, faculty_id_param of type bigint, representing the faculty member for whom the productivity score is to be calculated, and returns a numeric value representing the computed productivity score. The function begins by declaring several local variables: publication_count of type bigint to store the count of publications, project_count of type bigint to store the count of research projects, milestone_count of type bigint to store the count of academic milestones, base_score of type numeric to hold the initial calculated score, experience_multiplier of type numeric to store the multiplier based on years of experience, tenure_bonus of type numeric to store the bonus for tenure status, leadership_bonus of type numeric to accumulate bonuses for leadership roles, total_score of type numeric for the final computed score, years_of_experience of type integer to store the calculated years from the hiring date, and hiring_date_val of type text to temporarily hold the hiring date from the faculty_members table.\n\nThe function first executes a SELECT query on the publications table to count the number of rows where the faculty_id column matches the provided faculty_id_param, storing the result in publication_count. It then performs a similar SELECT query on the research_projects table to count the number of rows where the principal_investigator_id column matches faculty_id_param, storing the result in project_count. Next, it executes a SELECT query on the academic_milestones table to count the number of rows where the faculty_id column matches faculty_id_param, storing the result in milestone_count.\n\nThe function then calculates the base_score by multiplying publication_count by 3.5, project_count by 2.8, and milestone_count by 1.2, and summing these products.\n\nTo determine the experience multiplier, the function retrieves the hiring_date from the faculty_members table for the given faculty_id_param, storing it in hiring_date_val. It calculates years_of_experience by extracting the year from the current date and subtracting the year part of hiring_date_val, assuming hiring_date_val is in a text format that can be cast to a date. Using a conditional IF statement, the function sets experience_multiplier based on years_of_experience: if years_of_experience is greater than 20, set experience_multiplier to 1.5; else if years_of_experience is greater than 10, set experience_multiplier to 1.3; else if years_of_experience is greater than 5, set experience_multiplier to 1.1; otherwise, set experience_multiplier to 1.0.\n\nThe function then checks the tenure_status in the faculty_members table for the given faculty_id_param. If tenure_status is equal to 1, it sets tenure_bonus to 0.15 times the base_score; otherwise, it sets tenure_bonus to 0.\n\nNext, the function calculates the leadership_bonus by initializing it to 0 and then checking three conditions sequentially. It performs a SELECT query on the research_groups table to check if there is at least one row where the leader_id column matches faculty_id_param; if such a row exists, it adds 5 to leadership_bonus. It then performs a SELECT query on the departments table to check if there is at least one row where the department_head_id column matches faculty_id_param; if such a row exists, it adds 8 to leadership_bonus. Finally, it performs a SELECT query on the schools table to check if there is at least one row where the dean_id column matches faculty_id_param; if such a row exists, it adds 12 to leadership_bonus.\n\nThe function computes the total_score by multiplying the base_score by the experience_multiplier, then adding the tenure_bonus and the leadership_bonus. It rounds the total_score up to two decimal places using the ceil function with scaling.\n\nFinally, the function returns the rounded total_score as the result.",
    "original_summary": "Create a PL/pgSQL function named calculate_faculty_productivity_score that takes a faculty ID (bigint) and returns a real number. The function calculates a score based on the faculty member's publication count (weight 3.5), project count (weight 2.8), and milestone count (weight 1.2). It applies an experience multiplier (1.1 for >5 years, 1.3 for >10, 1.5 for >20), adds a 15% tenure bonus if applicable, and adds leadership bonuses (5 for group leader, 8 for department head, 12 for dean). The final score is rounded up to two decimal places.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Calculate a faculty productivity score for a given faculty ID. Use the following formula: multiply the publication count by 3.5, the project count by 2.8, and the milestone count by 1.2. Apply an experience multiplier (1.1 for over 5 years, 1.3 for over 10, 1.5 for over 20). Add a 15% tenure bonus if applicable. Then, add leadership bonuses (5 for group leader, 8 for department head, 12 for dean). Finally, round the final score up to two decimal places."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_player_game_stats` that is designed to retrieve specific game statistics for a given player. This function accepts a single input parameter named `player_id_input`, which is of type `text`. The function is defined to return a set of rows, effectively acting as a table, with each row containing the following columns: `stat_id` of type `bigint`, `game_id` of type `bigint`, `mp` (minutes played) of type `real`, `pts` (points) of type `bigint`, `reb` (rebounds) of type `bigint`, and `ast` (assists) of type `bigint`. The core operation of this function involves executing a `SELECT` statement. This `SELECT` statement retrieves data from the `player_game_stats` table, aliased as `pgs`. Specifically, it selects the `stat_id`, `game_id`, `mp`, `pts`, `reb`, and `ast` columns from this table. The selection of rows is filtered by a `WHERE` clause, which ensures that only those rows where the `player_id` column in the `player_game_stats` table matches the value provided by the `player_id_input` parameter are included in the result set. The `RETURN QUERY` statement then returns the entire result set generated by this `SELECT` statement as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_game_stats(player_id_input text)\nRETURNS TABLE(stat_id bigint, game_id bigint, mp real, pts bigint, reb bigint, ast bigint) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT pgs.stat_id, pgs.game_id, pgs.mp, pgs.pts, pgs.reb, pgs.ast\n    FROM player_game_stats pgs\n    WHERE pgs.player_id = player_id_input;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "basketball_player_performance_and_team_statistics_758396",
    "tables": [
      "games",
      "player_game_stats",
      "players"
    ],
    "call_sqls": [
      "SELECT * FROM get_player_game_stats('0');",
      "SELECT * FROM get_player_game_stats('1');",
      "SELECT * FROM get_player_game_stats('some_player_id');",
      "SELECT * FROM get_player_game_stats('another_player_id');",
      "SELECT * FROM get_player_game_stats('player_id_xyz');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_player_game_stats that, given a player_id, retrieves and returns all game statistics for that specific player from the player_game_stats table, including the stat_id, game_id, mp, pts, reb, and ast for each record.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called get_player_game_stats? It should take a player's ID as text and return a table with columns: stat_id as a bigint, game_id as a bigint, mp as a real number, pts as a bigint, reb as a bigint, and ast as a bigint. Basically, just fetch all the game stats for that specific player from the player_game_stats table.",
    "id": 79,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_player_game_stats that accepts a single input parameter p_player_id of type TEXT, which corresponds to the player's ID, and returns a table with six columns: stat_id of type BIGINT, game_id of type BIGINT, mp of type REAL, pts of type BIGINT, reb of type BIGINT, and ast of type BIGINT. The function executes a SELECT query on the player_game_stats table, retrieving the stat_id, game_id, mp, pts, reb, and ast columns from all rows where the player_id column matches the input parameter p_player_id. The resulting rows are returned as the function's output, providing all game statistics for the specified player.",
    "original_summary": "Create a function named get_player_game_stats that takes a player_id (text) and returns a table with columns stat_id (bigint), game_id (bigint), mp (real), pts (bigint), reb (bigint), and ast (bigint). It returns all game statistics for the given player from the player_game_stats table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a function called get_player_game_stats? It should take a player's ID (as text) and spit back a table. The table needs to have these columns: stat_id (as a bigint), game_id (bigint), mp (real number), pts (bigint), reb (bigint), and ast (bigint). Basically, just fetch all the game stats for that specific player from the player_game_stats table."
  },
  {
    "ir": "Write a PLpgSQL function that takes a single parameter p_participant_id of type bigint and returns a bigint. The function's purpose is to calculate and return the count of adverse events associated with a specific participant. It performs a SELECT operation on the adverse_events table, specifically counting the number of rows where the participant_id column matches the provided p_participant_id parameter. The function does not perform any updates, inserts, or deletes, and it does not involve any conditional logic or special operations beyond the COUNT aggregate function. The function is defined using the plpgsql language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_participant_adverse_event_count(p_participant_id bigint) RETURNS bigint AS $$\nBEGIN\n    RETURN (SELECT COUNT(*) FROM adverse_events WHERE participant_id = p_participant_id);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "medical_research_and_clinical_trials",
    "tables": [
      "participants",
      "adverse_events",
      "concomitant_medications",
      "visits"
    ],
    "call_sqls": [
      "SELECT get_participant_adverse_event_count(0);",
      "SELECT get_participant_adverse_event_count(1);",
      "SELECT get_participant_adverse_event_count(10);",
      "SELECT get_participant_adverse_event_count(25);",
      "SELECT get_participant_adverse_event_count(100);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_participant_adverse_event_count that accepts a participant ID and returns the total number of adverse event records from the adverse_events table where the participant_id matches the provided input.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called get_participant_adverse_event_count that takes a participant's ID and spits back a bigint? Basically, I need it to count how many adverse event records in the 'adverse_events' table are tied to that specific participant.",
    "id": 80,
    "generated_ir": "Write a PLpgSQL function that takes a single parameter p_participant_id of type bigint and returns a bigint. The function's purpose is to calculate and return the count of adverse events associated with a specific participant. It performs a SELECT operation on the adverse_events table, specifically counting the number of rows where the participant_id column matches the provided p_participant_id parameter. The function does not perform any updates, inserts, or deletes, and it does not involve any conditional logic or special operations beyond the COUNT aggregate function. The function is defined using the plpgsql language.",
    "original_summary": "Create a PLpgSQL function that accepts a participant ID and returns a bigint count. The function returns the count of adverse event records in the adverse_events table where the participant_id matches the provided input parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PLpgSQL function that takes a participant's ID and spits back a bigint? Basically, I need it to count how many adverse event records in the 'adverse_events' table are tied to that specific participant."
  },
  {
    "ir": "Write a PL/pgSQL function named `get_income_by_marital_status` that accepts a single input parameter, `p_marital_status`, which is of type `TEXT`. This function is designed to retrieve and return a single `TEXT` value representing an income. The core operation of the function involves executing a `SELECT` statement against the `demographic_data` table. Within this `SELECT` statement, the function retrieves the `income` column. Before returning the `income` value, two transformations are applied: first, the `TRIM()` function is used to remove any leading or trailing whitespace characters from the `income` string, and then the `UPPER()` function converts the entire trimmed `income` string to uppercase. The selection of the row from `demographic_data` is based on a `WHERE` clause that compares the `marital_status` column in the table with the input parameter `p_marital_status`. Specifically, both the `marital_status` column from the table and the `p_marital_status` input parameter are converted to lowercase using the `LOWER()` function before the comparison is made, ensuring a case-insensitive match. To ensure that only one `income` value is returned, the `LIMIT 1` clause is applied to the `SELECT` statement, which restricts the output to the first row that satisfies the `WHERE` condition. The function then returns this single, uppercase, and trimmed `income` string.",
    "plsql": "CREATE OR REPLACE FUNCTION get_income_by_marital_status(p_marital_status TEXT)\nRETURNS TEXT AS $$\nBEGIN\n    RETURN (SELECT UPPER(TRIM(income)) FROM demographic_data WHERE LOWER(marital_status) = LOWER(p_marital_status) LIMIT 1);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "demographic_and_socioeconomic_data_analysis_317338",
    "tables": [
      "demographic_data",
      "marital_statuses",
      "occupations",
      "relationships"
    ],
    "call_sqls": [
      "SELECT get_income_by_marital_status('Married-civ-spouse');",
      "SELECT get_income_by_marital_status('Never-married');",
      "SELECT get_income_by_marital_status('Divorced');",
      "SELECT get_income_by_marital_status('Separated');",
      "SELECT get_income_by_marital_status('Widowed');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_income_by_marital_status that, given a marital status as input, retrieves the corresponding income from the demographic_data table where the marital_status matches the input (case-insensitively), selects only the first matching row, and returns that income value with any leading/trailing whitespace removed and converted to uppercase.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_income_by_marital_status that, given a marital status text, returns a single income text. It should retrieve one income from the demographic_data table where the marital_status matches the provided input in a case-insensitive manner, then return that income after trimming any extra spaces and converting it to uppercase.",
    "id": 81,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_income_by_marital_status that accepts one input parameter: a parameter named marital_status_input of type TEXT, which is used to specify a marital status value for filtering records. The function returns a single value of type TEXT, representing an income category. The function first declares a variable named income_result of type TEXT to store the retrieved income value. It then executes a SELECT query on the demographic_data table to retrieve the income column value for one row where the marital_status column matches the provided marital_status_input parameter in a case-insensitive manner; this is achieved by using the ILIKE operator to compare the marital_status column with the marital_status_input parameter. The query limits the result to one row using the LIMIT 1 clause. The retrieved income value is assigned to the income_result variable. After retrieval, the function applies two string transformations to the income_result: first, it trims any leading or trailing spaces using the TRIM function, and second, it converts the trimmed value to uppercase using the UPPER function. The transformed value is then returned as the function's output. If no matching row is found, the function returns NULL.",
    "original_summary": "Create a function named get_income_by_marital_status that takes a marital_status text parameter and returns a single text income value. Select the income from the demographic_data table where the lowercased marital_status column matches the lowercased input parameter, limit to one row. Return the selected income value after trimming whitespace and converting it to uppercase.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function called get_income_by_marital_status that, given a marital status text, gives back a single income text. It should look in the demographic_data table for entries where the marital status kind of matches the provided input, ignoring case differences, and just pick one result. Return that income after cleaning it up a bit and making it all uppercase."
  },
  {
    "ir": "Write a PostgreSQL PLpgSQL function named convert_country_name_to_utf8 that accepts a single input parameter p_country_id of type bigint, which is used to identify a specific country record, and returns a value of type text. The function begins by declaring a local variable v_country_name of type text to store an intermediate result. It then executes a SELECT statement to query the countries table, specifically retrieving the value from the country_name column for the row where the country_id column exactly matches the provided input parameter p_country_id, and assigns this retrieved value into the local variable v_country_name. Following this data retrieval, the function performs a nested character set conversion: it first calls the convert_to function, passing the v_country_name variable and the string 'ISO_8859_1' as arguments, which encodes the text from the variable into a byte array using the ISO-8859-1 character encoding. The result of this convert_to operation is then immediately passed as the first argument to the convert_from function, with the second argument being the string 'UTF8', which decodes the provided byte array back into a text string using the UTF-8 character encoding. The final result of this convert_from operation, which is the country name text converted from ISO-8859-1 to UTF-8 encoding, is then returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION convert_country_name_to_utf8(p_country_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_country_name text;\nBEGIN\n    SELECT country_name INTO v_country_name\n    FROM countries\n    WHERE country_id = p_country_id;\n    \n    RETURN convert_from(convert_to(v_country_name, 'ISO_8859_1'), 'UTF8');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "fashion_size_chart_and_measurement_standards",
    "tables": [
      "countries",
      "measurement_guidelines",
      "measurements",
      "product_lines",
      "regions",
      "size_charts",
      "size_issues"
    ],
    "call_sqls": [
      "SELECT convert_country_name_to_utf8(0);",
      "SELECT convert_country_name_to_utf8(1);",
      "SELECT convert_country_name_to_utf8(2);",
      "SELECT convert_country_name_to_utf8(3);",
      "SELECT convert_country_name_to_utf8(4);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named convert_country_name_to_utf8 that, given a country_id, retrieves the corresponding country_name from the countries table and returns it converted from ISO_8859_1 encoding to UTF8 encoding.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named convert_country_name_to_utf8 that takes a country_id and returns the corresponding country_name from the countries table, converting the text encoding from ISO_8859_1 to UTF8.",
    "id": 82,
    "generated_ir": "Write a PostgreSQL PLpgSQL function named convert_country_name_to_utf8 that accepts a single input parameter p_country_id of type bigint, which is used to identify a specific country record, and returns a value of type text. The function begins by declaring a local variable v_country_name of type text to store an intermediate result. It then executes a SELECT statement to query the countries table, specifically retrieving the value from the country_name column for the row where the country_id column exactly matches the provided input parameter p_country_id, and assigns this retrieved value into the local variable v_country_name. Following this data retrieval, the function performs a nested character set conversion: it first calls the convert_to function, passing the v_country_name variable and the string 'ISO_8859_1' as arguments, which encodes the text from the variable into a byte array using the ISO-8859-1 character encoding. The result of this convert_to operation is then immediately passed as the first argument to the convert_from function, with the second argument being the string 'UTF8', which decodes the provided byte array back into a text string using the UTF-8 character encoding. The final result of this convert_from operation, which is the country name text converted from ISO-8859-1 to UTF-8 encoding, is then returned as the output of the function.",
    "original_summary": "Create a function named convert_country_name_to_utf8 that takes a bigint country_id and returns text. It retrieves the country_name for the given ID from the countries table and converts it from ISO_8859_1 to UTF8 encoding before returning.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Function convert_country_name_to_utf8: takes country_id (bigint), returns text. Fetch country_name for that ID from countries, convert from ISO_8859_1 to UTF8, return it."
  },
  {
    "ir": "Write a PLpgSQL function named calculate_log_rmse_ratio that accepts a single input parameter p_model_id of type bigint, which is used to identify a specific model, and returns a value of type real; the function declares a local variable log_ratio of type real, then executes a SELECT query that retrieves exactly one row from the performances table by applying a condition where the model_id column equals the provided p_model_id parameter, and from that row, it calculates the natural logarithm (using the ln function) of the division of the rmse column value cast to double precision by the cost column value also cast to double precision, storing the result of this calculation into the log_ratio variable, and finally returns the value stored in the log_ratio variable as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_log_rmse_ratio(p_model_id bigint)\nRETURNS real AS $$\nDECLARE\n    log_ratio real;\nBEGIN\n    SELECT ln(rmse::double precision / cost::double precision) INTO log_ratio FROM performances WHERE model_id = p_model_id LIMIT 1;\n    RETURN log_ratio;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "machine_learning_model_performance_metrics_773034",
    "tables": [
      "models",
      "performances",
      "versions"
    ],
    "call_sqls": [
      "SELECT calculate_log_rmse_ratio(0);",
      "SELECT calculate_log_rmse_ratio(1);",
      "SELECT calculate_log_rmse_ratio(10);",
      "SELECT calculate_log_rmse_ratio(model_id) FROM models WHERE model_name = 'Model A';",
      "SELECT m.model_id, m.model_name, calculate_log_rmse_ratio(m.model_id) FROM models m WHERE m.status = 'production';"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `calculate_log_rmse_ratio` that, for a given model ID, retrieves the corresponding rmse and cost values from the `performances` table, calculates the natural logarithm of the ratio (rmse divided by cost), and returns this calculated log ratio as a real number.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named `calculate_log_rmse_ratio` that, for a given model ID, retrieves the corresponding RMSE and cost values from the performances table, computes the natural logarithm of the ratio (RMSE divided by cost), and returns this calculated real value.",
    "id": 83,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named calculate_log_rmse_ratio that accepts a single input parameter p_model_id of type bigint and returns a real value. The function declares a local variable v_rmse of type real and a local variable v_cost of type real. It performs a SELECT operation on the performances table to retrieve the rmse column value and the cost column value for the row where the model_id column matches the input parameter p_model_id, storing these values into the v_rmse and v_cost variables respectively. The function then computes the natural logarithm of the ratio of v_rmse divided by v_cost using the ln function, casting the result to real, and returns this computed value.",
    "original_summary": "Create a function named `calculate_log_rmse_ratio` that takes a `bigint` model ID and returns a `real`. It calculates and returns the natural logarithm of (rmse / cost) from the `performances` table for the specified model.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Calculate and return the natural logarithm of (rmse / cost) for the specified model ID from the performances table. Create a function named `calculate_log_rmse_ratio` that takes a `bigint` model ID and returns a `real`."
  },
  {
    "ir": "Write a PLpgSQL function named get_security_audit_schedule that accepts an integer parameter days_ahead and returns a table with columns county_name of type TEXT, fips_code of type BIGINT, next_audit_date of type TEXT, days_until_audit of type INTEGER, and audit_priority of type TEXT. The function begins by declaring a variable current_date_str of type TEXT and assigns it the value '2020-11-15'. It also declares a variable audit_date_interval of type INTERVAL, although this variable is not used further in the function. The function then executes a RETURN QUERY statement that performs a SELECT operation to retrieve data from the counties table and the election_security table, which are joined on the fips column. The SELECT statement retrieves the name column from the counties table as county_name, the fips column from the counties table as fips_code, and the next_audit_date column from the election_security table. It calculates the days_until_audit column using a CASE statement that checks the difference between the next_audit_date and current_date_str, both cast to DATE type, and assigns values of 15, 45, 75, or 120 based on whether the difference is less than or equal to 30, 60, 90, or greater than 90 days, respectively. Another CASE statement determines the audit_priority column, assigning 'High Priority', 'Medium Priority', 'Low Priority', or 'Future Planning' based on the same date difference conditions. The WHERE clause filters the results to include only rows where the difference between next_audit_date and current_date_str is less than or equal to the days_ahead parameter. The results are ordered by the next_audit_date column cast to DATE type.",
    "plsql": "CREATE OR REPLACE FUNCTION get_security_audit_schedule(days_ahead INTEGER) RETURNS TABLE (\n  county_name TEXT,\n  fips_code BIGINT,\n  next_audit_date TEXT,\n  days_until_audit INTEGER,\n  audit_priority TEXT\n) AS $$\nDECLARE\n  current_date_str TEXT;\n  audit_date_interval INTERVAL;\nBEGIN\n  current_date_str := '2020-11-15';\n  \n  RETURN QUERY\n  SELECT \n    c.name,\n    c.fips,\n    es.next_audit_date,\n    CASE \n      WHEN es.next_audit_date::DATE - current_date_str::DATE <= 30 THEN 15\n      WHEN es.next_audit_date::DATE - current_date_str::DATE <= 60 THEN 45\n      WHEN es.next_audit_date::DATE - current_date_str::DATE <= 90 THEN 75\n      ELSE 120\n    END,\n    CASE \n      WHEN es.next_audit_date::DATE - current_date_str::DATE <= 30 THEN 'High Priority'\n      WHEN es.next_audit_date::DATE - current_date_str::DATE <= 60 THEN 'Medium Priority'\n      WHEN es.next_audit_date::DATE - current_date_str::DATE <= 90 THEN 'Low Priority'\n      ELSE 'Future Planning'\n    END\n  FROM counties c\n  JOIN election_security es ON c.fips = es.fips\n  WHERE es.next_audit_date::DATE - current_date_str::DATE <= days_ahead\n  ORDER BY es.next_audit_date::DATE;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "election_results_and_data_management",
    "tables": [
      "absentee_votes",
      "counties",
      "election_security",
      "precinct_reporting",
      "public_reports",
      "voter_turnout"
    ],
    "call_sqls": [
      "SELECT * FROM get_security_audit_schedule(30);",
      "SELECT * FROM get_security_audit_schedule(60);",
      "SELECT * FROM get_security_audit_schedule(90);",
      "SELECT * FROM get_security_audit_schedule(120);",
      "SELECT * FROM get_security_audit_schedule(365);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_security_audit_schedule that takes an integer parameter days_ahead and returns a table with columns county_name, fips_code, next_audit_date, days_until_audit, and audit_priority. Using a fixed current date of '2020-11-15', join the counties and election_security tables on fips. For each county, calculate the days until the next audit from the election_security table and assign a priority of 'High Priority' if within 30 days, 'Medium Priority' if within 60 days, 'Low Priority' if within 90 days, or 'Future Planning' otherwise, with corresponding days_until_audit values of 15, 45, 75, or 120. Retrieve only records where the next audit is within the specified days_ahead, and order the results by the next_audit_date.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_security_audit_schedule that takes a number of days, days_ahead, and returns a list showing for each county its name from counties, its FIPS code, the next audit date from election_security, the number of days until that audit, and a priority label based on how soon the audit is. Use a fixed current date. Only include audits scheduled within the given days_ahead, and sort the results by the audit date.",
    "id": 84,
    "generated_ir": "Write a PLpgSQL function named get_security_audit_schedule that takes a single input parameter days_ahead of type integer, representing the number of days into the future to consider for upcoming security audits. The function returns a table with five columns: county_name of type text, fips of type bigint, next_audit_date of type text, days_until_audit of type integer, and priority_label of type text.\n\nThe function begins by declaring a constant variable v_current_date of type date, which is fixed to the date '2024-01-01'. It then executes a SELECT query that retrieves data from the counties table, aliased as c, and the election_security table, aliased as es. The tables are joined using an INNER JOIN on the condition that the fips column in the counties table matches the fips column in the election_security table.\n\nThe SELECT statement includes the following columns in its output: the name column from the counties table as county_name, the fips column from the counties table, the next_audit_date column from the election_security table, and two calculated columns. The first calculated column, days_until_audit, is computed by subtracting v_current_date from the next_audit_date column cast to a date type. The second calculated column, priority_label, is derived using a CASE statement: if days_until_audit is less than or equal to 7, the label is 'HIGH'; if days_until_audit is between 8 and 30 inclusive, the label is 'MEDIUM'; otherwise, the label is 'LOW'.\n\nThe query includes a WHERE clause that filters the results to only include rows where the next_audit_date column, when cast to a date, is between v_current_date and v_current_date plus the input parameter days_ahead. This ensures only audits scheduled within the specified future window are included. The results are then sorted in ascending order by the next_audit_date column cast to a date.\n\nThe function is defined using the PLpgSQL language and is designed to provide a prioritized schedule of upcoming security audits for all counties based on a fixed current date.",
    "original_summary": "Create a function named get_security_audit_schedule that takes an integer days_ahead and returns a table with columns county_name, fips_code, next_audit_date, days_until_audit, and audit_priority. Using a fixed current date, join counties and election_security tables. For each county, calculate days until the next audit and assign a priority based on that interval. Filter results where the audit is within the specified days_ahead and order by the audit date.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Alright, so I need you to whip up a function called get_security_audit_schedule. It's gonna take a number, days_ahead, and spit out a list with stuff like the county name, its FIPS code, when the next audit's happening, how many days until then, and how urgent it is. Here's the deal: we'll pretend today's date is fixed. We gotta look at the counties and election_security info together. For every county, figure out how long until their next audit and slap a priority label on it based on that wait time. Only show me the audits that are coming up within the number of days I gave you, and sort the whole list by the audit date."
  },
  {
    "ir": "Write a PLpgSQL function named get_customer_age that accepts a single parameter p_customer_id of type BIGINT, which represents the unique identifier of a customer. The function aims to calculate the age of the customer based on their date of birth stored in the customers table. Within the function, declare a local variable v_date_of_birth of type TIMESTAMP to hold the customer's date of birth. Execute a SELECT statement to retrieve the date_of_birth column from the customers table, where the customer_id matches the provided p_customer_id parameter. Convert the retrieved date_of_birth, which is stored as a string in 'YYYY-MM-DD' format, into a TIMESTAMP using the TO_TIMESTAMP function, and store the result in the v_date_of_birth variable. After obtaining the date of birth as a TIMESTAMP, calculate the age by using the age function, which computes the interval between the current date and the v_date_of_birth, and return this interval as the function's result.",
    "plsql": "CREATE OR REPLACE FUNCTION get_customer_age(p_customer_id BIGINT) RETURNS INTERVAL AS $$\nDECLARE\n    v_date_of_birth TIMESTAMP;\nBEGIN\n    SELECT TO_TIMESTAMP(c.date_of_birth, 'YYYY-MM-DD') INTO v_date_of_birth\n    FROM customers c\n    WHERE c.customer_id = p_customer_id;\n    RETURN age(v_date_of_birth);\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_commerce_order_management_and_sales_analytics",
    "tables": [
      "customers",
      "orders",
      "order_items",
      "products",
      "feedback",
      "returns",
      "shipping"
    ],
    "call_sqls": [
      "SELECT get_customer_age(1);",
      "SELECT get_customer_age(2);",
      "SELECT get_customer_age(3);",
      "SELECT get_customer_age(4);",
      "SELECT get_customer_age(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_customer_age that accepts a customer ID and returns the customer's age as an interval by retrieving their date of birth from the customers table and calculating it based on the current date.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called get_customer_age? It should take a p_customer_id and return an INTERVAL showing the customer's age. Basically, it needs to retrieve the customer's date_of_birth from the customers table, convert it to a TIMESTAMP, and calculate how old they are based on today's date.",
    "id": 85,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_customer_age that accepts a single input parameter, p_customer_id, which is of type bigint. The function returns a value of type INTERVAL, representing the calculated age of the customer. Inside the function, a local variable v_date_of_birth of type TIMESTAMP is declared to temporarily store the converted date of birth value. The function then executes a SELECT statement to query the customers table. Specifically, it selects the date_of_birth column for the row where the customer_id column matches the value provided in the p_customer_id input parameter. The date_of_birth column in the customers table is of type text, so the selected value is explicitly cast to a TIMESTAMP using the PostgreSQL ::TIMESTAMP syntax, and this result is assigned to the v_date_of_birth variable. Following this, the function calculates the age by using the PostgreSQL AGE() function. The AGE() function is called with the current date and time, obtained via the CURRENT_DATE function, as its first argument and the v_date_of_birth timestamp as its second argument. This AGE(CURRENT_DATE, v_date_of_birth) expression computes the interval between the two dates, resulting in the customer's age as an INTERVAL data type. Finally, the function returns this calculated INTERVAL value.",
    "original_summary": "Create a PL/pgSQL function named get_customer_age that accepts a p_customer_id (BIGINT) parameter and returns an INTERVAL. The function retrieves the customer's date of birth from the customers table, converts it to TIMESTAMP, and calculates their age using the current date.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/pgSQL function called get_customer_age? It should take a p_customer_id (that's a BIGINT) and spit back an INTERVAL. Basically, it needs to grab the customer's birthday from the customers table, turn that into a TIMESTAMP, and then figure out how old they are based on today's date."
  },
  {
    "ir": "Write a PLpgSQL function named consolidate_category_values that accepts four parameters: p_category_id of type bigint, p_year of type bigint, p_quarter_id of type bigint, and p_currency of type text. The function aims to calculate the total financial value for a specific category of financial instruments within a given year, quarter, and currency. It begins by declaring a numeric variable v_total initialized to zero, which will accumulate the total value. The function then iterates over each record in the financial_instruments table where the category column matches the provided p_category_id. For each instrument_id obtained from this selection, the function performs a nested query on the financial_values table, selecting the value column where the instrument_id matches the current instrument_id from the loop, and the year, quarter, and currency columns match the respective parameters p_year, p_quarter_id, and p_currency. The value retrieved from this query is cast to a numeric type and added to the v_total variable. After processing all relevant records, the function returns the accumulated total value as a text type by casting v_total to text.",
    "plsql": "CREATE OR REPLACE FUNCTION consolidate_category_values(p_category_id bigint, p_year bigint, p_quarter_id bigint, p_currency text)\nRETURNS text\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_total numeric := 0;\n    v_instrument_record RECORD;\nBEGIN\n    FOR v_instrument_record IN\n        SELECT instrument_id\n        FROM financial_instruments\n        WHERE category = p_category_id\n    LOOP\n        SELECT v_total + CAST(value AS numeric) INTO v_total\n        FROM financial_values\n        WHERE instrument_id = v_instrument_record.instrument_id\n          AND year = p_year\n          AND quarter = p_quarter_id\n          AND currency = p_currency;\n    END LOOP;\n\n    RETURN v_total::text;\nEND;\n$$;",
    "database_name": "banking_and_financial_management_95020",
    "tables": [
      "financial_reports",
      "financial_instruments",
      "financial_values",
      "report_details",
      "categories",
      "quarters",
      "users"
    ],
    "call_sqls": [
      "SELECT consolidate_category_values(1, 2023, 1, 'USD');",
      "SELECT consolidate_category_values(2, 2023, 2, 'EUR');",
      "SELECT consolidate_category_values(1, 2022, 4, 'USD');",
      "SELECT consolidate_category_values(3, 2023, 3, 'GBP');",
      "SELECT consolidate_category_values(0, 2024, 1, 'USD');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `consolidate_category_values` that calculates and returns the total financial value as text for all instruments in a specified category from the financial_instruments table, for a given year, quarter, and currency, by summing the corresponding values from the financial_values table.",
    "natural_language": "Hey, can you whip up a PostgreSQL PL/pgSQL function called `consolidate_category_values` that figures out and spits back the total worth (as text) for all the financial stuff in a specific category, for a given year, quarter, and currency? Basically, it needs to add up the values from the financial_values table for every instrument in the financial_instruments table that matches the provided category, year, quarter, and currency.",
    "id": 86,
    "generated_ir": "Write a PLpgSQL function named consolidate_category_values that accepts four parameters: p_category_id of type bigint, p_year of type bigint, p_quarter_id of type bigint, and p_currency of type text. The function aims to calculate the total financial value for a specific category of financial instruments within a given year, quarter, and currency. It begins by declaring a numeric variable v_total initialized to zero, which will accumulate the total value. The function then iterates over each record in the financial_instruments table where the category column matches the provided p_category_id. For each instrument_id obtained from this selection, the function performs a nested query on the financial_values table, selecting the value column where the instrument_id matches the current instrument_id from the loop, and the year, quarter, and currency columns match the respective parameters p_year, p_quarter_id, and p_currency. The value retrieved from this query is cast to a numeric type and added to the v_total variable. After processing all relevant records, the function returns the accumulated total value as a text type by casting v_total to text.",
    "original_summary": "Create a PL/pgSQL function named `consolidate_category_values` that calculates and returns the total value (as text) for all financial instruments within a specified category, for a given year, quarter, and currency. It sums the values from the financial_values table for each instrument in the category that matches the criteria.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Hey, can you whip up a PL/pgSQL function called `consolidate_category_values`? It should figure out and spit back the total worth (as text) for all the financial stuff in a specific category, for a given year, quarter, and currency. Basically, it needs to add up the values from the financial_values table for every instrument in that category that fits the bill."
  },
  {
    "ir": "Write a PL/pgSQL function named `calculate_total_sales` that accepts a single input parameter, `p_customer_id`, which is of type `BIGINT` and represents the unique identifier for a customer. This function is designed to compute and return the aggregate sales amount for the specified customer. Internally, the function declares a local variable named `v_total_sales` of type `REAL` to temporarily store the calculated total sales. The core operation involves executing a `SELECT` statement to retrieve data from the `orders` table, aliased as `o`. Specifically, it calculates the `SUM` of the `sales` column from the `orders` table. To handle cases where no sales records are found for the given `p_customer_id`, the `COALESCE` function is applied to the `SUM(o.sales)` result, ensuring that if the sum is `NULL` (meaning no matching orders were found), it defaults to `0`. The result of this `SELECT` statement, which is either the sum of sales or `0`, is then assigned to the `v_total_sales` variable. The `SELECT` statement includes a `WHERE` clause that filters the `orders` table, considering only those rows where the `customer_id` column in the `orders` table (`o.customer_id`) is equal to the value provided in the input parameter `p_customer_id`. Finally, the function returns the value stored in the `v_total_sales` variable, which represents the total sales for the customer identified by `p_customer_id`.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_total_sales(p_customer_id BIGINT) RETURNS REAL AS $$\nDECLARE\n    v_total_sales REAL;\nBEGIN\n    SELECT COALESCE(SUM(o.sales), 0) INTO v_total_sales\n    FROM orders o\n    WHERE o.customer_id = p_customer_id;\n    RETURN v_total_sales;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "e_commerce_order_management_and_sales_analytics",
    "tables": [
      "customers",
      "orders",
      "order_items",
      "products",
      "feedback",
      "returns",
      "shipping"
    ],
    "call_sqls": [
      "SELECT calculate_total_sales(1001);",
      "SELECT calculate_total_sales(2047);",
      "SELECT calculate_total_sales(305);",
      "SELECT calculate_total_sales(892);",
      "SELECT calculate_total_sales(1563);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_total_sales that, given a customer ID as input, returns the total sales amount for that customer from the ORDERS table, returning 0 if no sales are found.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_total_sales that takes a p_customer_id parameter to identify a customer and returns a REAL value representing the total sales amount for that customer from the orders table, returning 0 when there are no sales.",
    "id": 87,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `calculate_total_sales` that accepts a single input parameter, `p_customer_id`, which is of type `bigint`. This function is designed to return a `REAL` value representing the total sales amount for a specific customer. The function declares a local variable named `v_total_sales` of type `REAL` to store the calculated total. The core logic of the function involves executing a `SELECT` statement to compute this total. This `SELECT` statement retrieves data from the `orders` table. The `WHERE` clause filters the records, specifically selecting only those where the `customer_id` column from the `orders` table matches the input parameter `p_customer_id`. For the selected records, the `SUM` aggregate function is applied to the `sales` column from the `orders` table. The calculated total is then stored into the `v_total_sales` local variable. Finally, the function returns the value of `v_total_sales`. To handle cases where no sales are found for the given customer (which would result in `v_total_sales` being `NULL`), the `COALESCE` function is used to return `0` instead of `NULL` in such scenarios.",
    "original_summary": "Create a PL/pgSQL function named calculate_total_sales that accepts a p_customer_id (BIGINT) parameter and returns a REAL value. The function calculates the total sales amount for the given customer from the orders table, returning 0 if no sales are found.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called calculate_total_sales that takes a p_customer_id parameter of type BIGINT and returns a REAL. Make it compute the total sales amount for the specified customer from the orders table, and return 0 when there are no sales."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_player_position` that accepts a single input parameter named `player_id_input` of data type `text`. This function is designed to return a single value of data type `text`. Upon execution, the function declares a local variable named `position` of data type `text`. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `position` column of the `players` table. The retrieved value is then assigned to the local variable `position`. The `SELECT` statement includes a `WHERE` clause that filters the rows from the `players` table. The condition in the `WHERE` clause specifies that only rows where the value in the `player_id` column is equal to the value provided by the `player_id_input` parameter are considered. Finally, the function returns the value currently stored in the `position` local variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_player_position(player_id_input text)\nRETURNS text AS $$\nDECLARE\n    position text;\nBEGIN\n    SELECT players.position INTO position\n    FROM players\n    WHERE player_id = player_id_input;\n    RETURN position;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "basketball_player_performance_and_team_statistics_758396",
    "tables": [
      "games",
      "player_game_stats",
      "players"
    ],
    "call_sqls": [
      "SELECT get_player_position('0');",
      "SELECT get_player_position('1');",
      "SELECT get_player_position('2');",
      "SELECT get_player_position('3');",
      "SELECT get_player_position('4');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_player_position` that, given a `player_id_input`, retrieves and returns the `position` from the `players` table for the matching `player_id`.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `get_player_position` that, given a `player_id_input`, retrieves and returns the `position` from the `players` table for the player with the matching `player_id`.",
    "id": 88,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_player_position that accepts a single input parameter named player_id_input of data type text, which corresponds to the player identifier. The function is designed to return a text value representing the player's position. The function begins by declaring a variable to hold the retrieved position value, though this is implicit in the RETURN statement. The core operation involves executing a SELECT statement to query the players table. Specifically, it selects the position column from the players table where the player_id column matches the provided player_id_input parameter. This SELECT statement is executed directly within a RETURN QUERY or a SELECT INTO context to return the single text value. The function then returns the retrieved position value as a text output. If no matching player is found, the function will return NULL.",
    "original_summary": "Create a PL/pgSQL function named `get_player_position` that takes a `text` parameter `player_id_input` and returns a `text` value. The function should select the `position` from the `players` table where `player_id` equals the input parameter and return that value.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called `get_player_position` that accepts a `text` parameter named `player_id_input` and returns a `text`. The function must retrieve and return the `position` from the `players` table for the row where the `player_id` matches the provided input parameter."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_individual_access_summary that returns a table with three columns of text type: access_date, access_type, and device_type; this function accepts a single input parameter named p_individual_id of type bigint, which is used to filter records; the function executes a SELECT query on the access_logs table, specifically retrieving the access_date, access_type, and device_type columns from that table for all rows where the individual_id column in the access_logs table exactly matches the provided p_individual_id parameter value; the resulting rows are then ordered in descending sequence based on the values in the access_date column from the access_logs table, and this ordered result set is returned as the output of the function.",
    "plsql": "CREATE OR REPLACE FUNCTION get_individual_access_summary(p_individual_id bigint)\nRETURNS TABLE(access_date text, access_type text, device_type text) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT access_logs.access_date, access_logs.access_type, access_logs.device_type\n    FROM access_logs\n    WHERE access_logs.individual_id = p_individual_id\n    ORDER BY access_logs.access_date DESC;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "demographic_and_employment_data_analysis_192071",
    "tables": [
      "access_logs",
      "individuals",
      "users"
    ],
    "call_sqls": [
      "SELECT * FROM get_individual_access_summary(0);",
      "SELECT * FROM get_individual_access_summary(1);",
      "SELECT * FROM get_individual_access_summary(100);",
      "SELECT * FROM get_individual_access_summary(5);",
      "SELECT * FROM get_individual_access_summary(2);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_individual_access_summary` that, for a given individual ID, retrieves the access date, access type, and device type from the `access_logs` table, returning the results sorted by access date in descending order.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named `get_individual_access_summary` that, for a given individual ID, retrieves the access date, access type, and device type from the access_logs table, returning the results sorted by access date in descending order.",
    "id": 89,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_individual_access_summary` that accepts a single input parameter, `p_individual_id`, which is of type `bigint` and represents the unique identifier for an individual. This function is designed to return a table with three columns: `access_date` of type `text`, `access_type` of type `text`, and `device_type` of type `text`. The function will retrieve and return access log records specifically for the individual identified by the input parameter.\n\nThe function begins by declaring that it returns a table with the specified column types. No local variables are declared within the function body, as the result set is directly returned by a query.\n\nThe core operation of the function is a `SELECT` statement that queries the `access_logs` table. This `SELECT` statement performs the following actions:\n1. It selects the `access_date` column from the `access_logs` table.\n2. It selects the `access_type` column from the `access_logs` table.\n3. It selects the `device_type` column from the `access_logs` table.\n\nThe `FROM` clause specifies the source table as `access_logs`.\n\nThe `WHERE` clause filters the results to include only those rows where the `individual_id` column in the `access_logs` table matches the value of the input parameter `p_individual_id`. This ensures that only access logs associated with the specified individual are retrieved.\n\nThe `ORDER BY` clause sorts the resulting rows based on the `access_date` column. The sorting is done in descending order (`DESC`), meaning the most recent access dates will appear first in the output.\n\nThe function concludes by returning the result set of the `SELECT` statement directly. The returned table will contain all matching rows from the `access_logs` table, with each row providing the access date, access type, and device type for a single access event, ordered from the most recent to the oldest access date.",
    "original_summary": "Create a PL/pgSQL function named `get_individual_access_summary` that returns a table of `text` columns: `access_date`, `access_type`, and `device_type`. It takes an individual ID (`bigint`). The function selects those columns from the `access_logs` table for the given ID, ordering the results by `access_date` in descending order.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "List the access date, access type, and device type from the access_logs table for a specified individual ID, ordering the results by access date in descending order. Provide this as a PL/pgSQL function named `get_individual_access_summary`."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_category_crime_summary` that accepts one input parameter, `category_name_input`, which is of type `TEXT`. This function is designed to return a table containing two columns: `category_name` of type `TEXT` and `total_crimes` of type `BIGINT`. The function's primary purpose is to calculate the total number of crimes associated with a specific category, identified by the provided `category_name_input`.\n\nThe function begins its execution by initiating a `RETURN QUERY` statement, which signifies that the result of the subsequent `SELECT` statement will be returned directly as the function's output table.\n\nThe `SELECT` statement retrieves data by joining three tables: `categories`, `parks`, and `crime_statistics`.\n1. It selects the `category_name` column from the `categories` table, aliased as `c`.\n2. It calculates the sum of the `total_crimes` column from the `crime_statistics` table, aliased as `cs`. This sum is then explicitly cast to a `BIGINT` data type and aliased as `total_crimes` in the output.\n\nThe joins between these tables are performed as follows:\n1. An `INNER JOIN` is established between the `categories` table (`c`) and the `parks` table (`p`) on the condition that the `category_id` column in the `categories` table (`c.category_id`) is equal to the `category_id` column in the `parks` table (`p.category_id`). This links categories to the parks that belong to them.\n2. Another `INNER JOIN` is established between the `parks` table (`p`) and the `crime_statistics` table (`cs`) on the condition that the `park_id` column in the `parks` table (`p.park_id`) is equal to the `park_id` column in the `crime_statistics` table (`cs.park_id`). This links parks to their associated crime statistics.\n\nA `WHERE` clause is applied to filter the results. The condition for filtering is that the lowercase version of the `category_name` column from the `categories` table (`LOWER(c.category_name)`) must be equal to the lowercase version of the input parameter `category_name_input` (`LOWER(category_name_input)`). The `LOWER()` function is used on both sides of the comparison to ensure a case-insensitive match for the category name.\n\nFinally, the results are grouped by the `category_name` column from the `categories` table (`c.category_name`). This ensures that the `SUM(cs.total_crimes)` aggregation is performed for each distinct category name that matches the input.",
    "plsql": "CREATE OR REPLACE FUNCTION get_category_crime_summary(category_name_input TEXT) RETURNS TABLE(category_name TEXT, total_crimes BIGINT) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT c.category_name, SUM(cs.total_crimes)::BIGINT AS total_crimes\n    FROM categories c\n    JOIN parks p ON c.category_id = p.category_id\n    JOIN crime_statistics cs ON p.park_id = cs.park_id\n    WHERE LOWER(c.category_name) = LOWER(category_name_input)\n    GROUP BY c.category_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "urban_park_safety_and_crime_statistics_tracking",
    "tables": [
      "boroughs",
      "categories",
      "crime_categories",
      "crime_statistics",
      "crime_statistics_bridge",
      "parks"
    ],
    "call_sqls": [
      "SELECT * FROM get_category_crime_summary('ONE ACRE OR LARGER');",
      "SELECT * FROM get_category_crime_summary('SMALLER THAN ONE ACRE');",
      "SELECT * FROM get_category_crime_summary('One Acre Or Larger');",
      "SELECT * FROM get_category_crime_summary('Smaller Than One Acre');",
      "SELECT * FROM get_category_crime_summary('one acre or larger');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_category_crime_summary that, given a category name as input, retrieves the total number of crimes for that category by joining the categories, parks, and crime_statistics tables, where the category name matches the input case-insensitively, and returns the category name and the summed total crimes.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_category_crime_summary that returns a table with columns category_name and total_crimes, taking a category_name_input parameter. It should retrieve the total number of crimes for a specified category by joining the categories, parks, and crime_statistics tables, filtering where the category name matches the input case-insensitively, grouping by category_name, and summing the total_crimes.",
    "id": 90,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_category_crime_summary` that accepts one input parameter, `category_name_input`, which is of type `TEXT`. This function is designed to return a table containing two columns: `category_name` of type `TEXT` and `total_crimes` of type `BIGINT`. The function's primary purpose is to calculate the total number of crimes associated with a specific category, identified by the provided `category_name_input`.\n\nThe function begins its execution by initiating a `RETURN QUERY` statement, which signifies that the result of the subsequent `SELECT` statement will be returned directly as the function's output table.\n\nThe `SELECT` statement retrieves data by joining three tables: `categories`, `parks`, and `crime_statistics`.\n1. It selects the `category_name` column from the `categories` table, aliased as `c`.\n2. It calculates the sum of the `total_crimes` column from the `crime_statistics` table, aliased as `cs`. This sum is then explicitly cast to a `BIGINT` data type and aliased as `total_crimes` in the output.\n\nThe joins between these tables are performed as follows:\n1. An `INNER JOIN` is established between the `categories` table (`c`) and the `parks` table (`p`) on the condition that the `category_id` column in the `categories` table (`c.category_id`) is equal to the `category_id` column in the `parks` table (`p.category_id`). This links categories to the parks that belong to them.\n2. Another `INNER JOIN` is established between the `parks` table (`p`) and the `crime_statistics` table (`cs`) on the condition that the `park_id` column in the `parks` table (`p.park_id`) is equal to the `park_id` column in the `crime_statistics` table (`cs.park_id`). This links parks to their associated crime statistics.\n\nA `WHERE` clause is applied to filter the results. The condition for filtering is that the lowercase version of the `category_name` column from the `categories` table (`LOWER(c.category_name)`) must be equal to the lowercase version of the input parameter `category_name_input` (`LOWER(category_name_input)`). The `LOWER()` function is used on both sides of the comparison to ensure a case-insensitive match for the category name.\n\nFinally, the results are grouped by the `category_name` column from the `categories` table (`c.category_name`). This ensures that the `SUM(cs.total_crimes)` aggregation is performed for each distinct category name that matches the input.",
    "original_summary": "Create a PLpgSQL function named get_category_crime_summary that returns a table with columns category_name (TEXT) and total_crimes (BIGINT). It accepts a category_name_input (TEXT) parameter. The function returns a query that joins the categories, parks, and crime_statistics tables. Filter where the lowercase category_name matches the lowercase input. Group by category_name and sum the total_crimes.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PLpgSQL function get_category_crime_summary returning table(category_name TEXT, total_crimes BIGINT). It takes category_name_input TEXT. Join categories, parks, and crime_statistics. Filter where lower(category_name) equals lower(input). Group by category_name and sum total_crimes."
  },
  {
    "ir": "Write a PLpgSQL function named get_patient_medication_summary that accepts a single parameter p_patient_id of type bigint, which represents the unique identifier of a patient. The function aims to generate a textual summary of the medications associated with the specified patient. It begins by declaring a local variable v_summary of type text to store the resulting summary. The function executes a SELECT statement that concatenates the first name and last name of the patient, followed by the phrase 'takes', the count of medications, and the word 'medications'. This SELECT statement retrieves data from the patients table, aliased as p, and performs a LEFT JOIN operation with the medications table, aliased as m, using the condition that the patient_id column in the patients table matches the patient_id column in the medications table. The WHERE clause filters the results to include only the row where the patient_id in the patients table matches the input parameter p_patient_id. The GROUP BY clause groups the results by the first_name and last_name columns of the patients table to ensure the count of medications is calculated per patient. The result of the SELECT statement is stored into the v_summary variable. The function then returns the value of v_summary, using the COALESCE function to provide a default message 'Patient not found' in case v_summary is null, indicating that no matching patient was found or the patient has no medications. The function is defined using the plpgsql language.",
    "plsql": "CREATE OR REPLACE FUNCTION get_patient_medication_summary(p_patient_id bigint)\nRETURNS text AS $$\nDECLARE\n    v_summary text;\nBEGIN\n    SELECT CONCAT(first_name, ' ', last_name, ' takes ', COUNT(*), ' medications')\n    INTO v_summary\n    FROM patients p\n    LEFT JOIN medications m ON p.patient_id = m.patient_id\n    WHERE p.patient_id = p_patient_id\n    GROUP BY p.first_name, p.last_name;\n    RETURN COALESCE(v_summary, 'Patient not found');\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "healthcare_data_analysis_and_patient_outcomes",
    "tables": [
      "patients",
      "doctors",
      "billing",
      "medications"
    ],
    "call_sqls": [
      "SELECT get_patient_medication_summary(0);",
      "SELECT get_patient_medication_summary(1);",
      "SELECT get_patient_medication_summary(999);",
      "SELECT get_patient_medication_summary(NULL);",
      "SELECT get_patient_medication_summary(2);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named `get_patient_medication_summary` that, given a patient ID, returns a text summary stating the patient's full name from the patients table, followed by 'takes', the count of their medications from the medications table, and 'medications', or returns 'Patient not found' if no patient with that ID exists.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called `get_patient_medication_summary` that, for a given patient ID, returns a text summary. The summary should include the patient's full name from the patients table, followed by 'takes', the count of their medications from the medications table, and the word 'medications'. If the patient does not exist, return 'Patient not found'.",
    "id": 91,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_patient_medication_summary` that accepts a single input parameter, `p_patient_id`, which is of type `bigint`. This function is designed to return a text summary of a patient's medication information. The function returns a value of type `text`.\n\nUpon execution, the function declares two local variables: `v_patient_name` of type `text` to store the patient's full name, and `v_medication_count` of type `bigint` to store the count of medications associated with the patient.\n\nThe core logic begins with a `SELECT` statement that retrieves the patient's full name from the `patients` table. The full name is constructed by concatenating the `first_name` column, a single space, and the `last_name` column. This `SELECT` statement includes a `WHERE` clause that filters the rows in the `patients` table, ensuring that only the row where the `patient_id` column matches the value provided by the input parameter `p_patient_id` is considered. The result of this concatenation is stored into the `v_patient_name` variable.\n\nIf no row is found in the `patients` table for the given `p_patient_id`, the `v_patient_name` variable will remain `NULL`. The function then checks if `v_patient_name` is `NULL` using an `IF` statement. If it is `NULL`, the function immediately returns the string 'Patient not found'.\n\nIf the patient exists (i.e., `v_patient_name` is not `NULL`), the function proceeds to execute a second `SELECT` statement. This statement calculates the count of medications for the patient from the `medications` table. It uses the `COUNT(*)` aggregation function on the `medications` table. The `WHERE` clause filters the rows, ensuring that only records where the `patient_id` column matches the input parameter `p_patient_id` are counted. The result of this count is stored into the `v_medication_count` variable.\n\nFinally, the function constructs and returns the summary text. It concatenates the `v_patient_name` variable, the string ' takes ', the `v_medication_count` variable (cast to `text`), and the string ' medications' into a single text string. This concatenated string is returned as the function's output.",
    "original_summary": "Create a PL/pgSQL function named `get_patient_medication_summary` that takes a patient ID and returns a text summary. The summary should state the patient's full name, followed by 'takes', the count of their medications, and 'medications'. Return 'Patient not found' if no patient is found.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called `get_patient_medication_summary` that, for a given patient ID, gives back a text summary. The summary should basically say the patient's full name, then something like 'takes', along with roughly how many medications they're on, and the word 'medications'. If you can't find the patient, just return something like 'Patient not found'."
  },
  {
    "ir": "Write a PLpgSQL function that calculates the average value of a specified economic indicator for a given region. The function, named calculate_average_indicator, accepts two parameters: p_region_id of type bigint, which represents the unique identifier of the region, and p_indicator_name of type text, which specifies the name of the economic indicator to be averaged. The function returns a real number representing the average value of the specified indicator. Inside the function, a local variable v_avg_value of type real is declared to store the result of the average calculation. The function performs a SELECT operation to compute the average of the indicator_value column from the economic_indicators table, filtering the rows where the region_id matches the provided p_region_id and the indicator_name matches the provided p_indicator_name. The result of this average calculation is stored into the v_avg_value variable. A conditional statement checks if v_avg_value is not NULL, and if true, the function returns the value of v_avg_value. If v_avg_value is NULL, indicating that no matching records were found or the average could not be computed, the function returns 0.",
    "plsql": "CREATE OR REPLACE FUNCTION calculate_average_indicator(p_region_id bigint, p_indicator_name text)\nRETURNS real AS $$\nDECLARE\n    v_avg_value real;\nBEGIN\n    SELECT AVG(indicator_value) INTO v_avg_value \n    FROM economic_indicators \n    WHERE region_id = p_region_id AND indicator_name = p_indicator_name;\n    \n    IF v_avg_value IS NOT NULL THEN\n        RETURN v_avg_value;\n    END IF;\n    \n    RETURN 0;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "real_estate_market_analysis_and_housing_data_management",
    "tables": [
      "regions",
      "economic_indicators",
      "comparative_analyses",
      "market_trends"
    ],
    "call_sqls": [
      "SELECT calculate_average_indicator(1, 'GDP');",
      "SELECT calculate_average_indicator(2, 'Unemployment Rate');",
      "SELECT calculate_average_indicator(3, 'Inflation');",
      "SELECT calculate_average_indicator(4, 'Consumer Confidence');",
      "SELECT calculate_average_indicator(5, 'Retail Sales');"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named calculate_average_indicator that takes a region ID and an indicator name, retrieves the average indicator_value from the economic_indicators table for that region and indicator, and returns the average as a real number; if no matching data is found, it returns 0.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called calculate_average_indicator that accepts a region ID and an indicator name, and computes the average indicator_value as a real from the economic_indicators table for that region and indicator, returning 0 if no matching data exists.",
    "id": 92,
    "generated_ir": "Write a PLpgSQL function that calculates the average value of a specified economic indicator for a given region. The function, named calculate_average_indicator, accepts two parameters: p_region_id of type bigint, which represents the unique identifier of the region, and p_indicator_name of type text, which specifies the name of the economic indicator to be averaged. The function returns a real number representing the average value of the specified indicator. Inside the function, a local variable v_avg_value of type real is declared to store the result of the average calculation. The function performs a SELECT operation to compute the average of the indicator_value column from the economic_indicators table, filtering the rows where the region_id matches the provided p_region_id and the indicator_name matches the provided p_indicator_name. The result of this average calculation is stored into the v_avg_value variable. A conditional statement checks if v_avg_value is not NULL, and if true, the function returns the value of v_avg_value. If v_avg_value is NULL, indicating that no matching records were found or the average could not be computed, the function returns 0.",
    "original_summary": "Create a PL/pgSQL function named calculate_average_indicator that takes a region ID (bigint) and an indicator name (text), then returns the average value (real) of that indicator for the region from the economic_indicators table. Return 0 if no data is found.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called calculate_average_indicator that accepts a region ID as a bigint and an indicator name as text, and computes the average value as a real for that indicator in the specified region from the economic_indicators table. Ensure it returns 0 when no matching data exists."
  },
  {
    "ir": "Write a PLpgSQL function named find_largest_region_in_city that accepts a single input parameter p_city_id of type bigint, which represents the unique identifier of a city, and returns a value of type bigint. The function declares a local variable v_region_id of type bigint to store the result. The function executes a SELECT query on the table named regions, retrieving the region_id column. The query filters rows using a WHERE clause condition that requires the city_id column in the regions table to be equal to the input parameter p_city_id. From the resulting filtered set, the rows are ordered in descending order based on the population column using the ORDER BY population DESC clause. The query then uses the LIMIT 1 clause to select only the single top row from this ordered result set, which corresponds to the region with the highest population value for the given city. The selected region_id value is assigned into the local variable v_region_id using the INTO clause. Finally, the function returns the value stored in v_region_id.",
    "plsql": "CREATE OR REPLACE FUNCTION find_largest_region_in_city(p_city_id bigint)\nRETURNS bigint AS $$\nDECLARE\n    v_region_id bigint;\nBEGIN\n    SELECT region_id INTO v_region_id\n    FROM regions\n    WHERE city_id = p_city_id\n    ORDER BY population DESC\n    LIMIT 1;\n    \n    RETURN v_region_id;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "real_estate_market_analysis_292300",
    "tables": [
      "cities",
      "metros",
      "regions"
    ],
    "call_sqls": [
      "SELECT find_largest_region_in_city(0);",
      "SELECT find_largest_region_in_city(1);",
      "SELECT find_largest_region_in_city(2);",
      "SELECT find_largest_region_in_city(3);",
      "SELECT find_largest_region_in_city(4);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named find_largest_region_in_city that takes a city ID and returns the region ID from the regions table that has the highest population for that given city.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called find_largest_region_in_city that, given a specific city ID as input, retrieves from the regions table and returns the region ID of the most populous area within that city.",
    "id": 93,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `find_largest_region_in_city` that accepts a single input parameter, `city_id_input`, which is of type `BIGINT`. This function is designed to return a single value of type `BIGINT`. The function's primary purpose is to identify and return the `region_id` of the most populous region within a specified city.\n\nInside the function, a local variable named `largest_region_id` of type `BIGINT` is declared to temporarily store the result of the database query.\n\nThe core operation involves executing a `SELECT` statement. This `SELECT` statement queries the `regions` table. It specifically selects the `region_id` column from the `regions` table. The query includes a `WHERE` clause condition, which filters the rows to include only those where the `city_id` column matches the value provided by the `city_id_input` parameter. To determine the most populous area, the query includes an `ORDER BY` clause. It orders the filtered results by the `population` column in descending order (`DESC`), ensuring the region with the highest population appears first. To guarantee that only a single row is returned, the query is limited to one result using the `LIMIT 1` clause.\n\nThe result of this `SELECT` statement, which is the `region_id` of the first (and most populous) row in the ordered result set, is then assigned to the `largest_region_id` variable using the `INTO` clause.\n\nFinally, the function returns the value stored in the `largest_region_id` variable as its output.",
    "original_summary": "Create a PL/pgSQL function named find_largest_region_in_city that takes a city ID (bigint) and returns the region ID (bigint) with the highest population for that city from the regions table.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Design a PL/pgSQL function called find_largest_region_in_city which, when provided with a specific city ID as a bigint parameter, will meticulously query the regions table to identify and return, as a bigint, the precise region ID associated with the single most populous area within that particular city."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves a summary of product sales for a specified product ID, taking a single parameter p_product_id of type bigint, which represents the unique identifier of the product whose sales summary is to be fetched. The function returns a table with two columns: product_name of type text and total_sales of type numeric. The function begins by checking if the provided p_product_id is not null, ensuring that a valid product ID is supplied. If the condition is met, it executes a query that selects the product_name from the products table and calculates the total sales by summing the product of quantity and unit_price from the order_items table, where the product_id in both tables matches the provided p_product_id. The COALESCE function is used to ensure that the total_sales value defaults to 0 if no sales data is found. The results are grouped by product_name to aggregate sales data for the specified product.",
    "plsql": "CREATE OR REPLACE FUNCTION get_product_sales_summary(p_product_id bigint)\nRETURNS TABLE(product_name text, total_sales numeric) AS $$\nBEGIN\n    IF p_product_id IS NOT NULL THEN\n        RETURN QUERY SELECT p.product_name, COALESCE(SUM(oi.quantity * oi.unit_price::numeric), 0)\n        FROM products p\n        JOIN order_items oi ON p.product_id = oi.product_id\n        WHERE p.product_id = p_product_id\n        GROUP BY p.product_name;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "customer_purchase_and_discount_tracking",
    "tables": [
      "customers",
      "discounts",
      "order_items",
      "orders",
      "products",
      "user_management"
    ],
    "call_sqls": [
      "SELECT * FROM get_product_sales_summary(1);",
      "SELECT * FROM get_product_sales_summary(2);",
      "SELECT * FROM get_product_sales_summary(10);",
      "SELECT * FROM get_product_sales_summary(NULL);",
      "SELECT product_name, total_sales FROM get_product_sales_summary(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_product_sales_summary that, for a given product_id, returns the product_name from the products table and the total sales calculated as the sum of quantity multiplied by unit_price from the order_items table, defaulting to 0 if no sales exist, ensuring the input product_id is not null.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_product_sales_summary that, for a given product ID, retrieves the product's name from the products table and calculates its total sales as the sum of quantity multiplied by unit price from the order_items table, returning these as product_name and total_sales with total_sales defaulting to 0 if no sales exist, while ensuring the input product_id is validated to not be null.",
    "id": 94,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_product_sales_summary that takes a single input parameter named product_id of type bigint, which represents the identifier of the product for which the sales summary is to be retrieved. The function returns a table with two columns: product_name of type text and total_sales of type numeric, which will contain the product's name and the calculated total sales amount, respectively.\n\nThe function begins by declaring a local variable v_product_name of type text to store the product name retrieved from the products table, and a local variable v_total_sales of type numeric initialized to 0 to store the calculated total sales amount.\n\nThe function first validates that the input product_id parameter is not null. If the product_id is null, the function raises an exception with a message indicating that the product ID cannot be null, preventing further execution.\n\nIf the product_id is not null, the function proceeds to retrieve the product name from the products table. It performs a SELECT query on the products table, specifically selecting the product_name column where the product_id column matches the input product_id parameter. The retrieved product name is stored in the v_product_name variable. If no product is found with the given product_id, the v_product_name variable remains null.\n\nNext, the function calculates the total sales for the specified product_id. It executes a SELECT query on the order_items table to compute the sum of the quantity multiplied by the unit_price for all order items where the product_id matches the input product_id. Since the unit_price column is stored as text, the calculation involves casting the unit_price to numeric to perform arithmetic operations. The sum is computed as the sum of quantity multiplied by unit_price::numeric. If there are no matching order items, the sum returns null. The function uses the COALESCE function to convert any null result from the sum to 0, ensuring that the total_sales defaults to 0 if no sales exist for the product. The calculated total sales amount is stored in the v_total_sales variable.\n\nFinally, the function returns a single row consisting of the v_product_name and v_total_sales values as the product_name and total_sales columns in the result table. This provides a summary of the product's name and its total sales based on the order_items data.",
    "original_summary": "Create a PL/pgSQL function that returns a product's name and total sales (sum of quantity * unit_price) for a given product_id. Return columns: product_name (text) and total_sales (numeric, default 0). Validate that the input product_id is not null.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function to fetch a product's name and its total sales, calculated as the sum of quantity multiplied by unit price, for a specified product ID. The function must return the columns product_name as text and total_sales as numeric with a default of 0. Also, ensure the input product_id is validated to not be null."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_author_email_by_id` that accepts a single input parameter, `p_author_id`, which is of data type `BIGINT`. This function is designed to return a value of data type `TEXT`. Internally, the function declares a local variable named `author_email` of data type `TEXT`. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `email` column of the `authors` table. The retrieved `email` value is then assigned to the local variable `author_email`. The selection of the row from the `authors` table is based on a `WHERE` clause, which specifies that the `author_id` column in the `authors` table must be equal to the value provided by the input parameter `p_author_id`. Finally, the function returns the value stored in the `author_email` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_author_email_by_id(p_author_id BIGINT) RETURNS TEXT AS $$\nDECLARE\n    author_email TEXT;\nBEGIN\n    SELECT email INTO author_email FROM authors WHERE authors.author_id = p_author_id;\n    RETURN author_email;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "academic_research_and_publication_management_450452",
    "tables": [
      "authors",
      "citations",
      "paper_authors",
      "paper_files",
      "papers",
      "reviews",
      "tracks"
    ],
    "call_sqls": [
      "SELECT get_author_email_by_id(1);",
      "SELECT get_author_email_by_id(2);",
      "SELECT get_author_email_by_id(3);",
      "SELECT get_author_email_by_id(4);",
      "SELECT get_author_email_by_id(5);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_author_email_by_id that, given an author ID, retrieves and returns the corresponding email from the authors table where the author_id matches the provided ID.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_author_email_by_id that, for a given author_id, retrieves the corresponding email from the authors table and returns it as text.",
    "id": 95,
    "generated_ir": "Write a PLpgSQL function named get_author_email_by_id that retrieves the email address of an author from the authors table based on a provided author identifier. The function takes one parameter: p_author_id of type bigint, which specifies the unique identifier of the author. The function returns the email as text. The function begins by declaring a variable v_email of type text to store the retrieved email value. It then performs a SELECT query on the authors table, specifically selecting the email column where the author_id column matches the input parameter p_author_id. The result of this query is stored into the v_email variable. The function then returns the value of v_email. If no matching author is found, the function will return null.",
    "original_summary": "Create a function named get_author_email_by_id that takes an author ID (BIGINT) and returns TEXT. The function should retrieve and return the email from the authors table where the author_id matches the input parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write function get_author_email_by_id(BIGINT) returning TEXT to fetch email from authors for given author_id."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_experiment_name_by_block` that accepts a single input parameter, `block_id_input`, which is of type `BIGINT`. This function is designed to return a value of type `TEXT`. Upon execution, the function declares a local variable named `experiment_name` of type `TEXT` to temporarily store the retrieved experiment name. The core operation of the function involves a `SELECT` statement that retrieves the `experiment_name` from the `experiments` table. This `SELECT` statement performs an `INNER JOIN` operation between the `experiments` table (aliased as `e`) and the `blocks` table (aliased as `b`). The join condition for this operation is `e.experiment_id = b.experiment_id`, meaning rows are matched when the `experiment_id` column in the `experiments` table is equal to the `experiment_id` column in the `blocks` table. The `WHERE` clause of the `SELECT` statement filters the joined results, specifically looking for rows where the `block_id` column in the `blocks` table is equal to the value provided by the `block_id_input` parameter. The `experiment_name` value retrieved from the `experiments` table based on these join and filter conditions is then assigned to the local `experiment_name` variable using the `INTO` clause. Finally, the function returns the value stored in the `experiment_name` variable.",
    "plsql": "CREATE OR REPLACE FUNCTION get_experiment_name_by_block(block_id_input BIGINT) RETURNS TEXT AS $$\nDECLARE\n    experiment_name TEXT;\nBEGIN\n    SELECT e.experiment_name INTO experiment_name\n    FROM experiments e\n    JOIN blocks b ON e.experiment_id = b.experiment_id\n    WHERE b.block_id = block_id_input;\n    RETURN experiment_name;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "psychological_experiment_data_management_639848",
    "tables": [
      "experiments",
      "blocks",
      "responses",
      "subjects"
    ],
    "call_sqls": [
      "SELECT get_experiment_name_by_block(0);",
      "SELECT get_experiment_name_by_block(1);",
      "SELECT get_experiment_name_by_block(2);",
      "SELECT get_experiment_name_by_block(3);",
      "SELECT get_experiment_name_by_block(4);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_experiment_name_by_block that, given a block_id_input, retrieves and returns the corresponding experiment_name from the experiments table by finding the experiment linked to that block in the blocks table.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_experiment_name_by_block that, given a BIGINT block_id_input, returns the experiment_name from the experiments table by finding the matching experiment_id in the blocks table for the provided block_id.",
    "id": 96,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_experiment_name_by_block` that accepts a single input parameter, `block_id_input`, which is of type `BIGINT`. This function is designed to return a value of type `TEXT`. Upon execution, the function declares a local variable named `experiment_name` of type `TEXT` to temporarily store the retrieved experiment name. The core operation of the function involves a `SELECT` statement that retrieves the `experiment_name` from the `experiments` table. This `SELECT` statement performs an `INNER JOIN` operation between the `experiments` table (aliased as `e`) and the `blocks` table (aliased as `b`). The join condition for this operation is `e.experiment_id = b.experiment_id`, meaning rows are matched when the `experiment_id` column in the `experiments` table is equal to the `experiment_id` column in the `blocks` table. The `WHERE` clause of the `SELECT` statement filters the joined results, specifically looking for rows where the `block_id` column in the `blocks` table is equal to the value provided by the `block_id_input` parameter. The `experiment_name` value retrieved from the `experiments` table based on these join and filter conditions is then assigned to the local `experiment_name` variable using the `INTO` clause. Finally, the function returns the value stored in the `experiment_name` variable.",
    "original_summary": "Create a PL/pgSQL function named get_experiment_name_by_block that accepts a BIGINT block_id_input parameter and returns TEXT. The function retrieves the experiment_name from the experiments table by joining it with the blocks table where block_id matches the input parameter.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "How can I create a PL/pgSQL function called get_experiment_name_by_block that takes a BIGINT block_id_input and returns TEXT, which will fetch the experiment_name from the experiments table by joining it with the blocks table on a matching block_id?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named `get_experiment_status` that accepts a single input parameter. This input parameter is named `experiment_id_input` and is of data type `BIGINT`; its purpose is to specify the unique identifier of an experiment whose status is to be retrieved. The function is designed to return a value of data type `TEXT`, representing the status of the specified experiment. Upon execution, the function declares a local variable named `experiment_status` of data type `TEXT` to temporarily store the retrieved status. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `status` column from the table named `experiments`. The retrieved `status` value is then immediately assigned to the local variable `experiment_status`. The selection of the row from the `experiments` table is constrained by a `WHERE` clause, which specifies that the `experiment_id` column in the `experiments` table must be equal to the value provided by the `experiment_id_input` parameter. After successfully retrieving and assigning the status, the function concludes by returning the value currently stored in the `experiment_status` variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_experiment_status(experiment_id_input BIGINT) RETURNS TEXT AS $$\nDECLARE\n    experiment_status TEXT;\nBEGIN\n    SELECT status INTO experiment_status\n    FROM experiments\n    WHERE experiment_id = experiment_id_input;\n    RETURN experiment_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "psychological_experiment_data_management_639848",
    "tables": [
      "experiments",
      "blocks",
      "responses",
      "subjects"
    ],
    "call_sqls": [
      "SELECT get_experiment_status(0);",
      "SELECT get_experiment_status(1);",
      "SELECT get_experiment_status( (SELECT experiment_id FROM experiments ORDER BY RANDOM() LIMIT 1) );",
      "SELECT get_experiment_status( (SELECT MIN(experiment_id) FROM experiments) );",
      "SELECT get_experiment_status( (SELECT MAX(experiment_id) FROM experiments) );"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_experiment_status that accepts an experiment_id_input and returns the corresponding status from the experiments table as a text value.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_experiment_status that, for a given experiment ID, retrieves and returns the corresponding status as a text value from the experiments table.",
    "id": 97,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_experiment_status` that accepts a single input parameter. This input parameter is named `experiment_id_input` and is of data type `BIGINT`; its purpose is to specify the unique identifier of an experiment whose status is to be retrieved. The function is designed to return a value of data type `TEXT`, representing the status of the specified experiment. Upon execution, the function declares a local variable named `experiment_status` of data type `TEXT` to temporarily store the retrieved status. The core operation of the function involves executing a `SELECT` statement. This `SELECT` statement retrieves the value from the `status` column from the table named `experiments`. The retrieved `status` value is then immediately assigned to the local variable `experiment_status`. The selection of the row from the `experiments` table is constrained by a `WHERE` clause, which specifies that the `experiment_id` column in the `experiments` table must be equal to the value provided by the `experiment_id_input` parameter. After successfully retrieving and assigning the status, the function concludes by returning the value currently stored in the `experiment_status` variable as its output.",
    "original_summary": "Create a PL/pgSQL function named get_experiment_status that accepts an experiment_id_input (bigint) and returns a text value. The function should retrieve the status from the experiments table for the given experiment_id and return it.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "What is the status of the experiment with the given experiment ID, and can you provide it as a text value from the experiments table?"
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named justify_expenditure_hours that accepts two input parameters: a bigint parameter named p_country_id representing a specific country identifier and a bigint parameter named p_year representing a specific calendar year, and returns a value of type interval; the function declares a local interval variable named total_hours; the function body executes a SELECT query that retrieves data from the healthcare_expenditure table, aliased as he, where the country_id column in the table matches the input parameter p_country_id and the year column in the table matches the input parameter p_year; for each row that satisfies these conditions, the query calls a scalar function named justify_hours, passing a literal interval value of '27 hours' as its argument, and the result of this function call is assigned into the local variable total_hours using a SELECT INTO statement; the function then returns the value stored in the total_hours variable.",
    "plsql": "CREATE OR REPLACE FUNCTION justify_expenditure_hours(p_country_id bigint, p_year bigint)\nRETURNS interval AS $$\nDECLARE\n    total_hours interval;\nBEGIN\n    SELECT justify_hours(interval '27 hours') INTO total_hours\n    FROM healthcare_expenditure he\n    WHERE he.country_id = p_country_id AND he.year = p_year;\n    RETURN total_hours;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "global_health_and_economic_statistics",
    "tables": [
      "countries",
      "diseases",
      "economic_indicators",
      "education",
      "health_indicators",
      "healthcare_expenditure",
      "access_logs"
    ],
    "call_sqls": [
      "SELECT justify_expenditure_hours(0, 2015);",
      "SELECT justify_expenditure_hours(1, 2014);",
      "SELECT justify_expenditure_hours(0, 2014);",
      "SELECT justify_expenditure_hours(1, 2015);",
      "SELECT justify_expenditure_hours(0, 2016);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named justify_expenditure_hours that, given a specific country_id and year, retrieves all matching records from the healthcare_expenditure table and returns the total hours calculated by applying the justify_hours function with a fixed input of '27 hours' to each record.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called justify_expenditure_hours that takes a country_id and a year as inputs, and returns the total hours as an interval by calculating the sum of '27 hours' for each matching row in the healthcare_expenditure table where the country_id and year columns equal the provided parameters.",
    "id": 98,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named justify_expenditure_hours that accepts two input parameters: p_country_id of type bigint, representing the unique identifier of a country to filter records, and p_year of type bigint, representing the specific year to filter records. The function returns a value of type interval, which will represent the total calculated hours.\n\nThe function declares a local variable v_total_hours of type interval to store the computed result. It then executes a SELECT query that calculates the total hours by counting the number of rows in the healthcare_expenditure table where the country_id column exactly matches the provided p_country_id parameter and the year column exactly matches the provided p_year parameter. For each matching row found, the query adds an interval of '27 hours' to the total. This is achieved using the COUNT(*) function to determine the number of matching rows and then multiplying this count by the interval literal '27 hours' using the * operator. The resulting interval sum is stored into the v_total_hours variable.\n\nIf no rows in the healthcare_expenditure table satisfy the conditions (i.e., COUNT(*) returns 0), the multiplication will yield an interval of '0 hours', which is stored in v_total_hours. Finally, the function returns the value held in v_total_hours, which represents the total interval calculated as the number of matching healthcare expenditure records multiplied by 27 hours per record.",
    "original_summary": "Create a function named justify_expenditure_hours that accepts two bigint parameters: p_country_id and p_year. It returns an interval. The function should calculate the total hours by calling the justify_hours function with '27 hours' as input for each matching row in the healthcare_expenditure table where country_id and year match the parameters, and return the summed result.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Construct a function called justify_expenditure_hours, which is designed to take two parameters of the bigint type: specifically p_country_id and p_year. This function will ultimately return a value of the interval data type. Its primary operation involves meticulously calculating the cumulative total of hours by invoking the justify_hours function, using the literal input '27 hours', for every single row that corresponds within the healthcare_expenditure table where the country_id column and the year column precisely match the provided parameter values. The function then carefully sums all these individual results to produce and deliver the final aggregated interval."
  },
  {
    "ir": "Write a PostgreSQL PL/pgSQL function named get_average_temperature that accepts two input parameters: p_region_id, which is of type bigint and represents a specific region identifier, and p_year, which is also of type bigint and represents a specific year. This function is designed to return a single value of type real. Upon execution, the function declares a local variable named v_avg_temperature of type real to temporarily store the calculated average temperature. The core operation involves performing a SELECT statement to retrieve data from the climate_data table. Within this SELECT statement, the function calculates the average of the values in the temperature column. To handle cases where no matching rows are found or the average calculation results in a NULL value, the COALESCE function is applied, ensuring that if AVG(temperature) is NULL, a default value of 0.0 is used instead. The result of this average calculation (or 0.0 if no data is found) is then assigned to the previously declared local variable v_avg_temperature. The selection of rows for this calculation is constrained by a WHERE clause, which filters the climate_data table to include only those rows where the value in the region_id column matches the input parameter p_region_id AND the value in the year column matches the input parameter p_year. Finally, the function returns the value stored in the v_avg_temperature variable as its output.",
    "plsql": "CREATE OR REPLACE FUNCTION get_average_temperature(p_region_id bigint, p_year bigint)\nRETURNS real AS $$\nDECLARE\n    v_avg_temperature real;\nBEGIN\n    SELECT COALESCE(AVG(temperature), 0.0) INTO v_avg_temperature\n    FROM climate_data\n    WHERE region_id = p_region_id AND year = p_year;\n    RETURN v_avg_temperature;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "climate_data_analysis_and_prediction",
    "tables": [
      "climate_data",
      "regions"
    ],
    "call_sqls": [
      "SELECT get_average_temperature(0, 2023);",
      "SELECT get_average_temperature(1, 2022);",
      "SELECT get_average_temperature(0, 2021);",
      "SELECT get_average_temperature(1, 2020);",
      "SELECT get_average_temperature(2, 2023);"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_average_temperature that, given a region_id and a year, retrieves the average temperature from the climate_data table for that specific region and year, returning 0.0 if no matching data exists.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function called get_average_temperature that, given a region identifier and a year, calculates the average temperature from the climate_data table for that specific region and year, returning zero if no data is available.",
    "id": 99,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named get_average_temperature that accepts two input parameters: p_region_id, which is of type bigint and represents a specific region identifier, and p_year, which is also of type bigint and represents a specific year. This function is designed to return a single value of type real. Upon execution, the function declares a local variable named v_avg_temperature of type real to temporarily store the calculated average temperature. The core operation involves performing a SELECT statement to retrieve data from the climate_data table. Within this SELECT statement, the function calculates the average of the values in the temperature column. To handle cases where no matching rows are found or the average calculation results in a NULL value, the COALESCE function is applied, ensuring that if AVG(temperature) is NULL, a default value of 0.0 is used instead. The result of this average calculation (or 0.0 if no data is found) is then assigned to the previously declared local variable v_avg_temperature. The selection of rows for this calculation is constrained by a WHERE clause, which filters the climate_data table to include only those rows where the value in the region_id column matches the input parameter p_region_id AND the value in the year column matches the input parameter p_year. Finally, the function returns the value stored in the v_avg_temperature variable as its output.",
    "original_summary": "Create a PL/pgSQL function named get_average_temperature that takes a bigint region_id and a bigint year as input and returns a real value. The function calculates the average temperature from the climate_data table for the given region and year. If no data is found, return 0.0.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a PL/pgSQL function called get_average_temperature that needs a region identifier and a year, both as big numbers. It should figure out the typical temperature from the climate_data table for that general area and time period. If there isn't much data available, just give back zero."
  },
  {
    "ir": "Write a PLpgSQL function that retrieves the employment status of an individual from the individuals table based on a provided individual ID parameter, p_individual_id, which is of type bigint. The function begins by declaring a local variable, employment_status, of type text, which will store the result of the query. It then performs a SELECT operation on the individuals table, specifically targeting the row where the id column matches the value of p_individual_id. Within this SELECT statement, a CASE conditional expression is used to determine the value to be assigned to employment_status: if the employed column equals 1, the employment_status is set to 'Employed'; otherwise, it is set to 'Unemployed'. The result of this conditional logic is stored into the employment_status variable using the INTO clause. Finally, the function returns the value of employment_status, which represents the employment status of the individual identified by the given ID.",
    "plsql": "CREATE OR REPLACE FUNCTION get_individual_employment_status(p_individual_id bigint)\nRETURNS text AS $$\nDECLARE\n    employment_status text;\nBEGIN\n    SELECT CASE \n        WHEN employed = 1 THEN 'Employed'\n        ELSE 'Unemployed'\n    END INTO employment_status\n    FROM individuals\n    WHERE id = p_individual_id;\n    \n    RETURN employment_status;\nEND;\n$$ LANGUAGE plpgsql;",
    "database_name": "demographic_and_employment_data_analysis_192071",
    "tables": [
      "access_logs",
      "individuals",
      "users"
    ],
    "call_sqls": [
      "SELECT get_individual_employment_status(0);",
      "SELECT get_individual_employment_status(1);",
      "SELECT get_individual_employment_status( (SELECT id FROM individuals WHERE employed = 1 LIMIT 1) );",
      "SELECT get_individual_employment_status( (SELECT id FROM individuals WHERE employed = 0 LIMIT 1) );",
      "SELECT get_individual_employment_status( (SELECT id FROM individuals ORDER BY RANDOM() LIMIT 1) );"
    ],
    "summary": "Write a PostgreSQL PL/pgSQL function named get_individual_employment_status that takes an individual ID and returns a text value indicating whether the individual is employed or unemployed. The function should check the individuals table for the given ID and return 'Employed' if the employed column equals 1, otherwise return 'Unemployed'.",
    "natural_language": "Write a PostgreSQL PL/pgSQL function named get_individual_employment_status that returns 'Employed' or 'Unemployed' based on the employed column in the individuals table for a given individual ID.",
    "id": 100,
    "generated_ir": "Write a PostgreSQL PL/pgSQL function named `get_individual_employment_status` that returns a text value. This function accepts a single input parameter, `individual_id_input`, which is of type `bigint`. The function is designed to retrieve the employment status of a specific individual from the `individuals` table and return a human-readable string. Inside the function, a local variable named `employment_status` of type `bigint` is declared to temporarily store the value from the `employed` column. The core operation involves executing a `SELECT` statement. This `SELECT` statement queries the `individuals` table to fetch the value from the `employed` column for the row where the `id` column matches the provided `individual_id_input` parameter. The retrieved value is then immediately assigned to the `employment_status` local variable using the `INTO` clause. After retrieving the value, the function uses a conditional `IF` statement to evaluate the `employment_status` variable. If the value of `employment_status` is equal to 1, the function returns the string literal 'Employed'. If the value is not equal to 1 (which implicitly handles the case where it is 0 or NULL, given the column examples), the function returns the string literal 'Unemployed'. The function's return type is `text`, corresponding to the returned status string.",
    "original_summary": "Create a PL/pgSQL function that takes an individual ID (`bigint`) and returns a `text` value indicating employment status. It queries the `individuals` table for the given ID. If the `employed` column equals 1, return 'Employed'; otherwise, return 'Unemployed'.",
    "plsql_type": "PostgreSQL PL/pgSQL",
    "object_type": "function",
    "original_natural_language": "Write a function returning 'Employed' or 'Unemployed' based on the employed column for a given individual ID."
  }
]