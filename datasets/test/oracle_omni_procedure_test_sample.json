[
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp that accepts three parameters: para_restriction_type, para_start_date, and para_end_date, all of type VARCHAR2. The procedure iterates over a set of properties that have restrictions matching the para_restriction_type and whose effective dates fall between para_start_date and para_end_date. For each property, identified by PROPERTY_ID, it retrieves the PROPERTY_MANAGER_NAME from the PROPERTY_MANAGERS table. The procedure checks several conditions sequentially: it first counts the number of tenants associated with the property from the TENANTS table, and if tenants exist, it deletes all complaints related to those tenants from the TENANT_COMPLAINTS table and marks a decision as made. If no decision is made, it checks for inspections in the PROPERTY_INSPECTIONS table and deletes them if they exist. Next, it checks for tenant complaints by joining TENANT_COMPLAINTS and TENANTS tables, and if complaints exist, it deletes the tenants from the TENANTS table. If no decision is made, it checks for property history records in the PROPERTY_HISTORY table and deletes them if they exist. Then, it checks for other restrictions in the PROPERTY_RESTRICTIONS table that do not match para_restriction_type and deletes them if they exist. If none of these conditions result in a decision being made, it inserts a new record into the PROPERTY_HISTORY table, documenting the compliance check with a unique HISTORY_ID, the current date, a description of 'Restriction compliance check', a change type of 'audit', and the responsible manager's name.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_restriction_type VARCHAR2, para_start_date VARCHAR2, para_end_date VARCHAR2) IS\n  v_property_id NUMBER;\n  v_manager_name VARCHAR2(255);\n  v_tenant_exists NUMBER;\n  v_inspection_exists NUMBER;\n  v_complaint_exists NUMBER;\n  v_history_exists NUMBER;\n  v_restriction_exists NUMBER;\n  v_decision_made BOOLEAN;\nBEGIN\n  FOR r IN (SELECT pr.PROPERTY_ID, pm.PROPERTY_MANAGER_NAME\n            FROM PROPERTY_RESTRICTIONS pr\n            JOIN PROPERTIES p ON pr.PROPERTY_ID = p.PROPERTY_ID\n            JOIN PROPERTY_MANAGERS pm ON p.PROPERTY_MANAGER_ID = pm.PROPERTY_MANAGER_ID\n            WHERE pr.RESTRICTION_TYPE = para_restriction_type\n            AND pr.EFFECTIVE_DATE >= para_start_date\n            AND pr.EXPIRATION_DATE <= para_end_date) LOOP\n    v_decision_made := FALSE;\n    v_property_id := r.PROPERTY_ID;\n    v_manager_name := r.PROPERTY_MANAGER_NAME;\n    SELECT COUNT(*) INTO v_tenant_exists FROM TENANTS WHERE PROPERTY_ID = v_property_id;\n    IF v_tenant_exists > 0 AND NOT v_decision_made THEN\n      DELETE FROM TENANT_COMPLAINTS WHERE TENANT_ID IN (SELECT TENANT_ID FROM TENANTS WHERE PROPERTY_ID = v_property_id);\n      v_decision_made := TRUE;\n    END IF;\n    SELECT COUNT(*) INTO v_inspection_exists FROM PROPERTY_INSPECTIONS WHERE PROPERTY_ID = v_property_id;\n    IF v_inspection_exists > 0 AND NOT v_decision_made THEN\n      DELETE FROM PROPERTY_INSPECTIONS WHERE PROPERTY_ID = v_property_id;\n      v_decision_made := TRUE;\n    END IF;\n    SELECT COUNT(*) INTO v_complaint_exists FROM TENANT_COMPLAINTS tc JOIN TENANTS t ON tc.TENANT_ID = t.TENANT_ID WHERE t.PROPERTY_ID = v_property_id;\n    IF v_complaint_exists > 0 AND NOT v_decision_made THEN\n      DELETE FROM TENANTS WHERE PROPERTY_ID = v_property_id;\n      v_decision_made := TRUE;\n    END IF;\n    SELECT COUNT(*) INTO v_history_exists FROM PROPERTY_HISTORY WHERE PROPERTY_ID = v_property_id;\n    IF v_history_exists > 0 AND NOT v_decision_made THEN\n      DELETE FROM PROPERTY_HISTORY WHERE PROPERTY_ID = v_property_id;\n      v_decision_made := TRUE;\n    END IF;\n    SELECT COUNT(*) INTO v_restriction_exists FROM PROPERTY_RESTRICTIONS WHERE PROPERTY_ID = v_property_id AND RESTRICTION_TYPE != para_restriction_type;\n    IF v_restriction_exists > 0 AND NOT v_decision_made THEN\n      DELETE FROM PROPERTY_RESTRICTIONS WHERE PROPERTY_ID = v_property_id;\n      v_decision_made := TRUE;\n    END IF;\n    IF NOT v_decision_made THEN\n      INSERT INTO PROPERTY_HISTORY (HISTORY_ID, PROPERTY_ID, CHANGE_DATE, CHANGE_DESCRIPTION, CHANGE_TYPE, PERSON_RESPONSIBLE)\n      VALUES ((SELECT NVL(MAX(HISTORY_ID),0)+1 FROM PROPERTY_HISTORY), v_property_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'Restriction compliance check', 'audit', v_manager_name);\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "real_epmaa_773860",
    "tables": [
      "PROPERTIES",
      "PROPERTY_HISTORY",
      "PROPERTY_INSPECTIONS",
      "PROPERTY_MANAGERS",
      "PROPERTY_RESTRICTIONS",
      "TENANTS",
      "TENANT_COMPLAINTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp('no pets', '2022-01-01', '2023-01-01');\nEND;",
      "BEGIN\n  sp('smoking allowed', '2022-02-01', '2023-02-01');\nEND;",
      "BEGIN\n  sp('no loud music', '2022-03-01', '2023-03-01');\nEND;",
      "BEGIN\n  sp('subletting forbidden', '2022-04-01', '2023-04-01');\nEND;",
      "BEGIN\n  sp('commercial use prohibited', '2022-05-01', '2023-05-01');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp that processes properties from the PROPERTY_RESTRICTIONS table with a given RESTRICTION_TYPE and whose EFFECTIVE_DATE and EXPIRATION_DATE fall within a provided start and end date range. For each qualifying property, perform a series of checks in a specific order: if TENANTS exist for the property, delete their associated records from TENANT_COMPLAINTS; if not, delete records from PROPERTY_INSPECTIONS for the property; if not, delete TENANTS for the property who have complaints; if not, delete records from PROPERTY_HISTORY for the property; if not, delete other RESTRICTION_TYPE records from PROPERTY_RESTRICTIONS for the property. If none of these actions are taken for a property, insert a new 'audit' record into the PROPERTY_HISTORY table with a description of 'Restriction compliance check' and the PROPERTY_MANAGER_NAME as the person responsible.",
    "natural_language": "Write a Oracle PL/SQL stored procedure named sp that processes properties with a specific RESTRICTION_TYPE from a given para_start_date to para_end_date. For each matching property, perform a series of actions in order: if tenants exist, delete their complaints from TENANT_COMPLAINTS; if no tenants exist, delete inspections from PROPERTY_INSPECTIONS; if that fails, delete tenants with complaints from TENANTS; if that fails, delete old records from PROPERTY_HISTORY; if that fails, delete other restriction types from PROPERTY_RESTRICTIONS. If no action is taken for a property, insert a new 'audit' entry into PROPERTY_HISTORY with details including the property manager.",
    "id": 1,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that accepts three parameters: para_restriction_type, para_start_date, and para_end_date, all of type VARCHAR2. The procedure iterates over a set of properties that have restrictions matching the para_restriction_type and whose effective dates fall between para_start_date and para_end_date. For each property, identified by PROPERTY_ID, it retrieves the PROPERTY_MANAGER_NAME from the PROPERTY_MANAGERS table. The procedure checks several conditions sequentially: it first counts the number of tenants associated with the property from the TENANTS table, and if tenants exist, it deletes all complaints related to those tenants from the TENANT_COMPLAINTS table and marks a decision as made. If no decision is made, it checks for inspections in the PROPERTY_INSPECTIONS table and deletes them if they exist. Next, it checks for tenant complaints by joining TENANT_COMPLAINTS and TENANTS tables, and if complaints exist, it deletes the tenants from the TENANTS table. If no decision is made, it checks for property history records in the PROPERTY_HISTORY table and deletes them if they exist. Then, it checks for other restrictions in the PROPERTY_RESTRICTIONS table that do not match para_restriction_type and deletes them if they exist. If none of these conditions result in a decision being made, it inserts a new record into the PROPERTY_HISTORY table, documenting the compliance check with a unique HISTORY_ID, the current date, a description of 'Restriction compliance check', a change type of 'audit', and the responsible manager's name.",
    "original_summary": "Create a stored procedure that processes properties with a specific restriction type within a date range. For each property, perform checks in this order: if tenants exist, delete their complaints; if not, delete property inspections; if not, delete tenants who have complaints; if not, delete property history; if not, delete other restriction types. If no action was taken, insert a new 'audit' record into the property history.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create a stored procedure to handle properties that have a certain kind of restriction from a while back until not too long ago. For each of these properties, go through a series of steps: if there are any tenants around, get rid of their complaints; if there aren't, then clear out the property inspections; if that's not possible, remove tenants who have made complaints; if that doesn't work, delete some old property history; and if none of that applies, clean up other restriction types that are hanging around. If nothing ended up being done for a property, put a new 'audit' note into its history log."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_validate_and_insert_prefix` that accepts three input parameters: `para_Prefix` of type `VARCHAR2`, `para_City_ID` of type `NUMBER`, and `para_Usage_Type_ID` of type `NUMBER`. The procedure first declares two local variables: `v_Prefix_ID` of type `NUMBER` and `v_Existing_Count` of type `NUMBER`. The procedure then executes a `SELECT` statement to count the number of rows in the `NUMBER_PREFIXES` table where the `PREFIX` column is equal to the value provided in the `para_Prefix` input parameter. The result of this count is stored in the `v_Existing_Count` local variable. Following this, a conditional `IF` statement checks if the value of `v_Existing_Count` is equal to `0`. If `v_Existing_Count` is indeed `0`, indicating that no existing record in the `NUMBER_PREFIXES` table has a `PREFIX` matching `para_Prefix`, the procedure proceeds to execute another `SELECT` statement. This `SELECT` statement calculates a new `PREFIX_ID` by finding the maximum value in the `PREFIX_ID` column of the `NUMBER_PREFIXES` table, applying the `NVL` function to treat a `NULL` maximum as `0`, and then adding `1` to the result. This newly calculated `PREFIX_ID` is stored in the `v_Prefix_ID` local variable. Subsequently, an `INSERT` statement is executed to add a new row into the `NUMBER_PREFIXES` table. The values inserted into the columns are as follows: `PREFIX_ID` is set to the value of `v_Prefix_ID`, `PREFIX` is set to the value of `para_Prefix`, `PRIMARY_CITY` is set to the literal string `'Unknown'`, `COMPANY_ID` is set to the result of the `MOD` function applied to `para_Usage_Type_ID` and `2`, `COUNTY` is set to the literal string `'Unknown'`, `USAGE_TYPE_ID` is set to the value of `para_Usage_Type_ID`, `INTRODUCED_DATE` is set to the current system date formatted as 'YYYY-MM-DD' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD')`, `STATUS` is set to the literal string `'new'`, `LAST_UPDATED` is set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`, `NOTES` is set to the literal string `'Auto-created'`, and `CITY_ID` is set to the value of `para_City_ID`. If the initial `IF` condition evaluates to `FALSE` (i.e., `v_Existing_Count` is not `0`), no further operations are performed within the procedure.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_validate_and_insert_prefix(para_Prefix VARCHAR2, para_City_ID NUMBER, para_Usage_Type_ID NUMBER) IS\n  v_Prefix_ID NUMBER;\n  v_Existing_Count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_Existing_Count FROM NUMBER_PREFIXES WHERE PREFIX = para_Prefix;\n  IF v_Existing_Count = 0 THEN\n    SELECT NVL(MAX(PREFIX_ID), 0) + 1 INTO v_Prefix_ID FROM NUMBER_PREFIXES;\n    INSERT INTO NUMBER_PREFIXES (PREFIX_ID, PREFIX, PRIMARY_CITY, COMPANY_ID, COUNTY, USAGE_TYPE_ID, INTRODUCED_DATE, STATUS, LAST_UPDATED, NOTES, CITY_ID)\n    VALUES (v_Prefix_ID, para_Prefix, 'Unknown', MOD(para_Usage_Type_ID, 2), 'Unknown', para_Usage_Type_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'new', TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), 'Auto-created', para_City_ID);\n  END IF;\nEND;",
    "database_name": "telecommunication_naa_usa",
    "tables": [
      "NUMBER_ALLOCATIONS",
      "NUMBER_PREFIXES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_validate_and_insert_prefix('684 - 300', 1, 0);\n  commit;\nEND;",
      "BEGIN\n  sp_validate_and_insert_prefix('684 - 301', 0, 1);\n  commit;\nEND;",
      "BEGIN\n  sp_validate_and_insert_prefix('684 - 302', 1, 1);\n  commit;\nEND;",
      "BEGIN\n  sp_validate_and_insert_prefix('684 - 303', 0, 0);\n  commit;\nEND;",
      "BEGIN\n  sp_validate_and_insert_prefix('684 - 304', 1, 0);\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_validate_and_insert_prefix that inserts a new record into the NUMBER_PREFIXES table only if the provided PREFIX does not already exist. The procedure takes a PREFIX value, a CITY_ID, and a USAGE_TYPE_ID as inputs. When inserting, it generates a new PREFIX_ID by incrementing the maximum existing ID, sets PRIMARY_CITY and COUNTY to 'Unknown', sets STATUS to 'new', sets NOTES to 'Auto-created', calculates COMPANY_ID as the remainder of USAGE_TYPE_ID divided by 2, uses the current date for INTRODUCED_DATE, uses the current date and time for LAST_UPDATED, and includes the provided CITY_ID and USAGE_TYPE_ID.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_validate_and_insert_prefix that inserts a new telephone number prefix into the NUMBER_PREFIXES table only if it does not already exist, automatically generating a new unique PREFIX_ID, setting PRIMARY_CITY and COUNTY to 'Unknown', STATUS to 'new', NOTES to 'Auto-created', and populating all timestamp columns with the current date and time, using the provided prefix, city ID, and usage type ID as inputs.",
    "id": 2,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_validate_and_insert_prefix that is designed to conditionally insert a new telephone number prefix record into the NUMBER_PREFIXES table within the telecommunication_naa_usa database. The procedure accepts three input parameters: p_prefix of type VARCHAR2, which represents the telephone number prefix to be inserted; p_city_id of type NUMBER, which represents the identifier for the associated city; and p_usage_type_id of type NUMBER, which represents the identifier for the usage type classification.\n\nThe procedure begins by declaring a local variable v_count of type NUMBER to store the result of a validation check. It then executes a SELECT statement that counts the number of existing records in the NUMBER_PREFIXES table where the PREFIX column matches the value of the input parameter p_prefix. This count is stored in the v_count variable.\n\nFollowing the validation, the procedure uses an IF-THEN control flow statement to check if v_count equals 0, meaning the prefix does not already exist in the table. If this condition is true, the procedure proceeds to perform an INSERT operation. It inserts a new row into the NUMBER_PREFIXES table. The PREFIX_ID column for the new row is populated by selecting the next value from a sequence named SEQ_PREFIX_ID, which automatically generates a new unique identifier. The PREFIX column is populated with the value from the p_prefix input parameter. The CITY_ID column is populated with the value from the p_city_id input parameter. The USAGE_TYPE_ID column is populated with the value from the p_usage_type_id input parameter. The PRIMARY_CITY column is hardcoded to the string 'Unknown'. The COUNTY column is also hardcoded to the string 'Unknown'. The STATUS column is hardcoded to the string 'new'. The NOTES column is hardcoded to the string 'Auto-created'. The CREATED_AT, UPDATED_AT, and any other timestamp columns (implied by \"all timestamp columns\") are populated by calling the SYSDATE function, which provides the current date and time from the database server. If the condition v_count = 0 is false (meaning the prefix already exists), the INSERT operation is skipped, and no action is taken for the duplicate prefix. The procedure does not have any output parameters and does not return a value; its purpose is solely to perform the conditional insert.",
    "original_summary": "Create a stored procedure named sp_validate_and_insert_prefix that inserts a new number prefix only if it does not already exist. The procedure should generate a new PREFIX_ID, set default values for several columns including 'Unknown' for PRIMARY_CITY and COUNTY, 'new' for STATUS, and 'Auto-created' for NOTES, and use the current date for timestamps.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create a comprehensive stored procedure, which should be named sp_validate_and_insert_prefix, that is designed to carefully insert a new telephone number prefix into the database, but only after it meticulously checks and confirms that the specified prefix does not already exist within the system. This procedure must automatically generate a unique, new PREFIX_ID for each successful insertion. Furthermore, it should thoughtfully assign sensible default values to several important columns: it must set the PRIMARY_CITY and COUNTY columns to the descriptive placeholder 'Unknown', it should mark the STATUS column with the value 'new' to indicate its recent creation, and it must populate the NOTES field with the explanatory text 'Auto-created' to document its origin. Finally, the procedure must also ensure that all relevant timestamp columns are accurately populated with the precise current date and time."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteOldThresholds that accepts a single parameter, p_sensor_id, which is of type NUMBER. This procedure performs a delete operation on the THRESHOLDS table. Specifically, it removes all rows where the SENSOR_ID column matches the value provided in the p_sensor_id parameter and the THRESHOLD_TYPE column is equal to the string 'low'. The procedure does not involve any conditional statements beyond the WHERE clause used in the DELETE operation, nor does it call any functions or perform any special operations. The logic flow is straightforward: upon execution, the procedure deletes all records from the THRESHOLDS table that meet the specified conditions, effectively removing entries associated with the given sensor ID that have a threshold type classified as 'low'.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteOldThresholds(p_sensor_id NUMBER) AS\nBEGIN\n    DELETE FROM THRESHOLDS\n    WHERE SENSOR_ID = p_sensor_id\n    AND THRESHOLD_TYPE = 'low';\nEND;",
    "database_name": "time_sdaaa_detection",
    "tables": [
      "SENSORS",
      "TIME_SERIES_DATA",
      "ANOMALY_DETECTION",
      "CHANGEPOINT_DETECTION",
      "THRESHOLDS",
      "TREND_ANALYSIS"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteOldThresholds(p_sensor_id => 0);\nEND;",
      "BEGIN\n  DeleteOldThresholds(p_sensor_id => 1);\nEND;",
      "BEGIN\n  DeleteOldThresholds(p_sensor_id => 10);\nEND;",
      "BEGIN\n  DeleteOldThresholds(p_sensor_id => 100);\nEND;",
      "BEGIN\n  DeleteOldThresholds(p_sensor_id => 5);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named DeleteOldThresholds that removes all low threshold records for a specific sensor from the THRESHOLDS table, using the input sensor identifier to match the SENSOR_ID and deleting only those rows where the THRESHOLD_TYPE is 'low'.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called DeleteOldThresholds that removes outdated low thresholds from the THRESHOLDS table by deleting all rows where the SENSOR_ID matches a provided sensor identifier and the THRESHOLD_TYPE is 'low'.",
    "id": 3,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DeleteOldThresholds that accepts a single parameter, p_sensor_id, which is of type NUMBER. This procedure performs a delete operation on the THRESHOLDS table. Specifically, it removes all rows where the SENSOR_ID column matches the value provided in the p_sensor_id parameter and the THRESHOLD_TYPE column is equal to the string 'low'. The procedure does not involve any conditional statements beyond the WHERE clause used in the DELETE operation, nor does it call any functions or perform any special operations. The logic flow is straightforward: upon execution, the procedure deletes all records from the THRESHOLDS table that meet the specified conditions, effectively removing entries associated with the given sensor ID that have a threshold type classified as 'low'.",
    "original_summary": "Create a stored procedure named DeleteOldThresholds that deletes rows from the THRESHOLDS table. It takes one NUMBER parameter, p_sensor_id. Delete all rows where SENSOR_ID equals p_sensor_id and THRESHOLD_TYPE equals 'low'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as 'DeleteOldThresholds'. This procedure shall be designed to remove records from the THRESHOLDS table. It must accept a single parameter of type NUMBER, named p_sensor_id. The procedure's operation is to delete all rows for which the SENSOR_ID column matches the provided p_sensor_id parameter and the THRESHOLD_TYPE column holds the value 'low'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `insert_new_lease` that accepts three input parameters: `p_tenant_id` of type `NUMBER`, representing the unique identifier for a tenant; `p_property_id` of type `NUMBER`, representing the unique identifier for a property; and `p_start_date` of type `VARCHAR2`, representing the lease start date in 'YYYY-MM-DD' format. The procedure performs a single `INSERT` operation into the `LEASES` table. For the `LEASE_ID` column, it calculates the next available lease ID by selecting the maximum `LEASE_ID` from the `LEASES` table, using `NVL` to default to `0` if no leases exist, and then adding `1` to the result. The `TENANT_ID` column is populated with the value provided by the `p_tenant_id` parameter. The `PROPERTY_ID` column is populated with the value provided by the `p_property_id` parameter. The `START_DATE` column is populated with the value provided by the `p_start_date` parameter. The `END_DATE` column is calculated by first converting the `p_start_date` parameter from `VARCHAR2` to a `DATE` type using the format mask 'YYYY-MM-DD' via the `TO_DATE` function, then adding 12 months to this date using the `ADD_MONTHS` function, and finally converting the resulting date back to a `VARCHAR2` type in 'YYYY-MM-DD' format using the `TO_CHAR` function. The `MONTHLY_RENT` column is set to a fixed value of `1500`. The `SECURITY_DEPOSIT` column is set to a fixed value of `1500`. The `LATE_FEE` column is set to a fixed value of `50`. The `PAYMENT_FREQUENCY` column is set to the string literal 'Monthly'.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_lease(\n    p_tenant_id IN NUMBER,\n    p_property_id IN NUMBER,\n    p_start_date IN VARCHAR2\n) IS\nBEGIN\n    INSERT INTO LEASES (LEASE_ID, TENANT_ID, PROPERTY_ID, START_DATE, END_DATE, MONTHLY_RENT, SECURITY_DEPOSIT, LATE_FEE, PAYMENT_FREQUENCY)\n    VALUES ((SELECT NVL(MAX(LEASE_ID), 0) + 1 FROM LEASES), p_tenant_id, p_property_id, p_start_date, \n            TO_CHAR(ADD_MONTHS(TO_DATE(p_start_date, 'YYYY-MM-DD'), 12), 'YYYY-MM-DD'), 1500, 1500, 50, 'Monthly');\nEND;",
    "database_name": "real_epmat_tracking",
    "tables": [
      "PROPERTIES",
      "ADDRESSES",
      "TENANTS",
      "LEASES",
      "PAYMENTS"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_lease(0, 1, '2023-03-01');\n  commit;\nEND;",
      "BEGIN\n  insert_new_lease(1, 0, '2023-04-01');\n  commit;\nEND;",
      "BEGIN\n  insert_new_lease(0, 0, '2023-05-01');\n  commit;\nEND;",
      "BEGIN\n  insert_new_lease(1, 1, '2023-06-01');\n  commit;\nEND;",
      "BEGIN\n  insert_new_lease(0, 1, '2023-07-01');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named insert_new_lease that accepts a tenant ID, a property ID, and a start date to create a new lease in the LEASES table. The procedure must generate a new LEASE_ID, use the provided TENANT_ID and PROPERTY_ID, set the START_DATE, calculate the END_DATE as 12 months after the start date, and set the MONTHLY_RENT to 1500, the SECURITY_DEPOSIT to 1500, the LATE_FEE to 50, and the PAYMENT_FREQUENCY to 'Monthly'.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called insert_new_lease that takes a tenant ID, a property ID, and a start date, and adds a new record to the LEASES table. It should generate a new LEASE_ID by incrementing the highest existing one, use the provided TENANT_ID and PROPERTY_ID, set the given START_DATE, calculate an END_DATE one year later, and assign standard values: 1500 for MONTHLY_RENT, 1500 for SECURITY_DEPOSIT, 50 for LATE_FEE, and 'Monthly' for PAYMENT_FREQUENCY.",
    "id": 4,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named insert_new_lease that accepts three input parameters: p_tenant_id of type NUMBER, p_property_id of type NUMBER, and p_start_date of type DATE. The procedure operates on the real_epmat_tracking database and is designed to insert a new record into the LEASES table.\n\nThe procedure begins by declaring a local variable v_new_lease_id of type NUMBER to store the generated lease ID. It then performs a SELECT operation on the LEASES table to retrieve the maximum existing value from the LEASE_ID column, incrementing this value by 1 to generate the new lease ID. If no existing records are found, the procedure defaults the new lease ID to 1.\n\nNext, the procedure calculates the END_DATE by adding exactly one year to the provided p_start_date using date arithmetic. The procedure then constructs an INSERT statement to add a new row to the LEASES table. The inserted values are as follows: the generated v_new_lease_id for the LEASE_ID column, the input parameter p_tenant_id for the TENANT_ID column, the input parameter p_property_id for the PROPERTY_ID column, the input parameter p_start_date for the START_DATE column, the calculated END_DATE for the END_DATE column, a fixed value of 1500 for the MONTHLY_RENT column, a fixed value of 1500 for the SECURITY_DEPOSIT column, a fixed value of 50 for the LATE_FEE column, and a fixed string 'Monthly' for the PAYMENT_FREQUENCY column.\n\nThe procedure performs no explicit return, as it is a stored procedure that modifies the database state by inserting a single record.",
    "original_summary": "Create a stored procedure named insert_new_lease that accepts a tenant ID, property ID, and start date. Insert a new lease into the LEASES table. Generate a new LEASE_ID, use the provided tenant and property IDs, set the start date, calculate the end date as 12 months later, and set fixed values for monthly rent, security deposit, late fee, and payment frequency.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called insert_new_lease that takes a tenant ID, a property ID, and a start date. It should add a new record to the LEASES table. You'll need to come up with a new LEASE_ID, use the given tenant and property details, put in the start date, figure out an end date roughly a year after, and set some reasonable standard amounts for the monthly rent, the security deposit, the late fee, and how often payments are due."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_model_name that accepts two parameters: para_model_id of type NUMBER and para_new_name of type VARCHAR2. The procedure first performs a SELECT operation to count the number of rows in the MODELS table where the MODEL_ID column matches the value of para_model_id, storing the result in a local variable v_count of type NUMBER. It then evaluates a conditional statement: if v_count is greater than 0, indicating that a row with the specified MODEL_ID exists, the procedure executes an UPDATE operation on the MODELS table, setting the MODEL_NAME column to the value of para_new_name for the row where MODEL_ID equals para_model_id. If v_count is not greater than 0, meaning no such row exists, the procedure performs an INSERT operation into the MODELS table, adding a new row with the MODEL_ID column set to para_model_id and the MODEL_NAME column set to para_new_name.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_model_name(para_model_id NUMBER, para_new_name VARCHAR2) IS\n  v_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_count FROM MODELS WHERE MODEL_ID = para_model_id;\n  IF v_count > 0 THEN\n    UPDATE MODELS SET MODEL_NAME = para_new_name WHERE MODEL_ID = para_model_id;\n  ELSE\n    INSERT INTO MODELS (MODEL_ID, MODEL_NAME) VALUES (para_model_id, para_new_name);\n  END IF;\nEND;",
    "database_name": "machine_lmpm_310382",
    "tables": [
      "MODELS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_model_name(0, 'Updated Model A');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_model_name(1, 'Enhanced Model B');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_model_name(2, 'New Model C');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_model_name(10, 'New Logistic Regression Model');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_model_name(1, 'Support Vector Machine v2');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_update_model_name that accepts a model ID and a new model name, checks if a model with that ID already exists in the MODELS table, updates the MODEL_NAME for that existing model if found, or inserts a new row with the provided MODEL_ID and MODEL_NAME if it does not exist.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_update_model_name that accepts a model ID and a new model name as parameters, checks if a model with that ID already exists in the MODELS table, updates the MODEL_NAME to the new name if it exists, or inserts a new record with the provided ID and name if it does not exist.",
    "id": 5,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_model_name that accepts two parameters: para_model_id of type NUMBER and para_new_name of type VARCHAR2. The procedure first performs a SELECT operation to count the number of rows in the MODELS table where the MODEL_ID column matches the value of para_model_id, storing the result in a local variable v_count of type NUMBER. It then evaluates a conditional statement: if v_count is greater than 0, indicating that a row with the specified MODEL_ID exists, the procedure executes an UPDATE operation on the MODELS table, setting the MODEL_NAME column to the value of para_new_name for the row where MODEL_ID equals para_model_id. If v_count is not greater than 0, meaning no such row exists, the procedure performs an INSERT operation into the MODELS table, adding a new row with the MODEL_ID column set to para_model_id and the MODEL_NAME column set to para_new_name.",
    "original_summary": "Create a stored procedure named `sp_update_model_name` that takes `para_model_id` (NUMBER) and `para_new_name` (VARCHAR2) as input. Check if a model with the given ID exists in the `MODELS` table. If it exists, update its `MODEL_NAME` to the new name. If it does not exist, insert a new row with the provided ID and name.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Write a stored procedure called `sp_update_model_name` that accepts `para_model_id` (NUMBER) and `para_new_name` (VARCHAR2) as parameters. First, verify if a model with the specified ID is present in the `MODELS` table. If it exists, update its `MODEL_NAME` to the new name. If it does not exist, insert a new record using the provided ID and name."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_inventory_and_check_reorder that accepts three parameters: p_item_id of type NUMBER, p_size_id of type NUMBER, and p_new_quantity of type NUMBER. This procedure first retrieves the inventory_id, current quantity, and reorder level from the inventory table for the row where the item_id matches p_item_id and the size_id matches p_size_id, storing these values into local variables v_inventory_id, v_current_qty, and v_reorder_level, respectively. It then updates the quantity column in the inventory table to the value of p_new_quantity for the row identified by v_inventory_id. The procedure includes a conditional statement that checks if p_new_quantity is less than v_reorder_level. If true, it updates the restock_level column in the inventory table to twice the value of v_reorder_level for the row with inventory_id equal to v_inventory_id. Otherwise, it sets the restock_level to the value of v_reorder_level for the same row. Additionally, if p_new_quantity is less than v_reorder_level, the procedure inserts a new row into the product_images table with a unique image_id generated by selecting the maximum existing image_id from the table and adding one, the item_id set to p_item_id, the image_url set to 'https://example.com/reorder.jpg', and the image_type set to 'alert'.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_inventory_and_check_reorder(p_item_id NUMBER, p_size_id NUMBER, p_new_quantity NUMBER)\nIS\n    v_current_qty NUMBER;\n    v_reorder_level NUMBER;\n    v_inventory_id NUMBER;\nBEGIN\n    SELECT inventory_id, quantity, reorder_level INTO v_inventory_id, v_current_qty, v_reorder_level\n    FROM inventory\n    WHERE item_id = p_item_id AND size_id = p_size_id;\n    \n    UPDATE inventory \n    SET quantity = p_new_quantity\n    WHERE inventory_id = v_inventory_id;\n    \n    IF p_new_quantity < v_reorder_level THEN\n        UPDATE inventory \n        SET restock_level = v_reorder_level * 2\n        WHERE inventory_id = v_inventory_id;\n    ELSE\n        UPDATE inventory \n        SET restock_level = v_reorder_level\n        WHERE inventory_id = v_inventory_id;\n    END IF;\n    \n    IF p_new_quantity < v_reorder_level THEN\n        INSERT INTO product_images (image_id, item_id, image_url, image_type)\n        VALUES ((SELECT NVL(MAX(image_id), 0) + 1 FROM product_images), p_item_id, 'https://example.com/reorder.jpg', 'alert');\n    END IF;\nEND;",
    "database_name": "fashion_aas_guide",
    "tables": [
      "CLOTHING_ITEMS",
      "FABRIC_TYPES",
      "INVENTORY",
      "ITEM_SIZES",
      "PRODUCT_IMAGES",
      "SIZES",
      "STYLE_TYPES"
    ],
    "call_sqls": [
      "BEGIN\n  update_inventory_and_check_reorder(0, 1, 15);\n  commit;\nEND;",
      "BEGIN\n  update_inventory_and_check_reorder(0, 0, 5);\n  commit;\nEND;",
      "BEGIN\n  update_inventory_and_check_reorder(0, 1, 25);\n  commit;\nEND;",
      "BEGIN\n  update_inventory_and_check_reorder(0, 0, 30);\n  commit;\nEND;",
      "BEGIN\n  update_inventory_and_check_reorder(0, 1, 10);\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_inventory_and_check_reorder that, given an item ID, a size ID, and a new quantity, updates the quantity for that specific item and size in the INVENTORY table, and then checks if the new quantity is below the reorder level. If it is below, it sets the restock level in INVENTORY to double the reorder level and also inserts a new 'alert' type record into the PRODUCT_IMAGES table for that item. If the new quantity is not below the reorder level, it resets the restock level in INVENTORY to the standard reorder level.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_inventory_and_check_reorder that updates an item's quantity in the inventory table using the provided item ID, size ID, and new quantity, and then manages reorder alerts by checking if the new quantity falls below the reorder level; if it does, set the restock level to double the reorder level and insert an 'alert' type record into the product_images table, otherwise reset the restock level to the standard reorder level.",
    "id": 6,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_inventory_and_check_reorder that is designed to update inventory quantities and manage reorder alerts. The procedure operates within the fashion_aas_guide database. It accepts three input parameters: p_item_id of type NUMBER, p_size_id of type NUMBER, and p_new_quantity of type NUMBER. These parameters are used to identify a specific inventory record and specify the new quantity value.\n\nThe procedure begins by performing an UPDATE operation on the inventory table. The UPDATE statement modifies the quantity column for the specific row where the item_id column matches the input parameter p_item_id and the size_id column matches the input parameter p_size_id. The quantity is set to the value of p_new_quantity.\n\nFollowing the update, the procedure executes a SELECT query to retrieve the reorder_level column from the inventory table for the same item and size combination, using the same WHERE clause conditions (item_id = p_item_id AND size_id = p_size_id). The retrieved value is stored into a local variable, v_reorder_level, of type NUMBER.\n\nThe core business logic involves a conditional check. The procedure compares the new quantity (p_new_quantity) with the retrieved reorder level (v_reorder_level). If p_new_quantity is less than v_reorder_level, it triggers a reorder alert process. In this case, a new local variable, v_restock_level, is calculated as double the v_reorder_level (i.e., v_reorder_level * 2). Subsequently, an INSERT operation is performed on the product_images table. The INSERT statement adds a new record with a specific set of column values. While the exact column list is not fully specified in the description, the logic implies that the inserted record is of 'alert' type. Based on common schema patterns, it is inferred that the INSERT likely populates columns such as item_id (with the value from p_item_id), image_type (with the literal string 'alert'), and potentially other columns like alert_timestamp or status, though these details are not explicitly defined. The description states the record is inserted into the product_images table, which suggests this table is used for storing various types of product-related records, including alerts.\n\nIf the condition is not met (i.e., p_new_quantity is greater than or equal to v_reorder_level), the else branch of the logic is executed. Here, the v_restock_level variable is set to be equal to the standard v_reorder_level value.\n\nFinally, regardless of the conditional path taken, the procedure performs a second UPDATE operation on the inventory table. This UPDATE sets the restock_level column for the identified item and size (using the same WHERE clause: item_id = p_item_id AND size_id = p_size_id) to the calculated value stored in the v_restock_level variable. This ensures the restock_level in the inventory record is always updated to reflect either the doubled reorder level (if an alert was generated) or reset back to the standard reorder level. The procedure does not have any explicit output parameters; its primary effect is the side effects of the UPDATE and INSERT operations on the database tables.",
    "original_summary": "Create a stored procedure named update_inventory_and_check_reorder that updates an item's quantity and manages reorder alerts. It accepts an item ID, size ID, and new quantity. The procedure retrieves the current inventory details, updates the quantity, and checks if the new quantity falls below the reorder level. If it does, it sets the restock level to double the reorder level and inserts an 'alert' type image record. Otherwise, it resets the restock level to the standard reorder level.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure named update_inventory_and_check_reorder that updates an item's quantity and manages reorder alerts by accepting an item ID, size ID, and new quantity, retrieving current inventory details, updating the quantity, and then checking if the new quantity falls below the reorder level to either set the restock level to double the reorder level and insert an 'alert' type image record or reset the restock level to the standard reorder level?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_create_experiment_parameter` that accepts four input parameters: `para_experiment_id` of type `NUMBER`, representing the unique identifier of an experiment; `para_parameter_name` of type `VARCHAR2`, representing the name of the parameter to be associated with the experiment; `para_parameter_value` of type `VARCHAR2`, representing the value of the parameter; and `para_user_id` of type `NUMBER`, representing the unique identifier of the user performing the operation. The procedure declares two local variables: `v_parameter_id` of type `NUMBER`, intended to store the newly generated parameter identifier, and `v_exists` of type `NUMBER`, intended to store a count indicating the existence of a specific experiment.\n\nThe procedure begins by executing a `SELECT` statement to count the number of rows in the `EXPERIMENTS` table where the `EXPERIMENT_ID` column matches the input `para_experiment_id` and the `USER_ID` column matches the input `para_user_id`. The result of this count is stored in the `v_exists` variable.\n\nFollowing this, a conditional `IF` statement checks if the value of `v_exists` is greater than `0`. This condition evaluates whether an experiment with the specified `EXPERIMENT_ID` exists and is associated with the provided `USER_ID`.\n\nIf the condition `v_exists > 0` is true, indicating that the experiment exists and belongs to the specified user, the procedure proceeds to execute another `SELECT` statement. This statement calculates a new `PARAMETER_ID` by querying the `EXPERIMENT_PARAMETERS` table. It retrieves the maximum value from the `PARAMETER_ID` column, uses the `NVL` function to treat a `NULL` result (if no parameters exist yet) as `0`, and then adds `1` to this result. The calculated new `PARAMETER_ID` is stored in the `v_parameter_id` variable.\n\nImmediately after determining the new `PARAMETER_ID`, an `INSERT` statement is executed to add a new row into the `EXPERIMENT_PARAMETERS` table. The `PARAMETER_ID` column is populated with the value from `v_parameter_id`, the `EXPERIMENT_ID` column is populated with the value from `para_experiment_id`, the `PARAMETER_NAME` column is populated with the value from `para_parameter_name`, and the `PARAMETER_VALUE` column is populated with the value from `para_parameter_value`.\n\nIf the initial condition `v_exists > 0` is false, meaning the experiment does not exist or is not associated with the specified user, no further operations are performed within the procedure.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_create_experiment_parameter(para_experiment_id NUMBER, para_parameter_name VARCHAR2, para_parameter_value VARCHAR2, para_user_id NUMBER) IS\n    v_parameter_id NUMBER;\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_exists FROM EXPERIMENTS WHERE EXPERIMENT_ID = para_experiment_id AND USER_ID = para_user_id;\n    IF v_exists > 0 THEN\n        SELECT NVL(MAX(PARAMETER_ID), 0) + 1 INTO v_parameter_id FROM EXPERIMENT_PARAMETERS;\n        INSERT INTO EXPERIMENT_PARAMETERS (PARAMETER_ID, EXPERIMENT_ID, PARAMETER_NAME, PARAMETER_VALUE)\n        VALUES (v_parameter_id, para_experiment_id, para_parameter_name, para_parameter_value);\n    END IF;\nEND;",
    "database_name": "reinforcement_letaa_93121",
    "tables": [
      "EXPERIMENTS",
      "EXPERIMENT_PARAMETERS",
      "ENTROPY_METRICS",
      "EXPLAINED_VARIANCE"
    ],
    "call_sqls": [
      "BEGIN\n  sp_create_experiment_parameter(0, 'learning_rate', '0.001', 0);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_create_experiment_parameter(1, 'batch_size', '64', 0);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_create_experiment_parameter(0, 'gamma', '0.99', 0);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_create_experiment_parameter(2, 'epsilon', '0.1', 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_create_experiment_parameter(1, 'num_layers', '3', 0);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_create_experiment_parameter that adds a new parameter for an experiment, taking an experiment ID, a parameter name, a parameter value, and a user ID. It must first verify that the specified experiment exists in the EXPERIMENTS table and belongs to the given user. If valid, it generates a new PARAMETER_ID by incrementing the current maximum from the EXPERIMENT_PARAMETERS table, then inserts a new record with the generated PARAMETER_ID, the provided EXPERIMENT_ID, PARAMETER_NAME, and PARAMETER_VALUE into the EXPERIMENT_PARAMETERS table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_create_experiment_parameter that adds a new parameter setting for a test run, requiring the test's ID (EXPERIMENT_ID), the parameter name (PARAMETER_NAME), its value (PARAMETER_VALUE), and the user's ID (USER_ID). The procedure must verify that the test run exists in the EXPERIMENTS table and is linked to the specified user; if valid, it generates a new PARAMETER_ID by incrementing the highest current ID from the EXPERIMENT_PARAMETERS table and inserts the new details into the EXPERIMENT_PARAMETERS table.",
    "id": 7,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp_create_experiment_parameter` that accepts four input parameters: `p_experiment_id` of `NUMBER` type representing the ID of the test run, `p_parameter_name` of `VARCHAR2` type representing the name of the parameter, `p_parameter_value` of `VARCHAR2` type representing the value of the parameter, and `p_user_id` of `NUMBER` type representing the ID of the user. The procedure declares a local variable `v_parameter_id` of `NUMBER` type to store the newly generated parameter ID. The procedure first executes a `SELECT` statement to verify that a record exists in the `EXPERIMENTS` table where the `EXPERIMENT_ID` column matches the input parameter `p_experiment_id` and the `USER_ID` column matches the input parameter `p_user_id`. This check ensures the test run exists and is linked to the specified user. If no such record is found, the procedure raises an application-specific exception to indicate that the experiment does not exist or is not associated with the user. If the validation passes, the procedure then executes a second `SELECT` statement to retrieve the maximum value of the `PARAMETER_ID` column from the `EXPERIMENT_PARAMETERS` table. It uses the `COALESCE` function to default to 0 if no `PARAMETER_ID` exists, then adds 1 to this value to generate a new unique `PARAMETER_ID`. This new ID is stored in the local variable `v_parameter_id`. Finally, the procedure performs an `INSERT` operation into the `EXPERIMENT_PARAMETERS` table. It inserts a new row with the following column values: `PARAMETER_ID` is set to the generated `v_parameter_id`, `EXPERIMENT_ID` is set to the input parameter `p_experiment_id`, `PARAMETER_NAME` is set to the input parameter `p_parameter_name`, `PARAMETER_VALUE` is set to the input parameter `p_parameter_value`, and `USER_ID` is set to the input parameter `p_user_id`. The procedure does not return any value but commits the transaction upon successful insertion.",
    "original_summary": "Create a stored procedure named sp_create_experiment_parameter that adds a new parameter for an experiment. It accepts an experiment ID, parameter name, parameter value, and user ID. The procedure first verifies that the experiment exists and belongs to the specified user. If valid, it generates a new PARAMETER_ID by incrementing the current maximum, then inserts the new record into the EXPERIMENT_PARAMETERS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called sp_create_experiment_parameter to put in a new setting for a test run. It needs the test's ID, what the setting is called, its value, and who's doing it. The procedure should first check that the test run is actually there and that it's associated with the right person. If everything seems okay, it should come up with a new PARAMETER_ID by taking the highest current one and adding a bit to it, then put the new details into the EXPERIMENT_PARAMETERS table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_remove_parameter_by_name that accepts four input parameters: a numeric parameter named para_experiment_id, a variable-length character parameter named para_parameter_name, a numeric parameter named para_user_id, and a variable-length character parameter named para_algorithm. The procedure begins by declaring a local numeric variable named v_valid_experiment. It then executes a SELECT statement that performs a COUNT(*) operation on the EXPERIMENTS table, retrieving the number of rows where the EXPERIMENT_ID column equals the para_experiment_id input, the USER_ID column equals the para_user_id input, and the ALGORITHM column equals the para_algorithm input; this count result is stored into the v_valid_experiment variable. Following this, an IF conditional statement checks if the value of v_valid_experiment is greater than zero. If this condition is true, the procedure executes a DELETE operation on the EXPERIMENT_PARAMETERS table, removing all rows where the EXPERIMENT_ID column matches the para_experiment_id input and the PARAMETER_NAME column matches the para_parameter_name input.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_remove_parameter_by_name(para_experiment_id NUMBER, para_parameter_name VARCHAR2, para_user_id NUMBER, para_algorithm VARCHAR2) IS\n    v_valid_experiment NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_valid_experiment FROM EXPERIMENTS \n    WHERE EXPERIMENT_ID = para_experiment_id AND USER_ID = para_user_id AND ALGORITHM = para_algorithm;\n    IF v_valid_experiment > 0 THEN\n        DELETE FROM EXPERIMENT_PARAMETERS \n        WHERE EXPERIMENT_ID = para_experiment_id AND PARAMETER_NAME = para_parameter_name;\n    END IF;\nEND;",
    "database_name": "reinforcement_letaa_93121",
    "tables": [
      "EXPERIMENTS",
      "EXPERIMENT_PARAMETERS",
      "ENTROPY_METRICS",
      "EXPLAINED_VARIANCE"
    ],
    "call_sqls": [
      "BEGIN\n  sp_remove_parameter_by_name(0, 'learning_rate', 0, 'PPO');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_remove_parameter_by_name(1, 'batch_size', 0, 'DQN');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_remove_parameter_by_name(0, 'gamma', 0, 'PPO');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_remove_parameter_by_name(2, 'epsilon', 1, 'DQN');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_remove_parameter_by_name(1, 'num_layers', 0, 'PPO');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_remove_parameter_by_name that deletes a specific parameter from the EXPERIMENT_PARAMETERS table for an experiment, provided the experiment exists. It accepts an experiment ID, a parameter name, a user ID, and an algorithm. The procedure must first verify that an experiment with the given experiment ID, user ID, and algorithm exists in the EXPERIMENTS table. If such an experiment is found, it then deletes the corresponding parameter entry from the EXPERIMENT_PARAMETERS table where the experiment ID and parameter name match the provided inputs.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_remove_parameter_by_name that deletes a specific parameter setting for an experiment. It takes the experiment's ID, the parameter name, the user's ID, and the algorithm as inputs. First, verify that an experiment exists in the EXPERIMENTS table with the given ID, belonging to the specified user and using the provided algorithm. If such an experiment is found, then remove the corresponding entry from the EXPERIMENT_PARAMETERS table where the experiment ID and parameter name match the inputs.",
    "id": 8,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_remove_parameter_by_name that accepts four input parameters: a numeric parameter named para_experiment_id, a variable-length character parameter named para_parameter_name, a numeric parameter named para_user_id, and a variable-length character parameter named para_algorithm. The procedure begins by declaring a local numeric variable named v_valid_experiment. It then executes a SELECT statement that performs a COUNT(*) operation on the EXPERIMENTS table, retrieving the number of rows where the EXPERIMENT_ID column equals the para_experiment_id input, the USER_ID column equals the para_user_id input, and the ALGORITHM column equals the para_algorithm input; this count result is stored into the v_valid_experiment variable. Following this, an IF conditional statement checks if the value of v_valid_experiment is greater than zero. If this condition is true, the procedure executes a DELETE operation on the EXPERIMENT_PARAMETERS table, removing all rows where the EXPERIMENT_ID column matches the para_experiment_id input and the PARAMETER_NAME column matches the para_parameter_name input.",
    "original_summary": "Create a stored procedure named sp_remove_parameter_by_name that deletes a specific parameter for an experiment. It accepts an experiment ID, parameter name, user ID, and algorithm. The procedure first verifies that an experiment exists with the given ID, user ID, and algorithm. If found, it deletes from the EXPERIMENT_PARAMETERS table where the EXPERIMENT_ID and PARAMETER_NAME match the inputs.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Alright, so we need a stored procedure called sp_remove_parameter_by_name. Basically, it's gotta delete a particular setting for an experiment. You'll feed it the experiment's ID, the name of the parameter, the user's ID, and the algorithm used. First thing it does is check if there's actually an experiment that matches that ID, belongs to that user, and uses that algorithm. If it finds one, it goes ahead and removes the entry from the EXPERIMENT_PARAMETERS table where the experiment ID and the parameter name line up with what you gave it."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named SynchronizeModelVersions that accepts a single input parameter p_model_id of type NUMBER, which identifies a specific model, and performs the following operations: first, it declares local variables v_latest_exp_version, v_current_model_version, v_new_version_number, and v_version_type as VARCHAR2(255), and v_exp_count and v_config_count as NUMBER; then, it queries the EXPERIMENTS table to count the number of rows where the MODEL_ID column equals the input p_model_id, storing the result in v_exp_count; based on this count, it assigns a value to v_version_type: if the count is zero, v_version_type is set to 'patch', if the count is between 1 and 5 inclusive, v_version_type is set to 'minor', and if the count is greater than 5, v_version_type is set to 'major'; next, it performs a SELECT statement to find the maximum VERSION_NUMBER from the EXPERIMENT_VERSIONS table, aliased as ev, by joining it with the EXPERIMENTS table, aliased as e, on the condition that ev.EXPERIMENT_ID equals e.EXPERIMENT_ID, and where e.MODEL_ID equals p_model_id, storing this maximum version in v_latest_exp_version; it then performs another SELECT to find the maximum VERSION_NUMBER from the MODEL_VERSIONS table where the MODEL_ID column equals p_model_id, storing this result in v_current_model_version; following this, it determines the value for v_new_version_number using conditional logic: if v_latest_exp_version is NULL, v_new_version_number is set to 'v1.0'; else if v_current_model_version is NULL, v_new_version_number is also set to 'v1.0'; else if v_version_type equals 'patch', v_new_version_number is set to 'v1.1'; else if v_version_type equals 'minor', v_new_version_number is set to 'v2.0'; otherwise, v_new_version_number is set to 'v3.0'; subsequently, it queries the MODEL_CONFIGS table to count the number of rows where MODEL_ID equals p_model_id, storing the count in v_config_count; finally, if v_config_count is greater than zero, it executes an INSERT statement into the MODEL_VERSIONS table, populating the columns VERSION_ID, MODEL_ID, VERSION_NUMBER, CREATED_AT, DESCRIPTION, and VERSION_TYPE: the VERSION_ID is derived from a subquery that selects the maximum VERSION_ID from the MODEL_VERSIONS table, uses the NVL function to convert NULL to 0, and adds 1 to that result; MODEL_ID is set to the input parameter p_model_id; VERSION_NUMBER is set to the derived v_new_version_number; CREATED_AT is set to the current system timestamp via CURRENT_TIMESTAMP; DESCRIPTION is set to the literal string 'Auto-generated version from experiment sync'; and VERSION_TYPE is set to the previously determined v_version_type.",
    "plsql": "CREATE OR REPLACE PROCEDURE SynchronizeModelVersions(p_model_id IN NUMBER) AS\n   v_latest_exp_version VARCHAR2(255);\n   v_current_model_version VARCHAR2(255);\n   v_new_version_number VARCHAR2(255);\n   v_version_type VARCHAR2(255);\n   v_exp_count NUMBER;\n   v_config_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_exp_count FROM EXPERIMENTS WHERE MODEL_ID = p_model_id;\n   IF v_exp_count = 0 THEN\n      v_version_type := 'patch';\n   ELSIF v_exp_count BETWEEN 1 AND 5 THEN\n      v_version_type := 'minor';\n   ELSE\n      v_version_type := 'major';\n   END IF;\n   SELECT MAX(VERSION_NUMBER) INTO v_latest_exp_version\n   FROM EXPERIMENT_VERSIONS ev\n   JOIN EXPERIMENTS e ON ev.EXPERIMENT_ID = e.EXPERIMENT_ID\n   WHERE e.MODEL_ID = p_model_id;\n   SELECT MAX(VERSION_NUMBER) INTO v_current_model_version\n   FROM MODEL_VERSIONS\n   WHERE MODEL_ID = p_model_id;\n   IF v_latest_exp_version IS NULL THEN\n      v_new_version_number := 'v1.0';\n   ELSIF v_current_model_version IS NULL THEN\n      v_new_version_number := 'v1.0';\n   ELSIF v_version_type = 'patch' THEN\n      v_new_version_number := 'v1.1';\n   ELSIF v_version_type = 'minor' THEN\n      v_new_version_number := 'v2.0';\n   ELSE\n      v_new_version_number := 'v3.0';\n   END IF;\n   SELECT COUNT(*) INTO v_config_count FROM MODEL_CONFIGS WHERE MODEL_ID = p_model_id;\n   IF v_config_count > 0 THEN\n      INSERT INTO MODEL_VERSIONS (VERSION_ID, MODEL_ID, VERSION_NUMBER, CREATED_AT, DESCRIPTION, VERSION_TYPE)\n      VALUES ((SELECT NVL(MAX(VERSION_ID), 0) + 1 FROM MODEL_VERSIONS),\n              p_model_id,\n              v_new_version_number,\n              CURRENT_TIMESTAMP,\n              'Auto-generated version from experiment sync',\n              v_version_type);\n   END IF;\nEND;",
    "database_name": "machine_lmpt_6768",
    "tables": [
      "MODELS",
      "MODEL_VERSIONS",
      "MODEL_CONFIGS",
      "MODEL_DOCUMENTS",
      "EXPERIMENTS",
      "EXPERIMENT_VERSIONS"
    ],
    "call_sqls": [
      "BEGIN\n  SynchronizeModelVersions(p_model_id => 0);\nEND;",
      "BEGIN\n  SynchronizeModelVersions(p_model_id => 1);\nEND;",
      "BEGIN\n  SynchronizeModelVersions(p_model_id => 2);\nEND;",
      "BEGIN\n  SynchronizeModelVersions(p_model_id => 3);\nEND;",
      "BEGIN\n  SynchronizeModelVersions(p_model_id => 4);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named SynchronizeModelVersions that, for a given MODEL_ID, determines a new model version based on related experiment data. It checks the count of records in the EXPERIMENTS table for that MODEL_ID to set a VERSION_TYPE: 'patch' if there are zero experiments, 'minor' for 1 to 5 experiments, or 'major' for more than 5. It then finds the latest VERSION_NUMBER from the EXPERIMENT_VERSIONS table (via EXPERIMENTS) and the current VERSION_NUMBER from the MODEL_VERSIONS table for the model. Based on these, it calculates a new VERSION_NUMBER: 'v1.0' if no latest experiment version exists or no current model version exists, otherwise 'v1.1' for patch, 'v2.0' for minor, or 'v3.0' for major. Finally, if at least one record exists in the MODEL_CONFIGS table for the MODEL_ID, it inserts a new record into the MODEL_VERSIONS table with an auto-incremented VERSION_ID, the provided MODEL_ID, the new VERSION_NUMBER, the current timestamp, a fixed description, and the determined VERSION_TYPE.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called SynchronizeModelVersions that accepts a model identifier as input. It should analyze the number of associated experiments in the EXPERIMENTS table for that model to determine a version type: 'patch' if there are no experiments, 'minor' if there are 1 to 5 experiments, or 'major' if there are more than 5. It should then compute a new version number based on the latest version from EXPERIMENT_VERSIONS (via EXPERIMENTS) and the current version in MODEL_VERSIONS: if no latest experiment version exists or no current model version exists, use 'v1.0'; otherwise, use 'v1.1' for patch, 'v2.0' for minor, or 'v3.0' for major. Finally, if configuration data exists for the model in the MODEL_CONFIGS table, insert a new entry into the MODEL_VERSIONS table with the computed version number and type, along with an auto-generated description and timestamp.",
    "id": 9,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named SynchronizeModelVersions that accepts a single input parameter p_model_id of type NUMBER, which identifies a specific model, and performs the following operations: first, it declares local variables v_latest_exp_version, v_current_model_version, v_new_version_number, and v_version_type as VARCHAR2(255), and v_exp_count and v_config_count as NUMBER; then, it queries the EXPERIMENTS table to count the number of rows where the MODEL_ID column equals the input p_model_id, storing the result in v_exp_count; based on this count, it assigns a value to v_version_type: if the count is zero, v_version_type is set to 'patch', if the count is between 1 and 5 inclusive, v_version_type is set to 'minor', and if the count is greater than 5, v_version_type is set to 'major'; next, it performs a SELECT statement to find the maximum VERSION_NUMBER from the EXPERIMENT_VERSIONS table, aliased as ev, by joining it with the EXPERIMENTS table, aliased as e, on the condition that ev.EXPERIMENT_ID equals e.EXPERIMENT_ID, and where e.MODEL_ID equals p_model_id, storing this maximum version in v_latest_exp_version; it then performs another SELECT to find the maximum VERSION_NUMBER from the MODEL_VERSIONS table where the MODEL_ID column equals p_model_id, storing this result in v_current_model_version; following this, it determines the value for v_new_version_number using conditional logic: if v_latest_exp_version is NULL, v_new_version_number is set to 'v1.0'; else if v_current_model_version is NULL, v_new_version_number is also set to 'v1.0'; else if v_version_type equals 'patch', v_new_version_number is set to 'v1.1'; else if v_version_type equals 'minor', v_new_version_number is set to 'v2.0'; otherwise, v_new_version_number is set to 'v3.0'; subsequently, it queries the MODEL_CONFIGS table to count the number of rows where MODEL_ID equals p_model_id, storing the count in v_config_count; finally, if v_config_count is greater than zero, it executes an INSERT statement into the MODEL_VERSIONS table, populating the columns VERSION_ID, MODEL_ID, VERSION_NUMBER, CREATED_AT, DESCRIPTION, and VERSION_TYPE: the VERSION_ID is derived from a subquery that selects the maximum VERSION_ID from the MODEL_VERSIONS table, uses the NVL function to convert NULL to 0, and adds 1 to that result; MODEL_ID is set to the input parameter p_model_id; VERSION_NUMBER is set to the derived v_new_version_number; CREATED_AT is set to the current system timestamp via CURRENT_TIMESTAMP; DESCRIPTION is set to the literal string 'Auto-generated version from experiment sync'; and VERSION_TYPE is set to the previously determined v_version_type.",
    "original_summary": "Create a stored procedure named SynchronizeModelVersions that generates a new model version based on experiment data. It takes a model ID, analyzes the count and latest version of related experiments to determine a new version number and type, and inserts a new record into the MODEL_VERSIONS table if configuration data exists for the model.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as 'SynchronizeModelVersions'. This procedure shall accept a model identifier as input. It is required to analyze the quantity and most recent version of associated experiments to compute a new version number and classification. Subsequently, provided that configuration data is present for the specified model, the procedure must insert a new entry into the MODEL_VERSIONS table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp1` that accepts a single input parameter. This parameter, named `para_RULE_ID`, is of the `NUMBER` data type and represents a unique identifier for a rule. The procedure's primary purpose is to remove data associated with a specific rule from two different tables. First, it performs a `DELETE` operation on the `ALERT_LOGS` table. This deletion targets all rows in `ALERT_LOGS` where the value in the `RULE_ID` column matches the value provided in the `para_RULE_ID` input parameter. This step effectively removes all child records or log entries that are linked to the specified rule. Following this, the procedure executes another `DELETE` operation, this time on the `ALERT_RULES` table. This second deletion targets the single parent record in `ALERT_RULES` where the value in the `RULE_ID` column is equal to the value supplied in the `para_RULE_ID` input parameter. This step removes the main rule definition itself, but only after its associated log entries have been cleared. The procedure does not contain any conditional logic or loops; it executes these two `DELETE` statements sequentially.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp1(para_RULE_ID NUMBER) IS\nBEGIN\n  -- First, delete child records from ALERT_LOGS that reference the RULE_ID\n  DELETE FROM ALERT_LOGS WHERE RULE_ID = para_RULE_ID;\n\n  -- Then, delete the parent record from ALERT_RULES\n  DELETE FROM ALERT_RULES WHERE RULE_ID = para_RULE_ID;\nEND;",
    "database_name": "meteorological_dcaa_76430",
    "tables": [
      "ALERT_LOGS",
      "ALERT_RULES",
      "DATA_SOURCES",
      "DATA_SOURCE_INTEGRATION",
      "WEATHER_CODES",
      "WEATHER_DATA_CODES"
    ],
    "call_sqls": [
      "BEGIN\n  sp1(0);\nEND;",
      "BEGIN\n  sp1(1);\nEND;",
      "BEGIN\n  sp1(2);\nEND;",
      "BEGIN\n  sp1(3);\nEND;",
      "BEGIN\n  sp1(4);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp1 that accepts a rule identifier (RULE_ID) and deletes all associated alert log entries from the ALERT_LOGS table for that rule, then removes the rule itself from the ALERT_RULES table.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL stored procedure called sp1 that takes a rule_id number? First, it should wipe out all the entries in the ALERT_LOGS table where the RULE_ID matches the one you give it. After that, go ahead and delete the matching rule from the ALERT_RULES table.",
    "id": 10,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp1` that accepts a single input parameter. This parameter, named `para_RULE_ID`, is of the `NUMBER` data type and represents a unique identifier for a rule. The procedure's primary purpose is to remove data associated with a specific rule from two different tables. First, it performs a `DELETE` operation on the `ALERT_LOGS` table. This deletion targets all rows in `ALERT_LOGS` where the value in the `RULE_ID` column matches the value provided in the `para_RULE_ID` input parameter. This step effectively removes all child records or log entries that are linked to the specified rule. Following this, the procedure executes another `DELETE` operation, this time on the `ALERT_RULES` table. This second deletion targets the single parent record in `ALERT_RULES` where the value in the `RULE_ID` column is equal to the value supplied in the `para_RULE_ID` input parameter. This step removes the main rule definition itself, but only after its associated log entries have been cleared. The procedure does not contain any conditional logic or loops; it executes these two `DELETE` statements sequentially.",
    "original_summary": "Create a PL/SQL procedure named sp1 that accepts a rule_id number. Delete all records from the ALERT_LOGS table where the RULE_ID matches the input, then delete the corresponding rule from the ALERT_RULES table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a PL/SQL procedure called sp1 that takes a rule_id number? First, it should wipe out all the entries in the ALERT_LOGS table where the RULE_ID matches the one you give it. After that, go ahead and delete the matching rule from the ALERT_RULES table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_stock_for_season that accepts three parameters: p_season of type VARCHAR2, p_discount_rate of type NUMBER, and p_min_stock of type NUMBER. The procedure performs two update operations on the CLOTHING_ITEMS table. The first update operation increases the STOCK column by the value of p_min_stock for rows where the SEASON column matches the value of p_season and the current STOCK value is less than p_min_stock. The second update operation adjusts the PRICE column by multiplying it with the factor (1 - p_discount_rate) for all rows where the SEASON column equals the value of p_season.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_stock_for_season(p_season VARCHAR2, p_discount_rate NUMBER, p_min_stock NUMBER)\nIS\nBEGIN\n   UPDATE CLOTHING_ITEMS\n   SET STOCK = STOCK + p_min_stock\n   WHERE SEASON = p_season AND STOCK < p_min_stock;\n   \n   UPDATE CLOTHING_ITEMS\n   SET PRICE = PRICE * (1 - p_discount_rate)\n   WHERE SEASON = p_season;\nEND;",
    "database_name": "clothing_ssaim_738508",
    "tables": [
      "CLOTHING_ITEMS",
      "ORDERS",
      "ORDER_ITEMS",
      "CUSTOMERS",
      "SIZES"
    ],
    "call_sqls": [
      "BEGIN\n  update_stock_for_season('Summer', 0.10, 100);\n  commit;\nEND;",
      "BEGIN\n  update_stock_for_season('Winter', 0.15, 50);\n  commit;\nEND;",
      "BEGIN\n  update_stock_for_season('Spring', 0.05, 200);\n  commit;\nEND;",
      "BEGIN\n  update_stock_for_season('Fall', 0.20, 75);\n  commit;\nEND;",
      "BEGIN\n  update_stock_for_season('All', 0.25, 150);\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_stock_for_season that accepts a season, a discount rate, and a minimum stock level to adjust the CLOTHING_ITEMS table. For items matching the given season, if the current STOCK is below the specified minimum, increase the STOCK to that minimum level, and for all items of that season, apply the discount rate to reduce the PRICE.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_stock_for_season that accepts a season, a discount rate, and a minimum stock level. For all items in the CLOTHING_ITEMS table matching the given season, if the current STOCK is below the minimum, increase the STOCK to meet that minimum. Then, for all items of that season, apply the discount rate to reduce the PRICE accordingly.",
    "id": 11,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_stock_for_season that accepts three parameters: p_season of type VARCHAR2, p_discount_rate of type NUMBER, and p_min_stock of type NUMBER. The procedure performs two update operations on the CLOTHING_ITEMS table. The first update operation increases the STOCK column by the value of p_min_stock for rows where the SEASON column matches the value of p_season and the current STOCK value is less than p_min_stock. The second update operation adjusts the PRICE column by multiplying it with the factor (1 - p_discount_rate) for all rows where the SEASON column equals the value of p_season.",
    "original_summary": "Create a stored procedure named update_stock_for_season that accepts a season, a discount rate, and a minimum stock level. For clothing items matching the season, increase stock to the minimum level if current stock is below it, and apply the discount rate to the price.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as 'update_stock_for_season'. This procedure must be configured to accept three input parameters: a season, a discount rate, and a minimum stock level. Its operational logic should be as follows: for all inventory items categorized as clothing that correspond to the specified season, evaluate the current stock quantity. If the existing stock falls below the stipulated minimum level, it should be increased to meet that minimum. Subsequently, for these same items, apply the provided discount rate to adjust the retail price accordingly."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named 'sp' that accepts two input parameters: a string parameter 'para_status' and a numeric parameter 'para_year'. The procedure begins by declaring a cursor named 'prop_cur' that selects the PROPERTY_ID, PROPERTY_STATUS, YEAR_BUILT, and PROPERTY_MANAGER_NAME columns from the PROPERTIES table, joining it with the PROPERTY_MANAGERS table on the PROPERTY_MANAGER_ID column, where the PROPERTY_STATUS column equals the input 'para_status' and the YEAR_BUILT column is less than the input 'para_year'. The procedure then declares six local variables: v_has_tenants, v_has_complaints, v_has_inspections, v_has_history, and v_has_restrictions as NUMBER types, and v_action_taken as a BOOLEAN type. The main logic iterates through each record fetched by the 'prop_cur' cursor. For each property record, it initializes the v_action_taken flag to FALSE. It then performs a series of sequential checks and actions, each contingent on the previous check not having taken an action (i.e., v_action_taken is FALSE). First, it counts the number of records in the TENANTS table where the PROPERTY_ID matches the current property's PROPERTY_ID, storing the result in v_has_tenants. If this count is greater than zero, it deletes all records from the TENANT_COMPLAINTS table where the TENANT_ID is found in a subquery selecting TENANT_ID from the TENANTS table for the current PROPERTY_ID, and then sets v_action_taken to TRUE. Second, if no action was taken, it counts the number of complaints for the property by joining the TENANT_COMPLAINTS and TENANTS tables on TENANT_ID where the tenant's PROPERTY_ID matches the current property's PROPERTY_ID, storing the result in v_has_complaints. If this count is greater than zero, it deletes all records from the TENANTS table where the PROPERTY_ID matches the current property's PROPERTY_ID, and sets v_action_taken to TRUE. Third, if no action was taken, it counts the number of records in the PROPERTY_INSPECTIONS table for the current PROPERTY_ID into v_has_inspections. If this count is greater than zero, it deletes all such records from the PROPERTY_INSPECTIONS table and sets v_action_taken to TRUE. Fourth, if no action was taken, it counts the number of records in the PROPERTY_HISTORY table for the current PROPERTY_ID into v_has_history. If this count is greater than zero, it deletes all such records from the PROPERTY_HISTORY table and sets v_action_taken to TRUE. Fifth, if no action was taken, it counts the number of records in the PROPERTY_RESTRICTIONS table for the current PROPERTY_ID into v_has_restrictions. If this count is greater than zero, it deletes all such records from the PROPERTY_RESTRICTIONS table and sets v_action_taken to TRUE. Finally, if after all these checks v_action_taken is still FALSE, it inserts a new record into the PROPERTY_HISTORY table. The inserted values are: for HISTORY_ID, it uses a subquery to calculate the next value by taking the maximum existing HISTORY_ID (or 0 if none) and adding 1; for PROPERTY_ID, it uses the current property's PROPERTY_ID; for CHANGE_DATE, it uses the current system date formatted as 'YYYY-MM-DD' using the TO_CHAR function with SYSDATE; for CHANGE_DESCRIPTION, it uses the string 'Property marked for review'; for CHANGE_TYPE, it uses the string 'status check'; and for PERSON_RESPONSIBLE, it uses the PROPERTY_MANAGER_NAME from the current cursor record.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_status VARCHAR2, para_year NUMBER) IS\n  CURSOR prop_cur IS\n    SELECT p.PROPERTY_ID, p.PROPERTY_STATUS, p.YEAR_BUILT, pm.PROPERTY_MANAGER_NAME\n    FROM PROPERTIES p\n    JOIN PROPERTY_MANAGERS pm ON p.PROPERTY_MANAGER_ID = pm.PROPERTY_MANAGER_ID\n    WHERE p.PROPERTY_STATUS = para_status AND p.YEAR_BUILT < para_year;\n  v_has_tenants NUMBER;\n  v_has_complaints NUMBER;\n  v_has_inspections NUMBER;\n  v_has_history NUMBER;\n  v_has_restrictions NUMBER;\n  v_action_taken BOOLEAN;\nBEGIN\n  FOR prop_rec IN prop_cur LOOP\n    v_action_taken := FALSE;\n    SELECT COUNT(*) INTO v_has_tenants FROM TENANTS WHERE PROPERTY_ID = prop_rec.PROPERTY_ID;\n    IF v_has_tenants > 0 AND NOT v_action_taken THEN\n      DELETE FROM TENANT_COMPLAINTS WHERE TENANT_ID IN (SELECT TENANT_ID FROM TENANTS WHERE PROPERTY_ID = prop_rec.PROPERTY_ID);\n      v_action_taken := TRUE;\n    END IF;\n    SELECT COUNT(*) INTO v_has_complaints FROM TENANT_COMPLAINTS tc JOIN TENANTS t ON tc.TENANT_ID = t.TENANT_ID WHERE t.PROPERTY_ID = prop_rec.PROPERTY_ID;\n    IF v_has_complaints > 0 AND NOT v_action_taken THEN\n      DELETE FROM TENANTS WHERE PROPERTY_ID = prop_rec.PROPERTY_ID;\n      v_action_taken := TRUE;\n    END IF;\n    SELECT COUNT(*) INTO v_has_inspections FROM PROPERTY_INSPECTIONS WHERE PROPERTY_ID = prop_rec.PROPERTY_ID;\n    IF v_has_inspections > 0 AND NOT v_action_taken THEN\n      DELETE FROM PROPERTY_INSPECTIONS WHERE PROPERTY_ID = prop_rec.PROPERTY_ID;\n      v_action_taken := TRUE;\n    END IF;\n    SELECT COUNT(*) INTO v_has_history FROM PROPERTY_HISTORY WHERE PROPERTY_ID = prop_rec.PROPERTY_ID;\n    IF v_has_history > 0 AND NOT v_action_taken THEN\n      DELETE FROM PROPERTY_HISTORY WHERE PROPERTY_ID = prop_rec.PROPERTY_ID;\n      v_action_taken := TRUE;\n    END IF;\n    SELECT COUNT(*) INTO v_has_restrictions FROM PROPERTY_RESTRICTIONS WHERE PROPERTY_ID = prop_rec.PROPERTY_ID;\n    IF v_has_restrictions > 0 AND NOT v_action_taken THEN\n      DELETE FROM PROPERTY_RESTRICTIONS WHERE PROPERTY_ID = prop_rec.PROPERTY_ID;\n      v_action_taken := TRUE;\n    END IF;\n    IF NOT v_action_taken THEN\n      INSERT INTO PROPERTY_HISTORY (HISTORY_ID, PROPERTY_ID, CHANGE_DATE, CHANGE_DESCRIPTION, CHANGE_TYPE, PERSON_RESPONSIBLE)\n      VALUES ((SELECT NVL(MAX(HISTORY_ID),0)+1 FROM PROPERTY_HISTORY), prop_rec.PROPERTY_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'Property marked for review', 'status check', prop_rec.PROPERTY_MANAGER_NAME);\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "real_epmaa_773860",
    "tables": [
      "PROPERTIES",
      "PROPERTY_HISTORY",
      "PROPERTY_INSPECTIONS",
      "PROPERTY_MANAGERS",
      "PROPERTY_RESTRICTIONS",
      "TENANTS",
      "TENANT_COMPLAINTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp('available', 2000);\nEND;",
      "BEGIN\n  sp('rented', 1990);\nEND;",
      "BEGIN\n  sp('maintenance', 1985);\nEND;",
      "BEGIN\n  sp('sold', 2010);\nEND;",
      "BEGIN\n  sp('vacant', 1975);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp that processes PROPERTIES based on a provided status (para_status) and a year threshold (para_year), specifically for properties with that status and built before the given year. For each matching property, it performs a series of conditional checks in order: if tenants exist in the TENANTS table, delete their complaints from TENANT_COMPLAINTS; if not, but complaints exist for tenants at that property, delete the tenants from TENANTS; if not, delete records from PROPERTY_INSPECTIONS; if not, delete records from PROPERTY_HISTORY; if not, delete records from PROPERTY_RESTRICTIONS. If no action was taken from these checks, insert a new 'status check' record into PROPERTY_HISTORY for that property with a description of 'Property marked for review' and the property manager's name as the person responsible.",
    "natural_language": "Write a Oracle PL/SQL stored procedure named sp that processes property records from the PROPERTIES table, filtering them by a given PROPERTY_STATUS and for those built before a specified year. For each qualifying property, it must perform a series of conditional checks in a strict order: first, if TENANTS exist, delete all associated TENANT_COMPLAINTS; if not, check for TENANT_COMPLAINTS and delete the TENANTS if found; if not, delete PROPERTY_INSPECTIONS if they exist; if not, delete PROPERTY_HISTORY if it exists; if not, delete PROPERTY_RESTRICTIONS if they exist. If no deletion occurs at any step, insert a new 'status check' record into PROPERTY_HISTORY for that property.",
    "id": 12,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named 'sp' that accepts two input parameters: a string parameter 'para_status' and a numeric parameter 'para_year'. The procedure begins by declaring a cursor named 'prop_cur' that selects the PROPERTY_ID, PROPERTY_STATUS, YEAR_BUILT, and PROPERTY_MANAGER_NAME columns from the PROPERTIES table, joining it with the PROPERTY_MANAGERS table on the PROPERTY_MANAGER_ID column, where the PROPERTY_STATUS column equals the input 'para_status' and the YEAR_BUILT column is less than the input 'para_year'. The procedure then declares six local variables: v_has_tenants, v_has_complaints, v_has_inspections, v_has_history, and v_has_restrictions as NUMBER types, and v_action_taken as a BOOLEAN type. The main logic iterates through each record fetched by the 'prop_cur' cursor. For each property record, it initializes the v_action_taken flag to FALSE. It then performs a series of sequential checks and actions, each contingent on the previous check not having taken an action (i.e., v_action_taken is FALSE). First, it counts the number of records in the TENANTS table where the PROPERTY_ID matches the current property's PROPERTY_ID, storing the result in v_has_tenants. If this count is greater than zero, it deletes all records from the TENANT_COMPLAINTS table where the TENANT_ID is found in a subquery selecting TENANT_ID from the TENANTS table for the current PROPERTY_ID, and then sets v_action_taken to TRUE. Second, if no action was taken, it counts the number of complaints for the property by joining the TENANT_COMPLAINTS and TENANTS tables on TENANT_ID where the tenant's PROPERTY_ID matches the current property's PROPERTY_ID, storing the result in v_has_complaints. If this count is greater than zero, it deletes all records from the TENANTS table where the PROPERTY_ID matches the current property's PROPERTY_ID, and sets v_action_taken to TRUE. Third, if no action was taken, it counts the number of records in the PROPERTY_INSPECTIONS table for the current PROPERTY_ID into v_has_inspections. If this count is greater than zero, it deletes all such records from the PROPERTY_INSPECTIONS table and sets v_action_taken to TRUE. Fourth, if no action was taken, it counts the number of records in the PROPERTY_HISTORY table for the current PROPERTY_ID into v_has_history. If this count is greater than zero, it deletes all such records from the PROPERTY_HISTORY table and sets v_action_taken to TRUE. Fifth, if no action was taken, it counts the number of records in the PROPERTY_RESTRICTIONS table for the current PROPERTY_ID into v_has_restrictions. If this count is greater than zero, it deletes all such records from the PROPERTY_RESTRICTIONS table and sets v_action_taken to TRUE. Finally, if after all these checks v_action_taken is still FALSE, it inserts a new record into the PROPERTY_HISTORY table. The inserted values are: for HISTORY_ID, it uses a subquery to calculate the next value by taking the maximum existing HISTORY_ID (or 0 if none) and adding 1; for PROPERTY_ID, it uses the current property's PROPERTY_ID; for CHANGE_DATE, it uses the current system date formatted as 'YYYY-MM-DD' using the TO_CHAR function with SYSDATE; for CHANGE_DESCRIPTION, it uses the string 'Property marked for review'; for CHANGE_TYPE, it uses the string 'status check'; and for PERSON_RESPONSIBLE, it uses the PROPERTY_MANAGER_NAME from the current cursor record.",
    "original_summary": "Create a stored procedure that processes properties based on status and year built. For each matching property, it performs a series of conditional checks in order: delete tenant complaints if tenants exist; if not, delete tenants if complaints exist; if not, delete inspections; if not, delete property history; if not, delete property restrictions. If no action was taken from these checks, insert a new 'status check' record into the property history.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Develop a comprehensive stored procedure designed to meticulously process property records, carefully filtering them according to their designated status and the specific year in which they were constructed. For every single property that meets these criteria, the procedure must systematically execute a precise sequence of conditional evaluations in a strict, predetermined order. Initially, it should verify the existence of associated tenants; if tenants are indeed present, it must proceed to delete all related tenant complaint records. Should no tenants be found, it then checks for the presence of any standalone complaints and, if they exist, proceeds to delete the tenant records themselves. If that condition also proves false, the procedure moves on to delete any inspection records linked to the property. Following that, if no inspections were removed, it attempts to delete the entire property history. Subsequently, if the history remains untouched, it then tries to delete any existing property restrictions. Finally, after diligently working through this entire cascade of checks, if absolutely no deletion action was successfully performed at any stage, the procedure must gracefully insert a brand new record, specifically labeled as a 'status check', into the property's historical log."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_treatment_follow_up that accepts two input parameters: a numeric parameter named p_treatment_id and a variable-length character string parameter named p_follow_up_date, and executes a single SQL UPDATE operation on the database table named TREATMENTS, specifically setting the value of the column FOLLOW_UP_DATE to the value provided in the p_follow_up_date parameter for every row in the TREATMENTS table where the value in the column TREATMENT_ID is exactly equal to the numeric value provided in the p_treatment_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_treatment_follow_up(p_treatment_id NUMBER, p_follow_up_date VARCHAR2) IS\nBEGIN\n  UPDATE TREATMENTS SET FOLLOW_UP_DATE = p_follow_up_date WHERE TREATMENT_ID = p_treatment_id;\nEND;",
    "database_name": "healthcare_dma_analytics",
    "tables": [
      "DATAMARTS",
      "DISPENSES",
      "PATIENTS",
      "QUERIES",
      "RESPONSES",
      "TREATMENTS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  update_treatment_follow_up(1, '2024-06-15');\nEND;",
      "BEGIN\n  update_treatment_follow_up(5, '2024-07-01');\nEND;",
      "BEGIN\n  update_treatment_follow_up(10, '2024-05-30');\nEND;",
      "BEGIN\n  update_treatment_follow_up(15, '2024-08-20');\nEND;",
      "BEGIN\n  update_treatment_follow_up(20, '2024-09-10');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_treatment_follow_up that accepts a treatment ID and a new follow-up date, and updates the FOLLOW_UP_DATE in the TREATMENTS table for the specific treatment identified by the given treatment ID.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_treatment_follow_up that updates the FOLLOW_UP_DATE in the TREATMENTS table for a given treatment ID using the provided follow-up date.",
    "id": 13,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_treatment_follow_up that accepts two input parameters: a numeric parameter named p_treatment_id and a variable-length character string parameter named p_follow_up_date, and executes a single SQL UPDATE operation on the database table named TREATMENTS, specifically setting the value of the column FOLLOW_UP_DATE to the value provided in the p_follow_up_date parameter for every row in the TREATMENTS table where the value in the column TREATMENT_ID is exactly equal to the numeric value provided in the p_treatment_id parameter.",
    "original_summary": "Create a stored procedure named update_treatment_follow_up that accepts a treatment ID and a follow-up date. It updates the FOLLOW_UP_DATE in the TREATMENTS table for the row matching the given treatment ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Update the FOLLOW_UP_DATE in the TREATMENTS table for a specified treatment ID using the provided follow-up date. Name this stored procedure update_treatment_follow_up."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts three input parameters: a string parameter `p_agency_type`, a numeric parameter `p_response_threshold`, and a string parameter `p_jurisdiction`. The procedure first declares a cursor named `c_agencies` that selects the `AGENCY_ID` and `NUMBER_OF_OFFICERS` columns from the `POLICE_AGENCIES` table for all rows where the `AGENCY_TYPE` column matches the `p_agency_type` parameter and the `JURISDICTION` column matches the `p_jurisdiction` parameter. The procedure then opens a loop to process each row returned by this cursor. For each agency record fetched from the cursor, it executes a `SELECT COUNT(*)` query on the `TRAFFIC_INCIDENTS` table, counting all rows where the `POLICE_AGENCY` column equals the character string conversion of the current agency's `AGENCY_ID` value (using the `TO_CHAR` function), and stores this count into a local variable `v_incident_count`. If this `v_incident_count` is greater than 10, the procedure performs an `INSERT` into the `SEVERITY_LEVELS` table, creating a new row with a `SEVERITY_ID` column value set to the agency's `AGENCY_ID` plus 100, a `SEVERITY_DESCRIPTION` column set to the literal string 'High Incident Agency', and a `DESCRIPTION_DETAILS` column set to a concatenated string starting with 'Agency with ', followed by the `v_incident_count` value, and ending with ' incidents'. After the loop completes processing all agencies from the cursor, the procedure executes a `DELETE` statement on the `POLICE_AGENCIES` table, removing any rows where the `RESPONSE_TIME` column value is greater than the `p_response_threshold` parameter and the `AGENCY_TYPE` column is not equal to the `p_agency_type` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_agency_type VARCHAR2, p_response_threshold NUMBER, p_jurisdiction VARCHAR2) IS\n  CURSOR c_agencies IS SELECT AGENCY_ID, NUMBER_OF_OFFICERS FROM POLICE_AGENCIES WHERE AGENCY_TYPE = p_agency_type AND JURISDICTION = p_jurisdiction;\n  v_incident_count NUMBER;\nBEGIN\n  FOR agency_rec IN c_agencies LOOP\n    SELECT COUNT(*) INTO v_incident_count FROM TRAFFIC_INCIDENTS WHERE POLICE_AGENCY = TO_CHAR(agency_rec.AGENCY_ID);\n    IF v_incident_count > 10 THEN\n      INSERT INTO SEVERITY_LEVELS (SEVERITY_ID, SEVERITY_DESCRIPTION, DESCRIPTION_DETAILS) VALUES (agency_rec.AGENCY_ID + 100, 'High Incident Agency', 'Agency with ' || v_incident_count || ' incidents');\n    END IF;\n  END LOOP;\n  DELETE FROM POLICE_AGENCIES WHERE RESPONSE_TIME > p_response_threshold AND AGENCY_TYPE != p_agency_type;\nEND;",
    "database_name": "traffic_iraa_624460",
    "tables": [
      "CITIES",
      "POLICE_AGENCIES",
      "ROADWAYS",
      "SEVERITY_LEVELS",
      "TRAFFIC_INCIDENTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp('Local', 18, 'WORCESTER');\n  commit;\nEND;",
      "BEGIN\n  sp('State', 25, 'Massachusetts');\n  commit;\nEND;",
      "BEGIN\n  sp('Local', 20, 'WORCESTER');\n  commit;\nEND;",
      "BEGIN\n  sp('State', 15, 'Massachusetts');\n  commit;\nEND;",
      "BEGIN\n  sp('Local', 22, 'WORCESTER');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `sp` that accepts an agency type, a response time threshold, and a jurisdiction. For each agency in POLICE_AGENCIES matching the given agency type and jurisdiction, count its associated records in TRAFFIC_INCIDENTS; if the count exceeds 10, insert a corresponding record into SEVERITY_LEVELS. After processing all such agencies, delete from POLICE_AGENCIES any agencies where the RESPONSE_TIME exceeds the provided threshold and the AGENCY_TYPE does not match the input agency type.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp that takes an agency type, a response threshold, and a jurisdiction. For each police agency in POLICE_AGENCIES matching the given agency type and jurisdiction, count its traffic incidents from TRAFFIC_INCIDENTS; if the count exceeds 10, insert a new severity record into SEVERITY_LEVELS with a severity ID based on the agency ID and a description noting the incident count. After processing all such agencies, delete any agencies from POLICE_AGENCIES where the response time is greater than the provided threshold and the agency type differs from the input agency type.",
    "id": 14,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that operates on the traffic_iraa_624460 database. The procedure accepts three input parameters: p_agency_type, which is an IN parameter representing the specific type of police agency to process; p_response_threshold, an IN parameter representing the numeric threshold value for response time; and p_jurisdiction, an IN parameter representing the jurisdiction area for filtering police agencies.\n\nThe procedure begins by declaring a cursor named agency_cursor. This cursor selects the agency_id and agency_name from the POLICE_AGENCIES table where the agency_type column matches the input parameter p_agency_type and the jurisdiction column matches the input parameter p_jurisdiction. For each row fetched from this cursor, the procedure executes a loop.\n\nInside the loop, for the current agency, the procedure performs a SELECT COUNT(*) query on the TRAFFIC_INCIDENTS table, counting all rows where the agency_id column matches the agency_id of the current cursor record. This count is stored into a local variable, v_incident_count.\n\nNext, an IF condition checks whether v_incident_count is greater than 10. If true, the procedure constructs a new severity ID by concatenating the string 'SEV_' with the current agency_id, storing it in a local variable v_severity_id. It also constructs a description string by concatenating 'High incident count: ' with the v_incident_count value, storing it in a local variable v_description. Then, it executes an INSERT statement into the SEVERITY_LEVELS table, inserting a new row with the following values: the severity_id column is set to v_severity_id, the agency_id column is set to the current agency_id from the cursor, the description column is set to v_description, and the created_date column is set to the current system date using SYSDATE.\n\nAfter the loop completes processing all agencies matching the type and jurisdiction, the procedure executes a DELETE statement on the POLICE_AGENCIES table. This DELETE removes all rows where the response_time column is greater than the input parameter p_response_threshold and the agency_type column is not equal to the input parameter p_agency_type.\n\nThe procedure does not return any value; it performs data modification operations (INSERT and DELETE) based on the conditional logic described.",
    "original_summary": "Create a stored procedure named `sp` that accepts agency type, response threshold, and jurisdiction parameters. It uses a cursor to fetch agencies matching the type and jurisdiction. For each agency, count its traffic incidents; if over 10, insert a severity record. After the loop, delete agencies where response time exceeds the threshold and agency type does not match the input.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Alright, so we need a stored procedure, call it `sp`. It's gotta take in an agency type, a response threshold, and a jurisdiction. Here's the plan: we'll use a cursor to go through all the agencies that fit the given type and jurisdiction. For each one, we count up its traffic incidents. If that count is more than 10, we slap a new severity record into the system. Once we're done with that loop, we clean house by deleting any agencies where the response time is worse than our threshold AND the agency type isn't the one we started with."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named cleanup_old_statements that accepts a single input parameter p_fiscal_year of type NUMBER, which represents a fiscal year identifier. The procedure first declares two local NUMBER variables: v_statement_count and v_is_versioned. It begins execution by performing a SELECT COUNT(*) query on the financial_statements table, counting all rows where the fiscal_year_id column equals the input parameter p_fiscal_year, and stores the result in v_statement_count. Next, it performs a SELECT MAX(is_versioned) query on the same financial_statements table, again for rows where fiscal_year_id equals p_fiscal_year, to find the maximum value of the is_versioned column, storing this result in v_is_versioned. The procedure then uses an IF-ELSIF-ELSE conditional block. If v_statement_count is greater than 5, it executes a DELETE operation on the comments table, removing all rows where the statement_id column matches any statement_id found in a subquery that selects statement_id from the financial_statements table for the specified p_fiscal_year. Otherwise, if the first condition is false and v_is_versioned equals 1, it executes an UPDATE operation on the financial_statements table, setting the is_versioned column to 0 for all rows where fiscal_year_id equals p_fiscal_year. If neither of the previous conditions is true, it executes an INSERT operation into the comments table, specifying columns comment_id, statement_id, user_id, comment_date, comment_text, is_private, created_by, and created_date. The values for this insert are selected from the financial_statements table for rows where fiscal_year_id equals p_fiscal_year: comment_id is derived by adding 3000 to the statement_id, statement_id is used directly, user_id is hardcoded as 1, comment_date is set to the current date formatted as 'YYYY-MM-DD' using TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), comment_text is the literal string 'Old statement comment', is_private is 0, created_by is 1, and created_date is also the current date formatted as 'YYYY-MM-DD'.",
    "plsql": "CREATE OR REPLACE PROCEDURE cleanup_old_statements(\n    p_fiscal_year NUMBER\n) IS\n    v_statement_count NUMBER;\n    v_is_versioned NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_statement_count \n    FROM financial_statements \n    WHERE fiscal_year_id = p_fiscal_year;\n    \n    SELECT MAX(is_versioned) INTO v_is_versioned \n    FROM financial_statements \n    WHERE fiscal_year_id = p_fiscal_year;\n    \n    IF v_statement_count > 5 THEN\n        DELETE FROM comments \n        WHERE statement_id IN (SELECT statement_id FROM financial_statements WHERE fiscal_year_id = p_fiscal_year);\n    ELSIF v_is_versioned = 1 THEN\n        UPDATE financial_statements \n        SET is_versioned = 0 \n        WHERE fiscal_year_id = p_fiscal_year;\n    ELSE\n        INSERT INTO comments (comment_id, statement_id, user_id, comment_date, comment_text, is_private, created_by, created_date)\n        SELECT statement_id + 3000, statement_id, 1, TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), 'Old statement comment', 0, 1, TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD')\n        FROM financial_statements WHERE fiscal_year_id = p_fiscal_year;\n    END IF;\nEND;",
    "database_name": "financial_saar_660831",
    "tables": [
      "FINANCIAL_STATEMENTS",
      "COMMENTS",
      "VERSIONS"
    ],
    "call_sqls": [
      "BEGIN\n  cleanup_old_statements(p_fiscal_year => 1);\nEND;",
      "BEGIN\n  cleanup_old_statements(p_fiscal_year => 2023);\nEND;",
      "BEGIN\n  cleanup_old_statements(p_fiscal_year => 2024);\nEND;",
      "BEGIN\n  cleanup_old_statements(p_fiscal_year => 1999);\nEND;",
      "BEGIN\n  cleanup_old_statements(p_fiscal_year => 2000);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named cleanup_old_statements that accepts a fiscal_year number. For the given fiscal_year, count the number of records in the financial_statements table and find the maximum is_versioned value. If the count exceeds 5, delete all related comments from the comments table for those statements. Otherwise, if the maximum is_versioned is 1, update all financial_statements records for that fiscal_year to set is_versioned to 0. If neither condition is met, insert a new public comment into the comments table for each financial_statement, where each comment_id is derived by adding 3000 to the statement_id, with a fixed comment text 'Old statement comment', user_id 1, and the current date.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called cleanup_old_statements that accepts a fiscal_year number to manage financial_statements for that fiscal_year. First, count the financial_statements for the given fiscal_year and find the maximum is_versioned value. If the count is greater than 5, delete all related comments for those statements. Otherwise, if the maximum is_versioned is 1, update those financial_statements to set is_versioned to 0. If neither condition is met, insert a new public comment for each financial_statement, deriving the comment_id from the statement_id by adding 3000, with a default user, current date, and standard text.",
    "id": 15,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named cleanup_old_statements that accepts one input parameter p_fiscal_year of type NUMBER, used to identify a specific fiscal year for processing financial statements. The procedure operates on the database financial_saar_660831 and involves the tables financial_statements and comments. The procedure begins by declaring two local variables: v_count of type NUMBER to store the count of financial statements for the given fiscal year, and v_max_is_versioned of type NUMBER to store the maximum value of the is_versioned column among those statements.\n\nThe procedure first performs a SELECT statement with aggregation to retrieve the count of rows and the maximum value of the is_versioned column from the financial_statements table, where the fiscal_year column equals the input parameter p_fiscal_year. The results are stored into the variables v_count and v_max_is_versioned.\n\nNext, the procedure implements conditional logic using IF-ELSIF-ELSE control flow. If v_count is greater than 5, the procedure performs a DELETE operation on the comments table, targeting all rows where the statement_id column matches any statement_id from the financial_statements table that has the same fiscal_year as p_fiscal_year. This is achieved using a subquery in the WHERE clause that selects statement_id from financial_statements where fiscal_year equals p_fiscal_year.\n\nOtherwise, if the first condition is not met and v_max_is_versioned equals 1, the procedure performs an UPDATE operation on the financial_statements table, setting the is_versioned column to 0 for all rows where the fiscal_year column equals p_fiscal_year.\n\nIf neither of the above conditions is true, the procedure performs an INSERT operation into the comments table for each financial statement that matches the fiscal year. For each such financial statement, the procedure inserts a new row with the following values: comment_id is derived by adding 3000 to the statement_id from the financial_statements table, user_id is set to a default value of 'SYSTEM', comment_date is set to the current system date using SYSDATE, comment_text is set to a standard text 'Processed by cleanup procedure', and statement_id is set to the corresponding statement_id from the financial_statements table. This is implemented using a cursor FOR loop that iterates over all rows in financial_statements where fiscal_year equals p_fiscal_year, and for each row, executes an INSERT statement with the computed and default values.\n\nThe procedure does not have any output parameters and does not return a value; it performs data manipulation based on the conditions described.",
    "original_summary": "Create a stored procedure named cleanup_old_statements that accepts a fiscal_year number. Count the financial_statements for that year and find the maximum is_versioned value. If the count is greater than 5, delete related comments. Else, if the maximum is_versioned is 1, update the statements to set is_versioned to 0. Otherwise, insert a new public comment for each statement, deriving the comment_id from the statement_id.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Count the financial_statements for the given fiscal_year and find the maximum is_versioned value. If the count is greater than 5, delete the related comments. Otherwise, if the maximum is_versioned is 1, update those statements to set is_versioned to 0. If neither condition is met, insert a new public comment for each statement, deriving the comment_id from the statement_id. Do this by creating a stored procedure named cleanup_old_statements that accepts a fiscal_year number."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_transform_and_cleanup that accepts two input parameters: p_user_type of type VARCHAR2, which specifies a user category, and p_cutoff_date of type VARCHAR2, which provides a date threshold. The procedure begins by declaring local variables v_user_story_text and v_criteria_text as VARCHAR2(255) to hold text, v_next_activity_id and v_next_story_id as NUMBER for sequence generation, and v_default_user_id as NUMBER initialized to 1. It first attempts to validate the default user by selecting the USER_ID from the USERS table where USER_ID equals the initial v_default_user_id value of 1, limiting the result to one row with ROWNUM = 1; if no row is found, a NO_DATA_FOUND exception is caught and v_default_user_id is set to NULL. Next, it processes each user story created before the p_cutoff_date by executing a FOR loop over a cursor that selects STORY_ID, USER_STORY, and ACCEPTANCE_CRITERIA from the USER_STORIES table where CREATED_AT is less than p_cutoff_date. For each fetched record, it assigns the USER_STORY and ACCEPTANCE_CRITERIA column values to the local variables v_user_story_text and v_criteria_text, respectively. It then safely generates the next activity ID by selecting the maximum existing ACTIVITY_ID from the USER_ACTIVITY table, using NVL to default to 0 if null, and adding 1, storing the result in v_next_activity_id. Using this ID, it inserts a new activity log into the USER_ACTIVITY table, populating ACTIVITY_ID with v_next_activity_id, USER_ID with v_default_user_id (which may be NULL), ACTIVITY_TYPE with the literal 'CLEANUP', ACTIVITY_DATE with the current system date formatted as 'YYYY-MM-DD' using TO_CHAR(SYSDATE, 'YYYY-MM-DD'), ACTIVITY_DESCRIPTION with a concatenated string 'Processed story ' followed by the current story's STORY_ID and ' for cleanup', and setting IP_ADDRESS and USER_AGENT to NULL. After the loop completes, the procedure deletes all expired password reset tokens by executing a DELETE operation on the RESET_PASSWORD_TOKENS table where the EXPIRES_AT column value is less than p_cutoff_date. It then generates the next story ID by selecting the maximum existing STORY_ID from the USER_STORIES table, using NVL to default to 0 if null, and adding 1, storing it in v_next_story_id. Finally, it inserts a new user story record into the USER_STORIES table, setting STORY_ID to v_next_story_id, USER_STORY to a string concatenating 'Cleanup procedure for ', the p_user_type parameter, and ' users', ACCEPTANCE_CRITERIA to 'Delete expired tokens and process old stories', PRIORITY to 'low', RELEASE_SPRINT to 'Sprint-4', DESCRIPTION to 'Data maintenance story', ESTIMATED_EFFORT to 2, and both CREATED_AT and UPDATED_AT to the current system date formatted as 'YYYY-MM-DD' using TO_CHAR(SYSDATE, 'YYYY-MM-DD'). The procedure includes an exception handler for WHEN OTHERS that simply re-raises any encountered error using the RAISE statement.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_transform_and_cleanup(p_user_type IN VARCHAR2, p_cutoff_date IN VARCHAR2)\nIS\n    v_user_story_text VARCHAR2(255);\n    v_criteria_text VARCHAR2(255);\n    v_next_activity_id NUMBER;\n    v_next_story_id NUMBER;\n    v_default_user_id NUMBER := 1;\nBEGIN\n    -- Check if the default user exists, if not use a safe fallback\n    BEGIN\n        SELECT USER_ID INTO v_default_user_id FROM USERS WHERE USER_ID = v_default_user_id AND ROWNUM = 1;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_default_user_id := NULL;\n    END;\n\n    -- Process user stories created before the cutoff date\n    FOR story_rec IN (SELECT STORY_ID, USER_STORY, ACCEPTANCE_CRITERIA FROM USER_STORIES WHERE CREATED_AT < p_cutoff_date) LOOP\n        v_user_story_text := story_rec.USER_STORY;\n        v_criteria_text := story_rec.ACCEPTANCE_CRITERIA;\n\n        -- Generate next activity ID safely\n        SELECT NVL(MAX(ACTIVITY_ID), 0) + 1 INTO v_next_activity_id FROM USER_ACTIVITY;\n\n        -- Log the activity of processing the story\n        INSERT INTO USER_ACTIVITY (ACTIVITY_ID, USER_ID, ACTIVITY_TYPE, ACTIVITY_DATE, ACTIVITY_DESCRIPTION, IP_ADDRESS, USER_AGENT)\n        VALUES (v_next_activity_id, v_default_user_id, 'CLEANUP', TO_CHAR(SYSDATE, 'YYYY-MM-DD'), \n                'Processed story ' || story_rec.STORY_ID || ' for cleanup', NULL, NULL);\n    END LOOP;\n\n    -- Delete expired password reset tokens\n    DELETE FROM RESET_PASSWORD_TOKENS WHERE EXPIRES_AT < p_cutoff_date;\n\n    -- Generate next story ID safely\n    SELECT NVL(MAX(STORY_ID), 0) + 1 INTO v_next_story_id FROM USER_STORIES;\n\n    -- Insert a new user story to document the cleanup procedure\n    INSERT INTO USER_STORIES (STORY_ID, USER_STORY, ACCEPTANCE_CRITERIA, PRIORITY, RELEASE_SPRINT, \n                             DESCRIPTION, ESTIMATED_EFFORT, CREATED_AT, UPDATED_AT)\n    VALUES (v_next_story_id, 'Cleanup procedure for ' || p_user_type || ' users', \n            'Delete expired tokens and process old stories', 'low', 'Sprint-4', \n            'Data maintenance story', 2, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\n\nEXCEPTION\n    WHEN OTHERS THEN\n        -- Basic exception handling to capture errors\n        RAISE;\nEND;",
    "database_name": "user_maafcd_application",
    "tables": [
      "CARS",
      "CAR_RESALE_VALUES",
      "LOGIN_ATTEMPTS",
      "RESET_PASSWORD_TOKENS",
      "USERS",
      "USER_ACTIVITY",
      "USER_STORIES"
    ],
    "call_sqls": [
      "BEGIN\n  proc_transform_and_cleanup(p_user_type => 'customer', p_cutoff_date => '2023-01-01');\nEND;",
      "BEGIN\n  proc_transform_and_cleanup(p_user_type => 'administrator', p_cutoff_date => '2023-03-15');\nEND;",
      "BEGIN\n  proc_transform_and_cleanup(p_user_type => 'guest', p_cutoff_date => '2023-06-30');\nEND;",
      "BEGIN\n  proc_transform_and_cleanup(p_user_type => 'premium', p_cutoff_date => '2022-12-31');\nEND;",
      "BEGIN\n  proc_transform_and_cleanup(p_user_type => 'standard', p_cutoff_date => TO_CHAR(SYSDATE - 30, 'YYYY-MM-DD'));\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named proc_transform_and_cleanup that, for a given user type and cutoff date, validates the existence of a default user from the USERS table, processes all USER_STORIES created before the cutoff date by logging each processed story as a 'CLEANUP' activity in the USER_ACTIVITY table, deletes all expired tokens from the RESET_PASSWORD_TOKENS table where the EXPIRES_AT date is before the cutoff, and finally inserts a new cleanup documentation story into the USER_STORIES table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called proc_transform_and_cleanup that, for a specified user type and a cutoff date, validates a default user account from the USERS table, processes all outdated user stories from the USER_STORIES table created before the cutoff date by logging each cleanup activity into the USER_ACTIVITY table, permanently deletes any expired password tokens from the RESET_PASSWORD_TOKENS table that expired before the cutoff date, and finally inserts a new cleanup story record into the USER_STORIES table to document the procedure.",
    "id": 16,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `proc_transform_and_cleanup` that accepts two input parameters: `p_user_type` of data type `VARCHAR2`, representing the specific user type to be used for validation; and `p_cutoff_date` of data type `DATE`, representing the cutoff date used to identify outdated records. The procedure declares several local variables: `v_default_user_id` of data type `NUMBER`, intended to store the user ID of a validated default user account; `v_user_story_count` of data type `NUMBER`, intended to store the count of outdated user stories processed; `v_deleted_token_count` of data type `NUMBER`, intended to store the count of expired password tokens deleted; and `v_activity_id` of data type `NUMBER`, intended to store the generated primary key for activity log entries.\n\nThe procedure begins by validating a default user account. It performs a `SELECT` statement on the `USERS` table to retrieve the `user_id` of a user where the `user_type` column matches the input parameter `p_user_type` and the `is_default_account` column has a value of 'Y'. This retrieved `user_id` is stored into the local variable `v_default_user_id`. If no such user is found, the procedure raises an application error indicating that no valid default user account exists for the specified user type.\n\nNext, the procedure processes all outdated user stories. It first performs a `SELECT` statement with a `COUNT(*)` aggregation on the `USER_STORIES` table to count all rows where the `created_date` column is strictly less than the input parameter `p_cutoff_date`. This count is stored into the local variable `v_user_story_count`.\n\nThen, the procedure enters a loop to process each outdated user story individually. For each row in the `USER_STORIES` table where `created_date` is less than `p_cutoff_date`, it performs the following operations: It retrieves the `story_id` and `story_title` from the current row. It then generates a new primary key value for the `USER_ACTIVITY` table by selecting from the sequence `user_activity_seq` using `NEXTVAL` and stores it in `v_activity_id`. Following this, it executes an `INSERT` statement into the `USER_ACTIVITY` table. The inserted values are: `v_activity_id` for the `activity_id` column, `v_default_user_id` for the `user_id` column, a string literal 'CLEANUP' for the `activity_type` column, the current system date and time (using `SYSDATE`) for the `activity_date` column, and a concatenated string for the `description` column. This description string is formed by combining the literal 'Cleaned up outdated user story: ', the retrieved `story_title`, and the literal ' (ID: ' followed by the retrieved `story_id` and a closing parenthesis. After logging the activity, it executes a `DELETE` statement to remove the current user story row from the `USER_STORIES` table based on its `story_id`.\n\nAfter processing all outdated user stories, the procedure handles expired password tokens. It performs a `DELETE` statement on the `RESET_PASSWORD_TOKENS` table where the `expiry_date` column is strictly less than the input parameter `p_cutoff_date`. The SQL%ROWCOUNT attribute is used to capture the number of rows deleted by this operation, and this count is stored into the local variable `v_deleted_token_count`.\n\nFinally, the procedure documents its execution by inserting a new cleanup story record. It executes an `INSERT` statement into the `USER_STORIES` table. The values inserted are: a new `story_id` generated from the sequence `user_stories_seq` using `NEXTVAL`, `v_default_user_id` for the `user_id` column, a string literal 'System Cleanup Report' for the `story_title` column, a detailed description string for the `story_description` column, and the current system date and time (using `SYSDATE`) for the `created_date` column. The description string is constructed by concatenating several parts: the literal 'Cleanup procedure executed for user type ', the input parameter `p_user_type`, the literal ' with cutoff date ', the input parameter `p_cutoff_date` (formatted to a string), the literal '. Removed ', the value of `v_user_story_count`, the literal ' outdated user stories and ', the value of `v_deleted_token_count`, and the literal ' expired password tokens.'.\n\nThe procedure performs all database operations within a single transaction, which is committed upon successful completion. If any error occurs during execution, the transaction is rolled back and the error is propagated.",
    "original_summary": "Create a stored procedure named proc_transform_and_cleanup for a given user type. It validates a default user, processes old user stories by logging cleanup activities, deletes expired password tokens, and inserts a new cleanup story record.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create a comprehensive stored procedure, to be named proc_transform_and_cleanup, which is specifically designed for a designated user type. This procedure meticulously validates a default user account, systematically processes outdated user stories by diligently logging all associated cleanup activities, permanently deletes any expired password tokens that are no longer valid, and finally inserts a brand new, detailed cleanup story record into the database."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_insert_model_from_vehicle that accepts four parameters: p_vehicle_id of type NUMBER, p_model_year of type NUMBER, p_model_changes of type VARCHAR2, and p_new_model_id of type NUMBER as an OUT parameter. The procedure begins by declaring two local variables: v_max_id and v_vehicle_exists, both of type NUMBER. It first performs a SELECT operation to count the number of records in the VEHICLES table where the VEHICLE_ID column matches the input parameter p_vehicle_id, storing the result in v_vehicle_exists. If v_vehicle_exists equals zero, indicating that no matching vehicle record exists, the procedure executes an INSERT operation to add a new record to the VEHICLES table with the VEHICLE_ID set to p_vehicle_id, MANUFACTURER_ID set to 1, MODEL_NAME set to 'Default Model', MODEL_YEAR set to p_model_year, and VEHICLE_STATUS set to 'ACTIVE'. Next, the procedure calculates the next available MODEL_ID for the VEHICLE_MODELS table by selecting the maximum value of the MODEL_ID column, using the NVL function to default to zero if no records exist, and adding one to this maximum value, storing the result in v_max_id. It then performs an INSERT operation into the VEHICLE_MODELS table, setting the MODEL_ID to v_max_id, VEHICLE_ID to p_vehicle_id, MODEL_YEAR to p_model_year, MODEL_CHANGES to p_model_changes, and MODEL_STATUS to 'ACTIVE'. Finally, the procedure assigns the value of v_max_id to the OUT parameter p_new_model_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_insert_model_from_vehicle (\n    p_vehicle_id IN NUMBER,\n    p_model_year IN NUMBER,\n    p_model_changes IN VARCHAR2,\n    p_new_model_id OUT NUMBER\n)\nIS\n    v_max_id NUMBER;\n    v_vehicle_exists NUMBER;\nBEGIN\n    -- Check if the vehicle_id exists in VEHICLES table\n    SELECT COUNT(*)\n    INTO v_vehicle_exists\n    FROM VEHICLES\n    WHERE VEHICLE_ID = p_vehicle_id;\n    \n    IF v_vehicle_exists = 0 THEN\n        -- If vehicle_id does not exist, insert a minimal record into VEHICLES\n        -- This assumes a default or minimal set of values for a new vehicle.\n        -- In a real application, more parameters or a separate procedure might be used to create a full vehicle.\n        INSERT INTO VEHICLES (\n            VEHICLE_ID,\n            MANUFACTURER_ID,\n            MODEL_NAME,\n            MODEL_YEAR,\n            VEHICLE_STATUS\n        ) VALUES (\n            p_vehicle_id,\n            1, -- Default manufacturer_id, assuming it exists or is nullable\n            'Default Model',\n            p_model_year,\n            'ACTIVE'\n        );\n        -- Optionally, you might want to commit here if vehicle creation is independent,\n        -- but typically, it's part of the same transaction.\n    END IF;\n    \n    SELECT NVL(MAX(MODEL_ID), 0) + 1 INTO v_max_id FROM VEHICLE_MODELS;\n    INSERT INTO VEHICLE_MODELS (\n        MODEL_ID,\n        VEHICLE_ID,\n        MODEL_YEAR,\n        MODEL_CHANGES,\n        MODEL_STATUS\n    ) VALUES (\n        v_max_id,\n        p_vehicle_id,\n        p_model_year,\n        p_model_changes,\n        'ACTIVE'\n    );\n    p_new_model_id := v_max_id;\nEND;",
    "database_name": "automobile_pas_database",
    "tables": [
      "VEHICLES",
      "VEHICLE_MODELS",
      "VEHICLE_REVIEWS",
      "VEHICLE_SALES"
    ],
    "call_sqls": [
      "DECLARE\n  v_new_model_id NUMBER;\nBEGIN\n  proc_insert_model_from_vehicle(101, 2023, 'New features added', v_new_model_id);\n  DBMS_OUTPUT.PUT_LINE('New Model ID: ' || v_new_model_id);\n  COMMIT;\nEND;",
      "DECLARE\n  v_new_model_id NUMBER;\nBEGIN\n  proc_insert_model_from_vehicle(102, 2022, 'Updated design', v_new_model_id);\n  DBMS_OUTPUT.PUT_LINE('New Model ID: ' || v_new_model_id);\n  COMMIT;\nEND;",
      "DECLARE\n  v_new_model_id NUMBER;\nBEGIN\n  proc_insert_model_from_vehicle(103, 2021, 'Improved safety features', v_new_model_id);\n  DBMS_OUTPUT.PUT_LINE('New Model ID: ' || v_new_model_id);\n  COMMIT;\nEND;",
      "DECLARE\n  v_new_model_id NUMBER;\nBEGIN\n  proc_insert_model_from_vehicle(104, 2020, 'Enhanced performance', v_new_model_id);\n  DBMS_OUTPUT.PUT_LINE('New Model ID: ' || v_new_model_id);\n  COMMIT;\nEND;",
      "DECLARE\n  v_new_model_id NUMBER;\nBEGIN\n  proc_insert_model_from_vehicle(105, 2019, 'New color options', v_new_model_id);\n  DBMS_OUTPUT.PUT_LINE('New Model ID: ' || v_new_model_id);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named proc_insert_model_from_vehicle that, given a VEHICLE_ID, MODEL_YEAR, and MODEL_CHANGES, first checks if the VEHICLE_ID exists in the VEHICLES table; if it does not exist, it inserts a new default vehicle record into VEHICLES with the provided VEHICLE_ID and MODEL_YEAR, using default values for MANUFACTURER_ID, MODEL_NAME, and VEHICLE_STATUS. Then, it inserts a new active model record into the VEHICLE_MODELS table for that VEHICLE_ID, using the provided MODEL_YEAR and MODEL_CHANGES, and returns the newly generated MODEL_ID via an OUT parameter.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called proc_insert_model_from_vehicle that, given a vehicle ID, model year, and model changes, first checks if the vehicle ID exists in the VEHICLES table and inserts a default vehicle record if it is missing, then inserts a new active model into the VEHICLE_MODELS table and returns the new MODEL_ID.",
    "id": 17,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named proc_insert_model_from_vehicle that accepts four parameters: p_vehicle_id of type NUMBER, p_model_year of type NUMBER, p_model_changes of type VARCHAR2, and p_new_model_id of type NUMBER as an OUT parameter. The procedure begins by declaring two local variables: v_max_id and v_vehicle_exists, both of type NUMBER. It first performs a SELECT operation to count the number of records in the VEHICLES table where the VEHICLE_ID column matches the input parameter p_vehicle_id, storing the result in v_vehicle_exists. If v_vehicle_exists equals zero, indicating that no matching vehicle record exists, the procedure executes an INSERT operation to add a new record to the VEHICLES table with the VEHICLE_ID set to p_vehicle_id, MANUFACTURER_ID set to 1, MODEL_NAME set to 'Default Model', MODEL_YEAR set to p_model_year, and VEHICLE_STATUS set to 'ACTIVE'. Next, the procedure calculates the next available MODEL_ID for the VEHICLE_MODELS table by selecting the maximum value of the MODEL_ID column, using the NVL function to default to zero if no records exist, and adding one to this maximum value, storing the result in v_max_id. It then performs an INSERT operation into the VEHICLE_MODELS table, setting the MODEL_ID to v_max_id, VEHICLE_ID to p_vehicle_id, MODEL_YEAR to p_model_year, MODEL_CHANGES to p_model_changes, and MODEL_STATUS to 'ACTIVE'. Finally, the procedure assigns the value of v_max_id to the OUT parameter p_new_model_id.",
    "original_summary": "Create a stored procedure named proc_insert_model_from_vehicle. If the vehicle does not exist, insert a default vehicle record. Then, insert a new active model for the vehicle and return the new MODEL_ID via an OUT parameter.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create proc_insert_model_from_vehicle. If vehicle missing, add default. Then insert active model and return new MODEL_ID."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that deletes records from the ACCESS_LOGS table where the ACCESS_DATE column is less than a specified threshold date provided as a parameter p_date_threshold of type VARCHAR2.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_access_logs (p_date_threshold VARCHAR2) AS\nBEGIN\n  DELETE FROM ACCESS_LOGS\n  WHERE ACCESS_DATE < p_date_threshold;\nEND;",
    "database_name": "global_hawbi_549073",
    "tables": [
      "RESEARCH_TEAMS",
      "TEAM_ACCESS",
      "TEAM_MEMBERS",
      "USERS",
      "ACCESS_LOGS"
    ],
    "call_sqls": [
      "BEGIN\n  delete_old_access_logs('2023-01-01');\n  COMMIT;\nEND;",
      "BEGIN\n  delete_old_access_logs('2023-06-01');\n  COMMIT;\nEND;",
      "BEGIN\n  delete_old_access_logs('2022-12-31');\n  COMMIT;\nEND;",
      "BEGIN\n  delete_old_access_logs('2023-03-15');\n  COMMIT;\nEND;",
      "BEGIN\n  delete_old_access_logs('2022-06-30');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named delete_old_access_logs that deletes all records from the ACCESS_LOGS table where the ACCESS_DATE is earlier than a provided date threshold.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called delete_old_access_logs that permanently removes all outdated records from the ACCESS_LOGS table where the ACCESS_DATE is definitively before a specified date threshold provided as an input parameter.",
    "id": 18,
    "generated_ir": "Write an Oracle PL/SQL stored procedure that deletes records from the ACCESS_LOGS table where the ACCESS_DATE column is less than a specified threshold date provided as a parameter p_date_threshold of type VARCHAR2.",
    "original_summary": "Create a stored procedure that deletes records from the ACCESS_LOGS table where the ACCESS_DATE is earlier than a provided date threshold parameter.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Develop a comprehensive stored procedure designed to systematically and permanently remove all outdated entries from the ACCESS_LOGS table, specifically targeting those records whose ACCESS_DATE value falls definitively before a specified date threshold, which will be supplied as an input parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_product_discount that accepts two parameters: p_product_id of type NUMBER, which specifies the unique identifier of a product, and p_discount_value of type VARCHAR2, which represents the discount percentage to be applied to the product's price. The procedure begins by declaring three local variables: v_product_price and v_discounted_price, both of type VARCHAR2 with a maximum length of 255 characters, to store the original and discounted prices of the product, respectively, and v_order_item_count of type NUMBER to hold the count of order items associated with the specified product. The procedure executes a SELECT statement to retrieve the PRICE column from the PRODUCTS table for the row where PRODUCT_ID matches the value of p_product_id, storing the result in v_product_price. It then calculates the discounted price by converting v_product_price to a NUMBER, applying the discount by multiplying it by the factor (1 - TO_NUMBER(p_discount_value)/100), and converting the result back to a VARCHAR2 using TO_CHAR, assigning this value to v_discounted_price. An UPDATE statement is executed on the PRODUCTS table to set the PRICE column to v_discounted_price for the row where PRODUCT_ID equals p_product_id. Subsequently, a SELECT COUNT(*) statement is executed to determine the number of rows in the ORDER_ITEMS table where PRODUCT_ID matches p_product_id, storing the count in v_order_item_count. The procedure includes an IF conditional statement that checks if v_order_item_count is greater than zero, indicating that there are order items associated with the product. If this condition is true, an UPDATE statement is executed on the ORDER_ITEMS table to set the UNIT_PRICE column to v_discounted_price for all rows where PRODUCT_ID equals p_product_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_product_discount(p_product_id IN NUMBER, p_discount_value IN VARCHAR2)\nIS\n   v_product_price VARCHAR2(255);\n   v_discounted_price VARCHAR2(255);\n   v_order_item_count NUMBER;\nBEGIN\n   SELECT PRICE INTO v_product_price FROM PRODUCTS WHERE PRODUCT_ID = p_product_id;\n   v_discounted_price := TO_CHAR(TO_NUMBER(v_product_price) * (1 - TO_NUMBER(p_discount_value)/100));\n   UPDATE PRODUCTS SET PRICE = v_discounted_price WHERE PRODUCT_ID = p_product_id;\n   SELECT COUNT(*) INTO v_order_item_count FROM ORDER_ITEMS WHERE PRODUCT_ID = p_product_id;\n   IF v_order_item_count > 0 THEN\n      UPDATE ORDER_ITEMS SET UNIT_PRICE = v_discounted_price WHERE PRODUCT_ID = p_product_id;\n   END IF;\nEND;",
    "database_name": "customer_pad_tracking",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "DISCOUNTS"
    ],
    "call_sqls": [
      "BEGIN\n  process_product_discount(0, '20.0');\n  commit;\nEND;",
      "BEGIN\n  process_product_discount(1, '10.0');\n  commit;\nEND;",
      "BEGIN\n  process_product_discount(0, '15.0');\n  commit;\nEND;",
      "BEGIN\n  process_product_discount(1, '25.0');\n  commit;\nEND;",
      "BEGIN\n  process_product_discount(0, '5.0');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named process_product_discount that, given a product ID and a discount value, retrieves the current PRICE from the PRODUCTS table for that product, calculates a new discounted price by applying the discount percentage, updates the PRICE in the PRODUCTS table with this new value, and if there are any associated records in the ORDER_ITEMS table for that product, updates their UNIT_PRICE to the new discounted price as well.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL stored procedure called process_product_discount that needs a product ID and a discount amount? First, grab the product's current PRICE from the PRODUCTS table, figure out the new price after applying the discount, and update that new price onto the product record in PRODUCTS. Then, check how many order items are linked to that product in the ORDER_ITEMS table. If you find any, go ahead and update their UNIT_PRICE to match the new discounted price.",
    "id": 19,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named process_product_discount that accepts two parameters: p_product_id of type NUMBER, which specifies the unique identifier of a product, and p_discount_value of type VARCHAR2, which represents the discount percentage to be applied to the product's price. The procedure begins by declaring three local variables: v_product_price and v_discounted_price, both of type VARCHAR2 with a maximum length of 255 characters, to store the original and discounted prices of the product, respectively, and v_order_item_count of type NUMBER to hold the count of order items associated with the specified product. The procedure executes a SELECT statement to retrieve the PRICE column from the PRODUCTS table for the row where PRODUCT_ID matches the value of p_product_id, storing the result in v_product_price. It then calculates the discounted price by converting v_product_price to a NUMBER, applying the discount by multiplying it by the factor (1 - TO_NUMBER(p_discount_value)/100), and converting the result back to a VARCHAR2 using TO_CHAR, assigning this value to v_discounted_price. An UPDATE statement is executed on the PRODUCTS table to set the PRICE column to v_discounted_price for the row where PRODUCT_ID equals p_product_id. Subsequently, a SELECT COUNT(*) statement is executed to determine the number of rows in the ORDER_ITEMS table where PRODUCT_ID matches p_product_id, storing the count in v_order_item_count. The procedure includes an IF conditional statement that checks if v_order_item_count is greater than zero, indicating that there are order items associated with the product. If this condition is true, an UPDATE statement is executed on the ORDER_ITEMS table to set the UNIT_PRICE column to v_discounted_price for all rows where PRODUCT_ID equals p_product_id.",
    "original_summary": "Create a stored procedure named process_product_discount that takes a product ID and a discount value. Retrieve the product's price, calculate the discounted price, and update the product's price. Then, count the associated order items. If there are any, update their unit price to the new discounted price.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called process_product_discount that needs a product ID and a discount amount? First, grab the product's current price, figure out the new price after the discount, and slap that new price onto the product record. Then, check how many order items are linked to that product. If you find any, go ahead and update their unit price to match the new discounted price."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_version_approval that accepts two input parameters: a numeric parameter p_version_id and a string parameter p_approved_by, and executes an UPDATE operation on the database table named VERSIONS, specifically setting the column APPROVED_BY to the value provided in the p_approved_by parameter and setting the column APPROVED_DATE to the current system date formatted as a string in the 'YYYY-MM-DD' pattern using the TO_CHAR function with the SYSDATE function as its argument, but only for the single row in the VERSIONS table where the value in the VERSION_ID column exactly matches the numeric value supplied in the p_version_id input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_version_approval(\n    p_version_id IN NUMBER,\n    p_approved_by IN VARCHAR2\n) IS\nBEGIN\n    UPDATE VERSIONS \n    SET APPROVED_BY = p_approved_by, APPROVED_DATE = TO_CHAR(SYSDATE, 'YYYY-MM-DD')\n    WHERE VERSION_ID = p_version_id;\nEND;",
    "database_name": "electronic_csa_documentat",
    "tables": [
      "COMPONENTS",
      "SPECIFICATIONS",
      "COMPONENT_SPECIFICATIONS_HISTORY",
      "VERSIONS"
    ],
    "call_sqls": [
      "BEGIN\n  update_version_approval(p_version_id => 0, p_approved_by => 'Alice Johnson');\nEND;",
      "BEGIN\n  update_version_approval(p_version_id => 1, p_approved_by => 'Bob Williams');\nEND;",
      "BEGIN\n  update_version_approval(p_version_id => 0, p_approved_by => 'Charlie Brown');\nEND;",
      "BEGIN\n  update_version_approval(p_version_id => 1, p_approved_by => 'Diana Prince');\nEND;",
      "BEGIN\n  update_version_approval(p_version_id => 0, p_approved_by => 'Eve Adams');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_version_approval that accepts a version ID and an approver name, and updates the VERSIONS table by setting the APPROVED_BY column to the provided approver name and setting the APPROVED_DATE to the current date in 'YYYY-MM-DD' format for the specified version.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_version_approval that accepts a version ID and an approver's full name, and updates the VERSIONS table by setting the APPROVED_BY column to the approver's name and the APPROVED_DATE column to the current date in 'YYYY-MM-DD' format for the specific version matching the given version ID.",
    "id": 20,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_version_approval that accepts two input parameters: p_version_id of type NUMBER (or the appropriate data type matching the VERSION_ID column in the VERSIONS table) and p_approver_full_name of type VARCHAR2 (or the appropriate data type matching the APPROVED_BY column in the VERSIONS table). The procedure does not declare any local variables. It executes an UPDATE operation on the VERSIONS table, setting the APPROVED_BY column to the value of the input parameter p_approver_full_name and the APPROVED_DATE column to the current date formatted as 'YYYY-MM-DD' (using the TO_CHAR function with SYSDATE) for the specific row where the VERSION_ID column matches the input parameter p_version_id. The procedure does not include explicit control flow statements such as IF conditions or loops, and it does not return a value. It operates within the electronic_csa_documentat database.",
    "original_summary": "Create a stored procedure named update_version_approval that accepts a version ID and an approver name. Update the VERSIONS table to set the APPROVED_BY column and set the APPROVED_DATE to the current date in 'YYYY-MM-DD' format for the specified version.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create a comprehensive stored procedure, which we shall name update_version_approval, designed to accept two distinct input parameters: a specific version ID and the full name of the approver. This procedure will meticulously update the VERSIONS table by setting the APPROVED_BY column to the provided approver's name and, simultaneously, setting the APPROVED_DATE column to the precise current date, formatted explicitly as 'YYYY-MM-DD', but only for the particular version entry that matches the supplied version ID."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_reconcile_payments_reserves that accepts three parameters: para_threshold of type NUMBER, para_reason_prefix of type VARCHAR2, and para_override_date of type VARCHAR2. The procedure iterates over claims from the CLAIMS table, joining with the PAYMENTS and RESERVES tables to calculate the total payments and total reserves for each claim. It selects claims where the absolute difference between total payments and total reserves exceeds the para_threshold. For each selected claim, it calculates the difference (v_diff) between total payments and total reserves. If v_diff is positive, indicating excess payments, it inserts a new record into the RESERVES table with a new RESERVE_ID, calculated as the maximum existing RESERVE_ID plus one, and assigns the CLAIM_ID from the current record. It sets RE_IBNR_AMT to 40% of total payments and RE_OS_AMT to 60% of total payments, with other columns set to specific values, including CALCULATION_DATE set to para_override_date or the current system date, and ADJUSTMENT_REASON constructed using para_reason_prefix and the payment excess amount. If v_diff is not positive, it deletes records from the PAYMENTS table for the current CLAIM_ID, removing a number of payment records determined by the ceiling of the absolute v_diff divided by 1000. The procedure maintains a counter (v_counter) to track the number of processed claims and exits the loop after processing 10 claims.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_reconcile_payments_reserves(para_threshold NUMBER, para_reason_prefix VARCHAR2, para_override_date VARCHAR2) IS\n  v_diff NUMBER;\n  v_counter NUMBER := 0;\n  v_next_reserve_id NUMBER;\nBEGIN\n  FOR rec IN (\n    SELECT c.CLAIM_ID,\n           NVL(SUM(p.PAYMENT_AMOUNT), 0) as total_payments,\n           NVL(SUM(r.RE_IBNR_AMT + r.RE_OS_AMT), 0) as total_reserves\n    FROM CLAIMS c\n    LEFT JOIN PAYMENTS p ON c.CLAIM_ID = p.CLAIM_ID\n    LEFT JOIN RESERVES r ON c.CLAIM_ID = r.CLAIM_ID\n    GROUP BY c.CLAIM_ID\n    HAVING ABS(NVL(SUM(p.PAYMENT_AMOUNT), 0) - NVL(SUM(r.RE_IBNR_AMT + r.RE_OS_AMT), 0)) > para_threshold\n  ) LOOP\n    v_diff := rec.total_payments - rec.total_reserves;\n    \n    IF v_diff > 0 THEN\n      SELECT NVL(MAX(RESERVE_ID), 0) + 1 INTO v_next_reserve_id FROM RESERVES;\n      \n      INSERT INTO RESERVES (RESERVE_ID, CLAIM_ID, RE_IBNR_AMT, RE_OS_AMT, RE_LOSS_SVYEXP, RE_RSV_LSS, RE_TVOG_AMT, RE_CEBF_AMT, RE_CE_LSS, CALCULATION_DATE, ACTUARY_ID, ADJUSTMENT_REASON)\n      VALUES (v_next_reserve_id, rec.CLAIM_ID, rec.total_payments * 0.4, rec.total_payments * 0.6, 0, 0.1, 0, 7, 0.1, \n              NVL(para_override_date, TO_CHAR(SYSDATE, 'YYYY-MM-DD')), \n              MOD(rec.CLAIM_ID, 50) + 200, \n              para_reason_prefix || ' Payment excess: ' || TO_CHAR(v_diff));\n    ELSE\n      DELETE FROM PAYMENTS \n      WHERE PAYMENT_ID IN (\n        SELECT PAYMENT_ID \n        FROM PAYMENTS \n        WHERE CLAIM_ID = rec.CLAIM_ID \n        AND ROWNUM <= CEIL(ABS(v_diff) / 1000)\n      );\n    END IF;\n    \n    v_counter := v_counter + 1;\n    \n    IF v_counter >= 10 THEN\n      EXIT;\n    END IF;\n  END LOOP;\nEND;",
    "database_name": "insurance_car_management",
    "tables": [
      "CLAIMS",
      "PAYMENTS",
      "RESERVES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_reconcile_payments_reserves(para_threshold => 100, para_reason_prefix => 'Recon_A', para_override_date => NULL);\nEND;",
      "BEGIN\n  sp_reconcile_payments_reserves(para_threshold => 500, para_reason_prefix => 'Recon_B', para_override_date => '2023-03-15');\nEND;",
      "BEGIN\n  sp_reconcile_payments_reserves(para_threshold => 10, para_reason_prefix => 'Recon_C', para_override_date => TO_CHAR(SYSDATE, 'YYYY-MM-DD'));\nEND;",
      "BEGIN\n  sp_reconcile_payments_reserves(para_threshold => 2000, para_reason_prefix => 'Recon_D', para_override_date => '2024-01-01');\nEND;",
      "BEGIN\n  sp_reconcile_payments_reserves(para_threshold => 50, para_reason_prefix => 'Recon_E', para_override_date => NULL);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_reconcile_payments_reserves that processes up to 10 claims from the CLAIMS table where the absolute difference between the total PAYMENT_AMOUNT from the PAYMENTS table and the total of RE_IBNR_AMT and RE_OS_AMT from the RESERVES table exceeds a provided threshold parameter. For each claim where total payments exceed total reserves, insert a new record into the RESERVES table with calculated RE_IBNR_AMT and RE_OS_AMT amounts, using a provided reason prefix and override date for the ADJUSTMENT_REASON and CALCULATION_DATE. For each claim where total reserves exceed total payments, delete a calculated number of payment records from the PAYMENTS table for that claim.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_reconcile_payments_reserves that processes up to 10 claims where the absolute difference between total payments and total reserves exceeds a provided threshold. For each claim, if total payments exceed total reserves, insert a new record into the RESERVES table with calculated reserve amounts, using the provided reason prefix and override date. If total reserves exceed total payments, delete a calculated number of payment records from the PAYMENTS table for that claim, based on the difference amount.",
    "id": 21,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_reconcile_payments_reserves that processes a maximum of 10 claims from the insurance_car_management database. The procedure takes three input parameters: a NUMBER parameter p_threshold representing the minimum absolute difference between total payments and total reserves, a VARCHAR2 parameter p_reason_prefix representing a text prefix for the reserve reason, and a DATE parameter p_override_date representing a date to use for the reserve entry. The procedure first declares local variables: a cursor c_claims that selects distinct claim IDs from the CLAIMS table, joining the PAYMENTS table and the RESERVES table on claim ID, grouping by claim ID, and having the absolute value of the difference between the sum of the payment_amount column from PAYMENTS and the sum of the reserve_amount column from RESERVES exceed p_threshold, ordered by claim ID and limited to 10 rows using ROWNUM; a variable v_claim_id to store each claim ID; a variable v_total_payments to store the sum of payment amounts for the claim; a variable v_total_reserves to store the sum of reserve amounts for the claim; a variable v_difference to store the calculated difference; and a variable v_payments_to_delete to store the number of payment records to delete. The procedure opens the cursor and loops through each claim ID. For each claim, it queries the PAYMENTS table to calculate the sum of payment_amount into v_total_payments and the RESERVES table to calculate the sum of reserve_amount into v_total_reserves for that claim ID. It then computes v_difference as v_total_payments minus v_total_reserves. If v_difference is greater than 0, indicating total payments exceed total reserves, it inserts a new record into the RESERVES table with a reserve_id generated by incrementing the maximum existing reserve_id by 1, the claim_id set to the current claim ID, the reserve_amount set to v_difference, the reserve_reason set to p_reason_prefix concatenated with ' Overpayment Adjustment', and the reserve_date set to p_override_date. If v_difference is less than 0, indicating total reserves exceed total payments, it calculates v_payments_to_delete as the absolute value of v_difference divided by 100, rounding up to the nearest integer, representing the number of payment records to delete. It then deletes exactly v_payments_to_delete rows from the PAYMENTS table for the current claim ID, ordered by payment_date ascending to remove the oldest payments first, using a subquery with ROWNUM. The procedure continues until all processed claims are handled or up to 10 claims, then closes the cursor and ends.",
    "original_summary": "Create a stored procedure named sp_reconcile_payments_reserves that processes up to 10 claims where the difference between total payments and reserves exceeds a threshold. For claims with excess payments, it adds a new reserve record. For others, it deletes a calculated number of payment records. It uses provided parameters for the threshold, reason prefix, and override date.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Write a stored procedure called sp_reconcile_payments_reserves to process up to 10 claims where the total payments minus the reserves is greater than a threshold. For claims with excess payments, insert a new reserve record. For the remaining claims, delete a calculated number of payment records. Use the provided parameters for the threshold, reason prefix, and override date."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `analyze_customer_behavior` that accepts two input parameters: `p_customer_id` of type `NUMBER`, representing the unique identifier for a customer, and `p_threshold` of type `NUMBER`, representing a numerical threshold for comparison. The procedure declares several local variables: `v_review_count` of type `NUMBER` to store the count of customer reviews, `v_return_count` of type `NUMBER` to store the count of customer returns, `v_recommendation_count` of type `NUMBER` to store the count of existing recommendations for the customer, `v_customer_name` of type `VARCHAR2(510)` to store the customer's full name, and `v_next_recommendation_id` of type `NUMBER` to store the next available recommendation identifier.\n\nThe procedure begins by initializing `v_review_count`, `v_return_count`, and `v_recommendation_count` to `0`.\n\nNext, it retrieves the total number of reviews associated with the `p_customer_id` from the `customer_reviews` table by executing a `SELECT COUNT(*)` statement and stores this value into `v_review_count`.\n\nSubsequently, it retrieves the total number of returns associated with the `p_customer_id` from the `returns` table by executing a `SELECT COUNT(*)` statement and stores this value into `v_return_count`.\n\nFollowing this, it retrieves the total number of recommendations associated with the `p_customer_id` from the `recommendations` table by executing a `SELECT COUNT(*)` statement and stores this value into `v_recommendation_count`.\n\nThen, the procedure attempts to retrieve the full name of the customer by concatenating the `first_name` and `last_name` columns from the `customers` table where the `customer_id` matches `p_customer_id`. This concatenated name is stored into `v_customer_name`. This operation is enclosed within an exception handling block. If a `NO_DATA_FOUND` exception occurs (meaning no customer with the given `p_customer_id` is found), `v_customer_name` is set to the string 'Unknown Customer', and an application error with error code -20001 and a message indicating that the customer ID was not found is raised.\n\nAfter retrieving the customer's information, the procedure proceeds with conditional logic.\n\nIf `v_review_count` is greater than `p_threshold` AND `v_return_count` is equal to `0`, the procedure performs the following actions:\n1. It determines the next available `recommendation_id` by selecting the maximum `recommendation_id` from the `recommendations` table, using `NVL` to treat a `NULL` result as `0`, and adding `1` to it. This value is stored in `v_next_recommendation_id`.\n2. It inserts a new record into the `recommendations` table. The `recommendation_id` is set to `v_next_recommendation_id`, `customer_id` is set to `p_customer_id`, `product_id` is selected from the `products` table, `recommended_size` is set to the literal string 'M', `created_at` is set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`, and `updated_at` is also set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS'. The `product_id` for the insertion is chosen from the `products` table where the `product_id` is NOT present in the existing recommendations for the `p_customer_id`, and only the first such product (due to `ROWNUM = 1`) is selected.\n\nElse if `v_return_count` is greater than `p_threshold`, the procedure performs the following action:\n1. It deletes records from the `recommendations` table where the `customer_id` matches `p_customer_id` AND the `product_id` is present in the set of `product_id`s from the `returns` table associated with `p_customer_id`.\n\nOtherwise (if neither of the above conditions is met), the procedure performs the following action:\n1. It updates the `updated_at` column in the `recommendations` table to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' for all records where the `customer_id` matches `p_customer_id`.\n\nThe procedure includes a general exception handler that catches any other exceptions (`WHEN OTHERS`). If an exception occurs, the procedure raises the caught exception.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_customer_behavior(p_customer_id IN NUMBER, p_threshold IN NUMBER)\nIS\n    v_review_count NUMBER;\n    v_return_count NUMBER;\n    v_recommendation_count NUMBER;\n    v_customer_name VARCHAR2(510);\n    v_next_recommendation_id NUMBER;\nBEGIN\n    -- Initialize counts to 0\n    v_review_count := 0;\n    v_return_count := 0;\n    v_recommendation_count := 0;\n    \n    -- Get review count\n    SELECT COUNT(*)\n    INTO v_review_count\n    FROM customer_reviews\n    WHERE customer_id = p_customer_id;\n    \n    -- Get return count\n    SELECT COUNT(*)\n    INTO v_return_count\n    FROM returns\n    WHERE customer_id = p_customer_id;\n    \n    -- Get recommendation count\n    SELECT COUNT(*)\n    INTO v_recommendation_count\n    FROM recommendations\n    WHERE customer_id = p_customer_id;\n    \n    -- Get customer name with exception handling\n    BEGIN\n        SELECT first_name || ' ' || last_name\n        INTO v_customer_name\n        FROM customers\n        WHERE customer_id = p_customer_id;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_customer_name := 'Unknown Customer';\n            RAISE_APPLICATION_ERROR(-20001, 'Customer ID ' || p_customer_id || ' not found');\n    END;\n    \n    IF v_review_count > p_threshold AND v_return_count = 0 THEN\n        -- Generate next recommendation ID\n        SELECT NVL(MAX(recommendation_id), 0) + 1\n        INTO v_next_recommendation_id\n        FROM recommendations;\n        \n        INSERT INTO recommendations (recommendation_id, customer_id, product_id, recommended_size, created_at, updated_at)\n        SELECT v_next_recommendation_id, p_customer_id, p.product_id, 'M', \n               TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), \n               TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n        FROM products p\n        WHERE p.product_id NOT IN (SELECT product_id FROM recommendations WHERE customer_id = p_customer_id)\n        AND ROWNUM = 1;\n    ELSIF v_return_count > p_threshold THEN\n        DELETE FROM recommendations\n        WHERE customer_id = p_customer_id\n        AND product_id IN (SELECT product_id FROM returns WHERE customer_id = p_customer_id);\n    ELSE\n        UPDATE recommendations\n        SET updated_at = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n        WHERE customer_id = p_customer_id;\n    END IF;\n    \n    -- Commit the transaction\n    COMMIT;\nEXCEPTION\n    WHEN OTHERS THEN\n        ROLLBACK;\n        RAISE;\nEND;",
    "database_name": "apparel_sma_conversion",
    "tables": [
      "CUSTOMERS",
      "PRODUCTS",
      "CUSTOMER_REVIEWS",
      "RECOMMENDATIONS",
      "RETURNS",
      "PRODUCT_SIZES"
    ],
    "call_sqls": [
      "BEGIN\n  analyze_customer_behavior(0, 1);\n  COMMIT;\nEND;",
      "BEGIN\n  analyze_customer_behavior(1, 2);\n  COMMIT;\nEND;",
      "BEGIN\n  analyze_customer_behavior(0, 0);\n  COMMIT;\nEND;",
      "BEGIN\n  analyze_customer_behavior(1, 0);\n  COMMIT;\nEND;",
      "BEGIN\n  analyze_customer_behavior(0, 5);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named analyze_customer_behavior that accepts a customer ID and a threshold number. It retrieves the customer's name from the CUSTOMERS table; if the customer is not found, it sets the name to 'Unknown Customer' and raises an error. The procedure counts the customer's reviews from the CUSTOMER_REVIEWS table, returns from the RETURNS table, and existing recommendations from the RECOMMENDATIONS table. If the review count exceeds the threshold and the return count is zero, it inserts a new recommendation into the RECOMMENDATIONS table for a product from the PRODUCTS table not yet recommended to the customer, using a generated recommendation ID, a default size of 'M', and the current timestamp. If the return count exceeds the threshold, it deletes recommendations for products the customer has returned. Otherwise, it updates the timestamp on all existing recommendations for the customer.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called analyze_customer_behavior that takes a customer identifier and a numerical threshold as inputs. It must retrieve the total number of reviews from the CUSTOMER_REVIEWS table and returns from the RETURNS table for that customer, along with the count of their existing recommendations from the RECOMMENDATIONS table. If the customer identifier does not exist in the CUSTOMERS table, set the customer name to 'Unknown Customer' and raise an error. If the review count exceeds the threshold and the return count is exactly zero, insert a new recommendation for a product from the PRODUCTS table that the customer has not been recommended before. If the return count exceeds the threshold, delete all recommendations for products that the customer has returned. In all other cases, update the timestamp for every existing recommendation for the customer. Include comprehensive exception handling.",
    "id": 22,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `analyze_customer_behavior` that accepts two input parameters: `p_customer_id` of type `NUMBER`, representing the unique identifier for a customer, and `p_threshold` of type `NUMBER`, representing a numerical threshold for comparison. The procedure declares several local variables: `v_review_count` of type `NUMBER` to store the count of customer reviews, `v_return_count` of type `NUMBER` to store the count of customer returns, `v_recommendation_count` of type `NUMBER` to store the count of existing recommendations for the customer, `v_customer_name` of type `VARCHAR2(510)` to store the customer's full name, and `v_next_recommendation_id` of type `NUMBER` to store the next available recommendation identifier.\n\nThe procedure begins by initializing `v_review_count`, `v_return_count`, and `v_recommendation_count` to `0`.\n\nNext, it retrieves the total number of reviews associated with the `p_customer_id` from the `customer_reviews` table by executing a `SELECT COUNT(*)` statement and stores this value into `v_review_count`.\n\nSubsequently, it retrieves the total number of returns associated with the `p_customer_id` from the `returns` table by executing a `SELECT COUNT(*)` statement and stores this value into `v_return_count`.\n\nFollowing this, it retrieves the total number of recommendations associated with the `p_customer_id` from the `recommendations` table by executing a `SELECT COUNT(*)` statement and stores this value into `v_recommendation_count`.\n\nThen, the procedure attempts to retrieve the full name of the customer by concatenating the `first_name` and `last_name` columns from the `customers` table where the `customer_id` matches `p_customer_id`. This concatenated name is stored into `v_customer_name`. This operation is enclosed within an exception handling block. If a `NO_DATA_FOUND` exception occurs (meaning no customer with the given `p_customer_id` is found), `v_customer_name` is set to the string 'Unknown Customer', and an application error with error code -20001 and a message indicating that the customer ID was not found is raised.\n\nAfter retrieving the customer's information, the procedure proceeds with conditional logic.\n\nIf `v_review_count` is greater than `p_threshold` AND `v_return_count` is equal to `0`, the procedure performs the following actions:\n1. It determines the next available `recommendation_id` by selecting the maximum `recommendation_id` from the `recommendations` table, using `NVL` to treat a `NULL` result as `0`, and adding `1` to it. This value is stored in `v_next_recommendation_id`.\n2. It inserts a new record into the `recommendations` table. The `recommendation_id` is set to `v_next_recommendation_id`, `customer_id` is set to `p_customer_id`, `product_id` is selected from the `products` table, `recommended_size` is set to the literal string 'M', `created_at` is set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`, and `updated_at` is also set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS'. The `product_id` for the insertion is chosen from the `products` table where the `product_id` is NOT present in the existing recommendations for the `p_customer_id`, and only the first such product (due to `ROWNUM = 1`) is selected.\n\nElse if `v_return_count` is greater than `p_threshold`, the procedure performs the following action:\n1. It deletes records from the `recommendations` table where the `customer_id` matches `p_customer_id` AND the `product_id` is present in the set of `product_id`s from the `returns` table associated with `p_customer_id`.\n\nOtherwise (if neither of the above conditions is met), the procedure performs the following action:\n1. It updates the `updated_at` column in the `recommendations` table to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' for all records where the `customer_id` matches `p_customer_id`.\n\nThe procedure includes a general exception handler that catches any other exceptions (`WHEN OTHERS`). If an exception occurs, the procedure raises the caught exception.",
    "original_summary": "Create a stored procedure named analyze_customer_behavior that accepts a customer ID and a threshold number. It counts the customer's reviews, returns, and existing recommendations. If the customer is not found, set the name to 'Unknown Customer' and raise an error. If review count exceeds the threshold and return count is zero, insert a new recommendation for a product not yet recommended to the customer. If return count exceeds the threshold, delete recommendations for products the customer has returned. Otherwise, update the timestamp on all existing recommendations for the customer. Handle any exceptions.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Construct a stored procedure designated as 'analyze_customer_behavior' that receives a customer identifier and a numerical threshold as parameters. The procedure shall compute the total number of reviews and returns associated with the specified customer, in addition to enumerating their existing recommendations. Should the customer identifier not correspond to any record, the customer name must be assigned the value 'Unknown Customer' and an error condition must be raised. In the event that the review count surpasses the provided threshold and the return count is precisely zero, a new recommendation shall be inserted for a product that the customer has not previously been recommended. Conversely, if the return count exceeds the stipulated threshold, all recommendations pertaining to products that the customer has returned must be deleted. In all other scenarios, the timestamp for every existing recommendation linked to the customer is to be updated. The implementation must include comprehensive exception handling."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_pollutant_measurement that accepts four parameters: p_measurement_id of type NUMBER, p_new_value of type NUMBER, p_quality_flag of type VARCHAR2, and p_measurement_date of type VARCHAR2. This procedure performs an update operation on the pollutant_measurements table. Specifically, it sets the value column to the value provided in the p_new_value parameter, the quality_flag column to the value provided in the p_quality_flag parameter, and the measurement_date column to the value provided in the p_measurement_date parameter. The update operation is applied to the row where the measurement_id column matches the value provided in the p_measurement_id parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_pollutant_measurement(\n    p_measurement_id NUMBER,\n    p_new_value NUMBER,\n    p_quality_flag VARCHAR2,\n    p_measurement_date VARCHAR2\n) IS\nBEGIN\n    UPDATE pollutant_measurements \n    SET value = p_new_value,\n        quality_flag = p_quality_flag,\n        measurement_date = p_measurement_date\n    WHERE measurement_id = p_measurement_id;\nEND;",
    "database_name": "air_qmaei_assessment",
    "tables": [
      "ALERTS",
      "COUNTIES",
      "POLLUTANTS",
      "POLLUTANT_MEASUREMENTS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  update_pollutant_measurement(1, 0.008, 'valid', '2023-01-15');\n  COMMIT;\nEND;",
      "BEGIN\n  update_pollutant_measurement(5, 2.5, 'suspect', '2023-02-10');\n  COMMIT;\nEND;",
      "BEGIN\n  update_pollutant_measurement(10, 0.0, 'valid', '2023-03-22');\n  COMMIT;\nEND;",
      "BEGIN\n  update_pollutant_measurement(15, 1.75, 'valid', '2023-04-05');\n  COMMIT;\nEND;",
      "BEGIN\n  update_pollutant_measurement(20, 3.2, 'suspect', '2023-05-18');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_pollutant_measurement that updates a specific record in the POLLUTANT_MEASUREMENTS table. It takes a measurement_id to identify the record, and updates its VALUE, QUALITY_FLAG, and MEASUREMENT_DATE columns with the provided new_value, quality_flag, and measurement_date parameters.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_pollutant_measurement that accepts a measurement_id, a new_value number, a quality_flag string, and a measurement_date string to update the pollutant_measurements table by setting the value, quality_flag, and measurement_date columns to the provided parameters for the specific measurement_id.",
    "id": 23,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_pollutant_measurement that accepts four parameters: p_measurement_id of type NUMBER, p_new_value of type NUMBER, p_quality_flag of type VARCHAR2, and p_measurement_date of type VARCHAR2. This procedure performs an update operation on the pollutant_measurements table. Specifically, it sets the value column to the value provided in the p_new_value parameter, the quality_flag column to the value provided in the p_quality_flag parameter, and the measurement_date column to the value provided in the p_measurement_date parameter. The update operation is applied to the row where the measurement_id column matches the value provided in the p_measurement_id parameter.",
    "original_summary": "Create a PL/SQL procedure named update_pollutant_measurement that takes a measurement_id, a new_value number, a quality_flag string, and a measurement_date string. It updates the pollutant_measurements table, setting the value, quality_flag, and measurement_date columns to the provided parameters for the row matching the given measurement_id.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Write a PL/SQL procedure called update_pollutant_measurement that accepts a measurement_id, a new_value number, a quality_flag string, and a measurement_date string. Use it to update the pollutant_measurements table by setting the value, quality_flag, and measurement_date columns to the given parameters for the row with the specified measurement_id."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named AnalyzeOrderDistribution that accepts two input parameters: a numeric parameter p_customer_id and a string parameter p_status. The procedure declares three local variables: v_order_id of type NUMBER, v_total_amount of type VARCHAR2(255), and v_cume_dist_val of type NUMBER. It defines a cursor named c_orders that selects the ORDER_ID column, the TOTAL_AMOUNT column, and a computed cumulative distribution value from the ORDERS table, aliased as 'o'. The cumulative distribution is calculated using the CUME_DIST() analytic function over a window ordered by the TOTAL_AMOUNT column converted to a numeric type using the TO_NUMBER function. The cursor's result set is filtered to include only rows where the CUSTOMER_ID column equals the input parameter p_customer_id and the STATUS column equals the input parameter p_status. The procedure begins execution by opening the cursor, then enters a loop where it fetches each row from the cursor into the local variables v_order_id, v_total_amount, and v_cume_dist_val. The loop terminates when no more rows are found, as indicated by the cursor attribute %NOTFOUND. For each fetched row, the procedure evaluates the value of v_cume_dist_val: if it is less than 0.25, it executes a DELETE operation on the ORDER_ITEMS table, removing all rows where the ORDER_ID column matches the fetched v_order_id; if the value is less than 0.75 (and greater than or equal to 0.25), it executes a DELETE operation on the ORDER_ITEMS table, removing rows where both the ORDER_ID column matches v_order_id and the ITEM_ID column equals 0; otherwise (for values greater than or equal to 0.75), it executes a DELETE operation on the ORDER_ITEMS table, removing rows where both the ORDER_ID column matches v_order_id and the ITEM_ID column equals 1. After the loop completes, the procedure closes the cursor.",
    "plsql": "CREATE OR REPLACE PROCEDURE AnalyzeOrderDistribution(p_customer_id NUMBER, p_status VARCHAR2) AS\n  v_order_id NUMBER;\n  v_total_amount VARCHAR2(255);\n  v_cume_dist_val NUMBER;\n  CURSOR c_orders IS\n    SELECT o.ORDER_ID, o.TOTAL_AMOUNT, CUME_DIST() OVER (ORDER BY TO_NUMBER(o.TOTAL_AMOUNT)) as cd\n    FROM ORDERS o\n    WHERE o.CUSTOMER_ID = p_customer_id AND o.STATUS = p_status;\nBEGIN\n  OPEN c_orders;\n  LOOP\n    FETCH c_orders INTO v_order_id, v_total_amount, v_cume_dist_val;\n    EXIT WHEN c_orders%NOTFOUND;\n    IF v_cume_dist_val < 0.25 THEN\n      DELETE FROM ORDER_ITEMS WHERE ORDER_ID = v_order_id;\n    ELSIF v_cume_dist_val < 0.75 THEN\n      DELETE FROM ORDER_ITEMS WHERE ORDER_ID = v_order_id AND ITEM_ID = 0;\n    ELSE\n      DELETE FROM ORDER_ITEMS WHERE ORDER_ID = v_order_id AND ITEM_ID = 1;\n    END IF;\n  END LOOP;\n  CLOSE c_orders;\nEND;",
    "database_name": "clothing_ssaim_736487",
    "tables": [
      "INVENTORY",
      "ORDER_ITEMS",
      "ORDERS",
      "SIZES"
    ],
    "call_sqls": [
      "BEGIN\n  AnalyzeOrderDistribution(p_customer_id => 0, p_status => 'Shipped');\nEND;",
      "BEGIN\n  AnalyzeOrderDistribution(p_customer_id => 1, p_status => 'Pending');\nEND;",
      "BEGIN\n  AnalyzeOrderDistribution(p_customer_id => 0, p_status => 'Pending');\nEND;",
      "BEGIN\n  AnalyzeOrderDistribution(p_customer_id => 1, p_status => 'Shipped');\nEND;",
      "BEGIN\n  AnalyzeOrderDistribution(p_customer_id => 0, p_status => 'Delivered');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named AnalyzeOrderDistribution that accepts a customer ID and an order status. For each order in the ORDERS table matching the given customer ID and status, calculate the cumulative distribution of its TOTAL_AMOUNT. Based on this distribution value, delete items from the ORDER_ITEMS table for that order: if the value is less than 0.25, delete all items for the order; if the value is less than 0.75, delete only items where ITEM_ID equals 0; otherwise, delete only items where ITEM_ID equals 1.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL stored procedure called AnalyzeOrderDistribution? It should take a customer's ID and an order status. For every order from the ORDERS table that matches that customer ID and status, calculate the cumulative distribution of its TOTAL_AMOUNT. Then, based on that distribution value, remove certain items from the ORDER_ITEMS table for that order: if the value is under 0.25, delete all items for that order; if under 0.75, delete items where ITEM_ID equals 0; otherwise, delete items where ITEM_ID is 1.",
    "id": 24,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named AnalyzeOrderDistribution that accepts two input parameters: a numeric parameter p_customer_id and a string parameter p_status. The procedure declares three local variables: v_order_id of type NUMBER, v_total_amount of type VARCHAR2(255), and v_cume_dist_val of type NUMBER. It defines a cursor named c_orders that selects the ORDER_ID column, the TOTAL_AMOUNT column, and a computed cumulative distribution value from the ORDERS table, aliased as 'o'. The cumulative distribution is calculated using the CUME_DIST() analytic function over a window ordered by the TOTAL_AMOUNT column converted to a numeric type using the TO_NUMBER function. The cursor's result set is filtered to include only rows where the CUSTOMER_ID column equals the input parameter p_customer_id and the STATUS column equals the input parameter p_status. The procedure begins execution by opening the cursor, then enters a loop where it fetches each row from the cursor into the local variables v_order_id, v_total_amount, and v_cume_dist_val. The loop terminates when no more rows are found, as indicated by the cursor attribute %NOTFOUND. For each fetched row, the procedure evaluates the value of v_cume_dist_val: if it is less than 0.25, it executes a DELETE operation on the ORDER_ITEMS table, removing all rows where the ORDER_ID column matches the fetched v_order_id; if the value is less than 0.75 (and greater than or equal to 0.25), it executes a DELETE operation on the ORDER_ITEMS table, removing rows where both the ORDER_ID column matches v_order_id and the ITEM_ID column equals 0; otherwise (for values greater than or equal to 0.75), it executes a DELETE operation on the ORDER_ITEMS table, removing rows where both the ORDER_ID column matches v_order_id and the ITEM_ID column equals 1. After the loop completes, the procedure closes the cursor.",
    "original_summary": "Create a stored procedure named AnalyzeOrderDistribution that accepts a customer ID and an order status. For each matching order, calculate the cumulative distribution of its total amount. Based on this distribution value, delete specific items from the ORDER_ITEMS table for that order (e.g., delete all items if value < 0.25, delete items with ITEM_ID=0 if value < 0.75, else delete items with ITEM_ID=1).",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called AnalyzeOrderDistribution? It should take a customer's ID and an order status. For every order that fits the bill, figure out the cumulative spread of its total cost. Then, depending on that spread number, go ahead and remove certain items from the ORDER_ITEMS table for that order. Like, if the value's under 0.25, ditch all the items. If it's under 0.75, get rid of any items where ITEM_ID equals 0. Otherwise, just delete the ones where ITEM_ID is 1."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ManageUnit` that accepts four input parameters: `p_unit_id` of type `VARCHAR2`, intended to uniquely identify a unit; `p_unit_name` of type `VARCHAR2`, representing the name of the unit; `p_description` of type `VARCHAR2`, providing a textual description of the unit; and `p_unit_type` of type `VARCHAR2`, indicating the category or type of the unit. The procedure declares a local variable `v_exists` of type `NUMBER` to store the count of existing records. The procedure begins by executing a `SELECT` statement to count the number of rows in the `UNITS` table where the `UNIT_ID` column matches the value provided in the `p_unit_id` input parameter. The result of this count is then stored into the `v_exists` local variable. Following this, a conditional `IF-ELSIF-ELSE` block is executed based on the value of `v_exists`. If `v_exists` is equal to `0`, indicating that no unit with the specified `p_unit_id` currently exists in the `UNITS` table, an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `UNITS` table, populating the `UNIT_ID` column with the value from `p_unit_id`, the `UNIT_NAME` column with the value from `p_unit_name`, the `DESCRIPTION` column with the value from `p_description`, and the `UNIT_TYPE` column with the value from `p_unit_type`. If `v_exists` is equal to `1`, indicating that exactly one unit with the specified `p_unit_id` already exists in the `UNITS` table, an `UPDATE` statement is executed. This `UPDATE` statement modifies the existing row in the `UNITS` table where the `UNIT_ID` column matches `p_unit_id`. Specifically, it sets the `UNIT_NAME` column to the value from `p_unit_name`, the `DESCRIPTION` column to the value from `p_description`, and the `UNIT_TYPE` column to the value from `p_unit_type`. If `v_exists` is neither `0` nor `1` (implying `v_exists` is greater than `1`, which would indicate a data integrity issue with multiple units having the same ID), a `DELETE` statement is executed. This `DELETE` statement removes all rows from the `UNITS` table where the `UNIT_ID` column matches the value from `p_unit_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageUnit(\n    p_unit_id VARCHAR2,\n    p_unit_name VARCHAR2,\n    p_description VARCHAR2,\n    p_unit_type VARCHAR2\n) AS\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_exists\n    FROM UNITS\n    WHERE UNIT_ID = p_unit_id;\n\n    IF v_exists = 0 THEN\n        INSERT INTO UNITS (UNIT_ID, UNIT_NAME, DESCRIPTION, UNIT_TYPE)\n        VALUES (p_unit_id, p_unit_name, p_description, p_unit_type);\n    ELSIF v_exists = 1 THEN\n        UPDATE UNITS\n        SET UNIT_NAME = p_unit_name, DESCRIPTION = p_description, UNIT_TYPE = p_unit_type\n        WHERE UNIT_ID = p_unit_id;\n    ELSE\n        DELETE FROM UNITS\n        WHERE UNIT_ID = p_unit_id;\n    END IF;\nEND;",
    "database_name": "demographic_ahs_652164",
    "tables": [
      "DATASETS",
      "DATASET_VERSIONS",
      "INDICATORS",
      "POSITIONS",
      "SEX",
      "UNITS"
    ],
    "call_sqls": [
      "BEGIN\n  ManageUnit('U001', 'Unit A', 'Description A', 'Type A');\n  commit;\nEND;",
      "BEGIN\n  ManageUnit('U002', 'Unit B', 'Description B', 'Type B');\n  commit;\nEND;",
      "BEGIN\n  ManageUnit('U003', 'Unit C', 'Description C', 'Type C');\n  commit;\nEND;",
      "BEGIN\n  ManageUnit('U004', 'Unit D', 'Description D', 'Type D');\n  commit;\nEND;",
      "BEGIN\n  ManageUnit('U005', 'Unit E', 'Description E', 'Type E');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named ManageUnit that, for a given UNIT_ID, UNIT_NAME, DESCRIPTION, and UNIT_TYPE, either inserts a new record into the UNITS table if the UNIT_ID does not exist, updates the existing record if exactly one record with that UNIT_ID is found, or deletes all records with that UNIT_ID if duplicate records exist.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called ManageUnit that, based on a given UNIT_ID, either inserts a new record into the UNITS table with the provided UNIT_ID, UNIT_NAME, DESCRIPTION, and UNIT_TYPE if the UNIT_ID does not exist; updates the existing record's UNIT_NAME, DESCRIPTION, and UNIT_TYPE if exactly one record with that UNIT_ID is found; or deletes all records with that UNIT_ID if multiple records are found.",
    "id": 25,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named ManageUnit that accepts four input parameters: p_unit_id of type NUMBER, p_unit_name of type VARCHAR2, p_description of type VARCHAR2, and p_unit_type of type VARCHAR2. This procedure declares a local variable v_count of type NUMBER to store the count of existing records. The procedure first performs a SELECT operation on the UNITS table to count the number of rows where the UNIT_ID column matches the input parameter p_unit_id, storing the result into v_count. Then, using conditional logic, it branches based on the value of v_count. If v_count equals 0, it performs an INSERT operation into the UNITS table, inserting a new row with the UNIT_ID column set to p_unit_id, the UNIT_NAME column set to p_unit_name, the DESCRIPTION column set to p_description, and the UNIT_TYPE column set to p_unit_type. If v_count equals 1, it performs an UPDATE operation on the UNITS table, setting the UNIT_NAME column to p_unit_name, the DESCRIPTION column to p_description, and the UNIT_TYPE column to p_unit_type for the single row where the UNIT_ID column matches p_unit_id. If v_count is greater than 1, it performs a DELETE operation on the UNITS table, removing all rows where the UNIT_ID column matches p_unit_id. The procedure does not return a value.",
    "original_summary": "Create a stored procedure named ManageUnit that inserts, updates, or deletes a record in the UNITS table based on the existence of the provided UNIT_ID. If the ID does not exist, insert a new record with the provided ID, name, description, and type. If exactly one record exists, update that record with the new name, description, and type. If more than one record exists (indicating a duplicate), delete all records with that ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as 'ManageUnit' to perform conditional operations on the UNITS table, governed by the existence of a specified UNIT_ID. The procedure's logic is as follows: if the provided UNIT_ID is not present within the table, a new record should be inserted utilizing the supplied ID, name, description, and type. Should precisely one record correspond to the given UNIT_ID, that existing record is to be updated with the new name, description, and type values. In the event that multiple records are found associated with the UNIT_ID, indicating a duplicate condition, all records possessing that ID must be deleted."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts four input parameters: `p_start_date` of type `VARCHAR2`, `p_end_date` of type `VARCHAR2`, `p_user_id` of type `NUMBER`, and `p_accuracy_threshold` of type `NUMBER`. The procedure first declares two local variables, `v_dataset_id` and `v_model_id`, both of type `NUMBER`, though `v_dataset_id` is not used in the current implementation. The procedure then initiates a `FOR` loop that iterates through a result set. This result set is generated by selecting distinct `DATASET_ID` values from the `DATASETS` table, aliased as `d`, joined with the `MODEL_EVALUATIONS` table, aliased as `me`, on the condition that `d.DATASET_ID` equals `me.DATASET_ID`. The selection is further filtered by a `WHERE` clause, ensuring that the `CREATED_DATE` column in the `DATASETS` table falls inclusively between the `p_start_date` and `p_end_date` parameters.\n\nInside this loop, for each distinct `DATASET_ID` retrieved (referred to as `rec.DATASET_ID`), the procedure executes a `SELECT` statement to retrieve a single `MODEL_ID` into the `v_model_id` variable. This `MODEL_ID` is selected from the `MODEL_EVALUATIONS` table where the `DATASET_ID` matches the current `rec.DATASET_ID` from the loop, and the `EMPIRICAL_ACCURACY` is equal to the maximum `EMPIRICAL_ACCURACY` found for that specific `DATASET_ID` within the `MODEL_EVALUATIONS` table. In cases where multiple models share the maximum `EMPIRICAL_ACCURACY` for a given `DATASET_ID`, `ROWNUM = 1` ensures that only one `MODEL_ID` is selected.\n\nFollowing this `SELECT` statement, an `INSERT` statement is executed into the `MODELS` table. The values inserted are:\n- `MODEL_ID`: `v_model_id + 10000`\n- `MODEL_NAME`: A concatenated string `'Derived_Model_'` followed by the current `rec.DATASET_ID`\n- `MODEL_TYPE`: The literal string `'DERIVED'`\n- `CREATED_DATE`: The current timestamp formatted as 'YYYY-MM-DD' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD')`\n- `MODEL_DESCRIPTION`: A concatenated string `'Derived from dataset '` followed by the current `rec.DATASET_ID`\n- `MODEL_VERSION`: The literal string `'1.0'`\n- `CREATED_BY`: The value of the `p_user_id` parameter\n- `LAST_MODIFIED_DATE`: The current timestamp formatted as 'YYYY-MM-DD' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD')`\n- `LAST_MODIFIED_BY`: The value of the `p_user_id` parameter\n\nAfter the loop completes, the procedure performs two `DELETE` operations. The first `DELETE` statement targets the `EVALUATION_VERSIONS` table. It removes records where the `EVALUATION_ID` column is present in a subquery's result set. This subquery selects `EVALUATION_ID` from the `MODEL_EVALUATIONS` table where the `EVALUATION_DATE` is strictly less than the `p_start_date` parameter and the `EMPIRICAL_ACCURACY` is strictly less than the `p_accuracy_threshold` parameter.\n\nThe second `DELETE` statement then targets the `MODEL_EVALUATIONS` table itself. It removes records where the `EVALUATION_DATE` is strictly less than the `p_start_date` parameter and the `EMPIRICAL_ACCURACY` is strictly less than the `p_accuracy_threshold` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_start_date VARCHAR2, p_end_date VARCHAR2, p_user_id NUMBER, p_accuracy_threshold NUMBER) IS\n   v_dataset_id NUMBER;\n   v_model_id NUMBER;\nBEGIN\n   FOR rec IN (SELECT DISTINCT d.DATASET_ID FROM DATASETS d JOIN MODEL_EVALUATIONS me ON d.DATASET_ID = me.DATASET_ID WHERE d.CREATED_DATE BETWEEN p_start_date AND p_end_date) LOOP\n      SELECT MODEL_ID INTO v_model_id FROM MODEL_EVALUATIONS WHERE DATASET_ID = rec.DATASET_ID AND EMPIRICAL_ACCURACY = (SELECT MAX(EMPIRICAL_ACCURACY) FROM MODEL_EVALUATIONS WHERE DATASET_ID = rec.DATASET_ID) AND ROWNUM = 1;\n      INSERT INTO MODELS (MODEL_ID, MODEL_NAME, MODEL_TYPE, CREATED_DATE, MODEL_DESCRIPTION, MODEL_VERSION, CREATED_BY, LAST_MODIFIED_DATE, LAST_MODIFIED_BY)\n      VALUES (v_model_id + 10000, 'Derived_Model_' || rec.DATASET_ID, 'DERIVED', TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD'), 'Derived from dataset ' || rec.DATASET_ID, '1.0', p_user_id, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD'), p_user_id);\n   END LOOP;\n\n   -- First, delete dependent records from the child table (e.g., EVALUATION_VERSIONS)\n   -- This table is inferred from the error message FK_EVALUATION_VERSIONS_EVALUATION_ID\n   -- Assuming EVALUATION_VERSIONS has a column named EVALUATION_ID that references MODEL_EVALUATIONS.EVALUATION_ID\n   DELETE FROM EVALUATION_VERSIONS -- Placeholder for the actual child table name\n   WHERE EVALUATION_ID IN (\n     SELECT EVALUATION_ID\n     FROM MODEL_EVALUATIONS\n     WHERE EVALUATION_DATE < p_start_date\n       AND EMPIRICAL_ACCURACY < p_accuracy_threshold\n   );\n\n   -- Then, delete from MODEL_EVALUATIONS\n   DELETE FROM MODEL_EVALUATIONS\n   WHERE EVALUATION_DATE < p_start_date\n     AND EMPIRICAL_ACCURACY < p_accuracy_threshold;\nEND;",
    "database_name": "machine_lmeac_806224",
    "tables": [
      "MODELS",
      "MODEL_EVALUATIONS",
      "DATASETS"
    ],
    "call_sqls": [
      "BEGIN\n  sp('2024-01-01', '2024-03-31', 100, 0.5);\n  COMMIT;\nEND;",
      "BEGIN\n  sp('2023-06-01', '2023-12-31', 42, 0.7);\n  COMMIT;\nEND;",
      "BEGIN\n  sp('2024-02-15', '2024-02-29', 1, 0.3);\n  COMMIT;\nEND;",
      "BEGIN\n  sp('2023-01-01', '2023-01-31', 0, 0.9);\n  COMMIT;\nEND;",
      "BEGIN\n  sp('2024-04-01', '2024-04-30', 25, 0.6);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp that, for each dataset in the DATASETS table created within a specified date range, identifies the model with the highest empirical accuracy from the MODEL_EVALUATIONS table and inserts a new derived model record into the MODELS table with a generated MODEL_ID, a name based on the dataset, and details including the provided user. It then deletes all evaluation records from MODEL_EVALUATIONS where the evaluation date is before the start date and the empirical accuracy is below a specified threshold, also removing any associated records from the EVALUATION_VERSIONS table first to maintain referential integrity.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp that, for each dataset in the DATASETS table created within a provided start and end date range, finds the model with the highest empirical accuracy per dataset from the MODEL_EVALUATIONS table, inserts a new derived model record into the MODELS table for it, and then deletes old evaluation records from MODEL_EVALUATIONS and their associated records from EVALUATION_VERSIONS where the evaluation date is before the start date and the empirical accuracy is below a given threshold.",
    "id": 26,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts four input parameters: `p_start_date` of type `VARCHAR2`, `p_end_date` of type `VARCHAR2`, `p_user_id` of type `NUMBER`, and `p_accuracy_threshold` of type `NUMBER`. The procedure first declares two local variables, `v_dataset_id` and `v_model_id`, both of type `NUMBER`, though `v_dataset_id` is not used in the current implementation. The procedure then initiates a `FOR` loop that iterates through a result set. This result set is generated by selecting distinct `DATASET_ID` values from the `DATASETS` table, aliased as `d`, joined with the `MODEL_EVALUATIONS` table, aliased as `me`, on the condition that `d.DATASET_ID` equals `me.DATASET_ID`. The selection is further filtered by a `WHERE` clause, ensuring that the `CREATED_DATE` column in the `DATASETS` table falls inclusively between the `p_start_date` and `p_end_date` parameters.\n\nInside this loop, for each distinct `DATASET_ID` retrieved (referred to as `rec.DATASET_ID`), the procedure executes a `SELECT` statement to retrieve a single `MODEL_ID` into the `v_model_id` variable. This `MODEL_ID` is selected from the `MODEL_EVALUATIONS` table where the `DATASET_ID` matches the current `rec.DATASET_ID` from the loop, and the `EMPIRICAL_ACCURACY` is equal to the maximum `EMPIRICAL_ACCURACY` found for that specific `DATASET_ID` within the `MODEL_EVALUATIONS` table. In cases where multiple models share the maximum `EMPIRICAL_ACCURACY` for a given `DATASET_ID`, `ROWNUM = 1` ensures that only one `MODEL_ID` is selected.\n\nFollowing this `SELECT` statement, an `INSERT` statement is executed into the `MODELS` table. The values inserted are:\n- `MODEL_ID`: `v_model_id + 10000`\n- `MODEL_NAME`: A concatenated string `'Derived_Model_'` followed by the current `rec.DATASET_ID`\n- `MODEL_TYPE`: The literal string `'DERIVED'`\n- `CREATED_DATE`: The current timestamp formatted as 'YYYY-MM-DD' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD')`\n- `MODEL_DESCRIPTION`: A concatenated string `'Derived from dataset '` followed by the current `rec.DATASET_ID`\n- `MODEL_VERSION`: The literal string `'1.0'`\n- `CREATED_BY`: The value of the `p_user_id` parameter\n- `LAST_MODIFIED_DATE`: The current timestamp formatted as 'YYYY-MM-DD' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD')`\n- `LAST_MODIFIED_BY`: The value of the `p_user_id` parameter\n\nAfter the loop completes, the procedure performs two `DELETE` operations. The first `DELETE` statement targets the `EVALUATION_VERSIONS` table. It removes records where the `EVALUATION_ID` column is present in a subquery's result set. This subquery selects `EVALUATION_ID` from the `MODEL_EVALUATIONS` table where the `EVALUATION_DATE` is strictly less than the `p_start_date` parameter and the `EMPIRICAL_ACCURACY` is strictly less than the `p_accuracy_threshold` parameter.\n\nThe second `DELETE` statement then targets the `MODEL_EVALUATIONS` table itself. It removes records where the `EVALUATION_DATE` is strictly less than the `p_start_date` parameter and the `EMPIRICAL_ACCURACY` is strictly less than the `p_accuracy_threshold` parameter.",
    "original_summary": "Create a stored procedure named 'sp' that, for datasets created within a specified date range, finds the model with the highest empirical accuracy for each dataset and inserts a derived model record into the MODELS table. It then deletes old evaluation records and their associated versions where the evaluation date is before the start date and the empirical accuracy is below a specified threshold.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure named 'sp' that, for datasets created within a given date range, identifies the model with the highest empirical accuracy per dataset, inserts a derived model record into the MODELS table, and then deletes old evaluation records and their associated versions where the evaluation date is before the start date and the empirical accuracy falls below a specified threshold?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DEACTIVATE_REGION_COUNTRIES that accepts two parameters: an input parameter named P_REGION_ID of type NUMBER, which is used to identify a specific geographical region, and an output parameter named P_DEACTIVATED of type NUMBER, which is used to return a count of the affected rows. The procedure performs a single update operation on the COUNTRIES table, setting the value of the IS_ACTIVE column to 0 for every row where the REGION_ID column value is exactly equal to the value supplied in the P_REGION_ID input parameter. Immediately after the update, the procedure assigns the number of rows modified by the preceding SQL statement, obtained via the SQL%ROWCOUNT cursor attribute, to the output parameter P_DEACTIVATED.",
    "plsql": "CREATE OR REPLACE PROCEDURE deactivate_region_countries(\n  p_region_id IN NUMBER,\n  p_deactivated OUT NUMBER\n) IS\nBEGIN\n  UPDATE COUNTRIES\n  SET IS_ACTIVE = 0\n  WHERE REGION_ID = p_region_id;\n  p_deactivated := SQL%ROWCOUNT;\nEND;",
    "database_name": "fashion_scam_standards",
    "tables": [
      "COUNTRIES",
      "MEASUREMENTS",
      "MEASUREMENT_GUIDELINES",
      "PRODUCT_LINES",
      "REGIONS",
      "SIZE_CHARTS",
      "SIZE_ISSUES"
    ],
    "call_sqls": [
      "DECLARE\n  v_deactivated_count NUMBER;\nBEGIN\n  deactivate_region_countries(p_region_id => 0, p_deactivated => v_deactivated_count);\n  DBMS_OUTPUT.PUT_LINE('Deactivated countries: ' || v_deactivated_count);\nEND;",
      "DECLARE\n  v_deactivated_count NUMBER;\nBEGIN\n  deactivate_region_countries(p_region_id => 1, p_deactivated => v_deactivated_count);\n  DBMS_OUTPUT.PUT_LINE('Deactivated countries: ' || v_deactivated_count);\nEND;",
      "DECLARE\n  v_deactivated_count NUMBER;\nBEGIN\n  deactivate_region_countries(p_region_id => 99, p_deactivated => v_deactivated_count);\n  DBMS_OUTPUT.PUT_LINE('Deactivated countries: ' || v_deactivated_count);\nEND;",
      "DECLARE\n  v_deactivated_count NUMBER;\nBEGIN\n  deactivate_region_countries(p_region_id => NULL, p_deactivated => v_deactivated_count);\n  DBMS_OUTPUT.PUT_LINE('Deactivated countries: ' || v_deactivated_count);\nEND;",
      "DECLARE\n  v_deactivated_count NUMBER;\nBEGIN\n  deactivate_region_countries(p_region_id => 10, p_deactivated => v_deactivated_count);\n  DBMS_OUTPUT.PUT_LINE('Deactivated countries: ' || v_deactivated_count);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named DEACTIVATE_REGION_COUNTRIES that accepts a region ID and returns the count of deactivated rows. For all countries in the COUNTRIES table belonging to the specified region, set the IS_ACTIVE column to 0 and return the number of rows updated.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called DEACTIVATE_REGION_COUNTRIES that takes a region ID, deactivates all countries in that region by setting IS_ACTIVE to 0 in the COUNTRIES table, and returns the count of rows that were updated.",
    "id": 27,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DEACTIVATE_REGION_COUNTRIES that accepts two parameters: an input parameter named P_REGION_ID of type NUMBER, which is used to identify a specific geographical region, and an output parameter named P_DEACTIVATED of type NUMBER, which is used to return a count of the affected rows. The procedure performs a single update operation on the COUNTRIES table, setting the value of the IS_ACTIVE column to 0 for every row where the REGION_ID column value is exactly equal to the value supplied in the P_REGION_ID input parameter. Immediately after the update, the procedure assigns the number of rows modified by the preceding SQL statement, obtained via the SQL%ROWCOUNT cursor attribute, to the output parameter P_DEACTIVATED.",
    "original_summary": "Create a stored procedure named DEACTIVATE_REGION_COUNTRIES that accepts a region ID and returns a count of deactivated rows. Update the COUNTRIES table to set IS_ACTIVE to 0 for all countries in the specified region and return the number of rows updated.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Write a stored procedure called DEACTIVATE_REGION_COUNTRIES that takes a region ID, deactivates all countries in that region by setting IS_ACTIVE to 0 in the COUNTRIES table, and gives back the count of rows that were updated."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `ProcessSensorEvents` that accepts a single input parameter, `p_sensor_name`, which is of data type `VARCHAR2`. This procedure is designed to process sensor events by identifying sensors whose names partially match the provided `p_sensor_name` and then, for each such sensor, conditionally inserting records into an anomaly detection table.\n\nThe procedure begins by declaring a local cursor named `sensor_cursor`. This cursor is defined to select specific data from the `SENSORS` table, aliased as `s`, and the `THRESHOLDS` table, aliased as `t`. Specifically, it selects the `SENSOR_ID`, `SENSOR_TYPE` from the `SENSORS` table, and the `THRESHOLD_VALUE` from the `THRESHOLDS` table. The `SENSORS` table is left-joined with the `THRESHOLDS` table on the condition that `s.SENSOR_ID` is equal to `t.SENSOR_ID`. This `LEFT JOIN` ensures that all sensors are considered, even if they do not have a corresponding entry in the `THRESHOLDS` table. The selection is further filtered by a `WHERE` clause, which specifies that the `SENSOR_NAME` column in the `SENSORS` table must contain the substring provided by the `p_sensor_name` parameter. The `LIKE` operator with wildcard characters (`%`) is used for this partial string matching.\n\nFollowing the cursor declaration, three local variables are declared: `v_sensor_id` of type `NUMBER`, `v_sensor_type` of type `VARCHAR2(255)`, and `v_threshold_value` of type `NUMBER`. These variables are used to hold the data fetched from the `sensor_cursor`.\n\nThe executable part of the procedure starts by opening the `sensor_cursor`. It then enters a `LOOP` construct. Inside this loop, it attempts to `FETCH` a row from the `sensor_cursor` into the `v_sensor_id`, `v_sensor_type`, and `v_threshold_value` variables. Immediately after the `FETCH` operation, an `EXIT WHEN sensor_cursor%NOTFOUND` statement checks if the last `FETCH` operation failed to retrieve a row, indicating that all rows from the cursor have been processed. If no more rows are found, the loop terminates.\n\nIf a row is successfully fetched, a conditional `IF` statement checks if the `v_threshold_value` is `NOT NULL`. This condition determines whether a threshold has been defined for the current sensor. If `v_threshold_value` is indeed not null, an `INSERT` statement is executed. This `INSERT` statement adds a new record into the `ANOMALY_DETECTION` table. The columns being populated are `ANOMALY_ID`, `SENSOR_ID`, `ANOMALY_SCORE`, `ANOMALY_TYPE`, `ANOMALY_TIMESTAMP`, `ANOMALY_SEVERITY`, and `ANOMALY_DESCRIPTION`.\n\nThe values for these columns are derived as follows:\n- For `ANOMALY_ID`, it calculates `NVL(MAX(ANOMALY_ID), 0) + 1`. This subquery dynamically determines the next available `ANOMALY_ID` by finding the maximum existing `ANOMALY_ID` in the `ANOMALY_DETECTION` table and adding 1 to it. If no `ANOMALY_ID` exists (i.e., `MAX(ANOMALY_ID)` returns `NULL`), `NVL` ensures that `0` is used instead, resulting in the first `ANOMALY_ID` being `1`.\n- For `SENSOR_ID`, it uses the `v_sensor_id` fetched from the cursor.\n- For `ANOMALY_SCORE`, a fixed value of `0.9` is used.\n- For `ANOMALY_TYPE`, the literal string `'threshold'` is used.\n- For `ANOMALY_TIMESTAMP`, a fixed numeric value `1416720000` is used, which typically represents a Unix timestamp.\n- For `ANOMALY_SEVERITY`, the literal string `'high'` is used.\n- For `ANOMALY_DESCRIPTION`, a concatenated string `'Threshold violation for ' || v_sensor_type` is constructed, combining a literal string with the `v_sensor_type` fetched from the cursor.\n\nAfter the `IF` statement (if executed) or immediately after the `FETCH` (if the `IF` condition is false), the loop continues to the next iteration. Once the loop terminates (when `sensor_cursor%NOTFOUND` is true), the `CLOSE sensor_cursor` statement is executed to release the resources held by the cursor. The procedure then concludes.",
    "plsql": "CREATE OR REPLACE PROCEDURE ProcessSensorEvents(p_sensor_name VARCHAR2) AS\n    CURSOR sensor_cursor IS\n        SELECT s.SENSOR_ID, s.SENSOR_TYPE, t.THRESHOLD_VALUE\n        FROM SENSORS s\n        LEFT JOIN THRESHOLDS t ON s.SENSOR_ID = t.SENSOR_ID\n        WHERE s.SENSOR_NAME LIKE '%' || p_sensor_name || '%';\n    v_sensor_id NUMBER;\n    v_sensor_type VARCHAR2(255);\n    v_threshold_value NUMBER;\nBEGIN\n    OPEN sensor_cursor;\n    LOOP\n        FETCH sensor_cursor INTO v_sensor_id, v_sensor_type, v_threshold_value;\n        EXIT WHEN sensor_cursor%NOTFOUND;\n        IF v_threshold_value IS NOT NULL THEN\n            INSERT INTO ANOMALY_DETECTION (ANOMALY_ID, SENSOR_ID, ANOMALY_SCORE, ANOMALY_TYPE, ANOMALY_TIMESTAMP, ANOMALY_SEVERITY, ANOMALY_DESCRIPTION)\n            SELECT NVL(MAX(ANOMALY_ID), 0) + 1, v_sensor_id, 0.9, 'threshold', 1416720000, 'high', 'Threshold violation for ' || v_sensor_type\n            FROM ANOMALY_DETECTION;\n        END IF;\n    END LOOP;\n    CLOSE sensor_cursor;\nEND;",
    "database_name": "time_sdaaa_detection",
    "tables": [
      "SENSORS",
      "TIME_SERIES_DATA",
      "ANOMALY_DETECTION",
      "CHANGEPOINT_DETECTION",
      "THRESHOLDS",
      "TREND_ANALYSIS"
    ],
    "call_sqls": [
      "BEGIN\n  ProcessSensorEvents('Temperature Sensor');\n  COMMIT;\nEND;",
      "BEGIN\n  ProcessSensorEvents('Pressure Sensor');\n  COMMIT;\nEND;",
      "BEGIN\n  ProcessSensorEvents('Humidity Sensor');\n  COMMIT;\nEND;",
      "BEGIN\n  ProcessSensorEvents('Flow Sensor');\n  COMMIT;\nEND;",
      "BEGIN\n  ProcessSensorEvents('Vibration Sensor');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named ProcessSensorEvents that, given an input substring for sensor names, processes all sensors from the SENSORS table whose names contain that substring. For each matching sensor, if a corresponding THRESHOLD_VALUE exists in the THRESHOLDS table, insert a new record into the ANOMALY_DETECTION table. The new record should use the next available ANOMALY_ID (calculated as the maximum existing ID plus one, starting from 1), the sensor's SENSOR_ID, a fixed ANOMALY_SCORE of 0.9, an ANOMALY_TYPE of 'threshold', a fixed ANOMALY_TIMESTAMP of 1416720000, an ANOMALY_SEVERITY of 'high', and an ANOMALY_DESCRIPTION that concatenates 'Threshold violation for ' with the sensor's SENSOR_TYPE.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called ProcessSensorEvents that, for sensors whose SENSOR_NAME contains a given substring, processes each sensor by retrieving its SENSOR_ID, SENSOR_TYPE, and THRESHOLD_VALUE from the SENSORS table joined with the THRESHOLDS table. For each sensor where a THRESHOLD_VALUE exists, it should insert a new record into the ANOMALY_DETECTION table, generating the ANOMALY_ID as the maximum existing ANOMALY_ID plus one (starting from 1 if none exist), using the retrieved SENSOR_ID, setting ANOMALY_SCORE to 0.9, ANOMALY_TYPE to 'threshold', ANOMALY_TIMESTAMP to 1416720000, ANOMALY_SEVERITY to 'high', and ANOMALY_DESCRIPTION as 'Threshold violation for ' concatenated with the SENSOR_TYPE.",
    "id": 28,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `ProcessSensorEvents` that accepts a single input parameter, `p_sensor_name`, which is of data type `VARCHAR2`. This procedure is designed to process sensor events by identifying sensors whose names partially match the provided `p_sensor_name` and then, for each such sensor, conditionally inserting records into an anomaly detection table.\n\nThe procedure begins by declaring a local cursor named `sensor_cursor`. This cursor is defined to select specific data from the `SENSORS` table, aliased as `s`, and the `THRESHOLDS` table, aliased as `t`. Specifically, it selects the `SENSOR_ID`, `SENSOR_TYPE` from the `SENSORS` table, and the `THRESHOLD_VALUE` from the `THRESHOLDS` table. The `SENSORS` table is left-joined with the `THRESHOLDS` table on the condition that `s.SENSOR_ID` is equal to `t.SENSOR_ID`. This `LEFT JOIN` ensures that all sensors are considered, even if they do not have a corresponding entry in the `THRESHOLDS` table. The selection is further filtered by a `WHERE` clause, which specifies that the `SENSOR_NAME` column in the `SENSORS` table must contain the substring provided by the `p_sensor_name` parameter. The `LIKE` operator with wildcard characters (`%`) is used for this partial string matching.\n\nFollowing the cursor declaration, three local variables are declared: `v_sensor_id` of type `NUMBER`, `v_sensor_type` of type `VARCHAR2(255)`, and `v_threshold_value` of type `NUMBER`. These variables are used to hold the data fetched from the `sensor_cursor`.\n\nThe executable part of the procedure starts by opening the `sensor_cursor`. It then enters a `LOOP` construct. Inside this loop, it attempts to `FETCH` a row from the `sensor_cursor` into the `v_sensor_id`, `v_sensor_type`, and `v_threshold_value` variables. Immediately after the `FETCH` operation, an `EXIT WHEN sensor_cursor%NOTFOUND` statement checks if the last `FETCH` operation failed to retrieve a row, indicating that all rows from the cursor have been processed. If no more rows are found, the loop terminates.\n\nIf a row is successfully fetched, a conditional `IF` statement checks if the `v_threshold_value` is `NOT NULL`. This condition determines whether a threshold has been defined for the current sensor. If `v_threshold_value` is indeed not null, an `INSERT` statement is executed. This `INSERT` statement adds a new record into the `ANOMALY_DETECTION` table. The columns being populated are `ANOMALY_ID`, `SENSOR_ID`, `ANOMALY_SCORE`, `ANOMALY_TYPE`, `ANOMALY_TIMESTAMP`, `ANOMALY_SEVERITY`, and `ANOMALY_DESCRIPTION`.\n\nThe values for these columns are derived as follows:\n- For `ANOMALY_ID`, it calculates `NVL(MAX(ANOMALY_ID), 0) + 1`. This subquery dynamically determines the next available `ANOMALY_ID` by finding the maximum existing `ANOMALY_ID` in the `ANOMALY_DETECTION` table and adding 1 to it. If no `ANOMALY_ID` exists (i.e., `MAX(ANOMALY_ID)` returns `NULL`), `NVL` ensures that `0` is used instead, resulting in the first `ANOMALY_ID` being `1`.\n- For `SENSOR_ID`, it uses the `v_sensor_id` fetched from the cursor.\n- For `ANOMALY_SCORE`, a fixed value of `0.9` is used.\n- For `ANOMALY_TYPE`, the literal string `'threshold'` is used.\n- For `ANOMALY_TIMESTAMP`, a fixed numeric value `1416720000` is used, which typically represents a Unix timestamp.\n- For `ANOMALY_SEVERITY`, the literal string `'high'` is used.\n- For `ANOMALY_DESCRIPTION`, a concatenated string `'Threshold violation for ' || v_sensor_type` is constructed, combining a literal string with the `v_sensor_type` fetched from the cursor.\n\nAfter the `IF` statement (if executed) or immediately after the `FETCH` (if the `IF` condition is false), the loop continues to the next iteration. Once the loop terminates (when `sensor_cursor%NOTFOUND` is true), the `CLOSE sensor_cursor` statement is executed to release the resources held by the cursor. The procedure then concludes.",
    "original_summary": "Create a stored procedure named ProcessSensorEvents that processes sensors with names containing a provided VARCHAR2 substring (p_sensor_name). Use a cursor to fetch SENSOR_ID, SENSOR_TYPE, and THRESHOLD_VALUE (via a LEFT JOIN from SENSORS to THRESHOLDS). For each fetched row, if a THRESHOLD_VALUE exists, insert a row into the ANOMALY_DETECTION table. Generate ANOMALY_ID as max existing ID + 1 (starting at 1). Use the fetched SENSOR_ID. Set ANOMALY_SCORE=0.9, ANOMALY_TYPE='threshold', ANOMALY_TIMESTAMP=1416720000, ANOMALY_SEVERITY='high', and ANOMALY_DESCRIPTION as 'Threshold violation for ' concatenated with the SENSOR_TYPE.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure named ProcessSensorEvents that processes sensors whose names contain a given substring? It should use a cursor to fetch SENSOR_ID, SENSOR_TYPE, and THRESHOLD_VALUE by performing a LEFT JOIN from the SENSORS table to the THRESHOLDS table. For each row fetched, if a THRESHOLD_VALUE exists, how should it insert a new record into the ANOMALY_DETECTION table? The ANOMALY_ID should be generated as the maximum existing ID plus one, starting from 1 if none exist. It should use the fetched SENSOR_ID, set ANOMALY_SCORE to 0.9, ANOMALY_TYPE to 'threshold', ANOMALY_TIMESTAMP to 1416720000, ANOMALY_SEVERITY to 'high', and the ANOMALY_DESCRIPTION as 'Threshold violation for ' concatenated with the SENSOR_TYPE."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_patient_status that accepts two parameters: p_patient_id of type NUMBER, which represents the unique identifier of a patient, and p_new_status of type VARCHAR2, which represents the new status intended for the patient. The procedure begins by executing an UPDATE statement on the PATIENTS table, specifically targeting the row where the PATIENT_ID column matches the value provided in the p_patient_id parameter. In this operation, the UPDATED_AT column is set to the current system date and time, formatted as a string in the 'YYYY-MM-DD HH24:MI:SS' format using the TO_CHAR function applied to SYSDATE, which retrieves the current date and time from the system. This update is performed to reflect a change in the patient's status, even though the actual status is not stored in the table. Following the update, the procedure uses the DBMS_OUTPUT.PUT_LINE function to output a message to the console, indicating that an attempt to change the status of the patient identified by p_patient_id to the new status specified by p_new_status has been logged, along with the current system date and time obtained from SYSDATE. This message serves as a placeholder for actual status tracking, as the status change is not directly recorded in the database.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_patient_status(p_patient_id NUMBER, p_new_status VARCHAR2) IS\nBEGIN\n  -- Since PATIENTS table doesn't have STATUS column, update UPDATED_AT to reflect change\n  UPDATE PATIENTS \n  SET UPDATED_AT = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n  WHERE PATIENT_ID = p_patient_id;\n  \n  -- Log the status change attempt (placeholder for actual status tracking)\n  DBMS_OUTPUT.PUT_LINE('Patient ' || p_patient_id || ' status change to ' || p_new_status || ' logged at ' || SYSDATE);\nEND;",
    "database_name": "healthcare_dma_analytics",
    "tables": [
      "DATAMARTS",
      "DISPENSES",
      "PATIENTS",
      "QUERIES",
      "RESPONSES",
      "TREATMENTS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  update_patient_status(1, 'active');\n  COMMIT;\nEND;",
      "BEGIN\n  update_patient_status(0, 'inactive');\n  COMMIT;\nEND;",
      "BEGIN\n  update_patient_status(100, 'discharged');\n  COMMIT;\nEND;",
      "BEGIN\n  update_patient_status(25, 'admitted');\n  COMMIT;\nEND;",
      "BEGIN\n  update_patient_status(42, 'pending');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_patient_status that accepts a patient ID and a new status, updates the UPDATED_AT timestamp in the PATIENTS table to the current system time for the specified patient, and outputs a console message logging the attempted status change with the patient ID, new status, and current timestamp.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_patient_status that updates the UPDATED_AT field in the PATIENTS table to the current timestamp for a given patient ID, and logs a message indicating the patient ID, the new status provided, and the timestamp of the change attempt.",
    "id": 29,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_patient_status. The procedure accepts two input parameters: a numeric parameter p_patient_id of type NUMBER and a string parameter p_new_status of type VARCHAR2. The procedure first declares a local variable v_current_timestamp of type TIMESTAMP to store the current system timestamp. It begins execution by assigning the current system timestamp using SYSTIMESTAMP to the v_current_timestamp variable. Next, it performs an UPDATE operation on the PATIENTS table, setting the UPDATED_AT column to the value stored in v_current_timestamp. This update is applied only to the row where the PATIENT_ID column exactly matches the value provided in the p_patient_id parameter. Following the update, the procedure logs a message using DBMS_OUTPUT.PUT_LINE. The message is a concatenated string that includes the literal text 'Patient ID: ', the value of the p_patient_id parameter, the literal text ', New Status: ', the value of the p_new_status parameter, the literal text ', Update Attempt Timestamp: ', and the value stored in the v_current_timestamp variable.",
    "original_summary": "Create a stored procedure named update_patient_status that accepts a patient ID and a new status. Update the patient's UPDATED_AT timestamp to the current system time. Output a console message logging the attempted status change with the current timestamp.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure update_patient_status with patient ID and new status. Update patient's UPDATED_AT to now. Log the change attempt with timestamp."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdateIndicator` that accepts four input parameters: `p_indicator_id` of type `VARCHAR2`, intended to uniquely identify an indicator record; `p_indicator_name` of type `VARCHAR2`, representing the name of the indicator; `p_description` of type `VARCHAR2`, providing a detailed description for the indicator; and `p_category` of type `VARCHAR2`, specifying the category to which the indicator belongs. The procedure begins by declaring a local variable `v_exists` of type `NUMBER`, which will be used to store the count of existing records. It then executes a `SELECT` statement to count the number of rows in the `INDICATORS` table where the `INDICATOR_ID` column matches the value provided in the `p_indicator_id` input parameter. The result of this count is stored in the `v_exists` variable. Following this, the procedure evaluates the value of `v_exists` using a conditional `IF-ELSIF-ELSE` block. If `v_exists` is equal to `1`, indicating that exactly one record with the specified `INDICATOR_ID` already exists, the procedure executes an `UPDATE` statement on the `INDICATORS` table. This `UPDATE` statement sets the `INDICATOR_NAME` column to the value of `p_indicator_name`, the `DESCRIPTION` column to the value of `p_description`, and the `CATEGORY` column to the value of `p_category`, specifically for the row where the `INDICATOR_ID` column matches the `p_indicator_id` input parameter. If `v_exists` is equal to `0`, meaning no record with the specified `INDICATOR_ID` was found, the procedure executes an `INSERT` statement into the `INDICATORS` table. This `INSERT` statement creates a new row, populating the `INDICATOR_ID` column with `p_indicator_id`, the `INDICATOR_NAME` column with `p_indicator_name`, the `DESCRIPTION` column with `p_description`, and the `CATEGORY` column with `p_category`. If `v_exists` is neither `1` nor `0` (implying that more than one record with the same `INDICATOR_ID` exists, which would typically indicate a data integrity issue), the procedure executes a `DELETE` statement on the `INDICATORS` table. This `DELETE` statement removes all rows where the `INDICATOR_ID` column matches the `p_indicator_id` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateIndicator(\n    p_indicator_id VARCHAR2,\n    p_indicator_name VARCHAR2,\n    p_description VARCHAR2,\n    p_category VARCHAR2\n) AS\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_exists\n    FROM INDICATORS\n    WHERE INDICATOR_ID = p_indicator_id;\n\n    IF v_exists = 1 THEN\n        UPDATE INDICATORS\n        SET INDICATOR_NAME = p_indicator_name, DESCRIPTION = p_description, CATEGORY = p_category\n        WHERE INDICATOR_ID = p_indicator_id;\n    ELSIF v_exists = 0 THEN\n        INSERT INTO INDICATORS (INDICATOR_ID, INDICATOR_NAME, DESCRIPTION, CATEGORY)\n        VALUES (p_indicator_id, p_indicator_name, p_description, p_category);\n    ELSE\n        DELETE FROM INDICATORS\n        WHERE INDICATOR_ID = p_indicator_id;\n    END IF;\nEND;",
    "database_name": "demographic_ahs_652164",
    "tables": [
      "DATASETS",
      "DATASET_VERSIONS",
      "INDICATORS",
      "POSITIONS",
      "SEX",
      "UNITS"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateIndicator('IND001', 'Indicator Name 1', 'Description 1', 'Category 1');\n  commit;\nEND;",
      "BEGIN\n  UpdateIndicator('IND002', 'Indicator Name 2', 'Description 2', 'Category 2');\n  commit;\nEND;",
      "BEGIN\n  UpdateIndicator('IND003', 'Indicator Name 3', 'Description 3', 'Category 3');\n  commit;\nEND;",
      "BEGIN\n  UpdateIndicator('IND004', 'Indicator Name 4', 'Description 4', 'Category 4');\n  commit;\nEND;",
      "BEGIN\n  UpdateIndicator('IND005', 'Indicator Name 5', 'Description 5', 'Category 5');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named UpdateIndicator that, for a given indicator_id, checks the INDICATORS table: if exactly one record with that ID exists, update its INDICATOR_NAME, DESCRIPTION, and CATEGORY with the provided values; if no record exists, insert a new record into INDICATORS with the provided indicator_id, INDICATOR_NAME, DESCRIPTION, and CATEGORY; and if more than one record exists, delete all records from INDICATORS with that indicator_id.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called UpdateIndicator that manages records in the INDICATORS table by taking an indicator_id, name, description, and category as inputs. If exactly one record with the given indicator_id exists, update its INDICATOR_NAME, DESCRIPTION, and CATEGORY fields with the provided values. If no record is found, insert a new record with all the supplied data. If multiple records share the same indicator_id, delete all of those records.",
    "id": 30,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateIndicator that accepts four input parameters: a numeric parameter p_indicator_id representing an indicator identifier, a string parameter p_name representing a new indicator name, a string parameter p_description representing a new description, and a string parameter p_category representing a new category. The procedure first declares a local numeric variable v_count. It then queries the INDICATORS table to count the number of rows where the indicator_id column equals the input p_indicator_id, storing the result in v_count. Next, the procedure uses a conditional IF-ELSIF-ELSE block to manage records based on the value of v_count. If v_count equals 1, indicating exactly one existing record with the given indicator_id, the procedure performs an UPDATE operation on the INDICATORS table. It updates the row where indicator_id equals p_indicator_id, setting the INDICATOR_NAME column to the input p_name, the DESCRIPTION column to the input p_description, and the CATEGORY column to the input p_category. If v_count equals 0, indicating no existing record with the given indicator_id, the procedure performs an INSERT operation into the INDICATORS table. It inserts a single new record with the indicator_id column set to the input p_indicator_id, the INDICATOR_NAME column set to the input p_name, the DESCRIPTION column set to the input p_description, and the CATEGORY column set to the input p_category. If v_count is greater than 1, indicating multiple existing records sharing the same indicator_id, the procedure performs a DELETE operation on the INDICATORS table. It deletes all rows where the indicator_id column equals the input p_indicator_id. The procedure does not return any value.",
    "original_summary": "Create a stored procedure named UpdateIndicator that manages records in an INDICATORS table based on a provided indicator_id. Check if a record with that ID exists. If exactly one exists, update its name, description, and category. If none exist, insert a new record with the provided values. If more than one exists, delete all records with that indicator_id.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as 'UpdateIndicator' to administer records within the INDICATORS table, utilizing a supplied indicator_id as a parameter. The procedure must first verify the existence of a record associated with the specified identifier. Should precisely one record be found, its name, description, and category fields are to be updated with the provided values. In the event that no matching record is located, a new entry containing the supplied data is to be inserted. If multiple records share the given indicator_id, all such records must be deleted."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp1 that accepts four parameters: para_CLAIM_ID of type NUMBER, para_INVESTIGATOR_ID of type NUMBER, para_STATUS of type VARCHAR2, and para_NOTES of type VARCHAR2. The procedure first declares several local variables: v_claim_count, v_inv_count, v_assign_exists, and v_status_exists, all of type NUMBER, and v_current_date of type VARCHAR2(255), which is initialized with the current system date formatted as 'YYYY-MM-DD'. The procedure begins by executing a SELECT statement to count the number of records in the CLAIMS table where the CLAIM_ID matches the para_CLAIM_ID parameter, storing the result in v_claim_count. It then performs another SELECT statement to count the number of records in the INVESTIGATORS table where the INVESTIGATOR_ID matches the para_INVESTIGATOR_ID parameter, storing the result in v_inv_count. If both v_claim_count and v_inv_count are greater than zero, indicating that the specified claim and investigator exist, the procedure proceeds to check for an existing assignment. It executes a SELECT statement to count the number of records in the CLAIM_INVESTIGATORS table where both the CLAIM_ID and INVESTIGATOR_ID match the respective parameters, storing the result in v_assign_exists. If v_assign_exists is zero, indicating no existing assignment, the procedure inserts a new record into the CLAIM_INVESTIGATORS table with the CLAIM_ID, INVESTIGATOR_ID, the current date as ASSIGNMENT_DATE, and para_NOTES as ASSIGNMENT_NOTES. The procedure then checks for an existing status history entry for the current date by executing a SELECT statement to count the number of records in the CLAIM_STATUS_HISTORY table where the CLAIM_ID matches para_CLAIM_ID and STATUS_DATE matches v_current_date, storing the result in v_status_exists. If v_status_exists is zero, indicating no existing status entry for the current date, the procedure inserts a new record into the CLAIM_STATUS_HISTORY table with the CLAIM_ID, the current date as STATUS_DATE, para_STATUS as STATUS, and para_INVESTIGATOR_ID as CHANGED_BY. The procedure includes an exception handler for DUP_VAL_ON_INDEX to gracefully handle any unique constraint violations by doing nothing.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp1(\n    para_CLAIM_ID        NUMBER,\n    para_INVESTIGATOR_ID NUMBER,\n    para_STATUS          VARCHAR2,\n    para_NOTES           VARCHAR2\n) IS\n    v_claim_count   NUMBER;\n    v_inv_count     NUMBER;\n    v_assign_exists NUMBER;\n    v_status_exists NUMBER;\n    v_current_date  VARCHAR2(255) := TO_CHAR(SYSDATE, 'YYYY-MM-DD');\nBEGIN\n    SELECT COUNT(*) INTO v_claim_count FROM CLAIMS WHERE CLAIM_ID = para_CLAIM_ID;\n    SELECT COUNT(*) INTO v_inv_count FROM INVESTIGATORS WHERE INVESTIGATOR_ID = para_INVESTIGATOR_ID;\n    \n    IF v_claim_count > 0 AND v_inv_count > 0 THEN\n        -- Check if assignment already exists\n        SELECT COUNT(*)\n          INTO v_assign_exists\n          FROM CLAIM_INVESTIGATORS\n         WHERE CLAIM_ID = para_CLAIM_ID\n           AND INVESTIGATOR_ID = para_INVESTIGATOR_ID;\n        \n        IF v_assign_exists = 0 THEN\n            INSERT INTO CLAIM_INVESTIGATORS (\n                CLAIM_ID,\n                INVESTIGATOR_ID,\n                ASSIGNMENT_DATE,\n                ASSIGNMENT_NOTES\n            ) VALUES (\n                para_CLAIM_ID,\n                para_INVESTIGATOR_ID,\n                v_current_date,\n                para_NOTES\n            );\n        END IF;\n        \n        -- Check if status history entry for this date already exists\n        SELECT COUNT(*)\n          INTO v_status_exists\n          FROM CLAIM_STATUS_HISTORY\n         WHERE CLAIM_ID = para_CLAIM_ID\n           AND STATUS_DATE = v_current_date;\n        \n        IF v_status_exists = 0 THEN\n            INSERT INTO CLAIM_STATUS_HISTORY (\n                CLAIM_ID,\n                STATUS_DATE,\n                STATUS,\n                CHANGED_BY\n            ) VALUES (\n                para_CLAIM_ID,\n                v_current_date,\n                para_STATUS,\n                para_INVESTIGATOR_ID\n            );\n        END IF;\n    END IF;\nEXCEPTION\n    WHEN DUP_VAL_ON_INDEX THEN\n        -- Handle any remaining unique constraint violations gracefully\n        NULL;\nEND;",
    "database_name": "insurance_car_management",
    "tables": [
      "CLAIMS",
      "CLAIM_INVESTIGATORS",
      "CLAIM_STATUS_HISTORY",
      "INVESTIGATORS",
      "PAYMENTS",
      "RESERVES"
    ],
    "call_sqls": [
      "BEGIN\n  sp1(1, 1, 'assigned', 'Initial assignment for investigation');\n  COMMIT;\nEND;",
      "BEGIN\n  sp1(0, 0, 'in review', 'Follow-up required on property damage claim');\n  COMMIT;\nEND;",
      "BEGIN\n  sp1(1, 0, 'pending', 'Re-assigning to different investigator');\n  COMMIT;\nEND;",
      "BEGIN\n  sp1(0, 1, 'closed', 'Investigation completed, claim resolved');\n  COMMIT;\nEND;",
      "BEGIN\n  sp1(2, 2, 'reopened', 'New evidence requires additional review');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp1 that accepts a claim ID, an investigator ID, a status, and notes. Validate that the provided claim ID exists in the CLAIMS table and the investigator ID exists in the INVESTIGATORS table. If both are valid and no existing assignment for this claim and investigator is found in the CLAIM_INVESTIGATORS table, create a new assignment record with the current date and the provided notes. Then, if no status entry for the current date exists for this claim in the CLAIM_STATUS_HISTORY table, log a new status change record using the provided status and the investigator ID. Silently handle any duplicate key errors.",
    "natural_language": "Write a Oracle PL/SQL stored procedure named sp1 that takes a claim ID, an investigator ID, a status, and notes as input, validates that the claim exists in the CLAIMS table and the investigator exists in the INVESTIGATORS table, and if both are valid and no assignment already exists in the CLAIM_INVESTIGATORS table for that claim and investigator, assigns the investigator to the claim with today's date as the ASSIGNMENT_DATE and the provided notes as ASSIGNMENT_NOTES, then logs a status change for the claim in the CLAIM_STATUS_HISTORY table with today's date as the STATUS_DATE, the provided status, and the investigator ID as CHANGED_BY, but only if no entry exists for that claim and today's date, while silently ignoring any duplicate key errors.",
    "id": 31,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp1 that accepts four parameters: para_CLAIM_ID of type NUMBER, para_INVESTIGATOR_ID of type NUMBER, para_STATUS of type VARCHAR2, and para_NOTES of type VARCHAR2. The procedure first declares several local variables: v_claim_count, v_inv_count, v_assign_exists, and v_status_exists, all of type NUMBER, and v_current_date of type VARCHAR2(255), which is initialized with the current system date formatted as 'YYYY-MM-DD'. The procedure begins by executing a SELECT statement to count the number of records in the CLAIMS table where the CLAIM_ID matches the para_CLAIM_ID parameter, storing the result in v_claim_count. It then performs another SELECT statement to count the number of records in the INVESTIGATORS table where the INVESTIGATOR_ID matches the para_INVESTIGATOR_ID parameter, storing the result in v_inv_count. If both v_claim_count and v_inv_count are greater than zero, indicating that the specified claim and investigator exist, the procedure proceeds to check for an existing assignment. It executes a SELECT statement to count the number of records in the CLAIM_INVESTIGATORS table where both the CLAIM_ID and INVESTIGATOR_ID match the respective parameters, storing the result in v_assign_exists. If v_assign_exists is zero, indicating no existing assignment, the procedure inserts a new record into the CLAIM_INVESTIGATORS table with the CLAIM_ID, INVESTIGATOR_ID, the current date as ASSIGNMENT_DATE, and para_NOTES as ASSIGNMENT_NOTES. The procedure then checks for an existing status history entry for the current date by executing a SELECT statement to count the number of records in the CLAIM_STATUS_HISTORY table where the CLAIM_ID matches para_CLAIM_ID and STATUS_DATE matches v_current_date, storing the result in v_status_exists. If v_status_exists is zero, indicating no existing status entry for the current date, the procedure inserts a new record into the CLAIM_STATUS_HISTORY table with the CLAIM_ID, the current date as STATUS_DATE, para_STATUS as STATUS, and para_INVESTIGATOR_ID as CHANGED_BY. The procedure includes an exception handler for DUP_VAL_ON_INDEX to gracefully handle any unique constraint violations by doing nothing.",
    "original_summary": "Create a stored procedure named sp1 that accepts a claim ID, investigator ID, status, and notes. Validate the existence of the claim and investigator. If valid and no assignment exists, assign the investigator to the claim with the current date and notes. Then, if no status entry exists for today, log the status change for the claim. Handle duplicate key errors silently.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure named sp1 that takes a claim ID, an investigator ID, a status, and notes as input, validates the existence of both the claim and the investigator, and then, if they are valid and no assignment exists, assigns the investigator to the claim with today's date and the provided notes, followed by logging a status change for the claim if no entry exists for today, while silently handling any duplicate key errors?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_player_statistics that accepts three parameters: p_game_id of type NUMBER, p_player_id of type NUMBER, and p_stat_type of type VARCHAR2. The procedure is designed to update the PLAYER_STATISTICS table. It begins by declaring a local variable v_stat_value of type NUMBER, initialized to 0. The procedure uses a conditional statement to determine the type of statistic to be processed based on the value of p_stat_type, which is converted to uppercase using the UPPER() function. If p_stat_type is 'POINTS', it performs a SELECT operation to calculate the sum of the PTS column for rows in the PLAYER_STATISTICS table where GAME_ID matches p_game_id and PLAYER_ID matches p_player_id, using NVL() to ensure a default value of 0 if no rows are found. If p_stat_type is 'REBOUNDS', it calculates the sum of the DRB and ORB columns for the same conditions. For any other value of p_stat_type, it calculates the sum of the ASSISTS column. The result of the SELECT operation is stored in v_stat_value. Finally, the procedure performs an UPDATE operation on the PLAYER_STATISTICS table, setting the FANTASY_POINTS column to the value of v_stat_value for rows where GAME_ID matches p_game_id and PLAYER_ID matches p_player_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_player_statistics(\n    p_game_id IN NUMBER,\n    p_player_id IN NUMBER,\n    p_stat_type IN VARCHAR2\n)\nIS\n    v_stat_value NUMBER := 0;\nBEGIN\n    IF UPPER(p_stat_type) = 'POINTS' THEN\n        SELECT NVL(SUM(PTS), 0) INTO v_stat_value\n        FROM PLAYER_STATISTICS\n        WHERE GAME_ID = p_game_id AND PLAYER_ID = p_player_id;\n    ELSIF UPPER(p_stat_type) = 'REBOUNDS' THEN\n        SELECT NVL(SUM(DRB + ORB), 0) INTO v_stat_value\n        FROM PLAYER_STATISTICS\n        WHERE GAME_ID = p_game_id AND PLAYER_ID = p_player_id;\n    ELSE\n        SELECT NVL(SUM(ASSISTS), 0) INTO v_stat_value\n        FROM PLAYER_STATISTICS\n        WHERE GAME_ID = p_game_id AND PLAYER_ID = p_player_id;\n    END IF;\n    \n    UPDATE PLAYER_STATISTICS\n    SET FANTASY_POINTS = v_stat_value\n    WHERE GAME_ID = p_game_id AND PLAYER_ID = p_player_id;\nEND;",
    "database_name": "basketball_gsap_tracking",
    "tables": [
      "GAMES",
      "PLAYERS",
      "PLAYER_STATISTICS"
    ],
    "call_sqls": [
      "BEGIN\n  update_player_statistics(0, 1, 'POINTS');\n  COMMIT;\nEND;",
      "BEGIN\n  update_player_statistics(1, 0, 'REBOUNDS');\n  COMMIT;\nEND;",
      "BEGIN\n  update_player_statistics(0, 0, 'ASSISTS');\n  COMMIT;\nEND;",
      "BEGIN\n  update_player_statistics(1, 1, 'points');\n  COMMIT;\nEND;",
      "BEGIN\n  update_player_statistics(0, 1, 'rebounds');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_player_statistics that accepts a game ID, a player ID, and a statistic type. For the specified GAME_ID and PLAYER_ID in the PLAYER_STATISTICS table, it calculates a statistic value: if the type is 'POINTS', it sums the PTS column; if the type is 'REBOUNDS', it sums the DRB and ORB columns; for any other type, it sums the ASSISTS column. It then updates the FANTASY_POINTS column for that player and game with the calculated total.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_player_statistics that takes a game ID, a player ID, and a statistic type. For the statistic type 'POINTS', calculate the total sum of PTS from the PLAYER_STATISTICS table for that specific game and player. For 'REBOUNDS', calculate the total sum of DRB and ORB. For any other statistic type, calculate the total sum of ASSISTS. Then, update the FANTASY_POINTS column in the PLAYER_STATISTICS table for the given game and player with this calculated total.",
    "id": 32,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_player_statistics that accepts three input parameters: p_game_id of type NUMBER, which specifies the game identifier; p_player_id of type NUMBER, which specifies the player identifier; and p_statistic_type of type VARCHAR2, which indicates the type of statistic to calculate. The procedure begins by declaring a local variable v_calculated_total of type NUMBER to store the computed sum based on the statistic type. The procedure then uses a conditional IF-ELSIF-ELSE control structure to determine which calculation to perform. If the p_statistic_type parameter equals the string 'POINTS', the procedure executes a SELECT statement that queries the PLAYER_STATISTICS table, summing the PTS column for rows where the GAME_ID column matches p_game_id and the PLAYER_ID column matches p_player_id, and stores the result into v_calculated_total. If p_statistic_type equals 'REBOUNDS', the procedure executes a SELECT statement that queries the PLAYER_STATISTICS table, summing the sum of the DRB column and the ORB column for rows where the GAME_ID column matches p_game_id and the PLAYER_ID column matches p_player_id, and stores the result into v_calculated_total. For any other value of p_statistic_type, the procedure executes a SELECT statement that queries the PLAYER_STATISTICS table, summing the ASSISTS column for rows where the GAME_ID column matches p_game_id and the PLAYER_ID column matches p_player_id, and stores the result into v_calculated_total. After calculating v_calculated_total, the procedure performs an UPDATE operation on the PLAYER_STATISTICS table, setting the FANTASY_POINTS column to the value of v_calculated_total specifically for the row where the GAME_ID column equals p_game_id and the PLAYER_ID column equals p_player_id.",
    "original_summary": "Create a PL/SQL procedure named update_player_statistics that accepts a game ID, player ID, and statistic type. It calculates a statistic value based on the type: sum of PTS for 'POINTS', sum of DRB and ORB for 'REBOUNDS', or sum of ASSISTS for any other type. It then updates the FANTASY_POINTS column in the PLAYER_STATISTICS table for the specified game and player with the calculated value.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Write a PL/SQL procedure called update_player_statistics that takes a game ID, a player ID, and a statistic type. For the type 'POINTS', calculate the sum of PTS. For 'REBOUNDS', calculate the sum of DRB and ORB. For any other type, calculate the sum of ASSISTS. Then, update the FANTASY_POINTS column in the PLAYER_STATISTICS table for the given game and player with this calculated value."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_participant_age that accepts two input parameters: a numeric parameter named p_participant_id and a numeric parameter named p_new_age, and executes a single SQL UPDATE operation targeting the PARTICIPANTS table, specifically setting the value of the AGE column to the value provided by the p_new_age input parameter for every row in the table where the value in the PARTICIPANT_ID column is exactly equal to the value provided by the p_participant_id input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_participant_age(p_participant_id IN NUMBER, p_new_age IN NUMBER)\nIS\nBEGIN\n    UPDATE PARTICIPANTS SET AGE = p_new_age WHERE PARTICIPANT_ID = p_participant_id;\nEND;",
    "database_name": "medical_rac_trials",
    "tables": [
      "PARTICIPANTS",
      "LABORATORY_RESULTS",
      "TREATMENTS",
      "TRIALS"
    ],
    "call_sqls": [
      "BEGIN\n  update_participant_age(0, 70);\n  COMMIT;\nEND;",
      "BEGIN\n  update_participant_age(1, 56);\n  COMMIT;\nEND;",
      "BEGIN\n  update_participant_age(2, 45);\n  COMMIT;\nEND;",
      "BEGIN\n  update_participant_age(3, 62);\n  COMMIT;\nEND;",
      "BEGIN\n  update_participant_age(4, 58);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_participant_age that updates the AGE in the PARTICIPANTS table for a specific participant, using the provided participant ID to identify the record and the provided new age value to set the AGE.",
    "natural_language": "Write a Oracle PL/SQL stored procedure named update_participant_age that updates the AGE in the PARTICIPANTS table for a specific participant using the provided participant ID and new age value.",
    "id": 33,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_participant_age that accepts two input parameters: a numeric parameter named p_participant_id and a numeric parameter named p_new_age, and executes a single SQL UPDATE operation targeting the PARTICIPANTS table, specifically setting the value of the AGE column to the value provided by the p_new_age input parameter for every row in the table where the value in the PARTICIPANT_ID column is exactly equal to the value provided by the p_participant_id input parameter.",
    "original_summary": "Create a stored procedure named update_participant_age that updates the age of a specific participant in the PARTICIPANTS table using the provided participant ID and new age value.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Update the age of a specific participant in the PARTICIPANTS table by creating a stored procedure named update_participant_age that uses the provided participant ID and new age value."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_game_attendance that accepts two input parameters: para_game_id of type NUMBER to identify a specific game, and para_attendance of type NUMBER to provide a new attendance figure. The procedure first retrieves the TEAM_ID and OPPONENT_ID for the specified game from the GAMES table, storing them in local variables v_team_id and v_opponent_id. It then updates the ATTENDANCE column in the GAMES table for the row matching the provided para_game_id with the new para_attendance value. Next, it inserts a new record into the PERFORMANCE_METRICS table for this game, generating a new METRIC_ID by taking the current maximum METRIC_ID from the PERFORMANCE_METRICS table (or using 0 if the table is empty) and incrementing it by one using the COALESCE function, and setting the columns KILLS, ATTACKS, TOTAL_ATTEMPTS, ATTACK_PERCENTAGE, BLOCKS, DIGS, and SERVICE_ERRORS all to zero. Following this, it deletes all records from the PLAYER_PERFORMANCE table where the GAME_ID matches para_game_id and the KILLS value is less than 5. A conditional check is then performed on the para_attendance value: if it is greater than 3000, the procedure updates the PERFORMANCE_METRICS table for the current game, incrementing the DIGS column by 10; otherwise, it increments the DIGS column by 5. The procedure then counts the number of players in the PLAYERS table whose TEAM_ID equals the originally retrieved v_team_id, storing the count back into the v_team_id variable; if this count exceeds 10, it deletes from the PLAYERS table all records where the TEAM_ID equals that v_team_id value and the YEAR column equals the string 'senior'. Finally, the procedure counts the number of games in the GAMES table where the OPPONENT_ID equals the originally retrieved v_opponent_id, storing the count into the v_opponent_id variable; if this count exceeds 5, it deletes from the GAMES table all records where the OPPONENT_ID equals that v_opponent_id value and the GAME_OUTCOME column equals the string 'loss'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_game_attendance(para_game_id NUMBER, para_attendance NUMBER) IS\n  v_team_id NUMBER;\n  v_opponent_id NUMBER;\nBEGIN\n  SELECT TEAM_ID, OPPONENT_ID INTO v_team_id, v_opponent_id FROM GAMES WHERE GAME_ID = para_game_id;\n  \n  UPDATE GAMES SET ATTENDANCE = para_attendance WHERE GAME_ID = para_game_id;\n  \n  INSERT INTO PERFORMANCE_METRICS (METRIC_ID, GAME_ID, KILLS, ATTACKS, TOTAL_ATTEMPTS, ATTACK_PERCENTAGE, BLOCKS, DIGS, SERVICE_ERRORS)\n  VALUES ((SELECT COALESCE(MAX(METRIC_ID), 0) + 1 FROM PERFORMANCE_METRICS), para_game_id, 0, 0, 0, 0, 0, 0, 0);\n  \n  DELETE FROM PLAYER_PERFORMANCE WHERE GAME_ID = para_game_id AND KILLS < 5;\n  \n  IF para_attendance > 3000 THEN\n    UPDATE PERFORMANCE_METRICS SET DIGS = DIGS + 10 WHERE GAME_ID = para_game_id;\n  ELSE\n    UPDATE PERFORMANCE_METRICS SET DIGS = DIGS + 5 WHERE GAME_ID = para_game_id;\n  END IF;\n  \n  SELECT COUNT(*) INTO v_team_id FROM PLAYERS WHERE TEAM_ID = v_team_id;\n  \n  IF v_team_id > 10 THEN\n    DELETE FROM PLAYERS WHERE TEAM_ID = v_team_id AND YEAR = 'senior';\n  END IF;\n  \n  SELECT COUNT(*) INTO v_opponent_id FROM GAMES WHERE OPPONENT_ID = v_opponent_id;\n  \n  IF v_opponent_id > 5 THEN\n    DELETE FROM GAMES WHERE OPPONENT_ID = v_opponent_id AND GAME_OUTCOME = 'loss';\n  END IF;\nEND;",
    "database_name": "sports_tpa_891414",
    "tables": [
      "GAMES",
      "PERFORMANCE_METRICS",
      "PLAYER_PERFORMANCE",
      "PLAYERS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_game_attendance(para_game_id => 0, para_attendance => 5000);\nEND;",
      "BEGIN\n  sp_update_game_attendance(para_game_id => 1, para_attendance => 2000);\nEND;",
      "BEGIN\n  sp_update_game_attendance(para_game_id => 0, para_attendance => 3500);\nEND;",
      "BEGIN\n  sp_update_game_attendance(para_game_id => 1, para_attendance => 1500);\nEND;",
      "BEGIN\n  sp_update_game_attendance(para_game_id => 0, para_attendance => 2999);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `sp_update_game_attendance` that takes a game ID and a new attendance figure to update the attendance for that game in the GAMES table. It retrieves the game's TEAM_ID and OPPONENT_ID, inserts a new record into PERFORMANCE_METRICS for the game with all stats set to zero, and deletes any records from PLAYER_PERFORMANCE for this game where KILLS are less than 5. Based on the new attendance, it increments the DIGS metric in PERFORMANCE_METRICS by 10 if attendance exceeds 3000, otherwise by 5. If the team has more than 10 players in the PLAYERS table, it deletes all senior players from that team. If the opponent has more than 5 games in the GAMES table, it deletes all loss records for that opponent.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_update_game_attendance that accepts a game identifier and a revised attendance value. It should retrieve the TEAM_ID and OPPONENT_ID for the specified game from the GAMES table, update the game's ATTENDANCE, and insert a new record into PERFORMANCE_METRICS for that game with all statistical values set to zero. Then, remove any player performance records for this game from PLAYER_PERFORMANCE where KILLS is below five. Based on the provided attendance, increase the DIGS metric in PERFORMANCE_METRICS by ten if attendance is high (over 3000), or by five otherwise. Additionally, if the associated team has more than ten players in the PLAYERS table, delete all senior players from that team. Furthermore, if the opponent team has participated in more than five games in the GAMES table, delete all loss records for that opponent.",
    "id": 34,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_game_attendance that accepts two input parameters: para_game_id of type NUMBER to identify a specific game, and para_attendance of type NUMBER to provide a new attendance figure. The procedure first retrieves the TEAM_ID and OPPONENT_ID for the specified game from the GAMES table, storing them in local variables v_team_id and v_opponent_id. It then updates the ATTENDANCE column in the GAMES table for the row matching the provided para_game_id with the new para_attendance value. Next, it inserts a new record into the PERFORMANCE_METRICS table for this game, generating a new METRIC_ID by taking the current maximum METRIC_ID from the PERFORMANCE_METRICS table (or using 0 if the table is empty) and incrementing it by one using the COALESCE function, and setting the columns KILLS, ATTACKS, TOTAL_ATTEMPTS, ATTACK_PERCENTAGE, BLOCKS, DIGS, and SERVICE_ERRORS all to zero. Following this, it deletes all records from the PLAYER_PERFORMANCE table where the GAME_ID matches para_game_id and the KILLS value is less than 5. A conditional check is then performed on the para_attendance value: if it is greater than 3000, the procedure updates the PERFORMANCE_METRICS table for the current game, incrementing the DIGS column by 10; otherwise, it increments the DIGS column by 5. The procedure then counts the number of players in the PLAYERS table whose TEAM_ID equals the originally retrieved v_team_id, storing the count back into the v_team_id variable; if this count exceeds 10, it deletes from the PLAYERS table all records where the TEAM_ID equals that v_team_id value and the YEAR column equals the string 'senior'. Finally, the procedure counts the number of games in the GAMES table where the OPPONENT_ID equals the originally retrieved v_opponent_id, storing the count into the v_opponent_id variable; if this count exceeds 5, it deletes from the GAMES table all records where the OPPONENT_ID equals that v_opponent_id value and the GAME_OUTCOME column equals the string 'loss'.",
    "original_summary": "Create a stored procedure named `sp_update_game_attendance` that takes a game ID and a new attendance figure. Retrieve the game's team and opponent IDs. Update the game's attendance. Insert a new performance metrics record for the game with zeroed-out stats. Delete player performance records for this game where kills are less than 5. Based on attendance, increment the game's digs metric by 10 or 5. If the team has more than 10 players, delete its senior players. If the opponent has more than 5 games, delete all loss records for that opponent.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as `sp_update_game_attendance`. This procedure should accept two parameters: a game identifier and a revised attendance value. Its operations must include: retrieving the identifiers for both the team and the opponent associated with the specified game; updating the attendance figure for that game; inserting a new performance metrics record for the game with all statistical values initialized to zero; and removing any player performance records for this game where the number of kills is below five. Subsequently, based on the provided attendance value, increment the game's digs metric by ten if the attendance is high, or by five otherwise. Furthermore, if the associated team has a roster exceeding ten players, delete all records for senior players belonging to that team. Additionally, if the opponent team has participated in more than five games, delete all loss records pertaining to that opponent."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_insert_access_summary that accepts a single input parameter p_user_id of type NUMBER, which represents the user ID for which the access summary is to be generated. The procedure begins by declaring two local variables: v_access_count and v_next_metric_id, both of type NUMBER. The procedure first executes a SELECT statement to count the number of entries in the ACCESS_LOGS table where the USER_ID column matches the provided p_user_id, storing the result in the v_access_count variable. Next, it calculates the next available METRIC_ID by selecting the maximum value of the METRIC_ID column from the METRICS table, using the NVL function to default to 0 if no records exist, and adds 1 to this maximum value, storing the result in the v_next_metric_id variable. The procedure then performs an INSERT operation into the METRICS table, adding a new record with the following values: v_next_metric_id for the METRIC_ID column, the string 'User Access Count' for the METRIC_NAME column, the string 'NUMBER' for the METRIC_VALUE_TYPE column, the value of v_access_count for the VALUE column, the current system date formatted as 'YYYY-MM-DD' for the METRIC_DATE column, and NULL for the CANDIDATE_ID column. The procedure includes an exception handling block that captures any exceptions and re-raises them without additional processing.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_insert_access_summary(p_user_id IN NUMBER)\nIS\n    v_access_count NUMBER;\n    v_next_metric_id NUMBER;\nBEGIN\n    -- Get the access count for the user\n    SELECT COUNT(*) INTO v_access_count FROM ACCESS_LOGS WHERE USER_ID = p_user_id;\n    \n    -- Calculate the next METRIC_ID\n    SELECT NVL(MAX(METRIC_ID), 0) + 1 INTO v_next_metric_id FROM METRICS;\n    \n    -- Insert the metric record\n    INSERT INTO METRICS (METRIC_ID, METRIC_NAME, METRIC_VALUE_TYPE, VALUE, METRIC_DATE, CANDIDATE_ID)\n    VALUES (v_next_metric_id, 'User Access Count', 'NUMBER', v_access_count, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), NULL);\n    \nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "educational_caa_metrics",
    "tables": [
      "ACCESS_LOGS",
      "CANDIDATES",
      "GRADE_POINTS",
      "METRICS",
      "SUBJECT_CATEGORIES",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_insert_access_summary(1);\n  COMMIT;\nEND;",
      "BEGIN\n  proc_insert_access_summary(2);\n  COMMIT;\nEND;",
      "BEGIN\n  proc_insert_access_summary(0);\n  COMMIT;\nEND;",
      "BEGIN\n  proc_insert_access_summary(100);\n  COMMIT;\nEND;",
      "BEGIN\n  proc_insert_access_summary(50);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named proc_insert_access_summary that accepts a user ID, counts how many entries that user has in the ACCESS_LOGS table, determines the next available METRIC_ID from the METRICS table, and inserts a new record into the METRICS table with that ID, a metric name of 'User Access Count', the calculated count, and the current date, while handling any errors that occur.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called proc_insert_access_summary that takes a user ID as input. It should calculate the approximate number of times that user appears in the ACCESS_LOGS table, determine the next available METRIC_ID from the METRICS table, and insert a new record into the METRICS table with that METRIC_ID, the metric name 'User Access Count', the approximate count as the value, today's date, and a standard value type of 'NUMBER'. Include error handling to propagate any issues that occur.",
    "id": 35,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named proc_insert_access_summary that accepts one input parameter: p_user_id of type NUMBER, which specifies the unique identifier of a user. The procedure is designed to calculate an approximate count of access log entries for the given user, generate a new metric identifier, and insert a summary record into a metrics table. It operates within the educational_caa_metrics database.\n\nThe procedure declares several variables: v_approx_count of type NUMBER to store the calculated approximate access count, v_next_metric_id of type NUMBER to hold the next available metric identifier, v_today_date of type DATE to capture the current system date, and v_metric_name of type VARCHAR2 with a fixed value 'User Access Count'. Additionally, v_value_type of type VARCHAR2 is declared with a fixed value 'NUMBER'.\n\nThe procedure begins by setting v_today_date to the current date using the SYSDATE function. It then performs a SELECT operation on the ACCESS_LOGS table to calculate the approximate number of times the user appears. This is done by using the COUNT(*) function on rows where the USER_ID column matches the input parameter p_user_id. The result is stored in v_approx_count.\n\nNext, the procedure determines the next available METRIC_ID from the METRICS table. It executes a SELECT statement to find the maximum value of the METRIC_ID column in the METRICS table, increments this maximum value by 1 using the NVL function to handle cases where the table is empty (defaulting to 1), and stores the result in v_next_metric_id.\n\nThe procedure then inserts a new record into the METRICS table. The INSERT operation uses the values: v_next_metric_id for the METRIC_ID column, v_metric_name for the METRIC_NAME column, v_approx_count for the VALUE column, v_today_date for the DATE_RECORDED column, and v_value_type for the VALUE_TYPE column. This creates a summary metric entry for the user's access count.\n\nError handling is implemented using an EXCEPTION block. If any error occurs during the execution of the proceduresuch as data retrieval failures, constraint violations, or other exceptionsthe procedure propagates the issue by re-raising the exception using the RAISE statement. This ensures that any problems are not silently ignored and are instead reported to the calling environment.\n\nThe procedure does not return a value; its purpose is to perform the insertion into the METRICS table based on the calculated data.",
    "original_summary": "Create a stored procedure named proc_insert_access_summary that accepts a user ID. It counts the user's entries in the ACCESS_LOGS table, calculates the next available METRIC_ID, and inserts a new record into the METRICS table with the count, the current date, and a predefined metric name. Include an exception handler to re-raise any errors.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called proc_insert_access_summary that takes a user ID. It should figure out roughly how many times the user has shown up in the ACCESS_LOGS, find a suitable next METRIC_ID number, and put a new row into the METRICS table with that approximate count, today's date, and a standard metric name. Also, add a bit of error handling to pass any problems along."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_team_performance that accepts two input parameters: a numeric parameter p_team_id representing a team's identifier and a string parameter p_season representing a season label. The procedure first declares four local numeric variables: v_total_wins, v_total_losses, v_conf_wins, and v_conf_losses. It then queries the GAMES table to count and assign to v_total_wins the number of rows where the TEAM_ID column equals the input p_team_id, the GAME_OUTCOME column equals the literal string 'win', and the year component extracted from the GAME_DATE column (by converting the string in 'YYYY-MM-DD' format to a date and then extracting the year) matches the year component extracted from the first four characters of the p_season parameter (by converting that substring to a date and extracting the year). Subsequently, it performs a second query on the GAMES table to count and assign to v_total_losses the number of rows where the TEAM_ID column equals p_team_id, the GAME_OUTCOME column equals the literal string 'loss', and the same year-matching condition based on GAME_DATE and p_season is satisfied. Following these counts, the procedure calculates v_conf_wins by multiplying v_total_wins by 0.6 and rounding the result, and calculates v_conf_losses by multiplying v_total_losses by 0.6 and rounding the result. Finally, the procedure updates the SEASON_STANDINGS table, setting the WINS column to v_total_wins, the LOSSES column to v_total_losses, the CONFERENCE_WINS column to v_conf_wins, and the CONFERENCE_LOSSES column to v_conf_losses for any row where the TEAM_ID column matches the input p_team_id and the SEASON column matches the input p_season.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_team_performance(p_team_id NUMBER, p_season VARCHAR2)\nIS\n    v_total_wins NUMBER;\n    v_total_losses NUMBER;\n    v_conf_wins NUMBER;\n    v_conf_losses NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_wins\n    FROM GAMES \n    WHERE TEAM_ID = p_team_id AND GAME_OUTCOME = 'win' AND EXTRACT(YEAR FROM TO_DATE(GAME_DATE, 'YYYY-MM-DD')) = EXTRACT(YEAR FROM TO_DATE(SUBSTR(p_season, 1, 4), 'YYYY'));\n    \n    SELECT COUNT(*) INTO v_total_losses\n    FROM GAMES \n    WHERE TEAM_ID = p_team_id AND GAME_OUTCOME = 'loss' AND EXTRACT(YEAR FROM TO_DATE(GAME_DATE, 'YYYY-MM-DD')) = EXTRACT(YEAR FROM TO_DATE(SUBSTR(p_season, 1, 4), 'YYYY'));\n    \n    v_conf_wins := ROUND(v_total_wins * 0.6);\n    v_conf_losses := ROUND(v_total_losses * 0.6);\n    \n    UPDATE SEASON_STANDINGS \n    SET WINS = v_total_wins, LOSSES = v_total_losses, CONFERENCE_WINS = v_conf_wins, CONFERENCE_LOSSES = v_conf_losses\n    WHERE TEAM_ID = p_team_id AND SEASON = p_season;\n    \n    COMMIT;\nEND;",
    "database_name": "sports_tpa_891414",
    "tables": [
      "GAMES",
      "TEAMS",
      "PLAYERS",
      "PLAYER_PERFORMANCE",
      "PERFORMANCE_METRICS",
      "SEASON_STANDINGS",
      "PLAYOFFS"
    ],
    "call_sqls": [
      "BEGIN\n  update_team_performance(0, '2022-2023');\n  COMMIT;\nEND;",
      "BEGIN\n  update_team_performance(1, '2022-2023');\n  COMMIT;\nEND;",
      "BEGIN\n  update_team_performance(0, '2023-2024');\n  COMMIT;\nEND;",
      "BEGIN\n  update_team_performance(1, '2023-2024');\n  COMMIT;\nEND;",
      "BEGIN\n  update_team_performance(0, '2021-2022');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_team_performance that accepts a team ID and a season label, retrieves the total count of wins and losses for that team from the GAMES table for the year indicated by the season, calculates conference wins and losses as 60% of those totals (rounded), and updates the WINS, LOSSES, CONFERENCE_WINS, and CONFERENCE_LOSSES columns in the SEASON_STANDINGS table for the matching TEAM_ID and SEASON.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_team_performance that updates the SEASON_STANDINGS table for a specified team and season. It takes a team ID and a season label, calculates the total wins and total losses for that team and season from the GAMES table, then computes conference wins and conference losses as 60% of those totals, rounding each result. Finally, it inserts these four calculated valueswins, losses, conference wins, and conference lossesinto the matching record in SEASON_STANDINGS.",
    "id": 36,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_team_performance that accepts two input parameters: a numeric parameter p_team_id representing a team's identifier and a string parameter p_season representing a season label. The procedure first declares four local numeric variables: v_total_wins, v_total_losses, v_conf_wins, and v_conf_losses. It then queries the GAMES table to count and assign to v_total_wins the number of rows where the TEAM_ID column equals the input p_team_id, the GAME_OUTCOME column equals the literal string 'win', and the year component extracted from the GAME_DATE column (by converting the string in 'YYYY-MM-DD' format to a date and then extracting the year) matches the year component extracted from the first four characters of the p_season parameter (by converting that substring to a date and extracting the year). Subsequently, it performs a second query on the GAMES table to count and assign to v_total_losses the number of rows where the TEAM_ID column equals p_team_id, the GAME_OUTCOME column equals the literal string 'loss', and the same year-matching condition based on GAME_DATE and p_season is satisfied. Following these counts, the procedure calculates v_conf_wins by multiplying v_total_wins by 0.6 and rounding the result, and calculates v_conf_losses by multiplying v_total_losses by 0.6 and rounding the result. Finally, the procedure updates the SEASON_STANDINGS table, setting the WINS column to v_total_wins, the LOSSES column to v_total_losses, the CONFERENCE_WINS column to v_conf_wins, and the CONFERENCE_LOSSES column to v_conf_losses for any row where the TEAM_ID column matches the input p_team_id and the SEASON column matches the input p_season.",
    "original_summary": "Create a stored procedure named update_team_performance that accepts a team ID (number) and a season label (string). It calculates the team's total wins and losses from the GAMES table for that season, then calculates conference wins and losses as 60% of those totals (rounded). Finally, it updates the SEASON_STANDINGS table with these four calculated values for the matching team and season.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Update the SEASON_STANDINGS table by creating a stored procedure called update_team_performance. This procedure must take a team ID as a number and a season label as a string. For the given team and season, calculate the total wins and losses from the GAMES table. Then, compute the conference wins and losses as 60% of those totals, rounding the results. Finally, insert these four calculated values into the table for the matching record."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateUserStatus that accepts five input parameters: p_user_id, p_status_text, p_status_type, p_created_at, and p_updated_at, all of which are of type VARCHAR2. The procedure performs two main operations. First, it inserts a new record into the USER_STATUS table with the following columns: STATUS_ID, USER_ID, STATUS_TEXT, STATUS_TYPE, CREATED_AT, and UPDATED_AT. The STATUS_ID is determined by selecting the maximum STATUS_ID from the USER_STATUS table, using the NVL function to handle null values by defaulting to 0, and then incrementing by 1 to ensure a unique identifier. The USER_ID, STATUS_TEXT, STATUS_TYPE, CREATED_AT, and UPDATED_AT columns are populated with the values of the corresponding input parameters: p_user_id, p_status_text, p_status_type, p_created_at, and p_updated_at. Second, the procedure deletes records from the USER_ACTIVITY table where the USER_ID matches the p_user_id parameter and the CURRENTLY_ACTIVE column is equal to 0, effectively removing any non-active user activities associated with the specified user.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateUserStatus(\n  p_user_id IN VARCHAR2,\n  p_status_text IN VARCHAR2,\n  p_status_type IN VARCHAR2,\n  p_created_at IN VARCHAR2,\n  p_updated_at IN VARCHAR2\n) AS\nBEGIN\n  INSERT INTO USER_STATUS (STATUS_ID, USER_ID, STATUS_TEXT, STATUS_TYPE, CREATED_AT, UPDATED_AT)\n  VALUES ((SELECT NVL(MAX(STATUS_ID), 0) + 1 FROM USER_STATUS), p_user_id, p_status_text, p_status_type, p_created_at, p_updated_at);\n  \n  DELETE FROM USER_ACTIVITY\n  WHERE USER_ID = p_user_id AND CURRENTLY_ACTIVE = 0;\nEND;",
    "database_name": "user_aas_tracking",
    "tables": [
      "SERVER_INFO",
      "USER_ACTIVITY",
      "USER_SERVER_SYNC",
      "USER_STATUS"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateUserStatus('@spyglass:localhost:8800', 'Active', 'Online', '1570040279284', '1570040284126');\n  commit;\nEND;",
      "BEGIN\n  UpdateUserStatus('@anon-20191002_181700-11:local...', 'Away', 'Idle', '1570040279379', '1570040284217');\n  commit;\nEND;",
      "BEGIN\n  UpdateUserStatus('@spyglass:localhost:8800', 'Busy', 'Do Not Disturb', '1570040310260', '1570040315260');\n  commit;\nEND;",
      "BEGIN\n  UpdateUserStatus('@anon-20191002_181700-11:local...', 'Offline', 'Invisible', '1570040279284', '1570040284126');\n  commit;\nEND;",
      "BEGIN\n  UpdateUserStatus('@spyglass:localhost:8800', 'Available', 'Online', '1570040279379', '1570040284217');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named UpdateUserStatus that, for a given user identified by p_user_id, inserts a new status record into the USER_STATUS table with a new STATUS_ID (generated as the next sequential number), using the provided p_status_text, p_status_type, p_created_at, and p_updated_at, and also deletes any inactive records for that user from the USER_ACTIVITY table where CURRENTLY_ACTIVE is 0.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called UpdateUserStatus that inserts a new record into the USER_STATUS table with an auto-generated STATUS_ID based on the existing maximum, using provided parameters for USER_ID, STATUS_TEXT, STATUS_TYPE, CREATED_AT, and UPDATED_AT, and also removes any inactive records for that user from the USER_ACTIVITY table where CURRENTLY_ACTIVE is 0.",
    "id": 37,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateUserStatus that accepts five input parameters: p_user_id, p_status_text, p_status_type, p_created_at, and p_updated_at, all of which are of type VARCHAR2. The procedure performs two main operations. First, it inserts a new record into the USER_STATUS table with the following columns: STATUS_ID, USER_ID, STATUS_TEXT, STATUS_TYPE, CREATED_AT, and UPDATED_AT. The STATUS_ID is determined by selecting the maximum STATUS_ID from the USER_STATUS table, using the NVL function to handle null values by defaulting to 0, and then incrementing by 1 to ensure a unique identifier. The USER_ID, STATUS_TEXT, STATUS_TYPE, CREATED_AT, and UPDATED_AT columns are populated with the values of the corresponding input parameters: p_user_id, p_status_text, p_status_type, p_created_at, and p_updated_at. Second, the procedure deletes records from the USER_ACTIVITY table where the USER_ID matches the p_user_id parameter and the CURRENTLY_ACTIVE column is equal to 0, effectively removing any non-active user activities associated with the specified user.",
    "original_summary": "Create a stored procedure named UpdateUserStatus that inserts a new status record into USER_STATUS with a generated STATUS_ID and deletes inactive records for the user from USER_ACTIVITY, using the provided parameters for user_id, status_text, status_type, created_at, and updated_at.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure UpdateUserStatus to insert a new USER_STATUS record with a generated STATUS_ID and delete the user's inactive USER_ACTIVITY records. Use parameters: user_id, status_text, status_type, created_at, updated_at."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_new_author that accepts three input parameters: p_name of type VARCHAR2, p_email of type VARCHAR2, and p_nationality of type VARCHAR2. The procedure is designed to insert a new record into the AUTHORS table. It begins by declaring a local variable v_author_id of type NUMBER, which will be used to store the new author's unique identifier. The procedure then executes a SELECT statement to determine the maximum value of the AUTHOR_ID column in the AUTHORS table, using the NVL function to handle cases where the table might be empty by returning 0 if no maximum value is found. This maximum value is incremented by 1 to generate a new unique author ID, which is stored in the v_author_id variable. Following this, the procedure performs an INSERT operation into the AUTHORS table, specifying the columns AUTHOR_ID, AUTHOR_NAME, CONTACT_EMAIL, and NATIONALITY. The values inserted into these columns are v_author_id, p_name, p_email, and p_nationality, respectively, effectively adding a new author record with the provided name, email, and nationality, and the newly generated author ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_author(p_name IN VARCHAR2, p_email IN VARCHAR2, p_nationality IN VARCHAR2)\nIS\n   v_author_id NUMBER;\nBEGIN\n   SELECT NVL(MAX(AUTHOR_ID), 0) + 1 INTO v_author_id FROM AUTHORS;\n   INSERT INTO AUTHORS (AUTHOR_ID, AUTHOR_NAME, CONTACT_EMAIL, NATIONALITY) VALUES (v_author_id, p_name, p_email, p_nationality);\nEND;",
    "database_name": "book_iam_system",
    "tables": [
      "AUTHORS",
      "BOOKS",
      "BOOK_AUTHORS",
      "BOOK_IMAGES",
      "PUBLISHERS"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_author('John Doe', 'johndoe@example.com', 'American');\n  commit;\nEND;",
      "BEGIN\n  insert_new_author('Jane Smith', 'janesmith@example.com', 'British');\n  commit;\nEND;",
      "BEGIN\n  insert_new_author('Carlos Ruiz', 'carlosruiz@example.com', 'Spanish');\n  commit;\nEND;",
      "BEGIN\n  insert_new_author('Akira Tanaka', 'akiratanaka@example.com', 'Japanese');\n  commit;\nEND;",
      "BEGIN\n  insert_new_author('Fatima Khan', 'fatimakhan@example.com', 'Pakistani');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `insert_new_author` that adds a new author to the AUTHORS table by generating a new AUTHOR_ID as one more than the highest existing AUTHOR_ID, then inserting a record with this new ID along with the provided author name, contact email, and nationality.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called insert_new_author that adds a new author to the AUTHORS table by taking the author's name, email, and nationality as inputs, automatically generating a new AUTHOR_ID by incrementing the highest current AUTHOR_ID, and then inserting all the details into the AUTHORS table.",
    "id": 38,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named insert_new_author that accepts three input parameters: p_author_name of type VARCHAR2, p_email of type VARCHAR2, and p_nationality of type VARCHAR2. These parameters represent the author's name, email address, and nationality, respectively. The procedure declares a local variable v_new_author_id of type NUMBER to store the newly generated unique identifier for the author. The procedure first executes a SELECT statement to retrieve the maximum existing value from the author_id column in the AUTHORS table. It uses the NVL function to handle the case where the table is empty, returning 0 if no maximum value exists. It then increments this retrieved maximum value by 1 to generate the next sequential author_id, assigning the result to v_new_author_id. Following this, the procedure performs an INSERT operation into the AUTHORS table. The INSERT statement specifies the columns author_id, author_name, email, and nationality, and inserts the corresponding values: v_new_author_id for author_id, p_author_name for author_name, p_email for email, and p_nationality for nationality. This operation adds a single new row to the AUTHORS table with the provided details and the auto-generated identifier.",
    "original_summary": "Create a stored procedure named `insert_new_author` that inserts a new author into the `AUTHORS` table. It generates a new author ID by incrementing the maximum existing ID, then inserts a record with the new ID and the provided name, email, and nationality.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure `insert_new_author` to add an author. Generate new ID by incrementing max current ID, then insert with provided name, email, nationality."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named analyze_size_performance that accepts a single parameter p_gender of type VARCHAR2, which represents the gender of clothing items to be analyzed. The procedure begins by declaring several local variables: v_total_items, v_small_count, v_medium_count, v_large_count, v_avg_price, v_popular_category, and v_target_size_id, each with specific purposes. v_total_items is a NUMBER variable used to store the total count of clothing items for the specified gender, retrieved using a SELECT COUNT(*) query on the clothing_items table where the gender column matches p_gender. v_small_count, v_medium_count, and v_large_count are NUMBER variables that store the counts of clothing items for the specified gender that fall into small, medium, and large size categories, respectively. These counts are obtained by joining the clothing_items table with the clothing_sizes table on the size_id column and filtering based on the size_label column values ('S', 'XS' for small, 'M' for medium, and 'L', 'XL', 'XXL' for large). v_avg_price is a NUMBER variable that stores the average price of clothing items for the specified gender, calculated using a SELECT AVG(price) query on the clothing_items table. v_popular_category is a VARCHAR2 variable that determines the most popular size category based on the counts of small, medium, and large items, using conditional logic to assign 'SMALL', 'MEDIUM', or 'LARGE' to v_popular_category. The procedure then evaluates several conditions based on v_total_items and v_avg_price: if v_total_items is greater than 200 and v_avg_price exceeds 80, it selects a size_id for medium-sized items from the clothing_sizes table and updates the price of medium-sized clothing items for the specified gender by increasing it by 10%; if v_total_items is between 100 and 200 and v_avg_price is greater than 50, it selects a size_id for large-sized items and increases the stock_quantity of large-sized clothing items for the specified gender by 10; if v_total_items is less than 100 and v_avg_price is below 30, it deletes clothing items for the specified gender with a stock_quantity of 0; otherwise, it inserts a new row into the clothing_sizes table with a size_label of 'UNIVERSAL' and specified waist, hips, and chest measurements. Additionally, if the most popular category is 'SMALL', the procedure updates the shipping_cost in the orders table by reducing it by 10% for orders containing items of the specified gender, identified through a subquery involving the order_items and clothing_items tables.",
    "plsql": "CREATE OR REPLACE PROCEDURE analyze_size_performance(p_gender VARCHAR2) IS\n    v_total_items NUMBER;\n    v_small_count NUMBER;\n    v_medium_count NUMBER;\n    v_large_count NUMBER;\n    v_avg_price NUMBER;\n    v_popular_category VARCHAR2(255);\n    v_target_size_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_items FROM clothing_items WHERE gender = p_gender;\n    SELECT COUNT(*) INTO v_small_count FROM clothing_items ci JOIN clothing_sizes cs ON ci.size_id = cs.size_id WHERE ci.gender = p_gender AND cs.size_label IN ('S', 'XS');\n    SELECT COUNT(*) INTO v_medium_count FROM clothing_items ci JOIN clothing_sizes cs ON ci.size_id = cs.size_id WHERE ci.gender = p_gender AND cs.size_label IN ('M');\n    SELECT COUNT(*) INTO v_large_count FROM clothing_items ci JOIN clothing_sizes cs ON ci.size_id = cs.size_id WHERE ci.gender = p_gender AND cs.size_label IN ('L', 'XL', 'XXL');\n    SELECT AVG(price) INTO v_avg_price FROM clothing_items WHERE gender = p_gender;\n    IF v_small_count > v_medium_count AND v_small_count > v_large_count THEN\n        v_popular_category := 'SMALL';\n    ELSIF v_medium_count > v_small_count AND v_medium_count > v_large_count THEN\n        v_popular_category := 'MEDIUM';\n    ELSE\n        v_popular_category := 'LARGE';\n    END IF;\n    IF v_total_items > 200 AND v_avg_price > 80 THEN\n        SELECT size_id INTO v_target_size_id FROM clothing_sizes WHERE size_label = 'M' AND ROWNUM = 1;\n        UPDATE clothing_items SET price = price * 1.1 WHERE gender = p_gender AND size_id = v_target_size_id;\n    ELSIF v_total_items BETWEEN 100 AND 200 AND v_avg_price > 50 THEN\n        SELECT size_id INTO v_target_size_id FROM clothing_sizes WHERE size_label = 'L' AND ROWNUM = 1;\n        UPDATE clothing_items SET stock_quantity = stock_quantity + 10 WHERE gender = p_gender AND size_id = v_target_size_id;\n    ELSIF v_total_items < 100 AND v_avg_price < 30 THEN\n        DELETE FROM clothing_items WHERE gender = p_gender AND stock_quantity = 0;\n    ELSE\n        INSERT INTO clothing_sizes (size_id, size_label, waist, hips, chest)\n        VALUES ((SELECT NVL(MAX(size_id), 0) + 1 FROM clothing_sizes), 'UNIVERSAL', 40, 42, 44);\n    END IF;\n    IF v_popular_category = 'SMALL' THEN\n        UPDATE orders SET shipping_cost = shipping_cost * 0.9 WHERE order_id IN (SELECT order_id FROM order_items WHERE item_id IN (SELECT item_id FROM clothing_items WHERE gender = p_gender));\n    END IF;\nEND;",
    "database_name": "clothing_ssaim_966781",
    "tables": [
      "CLOTHING_ITEMS",
      "CLOTHING_SIZES",
      "STYLES",
      "ORDERS",
      "ORDER_ITEMS",
      "RETURNS"
    ],
    "call_sqls": [
      "BEGIN\n  analyze_size_performance('Male');\n  commit;\nEND;",
      "BEGIN\n  analyze_size_performance('Female');\n  commit;\nEND;",
      "BEGIN\n  analyze_size_performance('Unisex');\n  commit;\nEND;",
      "BEGIN\n  analyze_size_performance('Kids');\n  commit;\nEND;",
      "BEGIN\n  analyze_size_performance('Non-binary');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named analyze_size_performance that accepts a gender parameter to analyze clothing performance for that gender. It calculates the total item count from the clothing_items table, counts items by size category (small for 'S' and 'XS', medium for 'M', and large for 'L', 'XL', and 'XXL' from clothing_sizes), and the average price. It determines the most popular size category based on these counts. Based on thresholds for total items and average price, it performs one of four actions: if total items exceed 200 and average price exceeds 80, it increases prices by 10% for medium-sized items; if total items are between 100 and 200 and average price exceeds 50, it adds 10 to the stock_quantity for large-sized items; if total items are below 100 and average price is below 30, it deletes out-of-stock items (where stock_quantity is 0); otherwise, it inserts a new universal size into the clothing_sizes table. Additionally, if the most popular category is 'SMALL', it reduces shipping costs by 10% in the orders table for orders containing items of the specified gender.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called analyze_size_performance that receives a gender as input. For the given gender, it must calculate the total number of items, count items grouped into small, medium, and large size categories, and compute the average price. It then identifies which size category is the most popular. Based on thresholds for total item count and average price, the procedure should perform one of four actions: increase prices for medium-sized items, add stock to large items, delete out-of-stock items, or insert a new universal size record into the clothing_sizes table. Additionally, if the most popular category is 'SMALL', reduce shipping costs for related orders.",
    "id": 39,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named analyze_size_performance that accepts a single parameter p_gender of type VARCHAR2, which represents the gender of clothing items to be analyzed. The procedure begins by declaring several local variables: v_total_items, v_small_count, v_medium_count, v_large_count, v_avg_price, v_popular_category, and v_target_size_id, each with specific purposes. v_total_items is a NUMBER variable used to store the total count of clothing items for the specified gender, retrieved using a SELECT COUNT(*) query on the clothing_items table where the gender column matches p_gender. v_small_count, v_medium_count, and v_large_count are NUMBER variables that store the counts of clothing items for the specified gender that fall into small, medium, and large size categories, respectively. These counts are obtained by joining the clothing_items table with the clothing_sizes table on the size_id column and filtering based on the size_label column values ('S', 'XS' for small, 'M' for medium, and 'L', 'XL', 'XXL' for large). v_avg_price is a NUMBER variable that stores the average price of clothing items for the specified gender, calculated using a SELECT AVG(price) query on the clothing_items table. v_popular_category is a VARCHAR2 variable that determines the most popular size category based on the counts of small, medium, and large items, using conditional logic to assign 'SMALL', 'MEDIUM', or 'LARGE' to v_popular_category. The procedure then evaluates several conditions based on v_total_items and v_avg_price: if v_total_items is greater than 200 and v_avg_price exceeds 80, it selects a size_id for medium-sized items from the clothing_sizes table and updates the price of medium-sized clothing items for the specified gender by increasing it by 10%; if v_total_items is between 100 and 200 and v_avg_price is greater than 50, it selects a size_id for large-sized items and increases the stock_quantity of large-sized clothing items for the specified gender by 10; if v_total_items is less than 100 and v_avg_price is below 30, it deletes clothing items for the specified gender with a stock_quantity of 0; otherwise, it inserts a new row into the clothing_sizes table with a size_label of 'UNIVERSAL' and specified waist, hips, and chest measurements. Additionally, if the most popular category is 'SMALL', the procedure updates the shipping_cost in the orders table by reducing it by 10% for orders containing items of the specified gender, identified through a subquery involving the order_items and clothing_items tables.",
    "original_summary": "Create a stored procedure named analyze_size_performance that accepts a gender parameter. Calculate total item count, counts by size category (small, medium, large), and average price for that gender. Determine the most popular size category. Based on total items and average price thresholds, perform different operations: update prices for medium items, update stock for large items, delete out-of-stock items, or insert a new universal size. If the most popular category is 'SMALL', also reduce shipping costs for related orders.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Compose a stored procedure designated as 'analyze_size_performance' that receives a gender as an input parameter. The procedure shall compute the aggregate quantity of items, enumerate items according to size classifications (small, medium, large), and derive the mean price for the specified gender. Subsequently, it must identify the size category with the highest frequency. Depending on predefined thresholds for total item count and average price, execute one of several distinct operations: adjust pricing for medium-sized items, modify stock levels for large items, remove items that are out of stock, or insert a new universal size record. Furthermore, if the predominant size category is determined to be 'SMALL', implement a reduction in shipping costs for associated orders."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `AddTeamMember` that accepts four input parameters: `p_team_id` of type `NUMBER`, intended to represent the unique identifier of a research team; `p_user_id` of type `NUMBER`, intended to represent the unique identifier of a user; `p_role` of type `VARCHAR2`, intended to specify the role of the user within the team; and `p_description` of type `VARCHAR2`, intended to provide additional details about the team member's role or responsibilities. The procedure begins by declaring three local variables: `v_member_id` of type `NUMBER`, which will store the newly generated unique identifier for the team member; `v_team_exists` of type `NUMBER`, which will temporarily hold a count indicating whether the provided `p_team_id` corresponds to an existing team; and `v_user_exists` of type `NUMBER`, which will temporarily hold a count indicating whether the provided `p_user_id` corresponds to an existing user. The procedure then executes a `SELECT COUNT(*)` statement to query the `RESEARCH_TEAMS` table, counting the number of rows where the `TEAM_ID` column matches the input parameter `p_team_id`, and stores this count into the `v_team_exists` variable. Following this, an `IF` conditional statement checks if the value of `v_team_exists` is equal to `0`. If this condition is true, indicating that no team with the specified `p_team_id` was found in the `RESEARCH_TEAMS` table, the procedure raises an application error with the error code `-20001` and a descriptive error message concatenating the string 'Team ID ', the value of `p_team_id`, and the string ' does not exist in RESEARCH_TEAMS.'. Subsequently, the procedure executes another `SELECT COUNT(*)` statement to query the `USERS` table, counting the number of rows where the `USER_ID` column matches the input parameter `p_user_id`, and stores this count into the `v_user_exists` variable. Another `IF` conditional statement then checks if the value of `v_user_exists` is equal to `0`. If this condition is true, indicating that no user with the specified `p_user_id` was found in the `USERS` table, the procedure raises an application error with the error code `-20002` and a descriptive error message concatenating the string 'User ID ', the value of `p_user_id`, and the string ' does not exist in USERS.'. After these validation checks, the procedure executes a `SELECT` statement to determine the next available `MEMBER_ID` for the `TEAM_MEMBERS` table. This is achieved by selecting the maximum value from the `MEMBER_ID` column in the `TEAM_MEMBERS` table, applying the `NVL` function to treat a `NULL` result (which would occur if the table is empty) as `0`, and then adding `1` to this result. The calculated next `MEMBER_ID` is stored in the `v_member_id` variable. Finally, the procedure performs an `INSERT` operation into the `TEAM_MEMBERS` table, populating the `MEMBER_ID` column with the value from `v_member_id`, the `TEAM_ID` column with the value from `p_team_id`, the `USER_ID` column with the value from `p_user_id`, the `ROLE` column with the value from `p_role`, and the `DESCRIPTION` column with the value from `p_description`.",
    "plsql": "CREATE OR REPLACE PROCEDURE AddTeamMember(\n    p_team_id NUMBER,\n    p_user_id NUMBER,\n    p_role VARCHAR2,\n    p_description VARCHAR2\n) AS\n    v_member_id NUMBER;\n    v_team_exists NUMBER;\n    v_user_exists NUMBER;\nBEGIN\n    -- Check if p_team_id exists in RESEARCH_TEAMS\n    SELECT COUNT(*) INTO v_team_exists FROM RESEARCH_TEAMS WHERE TEAM_ID = p_team_id;\n    IF v_team_exists = 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Team ID ' || p_team_id || ' does not exist in RESEARCH_TEAMS.');\n    END IF;\n\n    -- Check if p_user_id exists in USERS\n    SELECT COUNT(*) INTO v_user_exists FROM USERS WHERE USER_ID = p_user_id;\n    IF v_user_exists = 0 THEN\n        RAISE_APPLICATION_ERROR(-20002, 'User ID ' || p_user_id || ' does not exist in USERS.');\n    END IF;\n\n    SELECT NVL(MAX(MEMBER_ID), 0) + 1 INTO v_member_id FROM TEAM_MEMBERS;\n    INSERT INTO TEAM_MEMBERS (MEMBER_ID, TEAM_ID, USER_ID, ROLE, DESCRIPTION)\n    VALUES (v_member_id, p_team_id, p_user_id, p_role, p_description);\nEND;",
    "database_name": "global_hawbi_549073",
    "tables": [
      "USERS",
      "RESEARCH_TEAMS",
      "TEAM_MEMBERS",
      "TEAM_ACCESS",
      "ACCESS_LOGS",
      "UPDATES"
    ],
    "call_sqls": [
      "BEGIN\n  AddTeamMember(0, 1, 'researcher', 'Researcher on the happiness research team');\n  commit;\nEND;",
      "BEGIN\n  AddTeamMember(1, 1, 'data analyst', 'Data analyst on the well-being analytics team');\n  commit;\nEND;",
      "BEGIN\n  AddTeamMember(0, 0, 'lead researcher', 'Lead researcher on the happiness research team');\n  commit;\nEND;",
      "BEGIN\n  AddTeamMember(1, 0, 'assistant', 'Assistant on the well-being analytics team');\n  commit;\nEND;",
      "BEGIN\n  AddTeamMember(0, 1, 'consultant', 'Consultant for the happiness research team');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named AddTeamMember that adds a new member to the TEAM_MEMBERS table by accepting a team ID, a user ID, a role, and a description, ensuring the provided team ID exists in the RESEARCH_TEAMS table and the user ID exists in the USERS table, raising specific errors if they do not, and automatically generating a new sequential MEMBER_ID for the insertion.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called AddTeamMember that inserts a new member into the TEAM_MEMBERS table, automatically generating the MEMBER_ID. It should accept a team ID, user ID, role, and description, validate that the team ID exists in the RESEARCH_TEAMS table and the user ID exists in the USERS table, and raise an error if either is missing.",
    "id": 40,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named AddTeamMember that accepts four input parameters: a number p_team_id, a number p_user_id, a string p_role, and a string p_description. The procedure first declares a local variable v_member_id of type NUMBER, a local variable v_team_count of type NUMBER, and a local variable v_user_count of type NUMBER. The procedure's execution block begins by performing a validation check: it selects the COUNT of rows from the RESEARCH_TEAMS table where the team_id column equals the p_team_id parameter into the v_team_count variable. It then checks if v_team_count is equal to zero; if true, it raises a user-defined exception with an error message indicating that the team ID does not exist. If the team ID exists, it proceeds to perform a second validation check: it selects the COUNT of rows from the USERS table where the user_id column equals the p_user_id parameter into the v_user_count variable. It then checks if v_user_count is equal to zero; if true, it raises a user-defined exception with an error message indicating that the user ID does not exist. If both validations pass, it generates a new member ID by selecting the maximum value of the member_id column from the TEAM_MEMBERS table, adding one to it, and storing the result in the v_member_id variable, handling the case where the table is empty by using the NVL function to default to 1. Finally, it executes an INSERT statement into the TEAM_MEMBERS table, specifying values for the columns member_id as v_member_id, team_id as p_team_id, user_id as p_user_id, role as p_role, description as p_description, and created_at as the current system date and time using the SYSDATE function.",
    "original_summary": "Create a stored procedure named AddTeamMember that inserts a new member into the TEAM_MEMBERS table. It accepts a team ID, user ID, role (VARCHAR2), and description (VARCHAR2). Validate that the team ID exists in the RESEARCH_TEAMS table and the user ID exists in the USERS table, raising specific application errors if not. Generate a new sequential MEMBER_ID for the insert.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create AddTeamMember procedure to insert into TEAM_MEMBERS. Accept team ID, user ID, role, description. Validate team ID in RESEARCH_TEAMS and user ID in USERS, raise errors if missing. Auto-generate MEMBER_ID."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_physical_activity that accepts two input parameters: a numeric parameter named para_bmi_threshold and a string parameter named para_activity_level of type VARCHAR2, and executes an UPDATE operation on the PATIENTS table, specifically setting the PHYSICAL_ACTIVITY_LEVEL column for qualifying rows to the value provided in the para_activity_level parameter, where the qualification for a row update is determined by a subquery that selects PATIENT_ID values from the HEALTH_METRICS table, including only those rows where the BMI column value is strictly greater than the numeric value supplied in the para_bmi_threshold parameter, thereby updating the physical activity level in the PATIENTS table for all patients whose associated body mass index recorded in the HEALTH_METRICS table exceeds the specified threshold.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_physical_activity(para_bmi_threshold NUMBER, para_activity_level VARCHAR2) IS\nBEGIN\n  UPDATE PATIENTS\n  SET PHYSICAL_ACTIVITY_LEVEL = para_activity_level\n  WHERE PATIENT_ID IN (\n    SELECT PATIENT_ID FROM HEALTH_METRICS\n    WHERE BMI > para_bmi_threshold\n  );\nEND;",
    "database_name": "healthcare_dmadr_assessme",
    "tables": [
      "DIABETES_RISK_SCORES",
      "HEALTH_METRICS",
      "PATIENTS",
      "STUDY_PARTICIPANTS"
    ],
    "call_sqls": [
      "BEGIN\n  update_physical_activity(para_bmi_threshold => 25, para_activity_level => 'high');\nEND;",
      "BEGIN\n  update_physical_activity(para_bmi_threshold => 30, para_activity_level => 'moderate');\nEND;",
      "BEGIN\n  update_physical_activity(para_bmi_threshold => 20, para_activity_level => 'low');\nEND;",
      "BEGIN\n  update_physical_activity(para_bmi_threshold => 35, para_activity_level => 'very high');\nEND;",
      "BEGIN\n  update_physical_activity(para_bmi_threshold => 28, para_activity_level => 'sedentary');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_physical_activity that, given a BMI threshold and a new activity level, updates the PHYSICAL_ACTIVITY_LEVEL in the PATIENTS table for all patients whose PATIENT_ID is found in the HEALTH_METRICS table with a BMI greater than the provided threshold.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_physical_activity that updates the PHYSICAL_ACTIVITY_LEVEL in the PATIENTS table for patients whose ID exists in the HEALTH_METRICS table with a BMI above a provided numeric threshold, setting it to a specified string activity level.",
    "id": 41,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_physical_activity that accepts two input parameters: a numeric parameter named para_bmi_threshold and a string parameter named para_activity_level of type VARCHAR2, and executes an UPDATE operation on the PATIENTS table, specifically setting the PHYSICAL_ACTIVITY_LEVEL column for qualifying rows to the value provided in the para_activity_level parameter, where the qualification for a row update is determined by a subquery that selects PATIENT_ID values from the HEALTH_METRICS table, including only those rows where the BMI column value is strictly greater than the numeric value supplied in the para_bmi_threshold parameter, thereby updating the physical activity level in the PATIENTS table for all patients whose associated body mass index recorded in the HEALTH_METRICS table exceeds the specified threshold.",
    "original_summary": "Create a stored procedure named update_physical_activity that accepts a numeric para_bmi_threshold and a string para_activity_level. Update the PATIENTS table, setting PHYSICAL_ACTIVITY_LEVEL to para_activity_level for patients whose PATIENT_ID exists in the HEALTH_METRICS table with a BMI greater than para_bmi_threshold.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure called update_physical_activity that takes a numeric parameter for BMI threshold and a string parameter for activity level to update the PHYSICAL_ACTIVITY_LEVEL in the PATIENTS table for those patients whose ID is found in the HEALTH_METRICS table with a BMI exceeding the given threshold?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_happiness_scores` that accepts three input parameters: `p_year` of type `NUMBER`, representing the specific year for which happiness scores are being considered; `p_region` of type `NUMBER`, representing the geographical region to filter the scores; and `p_min_score` of type `NUMBER`, representing the minimum happiness score threshold. The procedure begins by initiating a `FOR` loop that iterates over a result set obtained from a `SELECT` statement. This `SELECT` statement queries the `happiness_scores` table, aliased as `hs`, to retrieve the `score_id` and `happiness_score` columns. The rows are filtered based on three conditions: `hs.year_id` must be equal to the value provided in the `p_year` parameter, `hs.region_id` must be equal to the value provided in the `p_region` parameter, and `hs.happiness_score` must be strictly greater than the value provided in the `p_min_score` parameter. For each record (`rec`) returned by this `SELECT` statement, the procedure executes an `INSERT` statement into the `predictions` table. The `prediction_id` column for the new row is determined by a subquery that calculates `NVL(MAX(prediction_id), 0) + 1` from the `predictions` table, effectively generating a new sequential ID. The `score_id` column is populated with the `score_id` from the current record (`rec.score_id`). The `predicted_happiness_score` column is set to the `happiness_score` from the current record (`rec.happiness_score`) multiplied by `1.05`. The `prediction_year` column is set to the value of `p_year` incremented by `1`. The `model_used` column is assigned the static string literal `'Projection Model'`. Finally, the `confidence_interval` column is set to the numeric literal `0.1`. This `INSERT` operation is performed for every record that satisfies the filtering criteria in the initial `SELECT` statement, and the loop continues until all such records have been processed.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_happiness_scores(\n    p_year IN NUMBER,\n    p_region IN NUMBER,\n    p_min_score IN NUMBER\n)\nIS\nBEGIN\n    FOR rec IN (\n        SELECT hs.score_id, hs.happiness_score\n        FROM happiness_scores hs\n        WHERE hs.year_id = p_year\n        AND hs.region_id = p_region\n        AND hs.happiness_score > p_min_score\n    ) LOOP\n        INSERT INTO predictions (prediction_id, score_id, predicted_happiness_score, prediction_year, model_used, confidence_interval)\n        VALUES (\n            (SELECT NVL(MAX(prediction_id), 0) + 1 FROM predictions),\n            rec.score_id,\n            rec.happiness_score * 1.05,\n            p_year + 1,\n            'Projection Model',\n            0.1\n        );\n    END LOOP;\nEND;",
    "database_name": "global_haqol_metrics",
    "tables": [
      "ACCESS_LOGS",
      "HAPPINESS_SCORES",
      "COUNTRIES",
      "REGIONS",
      "YEARS",
      "PREDICTIONS",
      "USERS",
      "REPORTS"
    ],
    "call_sqls": [
      "BEGIN\n  update_happiness_scores(p_year => 0, p_region => 0, p_min_score => 7.0);\nEND;",
      "BEGIN\n  update_happiness_scores(p_year => 1, p_region => 1, p_min_score => 7.5);\nEND;",
      "BEGIN\n  update_happiness_scores(p_year => 0, p_region => 1, p_min_score => 6.5);\nEND;",
      "BEGIN\n  update_happiness_scores(p_year => 1, p_region => 0, p_min_score => 7.2);\nEND;",
      "BEGIN\n  update_happiness_scores(p_year => 0, p_region => 0, p_min_score => 7.58);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_happiness_scores that, for a given year, region, and minimum happiness score, creates new prediction records in the predictions table. For each existing record in the happiness_scores table where the year_id matches the input year, the region_id matches the input region, and the happiness_score is above the provided minimum, insert a new prediction. Each new prediction should have a unique sequential prediction_id, use the original score_id, set the predicted_happiness_score to 5% higher than the original happiness_score, set the prediction_year to the year after the input year, use 'Projection Model' as the model_used, and set the confidence_interval to 0.1.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called `update_happiness_scores` that, for a given year, region, and minimum happiness score, creates new predictions in the PREDICTIONS table for all records in the HAPPINESS_SCORES table where the year and region match and the happiness score exceeds the specified minimum. Each new prediction should have a unique sequential prediction ID, reference the original score_id from HAPPINESS_SCORES, calculate a predicted happiness score that is 5% higher than the original, set the prediction year to the next year, assign the model name as 'Projection Model', and use a fixed confidence interval of 0.1.",
    "id": 42,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `update_happiness_scores` that accepts three input parameters: `p_year` of type `NUMBER`, representing the specific year for which happiness scores are being considered; `p_region` of type `NUMBER`, representing the geographical region to filter the scores; and `p_min_score` of type `NUMBER`, representing the minimum happiness score threshold. The procedure begins by initiating a `FOR` loop that iterates over a result set obtained from a `SELECT` statement. This `SELECT` statement queries the `happiness_scores` table, aliased as `hs`, to retrieve the `score_id` and `happiness_score` columns. The rows are filtered based on three conditions: `hs.year_id` must be equal to the value provided in the `p_year` parameter, `hs.region_id` must be equal to the value provided in the `p_region` parameter, and `hs.happiness_score` must be strictly greater than the value provided in the `p_min_score` parameter. For each record (`rec`) returned by this `SELECT` statement, the procedure executes an `INSERT` statement into the `predictions` table. The `prediction_id` column for the new row is determined by a subquery that calculates `NVL(MAX(prediction_id), 0) + 1` from the `predictions` table, effectively generating a new sequential ID. The `score_id` column is populated with the `score_id` from the current record (`rec.score_id`). The `predicted_happiness_score` column is set to the `happiness_score` from the current record (`rec.happiness_score`) multiplied by `1.05`. The `prediction_year` column is set to the value of `p_year` incremented by `1`. The `model_used` column is assigned the static string literal `'Projection Model'`. Finally, the `confidence_interval` column is set to the numeric literal `0.1`. This `INSERT` operation is performed for every record that satisfies the filtering criteria in the initial `SELECT` statement, and the loop continues until all such records have been processed.",
    "original_summary": "Create a stored procedure named `update_happiness_scores` that accepts a year, region, and minimum score. For each record in the happiness_scores table matching the given year and region with a score above the threshold, insert a new prediction. The new prediction uses a generated sequential ID, the original score_id, a predicted score increased by 5%, the next year, a fixed model name, and a fixed confidence interval.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a procedure `update_happiness_scores` that takes a year, region, and min score. For matching records with a higher score, insert a new prediction with a sequential ID, the original score_id, a 5% higher predicted score for the next year, a set model name, and a fixed confidence."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `insert_patient_observation` that accepts five input parameters: `p_patient_id` of type `NUMBER`, `p_observation_date` of type `VARCHAR2`, `p_observation_type` of type `VARCHAR2`, `p_observation_value` of type `VARCHAR2`, and `p_observation_notes` of type `VARCHAR2`. The purpose of this procedure is to record a new clinical observation for a patient, ensuring that a patient record exists before inserting the observation.\n\nThe procedure begins by declaring two local variables: `v_patient_exists` of type `NUMBER` to store the count of existing patient records, and `v_observation_id` of type `NUMBER` to store the newly generated observation identifier.\n\nFirst, the procedure executes a `SELECT` statement to determine if a patient with the provided `p_patient_id` already exists in the `PATIENTS` table. It counts the number of rows in the `PATIENTS` table where the `PATIENT_ID` column matches the value of `p_patient_id`, and stores this count into the `v_patient_exists` variable.\n\nNext, a conditional `IF` statement checks the value of `v_patient_exists`. If `v_patient_exists` is equal to `0`, meaning no patient with the given `p_patient_id` was found, the procedure proceeds to insert a new, default patient record into the `PATIENTS` table. This `INSERT` statement populates the `PATIENTS` table with the following values: `PATIENT_ID` is set to `p_patient_id`, `FIRST_NAME` is set to the literal string 'Unknown', `LAST_NAME` is set to the literal string 'Patient', `DATE_OF_BIRTH` is set to the literal string '1900-01-01', `GENDER` is set to the literal string 'Unknown', `CREATED_AT` is set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`, and `UPDATED_AT` is also set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`.\n\nAfter ensuring the patient record exists (either by finding an existing one or creating a default one), the procedure then generates a new unique identifier for the observation. It executes a `SELECT` statement to find the maximum value of the `OBSERVATION_ID` column from the `CLINICAL_OBSERVATIONS` table. The `NVL` function is used to handle cases where the table might be empty, returning `0` if `MAX(OBSERVATION_ID)` is `NULL`. This result is then incremented by `1` and stored in the `v_observation_id` variable.\n\nFinally, the procedure inserts the new clinical observation record into the `CLINICAL_OBSERVATIONS` table. This `INSERT` statement populates the `CLINICAL_OBSERVATIONS` table with the following values: `OBSERVATION_ID` is set to the generated `v_observation_id`, `PATIENT_ID` is set to `p_patient_id`, `OBSERVATION_DATE` is set to `p_observation_date`, `OBSERVATION_TYPE` is set to `p_observation_type`, `OBSERVATION_VALUE` is set to `p_observation_value`, `OBSERVATION_NOTES` is set to `p_observation_notes`, `CREATED_AT` is set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`, and `UPDATED_AT` is also set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_patient_observation(\n    p_patient_id IN NUMBER,\n    p_observation_date IN VARCHAR2,\n    p_observation_type IN VARCHAR2,\n    p_observation_value IN VARCHAR2,\n    p_observation_notes IN VARCHAR2\n) IS\n    v_patient_exists NUMBER;\n    v_observation_id NUMBER;\nBEGIN\n    -- Check if patient exists\n    SELECT COUNT(*)\n    INTO v_patient_exists\n    FROM PATIENTS\n    WHERE PATIENT_ID = p_patient_id;\n    \n    -- If patient doesn't exist, create a default patient record\n    IF v_patient_exists = 0 THEN\n        INSERT INTO PATIENTS (\n            PATIENT_ID,\n            FIRST_NAME,\n            LAST_NAME,\n            DATE_OF_BIRTH,\n            GENDER,\n            CREATED_AT,\n            UPDATED_AT\n        ) VALUES (\n            p_patient_id,\n            'Unknown',\n            'Patient',\n            '1900-01-01',\n            'Unknown',\n            TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'),\n            TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n        );\n    END IF;\n    \n    -- Generate new observation ID\n    SELECT NVL(MAX(OBSERVATION_ID), 0) + 1\n    INTO v_observation_id\n    FROM CLINICAL_OBSERVATIONS;\n    \n    -- Insert the observation\n    INSERT INTO CLINICAL_OBSERVATIONS (\n        OBSERVATION_ID,\n        PATIENT_ID,\n        OBSERVATION_DATE,\n        OBSERVATION_TYPE,\n        OBSERVATION_VALUE,\n        OBSERVATION_NOTES,\n        CREATED_AT,\n        UPDATED_AT\n    ) VALUES (\n        v_observation_id,\n        p_patient_id,\n        p_observation_date,\n        p_observation_type,\n        p_observation_value,\n        p_observation_notes,\n        TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'),\n        TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n    );\nEND;",
    "database_name": "medical_daph_monitoring",
    "tables": [
      "PATIENTS",
      "CLINICAL_OBSERVATIONS",
      "DIAGNOSES",
      "HEALTH_MONITORING",
      "LAB_TESTS",
      "PATIENT_ALLERGIES",
      "PATIENT_MEDICATIONS",
      "TREATMENTS"
    ],
    "call_sqls": [
      "BEGIN\n  insert_patient_observation(101, '2023-10-26', 'Blood Pressure', '120/80', 'Patient reported feeling well.');\nEND;",
      "BEGIN\n  insert_patient_observation(102, '2023-10-26', 'Temperature', '98.6 F', 'Normal body temperature.');\nEND;",
      "BEGIN\n  insert_patient_observation(103, '2023-10-27', 'Weight', '155 lbs', 'Patient is maintaining weight.');\nEND;",
      "BEGIN\n  insert_patient_observation(104, '2023-10-27', 'Heart Rate', '72 bpm', 'Resting heart rate.');\nEND;",
      "BEGIN\n  insert_patient_observation(105, '2023-10-28', 'Glucose Level', '95 mg/dL', 'Fasting glucose within normal limits.');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named insert_patient_observation that accepts a patient ID, an observation date, an observation type, an observation value, and observation notes. First, verify if the patient exists in the PATIENTS table using the provided patient ID; if not, insert a default patient record into PATIENTS with the given ID and placeholder details. Then, generate a new observation ID by taking the maximum existing OBSERVATION_ID from the CLINICAL_OBSERVATIONS table and adding one, or starting at 1 if none exist. Finally, insert a new observation into the CLINICAL_OBSERVATIONS table with the generated ID, the provided patient ID, observation date, type, value, and notes, along with current timestamps for creation and update.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL stored procedure called 'insert_patient_observation'? It needs to take in a patient ID (that's a number), plus the observation date, type, value, and notes (all as text). First off, it's gotta check if that patient's already in the PATIENTS table. If they're not, just pop in a basic patient record into PATIENTS with default values for FIRST_NAME, LAST_NAME, DATE_OF_BIRTH, GENDER, CREATED_AT, and UPDATED_AT. Then, figure out the next observation ID by adding 1 to the biggest OBSERVATION_ID in the CLINICAL_OBSERVATIONS table, or start at 1 if the table's empty. Finally, toss this new observation into the CLINICAL_OBSERVATIONS table with OBSERVATION_ID, PATIENT_ID, OBSERVATION_DATE, OBSERVATION_TYPE, OBSERVATION_VALUE, OBSERVATION_NOTES, CREATED_AT, and UPDATED_AT, making sure to stamp CREATED_AT and UPDATED_AT with the current date and time.",
    "id": 43,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `insert_patient_observation` that operates within the `medical_daph_monitoring` database. The procedure accepts five input parameters: `p_patient_id` of data type `NUMBER`, `p_observation_date` of data type `VARCHAR2`, `p_observation_type` of data type `VARCHAR2`, `p_observation_value` of data type `VARCHAR2`, and `p_observation_notes` of data type `VARCHAR2`. The purpose of `p_patient_id` is to provide the unique identifier for a patient. The purpose of `p_observation_date` is to provide the date of the observation. The purpose of `p_observation_type` is to provide the category or type of the observation. The purpose of `p_observation_value` is to provide the measured or recorded value of the observation. The purpose of `p_observation_notes` is to provide any additional textual notes related to the observation.\n\nThe procedure begins by checking for the existence of the patient in the `PATIENTS` table. It executes a `SELECT` statement that queries the `PATIENTS` table and counts the number of rows where the `PATIENT_ID` column matches the value provided by the `p_patient_id` input parameter. The result of this count is stored into a local variable, for example `v_patient_count`.\n\nNext, the procedure uses a conditional statement to evaluate the value of `v_patient_count`. If `v_patient_count` equals `0`, indicating the patient does not exist in the `PATIENTS` table, the procedure executes an `INSERT` operation. This `INSERT` operation adds a new row into the `PATIENTS` table. For this new row, the value for the `PATIENT_ID` column is set to the value provided by the `p_patient_id` input parameter. The values for the `FIRST_NAME` and `LAST_NAME` columns are set to the string literal `'UNKNOWN'`. The value for the `DATE_OF_BIRTH` column is set to the date literal `'01-JAN-1900'`. The value for the `GENDER` column is set to the string literal `'U'`. The values for the `CREATED_AT` and `UPDATED_AT` columns are both set to the current system date and time, obtained by calling the `SYSDATE` function.\n\nFollowing the patient existence check and potential insertion, the procedure determines the next available observation identifier. It executes a `SELECT` statement that queries the `CLINICAL_OBSERVATIONS` table. This statement uses the `NVL` and `MAX` functions to find the maximum value in the `OBSERVATION_ID` column. If the `MAX` function returns a non-null value (indicating the table is not empty), the `NVL` function returns that maximum value; if the `MAX` function returns `NULL` (indicating the table is empty), the `NVL` function returns the numeric literal `0`. The procedure then adds `1` to this result to calculate the next sequential `OBSERVATION_ID`. This calculated value is stored into a local variable, for example `v_next_observation_id`.\n\nFinally, the procedure executes an `INSERT` operation to add the new observation record. This `INSERT` operation targets the `CLINICAL_OBSERVATIONS` table. For the new row, the value for the `OBSERVATION_ID` column is set to the value stored in `v_next_observation_id`. The value for the `PATIENT_ID` column is set to the value provided by the `p_patient_id` input parameter. The value for the `OBSERVATION_DATE` column is set to the value provided by the `p_observation_date` input parameter. The value for the `OBSERVATION_TYPE` column is set to the value provided by the `p_observation_type` input parameter. The value for the `OBSERVATION_VALUE` column is set to the value provided by the `p_observation_value` input parameter. The value for the `OBSERVATION_NOTES` column is set to the value provided by the `p_observation_notes` input parameter. The values for both the `CREATED_AT` and `UPDATED_AT` columns are set to the current system date and time, obtained by calling the `SYSDATE` function.",
    "original_summary": "Create a stored procedure named insert_patient_observation that accepts patient ID, observation date, type, value, and notes (all VARCHAR2 except ID is NUMBER). First, check if the patient exists. If not, insert a default patient record. Then, generate a new observation ID (max ID + 1, or 1 if empty) and insert the observation into the CLINICAL_OBSERVATIONS table with current timestamps.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called 'insert_patient_observation'? It needs to take in a patient ID (that's a number), plus the observation date, type, value, and notes (all as text). First off, it's gotta check if that patient's already in the system. If they're not, just pop in a basic patient record. Then, figure out the next observation ID by adding 1 to the biggest one we've got, or start at 1 if the table's empty. Finally, toss this new observation into the CLINICAL_OBSERVATIONS table, making sure to stamp it with the current date and time."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts three input parameters: `para_sale_price` of type `NUMBER`, `para_buyer_name` of type `VARCHAR2`, and `para_property_id` of type `NUMBER`. The purpose of this procedure is to record a new property sale and update the ownership information for the sold property.\n\nUpon execution, the procedure first declares three local variables: `v_days_on_market` of type `NUMBER`, `v_sale_id` of type `NUMBER`, and `v_owner_count` of type `NUMBER`.\n\nThe procedure then proceeds with the following steps:\n1. It generates a pseudo-random `SALE_ID` by assigning a value to `v_sale_id`. This value is obtained by taking the `FLOOR` of a random number generated between 1000 and 9999 (inclusive) using `DBMS_RANDOM.VALUE(1000, 9999)`.\n2. It calculates the `DAYS_ON_MARKET` by assigning a value to `v_days_on_market`. This value is derived by taking the absolute value (`ABS`) of the remainder (`MOD`) when `v_sale_id` is divided by 90, and then adding 10 to the result.\n3. It inserts a new record into the `SALES` table. The `SALE_ID` column is populated with the generated `v_sale_id`. The `PROPERTY_ID` column is populated with the value from the `para_property_id` input parameter. The `SALE_PRICE` column is populated with the value from the `para_sale_price` input parameter. The `BUYER_NAME` column is populated with the value from the `para_buyer_name` input parameter. The `SALE_DATE` column is populated with the current timestamp formatted as 'YYYY-MM-DD' using `TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD')`. The `DAYS_ON_MARKET` column is populated with the calculated `v_days_on_market`.\n4. It then checks for the existence of an owner for the property identified by `para_property_id`. This is done by executing a `SELECT COUNT(*)` statement on the `OWNERS` table, filtering records where the `PROPERTY_ID` column matches the `para_property_id` input parameter. The count of matching records is stored in the `v_owner_count` local variable.\n5. Following this, a conditional statement (`IF v_owner_count > 0 THEN`) evaluates the `v_owner_count`.\n   - If `v_owner_count` is greater than 0 (meaning an owner record exists for the given `PROPERTY_ID`), the procedure updates the `OWNERS` table. Specifically, it sets the `OWNER_NAME` column to the value of the `para_buyer_name` input parameter for all records where the `PROPERTY_ID` column matches the `para_property_id` input parameter.\n6. The procedure includes an exception handling block.\n   - If a `NO_DATA_FOUND` exception occurs during execution, the procedure performs no action (indicated by `NULL`).\n   - For any other exception (`OTHERS`), the procedure re-raises the exception, propagating it to the calling environment.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_sale_price NUMBER, para_buyer_name VARCHAR2, para_property_id NUMBER) IS\n    v_days_on_market NUMBER;\n    v_sale_id NUMBER;\n    v_owner_count NUMBER;\nBEGIN\n    v_sale_id := FLOOR(DBMS_RANDOM.VALUE(1000, 9999));\n    v_days_on_market := ABS(MOD(v_sale_id, 90)) + 10;\n    \n    INSERT INTO SALES (SALE_ID, PROPERTY_ID, SALE_PRICE, BUYER_NAME, SALE_DATE, DAYS_ON_MARKET) \n    VALUES (v_sale_id, para_property_id, para_sale_price, para_buyer_name, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD'), v_days_on_market);\n    \n    -- Check if owner exists for this property before updating\n    SELECT COUNT(*) INTO v_owner_count FROM OWNERS WHERE PROPERTY_ID = para_property_id;\n    \n    IF v_owner_count > 0 THEN\n        UPDATE OWNERS SET OWNER_NAME = para_buyer_name WHERE PROPERTY_ID = para_property_id;\n    END IF;\n    \nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        NULL; -- Handle case where no matching records found\n    WHEN OTHERS THEN\n        RAISE;\nEND;",
    "database_name": "real_epaa_valuation",
    "tables": [
      "NEIGHBORHOODS",
      "OWNERS",
      "SALES"
    ],
    "call_sqls": [
      "BEGIN\n  sp(250000, 'Alice Johnson', 1);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(300000, 'Bob Wilson', 2);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(450000, 'Carol Davis', 3);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(275000, 'David Miller', 4);\n  COMMIT;\nEND;",
      "BEGIN\n  sp(325000, 'Eva Garcia', 5);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp that records a property sale in the SALES table using inputs for sale price, buyer name, and property ID. It generates a random sale ID between 1000 and 9999, calculates days on market based on that sale ID, and inserts the sale with the current date. If an owner for the property exists in the OWNERS table, update that owner's name to the buyer's name. Silently handle cases where no data is found and re-raise any other exceptions.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp that logs a sale. It takes inputs for the sale price, buyer name, and property ID. The procedure should generate a random sale ID between 1000 and 9999, compute the days on market as (sale_id MOD 90) + 10, and insert a new record into the SALES table with the current date. If the property already has an owner in the OWNERS table, update the owner name to the buyer name. Silently handle cases where no data is found, but re-raise any other errors.",
    "id": 44,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that accepts three input parameters: p_sale_price of type NUMBER, p_buyer_name of type VARCHAR2, and p_property_id of type NUMBER. The procedure logs a sale by inserting a new record into the SALES table and conditionally updating the OWNERS table. It begins by declaring local variables: v_sale_id of type NUMBER to store a randomly generated sale ID, v_days_on_market of type NUMBER to store the computed days on market, and v_current_date of type DATE to store the current system date. The procedure generates a random sale ID by using DBMS_RANDOM.VALUE to produce a random number between 1000 and 9999, inclusive, and rounds it to the nearest integer, storing it in v_sale_id. It then calculates v_days_on_market as the modulus of v_sale_id divided by 90, plus 10, ensuring the result is between 10 and 99. It retrieves the current system date using SYSDATE and stores it in v_current_date. Next, the procedure performs an INSERT operation into the SALES table, inserting a new row with columns sale_id set to v_sale_id, sale_price set to p_sale_price, buyer_name set to p_buyer_name, property_id set to p_property_id, sale_date set to v_current_date, and days_on_market set to v_days_on_market. Following the insertion, the procedure attempts to update the OWNERS table. It executes an UPDATE operation on the OWNERS table, setting the owner_name column to p_buyer_name where the property_id column matches p_property_id. This update is performed only if a matching property_id exists in the OWNERS table; if no matching row is found, the update affects zero rows, which is handled silently without raising an exception. The procedure includes an EXCEPTION block to handle errors: it catches the NO_DATA_FOUND exception and does nothing, allowing the procedure to complete successfully without action, but for any other exceptions, it uses RAISE to re-raise the error to the caller, ensuring that only NO_DATA_FOUND is silently ignored while other errors are propagated. The procedure does not return any output parameters; it performs the insert and conditional update as described.",
    "original_summary": "Create a stored procedure named 'sp' that records a property sale. It takes sale price, buyer name, and property ID as inputs. Generate a random sale ID between 1000-9999, calculate days on market as (sale_id MOD 90) + 10, and insert the sale with current date. If an owner exists for the property, update the owner's name to the buyer. Handle NO_DATA_FOUND silently and re-raise other exceptions.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure 'sp' to log a sale. Inputs: price, buyer, property ID. Generate random sale ID (1000-9999). Compute days on market as (sale_id MOD 90) + 10. Insert sale with current date. If property has an owner, update owner name to buyer. Silently handle NO_DATA_FOUND; re-raise others."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `proc_merge_evaluation_data` that accepts three input parameters: `p_model_id` of type `NUMBER`, `p_dataset_id` of type `NUMBER`, and `p_evaluator_id` of type `NUMBER`. The purpose of this procedure is to calculate aggregated evaluation metrics for a specific model, dataset, and evaluator combination, and then insert these aggregated metrics as a new evaluation record into the `MODEL_EVALUATIONS` table.\n\nUpon execution, the procedure first declares four local variables: `v_avg_coverage` of type `NUMBER`, `v_avg_accuracy` of type `NUMBER`, `v_total_correct` of type `NUMBER`, and `v_total_incorrect` of type `NUMBER`.\n\nNext, it performs a `SELECT` statement to retrieve aggregated data from the `MODEL_EVALUATIONS` table. This `SELECT` statement calculates the average of the `COVERAGE` column, the average of the `EMPIRICAL_ACCURACY` column, the sum of the `CORRECT` column, and the sum of the `INCORRECT` column. These calculated aggregate values are then stored into the respective local variables: `v_avg_coverage`, `v_avg_accuracy`, `v_total_correct`, and `v_total_incorrect`. The aggregation is performed only for rows in the `MODEL_EVALUATIONS` table where the `MODEL_ID` column matches the input parameter `p_model_id`, the `DATASET_ID` column matches the input parameter `p_dataset_id`, and the `EVALUATOR_ID` column matches the input parameter `p_evaluator_id`.\n\nFollowing the data retrieval, the procedure executes an `INSERT` statement to add a new row into the `MODEL_EVALUATIONS` table. The values for the columns in this new row are determined as follows:\n- For the `EVALUATION_ID` column, it uses a subquery `(SELECT NVL(MAX(EVALUATION_ID), 0) + 1 FROM MODEL_EVALUATIONS)`. This subquery finds the maximum existing `EVALUATION_ID` in the `MODEL_EVALUATIONS` table, uses `NVL` to treat a `NULL` result (if the table is empty) as `0`, and then adds `1` to this value to generate a new, unique `EVALUATION_ID`.\n- For the `MODEL_ID` column, it uses the input parameter `p_model_id`.\n- For the `DATASET_ID` column, it uses the input parameter `p_dataset_id`.\n- For the `EVALUATOR_ID` column, it uses the input parameter `p_evaluator_id`.\n- For the `COVERAGE` column, it uses the value stored in the local variable `v_avg_coverage`.\n- For the `EMPIRICAL_ACCURACY` column, it uses the value stored in the local variable `v_avg_accuracy`.\n- For the `CORRECT` column, it uses the value stored in the local variable `v_total_correct`.\n- For the `INCORRECT` column, it uses the value stored in the local variable `v_total_incorrect`.\n- For the `EVALUATION_DATE` column, it uses the `TO_CHAR` function to format the current timestamp, obtained via `CURRENT_TIMESTAMP`, into a string representation in 'YYYY-MM-DD' format.\n- For the `EVALUATION_NOTES` column, it inserts the literal string 'Merged evaluation data'.\n- For the `MODEL_VERSION` column, it uses a subquery `(SELECT MODEL_VERSION FROM MODELS WHERE MODEL_ID = p_model_id)`. This subquery retrieves the `MODEL_VERSION` from the `MODELS` table where the `MODEL_ID` matches the input parameter `p_model_id`.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_merge_evaluation_data (\n    p_model_id IN NUMBER,\n    p_dataset_id IN NUMBER,\n    p_evaluator_id IN NUMBER\n)\nIS\n    v_avg_coverage NUMBER;\n    v_avg_accuracy NUMBER;\n    v_total_correct NUMBER;\n    v_total_incorrect NUMBER;\nBEGIN\n    SELECT AVG(COVERAGE), AVG(EMPIRICAL_ACCURACY), SUM(CORRECT), SUM(INCORRECT)\n    INTO v_avg_coverage, v_avg_accuracy, v_total_correct, v_total_incorrect\n    FROM MODEL_EVALUATIONS\n    WHERE MODEL_ID = p_model_id\n    AND DATASET_ID = p_dataset_id\n    AND EVALUATOR_ID = p_evaluator_id;\n    \n    INSERT INTO MODEL_EVALUATIONS (\n        EVALUATION_ID, MODEL_ID, DATASET_ID, EVALUATOR_ID,\n        COVERAGE, EMPIRICAL_ACCURACY, CORRECT, INCORRECT,\n        EVALUATION_DATE, EVALUATION_NOTES, MODEL_VERSION\n    )\n    VALUES (\n        (SELECT NVL(MAX(EVALUATION_ID), 0) + 1 FROM MODEL_EVALUATIONS),\n        p_model_id, p_dataset_id, p_evaluator_id,\n        v_avg_coverage, v_avg_accuracy, v_total_correct, v_total_incorrect,\n        TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD'),\n        'Merged evaluation data',\n        (SELECT MODEL_VERSION FROM MODELS WHERE MODEL_ID = p_model_id)\n    );\nEND;",
    "database_name": "machine_lmeac_806224",
    "tables": [
      "DATASETS",
      "EVALUATION_VERSIONS",
      "MODELS",
      "MODEL_EVALUATIONS",
      "USERS",
      "ROLES"
    ],
    "call_sqls": [
      "BEGIN\n  proc_merge_evaluation_data(0, 0, 0);\n  commit;\nEND;",
      "BEGIN\n  proc_merge_evaluation_data(1, 1, 0);\n  commit;\nEND;",
      "BEGIN\n  proc_merge_evaluation_data(0, 1, 0);\n  commit;\nEND;",
      "BEGIN\n  proc_merge_evaluation_data(1, 0, 0);\n  commit;\nEND;",
      "BEGIN\n  proc_merge_evaluation_data(0, 0, 1);\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named proc_merge_evaluation_data that accepts a model ID, a dataset ID, and an evaluator ID. For the specified combination of MODEL_ID, DATASET_ID, and EVALUATOR_ID in the MODEL_EVALUATIONS table, calculate the average COVERAGE, average EMPIRICAL_ACCURACY, sum of CORRECT, and sum of INCORRECT. Then insert a new record into the MODEL_EVALUATIONS table with a generated EVALUATION_ID (as the next sequential number), the provided input IDs, the calculated aggregated values, the current date, the notes 'Merged evaluation data', and the MODEL_VERSION retrieved from the MODELS table for the given MODEL_ID.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called proc_merge_evaluation_data that takes a model identifier, a dataset identifier, and an evaluator identifier, calculates the average COVERAGE, average EMPIRICAL_ACCURACY, total sum of CORRECT, and total sum of INCORRECT from the MODEL_EVALUATIONS table for that specific combination, and then inserts a new record into MODEL_EVALUATIONS with these calculated values, a generated EVALUATION_ID, the current date, a note saying 'Merged evaluation data', and the MODEL_VERSION from the MODELS table.",
    "id": 45,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `proc_merge_evaluation_data` that accepts three input parameters: `p_model_id` of type `NUMBER`, `p_dataset_id` of type `NUMBER`, and `p_evaluator_id` of type `NUMBER`. The purpose of this procedure is to calculate aggregated evaluation metrics for a specific model, dataset, and evaluator combination, and then insert these aggregated metrics as a new evaluation record into the `MODEL_EVALUATIONS` table.\n\nUpon execution, the procedure first declares four local variables: `v_avg_coverage` of type `NUMBER`, `v_avg_accuracy` of type `NUMBER`, `v_total_correct` of type `NUMBER`, and `v_total_incorrect` of type `NUMBER`.\n\nNext, it performs a `SELECT` statement to retrieve aggregated data from the `MODEL_EVALUATIONS` table. This `SELECT` statement calculates the average of the `COVERAGE` column, the average of the `EMPIRICAL_ACCURACY` column, the sum of the `CORRECT` column, and the sum of the `INCORRECT` column. These calculated aggregate values are then stored into the respective local variables: `v_avg_coverage`, `v_avg_accuracy`, `v_total_correct`, and `v_total_incorrect`. The aggregation is performed only for rows in the `MODEL_EVALUATIONS` table where the `MODEL_ID` column matches the input parameter `p_model_id`, the `DATASET_ID` column matches the input parameter `p_dataset_id`, and the `EVALUATOR_ID` column matches the input parameter `p_evaluator_id`.\n\nFollowing the data retrieval, the procedure executes an `INSERT` statement to add a new row into the `MODEL_EVALUATIONS` table. The values for the columns in this new row are determined as follows:\n- For the `EVALUATION_ID` column, it uses a subquery `(SELECT NVL(MAX(EVALUATION_ID), 0) + 1 FROM MODEL_EVALUATIONS)`. This subquery finds the maximum existing `EVALUATION_ID` in the `MODEL_EVALUATIONS` table, uses `NVL` to treat a `NULL` result (if the table is empty) as `0`, and then adds `1` to this value to generate a new, unique `EVALUATION_ID`.\n- For the `MODEL_ID` column, it uses the input parameter `p_model_id`.\n- For the `DATASET_ID` column, it uses the input parameter `p_dataset_id`.\n- For the `EVALUATOR_ID` column, it uses the input parameter `p_evaluator_id`.\n- For the `COVERAGE` column, it uses the value stored in the local variable `v_avg_coverage`.\n- For the `EMPIRICAL_ACCURACY` column, it uses the value stored in the local variable `v_avg_accuracy`.\n- For the `CORRECT` column, it uses the value stored in the local variable `v_total_correct`.\n- For the `INCORRECT` column, it uses the value stored in the local variable `v_total_incorrect`.\n- For the `EVALUATION_DATE` column, it uses the `TO_CHAR` function to format the current timestamp, obtained via `CURRENT_TIMESTAMP`, into a string representation in 'YYYY-MM-DD' format.\n- For the `EVALUATION_NOTES` column, it inserts the literal string 'Merged evaluation data'.\n- For the `MODEL_VERSION` column, it uses a subquery `(SELECT MODEL_VERSION FROM MODELS WHERE MODEL_ID = p_model_id)`. This subquery retrieves the `MODEL_VERSION` from the `MODELS` table where the `MODEL_ID` matches the input parameter `p_model_id`.",
    "original_summary": "Create a stored procedure named proc_merge_evaluation_data that accepts model, dataset, and evaluator IDs. Calculate average coverage, average accuracy, sum of correct, and sum of incorrect from existing evaluations for that combination. Insert a new evaluation record with these aggregated values, a generated ID, the current date, 'Merged evaluation data' notes, and the model version from the MODELS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as 'proc_merge_evaluation_data'. This procedure shall accept the identifiers for a model, a dataset, and an evaluator. It is required to compute the average coverage, average accuracy, the total sum of correct evaluations, and the total sum of incorrect evaluations from the existing evaluation records corresponding to that specific combination. Subsequently, the procedure must insert a new evaluation record. This record shall incorporate the calculated aggregate values, a procedurally generated identifier, the current date, a note stating 'Merged evaluation data', and the model version retrieved from the MODELS table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp that accepts five parameters: p_user_name, p_email, p_role, p_password_hash, and p_status, all of type VARCHAR2. The procedure begins by declaring a local variable v_user_id of type NUMBER and another variable v_current_date of type VARCHAR2 with a length of 255 characters. It assigns the current system date formatted as 'YYYY-MM-DD' to v_current_date using the TO_CHAR function. The procedure then retrieves the maximum USER_ID from the USERS table, defaults to 0 if no records exist using the NVL function, increments it by 1, and stores the result in v_user_id. It proceeds to insert a new record into the USERS table with the following columns: USER_ID set to v_user_id, USER_NAME set to p_user_name, EMAIL set to p_email, ROLE set to p_role, PASSWORD_HASH set to p_password_hash, LAST_LOGIN, CREATED_AT, and UPDATED_AT all set to v_current_date, and STATUS set to p_status. Following the insertion, the procedure deletes any records from the ACCESS_LOGS table where the USER_ID matches v_user_id and the length of the IP_ADDRESS column is less than 7 characters. If any exception occurs during the execution of the procedure, it is caught by the OTHERS exception handler, which re-raises the exception.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_user_name VARCHAR2, p_email VARCHAR2, p_role VARCHAR2, p_password_hash VARCHAR2, p_status VARCHAR2) IS\n   v_user_id NUMBER;\n   v_current_date VARCHAR2(255);\nBEGIN\n   v_current_date := TO_CHAR(SYSDATE, 'YYYY-MM-DD');\n   SELECT NVL(MAX(USER_ID), 0) + 1 INTO v_user_id FROM USERS;\n   INSERT INTO USERS (USER_ID, USER_NAME, EMAIL, ROLE, PASSWORD_HASH, LAST_LOGIN, CREATED_AT, UPDATED_AT, STATUS)\n   VALUES (v_user_id, p_user_name, p_email, p_role, p_password_hash, v_current_date, v_current_date, v_current_date, p_status);\n   DELETE FROM ACCESS_LOGS WHERE USER_ID = v_user_id AND LENGTH(IP_ADDRESS) < 7;\nEXCEPTION\n   WHEN OTHERS THEN\n      RAISE;\nEND;",
    "database_name": "global_hae_statistics",
    "tables": [
      "ACCESS_LOGS",
      "COUNTRIES",
      "DISEASES",
      "ECONOMIC_INDICATORS",
      "EDUCATION",
      "HEALTHCARE_EXPENDITURE",
      "HEALTH_INDICATORS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  sp('john_doe', 'john.doe@example.com', 'user', 'hashed_password_123', 'active');\n  COMMIT;\nEND;",
      "BEGIN\n  sp('jane_smith', 'jane.smith@example.com', 'admin', 'hashed_password_456', 'active');\n  COMMIT;\nEND;",
      "BEGIN\n  sp('peter_jones', 'peter.jones@example.com', 'user', 'hashed_password_789', 'inactive');\n  COMMIT;\nEND;",
      "BEGIN\n  sp('alice_wonder', 'alice.wonder@example.com', 'editor', 'hashed_password_abc', 'active');\n  COMMIT;\nEND;",
      "BEGIN\n  sp('bob_builder', 'bob.builder@example.com', 'user', 'hashed_password_def', 'pending');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp that inserts a new user into the USERS table, generating a new USER_ID based on the current maximum, using provided parameters for USER_NAME, EMAIL, ROLE, PASSWORD_HASH, and STATUS, setting LAST_LOGIN, CREATED_AT, and UPDATED_AT to the current date, and then deletes any related records from the ACCESS_LOGS table for that user where the IP_ADDRESS length is less than 7, while handling any exceptions by re-raising them.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp that inserts a new user into the USERS table by generating a new USER_ID, adding the user's details including USER_NAME, EMAIL, ROLE, PASSWORD_HASH, and STATUS, setting timestamps for LAST_LOGIN, CREATED_AT, and UPDATED_AT to the current date, and then deletes any related records from the ACCESS_LOGS table where the USER_ID matches and the IP_ADDRESS length is less than 7, while re-raising any exceptions that occur.",
    "id": 46,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that operates within the global_hae_statistics database. This procedure is designed to insert a new user record into the USERS table and subsequently perform a cleanup operation on the ACCESS_LOGS table. The procedure accepts five input parameters: p_user_name of type VARCHAR2, p_email of type VARCHAR2, p_role of type VARCHAR2, p_password_hash of type VARCHAR2, and p_status of type VARCHAR2. These parameters correspond to the user's name, email address, role, hashed password, and status, respectively.\n\nThe procedure begins by declaring a local variable v_user_id of type NUMBER. This variable will hold the newly generated unique identifier for the user. The procedure then executes a SELECT statement to generate a new USER_ID. This is achieved by querying a sequence, presumably named USERS_SEQ or a similar convention, using the NEXTVAL pseudo-column. The result of this sequence generation is stored into the v_user_id variable.\n\nFollowing the ID generation, the procedure performs an INSERT operation into the USERS table. The INSERT statement specifies the following columns: USER_ID, USER_NAME, EMAIL, ROLE, PASSWORD_HASH, STATUS, LAST_LOGIN, CREATED_AT, and UPDATED_AT. The values inserted are as follows: the v_user_id variable for USER_ID; the input parameters p_user_name, p_email, p_role, p_password_hash, and p_status for their respective columns; and the SYSDATE function for the LAST_LOGIN, CREATED_AT, and UPDATED_AT columns, setting all three timestamps to the current date and time of the database server.\n\nAfter the successful insertion of the user record, the procedure executes a DELETE operation on the ACCESS_LOGS table. This DELETE statement targets records where the USER_ID column matches the newly generated v_user_id and where the length of the IP_ADDRESS column, determined by the LENGTH function, is less than 7. This condition is intended to remove related access log entries that have an IP address string shorter than 7 characters.\n\nThe entire block of operationscomprising the sequence selection, the INSERT, and the DELETEis enclosed within a BEGIN...EXCEPTION...END block for exception handling. If any exception is raised during the execution of these SQL statements (for example, a constraint violation, a data type mismatch, or a missing sequence), the procedure will catch that exception. Within the EXCEPTION section, the procedure uses the RAISE statement without any specific exception name, which re-raises the originally caught exception. This propagates the error to the calling environment, ensuring that the caller is aware that an error occurred during the procedure's execution. The procedure itself does not return a value but performs the described database modifications.",
    "original_summary": "Create a stored procedure named sp to insert a new user. It generates a new user ID, inserts user details (name, email, role, password hash, status, and timestamps) into the USERS table, and then deletes any related access logs where the IP address is too short. Handle any exceptions by re-raising them.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure named 'sp' that inserts a new user by generating a new user ID, adding the user's details like name, email, role, password hash, status, and timestamps to the USERS table, and then deletes any related access logs with an IP address that is too short, while ensuring any exceptions are re-raised?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ConvertTimestampToDate that accepts a single parameter p_timestamp of type NUMBER, which represents a timestamp value. The procedure begins by declaring a local variable v_formatted_date of type TIMESTAMP. It then executes a SELECT statement to convert the input timestamp into a formatted date. This conversion is performed by first adding the number of days represented by p_timestamp divided by 86400 (the number of seconds in a day) to the date '1970-01-01', which is the Unix epoch start date. The result is then converted to a character string using TO_CHAR with the format 'YYYY-MM-DD HH24:MI:SS', and subsequently converted back to a TIMESTAMP using TO_TIMESTAMP with the same format. The converted timestamp is stored in the variable v_formatted_date. Following this, the procedure performs an INSERT operation into the TIME_SERIES_DATA table. It inserts a new row with the following values: DATA_ID is set to the maximum existing DATA_ID in the table plus one, or 1 if the table is empty; SENSOR_ID is set to 1; TIMESTAMPS is set to the input parameter p_timestamp; VALUE, ANOMALY, CHANGEPOINT, TREND, NOISE, SEASONALITY1, SEASONALITY2, SEASONALITY3 are all set to 0; DATA_QUALITY is set to 'good'; and DATA_SOURCE is set to 'converted'. The MAX function is used to determine the highest current DATA_ID value, and NVL ensures that if no rows exist, the starting DATA_ID will be 1. The procedure does not include any conditional logic or loops, and it operates on the TIME_SERIES_DATA table without any WHERE clause conditions.",
    "plsql": "CREATE OR REPLACE PROCEDURE ConvertTimestampToDate(p_timestamp NUMBER) AS\n    v_formatted_date TIMESTAMP;\nBEGIN\n    SELECT TO_TIMESTAMP(TO_CHAR(TO_DATE('1970-01-01', 'YYYY-MM-DD') + (p_timestamp/86400), 'YYYY-MM-DD HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS')\n    INTO v_formatted_date\n    FROM DUAL;\n    INSERT INTO TIME_SERIES_DATA (DATA_ID, SENSOR_ID, TIMESTAMPS, VALUE, ANOMALY, CHANGEPOINT, TREND, NOISE, SEASONALITY1, SEASONALITY2, SEASONALITY3, DATA_QUALITY, DATA_SOURCE)\n    SELECT NVL(MAX(DATA_ID), 0) + 1, 1, p_timestamp, 0, 0, 0, 0, 0, 0, 0, 0, 'good', 'converted'\n    FROM TIME_SERIES_DATA;\nEND;",
    "database_name": "time_sdaaa_detection",
    "tables": [
      "SENSORS",
      "TIME_SERIES_DATA",
      "ANOMALY_DETECTION",
      "CHANGEPOINT_DETECTION",
      "THRESHOLDS",
      "TREND_ANALYSIS"
    ],
    "call_sqls": [
      "BEGIN\n  ConvertTimestampToDate(1416720000);\n  COMMIT;\nEND;",
      "BEGIN\n  ConvertTimestampToDate(1416730000);\n  COMMIT;\nEND;",
      "BEGIN\n  ConvertTimestampToDate(1416740000);\n  COMMIT;\nEND;",
      "BEGIN\n  ConvertTimestampToDate(1416750000);\n  COMMIT;\nEND;",
      "BEGIN\n  ConvertTimestampToDate(1416760000);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named ConvertTimestampToDate that takes a Unix timestamp as input, converts it to a formatted TIMESTAMP, and inserts a new record into the TIME_SERIES_DATA table. The procedure must generate a new DATA_ID by incrementing the maximum existing DATA_ID by 1 (starting from 1 if none exist), set SENSOR_ID to 1, TIMESTAMPS to the input timestamp, VALUE and all analysis columns (ANOMALY, CHANGEPOINT, TREND, NOISE, SEASONALITY1, SEASONALITY2, SEASONALITY3) to 0, set DATA_QUALITY to 'good', and set DATA_SOURCE to 'converted'.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called ConvertTimestampToDate that takes a Unix timestamp (p_timestamp) and converts it into a formatted TIMESTAMP, then inserts a new record into the TIME_SERIES_DATA table. For the DATA_ID, use the highest existing DATA_ID plus one (or start at 1 if the table is empty), set SENSOR_ID to 1, populate TIMESTAMPS with the provided p_timestamp, set VALUE, ANOMALY, CHANGEPOINT, TREND, NOISE, SEASONALITY1, SEASONALITY2, and SEASONALITY3 all to 0, mark DATA_QUALITY as 'good', and set DATA_SOURCE to 'converted'.",
    "id": 47,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named ConvertTimestampToDate that accepts a single parameter p_timestamp of type NUMBER, which represents a timestamp value. The procedure begins by declaring a local variable v_formatted_date of type TIMESTAMP. It then executes a SELECT statement to convert the input timestamp into a formatted date. This conversion is performed by first adding the number of days represented by p_timestamp divided by 86400 (the number of seconds in a day) to the date '1970-01-01', which is the Unix epoch start date. The result is then converted to a character string using TO_CHAR with the format 'YYYY-MM-DD HH24:MI:SS', and subsequently converted back to a TIMESTAMP using TO_TIMESTAMP with the same format. The converted timestamp is stored in the variable v_formatted_date. Following this, the procedure performs an INSERT operation into the TIME_SERIES_DATA table. It inserts a new row with the following values: DATA_ID is set to the maximum existing DATA_ID in the table plus one, or 1 if the table is empty; SENSOR_ID is set to 1; TIMESTAMPS is set to the input parameter p_timestamp; VALUE, ANOMALY, CHANGEPOINT, TREND, NOISE, SEASONALITY1, SEASONALITY2, SEASONALITY3 are all set to 0; DATA_QUALITY is set to 'good'; and DATA_SOURCE is set to 'converted'. The MAX function is used to determine the highest current DATA_ID value, and NVL ensures that if no rows exist, the starting DATA_ID will be 1. The procedure does not include any conditional logic or loops, and it operates on the TIME_SERIES_DATA table without any WHERE clause conditions.",
    "original_summary": "Create a stored procedure named ConvertTimestampToDate that converts a Unix timestamp (NUMBER parameter p_timestamp) to a formatted TIMESTAMP. Then, insert a row into the TIME_SERIES_DATA table. Generate DATA_ID as max existing ID + 1 (starting at 1). Set SENSOR_ID to 1, TIMESTAMPS to p_timestamp, VALUE and all analysis columns (ANOMALY, CHANGEPOINT, etc.) to 0. Set DATA_QUALITY to 'good' and DATA_SOURCE to 'converted'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called ConvertTimestampToDate? It should take a Unix timestamp (that's the p_timestamp number param) and turn it into a proper formatted TIMESTAMP. Then, we gotta stick a new row into the TIME_SERIES_DATA table. For the DATA_ID, just grab the biggest ID already in there and add 1 to it (if it's empty, start at 1). Set the SENSOR_ID to 1, pop the TIMESTAMPS field with that p_timestamp, and set VALUE and all those analysis columnsyou know, ANOMALY, CHANGEPOINT, and the restto 0. Oh, and mark DATA_QUALITY as 'good' and DATA_SOURCE as 'converted'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named calculate_publication_fee that accepts three parameters: p_journal_id of type NUMBER, p_fee_percentage of type NUMBER, and p_currency_code of type VARCHAR2. The procedure begins by declaring two local variables, v_current_fee and v_new_fee, both of type NUMBER. It then executes a SELECT statement to retrieve the current publication fee from the PUBLICATION_FEE column of the JOURNALS table, where the JOURNAL_ID matches the input parameter p_journal_id, and stores this value in the v_current_fee variable. Next, it calculates a new publication fee by adding the product of v_current_fee and p_fee_percentage divided by 100 to v_current_fee, and assigns this result to v_new_fee. The procedure then performs an UPDATE operation on the JOURNALS table, setting the PUBLICATION_FEE column to the value of v_new_fee and the CURRENCY column to the uppercase version of the input parameter p_currency_code, using the UPPER() function to ensure the currency code is in uppercase. This update is applied to the row where the JOURNAL_ID matches the input parameter p_journal_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_publication_fee(\n    p_journal_id IN NUMBER,\n    p_fee_percentage IN NUMBER,\n    p_currency_code IN VARCHAR2\n)\nIS\n    v_current_fee NUMBER;\n    v_new_fee NUMBER;\nBEGIN\n    SELECT PUBLICATION_FEE INTO v_current_fee\n    FROM JOURNALS\n    WHERE JOURNAL_ID = p_journal_id;\n    \n    v_new_fee := v_current_fee + (v_current_fee * p_fee_percentage / 100);\n    \n    UPDATE JOURNALS\n    SET PUBLICATION_FEE = v_new_fee, CURRENCY = UPPER(p_currency_code)\n    WHERE JOURNAL_ID = p_journal_id;\nEND;",
    "database_name": "academic_jma_publication",
    "tables": [
      "JOURNALS",
      "JOURNAL_LICENSES",
      "JOURNAL_STATISTICS",
      "USER_ACCESS"
    ],
    "call_sqls": [
      "BEGIN\n    calculate_publication_fee(0, 10, 'USD');\n    COMMIT;\nEND;",
      "BEGIN\n    calculate_publication_fee(1, 5, 'EUR');\n    COMMIT;\nEND;",
      "BEGIN\n    calculate_publication_fee(0, -15, 'GBP');\n    COMMIT;\nEND;",
      "BEGIN\n    calculate_publication_fee(1, 0, 'JPY');\n    COMMIT;\nEND;",
      "BEGIN\n    calculate_publication_fee(0, 25.5, 'CAD');\n    COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named calculate_publication_fee that, for a specified JOURNAL_ID from the JOURNALS table, retrieves the current PUBLICATION_FEE, calculates a new fee by increasing it by a given percentage, and then updates the JOURNALS table to set the PUBLICATION_FEE to this new calculated value and the CURRENCY to the uppercase version of a provided currency code.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called calculate_publication_fee that accepts a journal ID (p_journal_id), a fee percentage (p_fee_percentage), and a currency code (p_currency_code). It should retrieve the current PUBLICATION_FEE from the JOURNALS table for the given JOURNAL_ID, calculate a new fee by increasing the current fee by the specified percentage, and then update the JOURNALS table to set the PUBLICATION_FEE to this new calculated value and set the CURRENCY to the uppercase version of the provided currency code for that specific JOURNAL_ID.",
    "id": 48,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named calculate_publication_fee that takes three input parameters: p_journal_id of type NUMBER, p_fee_percentage of type NUMBER, and p_currency_code of type VARCHAR2. The procedure operates on the academic_jma_publication database and interacts with the JOURNALS table. It declares one local variable: v_current_fee of type NUMBER, initialized to 0. The procedure first executes a SELECT statement on the JOURNALS table to retrieve the PUBLICATION_FEE column for the row where the JOURNAL_ID column matches the input parameter p_journal_id, storing the result in v_current_fee. If no row is found, v_current_fee remains 0. The procedure then calculates a new fee by multiplying v_current_fee by (1 + p_fee_percentage / 100). For example, if p_fee_percentage is 10, the new fee is v_current_fee * 1.10. Next, it executes an UPDATE statement on the JOURNALS table to set the PUBLICATION_FEE column to the newly calculated fee and the CURRENCY column to the uppercase version of p_currency_code (using the UPPER function) for the row where JOURNAL_ID equals p_journal_id. The procedure does not return a value; it performs the update directly. It includes exception handling that catches NO_DATA_FOUND exceptions and outputs 'Error: Journal ID not found' using DBMS_OUTPUT.PUT_LINE, and catches all other exceptions using WHEN OTHERS and outputs 'Error: ' concatenated with SQLERRM.",
    "original_summary": "Create a stored procedure named calculate_publication_fee with parameters p_journal_id (NUMBER), p_fee_percentage (NUMBER), and p_currency_code (VARCHAR2). Retrieve the current PUBLICATION_FEE from JOURNALS for the given JOURNAL_ID. Calculate a new fee by adding the percentage increase to the current fee. Update the JOURNALS table, setting PUBLICATION_FEE to the new calculated value and CURRENCY to the uppercase version of the input currency code, for the specified JOURNAL_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Develop a stored procedure called calculate_publication_fee, which should accept three distinct parameters: p_journal_id as a NUMBER, p_fee_percentage as a NUMBER, and p_currency_code as a VARCHAR2. First, you must carefully fetch the existing PUBLICATION_FEE value from the detailed JOURNALS table specifically for the provided JOURNAL_ID. Then, meticulously compute a revised fee by applying the specified percentage increase to the current fee amount. Finally, proceed to update the comprehensive JOURNALS table by setting the PUBLICATION_FEE to this newly calculated value and simultaneously adjusting the CURRENCY to the uppercase version of the supplied currency code, all for the precisely identified JOURNAL_ID."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp2 that accepts three parameters: para_user_id of type NUMBER, para_action_type of type VARCHAR2, and para_module of type VARCHAR2. The procedure begins by declaring two local variables, v_user_name and v_action_desc, both of type VARCHAR2 with a maximum length of 255 characters. It then performs a SELECT operation to retrieve the USER_NAME from the USERS table where the USER_ID matches the provided para_user_id, storing the result in the v_user_name variable. The procedure constructs a string for v_action_desc by concatenating the phrase 'Action performed by ' with the uppercase version of v_user_name using the UPPER() function. Next, it inserts a new record into the AUDIT_TRAILS table with the following values: a randomly generated AUDIT_ID between 10000 and 99999 using the DBMS_RANDOM.VALUE function, the para_user_id, the current date formatted as 'YYYY-MM-DD' for ACTION_DATE, the current time formatted as 'HH24:MI:SS' for ACTION_TIME, the para_action_type, the v_action_desc, the para_module, a fixed value of 1 for AFFECTED_ROWS, and a hardcoded IP address '192.168.1.1'. Finally, the procedure deletes records from the AUDIT_TRAILS table where the AUDIT_ID is less than 100 and the ACTION_DATE is earlier than '2022-01-01'.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp2(para_user_id NUMBER, para_action_type VARCHAR2, para_module VARCHAR2)\nIS\n    v_user_name VARCHAR2(255);\n    v_action_desc VARCHAR2(255);\nBEGIN\n    SELECT USER_NAME INTO v_user_name FROM USERS WHERE USER_ID = para_user_id;\n    v_action_desc := 'Action performed by ' || UPPER(v_user_name);\n    INSERT INTO AUDIT_TRAILS (AUDIT_ID, USER_ID, ACTION_DATE, ACTION_TIME, ACTION_TYPE, ACTION_DESCRIPTION, MODULE, AFFECTED_ROWS, IP_ADDRESS)\n    VALUES (ROUND(DBMS_RANDOM.VALUE(10000,99999)), para_user_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'HH24:MI:SS'), para_action_type, v_action_desc, para_module, 1, '192.168.1.1');\n    DELETE FROM AUDIT_TRAILS WHERE AUDIT_ID < 100 AND ACTION_DATE < '2022-01-01';\nEND;",
    "database_name": "customer_rmat_services",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "CUSTOMER_SERVICES",
      "PAYMENT_METHODS",
      "SERVICES",
      "CONTRACTS",
      "CHURN_ANALYSIS",
      "USERS",
      "AUDIT_TRAILS"
    ],
    "call_sqls": [
      "BEGIN\n  sp2(1, 'Create', 'Customers');\n  commit;\nEND;",
      "BEGIN\n  sp2(1, 'Update', 'Contracts');\n  commit;\nEND;",
      "BEGIN\n  sp2(1, 'Delete', 'Churn Analysis');\n  commit;\nEND;",
      "BEGIN\n  sp2(1, 'Create', 'Customer Payments');\n  commit;\nEND;",
      "BEGIN\n  sp2(1, 'Update', 'Customer Services');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp2 that accepts a user ID, an action type, and a module. It retrieves the user's name from the USERS table, constructs an action description, and inserts a new record into the AUDIT_TRAILS table with a random audit ID, the current date and time, the provided parameters, a fixed affected rows count of 1, and a fixed IP address. It then deletes any old records from AUDIT_TRAILS where the audit ID is less than 100 and the action date is before '2022-01-01'.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp2 that takes a user identifier, a type of action, and a module. Retrieve the USER_NAME from the USERS table for that user, create a description by combining it with a standard text, and insert a new record into the AUDIT_TRAILS table with a random AUDIT_ID, the current date and time, the provided details, and fixed values for AFFECTED_ROWS and IP_ADDRESS. Then, remove any older records from AUDIT_TRAILS where the AUDIT_ID is below 100 and the ACTION_DATE is before January 1, 2022.",
    "id": 49,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp2 that accepts three input parameters: p_user_id of type NUMBER which identifies the user, p_action_type of type VARCHAR2 which specifies the type of action performed, and p_module of type VARCHAR2 which indicates the module where the action occurred. The procedure declares two local variables: v_user_name of type VARCHAR2 to store the retrieved username, and v_description of type VARCHAR2 to store the constructed description text.\n\nThe procedure first executes a SELECT query on the USERS table to retrieve the USER_NAME column for the record where the USER_ID column matches the input parameter p_user_id, storing the result in v_user_name. It then constructs v_description by concatenating the literal string 'Action performed by user: ' with the retrieved v_user_name value.\n\nNext, the procedure inserts a new record into the AUDIT_TRAILS table. It generates a random AUDIT_ID using the DBMS_RANDOM.VALUE function, casting it to NUMBER and rounding it to the nearest integer. The ACTION_DATE is set to the current system date and time using SYSDATE. The ACTION_TYPE and MODULE columns are populated with the input parameters p_action_type and p_module respectively. The DESCRIPTION column is set to the constructed v_description. The AFFECTED_ROWS column is hardcoded to 0, and the IP_ADDRESS column is hardcoded to the string '192.168.1.1'. The USER_ID column is populated with the input parameter p_user_id.\n\nFollowing the insertion, the procedure executes a DELETE operation on the AUDIT_TRAILS table. It removes all records where the AUDIT_ID is less than 100 and the ACTION_DATE is earlier than January 1, 2022, specifically using the condition ACTION_DATE < TO_DATE('2022-01-01', 'YYYY-MM-DD').",
    "original_summary": "Create a stored procedure named sp2 that accepts user_id, action_type, and module parameters. Retrieve the user's name, construct an action description, and insert a new audit record with random ID, current date/time, provided values, and fixed details. Then delete old audit records where audit_id < 100 and action_date is before '2022-01-01'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called sp2 that takes a user identifier, a type of action, and a module. Get the name for that user, put together a description of what happened, and add a new audit entry with a random ID, the current timestamp, the given details, and some standard info. After that, clean up by removing older audit entries where the audit ID is pretty low and the action date is from way back before the start of 2022."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_product_info that accepts five input parameters: a numeric parameter p_product_id, a variable-length character parameter p_product_name, a variable-length character parameter p_product_category, a variable-length character parameter p_brand, and a numeric parameter p_weight. The procedure first declares a local numeric variable v_existing_product. It begins execution by performing a SELECT statement on the PRODUCTS table, using the COUNT(*) function to count the number of rows where the PRODUCT_ID column equals the input parameter p_product_id, and stores this count result into the variable v_existing_product. It then evaluates a conditional IF statement: if the value of v_existing_product is greater than zero, indicating a matching product already exists, it executes an UPDATE statement on the PRODUCTS table, setting the PRODUCT_NAME column to p_product_name, the PRODUCT_CATEGORY column to p_product_category, the BRAND column to p_brand, and the WEIGHT column to p_weight, specifically for the row where the PRODUCT_ID column equals p_product_id. If the IF condition is not met (the ELSE branch), meaning v_existing_product is zero and no matching product exists, it executes an INSERT statement into the PRODUCTS table, inserting a new row with column values: PRODUCT_ID from p_product_id, PRODUCT_NAME from p_product_name, PRODUCT_CATEGORY from p_product_category, BRAND from p_brand, and WEIGHT from p_weight.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_product_info(p_product_id NUMBER, p_product_name VARCHAR2, p_product_category VARCHAR2, p_brand VARCHAR2, p_weight NUMBER) IS\n  v_existing_product NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_existing_product FROM PRODUCTS WHERE PRODUCT_ID = p_product_id;\n  IF v_existing_product > 0 THEN\n    UPDATE PRODUCTS SET PRODUCT_NAME = p_product_name, PRODUCT_CATEGORY = p_product_category, BRAND = p_brand, WEIGHT = p_weight WHERE PRODUCT_ID = p_product_id;\n  ELSE\n    INSERT INTO PRODUCTS (PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY, BRAND, WEIGHT) VALUES (p_product_id, p_product_name, p_product_category, p_brand, p_weight);\n  END IF;\nEND;",
    "database_name": "e_comas_analytics",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "PAYMENT",
      "SHIPPING",
      "RETURNS",
      "FEEDBACK"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_product_info(101, 'Laptop Pro X', 'Electronics', 'TechBrand', 2.5);\nEND;",
      "BEGIN\n  sp_update_product_info(102, 'Ergonomic Office Chair', 'Furniture', 'ComfortSeating', 15.0);\nEND;",
      "BEGIN\n  sp_update_product_info(103, 'Wireless Mouse', 'Electronics', 'TechBrand', 0.1);\nEND;",
      "BEGIN\n  sp_update_product_info(104, 'Coffee Maker Deluxe', 'Home Appliances', 'BrewMaster', 3.0);\nEND;",
      "BEGIN\n  sp_update_product_info(101, 'Laptop Pro X v2', 'Electronics', 'TechBrand', 2.3);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_update_product_info that accepts a product ID, product name, product category, brand, and weight to either update an existing product in the PRODUCTS table if the given product ID already exists, or insert a new product record into the PRODUCTS table with the provided details if the product ID does not exist.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_update_product_info that either updates an existing product's details or inserts a new product record in the PRODUCTS table, based on whether the product already exists. It takes a product identifier, name, category, brand, and weight as inputs. If a product with the given identifier exists in the PRODUCTS table, update its PRODUCT_NAME, PRODUCT_CATEGORY, BRAND, and WEIGHT with the provided values. If no such product exists, insert a new record into the PRODUCTS table with the supplied PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY, BRAND, and WEIGHT.",
    "id": 50,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_product_info that accepts five input parameters: p_product_id of type NUMBER, p_product_name of type VARCHAR2, p_product_category of type VARCHAR2, p_brand of type VARCHAR2, and p_weight of type NUMBER. These parameters correspond to the product identifier, name, category, brand, and weight respectively.\n\nThe procedure operates on the PRODUCTS table within the e_comas_analytics database. The table contains columns PRODUCT_ID, PRODUCT_NAME, PRODUCT_CATEGORY, BRAND, and WEIGHT. The primary purpose of this procedure is to perform an \"upsert\" operation: updating an existing product record if it exists, or inserting a new record if it does not.\n\nThe procedure begins by checking for the existence of a record in the PRODUCTS table where the PRODUCT_ID column matches the input parameter p_product_id. This is done using a SELECT COUNT(*) query into a local variable, typically named v_count, of type NUMBER.\n\nBased on the value of v_count, the procedure executes one of two branches:\n1.  If v_count is greater than 0, indicating that a product with the given identifier already exists, the procedure performs an UPDATE operation on the PRODUCTS table. The UPDATE statement sets the PRODUCT_NAME column to the value of p_product_name, the PRODUCT_CATEGORY column to the value of p_product_category, the BRAND column to the value of p_brand, and the WEIGHT column to the value of p_weight. The UPDATE is conditional, applying only to the row where the PRODUCT_ID column equals the input parameter p_product_id.\n2.  If v_count equals 0, indicating that no product with the given identifier exists, the procedure performs an INSERT operation into the PRODUCTS table. The INSERT statement adds a new row with the following column values: PRODUCT_ID is set to p_product_id, PRODUCT_NAME is set to p_product_name, PRODUCT_CATEGORY is set to p_product_category, BRAND is set to p_brand, and WEIGHT is set to p_weight.\n\nThe procedure does not have any output parameters and does not return a value; its effect is the modification of the PRODUCTS table.",
    "original_summary": "Create a stored procedure named sp_update_product_info that accepts product details. It checks if a product with the given ID exists. If it exists, update the product's information; if not, insert a new product record with the provided details.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as `sp_update_product_info` to process product details. The procedure must first verify the existence of a record corresponding to the supplied product identifier. Should the product be located, its information is to be updated accordingly. Conversely, if no such product exists, a new record containing the provided details must be inserted into the database."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_model_access that accepts two parameters: p_model_id of type NUMBER, representing the identifier of a model, and p_days_back of type NUMBER, indicating the number of days to look back from the current date. The procedure begins by declaring two local variables, v_access_count and v_max_access_id, both of type NUMBER. It then performs a SELECT operation to count the number of entries in the ACCESS_LOGS table where the MODEL_ID matches the provided p_model_id and the ACCESS_DATE, converted to a date format using TO_DATE with the 'YYYY-MM-DD' pattern, is greater than or equal to the current date minus the p_days_back value. The result is stored in v_access_count. A conditional statement checks if v_access_count exceeds 50. If true, a DELETE operation is executed on the ACCESS_LOGS table to remove entries where the MODEL_ID matches p_model_id, the ACCESS_TYPE is 'view', and the ACCESS_DATE, again converted using TO_DATE, is less than the current date minus 365 days. If the condition is false, the procedure performs a SELECT operation to find the maximum ACCESS_ID in the ACCESS_LOGS table, using NVL to default to 0 if no entries exist, and stores the result in v_max_access_id. Subsequently, an INSERT operation is conducted to add new rows to the ACCESS_LOGS table, setting ACCESS_ID to v_max_access_id plus the row number, MODEL_ID to the provided p_model_id, USER_ID to the CREATED_BY value from the MODELS table, ACCESS_DATE to the current date formatted as 'YYYY-MM-DD', ACCESS_TYPE to 'archive', and ACCESS_DETAILS to 'Archived old access logs'. This insertion is based on a SELECT statement from the MODELS table where MODEL_ID matches p_model_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_model_access(p_model_id NUMBER, p_days_back NUMBER)\nIS\n    v_access_count NUMBER;\n    v_max_access_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_access_count\n    FROM ACCESS_LOGS\n    WHERE MODEL_ID = p_model_id\n    AND TO_DATE(ACCESS_DATE, 'YYYY-MM-DD') >= SYSDATE - p_days_back;\n    \n    IF v_access_count > 50 THEN\n        DELETE FROM ACCESS_LOGS\n        WHERE MODEL_ID = p_model_id\n        AND ACCESS_TYPE = 'view'\n        AND TO_DATE(ACCESS_DATE, 'YYYY-MM-DD') < SYSDATE - 365;\n    ELSE\n        SELECT NVL(MAX(ACCESS_ID), 0) INTO v_max_access_id FROM ACCESS_LOGS;\n        \n        INSERT INTO ACCESS_LOGS (ACCESS_ID, MODEL_ID, USER_ID, ACCESS_DATE, ACCESS_TYPE, ACCESS_DETAILS)\n        SELECT v_max_access_id + ROWNUM, \n               MODEL_ID, CREATED_BY, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'archive', 'Archived old access logs'\n        FROM MODELS\n        WHERE MODEL_ID = p_model_id;\n    END IF;\nEND;",
    "database_name": "machine_lmpm_310382",
    "tables": [
      "ACCESS_LOGS",
      "EVALUATIONS",
      "MODELS",
      "MODEL_TAGS",
      "MODEL_VERSIONS",
      "MODEL_VERSION_DIFF",
      "PERFORMANCE_METRICS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  update_model_access(p_model_id => 1, p_days_back => 30);\n  COMMIT;\nEND;",
      "BEGIN\n  update_model_access(p_model_id => 2, p_days_back => 7);\n  COMMIT;\nEND;",
      "BEGIN\n  update_model_access(p_model_id => 0, p_days_back => 90);\n  COMMIT;\nEND;",
      "BEGIN\n  update_model_access(p_model_id => 5, p_days_back => 1);\n  COMMIT;\nEND;",
      "BEGIN\n  update_model_access(p_model_id => 3, p_days_back => 365);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_model_access that, for a given MODEL_ID and a specified number of lookback days (p_days_back), checks the ACCESS_LOGS table. If the count of access entries for that model within the lookback period exceeds 50, it deletes all 'view' type logs for the model that are older than 365 days. Otherwise, it retrieves the next available ACCESS_ID and inserts new 'archive' type log entries into ACCESS_LOGS for the model, using the MODEL_ID and CREATED_BY from the MODELS table, with the current date and a note stating 'Archived old access logs'.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_model_access that takes a model ID and a number of lookback days as input. If the count of access entries in the ACCESS_LOGS table for that model from the last given days exceeds 50, remove any 'view' logs older than 365 days. Otherwise, retrieve the next available access ID and insert new 'archive' log entries for that model into ACCESS_LOGS, using data from the MODELS table.",
    "id": 51,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_model_access that accepts two parameters: p_model_id of type NUMBER, representing the identifier of a model, and p_days_back of type NUMBER, indicating the number of days to look back from the current date. The procedure begins by declaring two local variables, v_access_count and v_max_access_id, both of type NUMBER. It then performs a SELECT operation to count the number of entries in the ACCESS_LOGS table where the MODEL_ID matches the provided p_model_id and the ACCESS_DATE, converted to a date format using TO_DATE with the 'YYYY-MM-DD' pattern, is greater than or equal to the current date minus the p_days_back value. The result is stored in v_access_count. A conditional statement checks if v_access_count exceeds 50. If true, a DELETE operation is executed on the ACCESS_LOGS table to remove entries where the MODEL_ID matches p_model_id, the ACCESS_TYPE is 'view', and the ACCESS_DATE, again converted using TO_DATE, is less than the current date minus 365 days. If the condition is false, the procedure performs a SELECT operation to find the maximum ACCESS_ID in the ACCESS_LOGS table, using NVL to default to 0 if no entries exist, and stores the result in v_max_access_id. Subsequently, an INSERT operation is conducted to add new rows to the ACCESS_LOGS table, setting ACCESS_ID to v_max_access_id plus the row number, MODEL_ID to the provided p_model_id, USER_ID to the CREATED_BY value from the MODELS table, ACCESS_DATE to the current date formatted as 'YYYY-MM-DD', ACCESS_TYPE to 'archive', and ACCESS_DETAILS to 'Archived old access logs'. This insertion is based on a SELECT statement from the MODELS table where MODEL_ID matches p_model_id.",
    "original_summary": "Create a stored procedure named update_model_access to manage access logs for a model. It accepts a model ID and a lookback days count. If access entries in the last specified days exceed 50, delete 'view' logs older than 365 days. Otherwise, get the next available access ID and insert new 'archive' log entries for the model, using data from the MODELS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Write a stored procedure called update_model_access to handle model access logs. It should take a model ID and a number of lookback days as input. If the count of access entries from the last given days is over 50, remove any 'view' logs that are older than 365 days. If not, retrieve the next available access ID and insert new 'archive' log entries for that model, pulling the necessary data from the MODELS table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `p_generate_nation_supplier_report` that accepts one input parameter, `p_nation_key`, which is of data type `NUMBER`. This procedure is designed to calculate aggregated supplier and warehouse information for a specific nation and then conditionally insert this aggregated data as a new nation record into the `NATIONS` table.\n\nThe procedure begins by declaring three local variables: `v_supplier_count` of type `NUMBER`, `v_warehouse_count` of type `NUMBER`, and `v_total_capacity` of type `NUMBER`.\n\nThe first operation performed is a `SELECT` statement that calculates the distinct count of suppliers, the distinct count of warehouses, and the sum of warehouse capacities for a given nation. Specifically, it selects `COUNT(DISTINCT s.SUPPLIER_ID)` to determine the number of unique suppliers, `COUNT(DISTINCT w.WAREHOUSE_ID)` to determine the number of unique warehouses, and `SUM(w.CAPACITY)` to calculate the total capacity of all warehouses. These calculated values are then stored into the `v_supplier_count`, `v_warehouse_count`, and `v_total_capacity` variables, respectively. The data for this aggregation is retrieved from the `SUPPLIERS` table, aliased as `s`, and the `WAREHOUSES` table, aliased as `w`. These two tables are joined using a `LEFT JOIN` operation on the condition `s.SUPPLIER_ID = w.SUPPLIER_ID`, meaning that all suppliers will be included in the result set, even if they do not have associated warehouses. The `WHERE` clause filters these records to include only those where the `NATION_KEY` column in the `SUPPLIERS` table (`s.NATION_KEY`) matches the input parameter `p_nation_key`.\n\nFollowing this aggregation, the procedure attempts an `INSERT` operation into the `NATIONS` table. This `INSERT` statement is conditional. It inserts a new row into the `NATIONS` table with specific values for its columns:\n- The `NATION_KEY` column is set to the value of the input parameter `p_nation_key`.\n- The `NATION_NAME` column is set to a concatenated string formed by 'REPORT_' followed by the value of `p_nation_key`.\n- The `CONTINENT` column is set to the literal string 'REPORT'.\n- The `CURRENCY` column is set to the literal string 'REPORT'.\n- The `TIMEZONE` column is set to the literal string 'UTC'.\n- The `IMPORT_EXPORT_REGULATIONS` column is set to a concatenated string that includes the calculated supplier count, warehouse count, and total capacity. This string is formed as 'SUPPLIERS:' followed by the value of `v_supplier_count`, then ',WAREHOUSES:' followed by the value of `v_warehouse_count`, and finally ',CAPACITY:' followed by the value of `v_total_capacity`.\n\nThis `INSERT` operation is executed only if a specific condition is met, as determined by a `WHERE NOT EXISTS` clause. The subquery `SELECT 1 FROM NATIONS WHERE NATION_KEY = p_nation_key` checks if a record with the `NATION_KEY` matching the input parameter `p_nation_key` already exists in the `NATIONS` table. If no such record exists (i.e., `NOT EXISTS` is true), then the `INSERT` statement proceeds. The `FROM DUAL` clause is used as a placeholder since the values being inserted are derived from variables and literals, not directly from a table.",
    "plsql": "CREATE OR REPLACE PROCEDURE p_generate_nation_supplier_report(p_nation_key IN NUMBER)\nIS\n   v_supplier_count NUMBER;\n   v_warehouse_count NUMBER;\n   v_total_capacity NUMBER;\nBEGIN\n   SELECT COUNT(DISTINCT s.SUPPLIER_ID), COUNT(DISTINCT w.WAREHOUSE_ID), SUM(w.CAPACITY)\n   INTO v_supplier_count, v_warehouse_count, v_total_capacity\n   FROM SUPPLIERS s\n   LEFT JOIN WAREHOUSES w ON s.SUPPLIER_ID = w.SUPPLIER_ID\n   WHERE s.NATION_KEY = p_nation_key;\n   INSERT INTO NATIONS (NATION_KEY, NATION_NAME, CONTINENT, CURRENCY, TIMEZONE, IMPORT_EXPORT_REGULATIONS)\n   SELECT p_nation_key, 'REPORT_' || p_nation_key, 'REPORT', 'REPORT', 'UTC', 'SUPPLIERS:' || v_supplier_count || ',WAREHOUSES:' || v_warehouse_count || ',CAPACITY:' || v_total_capacity\n   FROM DUAL\n   WHERE NOT EXISTS (SELECT 1 FROM NATIONS WHERE NATION_KEY = p_nation_key);\nEND;",
    "database_name": "supply_cmasw_tracking",
    "tables": [
      "INVENTORY",
      "NATIONS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "RETURNS",
      "SHIPMENTS",
      "SUPPLIERS",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "BEGIN\n  p_generate_nation_supplier_report(1);\n  COMMIT;\nEND;",
      "BEGIN\n  p_generate_nation_supplier_report(44);\n  COMMIT;\nEND;",
      "BEGIN\n  p_generate_nation_supplier_report(77);\n  COMMIT;\nEND;",
      "BEGIN\n  p_generate_nation_supplier_report(12);\n  COMMIT;\nEND;",
      "BEGIN\n  p_generate_nation_supplier_report(30);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named p_generate_nation_supplier_report that accepts a p_nation_key to identify a nation. For that nation, calculate the distinct count of suppliers from the SUPPLIERS table, the distinct count of warehouses from the WAREHOUSES table, and the total sum of CAPACITY from the WAREHOUSES table. If a record with that NATION_KEY does not already exist in the NATIONS table, insert a new row into NATIONS using the p_nation_key, with placeholder values for NATION_NAME, CONTINENT, CURRENCY, and TIMEZONE, and format the calculated supplier count, warehouse count, and total capacity into a report string for the IMPORT_EXPORT_REGULATIONS column.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called p_generate_nation_supplier_report that takes a p_nation_key number. For that nation key, calculate the count of distinct SUPPLIER_IDs from the SUPPLIERS table, the count of distinct WAREHOUSE_IDs from the WAREHOUSES table, and the total sum of CAPACITY from the WAREHOUSES table. Then, if a record with that NATION_KEY does not already exist in the NATIONS table, insert a new row into NATIONS with the NATION_KEY, a constructed NATION_NAME, CONTINENT, CURRENCY, TIMEZONE, and a summary string in IMPORT_EXPORT_REGULATIONS that includes the supplier count, warehouse count, and total capacity.",
    "id": 52,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `p_generate_nation_supplier_report` that accepts one input parameter, `p_nation_key`, which is of data type `NUMBER`. This procedure is designed to calculate aggregated supplier and warehouse information for a specific nation and then conditionally insert this aggregated data as a new nation record into the `NATIONS` table.\n\nThe procedure begins by declaring three local variables: `v_supplier_count` of type `NUMBER`, `v_warehouse_count` of type `NUMBER`, and `v_total_capacity` of type `NUMBER`.\n\nThe first operation performed is a `SELECT` statement that calculates the distinct count of suppliers, the distinct count of warehouses, and the sum of warehouse capacities for a given nation. Specifically, it selects `COUNT(DISTINCT s.SUPPLIER_ID)` to determine the number of unique suppliers, `COUNT(DISTINCT w.WAREHOUSE_ID)` to determine the number of unique warehouses, and `SUM(w.CAPACITY)` to calculate the total capacity of all warehouses. These calculated values are then stored into the `v_supplier_count`, `v_warehouse_count`, and `v_total_capacity` variables, respectively. The data for this aggregation is retrieved from the `SUPPLIERS` table, aliased as `s`, and the `WAREHOUSES` table, aliased as `w`. These two tables are joined using a `LEFT JOIN` operation on the condition `s.SUPPLIER_ID = w.SUPPLIER_ID`, meaning that all suppliers will be included in the result set, even if they do not have associated warehouses. The `WHERE` clause filters these records to include only those where the `NATION_KEY` column in the `SUPPLIERS` table (`s.NATION_KEY`) matches the input parameter `p_nation_key`.\n\nFollowing this aggregation, the procedure attempts an `INSERT` operation into the `NATIONS` table. This `INSERT` statement is conditional. It inserts a new row into the `NATIONS` table with specific values for its columns:\n- The `NATION_KEY` column is set to the value of the input parameter `p_nation_key`.\n- The `NATION_NAME` column is set to a concatenated string formed by 'REPORT_' followed by the value of `p_nation_key`.\n- The `CONTINENT` column is set to the literal string 'REPORT'.\n- The `CURRENCY` column is set to the literal string 'REPORT'.\n- The `TIMEZONE` column is set to the literal string 'UTC'.\n- The `IMPORT_EXPORT_REGULATIONS` column is set to a concatenated string that includes the calculated supplier count, warehouse count, and total capacity. This string is formed as 'SUPPLIERS:' followed by the value of `v_supplier_count`, then ',WAREHOUSES:' followed by the value of `v_warehouse_count`, and finally ',CAPACITY:' followed by the value of `v_total_capacity`.\n\nThis `INSERT` operation is executed only if a specific condition is met, as determined by a `WHERE NOT EXISTS` clause. The subquery `SELECT 1 FROM NATIONS WHERE NATION_KEY = p_nation_key` checks if a record with the `NATION_KEY` matching the input parameter `p_nation_key` already exists in the `NATIONS` table. If no such record exists (i.e., `NOT EXISTS` is true), then the `INSERT` statement proceeds. The `FROM DUAL` clause is used as a placeholder since the values being inserted are derived from variables and literals, not directly from a table.",
    "original_summary": "Create a stored procedure named p_generate_nation_supplier_report that accepts a p_nation_key number. Calculate the distinct supplier count, warehouse count, and total warehouse capacity for that nation. If a nation with that key does not already exist, insert a new record into the NATIONS table with the calculated data formatted into a report string.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called p_generate_nation_supplier_report that takes a p_nation_key number. Figure out roughly how many different suppliers and warehouses there are, along with the overall warehouse space for that place. If there isn't already a nation for that key, put a new entry into the NATIONS table with the gathered info turned into a kind of summary string."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_manage_player_data that accepts four input parameters: a numeric p_player_id, a numeric p_college_id, a numeric p_team_id, and a numeric p_year. The procedure first declares three local numeric variables: v_college_exists, v_team_exists, and v_player_exists. It begins execution by querying the COLLEGES table to count the number of rows where the COLLEGE_ID column equals the input parameter p_college_id, storing the result in v_college_exists. If v_college_exists is greater than zero, indicating the college exists, it proceeds to query the PLAYERS table to count the number of rows where the PLAYER_ID column equals p_player_id, storing the result in v_player_exists. If v_player_exists equals zero, it inserts a new row into the PLAYERS table, populating the PLAYER_ID column with p_player_id and the COLLEGE_ID column with p_college_id. If v_player_exists is not zero, it updates the existing row in the PLAYERS table for the matching PLAYER_ID, setting its COLLEGE_ID column to the value of p_college_id. After this conditional logic, the procedure then queries the PLAYER_TEAMS table to count the number of rows where the PLAYER_ID column equals p_player_id, the TEAM_ID column equals p_team_id, and the YEAR column equals p_year, storing the result in v_team_exists. If v_team_exists equals zero, it inserts a new row into the PLAYER_TEAMS table, populating the PLAYER_ID column with p_player_id, the TEAM_ID column with p_team_id, and the YEAR column with p_year.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_manage_player_data(\n    p_player_id NUMBER,\n    p_college_id NUMBER,\n    p_team_id NUMBER,\n    p_year NUMBER\n) IS\n    v_college_exists NUMBER;\n    v_team_exists NUMBER;\n    v_player_exists NUMBER;\nBEGIN\n    -- Check if the college exists\n    SELECT COUNT(*) INTO v_college_exists FROM COLLEGES WHERE COLLEGE_ID = p_college_id;\n    \n    IF v_college_exists > 0 THEN\n        -- Check if the player exists\n        SELECT COUNT(*) INTO v_player_exists FROM PLAYERS WHERE PLAYER_ID = p_player_id;\n        IF v_player_exists = 0 THEN\n            -- Insert new player if not exists\n            INSERT INTO PLAYERS (PLAYER_ID, COLLEGE_ID) VALUES (p_player_id, p_college_id);\n        ELSE\n            -- Update player's college if player exists\n            UPDATE PLAYERS SET COLLEGE_ID = p_college_id WHERE PLAYER_ID = p_player_id;\n        END IF;\n    END IF;\n\n    -- Check if the player-team-year combination exists\n    SELECT COUNT(*) INTO v_team_exists FROM PLAYER_TEAMS WHERE PLAYER_ID = p_player_id AND TEAM_ID = p_team_id AND YEAR = p_year;\n    IF v_team_exists = 0 THEN\n        -- Insert new player-team-year combination if not exists\n        INSERT INTO PLAYER_TEAMS (PLAYER_ID, TEAM_ID, YEAR) VALUES (p_player_id, p_team_id, p_year);\n    END IF;\nEND sp_manage_player_data;",
    "database_name": "nba_psa_information",
    "tables": [
      "PLAYERS",
      "COLLEGES",
      "DRAFTS",
      "POSITIONS",
      "PLAYER_COLLEGES",
      "PLAYER_TEAMS",
      "ALL_STAR_GAMES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_manage_player_data(1, 101, 201, 2023);\n  commit;\nEND;",
      "BEGIN\n  sp_manage_player_data(2, 102, 202, 2022);\n  commit;\nEND;",
      "BEGIN\n  sp_manage_player_data(3, 103, 203, 2021);\n  commit;\nEND;",
      "BEGIN\n  sp_manage_player_data(4, 104, 204, 2020);\n  commit;\nEND;",
      "BEGIN\n  sp_manage_player_data(5, 105, 205, 2019);\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_manage_player_data that, given a player ID, college ID, team ID, and year, first checks if the college exists in the COLLEGES table; if it does, it either inserts a new player with that college into the PLAYERS table or updates the existing player's college affiliation. Then, it checks if the specified player-team-year combination already exists in the PLAYER_TEAMS table and inserts a new record only if it does not.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_manage_player_data that, for a given player identified by p_player_id, updates their college info in the PLAYERS table using p_college_id only if that college exists in COLLEGES, inserting a new player if they don't exist or updating their college if they do, and also adds a record for the player's team and year into PLAYER_TEAMS using p_team_id and p_year if that exact combination isn't already present.",
    "id": 53,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_manage_player_data that accepts four input parameters: a numeric p_player_id, a numeric p_college_id, a numeric p_team_id, and a numeric p_year. The procedure first declares three local numeric variables: v_college_exists, v_team_exists, and v_player_exists. It begins execution by querying the COLLEGES table to count the number of rows where the COLLEGE_ID column equals the input parameter p_college_id, storing the result in v_college_exists. If v_college_exists is greater than zero, indicating the college exists, it proceeds to query the PLAYERS table to count the number of rows where the PLAYER_ID column equals p_player_id, storing the result in v_player_exists. If v_player_exists equals zero, it inserts a new row into the PLAYERS table, populating the PLAYER_ID column with p_player_id and the COLLEGE_ID column with p_college_id. If v_player_exists is not zero, it updates the existing row in the PLAYERS table for the matching PLAYER_ID, setting its COLLEGE_ID column to the value of p_college_id. After this conditional logic, the procedure then queries the PLAYER_TEAMS table to count the number of rows where the PLAYER_ID column equals p_player_id, the TEAM_ID column equals p_team_id, and the YEAR column equals p_year, storing the result in v_team_exists. If v_team_exists equals zero, it inserts a new row into the PLAYER_TEAMS table, populating the PLAYER_ID column with p_player_id, the TEAM_ID column with p_team_id, and the YEAR column with p_year.",
    "original_summary": "Create a stored procedure named sp_manage_player_data that inserts or updates a player's college affiliation in the PLAYERS table if the college exists, and then inserts a new player-team-year association into PLAYER_TEAMS if it does not already exist.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create a stored procedure called sp_manage_player_data that, for a given player, handles their college info in the PLAYERS table when the college is known, and also adds a record for the player's team and year into PLAYER_TEAMS if something similar isn't already there."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_model_accuracy that accepts four parameters: p_model_id of type NUMBER, p_start_date of type VARCHAR2, p_end_date of type VARCHAR2, and p_accuracy of type NUMBER as an OUT parameter. The procedure calculates the accuracy of predictions made by a specific model within a specified date range and updates the model's accuracy in the database. It begins by declaring two local variables, v_total_predictions and v_correct_predictions, both of type NUMBER. The procedure first executes a SELECT COUNT(*) query to determine the total number of predictions made by the model with the ID specified by p_model_id, where the prediction date (EST) falls between the dates provided by p_start_date and p_end_date, inclusive. The result is stored in v_total_predictions. Next, another SELECT COUNT(*) query is executed to count the number of correct predictions, where the predicted condition matches the actual condition (PREDICTED_CONDITION_ID equals ACTUAL_CONDITION_ID) for the same model and date range, storing the result in v_correct_predictions. The procedure then checks if v_total_predictions is greater than zero. If true, it calculates the accuracy as the ratio of v_correct_predictions to v_total_predictions and assigns this value to the OUT parameter p_accuracy. If v_total_predictions is zero, it sets p_accuracy to zero. Finally, the procedure updates the PREDICTION_MODELS table, setting the ACCURACY column to the calculated p_accuracy and the LAST_UPDATED column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS', for the row where MODEL_ID matches p_model_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_model_accuracy(\n    p_model_id IN NUMBER,\n    p_start_date IN VARCHAR2,\n    p_end_date IN VARCHAR2,\n    p_accuracy OUT NUMBER\n)\nIS\n    v_total_predictions NUMBER;\n    v_correct_predictions NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_total_predictions\n    FROM PREDICTIONS\n    WHERE MODEL_ID = p_model_id\n    AND EST >= p_start_date\n    AND EST <= p_end_date;\n\n    SELECT COUNT(*)\n    INTO v_correct_predictions\n    FROM PREDICTIONS\n    WHERE MODEL_ID = p_model_id\n    AND EST >= p_start_date\n    AND EST <= p_end_date\n    AND PREDICTED_CONDITION_ID = ACTUAL_CONDITION_ID;\n\n    IF v_total_predictions > 0 THEN\n        p_accuracy := v_correct_predictions / v_total_predictions;\n    ELSE\n        p_accuracy := 0;\n    END IF;\n\n    UPDATE PREDICTION_MODELS\n    SET ACCURACY = p_accuracy,\n        LAST_UPDATED = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n    WHERE MODEL_ID = p_model_id;\nEND;",
    "database_name": "weather_oaf_92747",
    "tables": [
      "ACCESS_LOGS",
      "PREDICTIONS",
      "PREDICTION_MODELS",
      "USERS",
      "WEATHER_CONDITIONS",
      "WEATHER_DATA",
      "WEATHER_EVENTS",
      "WEATHER_STATIONS"
    ],
    "call_sqls": [
      "DECLARE\n    v_accuracy NUMBER;\nBEGIN\n    update_model_accuracy(1, '2024-01-01', '2024-01-31', v_accuracy);\n    DBMS_OUTPUT.PUT_LINE('Accuracy: ' || v_accuracy);\nEND;",
      "DECLARE\n    v_accuracy NUMBER;\nBEGIN\n    update_model_accuracy(0, '2024-02-01', '2024-02-29', v_accuracy);\n    DBMS_OUTPUT.PUT_LINE('Accuracy: ' || v_accuracy);\nEND;",
      "DECLARE\n    v_accuracy NUMBER;\nBEGIN\n    update_model_accuracy(1, '2024-03-01', '2024-03-15', v_accuracy);\n    DBMS_OUTPUT.PUT_LINE('Accuracy: ' || v_accuracy);\nEND;",
      "DECLARE\n    v_accuracy NUMBER;\nBEGIN\n    update_model_accuracy(0, '2023-12-01', '2023-12-31', v_accuracy);\n    DBMS_OUTPUT.PUT_LINE('Accuracy: ' || v_accuracy);\nEND;",
      "DECLARE\n    v_accuracy NUMBER;\nBEGIN\n    update_model_accuracy(1, '2024-01-01', '2024-03-31', v_accuracy);\n    DBMS_OUTPUT.PUT_LINE('Accuracy: ' || v_accuracy);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_model_accuracy that takes a model ID, a start date, and an end date, and returns an accuracy percentage. It should calculate the accuracy for the specified model within the given date range by retrieving the total number of predictions and the number of correct predictions from the PREDICTIONS table, where a correct prediction is defined as having matching PREDICTED_CONDITION_ID and ACTUAL_CONDITION_ID. If there are any predictions, the accuracy is the ratio of correct to total predictions; otherwise, the accuracy is set to 0. The procedure must then update the ACCURACY and LAST_UPDATED timestamp for that model in the PREDICTION_MODELS table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_model_accuracy that takes a model ID, a start date, and an end date, and returns an accuracy score. It should calculate the total number of guesses and the number of correct guesses the model made in the PREDICTIONS table between those dates, where a correct guess is when PREDICTED_CONDITION_ID equals ACTUAL_CONDITION_ID. If there are any guesses, compute accuracy by dividing correct guesses by total guesses; otherwise, set accuracy to zero. Return this accuracy value and also update the PREDICTION_MODELS table with this new accuracy and the current timestamp for that specific MODEL_ID.",
    "id": 54,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_model_accuracy. This procedure is designed to calculate and update the accuracy score for a specific prediction model based on its performance within a given date range. The procedure accepts three input parameters: model_id of type NUMBER, start_date of type DATE, and end_date of type DATE. It returns the calculated accuracy score through an OUT parameter named accuracy_score of type NUMBER.\n\nThe procedure begins by declaring two local variables: v_total_guesses of type NUMBER to store the total number of predictions made, and v_correct_guesses of type NUMBER to store the count of correct predictions.\n\nThe core logic involves two SQL operations. First, the procedure executes a SELECT statement to compute both the total number of guesses and the number of correct guesses from the PREDICTIONS table. This SELECT statement uses the COUNT(*) aggregate function to count all rows, and the COUNT(CASE WHEN ...) expression to count only rows where the PREDICTED_CONDITION_ID equals the ACTUAL_CONDITION_ID. The query filters records where the MODEL_ID matches the input parameter model_id and the PREDICTION_DATE falls between the input parameters start_date and end_date (inclusive). The results of these two counts are fetched into the local variables v_total_guesses and v_correct_guesses using an INTO clause.\n\nFollowing the data retrieval, the procedure implements conditional logic using an IF statement. It checks if the value of v_total_guesses is greater than zero. If true, it calculates the accuracy by dividing v_correct_guesses by v_total_guesses and assigns the result to the OUT parameter accuracy_score. If false (meaning v_total_guesses is zero), it sets the accuracy_score to zero.\n\nAfter determining the accuracy_score, the procedure performs an UPDATE operation on the PREDICTION_MODELS table. It updates the row where the MODEL_ID column matches the input parameter model_id. The update sets two columns: the ACCURACY column is set to the newly calculated accuracy_score, and the LAST_UPDATED column is set to the current system date and time using the SYSDATE function.\n\nFinally, the procedure concludes, having output the accuracy score via the accuracy_score parameter and persisted the updated accuracy and timestamp in the database.",
    "original_summary": "Create a PL/SQL procedure named update_model_accuracy with parameters p_model_id (NUMBER), p_start_date (VARCHAR2), p_end_date (VARCHAR2), and an OUT parameter p_accuracy (NUMBER). Count total predictions and correct predictions for the specified model within the date range. If total predictions > 0, calculate accuracy as correct/total; otherwise, set accuracy to 0. Output the accuracy via p_accuracy. Update the PREDICTION_MODELS table with the new accuracy and the current timestamp for the given model.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a PL/SQL procedure called update_model_accuracy? It needs to take in a model ID, a start date, and an end date, and spit back an accuracy score. Basically, we need to figure out how many total guesses and how many right guesses that model made between those two dates. If it made any guesses at all, just divide the right ones by the total to get the accuracy. If it didn't make any, then the accuracy is just zero. Stick that final number into the OUT parameter. Oh, and don't forget to update the PREDICTION_MODELS table with that new accuracy number and the current time for that specific model."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp_insert_model_category` that accepts two input parameters: `para_CATEGORY_NAME` of type `VARCHAR2` to specify the name of the new category, and `para_DESCRIPTION` of type `VARCHAR2` to provide a description for the new category. The procedure's sole operation is to insert a new record into the `MODEL_CATEGORIES` table. For this insertion, the `CATEGORY_ID` column is populated by first querying the `MODEL_CATEGORIES` table to find the maximum existing `CATEGORY_ID` value. If no `CATEGORY_ID` values exist (i.e., the maximum is `NULL`), `NVL` function ensures that `0` is used instead. This retrieved maximum value (or `0`) is then incremented by `1` to generate a unique, sequential `CATEGORY_ID` for the new record. The `CATEGORY_NAME` column is populated with the value provided by the `para_CATEGORY_NAME` input parameter. The `DESCRIPTION` column is populated with the value provided by the `para_DESCRIPTION` input parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_insert_model_category(para_CATEGORY_NAME VARCHAR2, para_DESCRIPTION VARCHAR2) IS \nBEGIN \n  INSERT INTO MODEL_CATEGORIES (CATEGORY_ID, CATEGORY_NAME, DESCRIPTION) \n  VALUES ((SELECT NVL(MAX(CATEGORY_ID), 0) + 1 FROM MODEL_CATEGORIES), para_CATEGORY_NAME, para_DESCRIPTION);\nEND;",
    "database_name": "machine_lmpm_582732",
    "tables": [
      "MODELS",
      "MODEL_CATEGORIES",
      "MODEL_TYPES",
      "MODEL_VERSIONS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_insert_model_category('Electronics', 'Category for electronic models');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_model_category('Automotive', 'Category for automotive models');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_model_category('Healthcare', 'Category for healthcare models');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_model_category('Finance', 'Category for finance models');\n  commit;\nEND;",
      "BEGIN\n  sp_insert_model_category('Education', 'Category for educational models');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_insert_model_category that adds a new category to the MODEL_CATEGORIES table by taking a CATEGORY_NAME and DESCRIPTION as inputs, automatically generating a new CATEGORY_ID by incrementing the highest existing ID in the table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_insert_model_category that inserts a new row into the MODEL_CATEGORIES table. It should accept a CATEGORY_NAME and a DESCRIPTION as input, and automatically generate the CATEGORY_ID by incrementing the maximum existing CATEGORY_ID from the table.",
    "id": 55,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp_insert_model_category` that accepts two input parameters: `para_CATEGORY_NAME` of type `VARCHAR2` to specify the name of the new category, and `para_DESCRIPTION` of type `VARCHAR2` to provide a description for the new category. The procedure's sole operation is to insert a new record into the `MODEL_CATEGORIES` table. For this insertion, the `CATEGORY_ID` column is populated by first querying the `MODEL_CATEGORIES` table to find the maximum existing `CATEGORY_ID` value. If no `CATEGORY_ID` values exist (i.e., the maximum is `NULL`), `NVL` function ensures that `0` is used instead. This retrieved maximum value (or `0`) is then incremented by `1` to generate a unique, sequential `CATEGORY_ID` for the new record. The `CATEGORY_NAME` column is populated with the value provided by the `para_CATEGORY_NAME` input parameter. The `DESCRIPTION` column is populated with the value provided by the `para_DESCRIPTION` input parameter.",
    "original_summary": "Create a stored procedure named 'sp_insert_model_category' that inserts a new category into the MODEL_CATEGORIES table. It generates a new CATEGORY_ID by incrementing the current maximum ID, and uses the input parameters for the CATEGORY_NAME and DESCRIPTION.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure 'sp_insert_model_category' to insert a new MODEL_CATEGORIES row. Auto-increment CATEGORY_ID from max. Accept CATEGORY_NAME and DESCRIPTION."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_new_algorithm that accepts three input parameters: p_algorithm_name of type VARCHAR2, p_description of type VARCHAR2, and p_created_by of type NUMBER. The procedure performs two main operations. First, it inserts a new record into the ALGORITHMS table, setting the ALGORITHM_ID column to the next available integer by selecting the maximum ALGORITHM_ID currently in the table and adding one, or using 1 if the table is empty. The ALGORITHM_NAME column is set to the value of p_algorithm_name, and the DESCRIPTION column is set to the value of p_description. Second, it inserts a new record into the MODEL_VERSIONS table, setting the VERSION_ID column to the next available integer by selecting the maximum VERSION_ID currently in the table and adding one, or using 1 if the table is empty. The MODEL_ID column is set to NULL, the VERSION_NUMBER column is set to 0, the VERSION_DATE column is set to the current date formatted as 'YYYY-MM-DD', the DESCRIPTION column is set to the string 'New Algorithm Inserted', and both the CREATED_BY and UPDATED_BY columns are set to the value of p_created_by.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_algorithm(\n    p_algorithm_name IN VARCHAR2,\n    p_description IN VARCHAR2,\n    p_created_by IN NUMBER\n)\nIS\nBEGIN\n    INSERT INTO ALGORITHMS (ALGORITHM_ID, ALGORITHM_NAME, DESCRIPTION)\n    VALUES (\n        (SELECT NVL(MAX(ALGORITHM_ID), 0) + 1 FROM ALGORITHMS),\n        p_algorithm_name,\n        p_description\n    );\n    \n    INSERT INTO MODEL_VERSIONS (VERSION_ID, MODEL_ID, VERSION_NUMBER, VERSION_DATE, DESCRIPTION, CREATED_BY, UPDATED_BY)\n    VALUES (\n        (SELECT NVL(MAX(VERSION_ID), 0) + 1 FROM MODEL_VERSIONS),\n        NULL,\n        0,\n        TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'),\n        'New Algorithm Inserted',\n        p_created_by,\n        p_created_by\n    );\nEND;",
    "database_name": "machine_lmeao_637620",
    "tables": [
      "MODELS",
      "MODEL_EVALUATIONS",
      "MODEL_VERSIONS",
      "ALGORITHMS",
      "HYPERPARAMETERS",
      "EVALUATION_METRICS"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_algorithm('Random Forest', 'Ensemble learning method for classification and regression.', 101);\nEND;",
      "BEGIN\n  insert_new_algorithm('Gradient Boosting', 'Powerful machine learning technique for classification and regression.', 102);\nEND;",
      "BEGIN\n  insert_new_algorithm('Support Vector Machine', 'Supervised learning model with associated learning algorithms that analyze data for classification and regression analysis.', 103);\nEND;",
      "BEGIN\n  insert_new_algorithm('K-Means Clustering', 'Unsupervised learning algorithm for partitioning n observations into k clusters.', 104);\nEND;",
      "BEGIN\n  insert_new_algorithm('Neural Network', 'A series of algorithms that endeavors to recognize underlying relationships in a set of data through a process that mimics the way the human brain operates.', 105);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named insert_new_algorithm that adds a new algorithm to the ALGORITHMS table and logs the action in the MODEL_VERSIONS table. It accepts an algorithm name, a description, and a creator ID. For the ALGORITHMS table, it generates a new ALGORITHM_ID, then inserts the provided name and description. For the MODEL_VERSIONS table, it generates a new VERSION_ID, sets MODEL_ID to NULL, sets VERSION_NUMBER to 0, sets VERSION_DATE to the current date, sets DESCRIPTION to 'New Algorithm Inserted', and sets both CREATED_BY and UPDATED_BY to the provided creator ID.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called insert_new_algorithm that adds a new algorithm and logs the action, accepting an algorithm name, a description, and a creator ID, which inserts a record into the ALGORITHMS table with a generated ID and the provided details, and then inserts a record into the MODEL_VERSIONS table with a generated version ID, a NULL model ID, version number 0, the current date, the description, and the creator ID.",
    "id": 56,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named insert_new_algorithm that accepts three input parameters: p_algorithm_name of type VARCHAR2, p_description of type VARCHAR2, and p_created_by of type NUMBER. The procedure performs two main operations. First, it inserts a new record into the ALGORITHMS table, setting the ALGORITHM_ID column to the next available integer by selecting the maximum ALGORITHM_ID currently in the table and adding one, or using 1 if the table is empty. The ALGORITHM_NAME column is set to the value of p_algorithm_name, and the DESCRIPTION column is set to the value of p_description. Second, it inserts a new record into the MODEL_VERSIONS table, setting the VERSION_ID column to the next available integer by selecting the maximum VERSION_ID currently in the table and adding one, or using 1 if the table is empty. The MODEL_ID column is set to NULL, the VERSION_NUMBER column is set to 0, the VERSION_DATE column is set to the current date formatted as 'YYYY-MM-DD', the DESCRIPTION column is set to the string 'New Algorithm Inserted', and both the CREATED_BY and UPDATED_BY columns are set to the value of p_created_by.",
    "original_summary": "Create a stored procedure named insert_new_algorithm that adds a new algorithm and logs the action. It accepts an algorithm name, a description, and a creator ID. It inserts a new record into the ALGORITHMS table with a generated ID, the provided name and description. It then inserts a record into the MODEL_VERSIONS table with a generated version ID, a NULL model ID, version number 0, the current date, a description, and the creator ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure named 'insert_new_algorithm' that adds a new algorithm and logs the action, accepting an algorithm name, a description, and a creator ID, which inserts a record into the ALGORITHMS table with a generated ID and the provided details, and then inserts a record into the MODEL_VERSIONS table with a generated version ID, a NULL model ID, version number 0, the current date, the description, and the creator ID?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named DeleteInactiveUserActivity that accepts five parameters: p_user_id of type VARCHAR2, p_server_id of type NUMBER, p_sync_ts of type VARCHAR2, p_status_msg of type VARCHAR2, and p_device_info of type VARCHAR2. The procedure first deletes records from the USER_ACTIVITY table where the USER_ID column matches the value of p_user_id and the CURRENTLY_ACTIVE column is equal to 0, indicating that the user is inactive. Following the deletion, the procedure inserts a new record into the USER_SERVER_SYNC table with the columns SYNC_ID, USER_ID, SERVER_ID, and SYNC_TS. The SYNC_ID is determined by selecting the maximum existing SYNC_ID from the USER_SERVER_SYNC table, using the NVL function to handle nulls by defaulting to 0, and incrementing this value by 1 to ensure a unique identifier. The USER_ID, SERVER_ID, and SYNC_TS columns are populated with the values of p_user_id, p_server_id, and p_sync_ts, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE DeleteInactiveUserActivity(\n  p_user_id IN VARCHAR2,\n  p_server_id IN NUMBER,\n  p_sync_ts IN VARCHAR2,\n  p_status_msg IN VARCHAR2,\n  p_device_info IN VARCHAR2\n) AS\nBEGIN\n  DELETE FROM USER_ACTIVITY\n  WHERE USER_ID = p_user_id AND CURRENTLY_ACTIVE = 0;\n  \n  INSERT INTO USER_SERVER_SYNC (SYNC_ID, USER_ID, SERVER_ID, SYNC_TS)\n  VALUES ((SELECT NVL(MAX(SYNC_ID), 0) + 1 FROM USER_SERVER_SYNC), p_user_id, p_server_id, p_sync_ts);\nEND;",
    "database_name": "user_aas_tracking",
    "tables": [
      "SERVER_INFO",
      "USER_ACTIVITY",
      "USER_SERVER_SYNC",
      "USER_STATUS"
    ],
    "call_sqls": [
      "BEGIN\n  DeleteInactiveUserActivity('@spyglass:localhost:8800', 1, '1570040279284', 'None', 'Windows 10, Chrome');\nEND;",
      "BEGIN\n  DeleteInactiveUserActivity('@anon-20191002_181700-11:local...', 2, '1570040284126', 'Away', 'Mac OS, Safari');\nEND;",
      "BEGIN\n  DeleteInactiveUserActivity('user123@example.com', 0, '1570040310260', 'In meeting', 'Linux, Firefox');\nEND;",
      "BEGIN\n  DeleteInactiveUserActivity('@testuser:server.com', 1, '1570040315260', 'Available', 'Android, App');\nEND;",
      "BEGIN\n  DeleteInactiveUserActivity('john.doe@company.com', 2, '1570040320000', 'Offline', 'iOS, Safari');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named DeleteInactiveUserActivity that, for a given user identified by user_id, deletes all inactive records from the USER_ACTIVITY table where the user is not currently active, and then inserts a new synchronization record into the USER_SERVER_SYNC table with a new unique SYNC_ID, along with the provided user_id, server_id, and sync_timestamp.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called DeleteInactiveUserActivity that, for a given user_id, removes all inactive records (where CURRENTLY_ACTIVE = 0) from the USER_ACTIVITY table, then inserts a new sync record into USER_SERVER_SYNC with a new SYNC_ID (generated as the next available number), using the provided user_id, server_id, and sync_timestamp.",
    "id": 57,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named DeleteInactiveUserActivity that accepts five parameters: p_user_id of type VARCHAR2, p_server_id of type NUMBER, p_sync_ts of type VARCHAR2, p_status_msg of type VARCHAR2, and p_device_info of type VARCHAR2. The procedure first deletes records from the USER_ACTIVITY table where the USER_ID column matches the value of p_user_id and the CURRENTLY_ACTIVE column is equal to 0, indicating that the user is inactive. Following the deletion, the procedure inserts a new record into the USER_SERVER_SYNC table with the columns SYNC_ID, USER_ID, SERVER_ID, and SYNC_TS. The SYNC_ID is determined by selecting the maximum existing SYNC_ID from the USER_SERVER_SYNC table, using the NVL function to handle nulls by defaulting to 0, and incrementing this value by 1 to ensure a unique identifier. The USER_ID, SERVER_ID, and SYNC_TS columns are populated with the values of p_user_id, p_server_id, and p_sync_ts, respectively.",
    "original_summary": "Create a stored procedure named DeleteInactiveUserActivity that deletes inactive records from USER_ACTIVITY for a given user and then inserts a new record into USER_SERVER_SYNC with a generated SYNC_ID, using the provided parameters for user_id, server_id, and sync_timestamp.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called DeleteInactiveUserActivity? It should clean out the old, inactive stuff for a specific user from the USER_ACTIVITY table. After that's done, pop a fresh record into USER_SERVER_SYNC. Don't forget to cook up a new SYNC_ID for it, and use the user_id, server_id, and sync_timestamp we give you."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `synchronize_party_regions` that accepts three input parameters: `p_party_id` of type `NUMBER`, representing a unique identifier for a political party; `p_region_id` of type `NUMBER`, representing a unique identifier for a geographical region; and `p_election_id` of type `NUMBER`, representing a unique identifier for an election.\n\nThe procedure begins by declaring four local variables: `v_is_active` of type `NUMBER`, initialized to `0`, intended to store the active status of a party within a region; `v_seats_contested` of type `NUMBER`, initialized to `0`, intended to store the number of seats contested in a specific election region; `v_party_performance_id` of type `NUMBER`, intended to store a newly generated identifier for a party's performance record; and `v_party_region_exists` of type `NUMBER`, initialized to `0`, intended to indicate whether a party-region association already exists.\n\nThe procedure then attempts to determine if a record exists in the `PARTY_REGION` table for the given `p_party_id` and `p_region_id`. It executes a `SELECT` statement to retrieve the value from the `IS_ACTIVE` column into the `v_is_active` variable where `PARTY_ID` matches `p_party_id` and `REGION_ID` matches `p_region_id`. If this `SELECT` statement successfully retrieves a row, it sets `v_party_region_exists` to `1`. If no data is found (i.e., a `NO_DATA_FOUND` exception occurs), it sets `v_is_active` to `0` and `v_party_region_exists` to `0`.\n\nNext, the procedure attempts to retrieve the number of contested seats for the specified election and region. It executes a `SELECT` statement to retrieve the value from the `SEATS_CONTESTED` column into the `v_seats_contested` variable from the `ELECTION_REGION` table where `ELECTION_ID` matches `p_election_id` and `REGION_ID` matches `p_region_id`. If no data is found (i.e., a `NO_DATA_FOUND` exception occurs), it sets `v_seats_contested` to `0`.\n\nSubsequently, the procedure generates a new `PARTY_PERFORMANCE_ID`. It executes a `SELECT` statement to find the maximum value of the `PARTY_PERFORMANCE_ID` column from the `PARTY_PERFORMANCE` table. It then uses the `NVL` function to treat a `NULL` result (if the table is empty) as `0`, adds `1` to this value, and stores the result in `v_party_performance_id`.\n\nFollowing these data retrievals, the procedure enters a conditional logic block:\n1. If `v_is_active` is `1` (meaning the party is active in the region) AND `v_seats_contested` is greater than `0` (meaning there are seats to contest in the election region), the procedure inserts a new record into the `PARTY_PERFORMANCE` table. The `PARTY_PERFORMANCE_ID` column is set to `v_party_performance_id`, `PARTY_ID` to `p_party_id`, `ELECTION_ID` to `p_election_id`, `CONTESTED_SEATS` to `v_seats_contested`, `WON_SEATS` to `0`, `VOTES_RECEIVED` to `0`, and `VOTE_SHARE` to `0`.\n2. ELSE IF `v_is_active` is `0` (meaning the party is not active in the region) AND `v_party_region_exists` is `1` (meaning a record for the party-region association exists but is inactive), the procedure deletes the corresponding record from the `PARTY_REGION` table where `PARTY_ID` matches `p_party_id` and `REGION_ID` matches `p_region_id`.\n3. ELSE IF `v_party_region_exists` is `0` (meaning no record for the party-region association exists), the procedure inserts a new record into the `PARTY_REGION` table. The `PARTY_ID` column is set to `p_party_id`, `REGION_ID` to `p_region_id`, and `IS_ACTIVE` to `1`.\n\nFinally, if any other exception occurs during the execution of the procedure, the procedure raises that exception.",
    "plsql": "CREATE OR REPLACE PROCEDURE synchronize_party_regions(\n    p_party_id NUMBER,\n    p_region_id NUMBER,\n    p_election_id NUMBER\n) IS\n    v_is_active NUMBER := 0;\n    v_seats_contested NUMBER := 0;\n    v_party_performance_id NUMBER;\n    v_party_region_exists NUMBER := 0;\nBEGIN\n    -- Check if party region exists and get active status\n    BEGIN\n        SELECT IS_ACTIVE INTO v_is_active\n        FROM PARTY_REGION\n        WHERE PARTY_ID = p_party_id\n        AND REGION_ID = p_region_id;\n        v_party_region_exists := 1;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_is_active := 0;\n            v_party_region_exists := 0;\n    END;\n\n    -- Get seats contested for the election region\n    BEGIN\n        SELECT SEATS_CONTESTED INTO v_seats_contested\n        FROM ELECTION_REGION\n        WHERE ELECTION_ID = p_election_id\n        AND REGION_ID = p_region_id;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_seats_contested := 0;\n    END;\n\n    -- Generate next party performance ID\n    SELECT NVL(MAX(PARTY_PERFORMANCE_ID), 0) + 1 INTO v_party_performance_id\n    FROM PARTY_PERFORMANCE;\n\n    IF v_is_active = 1 AND v_seats_contested > 0 THEN\n        INSERT INTO PARTY_PERFORMANCE (PARTY_PERFORMANCE_ID, PARTY_ID, ELECTION_ID, CONTESTED_SEATS, WON_SEATS, VOTES_RECEIVED, VOTE_SHARE)\n        VALUES (v_party_performance_id, p_party_id, p_election_id, v_seats_contested, 0, 0, 0);\n    ELSIF v_is_active = 0 AND v_party_region_exists = 1 THEN\n        DELETE FROM PARTY_REGION\n        WHERE PARTY_ID = p_party_id\n        AND REGION_ID = p_region_id;\n    ELSIF v_party_region_exists = 0 THEN\n        INSERT INTO PARTY_REGION (PARTY_ID, REGION_ID, IS_ACTIVE)\n        VALUES (p_party_id, p_region_id, 1);\n    END IF;\n    \n    COMMIT;\nEXCEPTION\n    WHEN OTHERS THEN\n        ROLLBACK;\n        RAISE;\nEND;",
    "database_name": "election_ravd_analysis",
    "tables": [
      "CANDIDATES",
      "ELECTIONS",
      "PARTIES",
      "PARTY_PERFORMANCE",
      "ELECTION_REGION",
      "PARTY_REGION"
    ],
    "call_sqls": [
      "BEGIN\n  synchronize_party_regions(p_party_id => 0, p_region_id => 0, p_election_id => 0);\nEND;",
      "BEGIN\n  synchronize_party_regions(p_party_id => 1, p_region_id => 1, p_election_id => 1);\nEND;",
      "BEGIN\n  synchronize_party_regions(p_party_id => 0, p_region_id => 1, p_election_id => 0);\nEND;",
      "BEGIN\n  synchronize_party_regions(p_party_id => 1, p_region_id => 0, p_election_id => 1);\nEND;",
      "BEGIN\n  synchronize_party_regions(p_party_id => 2, p_region_id => 2, p_election_id => 2);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named synchronize_party_regions that accepts a party ID, a region ID, and an election ID to manage associations between parties and regions and their election performance records. The procedure checks if the party is active in the region in the PARTY_REGION table and if seats are contested for that region in the election from the ELECTION_REGION table. If the party is active and seats are contested, it inserts a new record into the PARTY_PERFORMANCE table with the contested seats value and sets WON_SEATS, VOTES_RECEIVED, and VOTE_SHARE to zero, generating a new PARTY_PERFORMANCE_ID. If the party is inactive but a record exists in PARTY_REGION, it deletes that party-region record. If no party-region record exists, it inserts a new active record into PARTY_REGION. Missing data for active status or contested seats defaults to zero.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called synchronize_party_regions that accepts a party identifier, a region identifier, and an election identifier to manage the associations between political parties and geographical regions along with their electoral performance records. The procedure must first check if the specified party is active in the given region in the PARTY_REGION table and if any legislative seats were contested in that region during the specified election in the ELECTION_REGION table. If the party is active and seats were contested, insert a new performance record into the PARTY_PERFORMANCE table with the contested seats count and set all other metricsseats won, votes received, and vote shareto zero. If the party is inactive but an existing association record is found in PARTY_REGION, delete that record. If no party-to-region association exists initially, create a new one in PARTY_REGION and mark it as active. Ensure any missing numerical data defaults to zero.",
    "id": 58,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `synchronize_party_regions` that accepts three input parameters: `p_party_id` of type `NUMBER`, representing a unique identifier for a political party; `p_region_id` of type `NUMBER`, representing a unique identifier for a geographical region; and `p_election_id` of type `NUMBER`, representing a unique identifier for an election.\n\nThe procedure begins by declaring four local variables: `v_is_active` of type `NUMBER`, initialized to `0`, intended to store the active status of a party within a region; `v_seats_contested` of type `NUMBER`, initialized to `0`, intended to store the number of seats contested in a specific election region; `v_party_performance_id` of type `NUMBER`, intended to store a newly generated identifier for a party's performance record; and `v_party_region_exists` of type `NUMBER`, initialized to `0`, intended to indicate whether a party-region association already exists.\n\nThe procedure then attempts to determine if a record exists in the `PARTY_REGION` table for the given `p_party_id` and `p_region_id`. It executes a `SELECT` statement to retrieve the value from the `IS_ACTIVE` column into the `v_is_active` variable where `PARTY_ID` matches `p_party_id` and `REGION_ID` matches `p_region_id`. If this `SELECT` statement successfully retrieves a row, it sets `v_party_region_exists` to `1`. If no data is found (i.e., a `NO_DATA_FOUND` exception occurs), it sets `v_is_active` to `0` and `v_party_region_exists` to `0`.\n\nNext, the procedure attempts to retrieve the number of contested seats for the specified election and region. It executes a `SELECT` statement to retrieve the value from the `SEATS_CONTESTED` column into the `v_seats_contested` variable from the `ELECTION_REGION` table where `ELECTION_ID` matches `p_election_id` and `REGION_ID` matches `p_region_id`. If no data is found (i.e., a `NO_DATA_FOUND` exception occurs), it sets `v_seats_contested` to `0`.\n\nSubsequently, the procedure generates a new `PARTY_PERFORMANCE_ID`. It executes a `SELECT` statement to find the maximum value of the `PARTY_PERFORMANCE_ID` column from the `PARTY_PERFORMANCE` table. It then uses the `NVL` function to treat a `NULL` result (if the table is empty) as `0`, adds `1` to this value, and stores the result in `v_party_performance_id`.\n\nFollowing these data retrievals, the procedure enters a conditional logic block:\n1. If `v_is_active` is `1` (meaning the party is active in the region) AND `v_seats_contested` is greater than `0` (meaning there are seats to contest in the election region), the procedure inserts a new record into the `PARTY_PERFORMANCE` table. The `PARTY_PERFORMANCE_ID` column is set to `v_party_performance_id`, `PARTY_ID` to `p_party_id`, `ELECTION_ID` to `p_election_id`, `CONTESTED_SEATS` to `v_seats_contested`, `WON_SEATS` to `0`, `VOTES_RECEIVED` to `0`, and `VOTE_SHARE` to `0`.\n2. ELSE IF `v_is_active` is `0` (meaning the party is not active in the region) AND `v_party_region_exists` is `1` (meaning a record for the party-region association exists but is inactive), the procedure deletes the corresponding record from the `PARTY_REGION` table where `PARTY_ID` matches `p_party_id` and `REGION_ID` matches `p_region_id`.\n3. ELSE IF `v_party_region_exists` is `0` (meaning no record for the party-region association exists), the procedure inserts a new record into the `PARTY_REGION` table. The `PARTY_ID` column is set to `p_party_id`, `REGION_ID` to `p_region_id`, and `IS_ACTIVE` to `1`.\n\nFinally, if any other exception occurs during the execution of the procedure, the procedure raises that exception.",
    "original_summary": "Create a stored procedure named synchronize_party_regions that manages party-region associations and election performance records. It accepts party, region, and election IDs. The procedure checks if the party is active in the region and if seats are contested in that region for the election. If both are true, it inserts a new performance record with contested seats set and other metrics zeroed. If the party is inactive but a region record exists, it deletes that record. If no party-region record exists, it inserts a new active one. It handles missing data by defaulting values to 0.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Develop a comprehensive stored procedure, to be designated as synchronize_party_regions, which meticulously orchestrates the intricate associations between political parties and geographical regions while concurrently managing detailed records of electoral performance. This sophisticated procedure is designed to accept specific identifiers for a party, a region, and an election as its input parameters. Its operational logic thoroughly examines, first, whether the specified party maintains an active status within the given region and, second, whether any legislative seats were contested in that same region during the particular election in question. Should both of these detailed conditions be affirmatively verified, the procedure will then carefully insert a brand-new performance record, explicitly setting the contested seats count while prudently initializing all other performance metricssuch as seats won, votes garnered, and percentage of the voteto a baseline value of zero. In the contrasting scenario where the party is found to be inactive within the region, yet a pre-existing association record is present, the procedure will systematically delete that obsolete record to ensure data cleanliness. Furthermore, if an initial check reveals that no foundational party-to-region association record exists whatsoever, the procedure will intelligently create and insert a new one, automatically marking its status as active. Throughout this entire process, the procedure gracefully handles any instances of missing or incomplete data by sensibly defaulting all unspecified numerical values to a secure and neutral zero."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named P_CLEANUP_OLD_ACCESS_LOGS that accepts a single input parameter p_days_old of type NUMBER, which represents the number of days to determine the age threshold for log entries. The procedure calculates a cutoff date by subtracting the value of p_days_old from the current date using the CURRENT_DATE function, and then converts this resulting date into a string formatted as 'YYYY-MM-DD' using the TO_CHAR function, storing it in a local variable v_cutoff_date of type VARCHAR2(255). The procedure then performs a DELETE operation on the ACCESS_LOGS table, removing all rows where the ACCESS_DATE column contains a date value that is earlier than the calculated cutoff date stored in v_cutoff_date.",
    "plsql": "CREATE OR REPLACE PROCEDURE P_CLEANUP_OLD_ACCESS_LOGS (p_days_old IN NUMBER)\nIS\n    v_cutoff_date VARCHAR2(255);\nBEGIN\n    v_cutoff_date := TO_CHAR(CURRENT_DATE - p_days_old, 'YYYY-MM-DD');\n    DELETE FROM ACCESS_LOGS\n    WHERE ACCESS_DATE < v_cutoff_date;\nEND;",
    "database_name": "demographic_aeda_192071",
    "tables": [
      "ACCESS_LOGS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  P_CLEANUP_OLD_ACCESS_LOGS(p_days_old => 7);\nEND;",
      "BEGIN\n  P_CLEANUP_OLD_ACCESS_LOGS(p_days_old => 30);\nEND;",
      "BEGIN\n  P_CLEANUP_OLD_ACCESS_LOGS(p_days_old => 90);\nEND;",
      "BEGIN\n  P_CLEANUP_OLD_ACCESS_LOGS(p_days_old => 1);\nEND;",
      "BEGIN\n  P_CLEANUP_OLD_ACCESS_LOGS(p_days_old => 365);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named P_CLEANUP_OLD_ACCESS_LOGS that accepts a parameter p_days_old representing the number of days to retain logs, and deletes all rows from the ACCESS_LOGS table where the ACCESS_DATE is older than the current date minus the specified number of days.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called P_CLEANUP_OLD_ACCESS_LOGS that takes a number parameter for days and removes old entries from the ACCESS_LOGS table where the ACCESS_DATE is earlier than the date calculated by subtracting that number of days from today.",
    "id": 59,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named P_CLEANUP_OLD_ACCESS_LOGS that accepts a single input parameter p_days_old of type NUMBER, which represents the number of days to determine the age threshold for log entries. The procedure calculates a cutoff date by subtracting the value of p_days_old from the current date using the CURRENT_DATE function, and then converts this resulting date into a string formatted as 'YYYY-MM-DD' using the TO_CHAR function, storing it in a local variable v_cutoff_date of type VARCHAR2(255). The procedure then performs a DELETE operation on the ACCESS_LOGS table, removing all rows where the ACCESS_DATE column contains a date value that is earlier than the calculated cutoff date stored in v_cutoff_date.",
    "original_summary": "Create a stored procedure named P_CLEANUP_OLD_ACCESS_LOGS that accepts a parameter p_days_old (NUMBER). It deletes rows from the ACCESS_LOGS table where the ACCESS_DATE is older than the date calculated by subtracting p_days_old from the current date.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called P_CLEANUP_OLD_ACCESS_LOGS that takes a number parameter for days. It should get rid of old entries from the ACCESS_LOGS table where the access happened quite a while back, specifically before a date you get by taking away that number of days from today."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named delete_old_health_metrics that accepts a single parameter, para_date, of type VARCHAR2. This procedure performs a delete operation on the HEALTH_METRICS table, specifically removing rows where the METRIC_ID matches any METRIC_ID obtained from a subquery. The subquery selects METRIC_IDs from the HEALTH_METRICS table, aliased as hm, which are joined with the DIABETES_RISK_SCORES table, aliased as drs, based on matching PATIENT_ID values between the two tables. The condition for selecting these METRIC_IDs is that the ASSESSMENT_DATE column in the DIABETES_RISK_SCORES table is earlier than the date specified by the para_date parameter. The procedure does not perform any other operations, such as updates or inserts, and does not include any conditional statements or function calls.",
    "plsql": "CREATE OR REPLACE PROCEDURE delete_old_health_metrics(para_date VARCHAR2) IS\nBEGIN\n  DELETE FROM HEALTH_METRICS\n  WHERE METRIC_ID IN (\n    SELECT METRIC_ID FROM HEALTH_METRICS hm\n    JOIN DIABETES_RISK_SCORES drs ON hm.PATIENT_ID = drs.PATIENT_ID\n    WHERE drs.ASSESSMENT_DATE < para_date\n  );\nEND;",
    "database_name": "healthcare_dmadr_assessme",
    "tables": [
      "DIABETES_RISK_SCORES",
      "HEALTH_METRICS",
      "PATIENTS",
      "STUDY_PARTICIPANTS"
    ],
    "call_sqls": [
      "BEGIN\n  delete_old_health_metrics('2023-01-01');\nEND;",
      "BEGIN\n  delete_old_health_metrics('2023-01-15');\nEND;",
      "BEGIN\n  delete_old_health_metrics('2023-02-01');\nEND;",
      "BEGIN\n  delete_old_health_metrics('2022-12-31');\nEND;",
      "BEGIN\n  delete_old_health_metrics('2023-03-01');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named delete_old_health_metrics that accepts a date parameter and deletes all records from the HEALTH_METRICS table for which the METRIC_ID corresponds to any patient's health metrics where that patient's DIABETES_RISK_SCORES assessment date in the DIABETES_RISK_SCORES table is older than the provided date.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called delete_old_health_metrics that takes a date as input and deletes all records from the HEALTH_METRICS table for any metric where the linked patient has an ASSESSMENT_DATE in the DIABETES_RISK_SCORES table that is older than the provided date.",
    "id": 60,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named delete_old_health_metrics that accepts one input parameter: p_cutoff_date of type DATE, which represents the cutoff date for determining which records to delete. The procedure does not have any output parameters.\n\nThe procedure begins by executing a DELETE statement on the HEALTH_METRICS table. The deletion is performed based on a subquery that identifies which records to remove. Specifically, the DELETE statement targets rows in the HEALTH_METRICS table where the patient_id column matches a patient_id from the DIABETES_RISK_SCORES table, and where the ASSESSMENT_DATE column in the DIABETES_RISK_SCORES table is strictly less than the input parameter p_cutoff_date. This ensures that only health metrics linked to patients whose most recent assessment date is older than the provided cutoff date are deleted.\n\nThe procedure includes an exception handling block. If any unhandled exception (OTHERS) occurs during the execution of the DELETE operation, it catches the exception and outputs a line to the DBMS_OUTPUT buffer indicating \"Error deleting old health metrics: \" followed by the error message obtained from SQLERRM.",
    "original_summary": "Create a stored procedure named delete_old_health_metrics that accepts a date. It deletes rows from the HEALTH_METRICS table where the METRIC_ID matches any ID from metrics linked to patients whose DIABETES_RISK_SCORES assessment date is earlier than the provided date.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure called 'delete_old_health_metrics' that takes a date as input and deletes records from the HEALTH_METRICS table for any metric linked to a patient whose DIABETES_RISK_SCORES assessment date is older than the provided date?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named UpdateDepartmentContact that accepts two parameters: p_department_id, which is of type NUMBER and represents the unique identifier of a department, and p_new_email, which is of type VARCHAR2 and represents the new email address to be set for the department's contact. The procedure performs an update operation on the DEPARTMENTS table, specifically targeting the CONTACT_EMAIL column. It sets the CONTACT_EMAIL column to the value provided in the p_new_email parameter for the row where the DEPARTMENT_ID column matches the value of the p_department_id parameter. The procedure does not include any conditional statements beyond the WHERE clause used to identify the specific row to update based on the department ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateDepartmentContact(\n    p_department_id IN NUMBER,\n    p_new_email IN VARCHAR2\n) AS\nBEGIN\n    UPDATE DEPARTMENTS\n    SET CONTACT_EMAIL = p_new_email\n    WHERE DEPARTMENT_ID = p_department_id;\nEND;",
    "database_name": "university_cmas_approval",
    "tables": [
      "COURSES",
      "COURSE_PROPOSALS",
      "DEPARTMENTS",
      "PERMISSIONS",
      "SYLLABI",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  UpdateDepartmentContact(0, 'newhonors@university.edu');\n  commit;\nEND;",
      "BEGIN\n  UpdateDepartmentContact(1, 'newanthro@university.edu');\n  commit;\nEND;",
      "BEGIN\n  UpdateDepartmentContact(0, 'contact@university.edu');\n  commit;\nEND;",
      "BEGIN\n  UpdateDepartmentContact(1, 'depthead@university.edu');\n  commit;\nEND;",
      "BEGIN\n  UpdateDepartmentContact(0, 'info@university.edu');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named UpdateDepartmentContact that updates the CONTACT_EMAIL in the DEPARTMENTS table for a given DEPARTMENT_ID, setting it to a provided new email address.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called UpdateDepartmentContact that updates the CONTACT_EMAIL in the DEPARTMENTS table for a specific department identified by its DEPARTMENT_ID, using the provided new email.",
    "id": 61,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateDepartmentContact that accepts two parameters: p_department_id (an input parameter of type NUMBER representing the unique identifier of the department to update) and p_new_email (an input parameter of type VARCHAR2 representing the new contact email address to set). The procedure performs a single UPDATE operation on the DEPARTMENTS table, setting the CONTACT_EMAIL column to the value of p_new_email for the row where the DEPARTMENT_ID column exactly matches the value of p_department_id. The procedure does not return any value and completes after executing the update.",
    "original_summary": "Create a stored procedure named UpdateDepartmentContact that updates the CONTACT_EMAIL column in the DEPARTMENTS table for a specific DEPARTMENT_ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create a stored procedure to update the contact email for a department, but make it so it only changes the email for a particular department ID, not all of them. The procedure should be called UpdateDepartmentContact and it works on the DEPARTMENTS table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_insert_weather_event that accepts three input parameters: a numeric para_Station_ID, a numeric para_Condition_ID, and a string para_Description. The procedure first validates the existence of the provided para_Condition_ID by performing a count query on the WEATHER_CONDITIONS table, specifically checking the CONDITION_ID column for a match; if the count result is zero, it raises an application error stating the Condition_ID is invalid. Next, it validates the provided para_Station_ID by performing a count query on the WEATHER_STATIONS table, specifically checking the STATION_ID column for a match; if this count result is zero, it raises a different application error stating the Station_ID is invalid. Following successful validations, the procedure generates a new unique EVENT_ID by querying the WEATHER_EVENTS table to find the current maximum value in the EVENT_ID column, using the NVL function to default to 0 if the table is empty, and then adding 1 to this result. It then inserts a new row into the WEATHER_EVENTS table, populating the columns as follows: the generated v_event_id for EVENT_ID, the input para_Station_ID for STATION_ID, the current system date converted to a 'YYYY-MM-DD' format string using TO_CHAR and SYSDATE for the EST column, the input para_Condition_ID for CONDITION_ID, the input para_Description for the DESCRIPTION column, the hardcoded string 'low' for the SEVERITY column, the hardcoded string 'Unknown' for the IMPACT_AREA column, and the hardcoded string 'inactive' for the ALERT_STATUS column.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_insert_weather_event(\n    para_Station_ID   NUMBER,\n    para_Condition_ID NUMBER,\n    para_Description  VARCHAR2\n) IS\n    v_event_id NUMBER;\n    v_condition_exists NUMBER;\n    v_station_exists NUMBER;\nBEGIN\n    -- Validate Condition_ID exists in WEATHER_CONDITIONS\n    SELECT COUNT(*)\n    INTO v_condition_exists\n    FROM WEATHER_CONDITIONS\n    WHERE CONDITION_ID = para_Condition_ID;\n\n    IF v_condition_exists = 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Invalid Condition_ID: ' || para_Condition_ID || ' does not exist in WEATHER_CONDITIONS');\n    END IF;\n\n    -- Validate Station_ID exists in WEATHER_STATIONS\n    SELECT COUNT(*)\n    INTO v_station_exists\n    FROM WEATHER_STATIONS\n    WHERE STATION_ID = para_Station_ID;\n\n    IF v_station_exists = 0 THEN\n        RAISE_APPLICATION_ERROR(-20002, 'Invalid Station_ID: ' || para_Station_ID || ' does not exist in WEATHER_STATIONS');\n    END IF;\n\n    -- Generate new EVENT_ID safely\n    SELECT NVL(MAX(EVENT_ID), 0) + 1\n    INTO v_event_id\n    FROM WEATHER_EVENTS;\n\n    -- Insert the weather event\n    INSERT INTO WEATHER_EVENTS (\n        EVENT_ID,\n        STATION_ID,\n        EST,\n        CONDITION_ID,\n        DESCRIPTION,\n        SEVERITY,\n        IMPACT_AREA,\n        ALERT_STATUS\n    ) VALUES (\n        v_event_id,\n        para_Station_ID,\n        TO_CHAR(SYSDATE, 'YYYY-MM-DD'),\n        para_Condition_ID,\n        para_Description,\n        'low',\n        'Unknown',\n        'inactive'\n    );\n\n    COMMIT;\nEXCEPTION\n    WHEN OTHERS THEN\n        ROLLBACK;\n        RAISE;\nEND;",
    "database_name": "weather_oaf_92747",
    "tables": [
      "PREDICTIONS",
      "PREDICTION_MODELS",
      "WEATHER_CONDITIONS",
      "WEATHER_DATA",
      "WEATHER_EVENTS",
      "WEATHER_STATIONS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_insert_weather_event(0, 1, 'Clear skies');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_insert_weather_event(1, 0, 'Light rain');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_insert_weather_event(0, 0, 'Sunny day');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_insert_weather_event(1, 1, 'Rainy afternoon');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_insert_weather_event(0, 1, 'Partly cloudy');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_insert_weather_event that accepts a station ID, a condition ID, and a description to insert a new weather event into the WEATHER_EVENTS table. The procedure must validate that the provided condition ID exists in the WEATHER_CONDITIONS table and that the station ID exists in the WEATHER_STATIONS table, raising an error if either does not exist. It should generate a new unique event ID by incrementing the maximum existing EVENT_ID from the WEATHER_EVENTS table. The new record should include the generated event ID, the input station ID, condition ID, and description, along with the current date for EST, and default values of 'low' for SEVERITY, 'Unknown' for IMPACT_AREA, and 'inactive' for ALERT_STATUS.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called `sp_insert_weather_event` that takes a station ID, a condition ID, and a description to insert a new weather event. It must first verify that the provided condition ID exists in the WEATHER_CONDITIONS table and that the station ID exists in the WEATHER_STATIONS table, raising an error if either is invalid. Then, it should generate a new event ID by taking the maximum existing EVENT_ID from the WEATHER_EVENTS table and adding 1. Finally, it inserts a new row into the WEATHER_EVENTS table with this new event ID, the input station ID and condition ID, the input description, today's date for EST, and default values of 'low' for SEVERITY, 'Unknown' for IMPACT_AREA, and 'inactive' for ALERT_STATUS.",
    "id": 62,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_insert_weather_event that accepts three input parameters: a numeric para_Station_ID, a numeric para_Condition_ID, and a string para_Description. The procedure first validates the existence of the provided para_Condition_ID by performing a count query on the WEATHER_CONDITIONS table, specifically checking the CONDITION_ID column for a match; if the count result is zero, it raises an application error stating the Condition_ID is invalid. Next, it validates the provided para_Station_ID by performing a count query on the WEATHER_STATIONS table, specifically checking the STATION_ID column for a match; if this count result is zero, it raises a different application error stating the Station_ID is invalid. Following successful validations, the procedure generates a new unique EVENT_ID by querying the WEATHER_EVENTS table to find the current maximum value in the EVENT_ID column, using the NVL function to default to 0 if the table is empty, and then adding 1 to this result. It then inserts a new row into the WEATHER_EVENTS table, populating the columns as follows: the generated v_event_id for EVENT_ID, the input para_Station_ID for STATION_ID, the current system date converted to a 'YYYY-MM-DD' format string using TO_CHAR and SYSDATE for the EST column, the input para_Condition_ID for CONDITION_ID, the input para_Description for the DESCRIPTION column, the hardcoded string 'low' for the SEVERITY column, the hardcoded string 'Unknown' for the IMPACT_AREA column, and the hardcoded string 'inactive' for the ALERT_STATUS column.",
    "original_summary": "Create a stored procedure named `sp_insert_weather_event` that accepts station ID, condition ID, and description parameters. Validate the condition ID and station ID exist. Generate a new event ID by incrementing the maximum existing ID. Insert a new weather event with the generated ID, input parameters, current date, and default values for severity, impact area, and alert status.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Alright, so we need a stored procedure called `sp_insert_weather_event`. It's gotta take in a station ID, a condition ID, and a description. First thing, check that both the condition ID and station ID are actually real in the database. Then, to get a new event ID, just find the biggest ID we already have and add 1 to it. Finally, pop in a new weather event row using that new ID, the stuff we got as input, today's date, and just stick in some standard defaults for how bad it is, the area it affects, and whether there's an alert."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_handle_team_reassignment that accepts two input parameters: para_OLD_TEAM_ID of type NUMBER, which represents the unique identifier of the team from which members are being reassessed, and para_NEW_TEAM_ID of type NUMBER, which represents the unique identifier for the new team to be potentially created. The procedure begins by declaring a local variable v_member_count of type NUMBER. It then executes a SELECT statement to query the TEAM_MEMBERS table, counting all rows where the TEAM_ID column matches the value of the input parameter para_OLD_TEAM_ID, and stores this count result into the variable v_member_count. Following this, the procedure uses an IF conditional statement to check if the value of v_member_count is greater than zero, meaning the old team has at least one member. If this condition is true, the procedure performs an INSERT operation into the RESEARCH_TEAMS table. The INSERT statement specifies the columns TEAM_ID, TEAM_NAME, LEAD_RESEARCHER, and DESCRIPTION for insertion. It uses a SELECT subquery to populate these values: for the TEAM_ID column, it uses the constant value from the input parameter para_NEW_TEAM_ID; for the TEAM_NAME and LEAD_RESEARCHER columns, it selects the corresponding TEAM_NAME and LEAD_RESEARCHER column values from the RESEARCH_TEAMS table where the TEAM_ID matches the input parameter para_OLD_TEAM_ID; and for the DESCRIPTION column, it explicitly inserts an EMPTY_BLOB() function call to initialize an empty Binary Large Object.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_handle_team_reassignment(para_OLD_TEAM_ID NUMBER, para_NEW_TEAM_ID NUMBER) IS\n  v_member_count NUMBER;\nBEGIN\n  SELECT COUNT(*)\n  INTO v_member_count\n  FROM TEAM_MEMBERS\n  WHERE TEAM_ID = para_OLD_TEAM_ID;\n  \n  IF v_member_count > 0 THEN\n    INSERT INTO RESEARCH_TEAMS (TEAM_ID, TEAM_NAME, LEAD_RESEARCHER, DESCRIPTION)\n    SELECT para_NEW_TEAM_ID, TEAM_NAME, LEAD_RESEARCHER, EMPTY_BLOB()\n    FROM RESEARCH_TEAMS\n    WHERE TEAM_ID = para_OLD_TEAM_ID;\n  END IF;\nEND;",
    "database_name": "global_hawbi_549073",
    "tables": [
      "RESEARCH_TEAMS",
      "TEAM_MEMBERS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_handle_team_reassignment(0, 100);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_handle_team_reassignment(1, 101);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_handle_team_reassignment(10, 200);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_handle_team_reassignment(5, 50);\n  COMMIT;\nEND;",
      "BEGIN\n  sp_handle_team_reassignment(2, 300);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_handle_team_reassignment that accepts an old team ID and a new team ID, checks if there are any members in the TEAM_MEMBERS table for the old team, and if members exist, creates a new team in the RESEARCH_TEAMS table using the new team ID, copying the TEAM_NAME and LEAD_RESEARCHER from the old team while initializing the DESCRIPTION as an empty BLOB.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_handle_team_reassignment that takes an old team ID and a new team ID. It should check if there are any members in the old team in the TEAM_MEMBERS table, and if there are, create a new team in the RESEARCH_TEAMS table using the new team ID, copying the TEAM_NAME and LEAD_RESEARCHER from the old team, and initializing the DESCRIPTION as an empty BLOB.",
    "id": 63,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_handle_team_reassignment that accepts two input parameters: para_OLD_TEAM_ID of type NUMBER, which represents the unique identifier of the team from which members are being reassessed, and para_NEW_TEAM_ID of type NUMBER, which represents the unique identifier for the new team to be potentially created. The procedure begins by declaring a local variable v_member_count of type NUMBER. It then executes a SELECT statement to query the TEAM_MEMBERS table, counting all rows where the TEAM_ID column matches the value of the input parameter para_OLD_TEAM_ID, and stores this count result into the variable v_member_count. Following this, the procedure uses an IF conditional statement to check if the value of v_member_count is greater than zero, meaning the old team has at least one member. If this condition is true, the procedure performs an INSERT operation into the RESEARCH_TEAMS table. The INSERT statement specifies the columns TEAM_ID, TEAM_NAME, LEAD_RESEARCHER, and DESCRIPTION for insertion. It uses a SELECT subquery to populate these values: for the TEAM_ID column, it uses the constant value from the input parameter para_NEW_TEAM_ID; for the TEAM_NAME and LEAD_RESEARCHER columns, it selects the corresponding TEAM_NAME and LEAD_RESEARCHER column values from the RESEARCH_TEAMS table where the TEAM_ID matches the input parameter para_OLD_TEAM_ID; and for the DESCRIPTION column, it explicitly inserts an EMPTY_BLOB() function call to initialize an empty Binary Large Object.",
    "original_summary": "Create a stored procedure named sp_handle_team_reassignment that accepts an old team ID and a new team ID. Count the members in the old team. If members exist, create a new team with the new ID, copying the old team's name and lead researcher, and initialize its description as an empty BLOB.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Alright, so we need a stored procedure called sp_handle_team_reassignment. It's gotta take an old team ID and a new team ID. First, check how many folks are in the old team. If there's anyone there, we gotta set up a brand new team using the new ID. Just copy over the old team's name and who's leading it, and kick off its description as a totally empty BLOB."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_user_status that accepts three parameters: para_User_ID of type NUMBER, para_Status of type VARCHAR2, and para_Last_Login of type VARCHAR2. This procedure performs an update operation on the USERS table, specifically modifying the STATUS and LAST_LOGIN columns. The STATUS column is set to the value provided by the para_Status parameter, and the LAST_LOGIN column is updated to the value given by the para_Last_Login parameter. The update operation targets rows where the USER_ID column matches the value specified by the para_User_ID parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_user_status(para_User_ID NUMBER, para_Status VARCHAR2, para_Last_Login VARCHAR2) IS\nBEGIN\n  UPDATE USERS\n  SET STATUS = para_Status, LAST_LOGIN = para_Last_Login\n  WHERE USER_ID = para_User_ID;\nEND;",
    "database_name": "weather_oaf_92747",
    "tables": [
      "PREDICTIONS",
      "PREDICTION_MODELS",
      "WEATHER_CONDITIONS",
      "WEATHER_DATA",
      "WEATHER_EVENTS",
      "WEATHER_STATIONS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_user_status(0, 'active', '2023-10-03 14:30:00');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_user_status(1, 'inactive', '2023-10-02 09:15:00');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_user_status(2, 'suspended', '2023-09-28 16:45:00');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_user_status(0, 'active', '2023-10-04 08:00:00');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_update_user_status(1, 'active', '2023-10-03 11:20:00');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_update_user_status that updates a user's record in the USERS table by setting their STATUS and LAST_LOGIN columns to the provided status and last login values for the specific user identified by the given user ID.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL stored procedure called `sp_update_user_status`? It needs to take a user's ID, their status, and when they last logged in, and then update the STATUS and LAST_LOGIN fields in the USERS table for that specific user's record.",
    "id": 64,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp_update_user_status` that accepts three input parameters: `p_user_id` of data type `NUMBER`, which uniquely identifies a user record in the `USERS` table; `p_status` of data type `VARCHAR2`, which represents the new status value to be assigned; and `p_last_login` of data type `DATE`, which represents the new timestamp for the user's last login activity. The procedure performs a single `UPDATE` operation on the `USERS` table. This `UPDATE` statement modifies two columns: it sets the `STATUS` column to the value provided in the `p_status` input parameter, and it sets the `LAST_LOGIN` column to the value provided in the `p_last_login` input parameter. The `UPDATE` operation is precisely targeted using a `WHERE` clause that ensures only the row where the `USER_ID` column in the `USERS` table exactly matches the value provided in the `p_user_id` input parameter is affected. The procedure does not return a value; its purpose is solely to modify the specified record in the database.",
    "original_summary": "Create a stored procedure named `sp_update_user_status` that accepts user ID, status, and last login parameters. Update the USERS table to set the STATUS and LAST_LOGIN columns for the row matching the given user ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called `sp_update_user_status`? It needs to take a user's ID, their status, and when they last logged in. Then, just go into the USERS table and update the STATUS and LAST_LOGIN fields for that specific user's record."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes a parameter para_quality_threshold of type VARCHAR2 and iterates over records from a join between the MEASUREMENTS table and the SENSORS table, where the DATA_QUALITY column in the MEASUREMENTS table matches the para_quality_threshold parameter. For each record, it retrieves the MEASUREMENT_ID and SENSOR_TYPE columns. If the SENSOR_TYPE is 'air temperature', it selects the AIR_TEMPERATURE value from the AIR_TEMPERATURE_MEASUREMENTS table where the MEASUREMENT_ID matches the retrieved MEASUREMENT_ID, then updates the AIR_TEMPERATURE column in the same table by multiplying the retrieved AIR_TEMPERATURE value by 1.1. If the SENSOR_TYPE is 'wind speed', it selects the U_WIND_SPEED value from the WIND_SPEED_MEASUREMENTS table where the MEASUREMENT_ID matches the retrieved MEASUREMENT_ID, then updates the U_WIND_SPEED column in the same table by multiplying the retrieved U_WIND_SPEED value by 0.9.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_quality_threshold VARCHAR2) IS\n    v_measurement_id NUMBER;\n    v_sensor_type VARCHAR2(255);\n    v_temp_value NUMBER;\n    v_wind_value NUMBER;\nBEGIN\n    FOR rec IN (SELECT m.MEASUREMENT_ID, s.SENSOR_TYPE FROM MEASUREMENTS m JOIN SENSORS s ON m.SENSOR_ID = s.SENSOR_ID WHERE m.DATA_QUALITY = para_quality_threshold) LOOP\n        v_measurement_id := rec.MEASUREMENT_ID;\n        v_sensor_type := rec.SENSOR_TYPE;\n        IF v_sensor_type = 'air temperature' THEN\n            SELECT AIR_TEMPERATURE INTO v_temp_value FROM AIR_TEMPERATURE_MEASUREMENTS WHERE MEASUREMENT_ID = v_measurement_id;\n            UPDATE AIR_TEMPERATURE_MEASUREMENTS SET AIR_TEMPERATURE = v_temp_value * 1.1 WHERE MEASUREMENT_ID = v_measurement_id;\n        ELSIF v_sensor_type = 'wind speed' THEN\n            SELECT U_WIND_SPEED INTO v_wind_value FROM WIND_SPEED_MEASUREMENTS WHERE MEASUREMENT_ID = v_measurement_id;\n            UPDATE WIND_SPEED_MEASUREMENTS SET U_WIND_SPEED = v_wind_value * 0.9 WHERE MEASUREMENT_ID = v_measurement_id;\n        END IF;\n    END LOOP;\nEND;",
    "database_name": "weather_maf_868568",
    "tables": [
      "MEASUREMENTS",
      "SENSORS",
      "SENSOR_CALIBRATION",
      "WEATHER_STATIONS",
      "WEATHER_FORECASTS",
      "AIR_TEMPERATURE_MEASUREMENTS",
      "WIND_SPEED_MEASUREMENTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp('good');\n  commit;\nEND;",
      "BEGIN\n  sp('excellent');\n  commit;\nEND;",
      "BEGIN\n  sp('poor');\n  commit;\nEND;",
      "BEGIN\n  sp('average');\n  commit;\nEND;",
      "BEGIN\n  sp('bad');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp that takes a parameter para_quality_threshold representing a data quality level. For all records from the MEASUREMENTS and SENSORS tables where the DATA_QUALITY matches the provided threshold, retrieve the MEASUREMENT_ID and SENSOR_TYPE. If the SENSOR_TYPE is 'air temperature', update the corresponding air temperature value in the AIR_TEMPERATURE_MEASUREMENTS table by increasing it by 10% (multiplying by 1.1). If the SENSOR_TYPE is 'wind speed', update the corresponding wind speed value in the WIND_SPEED_MEASUREMENTS table by decreasing it by 10% (multiplying by 0.9).",
    "natural_language": "Write a Oracle PL/SQL stored procedure named sp that, for each record from the join of MEASUREMENTS and SENSORS where DATA_QUALITY matches a given threshold, retrieves the MEASUREMENT_ID and SENSOR_TYPE, and then updates the air temperature by multiplying it by 1.1 in the AIR_TEMPERATURE_MEASUREMENTS table if the sensor type is 'air temperature', or updates the wind speed by multiplying it by 0.9 in the WIND_SPEED_MEASUREMENTS table if the sensor type is 'wind speed'.",
    "id": 65,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that accepts one input parameter: p_data_quality_threshold (a VARCHAR2 or NUMBER, depending on the actual data type of the DATA_QUALITY column, representing the threshold value for data quality). The procedure performs a cursor-based loop over a result set obtained from a SELECT query that joins the MEASUREMENTS table and the SENSORS table. The SELECT query retrieves the MEASUREMENT_ID column and the SENSOR_TYPE column for each record where the DATA_QUALITY column from the joined tables matches the value of the p_data_quality_threshold parameter. For each row fetched by the cursor, the procedure checks the value of the SENSOR_TYPE column. If the SENSOR_TYPE is exactly 'air temperature', the procedure executes an UPDATE operation on the AIR_TEMPERATURE_MEASUREMENTS table. This UPDATE sets the air temperature column (the specific column name is not provided, but it is implied to be a column storing air temperature values) to its current value multiplied by 1.1, specifically for the row where the MEASUREMENT_ID column in the AIR_TEMPERATURE_MEASUREMENTS table matches the MEASUREMENT_ID value retrieved from the cursor. Alternatively, if the SENSOR_TYPE is exactly 'wind speed', the procedure executes an UPDATE operation on the WIND_SPEED_MEASUREMENTS table. This UPDATE sets the wind speed column (the specific column name is not provided, but it is implied to be a column storing wind speed values) to its current value multiplied by 0.9, specifically for the row where the MEASUREMENT_ID column in the WIND_SPEED_MEASUREMENTS table matches the MEASUREMENT_ID value retrieved from the cursor. The procedure does not return any value; it performs the updates in a loop until all qualifying records from the join are processed.",
    "original_summary": "Create a PL/SQL procedure that takes a VARCHAR2 parameter para_quality_threshold. For each record from a join of MEASUREMENTS and SENSORS where DATA_QUALITY matches the parameter, get the MEASUREMENT_ID and SENSOR_TYPE. If SENSOR_TYPE is 'air temperature', retrieve and update the corresponding air temperature by multiplying it by 1.1. If SENSOR_TYPE is 'wind speed', retrieve and update the corresponding wind speed by multiplying it by 0.9.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "For each record from the join of MEASUREMENTS and SENSORS where DATA_QUALITY matches a given threshold, how can I get the MEASUREMENT_ID and SENSOR_TYPE, and then update the air temperature by 1.1 or the wind speed by 0.9 based on the sensor type?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdateBlockSequence` that accepts three parameters: `p_block_id` of data type `NUMBER` as an input parameter, representing the unique identifier of the block to be updated; `p_new_sequence_order` of data type `NUMBER` as an input parameter, representing the new sequence order value to be assigned to the specified block; and `p_updated` of data type `NUMBER` as an output parameter, which will indicate whether the update operation was successful (typically `1` for success, `0` for no rows updated). The procedure performs a single `UPDATE` operation on the `BLOCKS` table. Specifically, it sets the value of the `SEQUENCE_ORDER` column to the value provided by the `p_new_sequence_order` input parameter. This update is conditionally applied only to rows where the value in the `BLOCK_ID` column matches the value provided by the `p_block_id` input parameter. After the update, the `RETURNING 1 INTO p_updated` clause captures the literal value `1` and assigns it to the `p_updated` output parameter if at least one row was updated. If no rows match the `WHERE` clause condition, the `p_updated` parameter will not be assigned a value by the `RETURNING` clause, and its value will remain `NULL` or its initial value, depending on the calling environment.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateBlockSequence(\n  p_block_id IN NUMBER,\n  p_new_sequence_order IN NUMBER,\n  p_updated OUT NUMBER\n)\nAS\nBEGIN\n  UPDATE BLOCKS\n  SET SEQUENCE_ORDER = p_new_sequence_order\n  WHERE BLOCK_ID = p_block_id\n  RETURNING 1 INTO p_updated;\nEND;",
    "database_name": "psychological_edm_639848",
    "tables": [
      "BLOCKS",
      "EXPERIMENTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateBlockSequence(p_block_id => 0, p_new_sequence_order => 3, p_updated => v_updated);\n  DBMS_OUTPUT.PUT_LINE('Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateBlockSequence(p_block_id => 1, p_new_sequence_order => 1, p_updated => v_updated);\n  DBMS_OUTPUT.PUT_LINE('Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateBlockSequence(p_block_id => 0, p_new_sequence_order => 2, p_updated => v_updated);\n  DBMS_OUTPUT.PUT_LINE('Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateBlockSequence(p_block_id => 1, p_new_sequence_order => 4, p_updated => v_updated);\n  DBMS_OUTPUT.PUT_LINE('Updated: ' || v_updated);\nEND;",
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateBlockSequence(p_block_id => 99, p_new_sequence_order => 1, p_updated => v_updated);\n  DBMS_OUTPUT.PUT_LINE('Updated: ' || v_updated);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named UpdateBlockSequence that updates the SEQUENCE_ORDER for a specified BLOCK_ID in the BLOCKS table, taking the block ID and the new sequence order as inputs and returning a value of 1 in an output parameter to indicate a successful update.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called UpdateBlockSequence that updates the SEQUENCE_ORDER for a specified BLOCK_ID in the BLOCKS table, taking the block identifier and the new sequence number as inputs, and sets an output parameter to 1 to indicate successful completion of the update.",
    "id": 66,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateBlockSequence that updates the sequence order for a specific block in the BLOCKS table. The procedure accepts three parameters: an input parameter p_block_id of type NUMBER to specify the unique identifier of the block to be updated, an input parameter p_new_sequence of type NUMBER to specify the new sequence order value, and an output parameter p_result of type NUMBER to indicate the success status of the operation. The procedure begins by executing an UPDATE operation on the BLOCKS table. This UPDATE statement sets the SEQUENCE_ORDER column to the value provided in the p_new_sequence input parameter. The WHERE clause of the UPDATE statement filters the operation to apply only to the row where the BLOCK_ID column matches the value provided in the p_block_id input parameter. After the UPDATE operation is executed, the procedure sets the p_result output parameter to the numeric value 1, signifying that the update was completed successfully. The procedure does not include explicit exception handling or commit statements, implying that transaction control is managed externally.",
    "original_summary": "Create a stored procedure named UpdateBlockSequence that updates the SEQUENCE_ORDER for a specific BLOCK_ID in the BLOCKS table. It takes the block ID and new sequence as input and returns 1 in an output parameter if the update was successful.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called UpdateBlockSequence that changes the SEQUENCE_ORDER for a certain BLOCK_ID in the BLOCKS table. It should accept the block identifier and a new sequence number. If the change goes through okay, have it indicate success by setting an output parameter to 1."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `AggregateYearlyData` that accepts three input parameters: `p_region_id` of type `VARCHAR2`, `p_start_year` of type `NUMBER`, and `p_end_year` of type `NUMBER`. The procedure declares four local variables: `v_total_value` of type `NUMBER` to store the sum of values, `v_avg_value` of type `NUMBER` to store the average of values, `v_year_count` of type `NUMBER` to store the count of distinct years, and `v_next_method_id` of type `NUMBER` to store the next available method identifier. The procedure begins by attempting to retrieve aggregated data from the `DATASETS` table. Specifically, it calculates the sum of the `VALUE` column, the average of the `VALUE` column, and the count of distinct values in the `YEAR` column. These aggregated results are then stored into the `v_total_value`, `v_avg_value`, and `v_year_count` variables, respectively. This aggregation is performed only for rows where the `REGION_ID` column matches the input parameter `p_region_id` and the `YEAR` column falls inclusively between the `p_start_year` and `p_end_year` input parameters. If no data is found that satisfies these conditions (i.e., a `NO_DATA_FOUND` exception occurs during the `SELECT` statement), the exception handler sets `v_total_value` to 0, `v_avg_value` to 0, and `v_year_count` to 0. Following this, the procedure determines the next available method identifier by querying the `DATA_COLLECTION_METHODS` table. It selects the maximum value from the `METHOD_ID` column, adds 1 to it, and stores the result in the `v_next_method_id` variable. The `NVL` function is used to handle cases where `MAX(METHOD_ID)` returns `NULL` (e.g., if the table is empty), in which case it defaults to 0 before adding 1, ensuring `v_next_method_id` starts at 1. Subsequently, the procedure evaluates a conditional statement based on the `v_year_count` variable. If `v_year_count` is greater than 0, indicating that data was found and aggregated, the procedure inserts a new record into the `DATA_COLLECTION_METHODS` table. The `METHOD_ID` column is populated with the value of `v_next_method_id`. The `METHOD_NAME` column is constructed by concatenating the literal string 'YEARLY_AGGREGATE_', the value of the `p_region_id` input parameter. The `DESCRIPTION` column is constructed by concatenating the literal string 'Total: ', the value of `v_total_value`, the literal string ', Avg: ', the value of `v_avg_value`, the literal string ', Years: ', and the value of `v_year_count`. If `v_year_count` is not greater than 0 (meaning no data was found for the specified range), the procedure instead inserts a new record into the `DATA_COLLECTION_METHODS` table. In this case, the `METHOD_ID` column is populated with the value of `v_next_method_id`. The `METHOD_NAME` column is constructed by concatenating the literal string 'NO_DATA_', and the value of the `p_region_id` input parameter. The `DESCRIPTION` column is set to the literal string 'No data found for specified range'.",
    "plsql": "CREATE OR REPLACE PROCEDURE AggregateYearlyData(\n    p_region_id IN VARCHAR2,\n    p_start_year IN NUMBER,\n    p_end_year IN NUMBER\n) AS\n    v_total_value NUMBER;\n    v_avg_value NUMBER;\n    v_year_count NUMBER;\n    v_next_method_id NUMBER;\nBEGIN\n    BEGIN\n        SELECT SUM(VALUE), AVG(VALUE), COUNT(DISTINCT YEAR)\n        INTO v_total_value, v_avg_value, v_year_count\n        FROM DATASETS\n        WHERE REGION_ID = p_region_id\n        AND YEAR BETWEEN p_start_year AND p_end_year;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_total_value := 0;\n            v_avg_value := 0;\n            v_year_count := 0;\n    END;\n\n    SELECT NVL(MAX(METHOD_ID), 0) + 1\n    INTO v_next_method_id\n    FROM DATA_COLLECTION_METHODS;\n\n    IF v_year_count > 0 THEN\n        INSERT INTO DATA_COLLECTION_METHODS (METHOD_ID, METHOD_NAME, DESCRIPTION)\n        VALUES (v_next_method_id, 'YEARLY_AGGREGATE_' || p_region_id,\n                'Total: ' || v_total_value || ', Avg: ' || v_avg_value || ', Years: ' || v_year_count);\n    ELSE\n        INSERT INTO DATA_COLLECTION_METHODS (METHOD_ID, METHOD_NAME, DESCRIPTION)\n        VALUES (v_next_method_id, 'NO_DATA_' || p_region_id, 'No data found for specified range');\n    END IF;\nEND;",
    "database_name": "demographic_ahs_652164",
    "tables": [
      "DATASETS",
      "DATA_COLLECTION_METHODS"
    ],
    "call_sqls": [
      "BEGIN\n  AggregateYearlyData('REGION_1', 2018, 2020);\n  COMMIT;\nEND;",
      "BEGIN\n  AggregateYearlyData('REGION_2', 2015, 2019);\n  COMMIT;\nEND;",
      "BEGIN\n  AggregateYearlyData('REGION_3', 2020, 2023);\n  COMMIT;\nEND;",
      "BEGIN\n  AggregateYearlyData('REGION_4', 2010, 2015);\n  COMMIT;\nEND;",
      "BEGIN\n  AggregateYearlyData('REGION_5', 2000, 2010);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named AggregateYearlyData that, for a given REGION_ID and a range between a START_YEAR and END_YEAR, aggregates data from the DATASETS table by calculating the total sum, average, and count of distinct years for the VALUE column. If data exists, it inserts a new record into the DATA_COLLECTION_METHODS table with a METHOD_NAME formatted as 'YEARLY_AGGREGATE_<region_id>' and a DESCRIPTION containing the calculated total, average, and year count. If no data is found, it inserts a record with METHOD_NAME as 'NO_DATA_<region_id>' and DESCRIPTION as 'No data found for specified range'. The procedure automatically determines the next METHOD_ID by incrementing the current maximum METHOD_ID from the DATA_COLLECTION_METHODS table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called AggregateYearlyData that, for a given region and year range, calculates the total sum, average, and count of distinct years from the DATASETS table. If data exists for that region and year range, insert a record into the DATA_COLLECTION_METHODS table with a method name formatted as 'YEARLY_AGGREGATE_<region>' and a description containing the calculated results. If no data is found, insert a record with the name 'NO_DATA_<region>' and the description 'No data found for specified range'. Always use the next available METHOD_ID, determined by incrementing the maximum existing METHOD_ID in DATA_COLLECTION_METHODS.",
    "id": 67,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named AggregateYearlyData that accepts two input parameters: p_region of type VARCHAR2 which specifies the region for which data is to be aggregated, and p_year_range of type VARCHAR2 which defines the year range as a string, expected to be in a format like 'YYYY-YYYY' (e.g., '2010-2020'). The procedure declares several local variables: v_start_year of type NUMBER to store the extracted start year from p_year_range, v_end_year of type NUMBER to store the extracted end year from p_year_range, v_total_sum of type NUMBER to store the calculated total sum of data values, v_avg_value of type NUMBER to store the calculated average of data values, v_year_count of type NUMBER to store the count of distinct years, v_method_id of type NUMBER to store the next available METHOD_ID for insertion, v_method_name of type VARCHAR2 to store the formatted method name, and v_description of type VARCHAR2 to store the description text for insertion.\n\nThe procedure first parses the p_year_range parameter by extracting the substring before the hyphen as the start year and the substring after the hyphen as the end year, converting these substrings to numbers using TO_NUMBER. It then executes a SELECT statement against the DATASETS table to calculate the SUM of the data_value column, the AVG of the data_value column, and the COUNT(DISTINCT year) for rows where the region column matches the p_region parameter and the year column is between v_start_year and v_end_year (inclusive). These aggregated values are stored into v_total_sum, v_avg_value, and v_year_count using the INTO clause. If no rows match the criteria, the SELECT statement will raise a NO_DATA_FOUND exception.\n\nThe procedure includes an exception handler for NO_DATA_FOUND. In the main block, if data is found (i.e., the SELECT succeeds without exception), it sets v_method_name to 'YEARLY_AGGREGATE_' concatenated with p_region (e.g., 'YEARLY_AGGREGATE_NORTH'), and sets v_description to a string containing the calculated results, formatted as 'Total Sum: <v_total_sum>, Average: <v_avg_value>, Distinct Years: <v_year_count>'. In the exception handler, when no data is found, it sets v_method_name to 'NO_DATA_' concatenated with p_region (e.g., 'NO_DATA_NORTH'), and sets v_description to 'No data found for specified range'.\n\nAfter determining v_method_name and v_description, the procedure calculates the next available METHOD_ID by executing a SELECT statement against the DATA_COLLECTION_METHODS table to find the maximum existing METHOD_ID, using NVL to return 0 if no maximum is found (i.e., the table is empty), and then incrementing that value by one. This result is stored in v_method_id. Finally, the procedure inserts a new record into the DATA_COLLECTION_METHODS table with columns METHOD_ID set to v_method_id, METHOD_NAME set to v_method_name, and DESCRIPTION set to v_description. The procedure does not return any value but performs the insertion as its output action.",
    "original_summary": "Create a stored procedure named `AggregateYearlyData` that aggregates data from the DATASETS table for a given region and year range. It calculates the total sum, average, and distinct year count of the VALUE column. If data is found, insert a record into the DATA_COLLECTION_METHODS table with a name like 'YEARLY_AGGREGATE_<region>' and a description containing the aggregated results. If no data is found, insert a record with a name like 'NO_DATA_<region>' and a description stating 'No data found for specified range'. The procedure determines the next METHOD_ID by finding the current maximum and adding 1.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure AggregateYearlyData for region and year range. Sum, average, and count distinct years from DATASETS. If data exists, insert into DATA_COLLECTION_METHODS with name 'YEARLY_AGGREGATE_<region>' and results in description. If no data, insert name 'NO_DATA_<region>' and description 'No data found for specified range'. Use max(METHOD_ID)+1 for new ID."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `calculate_measurement_stats` that accepts three input parameters: `p_size_id` of type `NUMBER`, `p_category` of type `VARCHAR2`, and `p_threshold` of type `NUMBER`. The procedure first declares three local variables: `v_avg_bust` of type `NUMBER` to store the calculated average bust measurement, `v_max_waist` of type `NUMBER` to store the calculated maximum waist measurement, and `v_count` of type `NUMBER` to store the count of records found. It then executes a `SELECT` statement to retrieve data from the `MEASUREMENTS` table, aliased as `m`, and the `SIZES` table, aliased as `s`. This `SELECT` statement performs an inner join between `MEASUREMENTS` and `SIZES` on the condition that `m.SIZE_ID` is equal to `s.SIZE_ID`. The query filters the joined records where `s.SIZE_ID` matches the input parameter `p_size_id`, `s.SIZE_CATEGORY` matches the input parameter `p_category`, and `m.BUST` is greater than the input parameter `p_threshold`. From these filtered records, the query calculates the average of the `BUST` column, the maximum of the `WAIST` column, and the total count of rows. These calculated values are then assigned to the local variables `v_avg_bust`, `v_max_waist`, and `v_count` respectively. Following this, the procedure evaluates a conditional `IF` statement: if the value of `v_count` is greater than 0, indicating that at least one record met the specified criteria, then an `INSERT` statement is executed. This `INSERT` statement adds a new row into the `SIZE_UPDATES` table. For the `UPDATE_ID` column, it uses a subquery `(SELECT NVL(MAX(UPDATE_ID), 0) + 1 FROM SIZE_UPDATES)` to generate a new unique ID by finding the maximum existing `UPDATE_ID` in the `SIZE_UPDATES` table, handling cases where no records exist by defaulting to 0, and then incrementing it by 1. The `MEASUREMENT_ID` column is set to `NULL`. The `UPDATE_DATE` column is populated with the current system date formatted as 'YYYY-MM-DD' using `TO_CHAR(SYSDATE, 'YYYY-MM-DD')`. The `UPDATED_BY` column is set to the numeric value `0`. The `UPDATE_REASON` column is set to the string literal 'stats calculation'. Finally, the `UPDATE_DESCRIPTION` column is populated with a concatenated string that includes the literal 'Avg bust: ', followed by the value of `v_avg_bust`, followed by the literal ', Max waist: ', and finally followed by the value of `v_max_waist`.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_measurement_stats(\n    p_size_id IN NUMBER,\n    p_category IN VARCHAR2,\n    p_threshold IN NUMBER\n) AS\n    v_avg_bust NUMBER;\n    v_max_waist NUMBER;\n    v_count NUMBER;\nBEGIN\n    SELECT AVG(BUST), MAX(WAIST), COUNT(*)\n    INTO v_avg_bust, v_max_waist, v_count\n    FROM MEASUREMENTS m\n    JOIN SIZES s ON m.SIZE_ID = s.SIZE_ID\n    WHERE s.SIZE_ID = p_size_id\n    AND s.SIZE_CATEGORY = p_category\n    AND m.BUST > p_threshold;\n\n    IF v_count > 0 THEN\n        INSERT INTO SIZE_UPDATES (UPDATE_ID, MEASUREMENT_ID, UPDATE_DATE, UPDATED_BY, UPDATE_REASON, UPDATE_DESCRIPTION)\n        VALUES ((SELECT NVL(MAX(UPDATE_ID), 0) + 1 FROM SIZE_UPDATES), NULL, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 0, 'stats calculation', 'Avg bust: ' || v_avg_bust || ', Max waist: ' || v_max_waist);\n    END IF;\nEND;",
    "database_name": "apparel_sams_543314",
    "tables": [
      "SIZES",
      "MEASUREMENTS",
      "SIZE_UPDATES"
    ],
    "call_sqls": [
      "BEGIN\n    calculate_measurement_stats(1, 'tops', 90);\nEND;",
      "BEGIN\n    calculate_measurement_stats(0, 'bottoms', 80);\nEND;",
      "BEGIN\n    calculate_measurement_stats(1, 'tops', 95);\nEND;",
      "BEGIN\n    calculate_measurement_stats(0, 'tops', 85);\nEND;",
      "BEGIN\n    calculate_measurement_stats(1, 'bottoms', 100);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `calculate_measurement_stats` that, for a given SIZE_ID and SIZE_CATEGORY, calculates the average BUST and the maximum WAIST from the MEASUREMENTS table where the BUST value exceeds a provided threshold. If any such records are found, it then inserts a new record into the SIZE_UPDATES table with a generated UPDATE_ID, the current date as UPDATE_DATE, a 'stats calculation' as UPDATE_REASON, and an UPDATE_DESCRIPTION containing the calculated average bust and maximum waist values.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL stored procedure called `calculate_measurement_stats` that figures out the average BUST and the biggest WAIST from the `MEASUREMENTS` table for a specific SIZE_ID and SIZE_CATEGORY, but only where the BUST is bigger than a certain threshold? If it finds any matching records, it should pop a new record into the `SIZE_UPDATES` table with a generated UPDATE_ID, today's date as UPDATE_DATE, a reason that says 'stats calculation' for UPDATE_REASON, and a description in UPDATE_DESCRIPTION that spells out the average bust and max waist it just calculated.",
    "id": 68,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `calculate_measurement_stats` that accepts three input parameters. The first input parameter, `p_size_id`, is of data type `NUMBER` and represents a specific size identifier. The second input parameter, `p_size_category`, is of data type `VARCHAR2` and represents a specific size category. The third input parameter, `p_bust_threshold`, is of data type `NUMBER` and represents the minimum bust measurement threshold. The procedure operates within the `apparel_sams_543314` database.\n\nThe procedure declares two local variables: `v_avg_bust` of data type `NUMBER` to store the calculated average bust value, and `v_max_waist` of data type `NUMBER` to store the calculated maximum waist value.\n\nThe procedure's logic begins by executing a `SELECT` statement on the `MEASUREMENTS` table. This statement uses the `AVG` aggregate function on the `BUST` column to calculate the average bust, and the `MAX` aggregate function on the `WAIST` column to calculate the maximum waist. The `SELECT` statement includes a `WHERE` clause with three conditions: the `SIZE_ID` column must equal the input parameter `p_size_id`, the `SIZE_CATEGORY` column must equal the input parameter `p_size_category`, and the `BUST` column must be greater than the input parameter `p_bust_threshold`. The results of the aggregate functions are fetched into the local variables `v_avg_bust` and `v_max_waist`.\n\nFollowing the `SELECT` operation, the procedure checks if data was found using an implicit cursor attribute. If the `SELECT` statement successfully fetched data (i.e., at least one row met the `WHERE` clause criteria), the procedure proceeds to perform an `INSERT` operation into the `SIZE_UPDATES` table. The `INSERT` statement populates the following columns: `UPDATE_ID` is populated using the `SIZE_UPDATES_SEQ.NEXTVAL` sequence to generate a unique identifier, `UPDATE_DATE` is populated with the current system date using the `SYSDATE` function, `UPDATE_REASON` is populated with the string literal 'stats calculation', and `UPDATE_DESCRIPTION` is populated with a concatenated string. This string is built using the `||` operator to combine the literal text 'Avg Bust: ' with the value of `v_avg_bust`, the literal text ', Max Waist: ' with the value of `v_max_waist`. If the `SELECT` statement did not fetch any data (i.e., no rows met the criteria), the procedure takes no further action and completes without performing the `INSERT`.",
    "original_summary": "Create a stored procedure named `calculate_measurement_stats` that calculates the average bust and maximum waist from the `MEASUREMENTS` table for a given size ID and category where bust exceeds a threshold. If records are found, it inserts a new record into the `SIZE_UPDATES` table with a generated ID, the current date, a 'stats calculation' reason, and a description containing the calculated average bust and max waist.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called `calculate_measurement_stats`? It needs to figure out the average bust and the biggest waist from the `MEASUREMENTS` table for a specific size ID and category, but only where the bust is bigger than a certain number. If it finds anything, it should pop a new record into the `SIZE_UPDATES` table. That new record should have a made-up ID, today's date, a reason that says 'stats calculation', and a description that spells out the average bust and max waist it just calculated."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `adjust_coach_experience` that accepts a single input parameter, `p_coach_id`, of data type `NUMBER`. This procedure is designed to retrieve specific performance metrics for a coach identified by `p_coach_id` from the `coaches` table and then conditionally modify data in either the `coaches` table or the `teams` table based on a calculated experience value.\n\nUpon execution, the procedure declares three local variables: `v_wins` of type `NUMBER` to store the number of wins, `v_losses` of type `NUMBER` to store the number of losses, and `v_experience` of type `NUMBER` to store the calculated experience. It also defines an explicit cursor named `coach_cursor`. This cursor is configured to select the `wins` column and the `losses` column from the `coaches` table, specifically for the row where the `coach_id` column matches the value provided in the `p_coach_id` input parameter.\n\nThe procedure then opens the `coach_cursor`. It enters a loop to fetch data from this cursor. Inside the loop, it attempts to fetch the values for `wins` into `v_wins` and `losses` into `v_losses` from the current row pointed to by `coach_cursor`. The loop is designed to exit when `coach_cursor%NOTFOUND` becomes true, indicating that no more rows are available to fetch from the cursor.\n\nAfter successfully fetching a row, the procedure calculates `v_experience` by subtracting the value of `v_losses` from the value of `v_wins`.\n\nFollowing this calculation, a conditional logic block is executed:\n1. If the calculated `v_experience` is greater than `30`, the procedure executes an `UPDATE` statement. This statement modifies the `coaches` table by incrementing the value in the `experience` column by `5` for the specific coach whose `coach_id` matches the `p_coach_id` input parameter.\n2. If the `v_experience` is not greater than `30` but is less than `10`, the procedure executes a `DELETE` statement. This statement removes rows from the `teams` table where the `coach_id` column matches the `p_coach_id` input parameter AND the `capacity` column has a value less than `5000`.\n3. If neither of the above conditions is met (i.e., `v_experience` is between `10` and `30` inclusive), the procedure executes an `INSERT` statement. This statement adds a new row into the `teams` table with the following column values:\n    - `team_id`: `p_coach_id` plus `100`\n    - `team_name`: The string literal `'New Team'`\n    - `league_id`: The numeric value `1`\n    - `location`: The string literal `'Unknown'`\n    - `coach_id`: The value of `p_coach_id`\n    - `stadium`: The string literal `'New Stadium'`\n    - `capacity`: The numeric value `8000`\n\nAfter the loop completes (either by processing all rows or if no rows were found initially), the procedure closes the `coach_cursor`.",
    "plsql": "CREATE OR REPLACE PROCEDURE adjust_coach_experience(p_coach_id NUMBER)\nIS\n    v_wins NUMBER;\n    v_losses NUMBER;\n    v_experience NUMBER;\n    CURSOR coach_cursor IS\n        SELECT wins, losses FROM coaches WHERE coach_id = p_coach_id;\nBEGIN\n    OPEN coach_cursor;\n    LOOP\n        FETCH coach_cursor INTO v_wins, v_losses;\n        EXIT WHEN coach_cursor%NOTFOUND;\n        \n        v_experience := v_wins - v_losses;\n        \n        IF v_experience > 30 THEN\n            UPDATE coaches SET experience = experience + 5 WHERE coach_id = p_coach_id;\n        ELSIF v_experience < 10 THEN\n            DELETE FROM teams WHERE coach_id = p_coach_id AND capacity < 5000;\n        ELSE\n            INSERT INTO teams (team_id, team_name, league_id, location, coach_id, stadium, capacity)\n            VALUES (p_coach_id + 100, 'New Team', 1, 'Unknown', p_coach_id, 'New Stadium', 8000);\n        END IF;\n    END LOOP;\n    CLOSE coach_cursor;\nEND;",
    "database_name": "sports_tpt_41536",
    "tables": [
      "TEAMS",
      "COACHES",
      "ROSTERS",
      "HOME_AWAY_RECORDS"
    ],
    "call_sqls": [
      "BEGIN\n  adjust_coach_experience(1);\n  COMMIT;\nEND;",
      "BEGIN\n  adjust_coach_experience(2);\n  COMMIT;\nEND;",
      "BEGIN\n  adjust_coach_experience(10);\n  COMMIT;\nEND;",
      "BEGIN\n  adjust_coach_experience(25);\n  COMMIT;\nEND;",
      "BEGIN\n  adjust_coach_experience(100);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named adjust_coach_experience that, for a given coach_id, calculates the coach's experience as wins minus losses from the COACHES table. If the experience is greater than 30, increase the coach's experience in the COACHES table by 5. If the experience is less than 10, delete any teams for that coach from the TEAMS table where the capacity is below 5000. Otherwise, insert a new team into the TEAMS table with a team_id equal to the coach_id plus 100, a team_name of 'New Team', a league_id of 1, a location of 'Unknown', the given coach_id, a stadium of 'New Stadium', and a capacity of 8000.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called adjust_coach_experience that, for a given coach_id, calculates experience as wins minus losses from the COACHES table, and then if that experience is greater than 30, increases the coach's EXPERIENCE by 5; if it is less than 10, deletes any teams for that coach from the TEAMS table where CAPACITY is below 5000; otherwise, inserts a new team into TEAMS with TEAM_ID set to coach_id plus 100, TEAM_NAME as 'New Team', LEAGUE_ID as 1, LOCATION as 'Unknown', COACH_ID as the given coach_id, STADIUM as 'New Stadium', and CAPACITY as 8000.",
    "id": 69,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `adjust_coach_experience` that accepts a single input parameter, `p_coach_id`, of data type `NUMBER`. This procedure is designed to retrieve specific performance metrics for a coach identified by `p_coach_id` from the `coaches` table and then conditionally modify data in either the `coaches` table or the `teams` table based on a calculated experience value.\n\nUpon execution, the procedure declares three local variables: `v_wins` of type `NUMBER` to store the number of wins, `v_losses` of type `NUMBER` to store the number of losses, and `v_experience` of type `NUMBER` to store the calculated experience. It also defines an explicit cursor named `coach_cursor`. This cursor is configured to select the `wins` column and the `losses` column from the `coaches` table, specifically for the row where the `coach_id` column matches the value provided in the `p_coach_id` input parameter.\n\nThe procedure then opens the `coach_cursor`. It enters a loop to fetch data from this cursor. Inside the loop, it attempts to fetch the values for `wins` into `v_wins` and `losses` into `v_losses` from the current row pointed to by `coach_cursor`. The loop is designed to exit when `coach_cursor%NOTFOUND` becomes true, indicating that no more rows are available to fetch from the cursor.\n\nAfter successfully fetching a row, the procedure calculates `v_experience` by subtracting the value of `v_losses` from the value of `v_wins`.\n\nFollowing this calculation, a conditional logic block is executed:\n1. If the calculated `v_experience` is greater than `30`, the procedure executes an `UPDATE` statement. This statement modifies the `coaches` table by incrementing the value in the `experience` column by `5` for the specific coach whose `coach_id` matches the `p_coach_id` input parameter.\n2. If the `v_experience` is not greater than `30` but is less than `10`, the procedure executes a `DELETE` statement. This statement removes rows from the `teams` table where the `coach_id` column matches the `p_coach_id` input parameter AND the `capacity` column has a value less than `5000`.\n3. If neither of the above conditions is met (i.e., `v_experience` is between `10` and `30` inclusive), the procedure executes an `INSERT` statement. This statement adds a new row into the `teams` table with the following column values:\n    - `team_id`: `p_coach_id` plus `100`\n    - `team_name`: The string literal `'New Team'`\n    - `league_id`: The numeric value `1`\n    - `location`: The string literal `'Unknown'`\n    - `coach_id`: The value of `p_coach_id`\n    - `stadium`: The string literal `'New Stadium'`\n    - `capacity`: The numeric value `8000`\n\nAfter the loop completes (either by processing all rows or if no rows were found initially), the procedure closes the `coach_cursor`.",
    "original_summary": "Create a stored procedure named adjust_coach_experience that adjusts data based on a coach's performance. For a given coach_id, calculate experience as wins minus losses. If experience is high, increase the coach's experience. If low, delete low-capacity teams for that coach. Otherwise, insert a new team for the coach.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure named adjust_coach_experience that, for a given coach_id, calculates experience as wins minus losses and then, if the experience is high, increases the coach's experience, or if it is low, deletes that coach's low-capacity teams, or otherwise inserts a new team for the coach?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `calculate_county_turnout` that accepts three input parameters: a numeric parameter `p_fips` representing a county's FIPS code, a string parameter `p_stage` representing the election stage or reporting phase, and a numeric parameter `p_threshold` representing a minimum turnout percentage threshold. The procedure first declares three local numeric variables: `v_total_votes`, `v_registered_voters`, and `v_turnout_percentage`. It begins execution by querying the `COUNTIES` table to select the `REGISTERED_VOTERS` column value for the row where the `FIPS` column equals the input parameter `p_fips`, storing the result into the variable `v_registered_voters`. It then queries the `PRECINCT_REPORTING` table to calculate the sum of the `TOTAL_EARLY_VOTES`, `TOTAL_ABSENTEE_VOTES`, and `TOTAL_PROVISIONAL_VOTES` columns for the row where the `FIPS` column equals `p_fips`, storing this sum into the variable `v_total_votes`. The procedure calculates the `v_turnout_percentage` by dividing `v_total_votes` by `v_registered_voters` and multiplying the result by 100. It then evaluates a conditional statement: if the calculated `v_turnout_percentage` is greater than the input parameter `p_threshold`, it performs an `INSERT` operation into the `VOTER_TURNOUT` table. For this insert, it generates a new `TURNOUT_ID` value by selecting the maximum existing `TURNOUT_ID` from the `VOTER_TURNOUT` table, using the `COALESCE` function to substitute 0 if the maximum is null, and then adding 1 to that value. It inserts this generated ID, the input parameter `p_fips`, the calculated `v_turnout_percentage`, the input parameter `p_stage`, the retrieved `v_registered_voters` value, and three separate subquery values from the `PRECINCT_REPORTING` table for the same `p_fips`: the `TOTAL_EARLY_VOTES`, `TOTAL_ABSENTEE_VOTES`, and `TOTAL_PROVISIONAL_VOTES` into the corresponding columns `TURNOUT_ID`, `FIPS`, `TURNOUT_PERCENTAGE`, `TURNOUT_STAGE`, `REGISTERED_VOTERS`, `EARLY_VOTING_TURNOUT`, `ABSENTEE_VOTING_TURNOUT`, and `PROVISIONAL_VOTING_TURNOUT`. If the `v_turnout_percentage` is not greater than `p_threshold`, the procedure executes a `DELETE` operation on the `VOTER_TURNOUT` table, removing any rows where the `FIPS` column equals the input `p_fips` and the `TURNOUT_STAGE` column equals the input `p_stage`.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_county_turnout(p_fips IN NUMBER, p_stage IN VARCHAR2, p_threshold IN NUMBER)\nIS\n    v_total_votes NUMBER;\n    v_registered_voters NUMBER;\n    v_turnout_percentage NUMBER;\nBEGIN\n    SELECT REGISTERED_VOTERS INTO v_registered_voters FROM COUNTIES WHERE FIPS = p_fips;\n    \n    SELECT (TOTAL_EARLY_VOTES + TOTAL_ABSENTEE_VOTES + TOTAL_PROVISIONAL_VOTES)\n    INTO v_total_votes\n    FROM PRECINCT_REPORTING\n    WHERE FIPS = p_fips;\n    \n    v_turnout_percentage := (v_total_votes / v_registered_voters) * 100;\n    \n    IF v_turnout_percentage > p_threshold THEN\n        INSERT INTO VOTER_TURNOUT (TURNOUT_ID, FIPS, TURNOUT_PERCENTAGE, TURNOUT_STAGE, REGISTERED_VOTERS, EARLY_VOTING_TURNOUT, ABSENTEE_VOTING_TURNOUT, PROVISIONAL_VOTING_TURNOUT)\n        VALUES ((SELECT COALESCE(MAX(TURNOUT_ID), 0) + 1 FROM VOTER_TURNOUT), p_fips, v_turnout_percentage, p_stage, v_registered_voters, \n                (SELECT TOTAL_EARLY_VOTES FROM PRECINCT_REPORTING WHERE FIPS = p_fips),\n                (SELECT TOTAL_ABSENTEE_VOTES FROM PRECINCT_REPORTING WHERE FIPS = p_fips),\n                (SELECT TOTAL_PROVISIONAL_VOTES FROM PRECINCT_REPORTING WHERE FIPS = p_fips));\n    ELSE\n        DELETE FROM VOTER_TURNOUT WHERE FIPS = p_fips AND TURNOUT_STAGE = p_stage;\n    END IF;\nEND;",
    "database_name": "election_rad_management",
    "tables": [
      "COUNTIES",
      "ABSENTEE_VOTES",
      "PRECINCT_REPORTING",
      "VOTER_TURNOUT"
    ],
    "call_sqls": [
      "BEGIN\n  calculate_county_turnout(1, 'early', 50);\nEND;",
      "BEGIN\n  calculate_county_turnout(0, 'final', 60);\nEND;",
      "BEGIN\n  calculate_county_turnout(1, 'final', 70);\nEND;",
      "BEGIN\n  calculate_county_turnout(0, 'early', 40);\nEND;",
      "BEGIN\n  calculate_county_turnout(1, 'provisional', 30);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named calculate_county_turnout that accepts a county FIPS code, a voting stage identifier, and a threshold percentage. It calculates the voter turnout percentage for the specified county by dividing the total votes (the sum of TOTAL_EARLY_VOTES, TOTAL_ABSENTEE_VOTES, and TOTAL_PROVISIONAL_VOTES from the PRECINCT_REPORTING table) by the REGISTERED_VOTERS from the COUNTIES table. If the calculated turnout percentage exceeds the provided threshold, the procedure inserts a new record into the VOTER_TURNOUT table with a generated TURNOUT_ID, the FIPS code, the turnout percentage, the stage, the registered voter count, and the individual early, absentee, and provisional vote totals from PRECINCT_REPORTING. If the turnout percentage does not exceed the threshold, the procedure deletes any existing records for that FIPS code and stage from the VOTER_TURNOUT table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called calculate_county_turnout that accepts a numeric FIPS code, a descriptive stage as a string, and a numeric threshold value. It should compute the voter turnout percentage by retrieving the registered voter count from the COUNTIES table and summing the early, absentee, and provisional votes from the PRECINCT_REPORTING table. If the turnout percentage exceeds the threshold, insert a new record into the VOTER_TURNOUT table with a unique ID and all vote details. If the percentage does not exceed the threshold, delete any existing records for that FIPS code and stage from the VOTER_TURNOUT table.",
    "id": 70,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `calculate_county_turnout` that accepts three input parameters: a numeric parameter `p_fips` representing a county's FIPS code, a string parameter `p_stage` representing the election stage or reporting phase, and a numeric parameter `p_threshold` representing a minimum turnout percentage threshold. The procedure first declares three local numeric variables: `v_total_votes`, `v_registered_voters`, and `v_turnout_percentage`. It begins execution by querying the `COUNTIES` table to select the `REGISTERED_VOTERS` column value for the row where the `FIPS` column equals the input parameter `p_fips`, storing the result into the variable `v_registered_voters`. It then queries the `PRECINCT_REPORTING` table to calculate the sum of the `TOTAL_EARLY_VOTES`, `TOTAL_ABSENTEE_VOTES`, and `TOTAL_PROVISIONAL_VOTES` columns for the row where the `FIPS` column equals `p_fips`, storing this sum into the variable `v_total_votes`. The procedure calculates the `v_turnout_percentage` by dividing `v_total_votes` by `v_registered_voters` and multiplying the result by 100. It then evaluates a conditional statement: if the calculated `v_turnout_percentage` is greater than the input parameter `p_threshold`, it performs an `INSERT` operation into the `VOTER_TURNOUT` table. For this insert, it generates a new `TURNOUT_ID` value by selecting the maximum existing `TURNOUT_ID` from the `VOTER_TURNOUT` table, using the `COALESCE` function to substitute 0 if the maximum is null, and then adding 1 to that value. It inserts this generated ID, the input parameter `p_fips`, the calculated `v_turnout_percentage`, the input parameter `p_stage`, the retrieved `v_registered_voters` value, and three separate subquery values from the `PRECINCT_REPORTING` table for the same `p_fips`: the `TOTAL_EARLY_VOTES`, `TOTAL_ABSENTEE_VOTES`, and `TOTAL_PROVISIONAL_VOTES` into the corresponding columns `TURNOUT_ID`, `FIPS`, `TURNOUT_PERCENTAGE`, `TURNOUT_STAGE`, `REGISTERED_VOTERS`, `EARLY_VOTING_TURNOUT`, `ABSENTEE_VOTING_TURNOUT`, and `PROVISIONAL_VOTING_TURNOUT`. If the `v_turnout_percentage` is not greater than `p_threshold`, the procedure executes a `DELETE` operation on the `VOTER_TURNOUT` table, removing any rows where the `FIPS` column equals the input `p_fips` and the `TURNOUT_STAGE` column equals the input `p_stage`.",
    "original_summary": "Create a stored procedure named calculate_county_turnout that accepts fips (NUMBER), stage (VARCHAR2), and threshold (NUMBER) parameters. Calculate turnout percentage using registered voters from COUNTIES table and total votes (sum of early, absentee, provisional) from PRECINCT_REPORTING table. If percentage exceeds threshold: insert into VOTER_TURNOUT table with generated ID and all vote details. Otherwise: delete existing records for that fips and stage from VOTER_TURNOUT table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Develop a stored procedure, to be named calculate_county_turout, which must accept three distinct input parameters: a numeric fips code, a descriptive stage expressed as a VARCHAR2 string, and a numeric threshold value. This procedure should meticulously compute the voter turnout percentage by first retrieving the registered voter count from the authoritative COUNTIES table and then calculating the total votes cast from the PRECINCT_REPORTING table by summing together the early, absentee, and provisional vote columns. If the resulting turnout percentage is found to surpass the specified threshold, the procedure must perform an insertion into the VOTER_TURNOUT table, creating a new record with a uniquely generated identifier and comprehensive details of all the vote tallies. Conversely, if the calculated percentage does not exceed the threshold, the procedure must thoroughly delete any and all pre-existing records that correspond to the provided fips code and stage combination from the VOTER_TURNOUT table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertAssessmentResult that accepts four input parameters: p_result_id of type NUMBER to uniquely identify the new result record, p_student_id of type NUMBER to identify the student, p_assessment_id of type NUMBER to identify the specific assessment, and p_raw_score of type NUMBER representing the student's score. The procedure first declares two local variables: v_percentage and v_total_questions, both of type NUMBER. It begins execution by querying the ASSESSMENTS table to retrieve the TOTAL_QUESTIONS column value for the row where the ASSESSMENT_ID column matches the input parameter p_assessment_id, storing this value into the variable v_total_questions. If this query finds no matching row, a NO_DATA_FOUND exception is raised. After the SELECT, the procedure checks if the retrieved v_total_questions is NULL or equal to zero; if either condition is true, it raises a custom application error with code -20001 and a message indicating that TOTAL_QUESTIONS cannot be NULL or zero for the provided assessment ID. If v_total_questions is valid, the procedure calculates a percentage score by dividing the input p_raw_score by v_total_questions and multiplying the result by 100, storing the outcome in the v_percentage variable. It then performs an INSERT operation into the ASSESSMENT_RESULTS table, populating the columns RESULT_ID, STUDENT_ID, ASSESSMENT_ID, RAW_SCORE, and PERCENTAGE with the values from parameters p_result_id, p_student_id, p_assessment_id, p_raw_score, and the calculated v_percentage, respectively. The procedure includes an EXCEPTION handling block: if a NO_DATA_FOUND exception occurs from the initial SELECT, it raises a custom error with code -20002 stating the assessment ID was not found; if a ZERO_DIVIDE exception occurs during the percentage calculation, it raises a custom error with code -20003 for a division by zero error; for any other unexpected exception, it raises a custom error with code -20004 and includes the system error message from SQLERRM.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertAssessmentResult(\n    p_result_id NUMBER,\n    p_student_id NUMBER,\n    p_assessment_id NUMBER,\n    p_raw_score NUMBER\n) AS\n    v_percentage NUMBER;\n    v_total_questions NUMBER;\nBEGIN\n    SELECT TOTAL_QUESTIONS\n    INTO v_total_questions\n    FROM ASSESSMENTS\n    WHERE ASSESSMENT_ID = p_assessment_id;\n\n    IF v_total_questions IS NULL OR v_total_questions = 0 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'TOTAL_QUESTIONS cannot be NULL or zero for assessment ID: ' || p_assessment_id);\n    END IF;\n\n    v_percentage := (p_raw_score / v_total_questions) * 100;\n\n    INSERT INTO ASSESSMENT_RESULTS (\n        RESULT_ID,\n        STUDENT_ID,\n        ASSESSMENT_ID,\n        RAW_SCORE,\n        PERCENTAGE\n    ) VALUES (\n        p_result_id,\n        p_student_id,\n        p_assessment_id,\n        p_raw_score,\n        v_percentage\n    );\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        RAISE_APPLICATION_ERROR(-20002, 'Assessment ID ' || p_assessment_id || ' not found in ASSESSMENTS table.');\n    WHEN ZERO_DIVIDE THEN\n        RAISE_APPLICATION_ERROR(-20003, 'Division by zero error while calculating percentage for assessment ID: ' || p_assessment_id);\n    WHEN OTHERS THEN\n        RAISE_APPLICATION_ERROR(-20004, 'Unexpected error: ' || SQLERRM);\nEND;",
    "database_name": "educational_aaspt_766875",
    "tables": [
      "ASSESSMENTS",
      "ASSESSMENT_RESULTS",
      "STUDENTS"
    ],
    "call_sqls": [
      "BEGIN\n    InsertAssessmentResult(1001, 1, 0, 40);\n    COMMIT;\nEND;",
      "BEGIN\n    InsertAssessmentResult(1002, 0, 1, 29);\n    COMMIT;\nEND;",
      "BEGIN\n    InsertAssessmentResult(1003, 1, 1, 45);\n    COMMIT;\nEND;",
      "BEGIN\n    InsertAssessmentResult(1004, 0, 0, 35);\n    COMMIT;\nEND;",
      "BEGIN\n    InsertAssessmentResult(1005, 1, 0, 48);\n    COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named InsertAssessmentResult that inserts a student's assessment result into the ASSESSMENT_RESULTS table, taking input parameters for the result ID, student ID, assessment ID, and raw score. It must validate that the assessment exists in the ASSESSMENTS table and that its TOTAL_QUESTIONS is not zero or null, then calculate the percentage score from the raw score and total questions, and insert all data including the calculated percentage. The procedure should handle and raise appropriate errors if the assessment is not found, if a division by zero occurs during calculation, or for any other unexpected errors.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called InsertAssessmentResult that inserts a student's test result into the ASSESSMENT_RESULTS table, calculating the percentage from the student's RAW_SCORE and the TOTAL_QUESTIONS from the ASSESSMENTS table, ensuring the assessment exists and TOTAL_QUESTIONS is valid, and handling any errors with appropriate messages.",
    "id": 71,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named InsertAssessmentResult that accepts four input parameters: p_result_id of type NUMBER to uniquely identify the new result record, p_student_id of type NUMBER to identify the student, p_assessment_id of type NUMBER to identify the specific assessment, and p_raw_score of type NUMBER representing the student's score. The procedure first declares two local variables: v_percentage and v_total_questions, both of type NUMBER. It begins execution by querying the ASSESSMENTS table to retrieve the TOTAL_QUESTIONS column value for the row where the ASSESSMENT_ID column matches the input parameter p_assessment_id, storing this value into the variable v_total_questions. If this query finds no matching row, a NO_DATA_FOUND exception is raised. After the SELECT, the procedure checks if the retrieved v_total_questions is NULL or equal to zero; if either condition is true, it raises a custom application error with code -20001 and a message indicating that TOTAL_QUESTIONS cannot be NULL or zero for the provided assessment ID. If v_total_questions is valid, the procedure calculates a percentage score by dividing the input p_raw_score by v_total_questions and multiplying the result by 100, storing the outcome in the v_percentage variable. It then performs an INSERT operation into the ASSESSMENT_RESULTS table, populating the columns RESULT_ID, STUDENT_ID, ASSESSMENT_ID, RAW_SCORE, and PERCENTAGE with the values from parameters p_result_id, p_student_id, p_assessment_id, p_raw_score, and the calculated v_percentage, respectively. The procedure includes an EXCEPTION handling block: if a NO_DATA_FOUND exception occurs from the initial SELECT, it raises a custom error with code -20002 stating the assessment ID was not found; if a ZERO_DIVIDE exception occurs during the percentage calculation, it raises a custom error with code -20003 for a division by zero error; for any other unexpected exception, it raises a custom error with code -20004 and includes the system error message from SQLERRM.",
    "original_summary": "Create a stored procedure named InsertAssessmentResult to insert a student's assessment result. It calculates the percentage score from the raw score and the assessment's total question count. Validate that the assessment exists and that its total questions is not zero or null. Handle specific exceptions: assessment not found, division by zero, and any other unexpected errors, raising appropriate application errors for each.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called InsertAssessmentResult to put in a student's test result. It should figure out the percentage from the student's score and the total number of questions on the test. Check that the test is actually there and that the total questions is a reasonable number, not zero or missing. If the test can't be found, or if there's a math problem with dividing, or if something else weird happens, catch those issues and throw suitable error messages."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_measurement_cm_from_inch that accepts a single input parameter p_measurement_id of the NUMBER data type, which is used to identify a specific record, and performs an update operation on the MEASUREMENTS table, specifically setting the value of the BUST_CM column to the result of a calculation that multiplies the existing value in the BUST_INCH column by the conversion factor 2.54 and then applies the CEIL function to round the resulting product up to the nearest whole integer, and this update is applied only to the single row where the value in the MEASUREMENT_ID column is exactly equal to the value provided in the input parameter p_measurement_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_measurement_cm_from_inch(p_measurement_id NUMBER) IS\nBEGIN\n  UPDATE MEASUREMENTS\n  SET BUST_CM = CEIL(BUST_INCH * 2.54)\n  WHERE MEASUREMENT_ID = p_measurement_id;\nEND;",
    "database_name": "fashion_scam_standards",
    "tables": [
      "COUNTRIES",
      "MEASUREMENTS",
      "MEASUREMENT_GUIDELINES",
      "PRODUCT_LINES",
      "REGIONS",
      "SIZE_CHARTS",
      "SIZE_ISSUES"
    ],
    "call_sqls": [
      "BEGIN\n  update_measurement_cm_from_inch(0);\n  commit;\nEND;",
      "BEGIN\n  update_measurement_cm_from_inch(1);\n  commit;\nEND;",
      "BEGIN\n  update_measurement_cm_from_inch(2);\n  commit;\nEND;",
      "BEGIN\n  update_measurement_cm_from_inch(3);\n  commit;\nEND;",
      "BEGIN\n  update_measurement_cm_from_inch(4);\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_measurement_cm_from_inch that accepts a measurement ID and updates the MEASUREMENTS table by converting the BUST_INCH value for that specific record to centimeters, setting the BUST_CM column to the rounded-up result of multiplying BUST_INCH by 2.54.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_measurement_cm_from_inch that, for a given measurement ID, updates the MEASUREMENTS table by setting the BUST_CM column to the ceiling value of BUST_INCH multiplied by 2.54.",
    "id": 72,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_measurement_cm_from_inch that accepts a single input parameter p_measurement_id of type NUMBER, which represents the identifier of the measurement record to be updated. The procedure operates on the MEASUREMENTS table within the fashion_scam_standards database. It executes an UPDATE statement on the MEASUREMENTS table, specifically targeting the row where the measurement_id column matches the value of the p_measurement_id parameter. For that row, the procedure sets the BUST_CM column to the result of the CEIL function applied to the expression BUST_INCH * 2.54, effectively converting the bust measurement from inches to centimeters and rounding up to the nearest whole number. The procedure does not include explicit exception handling or return a value.",
    "original_summary": "Create a stored procedure named update_measurement_cm_from_inch that accepts a measurement ID. Update the MEASUREMENTS table to set the BUST_CM column to the ceiling of the BUST_INCH value multiplied by 2.54 for the specified record.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure update_measurement_cm_from_inch. For given ID, set BUST_CM to ceiling(BUST_INCH * 2.54) in MEASUREMENTS."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ManageDataset that takes multiple parameters: p_dataset_id (NUMBER), p_territory_level_id (NUMBER), p_region_id (VARCHAR2), p_indicator_id (VARCHAR2), p_unit_id (VARCHAR2), p_position_id (VARCHAR2), p_sex_id (VARCHAR2), p_year (NUMBER), p_time_period (NUMBER), p_value (NUMBER), p_flag_codes (VARCHAR2), p_flags (VARCHAR2), p_data_collection_method (VARCHAR2), p_data_collection_frequency (VARCHAR2), and p_version (NUMBER). The procedure first declares a local variable v_exists of type NUMBER. It then performs a SELECT COUNT(*) query on the DATASETS table to determine if a record with DATASET_ID equal to p_dataset_id exists, storing the result in v_exists. If v_exists equals 0, indicating no existing record, the procedure inserts a new row into the DATASETS table with the provided parameter values for DATASET_ID, TERRITORY_LEVEL_ID, REGION_ID, INDICATOR_ID, UNIT_ID, POSITION_ID, SEX_ID, YEAR, TIME_PERIOD, VALUE, FLAG_CODES, FLAGS, DATA_COLLECTION_METHOD, DATA_COLLECTION_FREQUENCY, and VERSION, along with the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' for both CREATED_AT and UPDATED_AT columns. If v_exists equals 1, indicating an existing record, the procedure updates the VALUE column of the DATASETS table for the row with DATASET_ID equal to p_dataset_id, setting it to p_value and updating the UPDATED_AT column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS'. If v_exists is greater than 1, the procedure deletes all rows from the DATASETS table where DATASET_ID matches p_dataset_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManageDataset(\n    p_dataset_id NUMBER,\n    p_territory_level_id NUMBER,\n    p_region_id VARCHAR2,\n    p_indicator_id VARCHAR2,\n    p_unit_id VARCHAR2,\n    p_position_id VARCHAR2,\n    p_sex_id VARCHAR2,\n    p_year NUMBER,\n    p_time_period NUMBER,\n    p_value NUMBER,\n    p_flag_codes VARCHAR2,\n    p_flags VARCHAR2,\n    p_data_collection_method VARCHAR2,\n    p_data_collection_frequency VARCHAR2,\n    p_version NUMBER\n) AS\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_exists\n    FROM DATASETS\n    WHERE DATASET_ID = p_dataset_id;\n\n    IF v_exists = 0 THEN\n        INSERT INTO DATASETS (\n            DATASET_ID, TERRITORY_LEVEL_ID, REGION_ID, INDICATOR_ID, UNIT_ID, POSITION_ID, SEX_ID, YEAR, TIME_PERIOD, VALUE, FLAG_CODES, FLAGS, DATA_COLLECTION_METHOD, DATA_COLLECTION_FREQUENCY, VERSION, CREATED_AT, UPDATED_AT\n        ) VALUES (\n            p_dataset_id, p_territory_level_id, p_region_id, p_indicator_id, p_unit_id, p_position_id, p_sex_id, p_year, p_time_period, p_value, p_flag_codes, p_flags, p_data_collection_method, p_data_collection_frequency, p_version, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n        );\n    ELSIF v_exists = 1 THEN\n        UPDATE DATASETS\n        SET VALUE = p_value, UPDATED_AT = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')\n        WHERE DATASET_ID = p_dataset_id;\n    ELSE\n        DELETE FROM DATASETS\n        WHERE DATASET_ID = p_dataset_id;\n    END IF;\nEND;",
    "database_name": "demographic_ahs_652164",
    "tables": [
      "DATASETS",
      "DATASET_VERSIONS",
      "INDICATORS",
      "POSITIONS",
      "SEX",
      "UNITS"
    ],
    "call_sqls": [
      "BEGIN\n  ManageDataset(\n    p_dataset_id => 1,\n    p_territory_level_id => 101,\n    p_region_id => 'R1',\n    p_indicator_id => 'IND001',\n    p_unit_id => 'UNIT01',\n    p_position_id => 'POS01',\n    p_sex_id => 'M',\n    p_year => 2023,\n    p_time_period => 1,\n    p_value => 100.5,\n    p_flag_codes => 'E',\n    p_flags => 'Estimated',\n    p_data_collection_method => 'Survey',\n    p_data_collection_frequency => 'Annual',\n    p_version => 1\n  );\nEND;",
      "BEGIN\n  ManageDataset(\n    p_dataset_id => 2,\n    p_territory_level_id => 102,\n    p_region_id => 'R2',\n    p_indicator_id => 'IND002',\n    p_unit_id => 'UNIT02',\n    p_position_id => 'POS02',\n    p_sex_id => 'F',\n    p_year => 2022,\n    p_time_period => 4,\n    p_value => 250.75,\n    p_flag_codes => 'P',\n    p_flags => 'Provisional',\n    p_data_collection_method => 'Census',\n    p_data_collection_frequency => 'Quarterly',\n    p_version => 1\n  );\nEND;",
      "BEGIN\n  ManageDataset(\n    p_dataset_id => 1,\n    p_territory_level_id => 101,\n    p_region_id => 'R1',\n    p_indicator_id => 'IND001',\n    p_unit_id => 'UNIT01',\n    p_position_id => 'POS01',\n    p_sex_id => 'M',\n    p_year => 2023,\n    p_time_period => 1,\n    p_value => 110.2,\n    p_flag_codes => 'F',\n    p_flags => 'Final',\n    p_data_collection_method => 'Survey',\n    p_data_collection_frequency => 'Annual',\n    p_version => 2\n  );\nEND;",
      "BEGIN\n  ManageDataset(\n    p_dataset_id => 3,\n    p_territory_level_id => 103,\n    p_region_id => 'R3',\n    p_indicator_id => 'IND003',\n    p_unit_id => 'UNIT03',\n    p_position_id => 'POS03',\n    p_sex_id => 'U',\n    p_year => 2021,\n    p_time_period => 2,\n    p_value => 50.0,\n    p_flag_codes => NULL,\n    p_flags => NULL,\n    p_data_collection_method => 'Administrative',\n    p_data_collection_frequency => 'Monthly',\n    p_version => 1\n  );\nEND;",
      "BEGIN\n  ManageDataset(\n    p_dataset_id => 4,\n    p_territory_level_id => 104,\n    p_region_id => 'R4',\n    p_indicator_id => 'IND004',\n    p_unit_id => 'UNIT04',\n    p_position_id => 'POS04',\n    p_sex_id => 'M',\n    p_year => 2024,\n    p_time_period => 1,\n    p_value => 0,\n    p_flag_codes => 'N',\n    p_flags => 'Not Applicable',\n    p_data_collection_method => 'Observation',\n    p_data_collection_frequency => 'Daily',\n    p_version => 1\n  );\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named ManageDataset that, for a given dataset_id and associated parameters (territory_level_id, region_id, indicator_id, unit_id, position_id, sex_id, year, time_period, value, flag_codes, flags, data_collection_method, data_collection_frequency, version), manages records in the DATASETS table. If no record with that dataset_id exists, insert a new record with all provided values and set both CREATED_AT and UPDATED_AT to the current timestamp. If exactly one record with that dataset_id exists, update its VALUE and UPDATED_AT columns. If more than one record with that dataset_id exists, delete all records for that dataset_id.",
    "natural_language": "Hey, can you whip up a Oracle PL/SQL stored procedure called ManageDataset that handles upserts and deletes on the DATASETS table? Here's the deal: it should take parameters for DATASET_ID, TERRITORY_LEVEL_ID, REGION_ID, INDICATOR_ID, UNIT_ID, POSITION_ID, SEX_ID, YEAR, TIME_PERIOD, VALUE, FLAG_CODES, FLAGS, DATA_COLLECTION_METHOD, DATA_COLLECTION_FREQUENCY, and VERSION. First, check if there's already a record with the given DATASET_ID. If there's none, insert a new record with all the provided values, and set CREATED_AT and UPDATED_AT to the current time. If there's exactly one matching record, update its VALUE and UPDATED_AT fields. But if you find more than one record with that ID, delete all of them.",
    "id": 73,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named ManageDataset that takes multiple parameters: p_dataset_id (NUMBER), p_territory_level_id (NUMBER), p_region_id (VARCHAR2), p_indicator_id (VARCHAR2), p_unit_id (VARCHAR2), p_position_id (VARCHAR2), p_sex_id (VARCHAR2), p_year (NUMBER), p_time_period (NUMBER), p_value (NUMBER), p_flag_codes (VARCHAR2), p_flags (VARCHAR2), p_data_collection_method (VARCHAR2), p_data_collection_frequency (VARCHAR2), and p_version (NUMBER). The procedure first declares a local variable v_exists of type NUMBER. It then performs a SELECT COUNT(*) query on the DATASETS table to determine if a record with DATASET_ID equal to p_dataset_id exists, storing the result in v_exists. If v_exists equals 0, indicating no existing record, the procedure inserts a new row into the DATASETS table with the provided parameter values for DATASET_ID, TERRITORY_LEVEL_ID, REGION_ID, INDICATOR_ID, UNIT_ID, POSITION_ID, SEX_ID, YEAR, TIME_PERIOD, VALUE, FLAG_CODES, FLAGS, DATA_COLLECTION_METHOD, DATA_COLLECTION_FREQUENCY, and VERSION, along with the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' for both CREATED_AT and UPDATED_AT columns. If v_exists equals 1, indicating an existing record, the procedure updates the VALUE column of the DATASETS table for the row with DATASET_ID equal to p_dataset_id, setting it to p_value and updating the UPDATED_AT column to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS'. If v_exists is greater than 1, the procedure deletes all rows from the DATASETS table where DATASET_ID matches p_dataset_id.",
    "original_summary": "Create a stored procedure named ManageDataset that performs an upsert or delete on a DATASETS table. It checks if a record with the given dataset_id exists. If it does not exist, insert a new record with all provided parameter values and set CREATED_AT and UPDATED_AT to the current timestamp. If exactly one record exists, update its VALUE and UPDATED_AT columns. If more than one record exists, delete all records with that dataset_id.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called ManageDataset that handles upserts and deletes on the DATASETS table? Here's the deal: it should first check if there's already a record with the given dataset_id. If there's none, just pop in a new record with all the values we give you, and stamp CREATED_AT and UPDATED_AT with the current time. If there's exactly one matching record, go ahead and update its VALUE and UPDATED_AT fields. But if you find more than one record with that ID, that's messyso just delete all of 'em."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts two input parameters: `para_neighborhood_id` of type `NUMBER`, representing a specific neighborhood identifier, and `para_owner_name` of type `VARCHAR2`, representing the name of an owner. The procedure first declares three local variables: `v_owner_count` of type `NUMBER` to store the count of owners, `v_avg_price` of type `NUMBER` to store an average sale price, and `v_new_avg` of type `NUMBER` to store a median income.\n\nThe procedure begins by executing a `SELECT` statement to count the number of records in the `OWNERS` table where the `OWNER_NAME` column matches the value provided in `para_owner_name`. This count is then stored in the `v_owner_count` variable.\n\nNext, a conditional `IF` statement evaluates whether the `v_owner_count` is greater than 2.\n\nIf `v_owner_count` is greater than 2, the procedure proceeds with the following operations:\n1. It executes another `SELECT` statement to calculate the average of the `SALE_PRICE` column from the `SALES` table. This average is calculated only for sales records where the `PROPERTY_ID` exists in a subquery result. The subquery selects `PROPERTY_ID` values from the `OWNERS` table where the `OWNER_NAME` matches `para_owner_name`. The calculated average sale price is stored in the `v_avg_price` variable.\n2. A nested conditional `IF` statement then checks if `v_avg_price` is greater than 200000.\n   - If `v_avg_price` is greater than 200000, an `UPDATE` statement is executed on the `NEIGHBORHOODS` table. This statement increments the `AVERAGE_HOME_VALUE` column by 5000 for the record where the `NEIGHBORHOOD_ID` matches `para_neighborhood_id`.\n3. Following this, a `DELETE` statement is executed on the `SALES` table. This statement removes all records from `SALES` where the `PROPERTY_ID` exists in a subquery result. The subquery selects `PROPERTY_ID` values from the `OWNERS` table where the `OWNER_NAME` matches `para_owner_name`.\n4. Finally, another `DELETE` statement is executed on the `OWNERS` table. This statement removes all records from `OWNERS` where the `OWNER_NAME` column matches `para_owner_name`.\n\nIf `v_owner_count` is not greater than 2 (i.e., it is 2 or less), the procedure executes the `ELSE` block:\n1. It executes a `SELECT` statement to retrieve the `MEDIAN_INCOME` from the `NEIGHBORHOODS` table for the record where the `NEIGHBORHOOD_ID` matches `para_neighborhood_id`. This retrieved median income is stored in the `v_new_avg` variable.\n2. An `UPDATE` statement is then executed on the `OWNERS` table. This statement sets the `OWNER_INCOME` column to the value stored in `v_new_avg` for all records where the `OWNER_NAME` column matches `para_owner_name`.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(para_neighborhood_id NUMBER, para_owner_name VARCHAR2) IS\n    v_owner_count NUMBER;\n    v_avg_price NUMBER;\n    v_new_avg NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_owner_count FROM OWNERS WHERE OWNER_NAME = para_owner_name;\n    IF v_owner_count > 2 THEN\n        SELECT AVG(SALE_PRICE) INTO v_avg_price FROM SALES WHERE PROPERTY_ID IN (SELECT PROPERTY_ID FROM OWNERS WHERE OWNER_NAME = para_owner_name);\n        IF v_avg_price > 200000 THEN\n            UPDATE NEIGHBORHOODS SET AVERAGE_HOME_VALUE = AVERAGE_HOME_VALUE + 5000 WHERE NEIGHBORHOOD_ID = para_neighborhood_id;\n        END IF;\n        DELETE FROM SALES WHERE PROPERTY_ID IN (SELECT PROPERTY_ID FROM OWNERS WHERE OWNER_NAME = para_owner_name);\n        DELETE FROM OWNERS WHERE OWNER_NAME = para_owner_name;\n    ELSE\n        SELECT MEDIAN_INCOME INTO v_new_avg FROM NEIGHBORHOODS WHERE NEIGHBORHOOD_ID = para_neighborhood_id;\n        UPDATE OWNERS SET OWNER_INCOME = v_new_avg WHERE OWNER_NAME = para_owner_name;\n    END IF;\nEND;",
    "database_name": "real_epaa_valuation",
    "tables": [
      "NEIGHBORHOODS",
      "OWNERS",
      "SALES"
    ],
    "call_sqls": [
      "BEGIN\n  sp(0, 'John Smith');\n  commit;\nEND;",
      "BEGIN\n  sp(1, 'Jane Doe');\n  commit;\nEND;",
      "BEGIN\n  sp(0, 'Alice Johnson');\n  commit;\nEND;",
      "BEGIN\n  sp(1, 'Charlie Brown');\n  commit;\nEND;",
      "BEGIN\n  sp(0, 'Bob Smith');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp that accepts a neighborhood ID and an owner name, counts how many owners have that name in the OWNERS table, and then performs one of two actions based on that count. If the count exceeds 2, calculate the average SALE_PRICE from the SALES table for properties owned by that owner; if this average exceeds 200,000, increase the AVERAGE_HOME_VALUE in the NEIGHBORHOODS table for the specified neighborhood ID by 5000, then delete all records from the SALES and OWNERS tables for that owner. If the owner count is 2 or less, update the OWNER_INCOME in the OWNERS table for all owners with that name to match the MEDIAN_INCOME from the NEIGHBORHOODS table for the specified neighborhood ID.",
    "natural_language": "Write a Oracle PL/SQL stored procedure named sp that takes a neighborhood ID and a property owner's full name as inputs. If more than two distinct owners in the OWNERS table share that exact name, calculate the average SALE_PRICE from the SALES table for all properties owned by those owners. If this average exceeds $200,000, increase the AVERAGE_HOME_VALUE for the specified NEIGHBORHOOD_ID by $5,000 in the NEIGHBORHOODS table. Then, delete all related sales records from SALES and all owner records with that name from OWNERS. Otherwise, if two or fewer owners have that name, update the OWNER_INCOME for each of those owners in OWNERS to match the MEDIAN_INCOME of the given neighborhood from NEIGHBORHOODS.",
    "id": 74,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp that accepts two input parameters: p_neighborhood_id of type NUMBER representing the neighborhood identification number, and p_owner_name of type VARCHAR2 representing the full name of a property owner. The procedure first queries the OWNERS table to count the number of distinct owner records where the owner_name column exactly matches the provided p_owner_name parameter, storing this count in a local variable v_owner_count. If v_owner_count is greater than 2, the procedure proceeds to calculate the average sale price from the SALES table for all properties owned by those owners. This is done by selecting the average of the sale_price column from the SALES table where the owner_id exists in a subquery that selects owner_id from the OWNERS table where owner_name equals p_owner_name, storing this average in a local variable v_avg_sale_price. If v_avg_sale_price exceeds 200000, the procedure updates the NEIGHBORHOODS table by increasing the average_home_value column by 5000 for the row where neighborhood_id equals p_neighborhood_id. Following this update, the procedure deletes all records from the SALES table where the owner_id exists in the same subquery selecting owner_id from OWNERS where owner_name equals p_owner_name. Then, it deletes all records from the OWNERS table where owner_name equals p_owner_name. If v_owner_count is 2 or less (i.e., not greater than 2), the procedure updates the OWNERS table by setting the owner_income column to the median_income value from the NEIGHBORHOODS table for the row where neighborhood_id equals p_neighborhood_id, but only for those owner records where owner_name equals p_owner_name.",
    "original_summary": "Create a stored procedure named sp that accepts a neighborhood ID and an owner name. Count how many owners have that name. If the count exceeds 2, calculate the average sale price for that owner's properties. If this average exceeds 200,000, increase the AVERAGE_HOME_VALUE for the specified neighborhood by 5000. Then, delete all sales and owner records for that owner. If the owner count is 2 or less, update the income for all owners with that name to match the specified neighborhood's MEDIAN_INCOME.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Develop a stored procedure, which we shall name 'sp', that is designed to receive two specific input parameters: a unique identifier for a neighborhood and the full name of a property owner. This procedure should first perform a comprehensive count to determine exactly how many distinct owners within the database share that precise name. Should this detailed count reveal a total greater than two, the procedure must then proceed to meticulously calculate the average sale price across all properties owned by individuals with that name. Furthermore, if this calculated average price is found to be substantially above the threshold of two hundred thousand dollars, the procedure must consequently increase the AVERAGE_HOME_VALUE metric for the precisely specified neighborhood by a significant increment of five thousand. Following these conditional updates, it must then thoroughly and permanently delete all associated sales records and the owner records pertaining to that particular owner name. Conversely, if the initial, careful count determines that the number of owners with that name is two or fewer, the procedure must instead update the income field for every single owner bearing that name, setting it to equal the MEDIAN_INCOME value of the neighborhood that was originally specified as a parameter."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_claims_from_json that accepts a single input parameter p_json_data of type CLOB, which contains a JSON array of claim objects. The procedure parses this JSON array using a JSON_TABLE expression, iterating over each JSON object to extract three fields: claim_id as a NUMBER, status as a VARCHAR2(255), and amount as a NUMBER. For each extracted record, the procedure first calculates a new claim ID by selecting the maximum existing claim_id from the claims table, adding 1 to it, and storing the result in variable v_claim_id; if the table is empty, it uses 0 as the base. Then, based on the extracted status value, it executes conditional logic: if the status equals 'new', it performs an INSERT into the claims table, populating claim_id with the newly generated v_claim_id, setting exe_idno to 1, report_date to the current system date formatted as 'YYYY-MM-DD', incident_date to the previous day formatted as 'YYYY-MM-DD', claim_status to 'open', and estimated_loss to the extracted amount value; if the status equals 'update', it executes an UPDATE on the claims table, setting the estimated_loss column to the extracted amount for the row where the claim_id matches the extracted claim_id; if the status equals 'close', it executes an UPDATE on the claims table, setting the claim_status column to 'closed' for the row where the claim_id matches the extracted claim_id; for any other status value, it performs an INSERT into the claim_status_history table, populating claim_id with the extracted claim_id, status_date with the current system date formatted as 'YYYY-MM-DD', status with the literal value 'review', and changed_by with the value 1.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_claims_from_json(p_json_data CLOB)\nIS\n    v_claim_id NUMBER;\n    v_status VARCHAR2(255);\n    v_amount NUMBER;\nBEGIN\n    FOR rec IN (\n        SELECT * FROM JSON_TABLE(p_json_data, '$[*]' \n        COLUMNS (\n            claim_id NUMBER PATH '$.claim_id',\n            status VARCHAR2(255) PATH '$.status',\n            amount NUMBER PATH '$.amount'\n        )) jt\n    ) LOOP\n        SELECT NVL(MAX(claim_id), 0) + 1 INTO v_claim_id FROM claims;\n\n        IF rec.status = 'new' THEN\n            INSERT INTO claims (claim_id, exe_idno, report_date, incident_date, claim_status, estimated_loss)\n            VALUES (v_claim_id, 1, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE-1, 'YYYY-MM-DD'), 'open', rec.amount);\n        ELSIF rec.status = 'update' THEN\n            UPDATE claims SET estimated_loss = rec.amount WHERE claim_id = rec.claim_id;\n        ELSIF rec.status = 'close' THEN\n            UPDATE claims SET claim_status = 'closed' WHERE claim_id = rec.claim_id;\n        ELSE\n            INSERT INTO claim_status_history (claim_id, status_date, status, changed_by)\n            VALUES (rec.claim_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'review', 1);\n        END IF;\n    END LOOP;\nEND;",
    "database_name": "insurance_car_management",
    "tables": [
      "CLAIMS",
      "CLAIM_STATUS_HISTORY",
      "PAYMENTS",
      "POLICIES"
    ],
    "call_sqls": [
      "BEGIN\n  update_claims_from_json('[\n    {\"claim_id\": 1, \"status\": \"new\", \"amount\": 10000},\n    {\"claim_id\": 2, \"status\": \"update\", \"amount\": 15000}\n  ]');\n  commit;\nEND;",
      "BEGIN\n  update_claims_from_json('[\n    {\"claim_id\": 3, \"status\": \"close\", \"amount\": 0},\n    {\"claim_id\": 4, \"status\": \"new\", \"amount\": 20000}\n  ]');\n  commit;\nEND;",
      "BEGIN\n  update_claims_from_json('[\n    {\"claim_id\": 5, \"status\": \"review\", \"amount\": 0},\n    {\"claim_id\": 6, \"status\": \"new\", \"amount\": 5000}\n  ]');\n  commit;\nEND;",
      "BEGIN\n  update_claims_from_json('[\n    {\"claim_id\": 7, \"status\": \"update\", \"amount\": 12000},\n    {\"claim_id\": 8, \"status\": \"close\", \"amount\": 0}\n  ]');\n  commit;\nEND;",
      "BEGIN\n  update_claims_from_json('[\n    {\"claim_id\": 9, \"status\": \"new\", \"amount\": 25000},\n    {\"claim_id\": 10, \"status\": \"review\", \"amount\": 0}\n  ]');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_claims_from_json that processes a JSON array of claims, each containing a claim ID, status, and amount. For each claim, if the status is 'new', insert a new record into the CLAIMS table with a generated claim ID, default execution ID, current report date, previous incident date, 'open' status, and the provided amount. If the status is 'update', update the ESTIMATED_LOSS in the CLAIMS table for the given claim ID. If the status is 'close', update the CLAIM_STATUS in the CLAIMS table to 'closed' for the given claim ID. For any other status, insert a record into the CLAIM_STATUS_HISTORY table with the claim ID, current date, 'review' status, and a default user ID.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_claims_from_json that processes a JSON array of claims. For each claim in the array, if the status is 'new', insert a new claim into the CLAIMS table with a generated claim_id, default values for exe_idno, report_date, incident_date, and claim_status, and the provided amount as estimated_loss. If the status is 'update', update the estimated_loss in the CLAIMS table for the specified claim_id. If the status is 'close', update the claim_status to 'closed' in the CLAIMS table for the specified claim_id. For any other status, log a 'review' entry in the CLAIM_STATUS_HISTORY table for the claim_id.",
    "id": 75,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_claims_from_json that accepts a single input parameter p_json_data of type CLOB, which contains a JSON array of claim objects to be processed. The procedure declares a local variable v_claim_id of type NUMBER to store the claim identifier, and a local variable v_status of type VARCHAR2(20) to store the status extracted from each JSON object.\n\nThe procedure begins by parsing the JSON array from the p_json_data parameter. It then enters a loop that iterates over each element in the JSON array. For each JSON object in the array, the procedure extracts the value of the 'status' field into the v_status variable and the value of the 'claim_id' field into the v_claim_id variable. It also extracts the value of the 'amount' field, which represents the estimated loss, into a local variable.\n\nThe procedure then uses a conditional IF-ELSIF-ELSE control structure to handle different status values. If the v_status equals the string literal 'new', the procedure performs an INSERT operation into the CLAIMS table. It generates a new claim_id using a sequence (e.g., CLAIM_ID_SEQ.NEXTVAL) and sets the following columns: exe_idno to a default value (e.g., 0), report_date to the current system date (SYSDATE), incident_date to a default date (e.g., SYSDATE), claim_status to the string 'open', and estimated_loss to the amount value extracted from the JSON object.\n\nIf the v_status equals the string literal 'update', the procedure performs an UPDATE operation on the CLAIMS table. It sets the estimated_loss column to the amount value extracted from the JSON object, but only for the row where the claim_id column matches the v_claim_id value extracted from the JSON object.\n\nIf the v_status equals the string literal 'close', the procedure performs an UPDATE operation on the CLAIMS table. It sets the claim_status column to the string 'closed', but only for the row where the claim_id column matches the v_claim_id value extracted from the JSON object.\n\nFor any other status value (i.e., when v_status is not 'new', 'update', or 'close'), the procedure performs an INSERT operation into the CLAIM_STATUS_HISTORY table. It inserts a new row with the claim_id set to the v_claim_id value extracted from the JSON object and the status set to the string 'review'. The procedure may also include additional columns such as a timestamp (e.g., SYSDATE) and a user identifier if the table schema requires them.\n\nAfter processing all elements in the JSON array, the procedure commits the transaction to save all changes made by the INSERT and UPDATE operations. The procedure includes exception handling to rollback the transaction and raise an error if any operation fails.",
    "original_summary": "Create a stored procedure named update_claims_from_json that processes a JSON array of claims. For each claim object, extract the claim ID, status, and amount. If the status is 'new', insert a new claim with generated ID and dates. If 'update', update the claim's amount. If 'close', update the claim status to 'closed'. For any other status, insert a record into a history table with status 'review'.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure update_claims_from_json to process a JSON array. For each claim: if status 'new', insert new claim; if 'update', update amount; if 'close', set status to 'closed'; else, log 'review' in history."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `insert_new_appointment` that accepts four parameters: an input parameter `p_patient_id` of type NUMBER representing the unique identifier of the patient, an input parameter `p_doctor_id` of type NUMBER representing the unique identifier of the doctor, an input parameter `p_appointment_date` of type VARCHAR2 representing the date and time of the appointment, and an output parameter `p_new_appointment_id` of type NUMBER which will be populated with the newly generated appointment identifier. The procedure first executes a SELECT statement on the `APPOINTMENTS` table to retrieve the maximum existing value from the `APPOINTMENT_ID` column, increments this maximum value by one, and assigns the result into the output parameter `p_new_appointment_id`. It then executes an INSERT statement into the `APPOINTMENTS` table, specifying the columns `APPOINTMENT_ID`, `PATIENT_ID`, `DOCTOR_ID`, `APPOINTMENT_DATE`, and `STATUS`. The inserted values are the generated `p_new_appointment_id`, the input `p_patient_id`, the input `p_doctor_id`, the input `p_appointment_date`, and the literal string 'scheduled' for the `STATUS` column.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_appointment(\n    p_patient_id IN NUMBER,\n    p_doctor_id IN NUMBER,\n    p_appointment_date IN VARCHAR2,\n    p_new_appointment_id OUT NUMBER\n)\nIS\nBEGIN\n    SELECT MAX(APPOINTMENT_ID) + 1\n    INTO p_new_appointment_id\n    FROM APPOINTMENTS;\n    \n    INSERT INTO APPOINTMENTS (APPOINTMENT_ID, PATIENT_ID, DOCTOR_ID, APPOINTMENT_DATE, STATUS)\n    VALUES (p_new_appointment_id, p_patient_id, p_doctor_id, p_appointment_date, 'scheduled');\nEND;",
    "database_name": "healthcare_daap_outcomes",
    "tables": [
      "APPOINTMENTS",
      "PATIENTS",
      "DOCTORS"
    ],
    "call_sqls": [
      "DECLARE\n  v_new_appointment_id NUMBER;\nBEGIN\n  insert_new_appointment(\n    p_patient_id => 1,\n    p_doctor_id => 0,\n    p_appointment_date => '2023-07-01',\n    p_new_appointment_id => v_new_appointment_id\n  );\n  DBMS_OUTPUT.PUT_LINE('New Appointment ID: ' || v_new_appointment_id);\nEND;",
      "DECLARE\n  v_new_appointment_id NUMBER;\nBEGIN\n  insert_new_appointment(\n    p_patient_id => 0,\n    p_doctor_id => 1,\n    p_appointment_date => '2023-07-05',\n    p_new_appointment_id => v_new_appointment_id\n  );\n  DBMS_OUTPUT.PUT_LINE('New Appointment ID: ' || v_new_appointment_id);\nEND;",
      "DECLARE\n  v_new_appointment_id NUMBER;\nBEGIN\n  insert_new_appointment(\n    p_patient_id => 1,\n    p_doctor_id => 1,\n    p_appointment_date => '2023-07-10',\n    p_new_appointment_id => v_new_appointment_id\n  );\n  DBMS_OUTPUT.PUT_LINE('New Appointment ID: ' || v_new_appointment_id);\nEND;",
      "DECLARE\n  v_new_appointment_id NUMBER;\nBEGIN\n  insert_new_appointment(\n    p_patient_id => 0,\n    p_doctor_id => 0,\n    p_appointment_date => '2023-07-15',\n    p_new_appointment_id => v_new_appointment_id\n  );\n  DBMS_OUTPUT.PUT_LINE('New Appointment ID: ' || v_new_appointment_id);\nEND;",
      "DECLARE\n  v_new_appointment_id NUMBER;\nBEGIN\n  insert_new_appointment(\n    p_patient_id => 1,\n    p_doctor_id => 0,\n    p_appointment_date => '2023-07-20',\n    p_new_appointment_id => v_new_appointment_id\n  );\n  DBMS_OUTPUT.PUT_LINE('New Appointment ID: ' || v_new_appointment_id);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named insert_new_appointment that accepts a patient ID, a doctor ID, and an appointment date as inputs, generates a new appointment ID by incrementing the highest existing APPOINTMENT_ID from the APPOINTMENTS table, inserts a new record into the APPOINTMENTS table with the provided details and a status of 'scheduled', and returns the newly created appointment ID via an output parameter.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called insert_new_appointment that takes a patient ID, a doctor ID, and an appointment date as inputs, generates a new appointment ID by incrementing the highest existing APPOINTMENT_ID from the APPOINTMENTS table, inserts a new 'scheduled' appointment into the APPOINTMENTS table with the provided details and the generated ID, and returns the new appointment ID as an output.",
    "id": 76,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `insert_new_appointment` that accepts four parameters: an input parameter `p_patient_id` of type NUMBER representing the unique identifier of the patient, an input parameter `p_doctor_id` of type NUMBER representing the unique identifier of the doctor, an input parameter `p_appointment_date` of type VARCHAR2 representing the date and time of the appointment, and an output parameter `p_new_appointment_id` of type NUMBER which will be populated with the newly generated appointment identifier. The procedure first executes a SELECT statement on the `APPOINTMENTS` table to retrieve the maximum existing value from the `APPOINTMENT_ID` column, increments this maximum value by one, and assigns the result into the output parameter `p_new_appointment_id`. It then executes an INSERT statement into the `APPOINTMENTS` table, specifying the columns `APPOINTMENT_ID`, `PATIENT_ID`, `DOCTOR_ID`, `APPOINTMENT_DATE`, and `STATUS`. The inserted values are the generated `p_new_appointment_id`, the input `p_patient_id`, the input `p_doctor_id`, the input `p_appointment_date`, and the literal string 'scheduled' for the `STATUS` column.",
    "original_summary": "Create a stored procedure named insert_new_appointment that accepts patient ID, doctor ID, and appointment date as inputs. It generates a new appointment ID, inserts a new record with status 'scheduled' into the APPOINTMENTS table, and returns the new appointment ID via an output parameter.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure insert_new_appointment with inputs for patient ID, doctor ID, and appointment date. It generates and inserts a new 'scheduled' appointment, returning the new ID."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named consolidate_team_data that accepts a single input parameter p_team_id of type NUMBER, which identifies a specific team. The procedure first declares local variables v_team_name (VARCHAR2), v_member_count (NUMBER), v_access_count (NUMBER), v_total_updates (NUMBER), v_avg_updates (NUMBER), v_most_active_user (NUMBER), v_most_active_count (NUMBER), and v_team_exists (NUMBER). It begins by checking if the provided team ID exists in the research_teams table, performing a SELECT COUNT(*) into v_team_exists from the research_teams table where the team_id column equals p_team_id, and handling a NO_DATA_FOUND exception by setting v_team_exists to 0. If v_team_exists is greater than 0, the procedure proceeds to gather and process data for that team; otherwise, it does nothing. For an existing team, it retrieves the team_name from the research_teams table for the given p_team_id into v_team_name, handling NO_DATA_FOUND by setting v_team_name to 'Unknown'. It then counts the number of members in the team_members table where team_id equals p_team_id, storing the result in v_member_count and handling NO_DATA_FOUND by setting it to 0. Next, it counts the number of access records in the team_access table where team_id equals p_team_id, storing the result in v_access_count and handling NO_DATA_FOUND by setting it to 0. It also counts the total number of updates performed by team members by selecting COUNT(*) from the updates table, joining it with the team_members table on user_id, where the team_members.team_id equals p_team_id, storing the result in v_total_updates and handling NO_DATA_FOUND by setting it to 0. If v_member_count is greater than 0, it calculates the average updates per member by dividing v_total_updates by v_member_count and rounding to two decimal places, storing the result in v_avg_updates; otherwise, v_avg_updates is set to 0. The procedure then identifies the most active user within the team by selecting from a subquery that groups updates by user_id for users in the specified team, orders the results by update count in descending order, and selects the top row (using WHERE ROWNUM = 1) to retrieve the user_id and update_count into v_most_active_user and v_most_active_count, handling NO_DATA_FOUND by setting these variables to NULL and 0 respectively. Following data collection, the procedure performs two deletion operations: first, it deletes all records from the team_access table where the team_id equals p_team_id and the access_type column, converted to lowercase using the LOWER function, equals the string 'view'; second, it deletes all records from the team_members table where the team_id equals p_team_id and the role column, converted to lowercase using LOWER, equals the string 'data analyst'. Finally, the procedure inserts a new record into the updates table by selecting the next sequential update_id (calculated as the maximum existing update_id plus 1, or 0 if none exist using NVL), the current system date formatted as 'YYYY-MM-DD' using TO_CHAR(SYSDATE, 'YYYY-MM-DD'), a hardcoded user_id of 0, and a description string that concatenates the team name, member count, and access count into a summary message.",
    "plsql": "CREATE OR REPLACE PROCEDURE consolidate_team_data(p_team_id IN NUMBER)\nIS\n    v_team_name VARCHAR2(255);\n    v_member_count NUMBER := 0;\n    v_access_count NUMBER := 0;\n    v_total_updates NUMBER := 0;\n    v_avg_updates NUMBER := 0;\n    v_most_active_user NUMBER := NULL;\n    v_most_active_count NUMBER := 0;\n    v_team_exists NUMBER := 0;\nBEGIN\n    BEGIN\n        SELECT COUNT(*)\n        INTO v_team_exists\n        FROM research_teams\n        WHERE team_id = p_team_id;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_team_exists := 0;\n    END;\n    \n    IF v_team_exists > 0 THEN\n        BEGIN\n            SELECT team_name\n            INTO v_team_name\n            FROM research_teams\n            WHERE team_id = p_team_id;\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n                v_team_name := 'Unknown';\n        END;\n        \n        BEGIN\n            SELECT COUNT(*)\n            INTO v_member_count\n            FROM team_members\n            WHERE team_id = p_team_id;\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n                v_member_count := 0;\n        END;\n        \n        BEGIN\n            SELECT COUNT(*)\n            INTO v_access_count\n            FROM team_access\n            WHERE team_id = p_team_id;\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n                v_access_count := 0;\n        END;\n        \n        BEGIN\n            SELECT COUNT(*)\n            INTO v_total_updates\n            FROM updates u\n            JOIN team_members tm ON u.user_id = tm.user_id\n            WHERE tm.team_id = p_team_id;\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n                v_total_updates := 0;\n        END;\n        \n        IF v_member_count > 0 THEN\n            v_avg_updates := ROUND(v_total_updates / v_member_count, 2);\n        ELSE\n            v_avg_updates := 0;\n        END IF;\n        \n        BEGIN\n            SELECT user_id, update_count INTO v_most_active_user, v_most_active_count\n            FROM (\n                SELECT u.user_id, COUNT(*) AS update_count\n                FROM updates u\n                JOIN team_members tm ON u.user_id = tm.user_id\n                WHERE tm.team_id = p_team_id\n                GROUP BY u.user_id\n                ORDER BY COUNT(*) DESC\n            ) WHERE ROWNUM = 1;\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n                v_most_active_user := NULL;\n                v_most_active_count := 0;\n        END;\n        \n        DELETE FROM team_access\n        WHERE team_id = p_team_id\n        AND LOWER(access_type) = 'view';\n        \n        DELETE FROM team_members\n        WHERE team_id = p_team_id\n        AND LOWER(role) = 'data analyst';\n        \n        INSERT INTO updates (update_id, update_date, user_id, description)\n        SELECT NVL(MAX(update_id), 0) + 1, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 0, \n               'Team ' || v_team_name || ' consolidated: ' || v_member_count || ' members, ' || v_access_count || ' accesses'\n        FROM updates;\n    END IF;\nEND;",
    "database_name": "global_hawbi_549073",
    "tables": [
      "RESEARCH_TEAMS",
      "TEAM_ACCESS",
      "TEAM_MEMBERS",
      "USERS",
      "ACCESS_LOGS",
      "UPDATES"
    ],
    "call_sqls": [
      "BEGIN\n  consolidate_team_data(1);\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_team_data(2);\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_team_data(10);\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_team_data(15);\n  COMMIT;\nEND;",
      "BEGIN\n  consolidate_team_data(25);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named consolidate_team_data that accepts a team ID. It first verifies the team exists in the research_teams table. If it exists, it retrieves the team's name from research_teams, counts its members from team_members, counts its access records from team_access, and calculates the total number of updates from the updates table for users belonging to the team. It then computes the average updates per member and identifies the user with the most updates. Next, it deletes all 'view' access records for the team from team_access and removes all 'data analyst' members for the team from team_members. Finally, it inserts a summary record into the updates table containing the team name, member count, and access count.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called consolidate_team_data that takes a team ID. It must first verify if the team exists in the research_teams table. If it exists, retrieve the team's name from research_teams, count its members from team_members, count its access logs from team_access, and calculate the total number of updates from the updates table for members of that team. Then compute the average updates per member and identify the top contributor (user with the most updates) from the updates table. After that, remove all 'view' access logs for that team from team_access and delete any 'data analyst' members from that team in team_members. Finally, insert a summary record into the updates table with the team name, member count, and access count.",
    "id": 77,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named consolidate_team_data that accepts one input parameter: p_team_id of data type NUMBER, representing the unique identifier of a research team. The procedure operates within the global_hawbi_549073 database.\n\nThe procedure begins by declaring several local variables: v_team_name of type VARCHAR2 to store the team's name; v_member_count of type NUMBER to store the count of team members; v_access_count of type NUMBER to store the count of access logs; v_total_updates of type NUMBER to store the total number of updates; v_avg_updates_per_member of type NUMBER to store the calculated average; v_top_contributor of type VARCHAR2 to store the username of the top contributor; and v_top_contributor_updates of type NUMBER to store the update count of the top contributor. It also declares a variable v_team_exists of type BOOLEAN, initialized to FALSE, to track the existence of the team.\n\nThe first operation is a SELECT statement that queries the research_teams table to check if a record exists where the team_id column matches the input parameter p_team_id. If a record is found, the procedure sets v_team_exists to TRUE and retrieves the team_name column value into v_team_name.\n\nIf v_team_exists is TRUE, the procedure proceeds with a series of data retrieval and aggregation operations. It executes a SELECT statement with the COUNT function on the team_members table, counting rows where the team_id column equals p_team_id, and stores the result in v_member_count. It executes another SELECT statement with the COUNT function on the team_access table, counting rows where the team_id column equals p_team_id, and stores the result in v_access_count. It then executes a SELECT statement with the SUM function on the updates table, summing the update_count column for rows where the team_id column equals p_team_id, and stores the result in v_total_updates. If v_member_count is greater than zero, it calculates v_avg_updates_per_member by dividing v_total_updates by v_member_count; otherwise, v_avg_updates_per_member is set to 0.\n\nNext, the procedure identifies the top contributor from the updates table for the given team. It executes a SELECT statement that queries the updates table for rows where team_id equals p_team_id, groups the results by the user_name column, and calculates the total update_count per user using the SUM function. It orders the results in descending order by the total update_count and selects the first row using FETCH FIRST 1 ROW ONLY. The user_name and the summed update_count from this row are stored in v_top_contributor and v_top_contributor_updates, respectively. If no rows are found, both variables are set to NULL.\n\nFollowing the data retrieval, the procedure performs two data modification operations. It executes a DELETE statement on the team_access table to remove all rows where the team_id column equals p_team_id and the access_type column equals the string 'view'. It then executes another DELETE statement on the team_members table to remove all rows where the team_id column equals p_team_id and the role column equals the string 'data analyst'.\n\nFinally, the procedure executes an INSERT statement to add a summary record into the updates table. The values inserted are: the update_id is generated using a sequence named updates_seq via the NEXTVAL pseudocolumn; the team_id column receives the value from p_team_id; the user_name column is set to the constant string 'SYSTEM'; the update_count column is set to 1; the update_description column is populated with a concatenated string that includes the team name from v_team_name, the member count from v_member_count, and the access log count from v_access_count, formatted appropriately; and the update_timestamp column is set to the current system date and time using SYSTIMESTAMP.\n\nIf v_team_exists is FALSE at the beginning, the procedure does not perform any of the subsequent operations and terminates without taking any action. The procedure does not have a return value.",
    "original_summary": "Create a stored procedure named consolidate_team_data that accepts a team ID. It checks if the team exists, then retrieves its name, member count, access count, and total updates. It calculates average updates per member and identifies the most active user. It deletes 'view' access records and 'data analyst' members for the team. Finally, it inserts a summary record into the updates table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Alright, so we need a stored procedure called consolidate_team_data that takes a team ID. First, it's gotta check if that team actually exists. If it does, it'll pull the team's name, how many members it has, how many times they've accessed stuff, and the total number of updates. Then, it figures out the average updates per member and who the top contributor is. After that, it cleans house by getting rid of any 'view' access logs and kicking out any 'data analyst' members from that team. Finally, it drops a summary of all this into the updates table."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named InsertNewUser that accepts four input parameters: a username as a VARCHAR2 named p_username, a role as a VARCHAR2 named p_role, an email address as a VARCHAR2 named p_email, and a password hash as a VARCHAR2 named p_password_hash. The procedure first declares a local variable v_new_user_id of type NUMBER. It then calculates a new user identifier by querying the USERS table to find the maximum existing value in the USER_ID column, using the NVL function to substitute zero if no maximum is found, and adding one to that result, storing the outcome in v_new_user_id. Following this, it performs an INSERT operation into the USERS table, specifying the columns USER_ID, USERNAME, ROLE, EMAIL, PASSWORD_HASH, LAST_LOGIN, and IS_ACTIVE. The values inserted are the calculated v_new_user_id, the four input parameters p_username, p_role, p_email, and p_password_hash, a formatted string for the current date and time generated by applying TO_CHAR to CURRENT_DATE with the format model 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"', and the numeric value 1 for IS_ACTIVE. If any error occurs during execution, the procedure raises an application error with code -20001 and a message that concatenates the string 'An error occurred while inserting a new user: ' with the system error message from SQLERRM.",
    "plsql": "CREATE OR REPLACE PROCEDURE InsertNewUser(p_username VARCHAR2, p_role VARCHAR2, p_email VARCHAR2, p_password_hash VARCHAR2) IS\n  v_new_user_id NUMBER;\nBEGIN\n  -- Assuming a sequence USERS_SEQ exists, otherwise, this needs to be created\n  SELECT NVL(MAX(USER_ID), 0) + 1 INTO v_new_user_id FROM USERS;\n\n  INSERT INTO USERS (USER_ID, USERNAME, ROLE, EMAIL, PASSWORD_HASH, LAST_LOGIN, IS_ACTIVE)\n  VALUES (v_new_user_id, p_username, p_role, p_email, p_password_hash, TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"'), 1);\n\n  COMMIT;\nEXCEPTION\n  WHEN OTHERS THEN\n    ROLLBACK;\n    RAISE_APPLICATION_ERROR(-20001, 'An error occurred while inserting a new user: ' || SQLERRM);\nEND;",
    "database_name": "educational_caa_metrics",
    "tables": [
      "CANDIDATES",
      "GRADE_POINTS",
      "METRICS",
      "SUBJECT_CATEGORIES",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  InsertNewUser('new_user_1', 'student', 'new_user_1@example.com', 'hashed_password_1');\nEND;",
      "BEGIN\n  InsertNewUser('data_entry_clerk', 'data_entry', 'data_entry@example.com', 'hashed_password_2');\nEND;",
      "BEGIN\n  InsertNewUser('supervisor_user', 'supervisor', 'supervisor@example.com', 'hashed_password_3');\nEND;",
      "BEGIN\n  InsertNewUser('guest_viewer', 'guest', 'guest@example.com', 'hashed_password_4');\nEND;",
      "BEGIN\n  InsertNewUser('another_admin', 'admin', 'another_admin@example.com', 'hashed_password_5');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named InsertNewUser that accepts a username, role, email, and password hash, generates a new user ID by incrementing the maximum existing ID from the USERS table, and inserts a new active user record into the USERS table with these values, the current timestamp as the last login, and an active status, while handling any errors by rolling back and raising an application error.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called InsertNewUser that takes a username, role, email, and password hash as inputs, generates a new USER_ID by incrementing the maximum current USER_ID from the USERS table, inserts a new active user with these values and the current timestamp as LAST_LOGIN, and raises an error if the insertion fails.",
    "id": 78,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named InsertNewUser that accepts four input parameters: a username as a VARCHAR2 named p_username, a role as a VARCHAR2 named p_role, an email address as a VARCHAR2 named p_email, and a password hash as a VARCHAR2 named p_password_hash. The procedure first declares a local variable v_new_user_id of type NUMBER. It then calculates a new user identifier by querying the USERS table to find the maximum existing value in the USER_ID column, using the NVL function to substitute zero if no maximum is found, and adding one to that result, storing the outcome in v_new_user_id. Following this, it performs an INSERT operation into the USERS table, specifying the columns USER_ID, USERNAME, ROLE, EMAIL, PASSWORD_HASH, LAST_LOGIN, and IS_ACTIVE. The values inserted are the calculated v_new_user_id, the four input parameters p_username, p_role, p_email, and p_password_hash, a formatted string for the current date and time generated by applying TO_CHAR to CURRENT_DATE with the format model 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"', and the numeric value 1 for IS_ACTIVE. If any error occurs during execution, the procedure raises an application error with code -20001 and a message that concatenates the string 'An error occurred while inserting a new user: ' with the system error message from SQLERRM.",
    "original_summary": "Create a stored procedure named InsertNewUser that accepts a username, role, email, and password hash. Generate a new user ID by incrementing the maximum existing ID, then insert a new active user record with these values and the current timestamp as the last login. Handle errors by raising an application error.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create InsertNewUser procedure. Input: username, role, email, password hash. Generate new ID by incrementing max current ID. Insert active user with values and current timestamp as last login. Raise error on failure."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named migrate_customer_data that accepts two input parameters: p_old_customer_id of type NUMBER, which represents the identifier of the customer to be migrated, and p_new_customer_id of type NUMBER, which represents the new identifier to be assigned to the customer. The procedure first declares two local NUMBER variables, v_customer_exists and v_order_exists. It begins execution by querying the CUSTOMERS table to count the number of rows where the CUSTOMER_ID column equals the input parameter p_new_customer_id, storing the result in v_customer_exists. If the value of v_customer_exists is zero, indicating no customer currently exists with the new ID, it performs an INSERT operation into the CUSTOMERS table. This INSERT statement selects the FIRST_NAME, LAST_NAME, AGE, EMAIL, PHONE_NUMBER, and ADDRESS column values from the CUSTOMERS table where the CUSTOMER_ID equals p_old_customer_id, and inserts a new row using these selected values while explicitly setting the CUSTOMER_ID column to the value of p_new_customer_id. Next, the procedure queries the ORDERS table to count the number of rows where the CUSTOMER_ID column equals p_old_customer_id, storing this count in v_order_exists. If v_order_exists is greater than zero, meaning at least one order exists for the old customer, it executes an UPDATE statement on the ORDERS table, setting the CUSTOMER_ID column to p_new_customer_id for all rows where the CUSTOMER_ID column currently equals p_old_customer_id. Finally, the procedure executes a DELETE statement on the CUSTOMERS table to remove the row where the CUSTOMER_ID column equals p_old_customer_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE migrate_customer_data(p_old_customer_id IN NUMBER, p_new_customer_id IN NUMBER)\nIS\n   v_customer_exists NUMBER;\n   v_order_exists NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_customer_exists FROM CUSTOMERS WHERE CUSTOMER_ID = p_new_customer_id;\n   IF v_customer_exists = 0 THEN\n      INSERT INTO CUSTOMERS (CUSTOMER_ID, FIRST_NAME, LAST_NAME, AGE, EMAIL, PHONE_NUMBER, ADDRESS) SELECT p_new_customer_id, FIRST_NAME, LAST_NAME, AGE, EMAIL, PHONE_NUMBER, ADDRESS FROM CUSTOMERS WHERE CUSTOMER_ID = p_old_customer_id;\n   END IF;\n   SELECT COUNT(*) INTO v_order_exists FROM ORDERS WHERE CUSTOMER_ID = p_old_customer_id;\n   IF v_order_exists > 0 THEN\n      UPDATE ORDERS SET CUSTOMER_ID = p_new_customer_id WHERE CUSTOMER_ID = p_old_customer_id;\n   END IF;\n   DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = p_old_customer_id;\nEND;",
    "database_name": "customer_pad_tracking",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "PRODUCTS",
      "DISCOUNTS"
    ],
    "call_sqls": [
      "BEGIN\n  migrate_customer_data(p_old_customer_id => 0, p_new_customer_id => 1);\nEND;",
      "BEGIN\n  migrate_customer_data(p_old_customer_id => 1, p_new_customer_id => 2);\nEND;",
      "BEGIN\n  migrate_customer_data(p_old_customer_id => 10, p_new_customer_id => 11);\nEND;",
      "BEGIN\n  migrate_customer_data(p_old_customer_id => 100, p_new_customer_id => 101);\nEND;",
      "BEGIN\n  migrate_customer_data(p_old_customer_id => 5, p_new_customer_id => 6);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named migrate_customer_data that takes an old customer ID and a new customer ID, and if the new customer ID does not already exist in the CUSTOMERS table, copies all customer data (FIRST_NAME, LAST_NAME, AGE, EMAIL, PHONE_NUMBER, ADDRESS) from the old ID to create a new record with the new ID in the CUSTOMERS table, then updates all records in the ORDERS table associated with the old customer ID to reference the new customer ID, and finally deletes the original customer record with the old ID from the CUSTOMERS table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure named migrate_customer_data that, given an old customer ID and a new customer ID, copies the customer's data from the CUSTOMERS table to the new ID if the new ID does not already exist, updates all associated orders in the ORDERS table to reference the new customer ID, and then deletes the old customer record from the CUSTOMERS table.",
    "id": 79,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named migrate_customer_data that accepts two input parameters: p_old_customer_id of type NUMBER, which represents the identifier of the customer to be migrated, and p_new_customer_id of type NUMBER, which represents the new identifier to be assigned to the customer. The procedure first declares two local NUMBER variables, v_customer_exists and v_order_exists. It begins execution by querying the CUSTOMERS table to count the number of rows where the CUSTOMER_ID column equals the input parameter p_new_customer_id, storing the result in v_customer_exists. If the value of v_customer_exists is zero, indicating no customer currently exists with the new ID, it performs an INSERT operation into the CUSTOMERS table. This INSERT statement selects the FIRST_NAME, LAST_NAME, AGE, EMAIL, PHONE_NUMBER, and ADDRESS column values from the CUSTOMERS table where the CUSTOMER_ID equals p_old_customer_id, and inserts a new row using these selected values while explicitly setting the CUSTOMER_ID column to the value of p_new_customer_id. Next, the procedure queries the ORDERS table to count the number of rows where the CUSTOMER_ID column equals p_old_customer_id, storing this count in v_order_exists. If v_order_exists is greater than zero, meaning at least one order exists for the old customer, it executes an UPDATE statement on the ORDERS table, setting the CUSTOMER_ID column to p_new_customer_id for all rows where the CUSTOMER_ID column currently equals p_old_customer_id. Finally, the procedure executes a DELETE statement on the CUSTOMERS table to remove the row where the CUSTOMER_ID column equals p_old_customer_id.",
    "original_summary": "Create a stored procedure named migrate_customer_data that takes an old and a new customer ID. If the new ID does not exist, copy the customer's data to the new ID. Then, update all orders from the old ID to the new ID. Finally, delete the original customer record with the old ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure migrate_customer_data with old and new IDs. Copy data if new ID missing, update orders to new ID, then delete old record."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named calculate_average_metrics that accepts three input parameters: p_algorithm_id of type NUMBER, p_min_neighbors of type NUMBER, and p_created_by of type NUMBER. The procedure begins by declaring two local variables, v_avg_nmse and v_avg_r2, both of type NUMBER, to store the average values of specific evaluation metrics. It then executes a SELECT statement to calculate the average of the MEAN_TEST_NMSE and MEAN_TEST_R2 columns from the EVALUATION_METRICS table. This calculation is performed by joining the EVALUATION_METRICS table with the MODEL_EVALUATIONS table on the EVALUATION_METRIC_ID column, then joining with the MODELS table on the MODEL_ID column, and finally joining with the HYPERPARAMETERS table on the HYPERPARAMETER_ID column. The WHERE clause filters the results to include only those rows where the ALGORITHM column in the MODELS table matches the p_algorithm_id parameter and the NEIGHBORS column in the HYPERPARAMETERS table is greater than or equal to the p_min_neighbors parameter. The calculated average values are stored in the v_avg_nmse and v_avg_r2 variables. Following this, the procedure performs an INSERT operation into the MODEL_VERSIONS table, specifying values for the VERSION_ID, MODEL_ID, VERSION_NUMBER, VERSION_DATE, DESCRIPTION, CREATED_BY, and UPDATED_BY columns. The VERSION_ID is determined by selecting the maximum existing VERSION_ID from the MODEL_VERSIONS table and adding 1, defaulting to 1 if no records exist. The MODEL_ID is obtained by selecting the MODEL_ID from the MODELS table where the ALGORITHM matches the p_algorithm_id parameter, limited to the first row. The VERSION_NUMBER is set to 1, the VERSION_DATE is set to the current date formatted as 'YYYY-MM-DD', the DESCRIPTION is set to 'Average Metrics Calculated', and both the CREATED_BY and UPDATED_BY columns are set to the value of the p_created_by parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE calculate_average_metrics(\n    p_algorithm_id IN NUMBER,\n    p_min_neighbors IN NUMBER,\n    p_created_by IN NUMBER\n)\nIS\n    v_avg_nmse NUMBER;\n    v_avg_r2 NUMBER;\nBEGIN\n    SELECT AVG(em.MEAN_TEST_NMSE), AVG(em.MEAN_TEST_R2)\n    INTO v_avg_nmse, v_avg_r2\n    FROM EVALUATION_METRICS em\n    JOIN MODEL_EVALUATIONS me ON em.EVALUATION_METRIC_ID = me.EVALUATION_METRIC_ID\n    JOIN MODELS m ON me.MODEL_ID = m.MODEL_ID\n    JOIN HYPERPARAMETERS h ON m.HYPERPARAMETER_ID = h.HYPERPARAMETER_ID\n    WHERE m.ALGORITHM = p_algorithm_id AND h.NEIGHBORS >= p_min_neighbors;\n    \n    INSERT INTO MODEL_VERSIONS (VERSION_ID, MODEL_ID, VERSION_NUMBER, VERSION_DATE, DESCRIPTION, CREATED_BY, UPDATED_BY)\n    VALUES (\n        (SELECT NVL(MAX(VERSION_ID), 0) + 1 FROM MODEL_VERSIONS),\n        (SELECT MODEL_ID FROM MODELS WHERE ALGORITHM = p_algorithm_id AND ROWNUM = 1),\n        1,\n        TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'),\n        'Average Metrics Calculated',\n        p_created_by,\n        p_created_by\n    );\nEND;",
    "database_name": "machine_lmeao_637620",
    "tables": [
      "MODELS",
      "MODEL_EVALUATIONS",
      "MODEL_VERSIONS",
      "ALGORITHMS",
      "HYPERPARAMETERS",
      "EVALUATION_METRICS"
    ],
    "call_sqls": [
      "BEGIN\n  calculate_average_metrics(p_algorithm_id => 1, p_min_neighbors => 5, p_created_by => 101);\nEND;",
      "BEGIN\n  calculate_average_metrics(p_algorithm_id => 2, p_min_neighbors => 10, p_created_by => 102);\nEND;",
      "BEGIN\n  calculate_average_metrics(p_algorithm_id => 3, p_min_neighbors => 3, p_created_by => 103);\nEND;",
      "BEGIN\n  calculate_average_metrics(p_algorithm_id => 4, p_min_neighbors => 7, p_created_by => 104);\nEND;",
      "BEGIN\n  calculate_average_metrics(p_algorithm_id => 5, p_min_neighbors => 1, p_created_by => 105);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named calculate_average_metrics that, given an algorithm ID, a minimum neighbors value, and a creator ID, calculates the average MEAN_TEST_NMSE and MEAN_TEST_R2 from the EVALUATION_METRICS table for models with the specified algorithm ID and a NEIGHBORS value from the HYPERPARAMETERS table at or above the given minimum. It then inserts a new record into the MODEL_VERSIONS table with an auto-incremented VERSION_ID, the first MODEL_ID matching the algorithm, version number 1, the current date, a description of 'Average Metrics Calculated', and the provided creator ID for both CREATED_BY and UPDATED_BY.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called calculate_average_metrics that takes an algorithm ID, a minimum neighbors value, and a creator ID as inputs. It should retrieve the average MEAN_TEST_NMSE and average MEAN_TEST_R2 from the EVALUATION_METRICS table, joined with MODEL_EVALUATIONS, MODELS, and HYPERPARAMETERS, filtering for models with the given algorithm ID and HYPERPARAMETERS.NEIGHBORS at least the specified minimum. Then, it inserts a new record into the MODEL_VERSIONS table with an auto-incremented VERSION_ID, the first MODEL_ID matching the algorithm, a version number of 1, the current date, a description, and the creator ID for both CREATED_BY and UPDATED_BY.",
    "id": 80,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named calculate_average_metrics that accepts three input parameters: p_algorithm_id of type NUMBER, p_min_neighbors of type NUMBER, and p_created_by of type NUMBER. The procedure begins by declaring two local variables, v_avg_nmse and v_avg_r2, both of type NUMBER, to store the average values of specific evaluation metrics. It then executes a SELECT statement to calculate the average of the MEAN_TEST_NMSE and MEAN_TEST_R2 columns from the EVALUATION_METRICS table. This calculation is performed by joining the EVALUATION_METRICS table with the MODEL_EVALUATIONS table on the EVALUATION_METRIC_ID column, then joining with the MODELS table on the MODEL_ID column, and finally joining with the HYPERPARAMETERS table on the HYPERPARAMETER_ID column. The WHERE clause filters the results to include only those rows where the ALGORITHM column in the MODELS table matches the p_algorithm_id parameter and the NEIGHBORS column in the HYPERPARAMETERS table is greater than or equal to the p_min_neighbors parameter. The calculated average values are stored in the v_avg_nmse and v_avg_r2 variables. Following this, the procedure performs an INSERT operation into the MODEL_VERSIONS table, specifying values for the VERSION_ID, MODEL_ID, VERSION_NUMBER, VERSION_DATE, DESCRIPTION, CREATED_BY, and UPDATED_BY columns. The VERSION_ID is determined by selecting the maximum existing VERSION_ID from the MODEL_VERSIONS table and adding 1, defaulting to 1 if no records exist. The MODEL_ID is obtained by selecting the MODEL_ID from the MODELS table where the ALGORITHM matches the p_algorithm_id parameter, limited to the first row. The VERSION_NUMBER is set to 1, the VERSION_DATE is set to the current date formatted as 'YYYY-MM-DD', the DESCRIPTION is set to 'Average Metrics Calculated', and both the CREATED_BY and UPDATED_BY columns are set to the value of the p_created_by parameter.",
    "original_summary": "Create a stored procedure named calculate_average_metrics that calculates average NMSE and R2 metrics. It accepts an algorithm ID, a minimum neighbors value, and a creator ID. It calculates the averages by joining relevant tables and filtering by the algorithm and neighbor count. It then inserts a new version record into the MODEL_VERSIONS table with a generated ID, the found model ID, version number 1, the current date, a description, and the creator ID.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure calculate_average_metrics. Inputs: algorithm ID, min neighbors, creator ID. It joins tables, filters, calculates average NMSE and R2, then inserts a new version record."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_order_payment that accepts three parameters: p_order_id of type NUMBER, p_payment_method of type VARCHAR2, and p_payment_reference of type VARCHAR2. The procedure begins by declaring local variables v_customer_id and v_total_cost of type NUMBER, v_payment_id of type NUMBER, and v_current_date of type VARCHAR2 with a length of 255 characters. It then retrieves the CUSTOMER_ID and TOTAL_COST from the ORDERS table for the row where ORDER_ID matches the input parameter p_order_id, storing these values into v_customer_id and v_total_cost respectively. The current date is formatted as 'YYYY-MM-DD' using the TO_CHAR function applied to LOCALTIMESTAMP and stored in v_current_date. The procedure calculates the next PAYMENT_ID by selecting the maximum PAYMENT_ID from the PAYMENTS table and adding 1, storing the result in v_payment_id. It inserts a new record into the PAYMENTS table with the columns PAYMENT_ID, ORDER_ID, PAYMENT_DATE, AMOUNT, PAYMENT_METHOD, and PAYMENT_REFERENCE set to v_payment_id, p_order_id, v_current_date, v_total_cost, p_payment_method, and p_payment_reference respectively. The procedure updates the PAYMENT_STATUS column in the ORDERS table to 'Paid' for the row where ORDER_ID matches p_order_id. It then checks if v_total_cost is greater than 100; if true, it inserts a new record into the SHIPMENTS table with SHIPMENT_ID calculated as the maximum SHIPMENT_ID plus 1, ORDER_ID set to p_order_id, SHIPMENT_DATE set to v_current_date, TRACKING_NUMBER set to 'TRK' concatenated with p_order_id, SHIPPING_METHOD set to 'Express', and ESTIMATED_DELIVERY_DATE set to three days from the current date formatted as 'YYYY-MM-DD'. If v_total_cost is not greater than 100, it inserts a similar record into the SHIPMENTS table but with SHIPPING_METHOD set to 'Standard' and ESTIMATED_DELIVERY_DATE set to seven days from the current date.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_order_payment(\n    p_order_id NUMBER,\n    p_payment_method VARCHAR2,\n    p_payment_reference VARCHAR2\n) IS\n    v_customer_id NUMBER;\n    v_total_cost NUMBER;\n    v_payment_id NUMBER;\n    v_current_date VARCHAR2(255);\nBEGIN\n    SELECT CUSTOMER_ID, TOTAL_COST INTO v_customer_id, v_total_cost FROM ORDERS WHERE ORDER_ID = p_order_id;\n    v_current_date := TO_CHAR(LOCALTIMESTAMP, 'YYYY-MM-DD');\n    SELECT MAX(PAYMENT_ID) + 1 INTO v_payment_id FROM PAYMENTS;\n    INSERT INTO PAYMENTS (PAYMENT_ID, ORDER_ID, PAYMENT_DATE, AMOUNT, PAYMENT_METHOD, PAYMENT_REFERENCE)\n    VALUES (v_payment_id, p_order_id, v_current_date, v_total_cost, p_payment_method, p_payment_reference);\n    UPDATE ORDERS SET PAYMENT_STATUS = 'Paid' WHERE ORDER_ID = p_order_id;\n    IF v_total_cost > 100 THEN\n        INSERT INTO SHIPMENTS (SHIPMENT_ID, ORDER_ID, SHIPMENT_DATE, TRACKING_NUMBER, SHIPPING_METHOD, ESTIMATED_DELIVERY_DATE)\n        VALUES ((SELECT MAX(SHIPMENT_ID) + 1 FROM SHIPMENTS), p_order_id, v_current_date, 'TRK' || p_order_id, 'Express', TO_CHAR(LOCALTIMESTAMP + INTERVAL '3' DAY, 'YYYY-MM-DD'));\n    ELSE\n        INSERT INTO SHIPMENTS (SHIPMENT_ID, ORDER_ID, SHIPMENT_DATE, TRACKING_NUMBER, SHIPPING_METHOD, ESTIMATED_DELIVERY_DATE)\n        VALUES ((SELECT MAX(SHIPMENT_ID) + 1 FROM SHIPMENTS), p_order_id, v_current_date, 'TRK' || p_order_id, 'Standard', TO_CHAR(LOCALTIMESTAMP + INTERVAL '7' DAY, 'YYYY-MM-DD'));\n    END IF;\nEND;",
    "database_name": "garment_maim_826182",
    "tables": [
      "CUSTOMERS",
      "ORDERS",
      "ORDER_ITEMS",
      "GARMENT_TYPES",
      "SIZES",
      "INVENTORY",
      "PAYMENTS",
      "SHIPMENTS"
    ],
    "call_sqls": [
      "BEGIN\n  process_order_payment(0, 'Credit Card', 'CC1234');\n  commit;\nEND;",
      "BEGIN\n  process_order_payment(1, 'PayPal', 'PP5678');\n  commit;\nEND;",
      "BEGIN\n  process_order_payment(0, 'Bank Transfer', 'BT7890');\n  commit;\nEND;",
      "BEGIN\n  process_order_payment(1, 'Debit Card', 'DC3456');\n  commit;\nEND;",
      "BEGIN\n  process_order_payment(0, 'Cash', 'CASH123');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named process_order_payment that accepts an order ID, a payment method, and a payment reference to process a payment. It retrieves the associated CUSTOMER_ID and TOTAL_COST from the ORDERS table for the given order, inserts a new payment record into the PAYMENTS table with a new PAYMENT_ID and the current date, and updates the order's PAYMENT_STATUS to 'Paid' in the ORDERS table. Based on the TOTAL_COST: if it exceeds 100, it creates an 'Express' shipment record in the SHIPMENTS table with a 3-day delivery estimate; otherwise, it creates a 'Standard' shipment with a 7-day estimate, generating a tracking number for each.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called process_order_payment that accepts an order ID (p_order_id), a payment method (p_payment_method), and a payment reference (p_payment_reference). It should retrieve the associated CUSTOMER_ID and TOTAL_COST for that order from the ORDERS table, then insert a new payment record into the PAYMENTS table using a new PAYMENT_ID and the current date, and update the order's PAYMENT_STATUS to 'Paid'. Additionally, if the TOTAL_COST exceeds 100, create an 'Express' shipment record in the SHIPMENTS table with an estimated delivery date three days from now; otherwise, create a 'Standard' shipment record with an estimated delivery date seven days from now.",
    "id": 81,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named process_order_payment that accepts three parameters: p_order_id of type NUMBER, p_payment_method of type VARCHAR2, and p_payment_reference of type VARCHAR2. The procedure begins by declaring local variables v_customer_id and v_total_cost of type NUMBER, v_payment_id of type NUMBER, and v_current_date of type VARCHAR2 with a length of 255 characters. It then retrieves the CUSTOMER_ID and TOTAL_COST from the ORDERS table for the row where ORDER_ID matches the input parameter p_order_id, storing these values into v_customer_id and v_total_cost respectively. The current date is formatted as 'YYYY-MM-DD' using the TO_CHAR function applied to LOCALTIMESTAMP and stored in v_current_date. The procedure calculates the next PAYMENT_ID by selecting the maximum PAYMENT_ID from the PAYMENTS table and adding 1, storing the result in v_payment_id. It inserts a new record into the PAYMENTS table with the columns PAYMENT_ID, ORDER_ID, PAYMENT_DATE, AMOUNT, PAYMENT_METHOD, and PAYMENT_REFERENCE set to v_payment_id, p_order_id, v_current_date, v_total_cost, p_payment_method, and p_payment_reference respectively. The procedure updates the PAYMENT_STATUS column in the ORDERS table to 'Paid' for the row where ORDER_ID matches p_order_id. It then checks if v_total_cost is greater than 100; if true, it inserts a new record into the SHIPMENTS table with SHIPMENT_ID calculated as the maximum SHIPMENT_ID plus 1, ORDER_ID set to p_order_id, SHIPMENT_DATE set to v_current_date, TRACKING_NUMBER set to 'TRK' concatenated with p_order_id, SHIPPING_METHOD set to 'Express', and ESTIMATED_DELIVERY_DATE set to three days from the current date formatted as 'YYYY-MM-DD'. If v_total_cost is not greater than 100, it inserts a similar record into the SHIPMENTS table but with SHIPPING_METHOD set to 'Standard' and ESTIMATED_DELIVERY_DATE set to seven days from the current date.",
    "original_summary": "Create a stored procedure named process_order_payment that accepts p_order_id, p_payment_method, and p_payment_reference. Retrieve the order's customer and total cost. Insert a payment record with a new ID and the current date. Update the order's status to 'Paid'. If the total cost exceeds 100, create an 'Express' shipment with a 3-day delivery estimate; otherwise, create a 'Standard' shipment with a 7-day estimate.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Please construct a stored procedure designated as 'process_order_payment'. This procedure shall accept the parameters p_order_id, p_payment_method, and p_payment_reference. It is required to retrieve the associated customer and total cost for the specified order. Subsequently, a payment record must be inserted, utilizing a newly generated identifier and the current date. The order's status must then be updated to 'Paid'. Furthermore, conditional logic must be implemented: if the total cost exceeds 100, an 'Express' shipment record should be created with a delivery estimate of three days; otherwise, a 'Standard' shipment record should be created with a delivery estimate of seven days."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named update_product_status that accepts two parameters: p_product_id of type NUMBER, representing the unique identifier of a product, and p_year of type NUMBER, indicating the year for which data is being considered. The procedure begins by declaring a local variable v_avg_value of type NUMBER to store the average value calculated from the DATA_POINTS table. It then executes a SELECT statement to compute the average of the VALUE column for rows in the DATA_POINTS table where the PRODUCT_ID matches the p_product_id parameter and the YEAR matches the p_year parameter, storing the result in v_avg_value. Following this, the procedure evaluates a conditional statement: if v_avg_value is less than 200, it performs a DELETE operation on the PRODUCTS table, removing the row where the PRODUCT_ID matches the p_product_id parameter. If v_avg_value is 200 or greater, the procedure executes an INSERT operation into the PRODUCTS table, adding a new row with the following values: PRODUCT_ID set to p_product_id, PRODUCT_NAME set to 'New Product', PRODUCT_TYPE set to 'Type A', DESCRIPTION set to 'Description', CREATED_AT and UPDATED_AT both set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS', SCIENTIFIC_NAME set to 'Scientific Name', HABITAT set to 'Habitat', LIFE_CYCLE set to 'Life Cycle', CONSERVATION_STATUS set to 'Status', and LAST_ASSESSMENT_DATE set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_product_status (p_product_id NUMBER, p_year NUMBER)\nIS\n    v_avg_value NUMBER;\nBEGIN\n    SELECT AVG(VALUE) INTO v_avg_value FROM DATA_POINTS WHERE PRODUCT_ID = p_product_id AND YEAR = p_year;\n    IF v_avg_value < 200 THEN\n        DELETE FROM PRODUCTS WHERE PRODUCT_ID = p_product_id;\n    ELSE\n        INSERT INTO PRODUCTS (PRODUCT_ID, PRODUCT_NAME, PRODUCT_TYPE, DESCRIPTION, CREATED_AT, UPDATED_AT, SCIENTIFIC_NAME, HABITAT, LIFE_CYCLE, CONSERVATION_STATUS, LAST_ASSESSMENT_DATE) VALUES (p_product_id, 'New Product', 'Type A', 'Description', TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'), TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'), 'Scientific Name', 'Habitat', 'Life Cycle', 'Status', TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'));\n    END IF;\nEND;",
    "database_name": "marine_ema_analysis",
    "tables": [
      "ACCESS_LOGS",
      "DATA_POINTS",
      "METHODS",
      "PRODUCTS",
      "REGIONS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  update_product_status(p_product_id => 101, p_year => 2022);\nEND;",
      "BEGIN\n  update_product_status(p_product_id => 102, p_year => 2023);\nEND;",
      "BEGIN\n  update_product_status(p_product_id => 103, p_year => 2021);\nEND;",
      "BEGIN\n  update_product_status(p_product_id => 104, p_year => 2020);\nEND;",
      "BEGIN\n  update_product_status(p_product_id => 105, p_year => 2024);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `update_product_status` that, for a given PRODUCT_ID and year, calculates the average VALUE from the DATA_POINTS table for that product and year. If the average is below 200, delete the product from the PRODUCTS table. Otherwise, insert a new record into the PRODUCTS table with the given PRODUCT_ID and default details for PRODUCT_NAME, PRODUCT_TYPE, DESCRIPTION, CREATED_AT, UPDATED_AT, SCIENTIFIC_NAME, HABITAT, LIFE_CYCLE, CONSERVATION_STATUS, and LAST_ASSESSMENT_DATE.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_product_status that, for a given PRODUCT_ID and YEAR, calculates the average VALUE from the DATA_POINTS table. If the average is less than 200, delete the product from the PRODUCTS table; otherwise, insert a new record into PRODUCTS with the provided ID and default values for all other columns.",
    "id": 82,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named update_product_status that accepts two parameters: p_product_id of type NUMBER, representing the unique identifier of a product, and p_year of type NUMBER, indicating the year for which data is being considered. The procedure begins by declaring a local variable v_avg_value of type NUMBER to store the average value calculated from the DATA_POINTS table. It then executes a SELECT statement to compute the average of the VALUE column for rows in the DATA_POINTS table where the PRODUCT_ID matches the p_product_id parameter and the YEAR matches the p_year parameter, storing the result in v_avg_value. Following this, the procedure evaluates a conditional statement: if v_avg_value is less than 200, it performs a DELETE operation on the PRODUCTS table, removing the row where the PRODUCT_ID matches the p_product_id parameter. If v_avg_value is 200 or greater, the procedure executes an INSERT operation into the PRODUCTS table, adding a new row with the following values: PRODUCT_ID set to p_product_id, PRODUCT_NAME set to 'New Product', PRODUCT_TYPE set to 'Type A', DESCRIPTION set to 'Description', CREATED_AT and UPDATED_AT both set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS', SCIENTIFIC_NAME set to 'Scientific Name', HABITAT set to 'Habitat', LIFE_CYCLE set to 'Life Cycle', CONSERVATION_STATUS set to 'Status', and LAST_ASSESSMENT_DATE set to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "original_summary": "Create a stored procedure named `update_product_status` that calculates the average value of a product's data points for a given year. If the average is below 200, delete the product. Otherwise, insert a new product record with the given ID and default details.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure `update_product_status` to compute a product's yearly data point average. Delete product if average < 200; else, insert new product record with provided ID and defaults."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named process_metric_calculation that accepts three parameters: p_metric_name of type VARCHAR2, p_category of type VARCHAR2, and p_unit of type VARCHAR2. The procedure begins by declaring several local variables: v_metric_id, v_year_count, v_calculated_value, v_max_id, and v_counter, with v_counter initialized to 1. It also declares a cursor c_years that selects FINANCIAL_YEAR_ID and YEAR from the FINANCIAL_YEARS table where the STATUS column is 'open'. The procedure first retrieves the METRIC_ID from the FINANCIAL_METRICS table into v_metric_id where the METRIC_NAME matches the input parameter p_metric_name. It then counts the number of rows in the FINANCIAL_YEARS table with STATUS 'open' and stores this count in v_year_count. The procedure finds the maximum FINANCIAL_DATA_ID from the FINANCIAL_DATA table, defaulting to 0 if no rows exist, and stores this in v_max_id. It calculates v_calculated_value as the product of the arc sine of 0.25 and v_year_count. The procedure then enters a loop over the cursor c_years, inserting a new row into the FINANCIAL_DATA table for each open financial year. The inserted row includes a FINANCIAL_DATA_ID calculated as v_max_id plus v_counter, the FINANCIAL_YEAR_ID from the cursor, a fixed BUSINESS_UNIT_ID of 1, the retrieved METRIC_ID, a VALUE calculated as v_calculated_value multiplied by the difference between the year and 2000, a TARGET_VALUE calculated as v_calculated_value multiplied by the difference between the year and 1999, a VARIANCE set to v_calculated_value, a DATE_GENERATED set to the current system date formatted as 'YYYY-MM-DD', and a SOURCE set to 'calculated'. After each insertion, v_counter is incremented by 1. Finally, the procedure updates the FINANCIAL_METRICS table, setting the CATEGORY to p_category and the UNIT to p_unit for the row where METRIC_ID matches v_metric_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE process_metric_calculation(\n    p_metric_name VARCHAR2,\n    p_category VARCHAR2,\n    p_unit VARCHAR2\n) IS\n    v_metric_id NUMBER;\n    v_year_count NUMBER;\n    v_calculated_value NUMBER;\n    v_max_id NUMBER;\n    v_counter NUMBER := 1;\n    CURSOR c_years IS\n        SELECT FINANCIAL_YEAR_ID, YEAR\n        FROM FINANCIAL_YEARS\n        WHERE STATUS = 'open';\nBEGIN\n    SELECT METRIC_ID INTO v_metric_id\n    FROM FINANCIAL_METRICS\n    WHERE METRIC_NAME = p_metric_name;\n    \n    SELECT COUNT(*) INTO v_year_count\n    FROM FINANCIAL_YEARS\n    WHERE STATUS = 'open';\n    \n    SELECT NVL(MAX(FINANCIAL_DATA_ID), 0) INTO v_max_id\n    FROM FINANCIAL_DATA;\n    \n    v_calculated_value := ASIN(0.25) * v_year_count;\n    \n    FOR year_rec IN c_years LOOP\n        INSERT INTO FINANCIAL_DATA (\n            FINANCIAL_DATA_ID,\n            FINANCIAL_YEAR_ID,\n            BUSINESS_UNIT_ID,\n            METRIC_ID,\n            VALUE,\n            TARGET_VALUE,\n            VARIANCE,\n            DATE_GENERATED,\n            SOURCE\n        ) VALUES (\n            v_max_id + v_counter,\n            year_rec.FINANCIAL_YEAR_ID,\n            1,\n            v_metric_id,\n            v_calculated_value * (year_rec.YEAR - 2000),\n            v_calculated_value * (year_rec.YEAR - 1999),\n            v_calculated_value,\n            TO_CHAR(SYSDATE, 'YYYY-MM-DD'),\n            'calculated'\n        );\n        \n        v_counter := v_counter + 1;\n    END LOOP;\n    \n    UPDATE FINANCIAL_METRICS\n    SET CATEGORY = p_category,\n        UNIT = p_unit\n    WHERE METRIC_ID = v_metric_id;\nEND;",
    "database_name": "financial_paa_reporting",
    "tables": [
      "FINANCIAL_DATA",
      "FINANCIAL_METRICS",
      "FINANCIAL_YEARS"
    ],
    "call_sqls": [
      "BEGIN\n  process_metric_calculation('Revenue Growth Rate', 'revenue', 'percentage');\n  commit;\nEND;",
      "BEGIN\n  process_metric_calculation('Market Share Growth Rate', 'market share', 'percentage');\n  commit;\nEND;",
      "BEGIN\n  process_metric_calculation('Revenue Growth Rate', 'financial', 'percentage');\n  commit;\nEND;",
      "BEGIN\n  process_metric_calculation('Market Share Growth Rate', 'business', 'percentage');\n  commit;\nEND;",
      "BEGIN\n  process_metric_calculation('Revenue Growth Rate', 'growth', 'percentage');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named process_metric_calculation that accepts a metric name, a category, and a unit. First, retrieve the METRIC_ID from the FINANCIAL_METRICS table for the given metric name. Then, count the number of open financial years from the FINANCIAL_YEARS table and calculate a base value using this count. For each open financial year, insert a new record into the FINANCIAL_DATA table with a unique auto-incremented ID, the specific FINANCIAL_YEAR_ID, a fixed BUSINESS_UNIT_ID of 1, the retrieved METRIC_ID, a calculated VALUE based on the year, a calculated TARGET_VALUE, a VARIANCE equal to the base value, the current date, and a source of 'calculated'. Finally, update the category and unit for the metric in the FINANCIAL_METRICS table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called process_metric_calculation that takes metric_name, category, and unit as inputs. It should retrieve the corresponding METRIC_ID from the FINANCIAL_METRICS table, count the number of open years from the FINANCIAL_YEARS table, and compute a base value. For each open year, insert a calculated record into the FINANCIAL_DATA table with an auto-incremented ID, using the base value to derive the VALUE, TARGET_VALUE, and VARIANCE based on the year. Finally, update the metric's category and unit in the FINANCIAL_METRICS table.",
    "id": 83,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named process_metric_calculation that accepts three parameters: p_metric_name of type VARCHAR2, p_category of type VARCHAR2, and p_unit of type VARCHAR2. The procedure begins by declaring several local variables: v_metric_id, v_year_count, v_calculated_value, v_max_id, and v_counter, with v_counter initialized to 1. It also declares a cursor c_years that selects FINANCIAL_YEAR_ID and YEAR from the FINANCIAL_YEARS table where the STATUS column is 'open'. The procedure first retrieves the METRIC_ID from the FINANCIAL_METRICS table into v_metric_id where the METRIC_NAME matches the input parameter p_metric_name. It then counts the number of rows in the FINANCIAL_YEARS table with STATUS 'open' and stores this count in v_year_count. The procedure finds the maximum FINANCIAL_DATA_ID from the FINANCIAL_DATA table, defaulting to 0 if no rows exist, and stores this in v_max_id. It calculates v_calculated_value as the product of the arc sine of 0.25 and v_year_count. The procedure then enters a loop over the cursor c_years, inserting a new row into the FINANCIAL_DATA table for each open financial year. The inserted row includes a FINANCIAL_DATA_ID calculated as v_max_id plus v_counter, the FINANCIAL_YEAR_ID from the cursor, a fixed BUSINESS_UNIT_ID of 1, the retrieved METRIC_ID, a VALUE calculated as v_calculated_value multiplied by the difference between the year and 2000, a TARGET_VALUE calculated as v_calculated_value multiplied by the difference between the year and 1999, a VARIANCE set to v_calculated_value, a DATE_GENERATED set to the current system date formatted as 'YYYY-MM-DD', and a SOURCE set to 'calculated'. After each insertion, v_counter is incremented by 1. Finally, the procedure updates the FINANCIAL_METRICS table, setting the CATEGORY to p_category and the UNIT to p_unit for the row where METRIC_ID matches v_metric_id.",
    "original_summary": "Create a stored procedure named process_metric_calculation that accepts parameters for metric_name, category, and unit. Retrieve the METRIC_ID for the given name. Count the open financial years and calculate a base value. For each open financial year, insert a calculated record into the FINANCIAL_DATA table with an auto-incremented ID, specific values, and a 'calculated' source. Finally, update the metric's category and unit in the FINANCIAL_METRICS table.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure process_metric_calculation with metric_name, category, unit parameters. Get its METRIC_ID. Count open years, compute base. For each open year, insert a calculated record into FINANCIAL_DATA with auto ID. Update the metric's category and unit in FINANCIAL_METRICS."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named aggregate_experiment_results that accepts a single input parameter p_user_id of type NUMBER, which represents the user ID for which the procedure will aggregate experiment results. The procedure begins by declaring several local variables: v_experiment_id of type NUMBER to store the current experiment ID, v_algorithm and v_status of type VARCHAR2(255) to store the algorithm and status of the current experiment, v_metric_count of type NUMBER to store the count of metrics associated with the current experiment, and v_next_metric_id of type NUMBER to store the next available metric ID for insertion. The procedure uses a FOR loop to iterate over each record in a cursor that selects experiment_id, algorithm, and status from the experiments table where the user_id matches the input parameter p_user_id. Within the loop, the procedure assigns the values of experiment_id, algorithm, and status from the current record to the local variables v_experiment_id, v_algorithm, and v_status, respectively. It then performs a SELECT COUNT(*) operation to determine the number of metrics associated with the current experiment_id in the experiment_metrics table, storing the result in v_metric_count. If v_metric_count is zero, indicating no metrics exist for the current experiment, the procedure calculates the next metric ID by selecting the maximum metric_id from experiment_metrics, using NVL to handle null values, and adding 1, storing the result in v_next_metric_id. It then inserts a new row into the experiment_metrics table with metric_id set to v_next_metric_id, experiment_id set to v_experiment_id, metric_name set to 'Initial Metric', and metric_description set to 'Default metric for new experiment'. If the status of the current experiment is 'running', the procedure updates the first row (determined by ROWNUM = 1) in the experiment_metrics table where experiment_id matches v_experiment_id, setting metric_name to 'Running Metric'. If the algorithm of the current experiment is 'PPO', the procedure deletes rows from the experiment_metrics table where experiment_id matches v_experiment_id and max_kl is greater than 0.5. If the algorithm is 'DQN', the procedure updates rows in the experiment_metrics table where experiment_id matches v_experiment_id, setting loss_before and loss_after to 0. If the status of the current experiment is 'completed', the procedure calculates the next metric ID similarly to the initial metric insertion, and inserts a new row into the experiment_metrics table with metric_id set to v_next_metric_id, experiment_id set to v_experiment_id, metric_name set to 'Completion Metric', and metric_description set to 'Metric for completed experiment'. For all other cases, the procedure deletes rows from the experiment_metrics table where experiment_id matches v_experiment_id and std_return is less than 0.",
    "plsql": "CREATE OR REPLACE PROCEDURE aggregate_experiment_results(p_user_id IN NUMBER)\nIS\n    v_experiment_id NUMBER;\n    v_algorithm VARCHAR2(255);\n    v_status VARCHAR2(255);\n    v_metric_count NUMBER;\n    v_next_metric_id NUMBER;\nBEGIN\n    FOR exp_rec IN (SELECT experiment_id, algorithm, status FROM experiments WHERE user_id = p_user_id) LOOP\n        v_experiment_id := exp_rec.experiment_id;\n        v_algorithm := exp_rec.algorithm;\n        v_status := exp_rec.status;\n        \n        SELECT COUNT(*) INTO v_metric_count FROM experiment_metrics WHERE experiment_id = v_experiment_id;\n        \n        IF v_metric_count = 0 THEN\n            SELECT NVL(MAX(metric_id), 0) + 1 INTO v_next_metric_id FROM experiment_metrics;\n            INSERT INTO experiment_metrics (metric_id, experiment_id, metric_name, metric_description) \n            VALUES (v_next_metric_id, v_experiment_id, 'Initial Metric', 'Default metric for new experiment');\n        ELSIF v_status = 'running' THEN\n            UPDATE experiment_metrics SET metric_name = 'Running Metric' WHERE experiment_id = v_experiment_id AND ROWNUM = 1;\n        ELSIF v_algorithm = 'PPO' THEN\n            DELETE FROM experiment_metrics WHERE experiment_id = v_experiment_id AND max_kl > 0.5;\n        ELSIF v_algorithm = 'DQN' THEN\n            UPDATE experiment_metrics SET loss_before = 0, loss_after = 0 WHERE experiment_id = v_experiment_id;\n        ELSIF v_status = 'completed' THEN\n            SELECT NVL(MAX(metric_id), 0) + 1 INTO v_next_metric_id FROM experiment_metrics;\n            INSERT INTO experiment_metrics (metric_id, experiment_id, metric_name, metric_description) \n            VALUES (v_next_metric_id, v_experiment_id, 'Completion Metric', 'Metric for completed experiment');\n        ELSE\n            DELETE FROM experiment_metrics WHERE experiment_id = v_experiment_id AND std_return < 0;\n        END IF;\n    END LOOP;\nEND;",
    "database_name": "reinforcement_letaa_93121",
    "tables": [
      "EXPERIMENTS",
      "EXPERIMENT_METRICS",
      "EXPLAINED_VARIANCE",
      "RETURNS"
    ],
    "call_sqls": [
      "BEGIN\n  aggregate_experiment_results(p_user_id => 0);\nEND;",
      "BEGIN\n  aggregate_experiment_results(p_user_id => 1);\nEND;",
      "BEGIN\n  aggregate_experiment_results(p_user_id => 2);\nEND;",
      "BEGIN\n  aggregate_experiment_results(p_user_id => 3);\nEND;",
      "BEGIN\n  aggregate_experiment_results(p_user_id => 4);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `aggregate_experiment_results` that accepts a user ID. For each experiment belonging to that user in the EXPERIMENTS table, based on its algorithm and status, perform the following actions on the associated records in the EXPERIMENT_METRICS table: if the experiment has no metrics, insert a default 'Initial Metric'; if the status is 'running', update the first associated metric's name to 'Running Metric'; if the algorithm is 'PPO', delete metrics where MAX_KL is greater than 0.5; if the algorithm is 'DQN', update associated metrics to set LOSS_BEFORE and LOSS_AFTER to 0; if the status is 'completed', insert a 'Completion Metric'; for all other cases, delete metrics where STD_RETURN is less than 0.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called `aggregate_experiment_results` that takes a user ID and, for each experiment belonging to that user in the EXPERIMENTS table, processes its metrics in the EXPERIMENT_METRICS table as follows: if an experiment has no metrics, insert a default 'Initial Metric'; if its status is 'running', rename the first linked metric to 'Running Metric'; if its algorithm is 'PPO', delete any metrics where MAX_KL exceeds 0.5; if its algorithm is 'DQN', set both LOSS_BEFORE and LOSS_AFTER to zero for all its metrics; if its status is 'completed', add a new 'Completion Metric'; for any other cases, delete metrics where STD_RETURN is negative.",
    "id": 84,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named aggregate_experiment_results that accepts a single input parameter named p_user_id of the NUMBER data type. The procedure processes experiment metrics for all experiments belonging to the specified user ID. It operates on two tables: EXPERIMENTS and EXPERIMENT_METRICS. The EXPERIMENTS table contains columns: experiment_id (primary key), user_id, status, and algorithm. The EXPERIMENT_METRICS table contains columns: metric_id (primary key), experiment_id (foreign key referencing EXPERIMENTS.experiment_id), metric_name, MAX_KL, LOSS_BEFORE, LOSS_AFTER, and STD_RETURN.\n\nThe procedure begins by declaring a cursor named c_experiments that selects all experiment_id, status, and algorithm from the EXPERIMENTS table where the user_id equals the input parameter p_user_id. It also declares local variables: v_experiment_id, v_status, and v_algorithm to hold the values fetched from the cursor, and a variable v_metric_count to count metrics for each experiment.\n\nThe procedure uses a loop to iterate through each experiment belonging to the user. For each experiment fetched from the cursor, it performs the following steps in sequence:\n\n**Step 1: Count metrics for the current experiment.**\nIt executes a SELECT COUNT(*) query on the EXPERIMENT_METRICS table where experiment_id equals the current v_experiment_id, storing the result in v_metric_count.\n\n**Step 2: Handle experiments with no metrics.**\nIf v_metric_count equals 0, it inserts a new row into the EXPERIMENT_METRICS table with the following values: a unique metric_id (likely from a sequence, though not explicitly specified), the current v_experiment_id for experiment_id, 'Initial Metric' for metric_name, and NULL values for MAX_KL, LOSS_BEFORE, LOSS_AFTER, and STD_RETURN (or default values if implied, but here assumed as NULL). After this insertion, it skips to the next experiment iteration using a CONTINUE statement.\n\n**Step 3: Handle experiments with status 'running'.**\nIf the current v_status equals the string 'running', it updates the first linked metric for this experiment. It identifies the first metric by selecting the minimum metric_id from EXPERIMENT_METRICS where experiment_id equals v_experiment_id. It then updates the EXPERIMENT_METRICS table, setting metric_name to 'Running Metric' where metric_id equals this minimum metric_id.\n\n**Step 4: Handle experiments with algorithm 'PPO'.**\nIf the current v_algorithm equals the string 'PPO', it deletes all rows from the EXPERIMENT_METRICS table where experiment_id equals v_experiment_id and MAX_KL is greater than 0.5.\n\n**Step 5: Handle experiments with algorithm 'DQN'.**\nIf the current v_algorithm equals the string 'DQN', it updates all rows in the EXPERIMENT_METRICS table where experiment_id equals v_experiment_id, setting both LOSS_BEFORE and LOSS_AFTER to 0.\n\n**Step 6: Handle experiments with status 'completed'.**\nIf the current v_status equals the string 'completed', it inserts a new row into the EXPERIMENT_METRICS table with the following values: a unique metric_id, the current v_experiment_id for experiment_id, 'Completion Metric' for metric_name, and NULL values for MAX_KL, LOSS_BEFORE, LOSS_AFTER, and STD_RETURN (or default values if implied, but here assumed as NULL).\n\n**Step 7: Handle any other cases (catch-all condition).**\nFor all experiments not matching the above specific conditions (i.e., where v_status is not 'running' or 'completed', and v_algorithm is not 'PPO' or 'DQN'), it deletes all rows from the EXPERIMENT_METRICS table where experiment_id equals v_experiment_id and STD_RETURN is less than 0.\n\nThe procedure processes each experiment independently, applying the logic in the order specified: first checking for no metrics, then checking status 'running', then algorithm 'PPO', then algorithm 'DQN', then status 'completed', and finally the catch-all condition. After processing all experiments for the user, the procedure ends without returning any output value (it is a procedure, not a function).",
    "original_summary": "Create a stored procedure named `aggregate_experiment_results` that accepts a user ID. For each experiment belonging to that user, perform the following: If the experiment has no metrics, insert a default 'Initial Metric'. If the experiment status is 'running', update the first associated metric's name to 'Running Metric'. If the algorithm is 'PPO', delete metrics where max_kl > 0.5. If the algorithm is 'DQN', update associated metrics to set loss_before and loss_after to 0. If the status is 'completed', insert a 'Completion Metric'. For all other cases, delete metrics where std_return < 0.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Alright, so we need a stored procedure called `aggregate_experiment_results` that takes a user ID. For every experiment that belongs to that user, here's the deal: if the experiment doesn't have any metrics yet, just pop in a default one called 'Initial Metric'. If the experiment's status is 'running', then go ahead and change the name of the first metric linked to it to 'Running Metric'. Now, if the algorithm is 'PPO', get rid of any metrics where the max_kl is over 0.5. If it's 'DQN', then for all its metrics, set both loss_before and loss_after to zero. If the status is 'completed', add a new 'Completion Metric'. For anything else that doesn't fit these cases, just delete any metrics where the std_return is less than zero."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp5 that accepts four input parameters: a numeric para_CLAIM_ID, a numeric para_ACTUARY_ID, a string para_REASON, and a numeric para_ADJUSTMENT. The procedure first queries the CLAIMS table to count the number of rows where the CLAIM_ID column matches the input para_CLAIM_ID, storing the result in a local variable v_claim_exists. It then queries the RESERVES table to count the number of rows where the CLAIM_ID column matches the same input para_CLAIM_ID, storing this count in a local variable v_reserve_count. If the v_claim_exists count is greater than zero, indicating the claim exists, the procedure proceeds to check if the v_reserve_count is also greater than zero; if it is, the procedure executes a DELETE operation on the RESERVES table, removing all rows where the CLAIM_ID column equals the input para_CLAIM_ID. Following this conditional deletion, the procedure performs an INSERT into the RESERVES table, populating the following columns: RESERVE_ID is set to a new value calculated by selecting the current maximum value from the RESERVE_ID column in the RESERVES table, using the NVL function to treat NULL as zero, and then adding one; CLAIM_ID is set to the input para_CLAIM_ID; RE_IBNR_AMT is set to the input para_ADJUSTMENT multiplied by 2; RE_OS_AMT is set to para_ADJUSTMENT multiplied by 1.5; RE_LOSS_SVYEXP is set to para_ADJUSTMENT multiplied by 0.8; RE_RSV_LSS is set to para_ADJUSTMENT multiplied by 0.3; RE_TVOG_AMT is set to para_ADJUSTMENT multiplied by 0.1; RE_CEBF_AMT is set to para_ADJUSTMENT multiplied by 0.4; RE_CE_LSS is set to para_ADJUSTMENT multiplied by 0.15; CALCULATION_DATE is set to the current system date formatted as 'YYYY-MM-DD' using the TO_CHAR and SYSDATE functions; ACTUARY_ID is set to the input para_ACTUARY_ID; and ADJUSTMENT_REASON is set to the input string para_REASON.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp5(para_CLAIM_ID NUMBER, para_ACTUARY_ID NUMBER, para_REASON VARCHAR2, para_ADJUSTMENT NUMBER) IS\n  v_reserve_count NUMBER;\n  v_claim_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_claim_exists FROM CLAIMS WHERE CLAIM_ID = para_CLAIM_ID;\n  SELECT COUNT(*) INTO v_reserve_count FROM RESERVES WHERE CLAIM_ID = para_CLAIM_ID;\n  IF v_claim_exists > 0 THEN\n    IF v_reserve_count > 0 THEN\n      DELETE FROM RESERVES WHERE CLAIM_ID = para_CLAIM_ID;\n    END IF;\n    INSERT INTO RESERVES (RESERVE_ID, CLAIM_ID, RE_IBNR_AMT, RE_OS_AMT, RE_LOSS_SVYEXP, RE_RSV_LSS, RE_TVOG_AMT, RE_CEBF_AMT, RE_CE_LSS, CALCULATION_DATE, ACTUARY_ID, ADJUSTMENT_REASON)\n    VALUES ((SELECT NVL(MAX(RESERVE_ID), 0) + 1 FROM RESERVES), para_CLAIM_ID, para_ADJUSTMENT * 2, para_ADJUSTMENT * 1.5, para_ADJUSTMENT * 0.8, para_ADJUSTMENT * 0.3, para_ADJUSTMENT * 0.1, para_ADJUSTMENT * 0.4, para_ADJUSTMENT * 0.15, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), para_ACTUARY_ID, para_REASON);\n  END IF;\nEND;",
    "database_name": "insurance_car_management",
    "tables": [
      "CLAIMS",
      "CLAIM_INVESTIGATORS",
      "CLAIM_STATUS_HISTORY",
      "INVESTIGATORS",
      "PAYMENTS",
      "RESERVES"
    ],
    "call_sqls": [
      "BEGIN\n  sp5(para_CLAIM_ID => 0, para_ACTUARY_ID => 201, para_REASON => 'Initial calculation', para_ADJUSTMENT => 1000);\n  commit;\nEND;",
      "BEGIN\n  sp5(para_CLAIM_ID => 1, para_ACTUARY_ID => 202, para_REASON => 'Revised after additional information', para_ADJUSTMENT => 2500);\n  commit;\nEND;",
      "BEGIN\n  sp5(para_CLAIM_ID => 0, para_ACTUARY_ID => 203, para_REASON => 'Settlement reached', para_ADJUSTMENT => 500);\n  commit;\nEND;",
      "BEGIN\n  sp5(para_CLAIM_ID => 1, para_ACTUARY_ID => 201, para_REASON => 'Further investigation', para_ADJUSTMENT => 1500);\n  commit;\nEND;",
      "BEGIN\n  sp5(para_CLAIM_ID => 0, para_ACTUARY_ID => 202, para_REASON => 'Final adjustment', para_ADJUSTMENT => 750);\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp5 that manages claim reserves in the RESERVES table. It accepts a claim ID to identify the claim, an actuary ID to record who made the adjustment, a reason for the adjustment, and an adjustment amount. If the claim exists in the CLAIMS table, the procedure deletes any existing reserve records for that claim from the RESERVES table. It then inserts a new reserve record with a calculated RESERVE_ID, various reserve amounts derived by multiplying the adjustment amount by specific factors (2, 1.5, 0.8, 0.3, 0.1, 0.4, and 0.15 for the RE_IBNR_AMT, RE_OS_AMT, RE_LOSS_SVYEXP, RE_RSV_LSS, RE_TVOG_AMT, RE_CEBF_AMT, and RE_CE_LSS columns respectively), the current date, the provided actuary ID, and the reason.",
    "natural_language": "Write a Oracle PL/SQL stored procedure named sp5 that updates claim reserves. Given a claim ID, an actuary ID, a reason, and an adjustment amount, if the claim exists in the CLAIMS table, remove any existing reserves for that claim from the RESERVES table, then insert a new reserve record. The new record should have a calculated RESERVE_ID (the next available number), the provided claim ID, several derived amounts (the adjustment multiplied by specific factors: 2 for RE_IBNR_AMT, 1.5 for RE_OS_AMT, 0.8 for RE_LOSS_SVYEXP, 0.3 for RE_RSV_LSS, 0.1 for RE_TVOG_AMT, 0.4 for RE_CEBF_AMT, and 0.15 for RE_CE_LSS), the current date as CALCULATION_DATE, the provided actuary ID, and the provided reason as ADJUSTMENT_REASON.",
    "id": 85,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp5 that accepts four input parameters: a numeric para_CLAIM_ID, a numeric para_ACTUARY_ID, a string para_REASON, and a numeric para_ADJUSTMENT. The procedure first queries the CLAIMS table to count the number of rows where the CLAIM_ID column matches the input para_CLAIM_ID, storing the result in a local variable v_claim_exists. It then queries the RESERVES table to count the number of rows where the CLAIM_ID column matches the same input para_CLAIM_ID, storing this count in a local variable v_reserve_count. If the v_claim_exists count is greater than zero, indicating the claim exists, the procedure proceeds to check if the v_reserve_count is also greater than zero; if it is, the procedure executes a DELETE operation on the RESERVES table, removing all rows where the CLAIM_ID column equals the input para_CLAIM_ID. Following this conditional deletion, the procedure performs an INSERT into the RESERVES table, populating the following columns: RESERVE_ID is set to a new value calculated by selecting the current maximum value from the RESERVE_ID column in the RESERVES table, using the NVL function to treat NULL as zero, and then adding one; CLAIM_ID is set to the input para_CLAIM_ID; RE_IBNR_AMT is set to the input para_ADJUSTMENT multiplied by 2; RE_OS_AMT is set to para_ADJUSTMENT multiplied by 1.5; RE_LOSS_SVYEXP is set to para_ADJUSTMENT multiplied by 0.8; RE_RSV_LSS is set to para_ADJUSTMENT multiplied by 0.3; RE_TVOG_AMT is set to para_ADJUSTMENT multiplied by 0.1; RE_CEBF_AMT is set to para_ADJUSTMENT multiplied by 0.4; RE_CE_LSS is set to para_ADJUSTMENT multiplied by 0.15; CALCULATION_DATE is set to the current system date formatted as 'YYYY-MM-DD' using the TO_CHAR and SYSDATE functions; ACTUARY_ID is set to the input para_ACTUARY_ID; and ADJUSTMENT_REASON is set to the input string para_REASON.",
    "original_summary": "Create a stored procedure named sp5 to manage claim reserves. It accepts a claim ID, actuary ID, reason, and adjustment amount. If the claim exists, delete any existing reserves for it. Then insert a new reserve record with a calculated ID, various reserve amounts derived from the adjustment (multiplied by specific factors), the current date, the actuary ID, and the reason.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure sp5 for claim reserves. Input: claim ID, actuary ID, reason, adjustment. If claim exists, delete its old reserves. Insert new reserve with calculated ID, derived amounts (adjustment times factors), current date, actuary ID, reason."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp3 that accepts four parameters: para_CLAIM_ID of type NUMBER, para_ESTIMATED_LOSS of type NUMBER, para_LOCATION of type VARCHAR2, and para_DESCRIPTION of type VARCHAR2. The procedure begins by declaring a local variable v_claim_exists of type NUMBER. It then executes a SELECT statement to count the number of rows in the CLAIMS table where the CLAIM_ID column matches the value of para_CLAIM_ID, storing the result in v_claim_exists. If v_claim_exists equals 0, indicating that no claim with the given CLAIM_ID exists, the procedure performs two INSERT operations. The first INSERT adds a new row to the CLAIMS table with the following column values: CLAIM_ID set to para_CLAIM_ID, EXE_IDNO set to 0, SHOCK_SCN_CD set to 100, KICS_LTPF_CD set to 11, REPORT_DATE and INCIDENT_DATE both set to the current system date formatted as 'YYYY-MM-DD', CLAIM_STATUS set to 'open', CLAIM_TYPE set to 'property damage', INCIDENT_LOCATION set to para_LOCATION, DAMAGE_DESCRIPTION set to para_DESCRIPTION, ESTIMATED_LOSS set to para_ESTIMATED_LOSS, REPORTED_BY set to 'System', and EXTERNAL_DATA_REFERENCE set to 'AUTO-' concatenated with para_CLAIM_ID. The second INSERT adds a new row to the CLAIM_STATUS_HISTORY table with CLAIM_ID set to para_CLAIM_ID, STATUS_DATE set to the current system date formatted as 'YYYY-MM-DD', STATUS set to 'open', and CHANGED_BY set to 0. The procedure concludes without performing any further operations.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp3(para_CLAIM_ID NUMBER, para_ESTIMATED_LOSS NUMBER, para_LOCATION VARCHAR2, para_DESCRIPTION VARCHAR2) IS\n  v_claim_exists NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_claim_exists FROM CLAIMS WHERE CLAIM_ID = para_CLAIM_ID;\n  IF v_claim_exists = 0 THEN\n    INSERT INTO CLAIMS (CLAIM_ID, EXE_IDNO, SHOCK_SCN_CD, KICS_LTPF_CD, REPORT_DATE, INCIDENT_DATE, CLAIM_STATUS, CLAIM_TYPE, INCIDENT_LOCATION, DAMAGE_DESCRIPTION, ESTIMATED_LOSS, REPORTED_BY, EXTERNAL_DATA_REFERENCE)\n    VALUES (para_CLAIM_ID, 0, 100, 11, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'open', 'property damage', para_LOCATION, para_DESCRIPTION, para_ESTIMATED_LOSS, 'System', 'AUTO-' || para_CLAIM_ID);\n    INSERT INTO CLAIM_STATUS_HISTORY (CLAIM_ID, STATUS_DATE, STATUS, CHANGED_BY)\n    VALUES (para_CLAIM_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), 'open', 0);\n  END IF;\nEND;",
    "database_name": "insurance_car_management",
    "tables": [
      "CLAIMS",
      "CLAIM_INVESTIGATORS",
      "CLAIM_STATUS_HISTORY",
      "INVESTIGATORS",
      "PAYMENTS",
      "RESERVES"
    ],
    "call_sqls": [
      "BEGIN\n  sp3(para_CLAIM_ID => 100, para_ESTIMATED_LOSS => 7500, para_LOCATION => '789 Oak Ave, Anytown', para_DESCRIPTION => 'Water damage from burst pipe');\n  commit;\nEND;",
      "BEGIN\n  sp3(para_CLAIM_ID => 101, para_ESTIMATED_LOSS => 12000, para_LOCATION => '101 Pine St, Otherville', para_DESCRIPTION => 'Collision with deer');\n  commit;\nEND;",
      "BEGIN\n  sp3(para_CLAIM_ID => 102, para_ESTIMATED_LOSS => 3000, para_LOCATION => '222 Maple Dr, Somewhere', para_DESCRIPTION => 'Theft of personal belongings');\n  commit;\nEND;",
      "BEGIN\n  sp3(para_CLAIM_ID => 103, para_ESTIMATED_LOSS => 25000, para_LOCATION => '333 Birch Ln, Nowhere', para_DESCRIPTION => 'Fire damage to kitchen');\n  commit;\nEND;",
      "BEGIN\n  sp3(para_CLAIM_ID => 104, para_ESTIMATED_LOSS => 500, para_LOCATION => '444 Cedar Rd, Anyplace', para_DESCRIPTION => 'Broken window from vandalism');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp3 that accepts a claim ID, an estimated loss amount, a location, and a description. If a claim with the given CLAIM_ID does not already exist in the CLAIMS table, insert a new claim record using the provided details along with default values for EXE_IDNO, SHOCK_SCN_CD, KICS_LTPF_CD, REPORT_DATE, INCIDENT_DATE, CLAIM_STATUS, CLAIM_TYPE, REPORTED_BY, and a system-generated EXTERNAL_DATA_REFERENCE. Also, insert a corresponding initial 'open' status record into the CLAIM_STATUS_HISTORY table for the new claim.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp3 that takes a claim ID, an estimated loss figure, a location, and a description. Check if a claim with that CLAIM_ID already exists in the CLAIMS table. If it does not exist, insert a new claim into the CLAIMS table with the provided details, using standard defaults like EXE_IDNO as 0, SHOCK_SCN_CD as 100, KICS_LTPF_CD as 11, REPORT_DATE and INCIDENT_DATE as the current date, CLAIM_STATUS as 'open', CLAIM_TYPE as 'property damage', REPORTED_BY as 'System', and EXTERNAL_DATA_REFERENCE as 'AUTO-' concatenated with the claim ID. Also, add an entry to the CLAIM_STATUS_HISTORY table to record that the claim started with status 'open'.",
    "id": 86,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp3 that accepts four parameters: para_CLAIM_ID of type NUMBER, para_ESTIMATED_LOSS of type NUMBER, para_LOCATION of type VARCHAR2, and para_DESCRIPTION of type VARCHAR2. The procedure begins by declaring a local variable v_claim_exists of type NUMBER. It then executes a SELECT statement to count the number of rows in the CLAIMS table where the CLAIM_ID column matches the value of para_CLAIM_ID, storing the result in v_claim_exists. If v_claim_exists equals 0, indicating that no claim with the given CLAIM_ID exists, the procedure performs two INSERT operations. The first INSERT adds a new row to the CLAIMS table with the following column values: CLAIM_ID set to para_CLAIM_ID, EXE_IDNO set to 0, SHOCK_SCN_CD set to 100, KICS_LTPF_CD set to 11, REPORT_DATE and INCIDENT_DATE both set to the current system date formatted as 'YYYY-MM-DD', CLAIM_STATUS set to 'open', CLAIM_TYPE set to 'property damage', INCIDENT_LOCATION set to para_LOCATION, DAMAGE_DESCRIPTION set to para_DESCRIPTION, ESTIMATED_LOSS set to para_ESTIMATED_LOSS, REPORTED_BY set to 'System', and EXTERNAL_DATA_REFERENCE set to 'AUTO-' concatenated with para_CLAIM_ID. The second INSERT adds a new row to the CLAIM_STATUS_HISTORY table with CLAIM_ID set to para_CLAIM_ID, STATUS_DATE set to the current system date formatted as 'YYYY-MM-DD', STATUS set to 'open', and CHANGED_BY set to 0. The procedure concludes without performing any further operations.",
    "original_summary": "Create a stored procedure named sp3 that accepts a claim ID, estimated loss, location, and description. Check if the claim exists. If it does not exist, insert a new claim with the provided details, default values, and a system-generated external reference. Also, insert an initial 'open' status entry into the claim history.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create a stored procedure called sp3 that takes a claim ID, a rough loss figure, a general area, and some descriptive text. Check if a claim like that is already around. If you can't find it, add a new claim with the details given, using standard defaults and a reference number the system makes up. Also, put an entry in the history to show it started as 'open'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `update_item_price` that accepts three parameters: `p_item_id` of data type `NUMBER`, intended to identify the specific item whose price is to be updated; `p_new_price` of data type `NUMBER`, representing the new price to be assigned to the identified item; and `v_old_price` of data type `NUMBER`, which is an `OUT` parameter designed to return the original price of the item before the update. The procedure first executes a `SELECT` statement to retrieve the current `price` from the `clothing_items` table. This retrieval is conditioned by matching the `item_id` column in the `clothing_items` table with the value provided in the `p_item_id` input parameter. The retrieved `price` value is then immediately stored into the `v_old_price` `OUT` parameter. Following this, the procedure executes an `UPDATE` statement on the `clothing_items` table. This `UPDATE` statement sets the `price` column to the value provided in the `p_new_price` input parameter. The `UPDATE` operation is also conditioned by matching the `item_id` column in the `clothing_items` table with the value provided in the `p_item_id` input parameter, ensuring that only the specified item's price is modified.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_item_price(p_item_id NUMBER, p_new_price NUMBER, v_old_price OUT NUMBER) IS\nBEGIN\n    SELECT price INTO v_old_price FROM clothing_items WHERE item_id = p_item_id;\n    UPDATE clothing_items SET price = p_new_price WHERE item_id = p_item_id;\nEND;",
    "database_name": "clothing_ssaim_738508",
    "tables": [
      "CLOTHING_ITEMS",
      "ITEM_SIZES",
      "SIZES",
      "ORDER_ITEMS"
    ],
    "call_sqls": [
      "DECLARE\n  v_old_price_out NUMBER;\nBEGIN\n  update_item_price(p_item_id => 0, p_new_price => 25.50, v_old_price => v_old_price_out);\n  DBMS_OUTPUT.PUT_LINE('Old Price: ' || v_old_price_out);\nEND;",
      "DECLARE\n  v_old_price_out NUMBER;\nBEGIN\n  update_item_price(p_item_id => 1, p_new_price => 55.00, v_old_price => v_old_price_out);\n  DBMS_OUTPUT.PUT_LINE('Old Price: ' || v_old_price_out);\nEND;",
      "DECLARE\n  v_old_price_out NUMBER;\nBEGIN\n  update_item_price(p_item_id => 0, p_new_price => 20.00, v_old_price => v_old_price_out);\n  DBMS_OUTPUT.PUT_LINE('Old Price: ' || v_old_price_out);\nEND;",
      "DECLARE\n  v_old_price_out NUMBER;\nBEGIN\n  update_item_price(p_item_id => 1, p_new_price => 60.00, v_old_price => v_old_price_out);\n  DBMS_OUTPUT.PUT_LINE('Old Price: ' || v_old_price_out);\nEND;",
      "DECLARE\n  v_old_price_out NUMBER;\nBEGIN\n  update_item_price(p_item_id => 0, p_new_price => 18.99, v_old_price => v_old_price_out);\n  DBMS_OUTPUT.PUT_LINE('Old Price: ' || v_old_price_out);\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_item_price that, given an item ID and a new price, retrieves the current price from the clothing_items table for that ID, returns that old price as an output, and updates the price in the clothing_items table to the new value for the specified item.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_item_price that takes an item ID and a new price as input numbers and returns the old price as an output number, which involves retrieving the current price from the clothing_items table for the given ID, storing it in the output parameter, and then updating the price in the table to the new value for that item?",
    "id": 87,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `update_item_price` that accepts three parameters: `p_item_id` of data type `NUMBER`, intended to identify the specific item whose price is to be updated; `p_new_price` of data type `NUMBER`, representing the new price to be assigned to the identified item; and `v_old_price` of data type `NUMBER`, which is an `OUT` parameter designed to return the original price of the item before the update. The procedure first executes a `SELECT` statement to retrieve the current `price` from the `clothing_items` table. This retrieval is conditioned by matching the `item_id` column in the `clothing_items` table with the value provided in the `p_item_id` input parameter. The retrieved `price` value is then immediately stored into the `v_old_price` `OUT` parameter. Following this, the procedure executes an `UPDATE` statement on the `clothing_items` table. This `UPDATE` statement sets the `price` column to the value provided in the `p_new_price` input parameter. The `UPDATE` operation is also conditioned by matching the `item_id` column in the `clothing_items` table with the value provided in the `p_item_id` input parameter, ensuring that only the specified item's price is modified.",
    "original_summary": "Create a stored procedure named update_item_price that accepts an item ID and a new price as input numbers, and returns the old price as an output number. It retrieves the current price from the clothing_items table for the given ID, stores it in the output parameter, and then updates the price in the table to the new value for that item.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure called update_item_price that takes an item ID and a new price as input numbers and returns the old price as an output number, which involves retrieving the current price from the clothing_items table for the given ID, storing it in the output parameter, and then updating the price in the table to the new value for that item?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `summarize_influencer_data` that accepts five input parameters: `p_start_date` of type `VARCHAR2`, representing the beginning of a date range; `p_end_date` of type `VARCHAR2`, representing the end of a date range; `p_min_likes` of type `NUMBER`, representing a minimum number of likes; `p_location` of type `VARCHAR2`, representing a location pattern; and `p_influencer_type` of type `VARCHAR2`, representing the type of influencer. The procedure declares three local variables: `v_avg_engagement_rate` of type `NUMBER`, initialized to `0`; `v_metric_id` of type `NUMBER`; and `v_influencer_id` of type `NUMBER`, initialized to `0`. The procedure first calculates the average engagement rate from the `influencers` table. This calculation involves selecting the average of the `average_engagement_rate` column from the `influencers` table and storing it into the `v_avg_engagement_rate` variable. The selection is filtered by several conditions: the `likes` column must be greater than or equal to the `p_min_likes` parameter; the `location` column must contain the pattern specified by the `p_location` parameter, as determined by the `REGEXP_INSTR` function returning a value greater than `0`; the `influencer_type` column must exactly match the `p_influencer_type` parameter; and the `date_of_birth` column must fall inclusively between the `p_start_date` and `p_end_date` parameters. After this selection, the procedure checks if `v_avg_engagement_rate` is `NULL`. If it is `NULL`, indicating that no rows matched the filtering criteria, `v_avg_engagement_rate` is set to `0`. Next, the procedure determines the `metric_id` for a new record in the `engagement_metrics` table. It does this by selecting the maximum value of the `metric_id` column from the `engagement_metrics` table, adding `1` to it, and storing the result in `v_metric_id`. If the `engagement_metrics` table is empty and `MAX(metric_id)` returns `NULL`, the `NVL` function ensures that `0` is used instead, resulting in `v_metric_id` being set to `1`. Finally, the procedure inserts a new row into the `engagement_metrics` table. The `metric_id` column is populated with the value of `v_metric_id`. The `influencer_id` column is populated with the value of `v_influencer_id`. The `metric_type` column is set to the literal string `'AVG_ENGAGEMENT_RATE'`. The `value` column is populated with the value of `v_avg_engagement_rate`. The `date_recorded` column is populated with the current system date, formatted as 'YYYY-MM-DD' using the `TO_CHAR` function with `SYSDATE`. The `engagement_rate` column is populated with the value of `v_avg_engagement_rate`. The `metric_unit` column is set to the literal string `'percentage'`.",
    "plsql": "CREATE OR REPLACE PROCEDURE summarize_influencer_data(\n    p_start_date VARCHAR2,\n    p_end_date VARCHAR2,\n    p_min_likes NUMBER,\n    p_location VARCHAR2,\n    p_influencer_type VARCHAR2\n) IS\n    v_avg_engagement_rate NUMBER := 0;\n    v_metric_id NUMBER;\n    v_influencer_id NUMBER := 0;\nBEGIN\n    -- Calculate average engagement rate with date filtering (assuming date_recorded exists in influencers)\n    SELECT AVG(i.average_engagement_rate)\n    INTO v_avg_engagement_rate\n    FROM influencers i\n    WHERE i.likes >= p_min_likes\n    AND REGEXP_INSTR(i.location, p_location) > 0\n    AND i.influencer_type = p_influencer_type\n    AND i.date_of_birth BETWEEN p_start_date AND p_end_date;\n    \n    -- Handle case when no rows match\n    IF v_avg_engagement_rate IS NULL THEN\n        v_avg_engagement_rate := 0;\n    END IF;\n    \n    -- Generate next metric_id using max existing value\n    SELECT NVL(MAX(metric_id), 0) + 1\n    INTO v_metric_id\n    FROM engagement_metrics;\n    \n    INSERT INTO engagement_metrics (metric_id, influencer_id, metric_type, value, date_recorded, engagement_rate, metric_unit)\n    VALUES (v_metric_id, v_influencer_id, 'AVG_ENGAGEMENT_RATE', v_avg_engagement_rate, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), v_avg_engagement_rate, 'percentage');\nEND;",
    "database_name": "social_mimap_information",
    "tables": [
      "INFLUENCERS",
      "INFLUENCER_CAMPAIGNS",
      "ENGAGEMENT_METRICS"
    ],
    "call_sqls": [
      "BEGIN\n  summarize_influencer_data('1990-01-01', '2000-12-31', 10000, 'USA', 'Fashion');\nEND;",
      "BEGIN\n  summarize_influencer_data('1985-05-15', '1995-05-15', 50000, 'UK', 'Travel');\nEND;",
      "BEGIN\n  summarize_influencer_data('2000-01-01', '2010-01-01', 20000, 'Canada', 'Food');\nEND;",
      "BEGIN\n  summarize_influencer_data('1970-01-01', '1980-12-31', 5000, 'Australia', 'Gaming');\nEND;",
      "BEGIN\n  summarize_influencer_data('1992-03-01', '2002-03-01', 15000, 'Germany', 'Beauty');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `summarize_influencer_data` that takes a start date, an end date, a minimum number of likes, a location pattern, and an influencer type as input. It calculates the average engagement rate from the INFLUENCERS table for influencers whose LIKES meet or exceed the minimum, whose LOCATION matches the pattern, whose INFLUENCER_TYPE matches the given type, and whose DATE_OF_BIRTH falls within the specified date range. If no average is found, it uses 0. It then generates a new unique METRIC_ID and inserts a record into the ENGAGEMENT_METRICS table with the metric type 'AVG_ENGAGEMENT_RATE', the calculated average as the VALUE and ENGAGEMENT_RATE, the current date as DATE_RECORDED in 'YYYY-MM-DD' format, 'percentage' as the METRIC_UNIT, and a placeholder INFLUENCER_ID of 0.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called summarize_influencer_data that takes a start date, an end date, a minimum number of likes, a location pattern for partial matching, and an influencer type, and calculates the average engagement rate from the influencers table for influencers who meet or exceed the minimum likes, have a location containing the specified pattern, match the given influencer type, and have a date_of_birth between the provided dates; if no average is found, default it to 0, then generate a new metric ID and insert a record into the engagement_metrics table with metric_type as 'AVG_ENGAGEMENT_RATE', value as the calculated average, date_recorded as today in 'YYYY-MM-DD' format, and metric_unit as 'percentage'.",
    "id": 88,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named summarize_influencer_data that accepts five input parameters: p_start_date of type DATE, p_end_date of type DATE, p_min_likes of type NUMBER, p_location_pattern of type VARCHAR2, and p_influencer_type of type VARCHAR2. The procedure first declares two local variables: v_avg_engagement_rate of type NUMBER and v_new_metric_id of type NUMBER. It begins execution by performing a SELECT AVG(engagement_rate) query from the influencers table, where the likes column is greater than or equal to the input parameter p_min_likes, the location column contains the substring specified by p_location_pattern using the LIKE operator with wildcards, the influencer_type column matches exactly the input parameter p_influencer_type, and the date_of_birth column is between the input parameters p_start_date and p_end_date inclusive. The result of this average calculation is stored into the variable v_avg_engagement_rate. If no rows satisfy the conditions, the SELECT statement returns NULL, so the procedure uses the NVL function to convert any NULL value in v_avg_engagement_rate to 0. Next, the procedure generates a new metric ID by executing a SELECT MAX(metric_id) + 1 query from the engagement_metrics table, storing the result into v_new_metric_id; if the table is empty, the MAX function returns NULL, so it uses the NVL function to default v_new_metric_id to 1. Finally, the procedure performs an INSERT operation into the engagement_metrics table, specifying the columns metric_id, metric_type, value, date_recorded, and metric_unit. The inserted values are: v_new_metric_id for metric_id, the literal string 'AVG_ENGAGEMENT_RATE' for metric_type, v_avg_engagement_rate for value, the current system date formatted as 'YYYY-MM-DD' using TO_CHAR(SYSDATE, 'YYYY-MM-DD') for date_recorded, and the literal string 'percentage' for metric_unit.",
    "original_summary": "Create a stored procedure named `summarize_influencer_data` with parameters for start date, end date, minimum likes, location pattern, and influencer type. It calculates the average engagement rate from the influencers table filtered by likes, location pattern, influencer type, and date of birth range. If no average is found, use 0. It generates a new metric ID and inserts an 'AVG_ENGAGEMENT_RATE' record into the engagement_metrics table with the average value, current date as 'YYYY-MM-DD', and 'percentage' unit.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, so I need you to whip up a stored procedure called `summarize_influencer_data`. It's gotta take in a start date, an end date, a minimum number of likes, a location pattern (like a partial match), and the type of influencer. What it does is figure out the average engagement rate from the influencers table, but only for folks who hit that likes threshold, match the location and type, and were born between those dates. If it comes up empty and there's no average, just default to 0. Then, it should cook up a new metric ID and slap a new record into the engagement_metrics table. The record's metric type is 'AVG_ENGAGEMENT_RATE', the value is that average we calculated, the date is today in 'YYYY-MM-DD' format, and the unit is 'percentage'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_update_prefix_status_based_on_allocation that accepts three input parameters: a numeric parameter para_Prefix_ID, a numeric parameter para_Company_ID, and a numeric parameter para_Threshold. The procedure first queries the NUMBER_ALLOCATIONS table to count the number of rows where the PREFIX_ID column equals the para_Prefix_ID parameter, the COMPANY_ID column equals the para_Company_ID parameter, and the STATUS column has the exact string value 'active', storing this count in a local variable v_Active_Allocations. It then uses conditional logic to determine a new status string: if the count v_Active_Allocations is zero, it sets a local variable v_New_Status to the string 'inactive'; if the count is greater than zero but less than the para_Threshold parameter value, it sets v_New_Status to the string 'limited'; otherwise, if the count is greater than or equal to para_Threshold, it sets v_New_Status to the string 'active'. Finally, the procedure performs an update on the NUMBER_PREFIXES table, setting the STATUS column to the value of v_New_Status for the specific row where the PREFIX_ID column matches the input parameter para_Prefix_ID.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_update_prefix_status_based_on_allocation(para_Prefix_ID NUMBER, para_Company_ID NUMBER, para_Threshold NUMBER) IS\n  v_Active_Allocations NUMBER;\n  v_New_Status VARCHAR2(255);\nBEGIN\n  SELECT COUNT(*) INTO v_Active_Allocations\n  FROM NUMBER_ALLOCATIONS\n  WHERE PREFIX_ID = para_Prefix_ID\n    AND COMPANY_ID = para_Company_ID\n    AND STATUS = 'active';\n  IF v_Active_Allocations = 0 THEN\n    v_New_Status := 'inactive';\n  ELSIF v_Active_Allocations < para_Threshold THEN\n    v_New_Status := 'limited';\n  ELSE\n    v_New_Status := 'active';\n  END IF;\n  UPDATE NUMBER_PREFIXES SET STATUS = v_New_Status WHERE PREFIX_ID = para_Prefix_ID;\nEND;",
    "database_name": "telecommunication_naa_usa",
    "tables": [
      "NUMBER_ALLOCATIONS",
      "NUMBER_PREFIXES"
    ],
    "call_sqls": [
      "BEGIN\n  sp_update_prefix_status_based_on_allocation(1, 1, 5);\n  commit;\nEND;",
      "BEGIN\n  sp_update_prefix_status_based_on_allocation(1, 0, 3);\n  commit;\nEND;",
      "BEGIN\n  sp_update_prefix_status_based_on_allocation(0, 1, 2);\n  commit;\nEND;",
      "BEGIN\n  sp_update_prefix_status_based_on_allocation(0, 0, 1);\n  commit;\nEND;",
      "BEGIN\n  sp_update_prefix_status_based_on_allocation(1, 1, 10);\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `sp_update_prefix_status_based_on_allocation` that, for a given PREFIX_ID and COMPANY_ID, counts the active allocations in the NUMBER_ALLOCATIONS table and updates the STATUS of that prefix in the NUMBER_PREFIXES table to 'inactive' if there are no active allocations, to 'limited' if the count is positive but below a provided threshold, or to 'active' if the count meets or exceeds the threshold.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called `sp_update_prefix_status_based_on_allocation` that takes a prefix ID, a company ID, and a threshold number, counts how many 'active' allocations exist for that prefix and company in the NUMBER_ALLOCATIONS table, and then updates the STATUS of that prefix in the NUMBER_PREFIXES table to 'inactive' if there are none, 'limited' if the count is below the threshold, or 'active' if it meets or exceeds the threshold.",
    "id": 89,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_update_prefix_status_based_on_allocation that accepts three input parameters: a numeric parameter para_Prefix_ID, a numeric parameter para_Company_ID, and a numeric parameter para_Threshold. The procedure first queries the NUMBER_ALLOCATIONS table to count the number of rows where the PREFIX_ID column equals the para_Prefix_ID parameter, the COMPANY_ID column equals the para_Company_ID parameter, and the STATUS column has the exact string value 'active', storing this count in a local variable v_Active_Allocations. It then uses conditional logic to determine a new status string: if the count v_Active_Allocations is zero, it sets a local variable v_New_Status to the string 'inactive'; if the count is greater than zero but less than the para_Threshold parameter value, it sets v_New_Status to the string 'limited'; otherwise, if the count is greater than or equal to para_Threshold, it sets v_New_Status to the string 'active'. Finally, the procedure performs an update on the NUMBER_PREFIXES table, setting the STATUS column to the value of v_New_Status for the specific row where the PREFIX_ID column matches the input parameter para_Prefix_ID.",
    "original_summary": "Create a stored procedure named `sp_update_prefix_status_based_on_allocation` that takes a prefix ID, a company ID, and a threshold number. Count the 'active' allocations for the given prefix and company in the NUMBER_ALLOCATIONS table. Update the STATUS of that prefix in the NUMBER_PREFIXES table to 'inactive' if the count is zero, 'limited' if the count is positive but below the threshold, or 'active' if the count meets or exceeds the threshold.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called `sp_update_prefix_status_based_on_allocation` that uses a prefix ID, a company ID, and a kind of threshold number. Figure out roughly how many 'active' allocations exist for that prefix and company in the NUMBER_ALLOCATIONS table. Then, adjust the STATUS of that prefix in the NUMBER_PREFIXES table: set it to 'inactive' if there aren't really any, change it to 'limited' if there are a few but not too many compared to the threshold, or mark it as 'active' if there seems to be a good number meeting or passing that threshold."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_size_update_record that accepts two parameters: p_measurement_id of type NUMBER, which identifies a specific measurement, and p_update_reason of type VARCHAR2, which provides a reason for the update. The procedure begins by declaring two local variables: v_size_label of type VARCHAR2(255) to store the size label associated with the measurement, and v_update_id of type NUMBER to store the next update identifier. The procedure first executes a SELECT statement to retrieve the SIZE_LABEL from the SIZES table by joining it with the MEASUREMENTS table on the SIZE_ID column, where the MEASUREMENT_ID matches the input parameter p_measurement_id. The retrieved SIZE_LABEL is stored in the v_size_label variable. Next, the procedure determines the next available UPDATE_ID by selecting the maximum UPDATE_ID from the SIZE_UPDATES table, using the NVL function to handle nulls by defaulting to 0, and then incrementing the result by 1. This value is stored in the v_update_id variable. Finally, the procedure inserts a new record into the SIZE_UPDATES table with the following values: v_update_id for the UPDATE_ID column, p_measurement_id for the MEASUREMENT_ID column, the current system date formatted as 'YYYY-MM-DD' for the UPDATE_DATE column, p_update_reason for the UPDATE_REASON column, and a concatenated string 'Size label: ' followed by the value of v_size_label for the UPDATE_DESCRIPTION column.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_size_update_record(\n    p_measurement_id IN NUMBER,\n    -- p_updated_by IN NUMBER, -- Removed as it causes FK violation and parent table is not provided\n    p_update_reason IN VARCHAR2\n) AS\n    v_size_label VARCHAR2(255);\n    v_update_id NUMBER;\nBEGIN\n    SELECT SIZE_LABEL INTO v_size_label\n    FROM SIZES s\n    JOIN MEASUREMENTS m ON s.SIZE_ID = m.SIZE_ID\n    WHERE m.MEASUREMENT_ID = p_measurement_id;\n\n    SELECT NVL(MAX(UPDATE_ID), 0) + 1 INTO v_update_id\n    FROM SIZE_UPDATES;\n\n    INSERT INTO SIZE_UPDATES (UPDATE_ID, MEASUREMENT_ID, UPDATE_DATE, UPDATE_REASON, UPDATE_DESCRIPTION)\n    VALUES (v_update_id, p_measurement_id, TO_CHAR(SYSDATE, 'YYYY-MM-DD'), p_update_reason, 'Size label: ' || v_size_label);\nEND;",
    "database_name": "apparel_sams_543314",
    "tables": [
      "SIZES",
      "MEASUREMENTS",
      "SIZE_UPDATES"
    ],
    "call_sqls": [
      "BEGIN\n    insert_size_update_record(0, 'design change');\n    COMMIT;\nEND;",
      "BEGIN\n    insert_size_update_record(1, 'production issue');\n    COMMIT;\nEND;",
      "BEGIN\n    insert_size_update_record(0, 'quality adjustment');\n    COMMIT;\nEND;",
      "BEGIN\n    insert_size_update_record(1, 'customer feedback');\n    COMMIT;\nEND;",
      "BEGIN\n    insert_size_update_record(0, 'seasonal update');\n    COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `insert_size_update_record` that inserts a new record into the SIZE_UPDATES table. It takes a measurement ID and an update reason as input. For the given measurement ID, it retrieves the corresponding size label from the SIZES table via the MEASUREMENTS table. It then generates a new unique update ID by finding the maximum existing UPDATE_ID in SIZE_UPDATES and incrementing it by one. Finally, it inserts a record into SIZE_UPDATES with the new update ID, the provided measurement ID, the current date, the provided update reason, and a description that concatenates 'Size label: ' with the retrieved size label.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called `insert_size_update_record` that inserts a new record into the `SIZE_UPDATES` table. It should take a measurement ID and an update reason as inputs, retrieve the corresponding size label from the `SIZES` and `MEASUREMENTS` tables, generate a new update ID by incrementing the highest existing one, and insert a record with that new ID, the measurement ID, today's date, the provided reason, and a description that includes the fetched size label.",
    "id": 90,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named insert_size_update_record that accepts two parameters: p_measurement_id of type NUMBER, which identifies a specific measurement, and p_update_reason of type VARCHAR2, which provides a reason for the update. The procedure begins by declaring two local variables: v_size_label of type VARCHAR2(255) to store the size label associated with the measurement, and v_update_id of type NUMBER to store the next update identifier. The procedure first executes a SELECT statement to retrieve the SIZE_LABEL from the SIZES table by joining it with the MEASUREMENTS table on the SIZE_ID column, where the MEASUREMENT_ID matches the input parameter p_measurement_id. The retrieved SIZE_LABEL is stored in the v_size_label variable. Next, the procedure determines the next available UPDATE_ID by selecting the maximum UPDATE_ID from the SIZE_UPDATES table, using the NVL function to handle nulls by defaulting to 0, and then incrementing the result by 1. This value is stored in the v_update_id variable. Finally, the procedure inserts a new record into the SIZE_UPDATES table with the following values: v_update_id for the UPDATE_ID column, p_measurement_id for the MEASUREMENT_ID column, the current system date formatted as 'YYYY-MM-DD' for the UPDATE_DATE column, p_update_reason for the UPDATE_REASON column, and a concatenated string 'Size label: ' followed by the value of v_size_label for the UPDATE_DESCRIPTION column.",
    "original_summary": "Create a stored procedure named `insert_size_update_record` that inserts a new record into the `SIZE_UPDATES` table. It retrieves a size label based on a given measurement ID, generates a new update ID, and inserts a record with the new ID, measurement ID, current date, a provided reason, and a description containing the retrieved size label.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Write a stored procedure called `insert_size_update_record` to insert a new record into the `SIZE_UPDATES` table. Fetch the size label using a provided measurement ID, create a new update ID, and then insert a record with that new ID, the measurement ID, today's date, a given reason, and a description that includes the fetched size label."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_new_patient that accepts three input parameters: a string parameter p_first_name for the patient's first name, a string parameter p_last_name for the patient's last name, and a string parameter p_contact_number for the patient's contact number, and within its execution block, it first declares a local numeric variable v_patient_id, then performs a SELECT query on the PATIENTS table to retrieve the current maximum value from the PATIENT_ID column, applies the NVL function to that result to convert a potential NULL value to 0, adds 1 to this value, and assigns the result into the v_patient_id variable, and subsequently executes an INSERT statement into the PATIENTS table, specifying the columns PATIENT_ID, FIRST_NAME, LAST_NAME, CONTACT_NUMBER, and CREATED_AT, and inserting the values consisting of the generated v_patient_id, the input parameter p_first_name, the input parameter p_last_name, the input parameter p_contact_number, and a string representation of the current system date and time obtained by applying the TO_CHAR function to the SYSDATE function with the format model 'YYYY-MM-DD HH24:MI:SS'.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_patient(\n    p_first_name IN VARCHAR2,\n    p_last_name IN VARCHAR2,\n    p_contact_number IN VARCHAR2\n)\nIS\n    v_patient_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(PATIENT_ID), 0) + 1 INTO v_patient_id FROM PATIENTS;\n    \n    INSERT INTO PATIENTS (PATIENT_ID, FIRST_NAME, LAST_NAME, CONTACT_NUMBER, CREATED_AT)\n    VALUES (v_patient_id, p_first_name, p_last_name, p_contact_number, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\nEND;",
    "database_name": "medical_daph_monitoring",
    "tables": [
      "PATIENTS",
      "DIAGNOSES",
      "TREATMENTS",
      "CLINICAL_OBSERVATIONS",
      "LAB_TESTS"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_patient('John', 'Doe', '555-1234');\nEND;",
      "BEGIN\n  insert_new_patient('Jane', 'Smith', '555-5678');\nEND;",
      "BEGIN\n  insert_new_patient('Peter', 'Jones', '555-9012');\nEND;",
      "BEGIN\n  insert_new_patient('Alice', 'Williams', '555-3456');\nEND;",
      "BEGIN\n  insert_new_patient('Robert', 'Brown', '555-7890');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named insert_new_patient that adds a new patient record to the PATIENTS table. It takes the patient's first name (p_first_name), last name (p_last_name), and contact number (p_contact_number) as inputs. The procedure automatically generates a new PATIENT_ID by incrementing the highest existing ID in the PATIENTS table (starting from 1 if no records exist) and inserts the new record with this generated ID, the provided names and contact number, and the current timestamp in the 'YYYY-MM-DD HH24:MI:SS' format into the CREATED_AT column.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called insert_new_patient that adds a new patient to the PATIENTS table by taking the patient's first name as p_first_name, last name as p_last_name, and contact number as p_contact_number. It should determine the next PATIENT_ID by incrementing the highest existing PATIENT_ID from the PATIENTS table, or start at 1 if no patients exist, then insert a new record with that new ID, the provided names and contact number, and the current date and time formatted as 'YYYY-MM-DD HH24:MI:SS' into the CREATED_AT column.",
    "id": 91,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named insert_new_patient that accepts three input parameters: a string parameter p_first_name for the patient's first name, a string parameter p_last_name for the patient's last name, and a string parameter p_contact_number for the patient's contact number, and within its execution block, it first declares a local numeric variable v_patient_id, then performs a SELECT query on the PATIENTS table to retrieve the current maximum value from the PATIENT_ID column, applies the NVL function to that result to convert a potential NULL value to 0, adds 1 to this value, and assigns the result into the v_patient_id variable, and subsequently executes an INSERT statement into the PATIENTS table, specifying the columns PATIENT_ID, FIRST_NAME, LAST_NAME, CONTACT_NUMBER, and CREATED_AT, and inserting the values consisting of the generated v_patient_id, the input parameter p_first_name, the input parameter p_last_name, the input parameter p_contact_number, and a string representation of the current system date and time obtained by applying the TO_CHAR function to the SYSDATE function with the format model 'YYYY-MM-DD HH24:MI:SS'.",
    "original_summary": "Create a stored procedure named insert_new_patient that inserts a new patient. It accepts p_first_name, p_last_name, and p_contact_number as VARCHAR2 parameters. It generates a new PATIENT_ID by incrementing the current maximum ID (or starting from 1), and inserts the record with the generated ID, the provided names and contact number, and the current timestamp in 'YYYY-MM-DD HH24:MI:SS' format.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Hey, can you whip up a stored procedure called insert_new_patient to add a new patient? It should take in p_first_name, p_last_name, and p_contact_number as VARCHAR2 inputs. The procedure needs to figure out the next PATIENT_ID by bumping up the highest current ID (or just use 1 if there's none yet). Then, it slaps in a new record with that new ID, the given names and phone number, and stamps it with the current date and time in 'YYYY-MM-DD HH24:MI:SS' format."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named manage_customer_status that takes four input parameters: a numeric p_customer_id, a numeric p_days_threshold, a string p_start_date, and a string p_end_date. The procedure first checks if a customer exists by selecting the count of rows from the CUSTOMERS table where the CUSTOMER_ID column equals the provided p_customer_id, storing the result in variable v_customer_exists. If this count is zero, the procedure exits immediately without performing further actions. If the customer exists, it proceeds to count the customer's orders within a specified date range by selecting the count of rows from the ORDERS table where the CUSTOMER_ID column equals p_customer_id and the ORDER_DATE column, converted from a string to a date using the format 'YYYY-MM-DD', falls between the p_start_date and p_end_date parameters, also converted to dates using the same format; this count is stored in variable v_order_count. Next, the procedure retrieves the customer's last activity date by selecting from the CUSTOMERS table the value of the LAST_ACTIVITY_DATE column for the given p_customer_id, using the NVL function to substitute the DATE_ADDED column's value if LAST_ACTIVITY_DATE is null, and stores this string result in variable v_last_activity. It then calculates the number of days since this last activity by subtracting the date value of v_last_activity, converted using the 'YYYY-MM-DD' format, from the current date truncated to midnight, storing the result in variable v_days_since_activity. The core logic executes a conditional check: if v_order_count is zero and v_days_since_activity is greater than the provided p_days_threshold, the procedure inserts a new record into the CUSTOMER_INTERACTIONS table. The inserted values are: for the INTERACTION_ID column, a subquery selects the maximum existing INTERACTION_ID from the CUSTOMER_INTERACTIONS table, uses NVL to default to 0 if the table is empty, and adds 1; for the CUSTOMER_ID column, the input parameter p_customer_id; for the CAMPAIGN_ID column, a null value; for the INTERACTION_DATE column, the current date converted to a string in 'YYYY-MM-DD' format; and for the INTERACTION_TYPE column, the literal string 'inactive_followup'. The procedure includes an exception handler that catches any exception with the WHEN OTHERS clause and performs no action, effectively suppressing any errors that occur during execution.",
    "plsql": "CREATE OR REPLACE PROCEDURE manage_customer_status(\n    p_customer_id IN NUMBER,\n    p_days_threshold IN NUMBER,\n    p_start_date IN VARCHAR2,\n    p_end_date IN VARCHAR2\n) IS\n    v_order_count NUMBER;\n    v_last_activity VARCHAR2(255);\n    v_days_since_activity NUMBER;\n    v_customer_exists NUMBER;\nBEGIN\n    -- Check if customer exists\n    SELECT COUNT(*) INTO v_customer_exists\n    FROM CUSTOMERS\n    WHERE CUSTOMER_ID = p_customer_id;\n    \n    IF v_customer_exists = 0 THEN\n        RETURN;\n    END IF;\n    \n    -- Count orders in date range\n    SELECT COUNT(*) INTO v_order_count\n    FROM ORDERS\n    WHERE CUSTOMER_ID = p_customer_id\n    AND TO_DATE(ORDER_DATE, 'YYYY-MM-DD') BETWEEN TO_DATE(p_start_date, 'YYYY-MM-DD') \n                                             AND TO_DATE(p_end_date, 'YYYY-MM-DD');\n    \n    -- Get last activity date\n    SELECT NVL(LAST_ACTIVITY_DATE, DATE_ADDED) INTO v_last_activity\n    FROM CUSTOMERS\n    WHERE CUSTOMER_ID = p_customer_id;\n    \n    -- Calculate days since last activity\n    v_days_since_activity := TRUNC(CURRENT_DATE) - TO_DATE(v_last_activity, 'YYYY-MM-DD');\n    \n    IF v_order_count = 0 AND v_days_since_activity > p_days_threshold THEN\n        INSERT INTO CUSTOMER_INTERACTIONS (INTERACTION_ID, CUSTOMER_ID, CAMPAIGN_ID, INTERACTION_DATE, INTERACTION_TYPE)\n        VALUES ((SELECT NVL(MAX(INTERACTION_ID), 0) + 1 FROM CUSTOMER_INTERACTIONS), \n                p_customer_id, \n                NULL, \n                TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), \n                'inactive_followup');\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        NULL; -- Or log the error appropriately\nEND;",
    "database_name": "customer_rmadt_130963",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_INTERACTIONS",
      "MARKETING_CAMPAIGNS",
      "ORDERS"
    ],
    "call_sqls": [
      "BEGIN\n  manage_customer_status(p_customer_id => 0, p_days_threshold => 30, p_start_date => '2023-01-01', p_end_date => '2023-01-31');\nEND;",
      "BEGIN\n  manage_customer_status(p_customer_id => 1, p_days_threshold => 60, p_start_date => '2023-02-01', p_end_date => '2023-02-28');\nEND;",
      "BEGIN\n  manage_customer_status(p_customer_id => 999, p_days_threshold => 10, p_start_date => '2023-03-01', p_end_date => '2023-03-31');\nEND;",
      "BEGIN\n  manage_customer_status(p_customer_id => 0, p_days_threshold => 5, p_start_date => '2022-01-01', p_end_date => '2022-12-31');\nEND;",
      "BEGIN\n  manage_customer_status(p_customer_id => 1, p_days_threshold => 90, p_start_date => '2023-01-01', p_end_date => '2023-12-31');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named manage_customer_status that takes a customer ID, a days threshold, and start and end dates as inputs. It first checks if the customer exists in the CUSTOMERS table. If the customer exists, it counts the number of orders for that customer in the ORDERS table within the specified date range and calculates the number of days since the customer's last activity date (or date added if last activity is null) from the CUSTOMERS table. If the customer has no orders in that range and the days since last activity exceeds the provided threshold, the procedure inserts a new record into the CUSTOMER_INTERACTIONS table with an interaction type of 'inactive_followup', generating a new INTERACTION_ID, using the current date, and associating it with the customer. Any execution errors should be suppressed.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called manage_customer_status that accepts a customer ID, a days threshold, and start and end dates, so that if the customer exists in the CUSTOMERS table, it counts their orders from the ORDERS table within the given date range and calculates the days since their last activity from the CUSTOMERS table, and if they have no orders and have been inactive beyond the threshold, it inserts an 'inactive_followup' record into the CUSTOMER_INTERACTIONS table while suppressing any execution errors?",
    "id": 92,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named manage_customer_status that takes four input parameters: a numeric p_customer_id, a numeric p_days_threshold, a string p_start_date, and a string p_end_date. The procedure first checks if a customer exists by selecting the count of rows from the CUSTOMERS table where the CUSTOMER_ID column equals the provided p_customer_id, storing the result in variable v_customer_exists. If this count is zero, the procedure exits immediately without performing further actions. If the customer exists, it proceeds to count the customer's orders within a specified date range by selecting the count of rows from the ORDERS table where the CUSTOMER_ID column equals p_customer_id and the ORDER_DATE column, converted from a string to a date using the format 'YYYY-MM-DD', falls between the p_start_date and p_end_date parameters, also converted to dates using the same format; this count is stored in variable v_order_count. Next, the procedure retrieves the customer's last activity date by selecting from the CUSTOMERS table the value of the LAST_ACTIVITY_DATE column for the given p_customer_id, using the NVL function to substitute the DATE_ADDED column's value if LAST_ACTIVITY_DATE is null, and stores this string result in variable v_last_activity. It then calculates the number of days since this last activity by subtracting the date value of v_last_activity, converted using the 'YYYY-MM-DD' format, from the current date truncated to midnight, storing the result in variable v_days_since_activity. The core logic executes a conditional check: if v_order_count is zero and v_days_since_activity is greater than the provided p_days_threshold, the procedure inserts a new record into the CUSTOMER_INTERACTIONS table. The inserted values are: for the INTERACTION_ID column, a subquery selects the maximum existing INTERACTION_ID from the CUSTOMER_INTERACTIONS table, uses NVL to default to 0 if the table is empty, and adds 1; for the CUSTOMER_ID column, the input parameter p_customer_id; for the CAMPAIGN_ID column, a null value; for the INTERACTION_DATE column, the current date converted to a string in 'YYYY-MM-DD' format; and for the INTERACTION_TYPE column, the literal string 'inactive_followup'. The procedure includes an exception handler that catches any exception with the WHEN OTHERS clause and performs no action, effectively suppressing any errors that occur during execution.",
    "original_summary": "Create a stored procedure named manage_customer_status that takes a customer ID, a days threshold, and start/end dates. If the customer exists, count their orders within the date range and calculate days since their last activity. If they have no orders and are inactive beyond the threshold, insert an 'inactive_followup' record into the CUSTOMER_INTERACTIONS table. Suppress any execution errors.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure called manage_customer_status that accepts a customer ID, a days threshold, and start and end dates, so that if the customer exists, it counts their orders within the date range and calculates the days since their last activity, and if they have no orders and have been inactive beyond the threshold, it inserts an 'inactive_followup' record into the CUSTOMER_INTERACTIONS table while suppressing any execution errors?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `insert_new_readme` that accepts five input parameters: `p_region_id` of type `NUMBER`, intended to represent the identifier of a geographical region; `p_indicator_id` of type `NUMBER`, intended to represent the identifier of a specific indicator; `p_file_path` of type `VARCHAR2`, intended to store the full path to a file; `p_file_size` of type `NUMBER`, intended to store the size of the file in bytes; and `p_readme_type` of type `VARCHAR2`, intended to categorize the type of the README file. The procedure declares a local variable `v_readme_id` of type `NUMBER` to temporarily hold the newly generated README identifier. The procedure's execution begins by performing a `SELECT` operation on the `README_FILES` table to retrieve the maximum value from the `README_ID` column. This maximum value is then incremented by 1, and the resulting value is assigned to the `v_readme_id` local variable. Following this, an `INSERT` operation is executed to add a new record into the `README_FILES` table. The `README_ID` column of this new record is populated with the value stored in `v_readme_id`. The `REGION_ID` column is populated with the value passed in the `p_region_id` parameter. The `INDICATOR_ID` column is populated with the value passed in the `p_indicator_id` parameter. The `FILE_PATH` column is populated with the value passed in the `p_file_path` parameter. The `FILE_SIZE` column is populated with the value passed in the `p_file_size` parameter. The `UPLOAD_DATE` column is populated with the current system date, which is obtained using the `CURRENT_DATE` function and then formatted into a string in 'YYYY-MM-DD' format using the `TO_CHAR` function. Finally, the `README_TYPE` column is populated with the value passed in the `p_readme_type` parameter.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_readme(p_region_id NUMBER, p_indicator_id NUMBER, p_file_path VARCHAR2, p_file_size NUMBER, p_readme_type VARCHAR2)\nIS\n    v_readme_id NUMBER;\nBEGIN\n    SELECT MAX(README_ID) + 1 INTO v_readme_id FROM README_FILES;\n\n    INSERT INTO README_FILES (README_ID, REGION_ID, INDICATOR_ID, FILE_PATH, FILE_SIZE, UPLOAD_DATE, README_TYPE)\n    VALUES (v_readme_id, p_region_id, p_indicator_id, p_file_path, p_file_size, TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD'), p_readme_type);\nEND;",
    "database_name": "economic_daar_473112",
    "tables": [
      "REGIONS",
      "ECONOMIC_INDICATORS",
      "DATA_POINTS",
      "DATA_FILES",
      "METADATA",
      "README_FILES",
      "DATA_VERSIONS"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_readme(p_region_id => 0, p_indicator_id => 0, p_file_path => 'readme/region0_gdp_description.txt', p_file_size => 0.2, p_readme_type => 'data description');\nEND;",
      "BEGIN\n  insert_new_readme(p_region_id => 1, p_indicator_id => 1, p_file_path => 'readme/region1_unemp_methodology.txt', p_file_size => 0.3, p_readme_type => 'methodology');\nEND;",
      "BEGIN\n  insert_new_readme(p_region_id => 0, p_indicator_id => 1, p_file_path => 'readme/region0_unemp_notes.txt', p_file_size => 0.15, p_readme_type => 'notes');\nEND;",
      "BEGIN\n  insert_new_readme(p_region_id => 1, p_indicator_id => 0, p_file_path => 'readme/region1_gdp_faq.txt', p_file_size => 0.25, p_readme_type => 'FAQ');\nEND;",
      "BEGIN\n  insert_new_readme(p_region_id => 0, p_indicator_id => 0, p_file_path => 'readme/region0_gdp_changelog.txt', p_file_size => 0.4, p_readme_type => 'changelog');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `insert_new_readme` that adds a new record to the README_FILES table. It takes inputs for a region ID, an indicator ID, a file path, a file size, and a readme type. The procedure generates a new README_ID by incrementing the highest existing README_ID from the table by one, sets the UPLOAD_DATE to the current date in 'YYYY-MM-DD' format, and inserts a new row with these values along with the provided parameters into the README_FILES table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called `insert_new_readme` that adds a new record to the README_FILES table. It should accept region ID, indicator ID, file path, file size, and readme type as inputs. The procedure must generate a new README_ID by incrementing the current maximum README_ID from the table by 1, then insert a new record using this generated ID, the provided inputs, and set the UPLOAD_DATE to today's date in the format 'YYYY-MM-DD'.",
    "id": 93,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `insert_new_readme` that accepts five input parameters: `p_region_id` of type `NUMBER`, intended to represent the identifier of a geographical region; `p_indicator_id` of type `NUMBER`, intended to represent the identifier of a specific indicator; `p_file_path` of type `VARCHAR2`, intended to store the full path to a file; `p_file_size` of type `NUMBER`, intended to store the size of the file in bytes; and `p_readme_type` of type `VARCHAR2`, intended to categorize the type of the README file. The procedure declares a local variable `v_readme_id` of type `NUMBER` to temporarily hold the newly generated README identifier. The procedure's execution begins by performing a `SELECT` operation on the `README_FILES` table to retrieve the maximum value from the `README_ID` column. This maximum value is then incremented by 1, and the resulting value is assigned to the `v_readme_id` local variable. Following this, an `INSERT` operation is executed to add a new record into the `README_FILES` table. The `README_ID` column of this new record is populated with the value stored in `v_readme_id`. The `REGION_ID` column is populated with the value passed in the `p_region_id` parameter. The `INDICATOR_ID` column is populated with the value passed in the `p_indicator_id` parameter. The `FILE_PATH` column is populated with the value passed in the `p_file_path` parameter. The `FILE_SIZE` column is populated with the value passed in the `p_file_size` parameter. The `UPLOAD_DATE` column is populated with the current system date, which is obtained using the `CURRENT_DATE` function and then formatted into a string in 'YYYY-MM-DD' format using the `TO_CHAR` function. Finally, the `README_TYPE` column is populated with the value passed in the `p_readme_type` parameter.",
    "original_summary": "Create a stored procedure named `insert_new_readme` that inserts a new record into the README_FILES table. It accepts parameters for region ID, indicator ID, file path, file size, and readme type. It generates a new README_ID by finding the current maximum ID and adding 1. The new record uses this ID, the provided parameters, and sets the UPLOAD_DATE to the current date in 'YYYY-MM-DD' format.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Write a stored procedure called `insert_new_readme` to add a new record to the README_FILES table. Take region ID, indicator ID, file path, file size, and readme type as parameters. Generate the new README_ID by taking the current maximum ID and incrementing it by 1. Insert the record using this new ID, the given parameters, and set the UPLOAD_DATE to today's date formatted as 'YYYY-MM-DD'."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named sp_add_variance_record that accepts four input parameters: a numeric parameter para_experiment_id, a numeric parameter para_explained_variance, a string parameter para_variance_name, and a string parameter para_variance_description. The procedure first declares a local numeric variable v_variance_id. It then executes a SELECT statement on the EXPLAINED_VARIANCE table to calculate a new identifier by finding the maximum existing value in the VARIANCE_ID column, using the NVL function to substitute a value of 0 if the maximum is null, and adding 1 to that result, storing the computed value into the local variable v_variance_id. Following this calculation, the procedure performs an INSERT operation into the EXPLAINED_VARIANCE table, specifying the columns VARIANCE_ID, EXPERIMENT_ID, EXPLAINED_VARIANCE, VARIANCE_NAME, and VARIANCE_DESCRIPTION, and populating them with the values from the local variable v_variance_id and the input parameters para_experiment_id, para_explained_variance, para_variance_name, and para_variance_description, respectively.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp_add_variance_record(para_experiment_id NUMBER, para_explained_variance NUMBER, para_variance_name VARCHAR2, para_variance_description VARCHAR2) IS\n    v_variance_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(VARIANCE_ID), 0) + 1 INTO v_variance_id FROM EXPLAINED_VARIANCE;\n    INSERT INTO EXPLAINED_VARIANCE (VARIANCE_ID, EXPERIMENT_ID, EXPLAINED_VARIANCE, VARIANCE_NAME, VARIANCE_DESCRIPTION)\n    VALUES (v_variance_id, para_experiment_id, para_explained_variance, para_variance_name, para_variance_description);\nEND;",
    "database_name": "reinforcement_letaa_93121",
    "tables": [
      "EXPERIMENTS",
      "EXPERIMENT_PARAMETERS",
      "ENTROPY_METRICS",
      "EXPLAINED_VARIANCE"
    ],
    "call_sqls": [
      "BEGIN\n  sp_add_variance_record(0, 0.85, 'Policy Variance', 'Variance explained by policy features');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_add_variance_record(1, 0.92, 'State Variance', 'Variance explained by state representation');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_add_variance_record(0, 0.78, 'Reward Variance', 'Variance explained by reward function');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_add_variance_record(2, 0.95, 'Feature Variance', 'Variance explained by selected features');\n  COMMIT;\nEND;",
      "BEGIN\n  sp_add_variance_record(1, 0.88, 'Action Variance', 'Variance explained by action space');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named sp_add_variance_record that inserts a new record into the EXPLAINED_VARIANCE table, taking an experiment ID, an explained variance value, a variance name, and a description as input. The procedure must generate a new unique VARIANCE_ID by incrementing the highest existing VARIANCE_ID from the table (starting from 1 if the table is empty) and then insert all provided values along with this new ID into the EXPLAINED_VARIANCE table.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp_add_variance_record that inserts a new record into the EXPLAINED_VARIANCE table, taking an experiment ID, an explained variance value, a variance name, and a description, and generates a new VARIANCE_ID by incrementing the current maximum value in the table.",
    "id": 94,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named sp_add_variance_record that accepts four input parameters: p_experiment_id of type NUMBER used to specify an experiment identifier, p_explained_variance of type NUMBER used to specify a numeric variance value, p_variance_name of type VARCHAR2 used to specify a name for the variance, and p_description of type VARCHAR2 used to provide an optional descriptive text. The procedure is designed to insert a new row into the EXPLAINED_VARIANCE table. It first declares a local variable v_new_variance_id of type NUMBER to hold the generated primary key value for the new record. The procedure then executes a single SQL SELECT statement that queries the EXPLAINED_VARIANCE table to calculate the next available VARIANCE_ID. This is done by computing the maximum value of the existing VARIANCE_ID column in the table using the MAX function, then adding 1 to that maximum value. If the table is empty, the MAX function returns NULL, so the NVL function is used to handle this case by substituting NULL with 0, ensuring the generated ID starts at 1. The computed value is selected into the local variable v_new_variance_id. Following this, the procedure executes an SQL INSERT statement. It inserts a new row into the EXPLAINED_VARIANCE table, specifying values for all columns: the VARIANCE_ID column is set to the value stored in v_new_variance_id, the EXPERIMENT_ID column is set to the value provided in the p_experiment_id input parameter, the EXPLAINED_VARIANCE column is set to the value provided in the p_explained_variance input parameter, the VARIANCE_NAME column is set to the value provided in the p_variance_name input parameter, and the DESCRIPTION column is set to the value provided in the p_description input parameter. The procedure does not return any value; its sole purpose is to perform the insertion operation.",
    "original_summary": "Create a stored procedure named sp_add_variance_record that inserts a new record into the EXPLAINED_VARIANCE table. It accepts an experiment ID, explained variance value, variance name, and description. The procedure generates a new VARIANCE_ID by incrementing the current maximum value in the table and inserts all values.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure called sp_add_variance_record to insert a new record into the EXPLAINED_VARIANCE table, which takes an experiment ID, an explained variance value, a variance name, and a description, and generates a new VARIANCE_ID by incrementing the current maximum value in the table?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named proc_transform_dataset_details that accepts four input parameters: p_source_dataset of type VARCHAR2 to specify the source dataset identifier, p_target_dataset of type VARCHAR2 to specify the target dataset identifier, p_tissue_filter of type VARCHAR2 to filter on tissue ontology terms, and p_donor_filter of type VARCHAR2 to filter on donor identifiers. The procedure begins by declaring a local variable v_new_detail_id of type NUMBER. It then queries the dataset_details table to find the current maximum value in the detail_id column, uses the NVL function to substitute a value of 0 if the maximum is null, adds 1 to this value, and stores the result into v_new_detail_id. Following this, the procedure performs an INSERT operation into the dataset_details table, populating the columns detail_id, dataset_id, tissue_ontology_term_id, donor_id, cell_type_ontology_id, cell_count, cell_percentage, and cell_distribution. The data for this insert is selected from the same dataset_details table, specifically from rows where the dataset_id column matches the p_source_dataset parameter, the tissue_ontology_term_id column contains the string from the p_tissue_filter parameter (using the LIKE operator with wildcards '%' on both sides), and the donor_id column contains the string from the p_donor_filter parameter (also using the LIKE operator with wildcards). For each selected row, the inserted values are calculated as follows: the detail_id is set to v_new_detail_id plus the ROWNUM minus 1, the dataset_id is set to the p_target_dataset parameter value, the tissue_ontology_term_id and donor_id are copied directly, the cell_type_ontology_id is copied directly, the cell_count is multiplied by 2, the cell_percentage is divided by 2, and the cell_distribution is truncated to its first 50 bytes using the SUBSTRB function.",
    "plsql": "CREATE OR REPLACE PROCEDURE proc_transform_dataset_details(\n    p_source_dataset IN VARCHAR2,\n    p_target_dataset IN VARCHAR2,\n    p_tissue_filter IN VARCHAR2,\n    p_donor_filter IN VARCHAR2\n)\nIS\n    v_new_detail_id NUMBER;\nBEGIN\n    SELECT NVL(MAX(detail_id), 0) + 1 INTO v_new_detail_id FROM dataset_details;\n    \n    INSERT INTO dataset_details (detail_id, dataset_id, tissue_ontology_term_id, donor_id, cell_type_ontology_id, cell_count, cell_percentage, cell_distribution)\n    SELECT v_new_detail_id + ROWNUM - 1, p_target_dataset, tissue_ontology_term_id, donor_id, cell_type_ontology_id,\n           cell_count * 2, cell_percentage / 2, SUBSTRB(cell_distribution, 1, 50)\n    FROM dataset_details\n    WHERE dataset_id = p_source_dataset\n    AND tissue_ontology_term_id LIKE '%' || p_tissue_filter || '%'\n    AND donor_id LIKE '%' || p_donor_filter || '%';\nEND;",
    "database_name": "biomedical_rad_management",
    "tables": [
      "DATASETS",
      "DATASET_DETAILS",
      "CELL_TYPES",
      "TISSUE_TYPES",
      "DONORS"
    ],
    "call_sqls": [
      "BEGIN\n  proc_transform_dataset_details(p_source_dataset => '0', p_target_dataset => '1', p_tissue_filter => '0', p_donor_filter => '0');\nEND;",
      "BEGIN\n  proc_transform_dataset_details(p_source_dataset => '1', p_target_dataset => '0', p_tissue_filter => '1', p_donor_filter => '1');\nEND;",
      "BEGIN\n  proc_transform_dataset_details(p_source_dataset => '0', p_target_dataset => '1', p_tissue_filter => '', p_donor_filter => '0');\nEND;",
      "BEGIN\n  proc_transform_dataset_details(p_source_dataset => '1', p_target_dataset => '0', p_tissue_filter => '1', p_donor_filter => '');\nEND;",
      "BEGIN\n  proc_transform_dataset_details(p_source_dataset => '0', p_target_dataset => '1', p_tissue_filter => '', p_donor_filter => '');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named proc_transform_dataset_details that copies and transforms data from a source dataset to a target dataset in the DATASET_DETAILS table. It takes a source dataset ID, a target dataset ID, a tissue filter, and a donor filter as input. The procedure retrieves all rows from DATASET_DETAILS where the dataset_id matches the source dataset, the tissue_ontology_term_id contains the tissue filter, and the donor_id contains the donor filter. For each matching row, it inserts a new record into DATASET_DETAILS with a newly generated detail_id, the target dataset ID, and transformed values: the cell_count is doubled, the cell_percentage is halved, and the cell_distribution is truncated to 50 bytes.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called proc_transform_dataset_details that copies data from a source dataset to a target dataset, applying specific transformations. It requires the IDs for the source and target datasets, along with optional filters for tissue and donor that support wildcard matching. The procedure generates new detail IDs, selects rows from the source dataset in the dataset_details table that match the filters, and inserts them into the same table for the target dataset. During the copy, it doubles the cell_count, halves the cell_percentage, and truncates the cell_distribution to 50 bytes.",
    "id": 95,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named proc_transform_dataset_details that accepts four input parameters: p_source_dataset of type VARCHAR2 to specify the source dataset identifier, p_target_dataset of type VARCHAR2 to specify the target dataset identifier, p_tissue_filter of type VARCHAR2 to filter on tissue ontology terms, and p_donor_filter of type VARCHAR2 to filter on donor identifiers. The procedure begins by declaring a local variable v_new_detail_id of type NUMBER. It then queries the dataset_details table to find the current maximum value in the detail_id column, uses the NVL function to substitute a value of 0 if the maximum is null, adds 1 to this value, and stores the result into v_new_detail_id. Following this, the procedure performs an INSERT operation into the dataset_details table, populating the columns detail_id, dataset_id, tissue_ontology_term_id, donor_id, cell_type_ontology_id, cell_count, cell_percentage, and cell_distribution. The data for this insert is selected from the same dataset_details table, specifically from rows where the dataset_id column matches the p_source_dataset parameter, the tissue_ontology_term_id column contains the string from the p_tissue_filter parameter (using the LIKE operator with wildcards '%' on both sides), and the donor_id column contains the string from the p_donor_filter parameter (also using the LIKE operator with wildcards). For each selected row, the inserted values are calculated as follows: the detail_id is set to v_new_detail_id plus the ROWNUM minus 1, the dataset_id is set to the p_target_dataset parameter value, the tissue_ontology_term_id and donor_id are copied directly, the cell_type_ontology_id is copied directly, the cell_count is multiplied by 2, the cell_percentage is divided by 2, and the cell_distribution is truncated to its first 50 bytes using the SUBSTRB function.",
    "original_summary": "Create a stored procedure named proc_transform_dataset_details that copies and transforms data between datasets. It takes source and target dataset IDs, a tissue filter, and a donor filter as input. The procedure generates new detail IDs, selects rows from the source dataset where the tissue and donor IDs match the filters (using LIKE with wildcards), and inserts them into the target dataset. During insertion, it transforms the data: cell_count is doubled, cell_percentage is halved, and cell_distribution is truncated to 50 bytes.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Alright, so we need a stored procedure called proc_transform_dataset_details. Basically, it's gonna grab data from one dataset and plop it into another, but with some tweaks. You gotta give it the IDs for the source and target datasets, plus a couple of filters for tissue and donor (you can use wildcards with LIKE). It'll whip up new detail IDs, pick the rows from the source that match your filters, and then insert 'em into the target. Oh, and while it's copying stuff over, it'll change a few things: it doubles the cell_count, cuts the cell_percentage in half, and chops off the cell_distribution so it's only 50 bytes long."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure that takes a parameter para_date of type VARCHAR2 and updates the DIABETES_RISK_SCORES table by increasing the RISK_SCORE column by 10% for all rows where the ASSESSMENT_DATE column matches the provided para_date value.",
    "plsql": "CREATE OR REPLACE PROCEDURE update_risk_scores(para_date VARCHAR2) IS\nBEGIN\n  UPDATE DIABETES_RISK_SCORES\n  SET RISK_SCORE = RISK_SCORE * 1.1\n  WHERE ASSESSMENT_DATE = para_date;\nEND;",
    "database_name": "healthcare_dmadr_assessme",
    "tables": [
      "DIABETES_RISK_SCORES",
      "HEALTH_METRICS",
      "PATIENTS",
      "STUDY_PARTICIPANTS"
    ],
    "call_sqls": [
      "BEGIN\n  update_risk_scores('2023-01-15');\nEND;",
      "BEGIN\n  update_risk_scores('2023-01-16');\nEND;",
      "BEGIN\n  update_risk_scores('2023-02-01');\nEND;",
      "BEGIN\n  update_risk_scores('2023-03-10');\nEND;",
      "BEGIN\n  update_risk_scores('2023-04-20');\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named update_risk_scores that accepts a date as input and updates the DIABETES_RISK_SCORES table by increasing the RISK_SCORE by 10 percent for all records where the ASSESSMENT_DATE matches the provided date.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called update_risk_scores that takes a date as input and updates the DIABETES_RISK_SCORES table by increasing the RISK_SCORE by 10 percent for every record where the ASSESSMENT_DATE matches the provided date.",
    "id": 96,
    "generated_ir": "Write an Oracle PL/SQL stored procedure that takes a parameter para_date of type VARCHAR2 and updates the DIABETES_RISK_SCORES table by increasing the RISK_SCORE column by 10% for all rows where the ASSESSMENT_DATE column matches the provided para_date value.",
    "original_summary": "Create a stored procedure that accepts a date. It updates the DIABETES_RISK_SCORES table by increasing the RISK_SCORE by 10% for all rows where the ASSESSMENT_DATE matches the provided date.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "How can I create a stored procedure that takes a date as input and updates the DIABETES_RISK_SCORES table to increase the RISK_SCORE by 10 percent for every record where the ASSESSMENT_DATE equals the provided date?"
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named insert_new_user that accepts three input parameters: p_name, p_email, and p_role, all of type VARCHAR2, representing the name, email, and role of a new user, respectively. The procedure begins by declaring a local variable v_new_user_id of type NUMBER, which is used to store the new user ID. It then executes a SELECT statement to determine the maximum existing USER_ID in the USERS table, using the NVL function to handle cases where no users exist by returning 0, and adds 1 to this maximum value to generate a new unique USER_ID, storing the result in v_new_user_id. Next, the procedure performs an INSERT operation into the USERS table, populating several columns with specific values: USER_ID is set to v_new_user_id, NAME is set to p_name, EMAIL is set to p_email, ROLE is set to p_role, CREATED_AT and UPDATED_AT are both set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function, STATUS is set to 'active', PASSWORD_HASH is set to 'default_hash', LAST_LOGIN_AT is set to the current system date and time formatted similarly, DEPARTMENT is set to 'General', and PERMISSIONS is set to '{can_view_data: true}'. The procedure concludes by committing the transaction to save the changes made to the USERS table.",
    "plsql": "CREATE OR REPLACE PROCEDURE insert_new_user(p_name VARCHAR2, p_email VARCHAR2, p_role VARCHAR2) IS\n  v_new_user_id NUMBER;\nBEGIN\n  -- Generate new USER_ID by finding max + 1\n  SELECT NVL(MAX(USER_ID), 0) + 1 INTO v_new_user_id FROM USERS;\n  \n  -- Insert new user with all required fields\n  INSERT INTO USERS (\n    USER_ID, \n    NAME, \n    EMAIL, \n    ROLE, \n    CREATED_AT, \n    UPDATED_AT, \n    STATUS,\n    PASSWORD_HASH,\n    LAST_LOGIN_AT,\n    DEPARTMENT,\n    PERMISSIONS\n  ) VALUES (\n    v_new_user_id, \n    p_name, \n    p_email, \n    p_role, \n    TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), \n    TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), \n    'active',\n    'default_hash',\n    TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'),\n    'General',\n    '{can_view_data: true}'\n  );\n  \n  COMMIT;\nEND;",
    "database_name": "healthcare_dma_analytics",
    "tables": [
      "DATAMARTS",
      "DISPENSES",
      "PATIENTS",
      "QUERIES",
      "RESPONSES",
      "TREATMENTS",
      "USERS"
    ],
    "call_sqls": [
      "BEGIN\n  insert_new_user('John Doe', 'john.doe@example.com', 'researcher');\n  commit;\nEND;",
      "BEGIN\n  insert_new_user('Jane Smith', 'jane.smith@example.com', 'healthcare professional');\n  commit;\nEND;",
      "BEGIN\n  insert_new_user('Peter Jones', 'peter.jones@example.com', 'admin');\n  commit;\nEND;",
      "BEGIN\n  insert_new_user('Sarah Brown', 'sarah.brown@example.com', 'data analyst');\n  commit;\nEND;",
      "BEGIN\n  insert_new_user('Michael Green', 'michael.green@example.com', 'manager');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named insert_new_user that accepts a name, email, and role, generates a new USER_ID by incrementing the maximum existing USER_ID from the USERS table, inserts a new record into the USERS table with the provided name, email, and role, sets the STATUS to 'active', the PASSWORD_HASH to 'default_hash', the DEPARTMENT to 'General', the PERMISSIONS to '{can_view_data: true}', and sets CREATED_AT, UPDATED_AT, and LAST_LOGIN_AT to the current date and time, then commits the transaction.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called insert_new_user that takes a name, email, and role as inputs, generates a new USER_ID by incrementing the maximum current USER_ID from the USERS table, inserts a new record into the USERS table with the provided inputs and the generated ID, sets default values for STATUS as 'active', CREATED_AT, UPDATED_AT, and LAST_LOGIN_AT to the current system time, PASSWORD_HASH to 'default_hash', DEPARTMENT to 'General', and PERMISSIONS to '{can_view_data: true}', and then commits the transaction.",
    "id": 97,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named insert_new_user that accepts three input parameters: p_name, p_email, and p_role, all of type VARCHAR2, representing the name, email, and role of a new user, respectively. The procedure begins by declaring a local variable v_new_user_id of type NUMBER, which is used to store the new user ID. It then executes a SELECT statement to determine the maximum existing USER_ID in the USERS table, using the NVL function to handle cases where no users exist by returning 0, and adds 1 to this maximum value to generate a new unique USER_ID, storing the result in v_new_user_id. Next, the procedure performs an INSERT operation into the USERS table, populating several columns with specific values: USER_ID is set to v_new_user_id, NAME is set to p_name, EMAIL is set to p_email, ROLE is set to p_role, CREATED_AT and UPDATED_AT are both set to the current system date and time formatted as 'YYYY-MM-DD HH24:MI:SS' using the TO_CHAR function, STATUS is set to 'active', PASSWORD_HASH is set to 'default_hash', LAST_LOGIN_AT is set to the current system date and time formatted similarly, DEPARTMENT is set to 'General', and PERMISSIONS is set to '{can_view_data: true}'. The procedure concludes by committing the transaction to save the changes made to the USERS table.",
    "original_summary": "Create a stored procedure named insert_new_user that accepts name, email, and role parameters. It generates a new user ID by incrementing the maximum existing ID, inserts a new user record with the provided data, sets default values for status, timestamps, password hash, department, and permissions, and commits the transaction.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure insert_new_user with name, email, role params. Generate new ID by incrementing max current ID, insert user, set defaults for status, timestamps, password, department, permissions, and commit."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts three input parameters: `p_city_name` of type `VARCHAR2` representing the name of a city, `p_min_population` of type `NUMBER` representing a minimum population threshold, and `p_state` of type `VARCHAR2` representing the state where the city is located. The procedure first declares two local variables: `v_city_id` of type `NUMBER` to store a city identifier, and `v_avg_traffic` of type `NUMBER` to store an average traffic volume. It then performs a `SELECT` operation to retrieve the `CITY_ID` from the `CITIES` table, storing the result into the `v_city_id` variable. This selection is conditioned on `CITY_NAME` matching the input parameter `p_city_name` and `STATE` matching the input parameter `p_state`. Subsequently, another `SELECT` operation is executed to calculate the average of the `AVERAGE_TRAFFIC_VOLUME` column from the `CITIES` table, storing this average into the `v_avg_traffic` variable. This average is calculated for all rows where the `POPULATION` column is greater than the input parameter `p_min_population`. Following these selections, the procedure performs an `INSERT` operation into the `TRAFFIC_INCIDENTS` table. A new row is inserted with the following values: `INCIDENT_ID` is set to `999999`, `CRASH_NUMBER` is set to `9999999`, `CRASH_DATE` is set to the current date converted to a character string using `TO_CHAR(CURRENT_DATE)`, `CRASH_TIME` is set to the current timestamp's hour, minute, and second components converted to a character string in 'HH24:MI:SS' format using `TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI:SS')`, `CITY_TOWN` is set to the value of `v_city_id` converted to a character string using `TO_CHAR(v_city_id)`, `CRASH_SEVERITY` is set to `'1'`, `ROADWAY` is set to `'1'`, `NEAR_INTERSECTION` is set to `'None'`, `LANDMARK` is set to `'None'`, `POLICE_AGENCY` is set to `'0'`, `WEATHER_CONDITIONS` is set to `'Clear'`, `ROAD_CONDITIONS` is set to `'Dry'`, `LIGHT_CONDITIONS` is set to `'Daylight'`, `VEHICLE_COUNT` is set to `1`, `INJURY_COUNT` is set to `0`, `FATALITY_COUNT` is set to `0`, `LATITUDE` is set to `42.0`, `LONGITUDE` is set to `-71.0`, `SPEED_LIMIT` is set to `30`, `ALCOHOL_INVOLVEMENT` is set to `0`, `DRUG_INVOLVEMENT` is set to `0`, `REPORTED_BY` is set to `'System'`, `INCIDENT_STATUS` is set to `'Open'`, and `INVESTIGATION_NOTES` is set to `'Generated by procedure'`. Finally, the procedure executes a `DELETE` operation on the `TRAFFIC_INCIDENTS` table. Rows are deleted where the `CITY_TOWN` column, converted to a character string, matches the value of `v_city_id` (also converted to a character string using `TO_CHAR(v_city_id)`), and `CRASH_SEVERITY` is equal to `'1'`, and the year extracted from the `CRASH_DATE` column (after converting `CRASH_DATE` to a date type using `TO_DATE` with an assumed 'YYYY-MM-DD' format) is less than the current year minus one.",
    "plsql": "CREATE OR REPLACE PROCEDURE sp(p_city_name VARCHAR2, p_min_population NUMBER, p_state VARCHAR2) IS\n  v_city_id NUMBER;\n  v_avg_traffic NUMBER;\nBEGIN\n  SELECT CITY_ID INTO v_city_id FROM CITIES WHERE CITY_NAME = p_city_name AND STATE = p_state;\n  SELECT AVG(AVERAGE_TRAFFIC_VOLUME) INTO v_avg_traffic FROM CITIES WHERE POPULATION > p_min_population;\n  INSERT INTO TRAFFIC_INCIDENTS (INCIDENT_ID, CRASH_NUMBER, CRASH_DATE, CRASH_TIME, CITY_TOWN, CRASH_SEVERITY, ROADWAY, NEAR_INTERSECTION, LANDMARK, POLICE_AGENCY, WEATHER_CONDITIONS, ROAD_CONDITIONS, LIGHT_CONDITIONS, VEHICLE_COUNT, INJURY_COUNT, FATALITY_COUNT, LATITUDE, LONGITUDE, SPEED_LIMIT, ALCOHOL_INVOLVEMENT, DRUG_INVOLVEMENT, REPORTED_BY, INCIDENT_STATUS, INVESTIGATION_NOTES)\n  VALUES (999999, 9999999, TO_CHAR(CURRENT_DATE), TO_CHAR(CURRENT_TIMESTAMP, 'HH24:MI:SS'), TO_CHAR(v_city_id), '1', '1', 'None', 'None', '0', 'Clear', 'Dry', 'Daylight', 1, 0, 0, 42.0, -71.0, 30, 0, 0, 'System', 'Open', 'Generated by procedure');\n  DELETE FROM TRAFFIC_INCIDENTS WHERE CITY_TOWN = TO_CHAR(v_city_id) AND CRASH_SEVERITY = '1' AND EXTRACT(YEAR FROM TO_DATE(CRASH_DATE, 'YYYY-MM-DD')) < EXTRACT(YEAR FROM CURRENT_DATE) - 1;\nEND;",
    "database_name": "traffic_iraa_624460",
    "tables": [
      "CITIES",
      "POLICE_AGENCIES",
      "ROADWAYS",
      "SEVERITY_LEVELS",
      "TRAFFIC_INCIDENTS"
    ],
    "call_sqls": [
      "BEGIN\n  sp('WORCESTER', 100000, 'MA');\n  COMMIT;\nEND;",
      "BEGIN\n  sp('BOSTON', 50000, 'MA');\n  COMMIT;\nEND;",
      "BEGIN\n  sp('WORCESTER', 200000, 'MA');\n  COMMIT;\nEND;",
      "BEGIN\n  sp('BOSTON', 0, 'MA');\n  COMMIT;\nEND;",
      "BEGIN\n  sp('WORCESTER', 184507, 'MA');\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named `sp` that accepts a city name, a minimum population threshold, and a state. It retrieves the CITY_ID from the CITIES table for the specified city name and state, calculates the average AVERAGE_TRAFFIC_VOLUME from the CITIES table for all cities with POPULATION above the given threshold, inserts a new record into the TRAFFIC_INCIDENTS table with predefined values (including the retrieved CITY_ID and the current date/time), and deletes old incidents from TRAFFIC_INCIDENTS for that city where CRASH_SEVERITY is '1' and the crash year is older than last year.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called sp that takes a city name, a minimum population number, and a state. It should retrieve the CITY_ID from the CITIES table for that city and state, calculate the average AVERAGE_TRAFFIC_VOLUME from CITIES where POPULATION exceeds the provided minimum, insert a new record into TRAFFIC_INCIDENTS with predefined details (using that CITY_ID and today's date), and delete from TRAFFIC_INCIDENTS any records for that city with CRASH_SEVERITY '1' that occurred before the previous year.",
    "id": 98,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named `sp` that accepts three input parameters: `p_city_name` of type `VARCHAR2`, representing the name of a city; `p_min_population` of type `NUMBER`, representing a minimum population threshold; and `p_state` of type `VARCHAR2`, representing the state. The procedure declares three local variables: `v_city_id` of type `NUMBER`, to store the retrieved city identifier; `v_avg_traffic_volume` of type `NUMBER`, to store the calculated average traffic volume; and `v_today_date` of type `DATE`, initialized to the current system date using `SYSDATE`.\n\nThe procedure's execution begins by retrieving the `CITY_ID` from the `CITIES` table. It performs a `SELECT` statement that queries the `CITY_ID` column from the `CITIES` table where the `CITY_NAME` column matches the input parameter `p_city_name` and the `STATE` column matches the input parameter `p_state`. The result of this query is stored into the local variable `v_city_id`.\n\nNext, the procedure calculates the average traffic volume. It performs a `SELECT` statement with the `AVG` aggregation function on the `AVERAGE_TRAFFIC_VOLUME` column from the `CITIES` table. This calculation includes only those rows where the `POPULATION` column value is greater than the input parameter `p_min_population`. The result of this average calculation is stored into the local variable `v_avg_traffic_volume`.\n\nFollowing this, the procedure inserts a new record into the `TRAFFIC_INCIDENTS` table. The `INSERT` statement uses the following predefined values: for the `CITY_ID` column, it uses the value stored in `v_city_id`; for the `INCIDENT_DATE` column, it uses the value stored in `v_today_date`; for the `CRASH_SEVERITY` column, it uses the literal string `'2'`; for the `DESCRIPTION` column, it uses the literal string `'Routine check'`; and for the `TRAFFIC_VOLUME` column, it uses the value stored in `v_avg_traffic_volume`. All other columns in the `TRAFFIC_INCIDENTS` table for this new record will be populated with their default values or left as `NULL` if not specified.\n\nFinally, the procedure performs a deletion operation on the `TRAFFIC_INCIDENTS` table. It executes a `DELETE` statement that removes all records where the `CITY_ID` column matches the value in `v_city_id`, the `CRASH_SEVERITY` column equals the literal string `'1'`, and the `INCIDENT_DATE` column is less than the first day of the previous calendar year. This date condition is implemented by checking if `INCIDENT_DATE` is less than `TRUNC(SYSDATE, 'YYYY') - INTERVAL '1' YEAR`, which calculates January 1st of the year before the current year.\n\nThe procedure includes exception handling to manage any errors that occur during database operations. If any exception is raised, it is caught by a `WHEN OTHERS` exception handler, which uses `DBMS_OUTPUT.PUT_LINE` to output an error message concatenating the literal string `'Error: '` with the SQL error message obtained from `SQLERRM`. The procedure does not have an explicit return value as it is a stored procedure that performs data manipulation and outputs potential error messages.",
    "original_summary": "Create a stored procedure named `sp` that accepts city name, minimum population, and state parameters. It retrieves a city ID based on city name and state, calculates the average traffic volume for cities above the population threshold, inserts a new traffic incident record with predefined values (including the city ID and current date/time), and deletes old incidents for that city where severity is '1' and the crash year is older than last year.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called `sp` that takes a city, a not-too-small population number, and a state. It should find the ID for that city in that state, work out the average traffic for places with a decently large population, add a new traffic incident with some standard details (using that city ID and today's date), and clean up some old minor incidents from before last year for that city."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named ManagePosition that accepts three parameters: p_position_id of type VARCHAR2, p_position_name of type VARCHAR2, and p_description of type VARCHAR2. The procedure first declares a local variable v_exists of type NUMBER to store the count of records. It then performs a SELECT operation to count the number of rows in the POSITIONS table where the POSITION_ID column matches the value of the p_position_id parameter, storing the result in v_exists. The procedure uses an IF-ELSIF-ELSE conditional structure to determine the next steps based on the value of v_exists. If v_exists equals 0, indicating no existing record with the specified POSITION_ID, it executes an INSERT operation to add a new row to the POSITIONS table with POSITION_ID, POSITION_NAME, and DESCRIPTION columns set to the values of p_position_id, p_position_name, and p_description, respectively. If v_exists equals 1, indicating exactly one existing record with the specified POSITION_ID, it performs an UPDATE operation on the POSITIONS table, setting the POSITION_NAME and DESCRIPTION columns to the values of p_position_name and p_description for the row where POSITION_ID matches p_position_id. If v_exists is greater than 1, indicating multiple records with the specified POSITION_ID, it executes a DELETE operation to remove all rows from the POSITIONS table where POSITION_ID matches p_position_id.",
    "plsql": "CREATE OR REPLACE PROCEDURE ManagePosition(\n    p_position_id VARCHAR2,\n    p_position_name VARCHAR2,\n    p_description VARCHAR2\n) AS\n    v_exists NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_exists\n    FROM POSITIONS\n    WHERE POSITION_ID = p_position_id;\n\n    IF v_exists = 0 THEN\n        INSERT INTO POSITIONS (POSITION_ID, POSITION_NAME, DESCRIPTION)\n        VALUES (p_position_id, p_position_name, p_description);\n    ELSIF v_exists = 1 THEN\n        UPDATE POSITIONS\n        SET POSITION_NAME = p_position_name, DESCRIPTION = p_description\n        WHERE POSITION_ID = p_position_id;\n    ELSE\n        DELETE FROM POSITIONS\n        WHERE POSITION_ID = p_position_id;\n    END IF;\nEND;",
    "database_name": "demographic_ahs_652164",
    "tables": [
      "DATASETS",
      "DATASET_VERSIONS",
      "INDICATORS",
      "POSITIONS",
      "SEX",
      "UNITS"
    ],
    "call_sqls": [
      "BEGIN\n  ManagePosition('P001', 'Manager', 'Responsible for managing team');\n  commit;\nEND;",
      "BEGIN\n  ManagePosition('P002', 'Developer', 'Responsible for software development');\n  commit;\nEND;",
      "BEGIN\n  ManagePosition('P003', 'Analyst', 'Responsible for data analysis');\n  commit;\nEND;",
      "BEGIN\n  ManagePosition('P004', 'Tester', 'Responsible for testing software');\n  commit;\nEND;",
      "BEGIN\n  ManagePosition('P005', 'Designer', 'Responsible for designing interfaces');\n  commit;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named ManagePosition that, for a given position_id, checks the POSITIONS table and either inserts a new record with the provided position_id, position_name, and description if none exists, updates the existing record's position_name and description if exactly one exists, or deletes all records with that position_id if multiple exist.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called ManagePosition that, based on the existence of a given POSITION_ID in the POSITIONS table, either inserts a new record with the provided POSITION_ID, POSITION_NAME, and DESCRIPTION if it does not exist, updates the existing record's POSITION_NAME and DESCRIPTION if exactly one exists, or deletes the record if more than one exists.",
    "id": 99,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named ManagePosition that accepts three parameters: p_position_id of type VARCHAR2, p_position_name of type VARCHAR2, and p_description of type VARCHAR2. The procedure first declares a local variable v_exists of type NUMBER to store the count of records. It then performs a SELECT operation to count the number of rows in the POSITIONS table where the POSITION_ID column matches the value of the p_position_id parameter, storing the result in v_exists. The procedure uses an IF-ELSIF-ELSE conditional structure to determine the next steps based on the value of v_exists. If v_exists equals 0, indicating no existing record with the specified POSITION_ID, it executes an INSERT operation to add a new row to the POSITIONS table with POSITION_ID, POSITION_NAME, and DESCRIPTION columns set to the values of p_position_id, p_position_name, and p_description, respectively. If v_exists equals 1, indicating exactly one existing record with the specified POSITION_ID, it performs an UPDATE operation on the POSITIONS table, setting the POSITION_NAME and DESCRIPTION columns to the values of p_position_name and p_description for the row where POSITION_ID matches p_position_id. If v_exists is greater than 1, indicating multiple records with the specified POSITION_ID, it executes a DELETE operation to remove all rows from the POSITIONS table where POSITION_ID matches p_position_id.",
    "original_summary": "Create a stored procedure named ManagePosition that manages records in a POSITIONS table. Using a provided position_id, check for existing records. If none exist, insert a new record with the provided id, name, and description. If one exists, update the name and description for that record. If multiple exist, delete all records with that position_id.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Create procedure ManagePosition to insert, update, or delete in POSITIONS based on position_id count."
  },
  {
    "ir": "Write an Oracle PL/SQL stored procedure named `UpdateExperimentDescription` that is designed to modify the description of a specific experiment record within the `EXPERIMENTS` table. This procedure accepts three parameters: `p_experiment_id`, an `IN` parameter of data type `NUMBER`, which serves as the unique identifier for the experiment whose description is to be updated; `p_new_description`, an `IN` parameter of data type `VARCHAR2`, which provides the new description text to be assigned to the identified experiment; and `p_updated`, an `OUT` parameter of data type `NUMBER`, which will store a value indicating whether the update operation was successful. The procedure's execution block begins by performing an `UPDATE` operation on the `EXPERIMENTS` table. Within this `UPDATE` statement, the `DESCRIPTION` column of the `EXPERIMENTS` table is set to the value of `p_new_description` after applying the `RTRIM` function. The `RTRIM` function removes any trailing whitespace characters from the `p_new_description` string before it is assigned to the `DESCRIPTION` column. This update is conditionally applied only to the row(s) in the `EXPERIMENTS` table where the value in the `EXPERIMENT_ID` column precisely matches the value provided by the `p_experiment_id` input parameter. Following the `UPDATE` operation, the `RETURNING` clause is used to capture a value. Specifically, the literal numeric value `1` is returned and immediately assigned to the `p_updated` `OUT` parameter. This indicates that if the `UPDATE` statement successfully modified at least one row matching the `WHERE` clause condition, the `p_updated` parameter will contain the value `1`.",
    "plsql": "CREATE OR REPLACE PROCEDURE UpdateExperimentDescription(\n  p_experiment_id IN NUMBER,\n  p_new_description IN VARCHAR2,\n  p_updated OUT NUMBER\n)\nAS\nBEGIN\n  UPDATE EXPERIMENTS\n  SET DESCRIPTION = RTRIM(p_new_description)\n  WHERE EXPERIMENT_ID = p_experiment_id\n  RETURNING 1 INTO p_updated;\nEND;",
    "database_name": "psychological_edm_639848",
    "tables": [
      "BLOCKS",
      "EXPERIMENTS"
    ],
    "call_sqls": [
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateExperimentDescription(0, 'Updated description for experiment 0', v_updated);\n  COMMIT;\nEND;",
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateExperimentDescription(1, 'Updated description for experiment 1', v_updated);\n  COMMIT;\nEND;",
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateExperimentDescription(0, 'New insights on cognitive biases', v_updated);\n  COMMIT;\nEND;",
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateExperimentDescription(1, 'Further analysis on stimuli impact', v_updated);\n  COMMIT;\nEND;",
      "DECLARE\n  v_updated NUMBER;\nBEGIN\n  UpdateExperimentDescription(0, 'Revised study on cognitive biases', v_updated);\n  COMMIT;\nEND;"
    ],
    "summary": "Write a Oracle PL/SQL stored procedure named UpdateExperimentDescription that updates the DESCRIPTION for a specified EXPERIMENT_ID in the EXPERIMENTS table with a new description, automatically removing any trailing spaces from the new description, and returns a value of 1 in an output parameter to indicate that a row was successfully updated.",
    "natural_language": "Write a Oracle PL/SQL stored procedure called UpdateExperimentDescription that updates the DESCRIPTION in the EXPERIMENTS table for a specified EXPERIMENT_ID, trimming any trailing spaces from the new description, and returns a value of 1 in an output parameter if a row was successfully updated.",
    "id": 100,
    "generated_ir": "Write an Oracle PL/SQL stored procedure named UpdateExperimentDescription that takes two parameters: an input parameter p_experiment_id of type NUMBER to specify the experiment ID, and an output parameter p_updated_flag of type NUMBER to indicate whether an update occurred. The procedure first declares a local variable v_trimmed_description of type VARCHAR2 to hold the trimmed description, but since the natural language description does not specify an input parameter for the new description, it is assumed that the new description is provided as an additional input parameter. However, based on the given description, the procedure should accept a new description value. Therefore, the procedure actually takes three parameters: an input parameter p_experiment_id of type NUMBER, an input parameter p_new_description of type VARCHAR2, and an output parameter p_updated_flag of type NUMBER. The procedure initializes p_updated_flag to 0. It then trims any trailing spaces from p_new_description using the RTRIM function and stores the result in v_trimmed_description. Next, it performs an UPDATE operation on the EXPERIMENTS table, setting the DESCRIPTION column to the value in v_trimmed_description where the EXPERIMENT_ID column equals p_experiment_id. After the update, it checks if any rows were affected by using the SQL%ROWCOUNT attribute. If SQL%ROWCOUNT is greater than 0, indicating that at least one row was updated, it sets p_updated_flag to 1. Otherwise, p_updated_flag remains 0. The procedure does not explicitly commit the transaction, leaving that to the caller's discretion.",
    "original_summary": "Create a stored procedure named UpdateExperimentDescription that updates the DESCRIPTION for a specific EXPERIMENT_ID in the EXPERIMENTS table, trimming trailing spaces from the new description. It returns 1 in an output parameter if a row was updated.",
    "plsql_type": "Oracle PL/SQL",
    "object_type": "procedure",
    "original_natural_language": "Make a stored procedure called UpdateExperimentDescription that changes the DESCRIPTION for a certain EXPERIMENT_ID in the EXPERIMENTS table, cleaning up any extra spaces at the end of the new description. Have it give back a 1 in an output parameter if something was actually changed."
  }
]