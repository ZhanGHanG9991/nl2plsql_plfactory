[
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_UPD_GYMNAST_TOTAL` that is designed to execute automatically before an `UPDATE` operation is performed on the `GYMNAST` table. This trigger is specifically activated only when one or more of the following columns are being updated: `FLOOR_EXERCISE_POINTS`, `POMMEL_HORSE_POINTS`, `RINGS_POINTS`, `VAULT_POINTS`, `PARALLEL_BARS_POINTS`, or `HORIZONTAL_BAR_POINTS`. The trigger is defined with the `FOR EACH ROW` clause, meaning that its body will be executed once for every individual row in the `GYMNAST` table that is affected by the `UPDATE` statement. Within the trigger's execution block, the value of the `TOTAL_POINTS` column for the row currently being updated (represented by `:NEW.TOTAL_POINTS`) is calculated. This calculation involves summing the values of several other columns from the same row as they will be after the update. Specifically, the new value for `TOTAL_POINTS` is set to the sum of the new value of `FLOOR_EXERCISE_POINTS` (represented by `:NEW.FLOOR_EXERCISE_POINTS`), the new value of `POMMEL_HORSE_POINTS` (represented by `:NEW.POMMEL_HORSE_POINTS`), the new value of `RINGS_POINTS` (represented by `:NEW.RINGS_POINTS`), the new value of `VAULT_POINTS` (represented by `:NEW.VAULT_POINTS`), the new value of `PARALLEL_BARS_POINTS` (represented by `:NEW.PARALLEL_BARS_POINTS`), and the new value of `HORIZONTAL_BAR_POINTS` (represented by `:NEW.HORIZONTAL_BAR_POINTS`). This operation effectively ensures that the `TOTAL_POINTS` column is automatically maintained as the sum of the individual event scores whenever any of those individual scores are modified.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_UPD_GYMNAST_TOTAL\nBEFORE UPDATE OF FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS ON GYMNAST\nFOR EACH ROW\nBEGIN\n    :NEW.TOTAL_POINTS := :NEW.FLOOR_EXERCISE_POINTS + :NEW.POMMEL_HORSE_POINTS + :NEW.RINGS_POINTS + :NEW.VAULT_POINTS + :NEW.PARALLEL_BARS_POINTS + :NEW.HORIZONTAL_BAR_POINTS;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "UPDATE GYMNAST SET FLOOR_EXERCISE_POINTS = 9.8 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET POMMEL_HORSE_POINTS = 9.8 WHERE GYMNAST_ID = 2",
      "UPDATE GYMNAST SET RINGS_POINTS = 9.8 WHERE GYMNAST_ID = 4",
      "UPDATE GYMNAST SET VAULT_POINTS = 9.8 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET PARALLEL_BARS_POINTS = 9.8 WHERE GYMNAST_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE trigger on the GYMNAST table that fires when specific points columns are updated. For each row, recalculate TOTAL_POINTS as the sum of the new values for FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, and HORIZONTAL_BAR_POINTS.",
    "natural_language": "Set up a trigger on the gymnast table that runs before updates. When certain score columns get changed, have it figure out a new total by adding up the fresh numbers from a few of the main events.",
    "id": 1,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_UPD_GYMNAST_TOTAL that is executed before an update operation on the GYMNAST table for each row affected by the update. The trigger is designed to recalculate the TOTAL_POINTS column whenever specific score columns are modified. It begins by checking if any of the following columns in the GYMNAST table have been changed: FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, or HORIZONTAL_BAR_POINTS. This check is performed by comparing the OLD and NEW pseudorecord values for each of these columns. If at least one of these columns has a different value in the NEW record compared to the OLD record, the trigger proceeds to calculate a new total. The calculation involves summing the updated values from these six columns: FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, and HORIZONTAL_BAR_POINTS. The sum is computed by adding the :NEW values of each column together. The resulting sum is then assigned to the TOTAL_POINTS column of the NEW record for the row being updated. This ensures that the TOTAL_POINTS column is automatically updated to reflect the current total of the six event scores whenever any of those individual scores are changed. If none of the specified score columns have been modified, the trigger takes no action, leaving the TOTAL_POINTS column unchanged."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_problem_status_update that fires before any update operation on the PROBLEM_LOG table, specifically when the PROBLEM_STATUS_CODE column is being updated, and executes once for each row being updated, declaring two local variables v_old_status_desc and v_new_status_desc, each of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT operation on the PROBLEM_STATUS_CODES table to retrieve the PROBLEM_STATUS_DESCRIPTION column value corresponding to the old PROBLEM_STATUS_CODE value from the :OLD pseudorecord and stores it into v_old_status_desc, followed by another SELECT operation on the PROBLEM_STATUS_CODES table to retrieve the PROBLEM_STATUS_DESCRIPTION column value corresponding to the new PROBLEM_STATUS_CODE value from the :NEW pseudorecord and stores it into v_new_status_desc, then evaluates a conditional IF statement comparing v_old_status_desc and v_new_status_desc for inequality, and if they are not equal, constructs a string by concatenating the literal 'Status changed from ', the value of v_old_status_desc, the literal ' to ', and the value of v_new_status_desc, and assigns this resulting string to the LOG_ENTRY_DESCRIPTION column of the :NEW pseudorecord for the PROBLEM_LOG table row, but if the values are equal, constructs a string by concatenating the literal 'Status remains ' and the value of v_new_status_desc and assigns this resulting string to the LOG_ENTRY_DESCRIPTION column of the :NEW pseudorecord.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_problem_status_update\nBEFORE UPDATE OF PROBLEM_STATUS_CODE ON PROBLEM_LOG\nFOR EACH ROW\nDECLARE\n    v_old_status_desc VARCHAR2(255);\n    v_new_status_desc VARCHAR2(255);\nBEGIN\n    SELECT PROBLEM_STATUS_DESCRIPTION INTO v_old_status_desc\n    FROM PROBLEM_STATUS_CODES\n    WHERE PROBLEM_STATUS_CODE = :OLD.PROBLEM_STATUS_CODE;\n\n    SELECT PROBLEM_STATUS_DESCRIPTION INTO v_new_status_desc\n    FROM PROBLEM_STATUS_CODES\n    WHERE PROBLEM_STATUS_CODE = :NEW.PROBLEM_STATUS_CODE;\n\n    IF v_old_status_desc != v_new_status_desc THEN\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Status changed from ' || v_old_status_desc || ' to ' || v_new_status_desc;\n    ELSE\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Status remains ' || v_new_status_desc;\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES",
      "PRODUCT",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Reported' WHERE PROBLEM_LOG_ID = 2",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved' WHERE PROBLEM_ID = 11",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Reported', LOG_ENTRY_DATE = SYSDATE WHERE PROBLEM_LOG_ID = 3",
      "UPDATE PROBLEM_LOG SET PROBLEM_STATUS_CODE = 'Solved', PROBLEM_CATEGORY_CODE = 'GUI' WHERE PROBLEM_LOG_ID = 4"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_problem_status_update on the PROBLEM_LOG table that fires when PROBLEM_STATUS_CODE changes. For each updated row, retrieve the old and new status descriptions from PROBLEM_STATUS_CODES. If descriptions differ, set LOG_ENTRY_DESCRIPTION to 'Status changed from [old description] to [new description]'. Otherwise, set it to 'Status remains [new description]'.",
    "natural_language": "Please construct a BEFORE UPDATE row-level trigger designated as trg_problem_status_update on the PROBLEM_LOG table. This trigger should be activated specifically when the PROBLEM_STATUS_CODE column is modified. For each affected row, it is necessary to obtain the descriptions corresponding to the previous and updated status values from the PROBLEM_STATUS_CODES reference table. Subsequently, if the two descriptions are not identical, the LOG_ENTRY_DESCRIPTION field must be populated with the text 'Status changed from [old description] to [new description]'. Conversely, if the descriptions are the same, the field should be set to 'Status remains [new description]'.",
    "id": 2,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_problem_status_update that is executed automatically before an update operation is performed on the PROBLEM_LOG table. This trigger operates for each row affected by the update and is activated specifically when the PROBLEM_STATUS_CODE column is modified. Within the trigger's body, two SELECT operations are executed to retrieve descriptions from the PROBLEM_STATUS_CODES reference table. The first SELECT operation retrieves the PROBLEM_STATUS_DESCRIPTION corresponding to the old value of the PROBLEM_STATUS_CODE column from the updated row, accessed using the :OLD prefix. The second SELECT operation retrieves the PROBLEM_STATUS_DESCRIPTION corresponding to the new value of the PROBLEM_STATUS_CODE column from the updated row, accessed using the :NEW prefix. These descriptions are stored in local variables. Subsequently, a conditional check is performed to compare the two retrieved descriptions. If the two descriptions are not identical, the LOG_ENTRY_DESCRIPTION field of the updated row is populated with a string value that concatenates the text 'Status changed from ', the old description, the text ' to ', and the new description. Conversely, if the two descriptions are the same, the LOG_ENTRY_DESCRIPTION field is set to a string value that concatenates the text 'Status remains ' and the new description. This trigger ensures that the LOG_ENTRY_DESCRIPTION is automatically updated to reflect the status change or lack thereof whenever the PROBLEM_STATUS_CODE is modified in the PROBLEM_LOG table."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_ship_tonnage_validation` that is defined to execute `BEFORE UPDATE` operations on the `SHIP` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is being updated in the `SHIP` table. The trigger's purpose is to modify the `TYPE` column of the `SHIP` table based on the `TONNAGE` value of the row being updated. Specifically, it evaluates the `TONNAGE` value of the new row image (`:NEW.TONNAGE`). If the `TONNAGE` value is strictly greater than 5000, the trigger concatenates the string literal 'Heavy ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). If the `TONNAGE` value is not greater than 5000, the trigger then checks if the `TONNAGE` value is strictly less than 2000. If this condition is true, it concatenates the string literal 'Light ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). If neither of the preceding conditions is met (i.e., `TONNAGE` is between 2000 and 5000, inclusive), the trigger concatenates the string literal 'Medium ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). The modifications to `:NEW.TYPE` will be applied to the `TYPE` column of the `SHIP` table as part of the `UPDATE` statement that fired the trigger.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_ship_tonnage_validation\nBEFORE UPDATE ON SHIP\nFOR EACH ROW\nBEGIN\n    IF :NEW.TONNAGE > 5000 THEN\n        :NEW.TYPE := 'Heavy ' || :NEW.TYPE;\n    ELSIF :NEW.TONNAGE < 2000 THEN\n        :NEW.TYPE := 'Light ' || :NEW.TYPE;\n    ELSE\n        :NEW.TYPE := 'Medium ' || :NEW.TYPE;\n    END IF;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "UPDATE SHIP SET TONNAGE = 6000 WHERE SHIP_ID = 1",
      "UPDATE SHIP SET TONNAGE = 1500 WHERE SHIP_ID = 2",
      "UPDATE SHIP SET TONNAGE = 2500 WHERE SHIP_ID = 3",
      "UPDATE SHIP SET TONNAGE = 500 WHERE SHIP_ID = 1",
      "UPDATE SHIP SET TONNAGE = 4500 WHERE SHIP_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_ship_tonnage_validation on the SHIP table. For each row, modify :NEW.TYPE by prepending 'Heavy ' if :NEW.TONNAGE > 5000, 'Light ' if :NEW.TONNAGE < 2000, or 'Medium ' otherwise.",
    "natural_language": "Create a BEFORE UPDATE row-level trigger called trg_ship_tonnage_validation for the SHIP table. For each updated row, set the :NEW.TYPE to 'Heavy ' if :NEW.TONNAGE exceeds 5000, to 'Light ' if it is below 2000, and to 'Medium ' in all other cases.",
    "id": 3,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_ship_tonnage_validation` that is defined to execute `BEFORE UPDATE` operations on the `SHIP` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is being updated in the `SHIP` table. The trigger's purpose is to modify the `TYPE` column of the `SHIP` table based on the `TONNAGE` value of the row being updated. Specifically, it evaluates the `TONNAGE` value of the new row image (`:NEW.TONNAGE`). If the `TONNAGE` value is strictly greater than 5000, the trigger concatenates the string literal 'Heavy ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). If the `TONNAGE` value is not greater than 5000, the trigger then checks if the `TONNAGE` value is strictly less than 2000. If this condition is true, it concatenates the string literal 'Light ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). If neither of the preceding conditions is met (i.e., `TONNAGE` is between 2000 and 5000, inclusive), the trigger concatenates the string literal 'Medium ' with the existing value of the `TYPE` column from the new row image (`:NEW.TYPE`) and assigns this new concatenated string back to the `TYPE` column of the new row image (`:NEW.TYPE`). The modifications to `:NEW.TYPE` will be applied to the `TYPE` column of the `SHIP` table as part of the `UPDATE` statement that fired the trigger."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that is executed before an update operation on the photos table, specifically for each row that is being updated. The trigger modifies the NAME column of the row being updated by truncating its value to a maximum length of 50 characters. This is achieved by using the SUBSTR function, which extracts a substring from the NAME column starting at the first character and extending up to the 50th character. The result of this operation is then assigned back to the NAME column of the new version of the row, denoted by :NEW.NAME, ensuring that the updated NAME value does not exceed 50 characters in length.",
    "plsql": "CREATE OR REPLACE TRIGGER photos_before_update_trim_name\nBEFORE UPDATE ON photos\nFOR EACH ROW\nBEGIN\n   :NEW.NAME := SUBSTR(:NEW.NAME, 1, 50);\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "PHOTOS"
    ],
    "call_sqls": [
      "UPDATE photos SET name = 'A very long photo name that definitely exceeds fifty characters in total length' WHERE id = 1",
      "UPDATE photos SET name = 'Sunset over the mountain range with a beautiful reflection in the lake' WHERE id = 2",
      "UPDATE photos SET name = name || ' - additional descriptive text to make it longer' WHERE id = 4",
      "UPDATE photos SET name = 'Test', color = 'RGB' WHERE mountain_id = 20",
      "UPDATE photos SET name = 'A' WHERE camera_lens_id = 10"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger on the PHOTOS table. For each updated row, truncate the :NEW.NAME value to a maximum of 50 characters.",
    "natural_language": "How can I create a BEFORE UPDATE row-level trigger for the PHOTOS table that truncates the :NEW.NAME value to 50 characters for each updated row?",
    "id": 4,
    "generated_ir": "Write an Oracle PL/SQL trigger that is executed before an update operation on the photos table, specifically for each row that is being updated. The trigger modifies the NAME column of the row being updated by truncating its value to a maximum length of 50 characters. This is achieved by using the SUBSTR function, which extracts a substring from the NAME column starting at the first character and extending up to the 50th character. The result of this operation is then assigned back to the NAME column of the new version of the row, denoted by :NEW.NAME, ensuring that the updated NAME value does not exceed 50 characters in length."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_delete_actual_order_products` that is activated `AFTER` a `DELETE` operation occurs on the `ACTUAL_ORDERS` table. This trigger is configured to execute `FOR EACH ROW` that is deleted from the `ACTUAL_ORDERS` table. Upon activation, for each row that has been deleted from the `ACTUAL_ORDERS` table, the trigger performs a `DELETE` operation on the `ACTUAL_ORDER_PRODUCTS` table. The `DELETE` operation on the `ACTUAL_ORDER_PRODUCTS` table is conditional, targeting only those rows where the value in the `ACTUAL_ORDER_ID` column of the `ACTUAL_ORDER_PRODUCTS` table is equal to the value of the `ACTUAL_ORDER_ID` column from the row that was just deleted from the `ACTUAL_ORDERS` table. The `:OLD.ACTUAL_ORDER_ID` refers to the value of the `ACTUAL_ORDER_ID` column in the row of the `ACTUAL_ORDERS` table that existed *before* the `DELETE` operation was performed.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_actual_order_products\nAFTER DELETE ON ACTUAL_ORDERS\nFOR EACH ROW\nBEGIN\n  DELETE FROM ACTUAL_ORDER_PRODUCTS\n  WHERE ACTUAL_ORDER_ID = :OLD.ACTUAL_ORDER_ID;\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS"
    ],
    "call_sqls": [
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 1",
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 2",
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 3",
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 8",
      "DELETE FROM ACTUAL_ORDERS WHERE ACTUAL_ORDER_ID = 15"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_delete_actual_order_products on the ACTUAL_ORDERS table. For each deleted order, delete all related rows from the ACTUAL_ORDER_PRODUCTS table where the ACTUAL_ORDER_ID matches the deleted order's ID.",
    "natural_language": "Set up a trigger on the ACTUAL_ORDERS table that runs after rows are removed. It should clean up the related entries in the ACTUAL_ORDER_PRODUCTS table, getting rid of the ones that seem to be linked to the deleted orders.",
    "id": 5,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_delete_actual_order_products` that is activated `AFTER` a `DELETE` operation occurs on the `ACTUAL_ORDERS` table. This trigger is configured to execute `FOR EACH ROW` that is deleted from the `ACTUAL_ORDERS` table. Upon activation, for each row that has been deleted from the `ACTUAL_ORDERS` table, the trigger performs a `DELETE` operation on the `ACTUAL_ORDER_PRODUCTS` table. The `DELETE` operation on the `ACTUAL_ORDER_PRODUCTS` table is conditional, targeting only those rows where the value in the `ACTUAL_ORDER_ID` column of the `ACTUAL_ORDER_PRODUCTS` table is equal to the value of the `ACTUAL_ORDER_ID` column from the row that was just deleted from the `ACTUAL_ORDERS` table. The `:OLD.ACTUAL_ORDER_ID` refers to the value of the `ACTUAL_ORDER_ID` column in the row of the `ACTUAL_ORDERS` table that existed *before* the `DELETE` operation was performed."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_insert_subject_course` that is defined to execute automatically after an `INSERT` operation is performed on the `SUBJECTS` table. This trigger is a row-level trigger, meaning it will execute once for each row that is inserted into the `SUBJECTS` table. Upon activation, the trigger performs a single `INSERT` operation into the `COURSES` table. The `INSERT` statement populates the `COURSE_ID`, `AUTHOR_ID`, `SUBJECT_ID`, `COURSE_NAME`, and `COURSE_DESCRIPTION` columns of the `COURSES` table. The value for the `COURSE_ID` column is determined by a subquery that first selects the maximum existing `COURSE_ID` from the `COURSES` table using the `MAX()` aggregate function. If no `COURSE_ID` exists (i.e., `MAX(COURSE_ID)` returns `NULL`), the `NVL()` function replaces `NULL` with `0`. This result is then incremented by `1` to generate a new, unique `COURSE_ID`. The `AUTHOR_ID` column is assigned a static numeric value of `1`. The `SUBJECT_ID` column is populated with the value of the `SUBJECT_ID` column from the newly inserted row in the `SUBJECTS` table, referenced using the `:NEW.SUBJECT_ID` pseudorecord. The `COURSE_NAME` column is assigned the static string literal `'New Course'`. Finally, the `COURSE_DESCRIPTION` column is assigned the static string literal `'Description'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_subject_course\nAFTER INSERT ON SUBJECTS\nFOR EACH ROW\nBEGIN\n    INSERT INTO COURSES (COURSE_ID, AUTHOR_ID, SUBJECT_ID, COURSE_NAME, COURSE_DESCRIPTION)\n    VALUES ((SELECT NVL(MAX(COURSE_ID), 0) + 1 FROM COURSES), 1, :NEW.SUBJECT_ID, 'New Course', 'Description');\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (101, 'Mathematics')",
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (102, 'Physics')",
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (103, 'Chemistry')",
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (104, 'Biology')",
      "INSERT INTO SUBJECTS (SUBJECT_ID, SUBJECT_NAME) VALUES (105, 'History')"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_subject_course on the SUBJECTS table. For each new row, insert a record into the COURSES table. Set COURSE_ID to the maximum existing COURSE_ID plus one (starting at 1 if null), AUTHOR_ID to 1, SUBJECT_ID to :NEW.SUBJECT_ID, COURSE_NAME to 'New Course', and COURSE_DESCRIPTION to 'Description'.",
    "natural_language": "Alright, so we need a trigger that fires off after a new row is added to the SUBJECTS table. Name it 'trg_insert_subject_course'. Every time a new subject pops in, we gotta add a matching entry to the COURSES table. For that new course record, figure out the COURSE_ID by taking the highest one we already have and adding 1 to it (if there's none, just start at 1). Set the AUTHOR_ID to 1, grab the new SUBJECT_ID from the fresh row, call the COURSE_NAME 'New Course', and slap 'Description' into the COURSE_DESCRIPTION.",
    "id": 6,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_insert_subject_course` that is defined to execute automatically after an `INSERT` operation is performed on the `SUBJECTS` table. This trigger is a row-level trigger, meaning it will execute once for each row that is inserted into the `SUBJECTS` table. Upon activation, the trigger performs a single `INSERT` operation into the `COURSES` table. The `INSERT` statement populates the `COURSE_ID`, `AUTHOR_ID`, `SUBJECT_ID`, `COURSE_NAME`, and `COURSE_DESCRIPTION` columns of the `COURSES` table. The value for the `COURSE_ID` column is determined by a subquery that first selects the maximum existing `COURSE_ID` from the `COURSES` table using the `MAX()` aggregate function. If no `COURSE_ID` exists (i.e., `MAX(COURSE_ID)` returns `NULL`), the `NVL()` function replaces `NULL` with `0`. This result is then incremented by `1` to generate a new, unique `COURSE_ID`. The `AUTHOR_ID` column is assigned a static numeric value of `1`. The `SUBJECT_ID` column is populated with the value of the `SUBJECT_ID` column from the newly inserted row in the `SUBJECTS` table, referenced using the `:NEW.SUBJECT_ID` pseudorecord. The `COURSE_NAME` column is assigned the static string literal `'New Course'`. Finally, the `COURSE_DESCRIPTION` column is assigned the static string literal `'Description'`."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_catalog_content_price_update that is executed before an update operation on the PRICE_IN_DOLLARS column of the CATALOG_CONTENTS table for each row being updated. The trigger first checks if the new value of PRICE_IN_DOLLARS is greater than the old value; if true, it updates the PRICE_IN_EUROS column of the same row to be 85% of the new PRICE_IN_DOLLARS value. If the new PRICE_IN_DOLLARS is less than the old value, it updates the PRICE_IN_POUNDS column to be 75% of the new PRICE_IN_DOLLARS value. If the new and old PRICE_IN_DOLLARS values are equal, it inserts a new row into the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table with the CATALOG_ENTRY_ID and CATALOG_LEVEL_NUMBER from the updated row, an ATTRIBUTE_ID of 1, and an ATTRIBUTE_VALUE of 'Unchanged'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_catalog_content_price_update\nBEFORE UPDATE OF PRICE_IN_DOLLARS ON CATALOG_CONTENTS\nFOR EACH ROW\nBEGIN\n  IF :NEW.PRICE_IN_DOLLARS > :OLD.PRICE_IN_DOLLARS THEN\n    :NEW.PRICE_IN_EUROS := :NEW.PRICE_IN_DOLLARS * 0.85;\n  ELSIF :NEW.PRICE_IN_DOLLARS < :OLD.PRICE_IN_DOLLARS THEN\n    :NEW.PRICE_IN_POUNDS := :NEW.PRICE_IN_DOLLARS * 0.75;\n  ELSE\n    INSERT INTO CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES (CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID, ATTRIBUTE_VALUE)\n    VALUES (:NEW.CATALOG_ENTRY_ID, :NEW.CATALOG_LEVEL_NUMBER, 1, 'Unchanged');\n  END IF;\nEND;",
    "database_name": "product_catalog",
    "tables": [
      "ATTRIBUTE_DEFINITIONS",
      "CATALOGS",
      "CATALOG_CONTENTS",
      "CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES",
      "CATALOG_STRUCTURE"
    ],
    "call_sqls": [
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 250.00 WHERE CATALOG_ENTRY_ID = 1",
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 150.00 WHERE CATALOG_ENTRY_ID = 2",
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 360.50 WHERE CATALOG_ENTRY_ID = 3",
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 700.00 WHERE CATALOG_ENTRY_ID = 1",
      "UPDATE CATALOG_CONTENTS SET PRICE_IN_DOLLARS = 50.00 WHERE CATALOG_ENTRY_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_catalog_content_price_update on the CATALOG_CONTENTS table for the PRICE_IN_DOLLARS column. If the new price is greater than the old, set PRICE_IN_EUROS to 85% of the new price. If the new price is less, set PRICE_IN_POUNDS to 75% of the new price. If the prices are equal, insert a row into CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES with the row's CATALOG_ENTRY_ID, CATALOG_LEVEL_NUMBER, ATTRIBUTE_ID=1, and ATTRIBUTE_VALUE='Unchanged'.",
    "natural_language": "Alright, so we need a trigger that fires off before any row gets updated in the CATALOG_CONTENTS table, specifically when the PRICE_IN_DOLLARS changes. Call this trigger trg_catalog_content_price_update. Here's the deal: if the new price is higher than the old one, we gotta set the PRICE_IN_EUROS to 85% of that new price. If the new price is lower, then set PRICE_IN_POUNDS to 75% of the new price instead. Now, if the old and new prices are exactly the same, we need to log that by popping a new row into the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table. For that row, use the current entry's CATALOG_ENTRY_ID and CATALOG_LEVEL_NUMBER, set the ATTRIBUTE_ID to 1, and slap 'Unchanged' into the ATTRIBUTE_VALUE field.",
    "id": 7,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_catalog_content_price_update that is executed before an update operation on the PRICE_IN_DOLLARS column of the CATALOG_CONTENTS table for each row being updated. The trigger first checks if the new value of PRICE_IN_DOLLARS is greater than the old value; if true, it updates the PRICE_IN_EUROS column of the same row to be 85% of the new PRICE_IN_DOLLARS value. If the new PRICE_IN_DOLLARS is less than the old value, it updates the PRICE_IN_POUNDS column to be 75% of the new PRICE_IN_DOLLARS value. If the new and old PRICE_IN_DOLLARS values are equal, it inserts a new row into the CATALOG_CONTENTS_ADDITIONAL_ATTRIBUTES table with the CATALOG_ENTRY_ID and CATALOG_LEVEL_NUMBER from the updated row, an ATTRIBUTE_ID of 1, and an ATTRIBUTE_VALUE of 'Unchanged'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_set_reported_date that fires before any row is inserted into the PROBLEMS table, and for each new row, checks if the column DATE_PROBLEM_REPORTED is null; if this condition is true, the trigger assigns a value to the :NEW.DATE_PROBLEM_REPORTED column by calling the CURRENT_TIMESTAMP function to get the current date and time from the system, then uses the TO_CHAR function with the format model 'YYYY-MM-DD HH24:MI:SS' to convert that timestamp into a string representation where YYYY is the four-digit year, MM is the two-digit month, DD is the two-digit day, HH24 is the two-digit hour in 24-hour format, MI is the two-digit minute, and SS is the two-digit second.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_set_reported_date\nBEFORE INSERT ON PROBLEMS\nFOR EACH ROW\nBEGIN\n  IF :NEW.DATE_PROBLEM_REPORTED IS NULL THEN\n    :NEW.DATE_PROBLEM_REPORTED := TO_CHAR(CURRENT_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS');\n  END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (4, 5, 6, 7, 'Problem description 1', 'Details 1')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (5, 6, 7, 8, 'Problem description 2', 'Details 2')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (6, 7, 8, 9, 'Problem description 3', 'Details 3')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (7, 8, 9, 10, 'Problem description 4', 'Details 4')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, CLOSURE_AUTHORISED_BY_STAFF_ID, REPORTED_BY_STAFF_ID, PROBLEM_DESCRIPTION, OTHER_PROBLEM_DETAILS) VALUES (8, 9, 10, 11, 'Problem description 5', 'Details 5')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_set_reported_date on the PROBLEMS table. If the new DATE_PROBLEM_REPORTED is null, set it to the current timestamp formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Please implement a BEFORE INSERT FOR EACH ROW trigger, designated as trg_set_reported_date, on the PROBLEMS table. This trigger should assign the current timestamp, formatted as 'YYYY-MM-DD HH24:MI:SS', to the new DATE_PROBLEM_REPORTED column whenever its value is found to be null.",
    "id": 8,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_set_reported_date that executes automatically before any row insertion operation on the PROBLEMS table, for each individual row being inserted. The trigger does not declare any local variables. It checks if the DATE_PROBLEM_REPORTED column value in the :NEW pseudorecord for the row being inserted is null. If this condition is true, the trigger assigns a new value to the DATE_PROBLEM_REPORTED column in the :NEW pseudorecord. The assigned value is the current system timestamp, obtained by calling the SYSTIMESTAMP function, which is then formatted to a string using the TO_CHAR function with the format model 'YYYY-MM-DD HH24:MI:SS'. This formatted string represents the current date and time in the specified format. If the DATE_PROBLEM_REPORTED column value in the :NEW pseudorecord is not null, the trigger takes no action, leaving the original value unchanged. The trigger does not perform any SQL operations such as SELECT, INSERT, UPDATE, or DELETE, and it does not raise any errors. Its sole purpose is to conditionally populate the DATE_PROBLEM_REPORTED column with a default timestamp when it is missing during an insert operation."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_order_date that is defined to fire BEFORE INSERT on the ACTUAL_ORDERS table for EACH ROW, and within its execution block, it assigns a value to the :NEW.ACTUAL_ORDER_DATE column by calling the TO_CHAR function with two arguments: the first argument is the SYSDATE function which returns the current date and time from the database server, and the second argument is the format model string 'YYYY-MM-DD HH24:MI:SS', which converts the date and time into a character string representing the year, month, day, hour in 24-hour format, minute, and second.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_order_date\nBEFORE INSERT ON ACTUAL_ORDERS\nFOR EACH ROW\nBEGIN\n  :NEW.ACTUAL_ORDER_DATE := TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');\nEND;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (101, 'Success', 10)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (102, 'Cancel', 11)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (103, 'Success', 12)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (104, 'Pending', 13)",
      "INSERT INTO ACTUAL_ORDERS (ACTUAL_ORDER_ID, ORDER_STATUS_CODE, REGULAR_ORDER_ID) VALUES (105, 'Success', 14)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_insert_order_date on the ACTUAL_ORDERS table. For each new row, set the ACTUAL_ORDER_DATE column to the current system date and time, formatted as 'YYYY-MM-DD HH24:MI:SS'.",
    "natural_language": "Construct a BEFORE INSERT row-level trigger, which should be named trg_insert_order_date, specifically for the ACTUAL_ORDERS table. For every single new row that is being inserted, you must meticulously ensure that the ACTUAL_ORDER_DATE column is automatically populated with the precise current system date and time, which should be carefully formatted in the detailed pattern of 'YYYY-MM-DD HH24:MI:SS'.",
    "id": 9,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_insert_order_date that is defined to fire BEFORE INSERT on the ACTUAL_ORDERS table for EACH ROW, and within its execution block, it assigns a value to the :NEW.ACTUAL_ORDER_DATE column by calling the TO_CHAR function with two arguments: the first argument is the SYSDATE function which returns the current date and time from the database server, and the second argument is the format model string 'YYYY-MM-DD HH24:MI:SS', which converts the date and time into a character string representing the year, month, day, hour in 24-hour format, minute, and second."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_dog_weight` that is activated `AFTER` an `INSERT` operation occurs on the `TREATMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `TREATMENTS` table. Upon activation, the trigger performs an `UPDATE` operation on the `DOGS` table. Specifically, it modifies the `WEIGHT` column of a particular row in the `DOGS` table. The row to be updated is identified by a `WHERE` clause, which specifies that the `DOG_ID` column in the `DOGS` table must be equal to the `DOG_ID` value of the newly inserted row in the `TREATMENTS` table. This `DOG_ID` value from the newly inserted row is accessed using the `:NEW.DOG_ID` pseudorecord. The new value for the `WEIGHT` column in the `DOGS` table is calculated by first converting the existing `WEIGHT` column's value from its current data type (which is implicitly assumed to be a character type due to the `TO_NUMBER` function call) to a numerical data type using the `TO_NUMBER()` function. To this numerical value, `0.5` is added. The resulting sum is then converted back to a character data type using the `TO_CHAR()` function before being assigned to the `WEIGHT` column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_dog_weight\nAFTER INSERT ON TREATMENTS\nFOR EACH ROW\nBEGIN\n    UPDATE DOGS SET WEIGHT = TO_CHAR(TO_NUMBER(WEIGHT) + 0.5) WHERE DOG_ID = :NEW.DOG_ID;\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "OWNERS",
      "BREEDS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (4, 1, 9, 'EXAM', '2023-10-01 10:00:00', 300)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (5, 2, 10, 'VAC', '2023-10-02 11:00:00', 150)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (6, 3, 4, 'WALK', '2023-10-03 12:00:00', 50)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (7, 1, 9, 'EXAM', '2023-10-04 13:00:00', 200)",
      "INSERT INTO TREATMENTS (TREATMENT_ID, DOG_ID, PROFESSIONAL_ID, TREATMENT_TYPE_CODE, DATE_OF_TREATMENT, COST_OF_TREATMENT) VALUES (8, 2, 10, 'VAC', '2023-10-05 14:00:00', 100)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_update_dog_weight on the TREATMENTS table. For each inserted row, update the DOGS table. Set the WEIGHT column to TO_CHAR(TO_NUMBER(WEIGHT) + 0.5) where DOG_ID equals :NEW.DOG_ID.",
    "natural_language": "How can I create an AFTER INSERT FOR EACH ROW trigger named trg_update_dog_weight on the TREATMENTS table that, for each new row, updates the DOGS table by setting the WEIGHT column to TO_CHAR(TO_NUMBER(WEIGHT) + 0.5) where DOG_ID matches :NEW.DOG_ID?",
    "id": 10,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_update_dog_weight` that is activated `AFTER` an `INSERT` operation occurs on the `TREATMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `TREATMENTS` table. Upon activation, the trigger performs an `UPDATE` operation on the `DOGS` table. Specifically, it modifies the `WEIGHT` column of a particular row in the `DOGS` table. The row to be updated is identified by a `WHERE` clause, which specifies that the `DOG_ID` column in the `DOGS` table must be equal to the `DOG_ID` value of the newly inserted row in the `TREATMENTS` table. This `DOG_ID` value from the newly inserted row is accessed using the `:NEW.DOG_ID` pseudorecord. The new value for the `WEIGHT` column in the `DOGS` table is calculated by first converting the existing `WEIGHT` column's value from its current data type (which is implicitly assumed to be a character type due to the `TO_NUMBER` function call) to a numerical data type using the `TO_NUMBER()` function. To this numerical value, `0.5` is added. The resulting sum is then converted back to a character data type using the `TO_CHAR()` function before being assigned to the `WEIGHT` column."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named school_details_synchronizer that is executed after a delete operation on the SCHOOL table for each row affected. The trigger begins by declaring a variable v_max_year of type VARCHAR2(255) to store the maximum SCHOOL_YEAR associated with the deleted SCHOOL_ID. It then performs a SELECT statement to retrieve the maximum SCHOOL_YEAR from the SCHOOL_PERFORMANCE table where the SCHOOL_ID matches the SCHOOL_ID of the deleted row, storing the result in v_max_year. If no data is found, the exception handler sets v_max_year to NULL. Following this, the trigger deletes all rows from the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the deleted row. Subsequently, the trigger checks if v_max_year is not NULL, and if this condition is true, it deletes rows from the SCHOOL_PERFORMANCE table where the SCHOOL_ID matches the SCHOOL_ID of the deleted row and the SCHOOL_YEAR equals v_max_year.",
    "plsql": "CREATE OR REPLACE TRIGGER school_details_synchronizer\nAFTER DELETE ON SCHOOL\nFOR EACH ROW\nDECLARE\n    v_max_year VARCHAR2(255);\nBEGIN\n    -- Get the maximum SCHOOL_YEAR for the deleted SCHOOL_ID\n    BEGIN\n        SELECT MAX(SCHOOL_YEAR)\n        INTO v_max_year\n        FROM SCHOOL_PERFORMANCE\n        WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            v_max_year := NULL;\n    END;\n    \n    -- Delete from SCHOOL_DETAILS\n    DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    \n    -- Delete from SCHOOL_PERFORMANCE only if v_max_year is not NULL\n    IF v_max_year IS NOT NULL THEN\n        DELETE FROM SCHOOL_PERFORMANCE \n        WHERE SCHOOL_ID = :OLD.SCHOOL_ID \n        AND SCHOOL_YEAR = v_max_year;\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 2",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 3",
      "DELETE FROM SCHOOL WHERE SCHOOL_ID = 4",
      "DELETE FROM SCHOOL WHERE SCHOOL = 'Barker College'",
      "DELETE FROM SCHOOL WHERE LOCATION = 'Wahroonga'"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named school_details_synchronizer on the SCHOOL table. For each deleted row, find the maximum SCHOOL_YEAR for that SCHOOL_ID from the SCHOOL_PERFORMANCE table. Then delete all records for that SCHOOL_ID from the SCHOOL_DETAILS table. Finally, if a maximum year was found, delete the corresponding record from the SCHOOL_PERFORMANCE table for that SCHOOL_ID and maximum SCHOOL_YEAR.",
    "natural_language": "How can I create an AFTER DELETE row-level trigger called school_details_synchronizer on the SCHOOL table so that, for each deleted row, it finds the maximum SCHOOL_YEAR for that SCHOOL_ID from the SCHOOL_PERFORMANCE table, deletes all records for that SCHOOL_ID from the SCHOOL_DETAILS table, and then, if a maximum year was found, deletes the corresponding record from the SCHOOL_PERFORMANCE table for that SCHOOL_ID and maximum SCHOOL_YEAR?",
    "id": 11,
    "generated_ir": "Write an Oracle PL/SQL trigger named school_details_synchronizer that automatically executes after any DELETE operation on the SCHOOL table, operating on a row-by-row basis. For each deleted row, the trigger performs the following operations: first, it declares a local variable v_max_school_year of type VARCHAR2(255) to store the maximum SCHOOL_YEAR value. It then executes a SELECT statement on the SCHOOL_PERFORMANCE table to find the maximum SCHOOL_YEAR for the SCHOOL_ID that matches the SCHOOL_ID of the deleted row from the :OLD pseudorecord, using the MAX aggregate function, and stores the result into v_max_school_year. Next, it executes a DELETE statement on the SCHOOL_DETAILS table to remove all records where the SCHOOL_ID column equals the SCHOOL_ID from the :OLD pseudorecord. After that, it checks if v_max_school_year is not null using an IF condition. If true, it executes another DELETE statement on the SCHOOL_PERFORMANCE table to remove the specific record where the SCHOOL_ID column equals the SCHOOL_ID from the :OLD pseudorecord and the SCHOOL_YEAR column equals the v_max_school_year value. This ensures synchronization by cleaning up related data in SCHOOL_DETAILS and the most recent performance record in SCHOOL_PERFORMANCE when a school is deleted."
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER INSERT OR UPDATE` row-level trigger named `trg_lesson_vehicle_check` on the `LESSONS` table. This trigger executes after an `INSERT` operation or an `UPDATE` operation on any row in the `LESSONS` table. It declares two local variables: `v_vehicle_details` of type `VARCHAR2(255)` to store vehicle details and `v_staff_count` of type `NUMBER` to store the count of staff members.\n\nThe trigger's execution begins by checking if the `VEHICLE_ID` column in the newly inserted or updated row (`:NEW.VEHICLE_ID`) is not `NULL`.\nIf `:NEW.VEHICLE_ID` is not `NULL`, it attempts to select the `VEHICLE_DETAILS` column from the `VEHICLES` table into the `v_vehicle_details` variable, specifically for the row where the `VEHICLE_ID` column matches `:NEW.VEHICLE_ID`.\nIf this `SELECT` statement results in `NO_DATA_FOUND` (meaning no vehicle with the specified `VEHICLE_ID` exists), it catches this exception and sets `v_vehicle_details` to `NULL`.\nIf `:NEW.VEHICLE_ID` is `NULL`, it directly sets `v_vehicle_details` to `NULL`.\n\nNext, it checks if the `STAFF_ID` column in the newly inserted or updated row (`:NEW.STAFF_ID`) is not `NULL`.\nIf `:NEW.STAFF_ID` is not `NULL`, it counts the number of rows in the `STAFF` table where the `STAFF_ID` column matches `:NEW.STAFF_ID` and stores this count in the `v_staff_count` variable.\nIf `:NEW.STAFF_ID` is `NULL`, it sets `v_staff_count` to `0`.\n\nFollowing these data retrieval and preparation steps, the trigger proceeds with a series of conditional logic checks:\n\n1.  It first checks if the `v_vehicle_details` variable is equal to the string literal `'Car'`.\n    If this condition is true, it updates the `VEHICLES` table, setting the `VEHICLE_DETAILS` column to the string literal `'Used Car'` for the row where the `VEHICLE_ID` column matches `:NEW.VEHICLE_ID`.\n\n2.  If the first condition is false, it then checks if `v_staff_count` is equal to `0` AND `:NEW.STAFF_ID` is not `NULL`.\n    If this combined condition is true, it inserts a new row into the `STAFF` table. The `STAFF_ID` column is set to `:NEW.STAFF_ID`, `STAFF_ADDRESS_ID` is set to `1`, `NICKNAME` is set to `'auto_gen'`, `FIRST_NAME` is set to `'Auto'`, `MIDDLE_NAME` is set to `'Gen'`, `LAST_NAME` is set to `'Staff'`, `DATE_OF_BIRTH` is set to the timestamp `'2000-01-01 00:00:00'`, `DATE_JOINED_STAFF` is set to the timestamp `'2000-01-01 00:00:00'`, and `DATE_LEFT_STAFF` is set to `NULL`.\n\n3.  If both the first and second conditions are false, it then checks if `:NEW.VEHICLE_ID` is not `NULL` AND `v_vehicle_details` is not `NULL`.\n    If this combined condition is true, it deletes rows from the `VEHICLES` table where the `VEHICLE_ID` column matches `:NEW.VEHICLE_ID`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_lesson_vehicle_check\nAFTER INSERT OR UPDATE ON LESSONS\nFOR EACH ROW\nDECLARE\n    v_vehicle_details VARCHAR2(255);\n    v_staff_count NUMBER;\nBEGIN\n    -- Handle potential NULL or non-existent VEHICLE_ID\n    IF :NEW.VEHICLE_ID IS NOT NULL THEN\n        BEGIN\n            SELECT VEHICLE_DETAILS INTO v_vehicle_details \n            FROM VEHICLES \n            WHERE VEHICLE_ID = :NEW.VEHICLE_ID;\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n                v_vehicle_details := NULL;\n        END;\n    ELSE\n        v_vehicle_details := NULL;\n    END IF;\n    \n    -- Check if STAFF_ID exists\n    IF :NEW.STAFF_ID IS NOT NULL THEN\n        SELECT COUNT(*) INTO v_staff_count \n        FROM STAFF \n        WHERE STAFF_ID = :NEW.STAFF_ID;\n    ELSE\n        v_staff_count := 0;\n    END IF;\n    \n    -- Conditional logic with proper NULL handling\n    IF v_vehicle_details = 'Car' THEN\n        UPDATE VEHICLES \n        SET VEHICLE_DETAILS = 'Used Car' \n        WHERE VEHICLE_ID = :NEW.VEHICLE_ID;\n    ELSIF v_staff_count = 0 AND :NEW.STAFF_ID IS NOT NULL THEN\n        INSERT INTO STAFF (STAFF_ID, STAFF_ADDRESS_ID, NICKNAME, FIRST_NAME, MIDDLE_NAME, LAST_NAME, DATE_OF_BIRTH, DATE_JOINED_STAFF, DATE_LEFT_STAFF) \n        VALUES (:NEW.STAFF_ID, 1, 'auto_gen', 'Auto', 'Gen', 'Staff', '2000-01-01 00:00:00', '2000-01-01 00:00:00', NULL);\n    ELSIF :NEW.VEHICLE_ID IS NOT NULL AND v_vehicle_details IS NOT NULL THEN\n        DELETE FROM VEHICLES \n        WHERE VEHICLE_ID = :NEW.VEHICLE_ID;\n    END IF;\nEND;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, LESSON_STATUS_CODE, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (100, 1, 'Scheduled', 1, 1, '2023-01-01', '10:00', 50)",
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, LESSON_STATUS_CODE, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (101, 2, 'Scheduled', 999, NULL, '2023-01-02', '11:00', 60)",
      "INSERT INTO LESSONS (LESSON_ID, CUSTOMER_ID, LESSON_STATUS_CODE, STAFF_ID, VEHICLE_ID, LESSON_DATE, LESSON_TIME, PRICE) VALUES (102, 3, 'Scheduled', 2, 2, '2023-01-03', '12:00', 70)",
      "UPDATE LESSONS SET VEHICLE_ID = 3 WHERE LESSON_ID = 100",
      "UPDATE LESSONS SET STAFF_ID = 998 WHERE LESSON_ID = 101"
    ],
    "summary": "Create an AFTER INSERT OR UPDATE FOR EACH ROW trigger named trg_lesson_vehicle_check on the LESSONS table. For each new or updated row, retrieve vehicle details if VEHICLE_ID is not null, and count staff if STAFF_ID is not null. If vehicle details are 'Car', update that vehicle's details to 'Used Car'. If the staff count is 0 and STAFF_ID is not null, insert a new auto-generated staff record. If VEHICLE_ID is not null and vehicle details are not null (but not 'Car'), delete that vehicle record.",
    "natural_language": "Please construct an AFTER INSERT OR UPDATE FOR EACH ROW trigger, designated as trg_lesson_vehicle_check, on the LESSONS table. For each newly inserted or modified row, it is required to fetch the associated vehicle details, provided the VEHICLE_ID is not null, and to calculate the count of staff members if the STAFF_ID is not null. Should the retrieved vehicle details be identified as 'Car', the corresponding vehicle record must be updated to reflect the status 'Used Car'. In the event that the staff count is determined to be zero while a STAFF_ID is present, a new staff record with auto-generated identifiers should be inserted. Furthermore, if a VEHICLE_ID is present and the associated vehicle details are not null, yet are not equivalent to 'Car', the pertinent vehicle record is to be deleted.",
    "id": 12,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_lesson_vehicle_check` that is activated `AFTER` an `INSERT` or `UPDATE` operation occurs on the `LESSONS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted or updated in the `LESSONS` table. The trigger operates within the `driving_school` database.\n\nUpon activation, for each newly inserted or updated row, the trigger performs a series of conditional operations based on the values of `VEHICLE_ID` and `STAFF_ID` in the affected row. The trigger begins by declaring two local variables: `v_vehicle_details` of type `VARCHAR2(255)`, intended to store the vehicle details fetched from the `VEHICLES` table, and `v_staff_count` of type `NUMBER`, intended to store the count of staff members from the `STAFF` table.\n\nFirst, if the `VEHICLE_ID` in the affected row (referenced as `:NEW.VEHICLE_ID`) is not null, the trigger executes a `SELECT` query on the `VEHICLES` table to retrieve the `VEHICLE_DETAILS` column for the record where `VEHICLE_ID` equals `:NEW.VEHICLE_ID`. The result is stored in the variable `v_vehicle_details`.\n\nSecond, if the `STAFF_ID` in the affected row (referenced as `:NEW.STAFF_ID`) is not null, the trigger executes a `SELECT` query on the `STAFF` table to count the number of records where `STAFF_ID` equals `:NEW.STAFF_ID`. The result is stored in the variable `v_staff_count`.\n\nFollowing these queries, the trigger implements a series of conditional actions:\n\nIf `v_vehicle_details` is retrieved and equals the exact string `'Car'`, the trigger performs an `UPDATE` operation on the `VEHICLES` table. Specifically, it modifies the `VEHICLE_DETAILS` column to set it to `'Used Car'` for the record where `VEHICLE_ID` equals `:NEW.VEHICLE_ID`.\n\nIf `v_staff_count` is retrieved and equals zero, and `:NEW.STAFF_ID` is not null, the trigger performs an `INSERT` operation into the `STAFF` table. The new record includes auto-generated identifiers: `STAFF_ID` is set to a new unique value (typically via a sequence or similar mechanism), `STAFF_ADDRESS_ID` is set to null or a default, `NICKNAME` is set to a default or derived value, `FIRST_NAME`, `MIDDLE_NAME`, and `LAST_NAME` are set to default or placeholder values, `DATE_OF_BIRTH` is set to a default date, `DATE_JOINED_STAFF` is set to the current date and time, and `DATE_LEFT_STAFF` is set to null. The exact values for these columns are determined by the system or application logic to ensure a valid staff record is created.\n\nIf `v_vehicle_details` is retrieved and is not null, and does not equal the exact string `'Car'`, the trigger performs a `DELETE` operation on the `VEHICLES` table. Specifically, it deletes the record where `VEHICLE_ID` equals `:NEW.VEHICLE_ID`.\n\nThe trigger does not return any value but may raise exceptions if any of the database operations fail, such as due to integrity constraints or missing data. The trigger interacts with the `LESSONS`, `VEHICLES`, and `STAFF` tables, using the `VEHICLE_ID` and `STAFF_ID` columns to link records across these tables."
  },
  {
    "ir": "Write an Oracle PL/SQL package and two triggers that manage school enrollment data. The package, named school_pkg, defines a PL/SQL associative array type called school_id_table, which stores school IDs as numbers indexed by PLS_INTEGER. It also declares a global variable g_school_ids of this type and a global index variable g_index initialized to zero. The first trigger, trg_school_enrollment_check_row, is a row-level trigger that fires after an insert or update of the ENROLLMENT column in the SCHOOL table. It increments the g_index variable and stores the SCHOOL_ID from the newly inserted or updated row into the g_school_ids array at the current index. The second trigger, trg_school_enrollment_check_stmt, is a statement-level trigger that activates after an insert or update on the SCHOOL table. It calculates the average enrollment across all schools by selecting the average ENROLLMENT into a local variable v_avg_enrollment. It then iterates over the g_school_ids array from index 1 to g_index, checking each school ID. For each school ID, it updates the DIVISION column in the SCHOOL_DETAILS table to 'Above Average' if the school's enrollment exceeds the average, or 'Below Average' otherwise. Additionally, if a school's enrollment is greater than 2000, it updates the CLASS column in SCHOOL_DETAILS to 'Large School'. It deletes any row in SCHOOL_DETAILS where the SCHOOL_ID matches the current school ID and the NICKNAME is 'Temporary'. It inserts a new row into SCHOOL_DETAILS with the current school ID and the current year as the LEAGUE, formatted as a string using TO_CHAR(SYSDATE, 'YYYY'). After processing all school IDs, it resets the g_index variable to zero.",
    "plsql": "CREATE OR REPLACE PACKAGE school_pkg IS\n  TYPE school_id_table IS TABLE OF NUMBER INDEX BY PLS_INTEGER;\n  g_school_ids school_id_table;\n  g_index PLS_INTEGER := 0;\nEND school_pkg;\n/\n\nCREATE OR REPLACE TRIGGER trg_school_enrollment_check_row\nAFTER INSERT OR UPDATE OF ENROLLMENT ON SCHOOL\nFOR EACH ROW\nBEGIN\n  school_pkg.g_index := school_pkg.g_index + 1;\n  school_pkg.g_school_ids(school_pkg.g_index) := :NEW.SCHOOL_ID;\nEND;\n/\n\nCREATE OR REPLACE TRIGGER trg_school_enrollment_check_stmt\nAFTER INSERT OR UPDATE ON SCHOOL\nDECLARE\n  v_avg_enrollment NUMBER;\nBEGIN\n  SELECT AVG(ENROLLMENT) INTO v_avg_enrollment FROM SCHOOL;\n\n  FOR i IN 1 .. school_pkg.g_index LOOP\n    IF EXISTS (SELECT 1 FROM SCHOOL WHERE SCHOOL_ID = school_pkg.g_school_ids(i) AND ENROLLMENT > v_avg_enrollment) THEN\n      UPDATE SCHOOL_DETAILS SET DIVISION = 'Above Average' WHERE SCHOOL_ID = school_pkg.g_school_ids(i);\n    ELSE\n      UPDATE SCHOOL_DETAILS SET DIVISION = 'Below Average' WHERE SCHOOL_ID = school_pkg.g_school_ids(i);\n    END IF;\n\n    IF EXISTS (SELECT 1 FROM SCHOOL WHERE SCHOOL_ID = school_pkg.g_school_ids(i) AND ENROLLMENT > 2000) THEN\n      UPDATE SCHOOL_DETAILS SET CLASS = 'Large School' WHERE SCHOOL_ID = school_pkg.g_school_ids(i);\n    END IF;\n\n    DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = school_pkg.g_school_ids(i) AND NICKNAME = 'Temporary';\n    INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, LEAGUE) VALUES (school_pkg.g_school_ids(i), TO_CHAR(SYSDATE, 'YYYY'));\n  END LOOP;\n\n  school_pkg.g_index := 0; -- Reset the index after processing\nEND;\n/",
    "database_name": "school_player",
    "tables": [
      "SCHOOL",
      "SCHOOL_DETAILS"
    ],
    "call_sqls": [
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (5, 'Test School', 'Test City', 1500, 1950, 'Test Denomination', 'Co-ed', 'Day', 2000, 'Green & Gold')",
      "UPDATE SCHOOL SET ENROLLMENT = 2500 WHERE SCHOOL_ID = 2",
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (6, 'Another School', 'Another City', 800, 1960, 'Another Denomination', 'Girls', 'Boarding', 2010, 'Purple & Silver')",
      "UPDATE SCHOOL SET ENROLLMENT = 1800, LOCATION = 'Updated City' WHERE SCHOOL_ID = 3",
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (7, 'Large Academy', 'Metro City', 3000, 1900, 'Academy', 'Boys', 'Day & Boarding', 1950, 'Maroon & Grey')"
    ],
    "summary": "Create a package named school_pkg with an associative array type school_id_table, a variable g_school_ids of that type, and an index variable g_index. Create two triggers on the SCHOOL table: 1) An AFTER INSERT OR UPDATE row-level trigger trg_school_enrollment_check_row that stores the SCHOOL_ID into g_school_ids when ENROLLMENT is modified. 2) An AFTER INSERT OR UPDATE statement-level trigger trg_school_enrollment_check_stmt that calculates the average ENROLLMENT, then for each stored SCHOOL_ID: updates SCHOOL_DETAILS.DIVISION based on enrollment vs. average; updates SCHOOL_DETAILS.CLASS to 'Large School' if enrollment > 2000; deletes SCHOOL_DETAILS rows where NICKNAME is 'Temporary'; inserts a new SCHOOL_DETAILS row with the current year as LEAGUE. Finally, reset g_index.",
    "natural_language": "Create a package for school stuff with a type for holding school IDs and a variable for that type, plus a counter. Set up a couple of triggers on the main school table. The first one, which fires after you add or change a row, should save the school's ID into our list when the student count is adjusted. The second one, which runs after the whole insert or update operation, needs to figure out the typical enrollment size. Then, for each school ID we saved, it should adjust the division category in the details table by comparing its enrollment to that typical size, mark it as a 'Large School' if it has a lot of students, get rid of any temporary detail entries, and add a new detail record with the current year. After all that, clear the counter.",
    "id": 13,
    "generated_ir": "Write an Oracle PL/SQL package and two triggers that manage school enrollment data. The package, named school_pkg, defines a PL/SQL associative array type called school_id_table, which stores school IDs as numbers indexed by PLS_INTEGER. It also declares a global variable g_school_ids of this type and a global index variable g_index initialized to zero. The first trigger, trg_school_enrollment_check_row, is a row-level trigger that fires after an insert or update of the ENROLLMENT column in the SCHOOL table. It increments the g_index variable and stores the SCHOOL_ID from the newly inserted or updated row into the g_school_ids array at the current index. The second trigger, trg_school_enrollment_check_stmt, is a statement-level trigger that activates after an insert or update on the SCHOOL table. It calculates the average enrollment across all schools by selecting the average ENROLLMENT into a local variable v_avg_enrollment. It then iterates over the g_school_ids array from index 1 to g_index, checking each school ID. For each school ID, it updates the DIVISION column in the SCHOOL_DETAILS table to 'Above Average' if the school's enrollment exceeds the average, or 'Below Average' otherwise. Additionally, if a school's enrollment is greater than 2000, it updates the CLASS column in SCHOOL_DETAILS to 'Large School'. It deletes any row in SCHOOL_DETAILS where the SCHOOL_ID matches the current school ID and the NICKNAME is 'Temporary'. It inserts a new row into SCHOOL_DETAILS with the current school ID and the current year as the LEAGUE, formatted as a string using TO_CHAR(SYSDATE, 'YYYY'). After processing all school IDs, it resets the g_index variable to zero."
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_player_position_mgmt that fires for DELETE operations on the PLAYER table, which first declares a record type with fields player_id of type NUMBER, school_id of type NUMBER, and position of type VARCHAR2(255), and a nested table type of that record, then instantiates a global collection variable g_deleted_players of that nested table type; within its AFTER EACH ROW section, it extends the global collection and populates the next element with the OLD.PLAYER_ID, OLD.SCHOOL_ID, and OLD.POSITION values from the currently deleted row; within its AFTER STATEMENT section, it declares local variables v_remaining_players of type NUMBER, v_school_type of type VARCHAR2(255), and v_school_found of type BOOLEAN, then loops through each record stored in the g_deleted_players collection, and for each iteration, it selects the COUNT of remaining players from the PLAYER table where the SCHOOL_ID equals the current record's school_id into v_remaining_players, then uses a nested block with exception handling to attempt to select the DAY_OR_BOARDING column from the SCHOOL table where SCHOOL_ID equals the current record's school_id into v_school_type, setting v_school_found to TRUE if successful, or catching the NO_DATA_FOUND exception to set v_school_found to FALSE and v_school_type to NULL; then, based on a conditional logic chain, if the current record's position field equals the string 'First Baseman', it deletes a single row from the SCHOOL_PERFORMANCE table where SCHOOL_ID equals the current record's school_id using ROWNUM = 1; otherwise, if v_remaining_players equals 0, it updates the SCHOOL table by setting the ENROLLMENT column to 0 for the row where SCHOOL_ID equals the current record's school_id; otherwise, if v_school_found is TRUE and v_school_type equals the string 'Day & Boarding', it uses a nested block to attempt to insert a new row into the SCHOOL_DETAILS table with SCHOOL_ID set to the current record's school_id and DIVISION set to 'Alumni', catching the DUP_VAL_ON_INDEX exception to instead update the existing SCHOOL_DETAILS row for that SCHOOL_ID by setting its DIVISION column to 'Alumni'; otherwise, if v_school_found is TRUE, it uses another nested block to attempt to update the SCHOOL_DETAILS table by setting the COLORS column to 'Memorial Colors' for the row where SCHOOL_ID equals the current record's school_id, catching the NO_DATA_FOUND exception to take no action; after processing all records in the collection, the trigger deletes all elements from the g_deleted_players collection.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_player_position_mgmt\nFOR DELETE ON PLAYER\nCOMPOUND TRIGGER\n    TYPE deleted_player_rec IS RECORD (\n        player_id NUMBER,\n        school_id NUMBER,\n        position VARCHAR2(255)\n    );\n    TYPE deleted_players_t IS TABLE OF deleted_player_rec;\n    g_deleted_players deleted_players_t := deleted_players_t();\n    \n    AFTER EACH ROW IS\n    BEGIN\n        g_deleted_players.EXTEND;\n        g_deleted_players(g_deleted_players.COUNT).player_id := :OLD.PLAYER_ID;\n        g_deleted_players(g_deleted_players.COUNT).school_id := :OLD.SCHOOL_ID;\n        g_deleted_players(g_deleted_players.COUNT).position := :OLD.POSITION;\n    END AFTER EACH ROW;\n    \n    AFTER STATEMENT IS\n        v_remaining_players NUMBER;\n        v_school_type VARCHAR2(255);\n        v_school_found BOOLEAN;\n    BEGIN\n        FOR i IN 1..g_deleted_players.COUNT LOOP\n            -- Get remaining players count for this school\n            SELECT COUNT(*) INTO v_remaining_players \n            FROM PLAYER \n            WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n            \n            -- Get school type with exception handling\n            BEGIN\n                SELECT DAY_OR_BOARDING INTO v_school_type \n                FROM SCHOOL \n                WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n                v_school_found := TRUE;\n            EXCEPTION\n                WHEN NO_DATA_FOUND THEN\n                    v_school_found := FALSE;\n                    v_school_type := NULL;\n            END;\n            \n            -- Execute logic based on conditions\n            IF g_deleted_players(i).position = 'First Baseman' THEN\n                DELETE FROM SCHOOL_PERFORMANCE \n                WHERE SCHOOL_ID = g_deleted_players(i).school_id AND ROWNUM = 1;\n            ELSIF v_remaining_players = 0 THEN\n                UPDATE SCHOOL SET ENROLLMENT = 0 \n                WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n            ELSIF v_school_found AND v_school_type = 'Day & Boarding' THEN\n                BEGIN\n                    INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, DIVISION) \n                    VALUES (g_deleted_players(i).school_id, 'Alumni');\n                EXCEPTION\n                    WHEN DUP_VAL_ON_INDEX THEN\n                        UPDATE SCHOOL_DETAILS SET DIVISION = 'Alumni'\n                        WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n                END;\n            ELSIF v_school_found THEN\n                BEGIN\n                    UPDATE SCHOOL_DETAILS SET COLORS = 'Memorial Colors' \n                    WHERE SCHOOL_ID = g_deleted_players(i).school_id;\n                EXCEPTION\n                    WHEN NO_DATA_FOUND THEN\n                        NULL; -- SCHOOL_DETAILS record doesn't exist\n                END;\n            END IF;\n        END LOOP;\n        \n        g_deleted_players.DELETE;\n    END AFTER STATEMENT;\nEND trg_player_position_mgmt;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "DELETE FROM PLAYER WHERE PLAYER_ID = 1",
      "DELETE FROM PLAYER WHERE PLAYER_ID = 2",
      "DELETE FROM PLAYER WHERE PLAYER_ID = 3",
      "DELETE FROM PLAYER WHERE PLAYER_ID = 4",
      "DELETE FROM PLAYER WHERE PLAYER_ID = 5"
    ],
    "summary": "Create a compound trigger named trg_player_position_mgmt for DELETE on the PLAYER table. Declare a global collection to store deleted player records. In the AFTER EACH ROW section, add the OLD values to the collection. In the AFTER STATEMENT section, for each deleted player: get the count of remaining players and try to fetch the school type. If the player's position was 'First Baseman', delete one related SCHOOL_PERFORMANCE row. Else if no players remain, set the school's enrollment to 0. Else if the school type is 'Day & Boarding', insert or update an 'Alumni' DIVISION in SCHOOL_DETAILS. Else if the school exists, attempt to update its SCHOOL_DETAILS colors to 'Memorial Colors'. Finally, clear the collection.",
    "natural_language": "Create a compound trigger called trg_player_position_mgmt for DELETE operations on the PLAYER table. First, declare a global collection to hold deleted player records. In the AFTER EACH ROW section, store the OLD row values into this collection. Then, in the AFTER STATEMENT section, process each deleted player: count the remaining players and try to get the school type. If the player's position was 'First Baseman', delete one corresponding row from SCHOOL_PERFORMANCE. Otherwise, if no players are left, set the school's enrollment to 0. Alternatively, if the school type is 'Day & Boarding', insert or update an 'Alumni' DIVISION in SCHOOL_DETAILS. If the school exists instead, try to update its SCHOOL_DETAILS colors to 'Memorial Colors'. Finally, empty the collection.",
    "id": 14,
    "generated_ir": "Write an Oracle PL/SQL compound trigger named trg_player_position_mgmt that is defined to fire automatically for DELETE operations on the PLAYER table. The trigger consists of multiple timing points: it declares a global collection to temporarily hold records of deleted players, then executes logic in the AFTER EACH ROW section and further logic in the AFTER STATEMENT section.\n\nFirst, the trigger declares a global collection type, likely a nested table or varray, to store the deleted player rows. This collection is declared at the trigger level so it persists across the different sections. The collection holds records that include the PLAYER_ID, TEAM, AGE, POSITION, and SCHOOL_ID from the deleted row.\n\nIn the AFTER EACH ROW section, which executes once for each row deleted from the PLAYER table, the trigger stores the values of the deleted row into the global collection. Specifically, it captures the OLD.PLAYER_ID, OLD.TEAM, OLD.AGE, OLD.POSITION, and OLD.SCHOOL_ID from the pseudorecord representing the row before deletion and adds them as a record to the collection.\n\nIn the AFTER STATEMENT section, which executes once after all rows have been deleted from the PLAYER table for the DELETE statement, the trigger processes each deleted player record stored in the collection. For each record, it performs a series of operations based on conditions.\n\nFirst, it counts the remaining players in the PLAYER table for the same SCHOOL_ID as the deleted player. This is done by executing a SELECT COUNT(*) operation from the PLAYER table where SCHOOL_ID equals the SCHOOL_ID from the current deleted player record.\n\nSecond, it attempts to retrieve the school type for the same SCHOOL_ID by executing a SELECT operation on the SCHOOL table to fetch the DAY_OR_BOARDING column where SCHOOL_ID matches the deleted player's SCHOOL_ID. This value is stored in a local variable.\n\nThen, based on the deleted player's POSITION and the results of the above queries, it executes conditional logic:\n\nIf the deleted player's POSITION is exactly 'First Baseman', it deletes one corresponding row from the SCHOOL_PERFORMANCE table. The deletion targets a row where SCHOOL_ID equals the deleted player's SCHOOL_ID. Since SCHOOL_PERFORMANCE has a composite primary key on SCHOOL_ID and SCHOOL_YEAR, the trigger may delete an arbitrary matching row, such as the first one found, unless further ordering is specified.\n\nOtherwise, if the count of remaining players for that SCHOOL_ID is zero, it updates the SCHOOL table by setting the ENROLLMENT column to 0 for the row where SCHOOL_ID equals the deleted player's SCHOOL_ID.\n\nAlternatively, if the school type retrieved earlier (DAY_OR_BOARDING) is exactly 'Day & Boarding', it performs an insert or update on the SCHOOL_DETAILS table. Specifically, it attempts to insert a new row into SCHOOL_DETAILS with the SCHOOL_ID set to the deleted player's SCHOOL_ID and the DIVISION column set to 'Alumni'. If a row with that SCHOOL_ID already exists in SCHOOL_DETAILS (which would cause a primary key violation), it instead updates the existing row by setting the DIVISION column to 'Alumni'.\n\nIf the school exists in the SCHOOL table (i.e., the earlier SELECT on SCHOOL returned a row), it attempts to update the SCHOOL_DETAILS table by setting the COLORS column to 'Memorial Colors' for the row where SCHOOL_ID equals the deleted player's SCHOOL_ID. This update only occurs if such a row exists in SCHOOL_DETAILS.\n\nAfter processing all deleted player records in the collection, the trigger empties the collection to clear its contents.\n\nThe trigger does not return a value but performs side effects on the SCHOOL_PERFORMANCE, SCHOOL, and SCHOOL_DETAILS tables based on the deletions from the PLAYER table."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_warehouse_capacity` that is activated `AFTER` an `INSERT` operation occurs on the `BOXES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `BOXES` table. Upon activation, the trigger performs a single `UPDATE` operation on the `WAREHOUSES` table. The `UPDATE` statement modifies the `CAPACITY` column of the `WAREHOUSES` table by decrementing its current value by `1`. This modification is applied only to the row(s) in the `WAREHOUSES` table where the `CODE` column matches the value of the `WAREHOUSE` column from the newly inserted row in the `BOXES` table. The `:NEW.WAREHOUSE` refers to the value of the `WAREHOUSE` column in the row that has just been inserted into the `BOXES` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_warehouse_capacity\nAFTER INSERT ON BOXES\nFOR EACH ROW\nBEGIN\n    UPDATE WAREHOUSES\n    SET CAPACITY = CAPACITY - 1\n    WHERE CODE = :NEW.WAREHOUSE;\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B001', 'Books', 100, 1)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B002', 'Electronics', 500, 2)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B003', 'Clothes', 75, 3)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B004', 'Tools', 200, 1)",
      "INSERT INTO BOXES (CODE, CONTENTS, VALUE, WAREHOUSE) VALUES ('B005', 'Toys', 50, 2)"
    ],
    "summary": "Create an AFTER INSERT FOR EACH ROW trigger named trg_update_warehouse_capacity on the BOXES table. For each new row, update the WAREHOUSES table by decrementing the CAPACITY by 1 where the WAREHOUSES.CODE matches the new row's :NEW.WAREHOUSE value.",
    "natural_language": "How can I create an AFTER INSERT FOR EACH ROW trigger called trg_update_warehouse_capacity on the BOXES table that, for each new row, updates the WAREHOUSES table to decrement the CAPACITY by 1 where the WAREHOUSES.CODE matches the new row's :NEW.WAREHOUSE value?",
    "id": 15,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_update_warehouse_capacity` that is activated `AFTER` an `INSERT` operation occurs on the `BOXES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is inserted into the `BOXES` table. Upon activation, the trigger performs a single `UPDATE` operation on the `WAREHOUSES` table. The `UPDATE` statement modifies the `CAPACITY` column of the `WAREHOUSES` table by decrementing its current value by `1`. This modification is applied only to the row(s) in the `WAREHOUSES` table where the `CODE` column matches the value of the `WAREHOUSE` column from the newly inserted row in the `BOXES` table. The `:NEW.WAREHOUSE` refers to the value of the `WAREHOUSE` column in the row that has just been inserted into the `BOXES` table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_resident_cleanup that is executed before a delete operation on the RESIDENTS table for each row being deleted. The trigger begins by declaring a local variable v_event_count of type NUMBER to store the count of related records. It then performs a SELECT operation to count the number of records in the CUSTOMER_EVENTS table where the RESIDENT_ID column matches the RESIDENT_ID of the row being deleted from the RESIDENTS table, storing this count in v_event_count. Following this, the trigger executes a DELETE operation on the CUSTOMER_EVENT_NOTES table to remove records where the CUSTOMER_EVENT_ID column matches any CUSTOMER_EVENT_ID from the CUSTOMER_EVENTS table that has the same RESIDENT_ID as the row being deleted. This is achieved using a subquery that selects CUSTOMER_EVENT_ID from CUSTOMER_EVENTS where RESIDENT_ID equals :OLD.RESIDENT_ID, which refers to the RESIDENT_ID of the row being deleted. Subsequently, the trigger performs another DELETE operation on the CUSTOMER_EVENT_NOTES table to remove records directly where the RESIDENT_ID column matches :OLD.RESIDENT_ID. Finally, the trigger deletes records from the CUSTOMER_EVENTS table where the RESIDENT_ID column matches :OLD.RESIDENT_ID, effectively cleaning up all related records in both CUSTOMER_EVENT_NOTES and CUSTOMER_EVENTS tables before the deletion of the row in the RESIDENTS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_resident_cleanup\nBEFORE DELETE ON RESIDENTS\nFOR EACH ROW\nDECLARE\n   v_event_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_event_count FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :OLD.RESIDENT_ID;\n   \n   -- Delete child records first - CUSTOMER_EVENT_NOTES that reference CUSTOMER_EVENTS to be deleted\n   DELETE FROM CUSTOMER_EVENT_NOTES \n   WHERE CUSTOMER_EVENT_ID IN (\n       SELECT CUSTOMER_EVENT_ID \n       FROM CUSTOMER_EVENTS \n       WHERE RESIDENT_ID = :OLD.RESIDENT_ID\n   );\n   \n   -- Also delete CUSTOMER_EVENT_NOTES directly by RESIDENT_ID\n   DELETE FROM CUSTOMER_EVENT_NOTES WHERE RESIDENT_ID = :OLD.RESIDENT_ID;\n   \n   -- Now delete parent records - CUSTOMER_EVENTS\n   DELETE FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :OLD.RESIDENT_ID;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "THINGS",
      "TIMED_LOCATIONS_OF_THINGS"
    ],
    "call_sqls": [
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 6",
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 10",
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 23",
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 28",
      "DELETE FROM RESIDENTS WHERE RESIDENT_ID = 37"
    ],
    "summary": "Create a BEFORE DELETE FOR EACH ROW trigger named trg_resident_cleanup on the RESIDENTS table. The trigger should first count related events, then delete all associated records from CUSTOMER_EVENT_NOTES and CUSTOMER_EVENTS tables where the RESIDENT_ID matches the deleted resident.",
    "natural_language": "Before deleting a resident, count their related events and remove all associated records from the CUSTOMER_EVENT_NOTES and CUSTOMER_EVENTS tables. Implement this logic in a BEFORE DELETE FOR EACH ROW trigger named trg_resident_cleanup on the RESIDENTS table.",
    "id": 16,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_resident_cleanup that is executed before a delete operation on the RESIDENTS table for each row being deleted. The trigger begins by declaring a local variable v_event_count of type NUMBER to store the count of related records. It then performs a SELECT operation to count the number of records in the CUSTOMER_EVENTS table where the RESIDENT_ID column matches the RESIDENT_ID of the row being deleted from the RESIDENTS table, storing this count in v_event_count. Following this, the trigger executes a DELETE operation on the CUSTOMER_EVENT_NOTES table to remove records where the CUSTOMER_EVENT_ID column matches any CUSTOMER_EVENT_ID from the CUSTOMER_EVENTS table that has the same RESIDENT_ID as the row being deleted. This is achieved using a subquery that selects CUSTOMER_EVENT_ID from CUSTOMER_EVENTS where RESIDENT_ID equals :OLD.RESIDENT_ID, which refers to the RESIDENT_ID of the row being deleted. Subsequently, the trigger performs another DELETE operation on the CUSTOMER_EVENT_NOTES table to remove records directly where the RESIDENT_ID column matches :OLD.RESIDENT_ID. Finally, the trigger deletes records from the CUSTOMER_EVENTS table where the RESIDENT_ID column matches :OLD.RESIDENT_ID, effectively cleaning up all related records in both CUSTOMER_EVENT_NOTES and CUSTOMER_EVENTS tables before the deletion of the row in the RESIDENTS table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that is executed before an INSERT operation on the PRODUCER table and modifies the value of the BIRTH_CITY column in the row being inserted. The trigger uses the pseudo-record :NEW, which represents the new row being inserted into the table, and specifically accesses the BIRTH_CITY column of this record. The trigger applies the TRIM function to the value of :NEW.BIRTH_CITY, which removes any leading and trailing whitespace characters from the string. The modified value is then assigned back to the :NEW.BIRTH_CITY column, ensuring that the inserted value in the BIRTH_CITY column does not contain unnecessary whitespace at the beginning or end of the string. The trigger operates on each row being inserted into the PRODUCER table, as indicated by the FOR EACH ROW clause, and does not perform any conditional checks or additional operations beyond trimming the whitespace from the BIRTH_CITY column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_producer_birth_city_trim\nBEFORE INSERT ON PRODUCER\nFOR EACH ROW\nBEGIN\n  :NEW.BIRTH_CITY := TRIM(:NEW.BIRTH_CITY);\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "DIRECTOR",
      "PRODUCER",
      "WRITER",
      "COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (1, 'Male', 'John Doe', 'American', ' New York ', 1970)",
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (2, 'Female', 'Jane Smith', 'British', ' London ', 1985)",
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (3, 'Male', 'Peter Jones', 'Australian', ' Sydney ', 1960)",
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (4, 'Female', 'Mary Brown', 'Canadian', ' Toronto ', 1990)",
      "INSERT INTO PRODUCER (PID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (5, 'Male', 'David Green', 'German', ' Berlin ', 1975)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger on the PRODUCER table. Trim leading and trailing whitespace from the new BIRTH_CITY value before insertion.",
    "natural_language": "Create trigger to trim BIRTH_CITY whitespace before inserting into PRODUCER.",
    "id": 17,
    "generated_ir": "Write an Oracle PL/SQL trigger that is executed before an INSERT operation on the PRODUCER table and modifies the value of the BIRTH_CITY column in the row being inserted. The trigger uses the pseudo-record :NEW, which represents the new row being inserted into the table, and specifically accesses the BIRTH_CITY column of this record. The trigger applies the TRIM function to the value of :NEW.BIRTH_CITY, which removes any leading and trailing whitespace characters from the string. The modified value is then assigned back to the :NEW.BIRTH_CITY column, ensuring that the inserted value in the BIRTH_CITY column does not contain unnecessary whitespace at the beginning or end of the string. The trigger operates on each row being inserted into the PRODUCER table, as indicated by the FOR EACH ROW clause, and does not perform any conditional checks or additional operations beyond trimming the whitespace from the BIRTH_CITY column."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_problem_category_update that fires before any update operation on the PROBLEM_LOG table, specifically when the PROBLEM_CATEGORY_CODE column is being modified, and executes once for each row being updated. The trigger declares two local VARCHAR2 variables, v_old_category_desc and v_new_category_desc, each with a maximum length of 255 characters. For the row being updated, the trigger first queries the PROBLEM_CATEGORY_CODES table to retrieve the PROBLEM_CATEGORY_DESCRIPTION associated with the original PROBLEM_CATEGORY_CODE value, which is accessed via the :OLD.PROBLEM_CATEGORY_CODE pseudorecord, and stores this description in the v_old_category_desc variable. It then queries the same PROBLEM_CATEGORY_CODES table again to retrieve the PROBLEM_CATEGORY_DESCRIPTION associated with the new PROBLEM_CATEGORY_CODE value, which is accessed via the :NEW.PROBLEM_CATEGORY_CODE pseudorecord, and stores this description in the v_new_category_desc variable. The trigger then compares the two retrieved description strings using an IF statement: if v_old_category_desc is not equal to v_new_category_desc, it constructs a string by concatenating the literal 'Category changed from ', the value of v_old_category_desc, the literal ' to ', and the value of v_new_category_desc, and assigns this resulting string to the :NEW.LOG_ENTRY_DESCRIPTION column of the row being updated in the PROBLEM_LOG table; otherwise, if the descriptions are equal, it constructs a string by concatenating the literal 'Category remains ' and the value of v_new_category_desc, and assigns this resulting string to the :NEW.LOG_ENTRY_DESCRIPTION column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_problem_category_update\nBEFORE UPDATE OF PROBLEM_CATEGORY_CODE ON PROBLEM_LOG\nFOR EACH ROW\nDECLARE\n    v_old_category_desc VARCHAR2(255);\n    v_new_category_desc VARCHAR2(255);\nBEGIN\n    SELECT PROBLEM_CATEGORY_DESCRIPTION INTO v_old_category_desc\n    FROM PROBLEM_CATEGORY_CODES\n    WHERE PROBLEM_CATEGORY_CODE = :OLD.PROBLEM_CATEGORY_CODE;\n\n    SELECT PROBLEM_CATEGORY_DESCRIPTION INTO v_new_category_desc\n    FROM PROBLEM_CATEGORY_CODES\n    WHERE PROBLEM_CATEGORY_CODE = :NEW.PROBLEM_CATEGORY_CODE;\n\n    IF v_old_category_desc != v_new_category_desc THEN\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Category changed from ' || v_old_category_desc || ' to ' || v_new_category_desc;\n    ELSE\n        :NEW.LOG_ENTRY_DESCRIPTION := 'Category remains ' || v_new_category_desc;\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES",
      "PRODUCT",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'GUI' WHERE PROBLEM_LOG_ID = 1",
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'Middleware' WHERE PROBLEM_LOG_ID = 2 AND PROBLEM_CATEGORY_CODE = 'GUI'",
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'Datatabase' WHERE PROBLEM_LOG_ID = 3",
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'GUI' WHERE PROBLEM_ID = 11",
      "UPDATE PROBLEM_LOG SET PROBLEM_CATEGORY_CODE = 'Datatabase' WHERE PROBLEM_CATEGORY_CODE = 'Middleware'"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_problem_category_update on the PROBLEM_LOG table that fires when PROBLEM_CATEGORY_CODE changes. For each updated row, retrieve the old and new category descriptions from PROBLEM_CATEGORY_CODES. If descriptions differ, set LOG_ENTRY_DESCRIPTION to 'Category changed from [old description] to [new description]'. Otherwise, set it to 'Category remains [new description]'.",
    "natural_language": "Construct a BEFORE UPDATE row-level trigger, which you should name trg_problem_category_update, specifically for the PROBLEM_LOG table; this trigger must activate precisely when the value within the PROBLEM_CATEGORY_CODE column is modified. For every individual row that undergoes an update, you must carefully fetch both the previous and the updated category descriptions directly from the PROBLEM_CATEGORY_CODES reference table. In the event that these two retrieved descriptions are not identical, you are to populate the LOG_ENTRY_DESCRIPTION field with a detailed message stating 'Category changed from [old description] to [new description]'. Conversely, if the descriptions are exactly the same, you should instead set that field to a message reading 'Category remains [new description]'.",
    "id": 18,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_problem_category_update that fires before any update operation on the PROBLEM_LOG table for each affected row, specifically when the PROBLEM_CATEGORY_CODE column is being modified. The trigger declares two local variables: v_old_description of type VARCHAR2(255) to hold the description of the old problem category, and v_new_description of type VARCHAR2(255) to hold the description of the new problem category. For each row being updated, the trigger performs a series of operations: first, it checks if the PROBLEM_CATEGORY_CODE column is being changed by comparing the old PROBLEM_CATEGORY_CODE value with the new PROBLEM_CATEGORY_CODE value using the UPDATING function or direct comparison; if a change is detected, it proceeds to fetch the corresponding descriptions from the PROBLEM_CATEGORY_CODES table. It selects the PROBLEM_CATEGORY_DESCRIPTION from the PROBLEM_CATEGORY_CODES table into v_old_description where the PROBLEM_CATEGORY_CODE matches the old PROBLEM_CATEGORY_CODE value from the PROBLEM_LOG row before the update. Similarly, it selects the PROBLEM_CATEGORY_DESCRIPTION from the PROBLEM_CATEGORY_CODES table into v_new_description where the PROBLEM_CATEGORY_CODE matches the new PROBLEM_CATEGORY_CODE value being set in the update. After retrieving both descriptions, the trigger compares v_old_description and v_new_description. If they are not identical, it constructs a message string by concatenating the literal 'Category changed from ', followed by v_old_description, then the literal ' to ', and finally v_new_description, and assigns this concatenated string to the new LOG_ENTRY_DESCRIPTION column value for the updated row. If the descriptions are identical, it constructs a message string by concatenating the literal 'Category remains ', followed by v_new_description, and assigns this string to the new LOG_ENTRY_DESCRIPTION column value. The trigger ensures that the LOG_ENTRY_DESCRIPTION is updated only when the PROBLEM_CATEGORY_CODE column is modified, and it uses the reference table PROBLEM_CATEGORY_CODES to map category codes to their descriptions for both the old and new values."
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_route_location_count that fires for INSERT operations on the DELIVERY_ROUTE_LOCATIONS table, which first declares a private collection type named route_id_list_t as a table of NUMBER and initializes a global variable g_route_ids of that type, then in its AFTER EACH ROW section extends the g_route_ids collection and assigns the newly inserted ROUTE_ID value from the :NEW pseudorecord into the last position of the collection, and subsequently in its AFTER STATEMENT section declares a local variable v_count of type NUMBER, then iterates through each index from 1 to the total count of elements in the g_route_ids collection, and for each iteration performs a SELECT COUNT(*) query from the DELIVERY_ROUTE_LOCATIONS table into v_count where the ROUTE_ID column equals the value stored at the current index in the g_route_ids collection, then checks if the modulus of v_count divided by 2 equals zero using the MOD function, and if true executes an UPDATE on the DELIVERY_ROUTES table setting the ROUTE_NAME column to the string literal 'Even Locations Route' for the row where the ROUTE_ID matches the current collection element, otherwise executes an UPDATE on the DELIVERY_ROUTES table setting the ROUTE_NAME column to the string literal 'Odd Locations Route' for the matching ROUTE_ID, and after the loop completes, invokes the DELETE method on the g_route_ids collection to remove all its elements.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_route_location_count\nFOR INSERT ON DELIVERY_ROUTE_LOCATIONS\nCOMPOUND TRIGGER\n\n    TYPE route_id_list_t IS TABLE OF NUMBER;\n    g_route_ids route_id_list_t := route_id_list_t();\n\n    AFTER EACH ROW IS\n    BEGIN\n        g_route_ids.EXTEND;\n        g_route_ids(g_route_ids.COUNT) := :NEW.ROUTE_ID;\n    END AFTER EACH ROW;\n\n    AFTER STATEMENT IS\n        v_count NUMBER;\n    BEGIN\n        FOR i IN 1..g_route_ids.COUNT LOOP\n            SELECT COUNT(*) INTO v_count \n            FROM DELIVERY_ROUTE_LOCATIONS \n            WHERE ROUTE_ID = g_route_ids(i);\n            \n            IF MOD(v_count, 2) = 0 THEN\n                UPDATE DELIVERY_ROUTES \n                SET ROUTE_NAME = 'Even Locations Route' \n                WHERE ROUTE_ID = g_route_ids(i);\n            ELSE\n                UPDATE DELIVERY_ROUTES \n                SET ROUTE_NAME = 'Odd Locations Route' \n                WHERE ROUTE_ID = g_route_ids(i);\n            END IF;\n        END LOOP;\n        \n        g_route_ids.DELETE;\n    END AFTER STATEMENT;\n\nEND trg_route_location_count;",
    "database_name": "customer_deliveries",
    "tables": [
      "ACTUAL_ORDERS",
      "ACTUAL_ORDER_PRODUCTS",
      "ORDER_DELIVERIES",
      "DELIVERY_ROUTE_LOCATIONS",
      "DELIVERY_ROUTES",
      "TRUCKS"
    ],
    "call_sqls": [
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('27 City Rd', 11, 5, 'Labadie-Crooks')",
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('30 Sam Rd', 7, 13, 'VonRueden, Schmeler and Fay')",
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('67 LV Rd', 11, 6, 'Carter, Pfannerstill and Ruthe...')",
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('45 Main St', 7, 8, 'New Location Name')",
      "INSERT INTO DELIVERY_ROUTE_LOCATIONS (LOCATION_CODE, ROUTE_ID, LOCATION_ADDRESS_ID, LOCATION_NAME) VALUES ('99 Elm St', 11, 9, 'Another Location Name')"
    ],
    "summary": "Create a compound trigger named trg_route_location_count for INSERT operations on the DELIVERY_ROUTE_LOCATIONS table. After each row, store the inserted ROUTE_ID in a collection. After the statement, for each stored ROUTE_ID, count its locations in the table. If the count is even, update the corresponding row in DELIVERY_ROUTES to set ROUTE_NAME to 'Even Locations Route'. If odd, set it to 'Odd Locations Route'. Finally, clear the collection.",
    "natural_language": "Please construct a compound trigger designated as trg_route_location_count to be activated upon INSERT operations targeting the DELIVERY_ROUTE_LOCATIONS table. Subsequent to each row insertion, the associated ROUTE_ID value is to be recorded within a collection. Following the completion of the statement, for every ROUTE_ID retained in said collection, ascertain the total count of its corresponding locations within the table. Should this count be determined to be an even number, proceed to update the relevant entry in the DELIVERY_ROUTES table, setting its ROUTE_NAME field to 'Even Locations Route'. Conversely, if the count is determined to be odd, the ROUTE_NAME field should be updated to 'Odd Locations Route'. Conclude the process by purging the contents of the collection.",
    "id": 19,
    "generated_ir": "Write an Oracle PL/SQL compound trigger named trg_route_location_count that is activated after each row insertion operation on the DELIVERY_ROUTE_LOCATIONS table. The trigger is structured with multiple timing sections: AFTER EACH ROW and AFTER STATEMENT.\n\nIn the AFTER EACH ROW section, for every newly inserted row, the trigger captures the ROUTE_ID value from the :NEW.ROUTE_ID column and stores it into a PL/SQL collection variable declared as a nested table of NUMBER type. This collection is used to accumulate all ROUTE_ID values affected by the INSERT statement.\n\nIn the AFTER STATEMENT section, after the entire INSERT operation is complete, the trigger processes each distinct ROUTE_ID stored in the collection. For each ROUTE_ID, it performs a SELECT COUNT(*) query on the DELIVERY_ROUTE_LOCATIONS table, counting all rows where the ROUTE_ID column matches the current ROUTE_ID from the collection. This count represents the total number of locations associated with that route.\n\nThe trigger then evaluates whether this count is even or odd using the MOD function, calculating MOD(count, 2). If the result is 0, indicating an even count, it executes an UPDATE statement on the DELIVERY_ROUTES table, setting the ROUTE_NAME column to the string 'Even Locations Route' for the row where the ROUTE_ID matches the current ROUTE_ID from the collection. If the result is 1, indicating an odd count, it executes an UPDATE statement on the DELIVERY_ROUTES table, setting the ROUTE_NAME column to the string 'Odd Locations Route' for the corresponding row.\n\nAfter processing all ROUTE_ID values in the collection, the trigger clears the collection by removing all elements, ensuring it is empty for subsequent operations."
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_update_box_value that fires for any update operation on the contents column of the boxes table, and which uses two global collections: one of type t_warehouse_list, which is a nested table of the warehouse column's data type from the boxes table, and another of type t_contents_list, which is a nested table of the contents column's data type from the boxes table, initializing these collections as empty. In the BEFORE EACH ROW section, for each row being updated, the trigger extends both global collections by one element and then assigns the new warehouse value from the :NEW pseudorecord and the new contents value from the :NEW pseudorecord into the last positions of the g_warehouses and g_contents collections, respectively. In the AFTER STATEMENT section, after all row-level operations are complete, the trigger iterates through the populated global collections using a FOR loop from index 1 to the count of elements in the g_warehouses collection, and for each index i, it executes an update statement on the boxes table, setting the value column to its current value multiplied by 1.1 for every row where the warehouse column equals the value stored in g_warehouses(i) and the contents column equals the value stored in g_contents(i). Finally, after completing the loop, the trigger deletes all elements from both the g_warehouses and g_contents collections.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_box_value\nFOR UPDATE OF contents ON boxes\nCOMPOUND TRIGGER\n    TYPE t_warehouse_list IS TABLE OF boxes.warehouse%TYPE;\n    TYPE t_contents_list IS TABLE OF boxes.contents%TYPE;\n    \n    g_warehouses t_warehouse_list := t_warehouse_list();\n    g_contents   t_contents_list := t_contents_list();\n    \n    BEFORE EACH ROW IS\n    BEGIN\n        g_warehouses.EXTEND;\n        g_contents.EXTEND;\n        g_warehouses(g_warehouses.LAST) := :NEW.warehouse;\n        g_contents(g_contents.LAST) := :NEW.contents;\n    END BEFORE EACH ROW;\n    \n    AFTER STATEMENT IS\n    BEGIN\n        FOR i IN 1..g_warehouses.COUNT LOOP\n            UPDATE boxes\n            SET value = value * 1.1\n            WHERE warehouse = g_warehouses(i)\n            AND contents = g_contents(i);\n        END LOOP;\n        \n        g_warehouses.DELETE;\n        g_contents.DELETE;\n    END AFTER STATEMENT;\nEND trg_update_box_value;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "UPDATE boxes SET contents = 'Rocks' WHERE code = '0MN7'",
      "UPDATE boxes SET contents = 'Scissors' WHERE code = '4H8P'",
      "UPDATE boxes SET contents = 'Rocks' WHERE code = '4RT3'",
      "UPDATE boxes SET contents = 'Scissors' WHERE warehouse = 1",
      "UPDATE boxes SET contents = 'Rocks' WHERE warehouse = 3"
    ],
    "summary": "Create a compound trigger named trg_update_box_value for updates on the contents column of the boxes table. Declare two global nested table collections: g_warehouses (type of warehouse column) and g_contents (type of contents column), initialized as empty. In the BEFORE EACH ROW section, extend both collections and store the :NEW.warehouse and :NEW.contents values. In the AFTER STATEMENT section, loop through the collections. For each index i, update the boxes table, setting value = value * 1.1 where warehouse = g_warehouses(i) and contents = g_contents(i). Finally, delete all elements from both collections.",
    "natural_language": "Alright, so we need to whip up a compound trigger called trg_update_box_value that kicks in whenever the contents column in the boxes table gets updated. First off, set up two global collections as nested tables: one for warehouses (matching the warehouse column's type) and another for contents (matching the contents column's type). Start 'em off empty. In the BEFORE EACH ROW part, just add the new :NEW.warehouse and :NEW.contents values into those collections. Then, in the AFTER STATEMENT section, loop through everything we've collected. For each item in the loop, update the boxes table by bumping up the value by 10% (so, value = value * 1.1) but only for rows where the warehouse and contents match what we've got stored. Once that's all done, clear out both collections so they're ready for the next round.",
    "id": 20,
    "generated_ir": "Write an Oracle PL/SQL compound trigger named trg_update_box_value that is executed for each UPDATE operation on the boxes table that modifies the contents column. The trigger is defined with two distinct sections: a BEFORE EACH ROW section and an AFTER STATEMENT section. It uses two global nested table collections declared at the trigger level, each initialized as empty. The first collection, named something like g_warehouse_tab, is defined to store values of the same data type as the warehouse column in the boxes table, which is NUMBER. The second collection, named something like g_contents_tab, is defined to store values of the same data type as the contents column in the boxes table, which is VARCHAR2(255). In the BEFORE EACH ROW section, for each row being updated, the trigger adds the value of the :NEW.warehouse column (the new warehouse value for that row) to the g_warehouse_tab collection and the value of the :NEW.contents column (the new contents value for that row) to the g_contents_tab collection. This captures all warehouse and contents pairs from the updated rows in the current statement. Then, in the AFTER STATEMENT section, the trigger iterates through all elements stored in the collections using a loop, typically from the first to the last index. For each iteration, corresponding to a specific warehouse and contents pair, the trigger performs an UPDATE operation on the boxes table. It sets the value column to its current value multiplied by 1.1 (i.e., increasing it by 10%) for all rows in the boxes table where the warehouse column matches the current warehouse value from the g_warehouse_tab collection and the contents column matches the current contents value from the g_contents_tab collection. This update applies to all existing rows in the boxes table that have matching warehouse and contents values, not just the rows that were initially updated. After completing the loop and updating all relevant rows, the trigger clears both the g_warehouse_tab and g_contents_tab collections by removing all elements, resetting them to empty for subsequent trigger executions. The trigger does not return any value and operates automatically on the database tables boxes and warehouses, leveraging the relationship where boxes.warehouse references warehouses.code, though this relationship is not directly used in the update logic beyond matching warehouse values."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_company_sales_adjust` that is configured to execute `BEFORE` any `INSERT` operation is performed on the `COMPANY` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its body will execute once for every row that is being inserted into the `COMPANY` table. Within the trigger's execution block, the following operations are performed: First, the value of the `SALES_BILLION` column for the `NEW` row being inserted into the `COMPANY` table is updated by multiplying its current value by `1.1`. This effectively increases the `SALES_BILLION` value by 10%. Second, an `UPDATE` statement is executed on the `GAS_STATION` table. This `UPDATE` statement sets the value of the `LOCATION` column to its `UPPERCASE` equivalent for all rows in the `GAS_STATION` table where the `STATION_ID` column matches the result of the `MOD` (modulo) operation performed on the `COMPANY_ID` of the `NEW` row being inserted into the `COMPANY` table and the integer `100`. The `MOD` function returns the remainder of the division of `NEW.COMPANY_ID` by `100`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_company_sales_adjust\nBEFORE INSERT ON COMPANY\nFOR EACH ROW\nBEGIN\n    :NEW.SALES_BILLION := :NEW.SALES_BILLION * 1.1;\n    UPDATE GAS_STATION SET LOCATION = UPPER(LOCATION) WHERE STATION_ID = MOD(:NEW.COMPANY_ID, 100);\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (101, 5, 'New Company 1', 'USA', 'Tech', 100.0, 10.0, 50.0, 200.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (202, 6, 'New Company 2', 'Germany', 'Automotive', 200.0, 20.0, 100.0, 300.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (303, 7, 'New Company 3', 'Japan', 'Electronics', 150.0, 15.0, 75.0, 250.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (404, 8, 'New Company 4', 'China', 'Manufacturing', 250.0, 25.0, 125.0, 350.0)",
      "INSERT INTO COMPANY (COMPANY_ID, RANK, COMPANY, HEADQUARTERS, MAIN_INDUSTRY, SALES_BILLION, PROFITS_BILLION, ASSETS_BILLION, MARKET_VALUE) VALUES (505, 9, 'New Company 5', 'UK', 'Finance', 120.0, 12.0, 60.0, 220.0)"
    ],
    "summary": "Create a trigger named trg_company_sales_adjust that fires BEFORE INSERT on the COMPANY table for each row. Increase the new row's SALES_BILLION value by 10%. Then update the GAS_STATION table, setting the LOCATION to uppercase for all rows where STATION_ID equals MOD(:NEW.COMPANY_ID, 100).",
    "natural_language": "Before inserting into COMPANY, trigger trg_company_sales_adjust raises new SALES_BILLION by 10% and uppercases GAS_STATION.LOCATION where STATION_ID matches MOD(:NEW.COMPANY_ID, 100).",
    "id": 21,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_company_sales_adjust` that is configured to execute `BEFORE` any `INSERT` operation is performed on the `COMPANY` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its body will execute once for every row that is being inserted into the `COMPANY` table. Within the trigger's execution block, the following operations are performed: First, the value of the `SALES_BILLION` column for the `NEW` row being inserted into the `COMPANY` table is updated by multiplying its current value by `1.1`. This effectively increases the `SALES_BILLION` value by 10%. Second, an `UPDATE` statement is executed on the `GAS_STATION` table. This `UPDATE` statement sets the value of the `LOCATION` column to its `UPPERCASE` equivalent for all rows in the `GAS_STATION` table where the `STATION_ID` column matches the result of the `MOD` (modulo) operation performed on the `COMPANY_ID` of the `NEW` row being inserted into the `COMPANY` table and the integer `100`. The `MOD` function returns the remainder of the division of `NEW.COMPANY_ID` by `100`."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_check_country_population that is defined to fire automatically before any INSERT or UPDATE operation is committed to the COUNTRY table, executing once for each row being modified. The trigger declares a local variable v_coaster_count of type NUMBER. For each affected row, the trigger performs a SELECT statement that counts all rows in the ROLLER_COASTER table where the COUNTRY_ID column matches the new COUNTRY_ID value (referenced as :NEW.COUNTRY_ID) from the triggering row in the COUNTRY table, storing the result into v_coaster_count. Following this query, the trigger uses an IF-ELSIF-ELSE conditional block to modify the new POPULATION value (referenced as :NEW.POPULATION) for the row in the COUNTRY table. If v_coaster_count is greater than 5, it increases the :NEW.POPULATION by 1000. If v_coaster_count is between 1 and 5 inclusive, it increases the :NEW.POPULATION by 500. If v_coaster_count is 0, it increases the :NEW.POPULATION by 100.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_check_country_population\nBEFORE INSERT OR UPDATE ON COUNTRY\nFOR EACH ROW\nDECLARE\n    v_coaster_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_coaster_count FROM ROLLER_COASTER WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n    IF v_coaster_count > 5 THEN\n        :NEW.POPULATION := :NEW.POPULATION + 1000;\n    ELSIF v_coaster_count BETWEEN 1 AND 5 THEN\n        :NEW.POPULATION := :NEW.POPULATION + 500;\n    ELSE\n        :NEW.POPULATION := :NEW.POPULATION + 100;\n    END IF;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (4, 'Norway', 5370000, 385207, 'Norwegian')",
      "UPDATE COUNTRY SET POPULATION = 5400000 WHERE COUNTRY_ID = 1",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (5, 'Denmark', 5830000, 42933, 'Danish')",
      "UPDATE COUNTRY SET POPULATION = 5300000 WHERE COUNTRY_ID = 2",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (6, 'Iceland', 364000, 103000, 'Icelandic')"
    ],
    "summary": "Create a trigger named trg_check_country_population that fires before each row insert or update on the COUNTRY table. For each row, count the roller coasters for the new country ID. If the count is greater than 5, increase the new population by 1000. If the count is between 1 and 5, increase it by 500. If the count is 0, increase it by 100.",
    "natural_language": "Construct a trigger designated as trg_check_country_population, which is to be executed prior to each row insertion or update operation on the COUNTRY table. For every row processed, ascertain the quantity of roller coasters associated with the new country identifier. Should this count exceed five, augment the new population value by one thousand. In the event the count falls within the inclusive range of one to five, increase the population by five hundred. If the count is determined to be zero, then increase the population by one hundred.",
    "id": 22,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_check_country_population that is defined to fire automatically before any INSERT or UPDATE operation is committed to the COUNTRY table, executing once for each row being modified. The trigger declares a local variable v_coaster_count of type NUMBER. For each affected row, the trigger performs a SELECT statement that counts all rows in the ROLLER_COASTER table where the COUNTRY_ID column matches the new COUNTRY_ID value (referenced as :NEW.COUNTRY_ID) from the triggering row in the COUNTRY table, storing the result into v_coaster_count. Following this query, the trigger uses an IF-ELSIF-ELSE conditional block to modify the new POPULATION value (referenced as :NEW.POPULATION) for the row in the COUNTRY table. If v_coaster_count is greater than 5, it increases the :NEW.POPULATION by 1000. If v_coaster_count is between 1 and 5 inclusive, it increases the :NEW.POPULATION by 500. If v_coaster_count is 0, it increases the :NEW.POPULATION by 100."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_company_industry_agg that is executed after an update operation on the MAIN_INDUSTRY column of the COMPANY table. This trigger performs several operations: first, it declares three variables, v_max_sales, v_min_profits, and v_company_id, all of type NUMBER, to store the maximum sales, minimum profits, and maximum company ID, respectively. It then selects the maximum value from the SALES_BILLION column of the COMPANY table into the v_max_sales variable, and the minimum value from the PROFITS_BILLION column into the v_min_profits variable. Additionally, it retrieves the maximum value from the COMPANY_ID column into the v_company_id variable. Following these selections, the trigger updates the COMPANY table by increasing the MARKET_VALUE column by the result of the expression (v_max_sales - v_min_profits) / 10 for all rows where the SALES_BILLION value is greater than half of v_max_sales. Subsequently, the trigger inserts new records into the STATION_COMPANY table by selecting the STATION_ID from the GAS_STATION table and using the previously determined v_company_id and the ceiling value of v_max_sales divided by 100 as the RANK_OF_THE_YEAR. This insertion only occurs for gas stations that opened after the year 2000 and do not already have an entry in the STATION_COMPANY table with the same STATION_ID and COMPANY_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_company_industry_agg\nAFTER UPDATE OF MAIN_INDUSTRY ON COMPANY\nDECLARE\n    v_max_sales NUMBER;\n    v_min_profits NUMBER;\n    v_company_id NUMBER; -- Declare a variable to hold the MAX(COMPANY_ID)\nBEGIN\n    SELECT MAX(SALES_BILLION) INTO v_max_sales FROM COMPANY;\n    SELECT MIN(PROFITS_BILLION) INTO v_min_profits FROM COMPANY;\n    SELECT MAX(COMPANY_ID) INTO v_company_id FROM COMPANY; -- Get the company_id once\n\n    UPDATE COMPANY SET MARKET_VALUE = MARKET_VALUE + (v_max_sales - v_min_profits) / 10 WHERE SALES_BILLION > v_max_sales * 0.5;\n\n    INSERT INTO STATION_COMPANY (STATION_ID, COMPANY_ID, RANK_OF_THE_YEAR)\n    SELECT gs.STATION_ID, v_company_id, CEIL(v_max_sales/100)\n    FROM GAS_STATION gs\n    WHERE gs.OPEN_YEAR > 2000\n      AND NOT EXISTS (\n        SELECT 1\n        FROM STATION_COMPANY sc\n        WHERE sc.STATION_ID = gs.STATION_ID\n          AND sc.COMPANY_ID = v_company_id\n      );\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Renewable Energy' WHERE COMPANY_ID = 1",
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Technology' WHERE COMPANY_ID = 2",
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Finance' WHERE COMPANY_ID = 3",
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Healthcare' WHERE COMPANY_ID = 1",
      "UPDATE COMPANY SET MAIN_INDUSTRY = 'Automotive' WHERE COMPANY_ID = 2"
    ],
    "summary": "Create a trigger named trg_company_industry_agg that fires AFTER UPDATE on the MAIN_INDUSTRY column of the COMPANY table. Declare variables to store the maximum SALES_BILLION, minimum PROFITS_BILLION, and maximum COMPANY_ID. Select these values into the variables. Update the COMPANY table, increasing the MARKET_VALUE by (max_sales - min_profits) / 10 for rows where SALES_BILLION > half of the maximum sales. Insert new records into the STATION_COMPANY table by selecting STATION_ID from GAS_STATION where OPEN_YEAR > 2000, using the maximum company ID and the ceiling of (max_sales / 100) as RANK_OF_THE_YEAR, only for stations not already existing in STATION_COMPANY with the same IDs.",
    "natural_language": "Construct a trigger designated as trg_company_industry_agg, which is to be executed subsequent to an update operation on the MAIN_INDUSTRY column within the COMPANY table. It is necessary to declare variables for the purpose of storing the highest SALES_BILLION value, the lowest PROFITS_BILLION value, and the highest COMPANY_ID value. These aggregate values should be selected into their respective variables. Subsequently, perform an update on the COMPANY table, wherein the MARKET_VALUE is incremented by the quotient of (maximum sales minus minimum profits) divided by ten. This adjustment is to be applied exclusively to those rows where the SALES_BILLION figure exceeds fifty percent of the identified maximum sales. Furthermore, insert new records into the STATION_COMPANY table. This insertion should involve selecting the STATION_ID from the GAS_STATION table for stations established after the year 2000. Utilize the maximum company ID and the ceiling value of (maximum sales divided by one hundred) for the RANK_OF_THE_YEAR column. This operation must ensure that stations with identifiers already present in the STATION_COMPANY table are not duplicated.",
    "id": 23,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_company_industry_agg that is executed after an update operation on the MAIN_INDUSTRY column of the COMPANY table. This trigger performs several operations: first, it declares three variables, v_max_sales, v_min_profits, and v_company_id, all of type NUMBER, to store the maximum sales, minimum profits, and maximum company ID, respectively. It then selects the maximum value from the SALES_BILLION column of the COMPANY table into the v_max_sales variable, and the minimum value from the PROFITS_BILLION column into the v_min_profits variable. Additionally, it retrieves the maximum value from the COMPANY_ID column into the v_company_id variable. Following these selections, the trigger updates the COMPANY table by increasing the MARKET_VALUE column by the result of the expression (v_max_sales - v_min_profits) / 10 for all rows where the SALES_BILLION value is greater than half of v_max_sales. Subsequently, the trigger inserts new records into the STATION_COMPANY table by selecting the STATION_ID from the GAS_STATION table and using the previously determined v_company_id and the ceiling value of v_max_sales divided by 100 as the RANK_OF_THE_YEAR. This insertion only occurs for gas stations that opened after the year 2000 and do not already have an entry in the STATION_COMPANY table with the same STATION_ID and COMPANY_ID."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_reviewer_name_format that is executed before an insert operation on the REVIEWER table. This trigger operates on each row being inserted into the table. The trigger modifies the NAME column of the new row being inserted. Specifically, it transforms the NAME value such that the first character is converted to uppercase using the UPPER() function, and the rest of the characters are converted to lowercase using the LOWER() function. The transformation is achieved by concatenating the uppercase version of the first character, obtained using the UPPER(SUBSTR(:NEW.NAME, 1, 1)) expression, with the lowercase version of the remaining characters, obtained using the LOWER(SUBSTR(:NEW.NAME, 2)) expression. The :NEW.NAME syntax refers to the NAME column value of the row currently being inserted into the REVIEWER table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_reviewer_name_format\nBEFORE INSERT ON REVIEWER\nFOR EACH ROW\nBEGIN\n  :NEW.NAME := UPPER(SUBSTR(:NEW.NAME, 1, 1)) || LOWER(SUBSTR(:NEW.NAME, 2));\nEND;",
    "database_name": "movie_1",
    "tables": [
      "MOVIE",
      "RATING",
      "REVIEWER"
    ],
    "call_sqls": [
      "INSERT INTO REVIEWER (RID, NAME) VALUES (204, 'john doe')",
      "INSERT INTO REVIEWER (RID, NAME) VALUES (205, 'jane smith')",
      "INSERT INTO REVIEWER (RID, NAME) VALUES (206, 'ALEX JOHNSON')",
      "INSERT INTO REVIEWER (RID, NAME) VALUES (207, 'bOb wIlSoN')",
      "INSERT INTO REVIEWER (RID, NAME) VALUES (208, 'charlie brown')"
    ],
    "summary": "Create a BEFORE INSERT trigger on the REVIEWER table that formats the NAME column of each new row to have the first character in uppercase and the remaining characters in lowercase.",
    "natural_language": "Make a BEFORE INSERT trigger for REVIEWER to capitalize the first letter of NAME and make the rest lowercase.",
    "id": 24,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_reviewer_name_format` that is configured to execute automatically `BEFORE` any `INSERT` operation is performed on a row in the `REVIEWER` table. This trigger is defined to fire `FOR EACH ROW` that is being inserted, meaning its logic will be applied individually to every new row before it is committed to the `REVIEWER` table. The trigger's primary purpose is to reformat the value in the `NAME` column of the new row to ensure proper capitalization. Specifically, it takes the new value provided for the `NAME` column, which is accessible via the `:NEW.NAME` pseudorecord variable, and transforms it so that the first character of the name is in uppercase and all subsequent characters are in lowercase. This transformation is performed using a combination of string functions: the `UPPER` function is applied to the first character of the string, and the `LOWER` function is applied to the substring starting from the second character onward. These two parts are then concatenated together. The resulting formatted string is assigned back to `:NEW.NAME`, thereby modifying the data just before the insert operation is finalized. This ensures that every new reviewer name entered into the `REVIEWER` table adheres to a standardized capitalization format, regardless of how the name was originally input."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_round_on_member_insert that is defined to execute automatically after a new row is inserted into the MEMBER table, and it executes once for each inserted row; within its body, it performs a single INSERT operation into a table named ROUND, specifying values for four columns: the ROUND_ID column is populated with the value from the :NEW.MEMBER_ID pseudo-record field of the newly inserted MEMBER row, the MEMBER_ID column is also populated with the same :NEW.MEMBER_ID value, the DECORATION_THEME column is populated with the literal string 'Default Theme', and the RANK_IN_ROUND column is populated with the literal numeric value 1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_round_on_member_insert\nAFTER INSERT ON MEMBER\nFOR EACH ROW\nBEGIN\n  INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND)\n  VALUES (:NEW.MEMBER_ID, :NEW.MEMBER_ID, 'Default Theme', 1);\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (4, 'Gary Player', 'South Africa', 1)",
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (5, 'Seve Ballesteros', 'Spain', 2)",
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (6, 'Tom Watson', 'United States', 3)",
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (7, 'Lee Trevino', 'United States', 1)",
      "INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) VALUES (8, 'Nick Faldo', 'United Kingdom', 2)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_round_on_member_insert on the MEMBER table. For each new row, insert into the ROUND table: set ROUND_ID and MEMBER_ID to :NEW.MEMBER_ID, DECORATION_THEME to 'Default Theme', and RANK_IN_ROUND to 1.",
    "natural_language": "Please construct an AFTER INSERT row-level trigger designated as trg_insert_round_on_member_insert for the MEMBER table. For each inserted row, the trigger must execute an insertion into the ROUND table, assigning the ROUND_ID and MEMBER_ID columns the value from :NEW.MEMBER_ID, setting the DECORATION_THEME to 'Default Theme', and initializing the RANK_IN_ROUND to 1.",
    "id": 25,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_insert_round_on_member_insert that is defined to execute automatically after a new row is inserted into the MEMBER table, and it executes once for each inserted row; within its body, it performs a single INSERT operation into a table named ROUND, specifying values for four columns: the ROUND_ID column is populated with the value from the :NEW.MEMBER_ID pseudo-record field of the newly inserted MEMBER row, the MEMBER_ID column is also populated with the same :NEW.MEMBER_ID value, the DECORATION_THEME column is populated with the literal string 'Default Theme', and the RANK_IN_ROUND column is populated with the literal numeric value 1."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_supplier_phone` that is activated `AFTER` an `UPDATE` operation on the `SUPPLIERS` table, specifically when the `SUPPLIER_PHONE` column is modified. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is updated in the `SUPPLIERS` table. Upon activation, the trigger performs two distinct operations. First, it executes an `UPDATE` statement on the `SUPPLIER_ADDRESSES` table. This `UPDATE` statement sets the `DATE_TO` column to a character string representing the current system date and time. The `TO_CHAR` function is used to convert the `SYSDATE` (which returns the current date and time) into a character string formatted as 'YYYY-MM-DD HH24:MI:SS' (e.g., '2023-10-27 14:35:01'). This update is applied to rows in `SUPPLIER_ADDRESSES` where the `SUPPLIER_ID` column matches the `SUPPLIER_ID` of the row that was just updated in the `SUPPLIERS` table. The `:NEW.SUPPLIER_ID` pseudo-record variable provides access to the `SUPPLIER_ID` value of the row *after* the update operation on the `SUPPLIERS` table. Second, immediately after the update, the trigger executes an `INSERT` statement into the `SUPPLIER_ADDRESSES` table. This `INSERT` statement adds a new row with four column values. The `SUPPLIER_ID` column is populated with the `SUPPLIER_ID` of the newly updated supplier, again accessed via `:NEW.SUPPLIER_ID`. The `ADDRESS_ID` column is populated with a calculated value, which is `200` plus the `SUPPLIER_ID` of the updated supplier (`200 + :NEW.SUPPLIER_ID`). The `DATE_FROM` column is populated with a character string representing the current system date and time, formatted using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`, similar to the `DATE_TO` column in the preceding `UPDATE` statement. Finally, the `DATE_TO` column for this newly inserted row is explicitly set to `NULL`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_supplier_phone\nAFTER UPDATE OF SUPPLIER_PHONE ON SUPPLIERS\nFOR EACH ROW\nBEGIN\n    UPDATE SUPPLIER_ADDRESSES SET DATE_TO = TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') WHERE SUPPLIER_ID = :NEW.SUPPLIER_ID;\n    INSERT INTO SUPPLIER_ADDRESSES (SUPPLIER_ID, ADDRESS_ID, DATE_FROM, DATE_TO)\n    VALUES (:NEW.SUPPLIER_ID, 200 + :NEW.SUPPLIER_ID, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), NULL);\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES"
    ],
    "call_sqls": [
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '1-800-555-0101' WHERE SUPPLIER_ID = 2",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '555-1234' WHERE SUPPLIER_ID = 3",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '1-432-960-9999' WHERE SUPPLIER_ID = 4",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = '287-071-0000', SUPPLIER_NAME = 'Tesco Updated' WHERE SUPPLIER_ID = 3",
      "UPDATE SUPPLIERS SET SUPPLIER_PHONE = 'NEW-PHONE-123' WHERE SUPPLIER_NAME = 'AB Store'"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_supplier_phone on the SUPPLIERS table, firing when SUPPLIER_PHONE is updated. For each updated row, first update SUPPLIER_ADDRESSES to set DATE_TO to TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') where SUPPLIER_ID equals :NEW.SUPPLIER_ID. Then, insert a new row into SUPPLIER_ADDRESSES with SUPPLIER_ID from :NEW.SUPPLIER_ID, ADDRESS_ID as 200 + :NEW.SUPPLIER_ID, DATE_FROM as TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), and DATE_TO as NULL.",
    "natural_language": "Construct an AFTER UPDATE FOR EACH ROW trigger, which should be named trg_update_supplier_phone, on the SUPPLIERS table; this trigger must be configured to fire specifically and exclusively whenever the SUPPLIER_PHONE column is updated. For every single row that is updated, the trigger must first meticulously update the SUPPLIER_ADDRESSES table, setting the DATE_TO column to the precisely formatted current system timestamp using TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'), but only for those records where the SUPPLIER_ID matches the new :NEW.SUPPLIER_ID value from the triggering update. Subsequently and importantly, it must then proceed to insert a brand new row into the SUPPLIER_ADDRESSES table, carefully populating it with the following values: the SUPPLIER_ID should be taken directly from :NEW.SUPPLIER_ID, the ADDRESS_ID should be calculated as 200 plus the :NEW.SUPPLIER_ID, the DATE_FROM should be set to the same current system timestamp formatted as 'YYYY-MM-DD HH24:MI:SS', and finally, the DATE_TO column should be explicitly set to NULL.",
    "id": 26,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_update_supplier_phone` that is activated `AFTER` an `UPDATE` operation on the `SUPPLIERS` table, specifically when the `SUPPLIER_PHONE` column is modified. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each row that is updated in the `SUPPLIERS` table. Upon activation, the trigger performs two distinct operations. First, it executes an `UPDATE` statement on the `SUPPLIER_ADDRESSES` table. This `UPDATE` statement sets the `DATE_TO` column to a character string representing the current system date and time. The `TO_CHAR` function is used to convert the `SYSDATE` (which returns the current date and time) into a character string formatted as 'YYYY-MM-DD HH24:MI:SS' (e.g., '2023-10-27 14:35:01'). This update is applied to rows in `SUPPLIER_ADDRESSES` where the `SUPPLIER_ID` column matches the `SUPPLIER_ID` of the row that was just updated in the `SUPPLIERS` table. The `:NEW.SUPPLIER_ID` pseudo-record variable provides access to the `SUPPLIER_ID` value of the row *after* the update operation on the `SUPPLIERS` table. Second, immediately after the update, the trigger executes an `INSERT` statement into the `SUPPLIER_ADDRESSES` table. This `INSERT` statement adds a new row with four column values. The `SUPPLIER_ID` column is populated with the `SUPPLIER_ID` of the newly updated supplier, again accessed via `:NEW.SUPPLIER_ID`. The `ADDRESS_ID` column is populated with a calculated value, which is `200` plus the `SUPPLIER_ID` of the updated supplier (`200 + :NEW.SUPPLIER_ID`). The `DATE_FROM` column is populated with a character string representing the current system date and time, formatted using `TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS')`, similar to the `DATE_TO` column in the preceding `UPDATE` statement. Finally, the `DATE_TO` column for this newly inserted row is explicitly set to `NULL`."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_wedding_year that is executed automatically after an update operation is performed on the WEDDING table. This trigger operates on each row affected by the update. It evaluates the YEAR column of the updated row using conditional logic. If the new YEAR value is greater than 2020, it updates the CHURCH table by increasing the OPEN_DATE column by 10 for the row where the CHURCH_ID matches the old CHURCH_ID value from the updated WEDDING row. If the new YEAR value is between 2010 and 2020 inclusive, it updates the CHURCH table by increasing the OPEN_DATE column by 5 for the row where the CHURCH_ID matches the old CHURCH_ID value from the updated WEDDING row. If the new YEAR value is less than 2010, it updates the CHURCH table by increasing the OPEN_DATE column by 1 for the row where the CHURCH_ID matches the old CHURCH_ID value from the updated WEDDING row. The trigger uses the :NEW and :OLD pseudorecords to access the new and old values of the YEAR and CHURCH_ID columns, respectively, from the WEDDING table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_wedding_year\nAFTER UPDATE ON WEDDING\nFOR EACH ROW\nBEGIN\n  IF :NEW.YEAR > 2020 THEN\n    UPDATE CHURCH SET OPEN_DATE = OPEN_DATE + 10 WHERE CHURCH_ID = :OLD.CHURCH_ID;\n  ELSIF :NEW.YEAR BETWEEN 2010 AND 2020 THEN\n    UPDATE CHURCH SET OPEN_DATE = OPEN_DATE + 5 WHERE CHURCH_ID = :OLD.CHURCH_ID;\n  ELSE\n    UPDATE CHURCH SET OPEN_DATE = OPEN_DATE + 1 WHERE CHURCH_ID = :OLD.CHURCH_ID;\n  END IF;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "UPDATE WEDDING SET YEAR = 2021 WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "UPDATE WEDDING SET YEAR = 2019 WHERE CHURCH_ID = 3 AND MALE_ID = 3 AND FEMALE_ID = 4",
      "UPDATE WEDDING SET YEAR = 2022 WHERE CHURCH_ID = 5 AND MALE_ID = 5 AND FEMALE_ID = 6",
      "UPDATE WEDDING SET YEAR = 2010 WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "UPDATE WEDDING SET YEAR = 2005 WHERE CHURCH_ID = 3 AND MALE_ID = 3 AND FEMALE_ID = 4"
    ],
    "summary": "Create a row-level trigger named `trg_update_wedding_year` that fires after UPDATE on the WEDDING table. Based on the new YEAR value: if >2020, add 10 to OPEN_DATE in CHURCH for the old CHURCH_ID; if between 2010 and 2020 inclusive, add 5; if <2010, add 1.",
    "natural_language": "Please construct a row-level trigger designated as `trg_update_wedding_year`. This trigger should be configured to execute subsequent to any UPDATE operation performed on the WEDDING table. Its logic must evaluate the newly provided YEAR value and, accordingly, modify the OPEN_DATE within the CHURCH table. The specific modifications are as follows: should the new YEAR exceed 2020, increment the OPEN_DATE by 10 for the record associated with the previous CHURCH_ID; should the new YEAR fall within the inclusive range of 2010 to 2020, increment the OPEN_DATE by 5; and should the new YEAR be less than 2010, increment the OPEN_DATE by 1.",
    "id": 27,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_wedding_year that is activated after any UPDATE operation on the WEDDING table. This trigger is a row-level trigger, meaning it executes once for each row that is updated in the WEDDING table. Upon activation, the trigger performs a single UPDATE operation on the CHURCH table. The UPDATE statement modifies the OPEN_DATE column for the specific CHURCH record where the CHURCH_ID matches the CHURCH_ID of the updated row in the WEDDING table, referenced by :NEW.CHURCH_ID. The new value for OPEN_DATE is calculated by adding an increment to the existing OPEN_DATE value from the CHURCH table. The increment amount is determined conditionally based on the new YEAR value from the updated WEDDING row, referenced by :NEW.YEAR. Specifically, if :NEW.YEAR is greater than 2020, the increment is 10; if :NEW.YEAR is between 2010 and 2020 inclusive (i.e., greater than or equal to 2010 and less than or equal to 2020), the increment is 5; otherwise, for all cases where :NEW.YEAR is less than 2010, the increment is 1. The trigger does not return a value but directly updates the CHURCH table based on the conditions."
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_after_payment_lesson_check` that fires for each row inserted into the `CUSTOMER_PAYMENTS` table, first accumulating payment data per customer in a collection during the row-level phase and then processing that aggregated data to update customer statuses in a statement-level phase. The trigger defines a record type `customer_payment_rec` with fields for `customer_id` (matching the `CUSTOMER_ID%TYPE` from `CUSTOMER_PAYMENTS`), `amount_payment` (matching the `AMOUNT_PAYMENT%TYPE` from `CUSTOMER_PAYMENTS`), `total_payment` (a `NUMBER`), and `payment_count` (a `NUMBER`), and an associative array type `customer_payment_tab` indexed by `PLS_INTEGER` to hold these records, which is instantiated as a global package-level variable `g_customer_payments`. In the `AFTER EACH ROW` section, for each new row inserted, the trigger uses the new `CUSTOMER_ID` value as an index key `l_index` to check if an entry for that customer already exists in the `g_customer_payments` collection using the `EXISTS` method; if it does not exist, it initializes a new record at that index, setting the `customer_id` to `:NEW.CUSTOMER_ID`, the `amount_payment` to `:NEW.AMOUNT_PAYMENT`, the `total_payment` to `:NEW.AMOUNT_PAYMENT`, and the `payment_count` to 1; if it does exist, it updates the existing record by setting the `amount_payment` to the new `:NEW.AMOUNT_PAYMENT`, incrementing the `total_payment` by `:NEW.AMOUNT_PAYMENT`, and incrementing the `payment_count` by 1. In the `AFTER STATEMENT` section, after all rows are inserted and processed, the trigger iterates through every distinct `customer_id` stored in the `g_customer_payments` collection using the `FIRST` and `NEXT` collection methods, assigning each key to a variable `l_customer_id`; for each customer, it performs a `SELECT COUNT(*)` query on the `LESSONS` table into a local variable `v_lesson_count`, counting all rows where the `CUSTOMER_ID` column equals the current `l_customer_id`; it then calculates an average payment `v_avg_payment` by dividing the customer's accumulated `total_payment` from the collection by their `payment_count`; based on these values, it assigns a status string to a local variable `v_status` using conditional logic: if `v_lesson_count` equals 0, `v_status` is set to 'New Customer'; otherwise, if the most recent `amount_payment` (from the collection) for that customer is greater than `v_avg_payment`, `v_status` is set to 'Premium'; if the most recent `amount_payment` is less than `v_avg_payment`, `v_status` is set to 'Standard'; if neither greater nor less (implying equality), `v_status` is set to 'Balanced'; finally, for each customer, it executes an `UPDATE` statement on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the derived `v_status` value for the row where the `CUSTOMER_ID` column matches the current `l_customer_id`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_payment_lesson_check\nFOR INSERT ON CUSTOMER_PAYMENTS\nCOMPOUND TRIGGER\n\n  TYPE customer_payment_rec IS RECORD (\n    customer_id CUSTOMER_PAYMENTS.CUSTOMER_ID%TYPE,\n    amount_payment CUSTOMER_PAYMENTS.AMOUNT_PAYMENT%TYPE,\n    total_payment NUMBER := 0,\n    payment_count NUMBER := 0\n  );\n\n  TYPE customer_payment_tab IS TABLE OF customer_payment_rec INDEX BY PLS_INTEGER;\n  g_customer_payments customer_payment_tab;\n\n  AFTER EACH ROW IS\n    l_index PLS_INTEGER;\n  BEGIN\n    l_index := :NEW.CUSTOMER_ID;\n    \n    IF NOT g_customer_payments.EXISTS(l_index) THEN\n      g_customer_payments(l_index).customer_id := :NEW.CUSTOMER_ID;\n      g_customer_payments(l_index).amount_payment := :NEW.AMOUNT_PAYMENT;\n      g_customer_payments(l_index).total_payment := :NEW.AMOUNT_PAYMENT;\n      g_customer_payments(l_index).payment_count := 1;\n    ELSE\n      g_customer_payments(l_index).amount_payment := :NEW.AMOUNT_PAYMENT;\n      g_customer_payments(l_index).total_payment := g_customer_payments(l_index).total_payment + :NEW.AMOUNT_PAYMENT;\n      g_customer_payments(l_index).payment_count := g_customer_payments(l_index).payment_count + 1;\n    END IF;\n  END AFTER EACH ROW;\n\n  AFTER STATEMENT IS\n    v_lesson_count NUMBER;\n    v_avg_payment NUMBER;\n    v_status VARCHAR2(255);\n    l_customer_id NUMBER;\n  BEGIN\n    l_customer_id := g_customer_payments.FIRST;\n    \n    WHILE l_customer_id IS NOT NULL LOOP\n      SELECT COUNT(*) INTO v_lesson_count \n      FROM LESSONS \n      WHERE CUSTOMER_ID = l_customer_id;\n      \n      v_avg_payment := g_customer_payments(l_customer_id).total_payment / g_customer_payments(l_customer_id).payment_count;\n      \n      IF v_lesson_count = 0 THEN\n        v_status := 'New Customer';\n      ELSIF g_customer_payments(l_customer_id).amount_payment > v_avg_payment THEN\n        v_status := 'Premium';\n      ELSIF g_customer_payments(l_customer_id).amount_payment < v_avg_payment THEN\n        v_status := 'Standard';\n      ELSE\n        v_status := 'Balanced';\n      END IF;\n      \n      UPDATE CUSTOMERS \n      SET CUSTOMER_STATUS_CODE = v_status\n      WHERE CUSTOMER_ID = l_customer_id;\n      \n      l_customer_id := g_customer_payments.NEXT(l_customer_id);\n    END LOOP;\n  END AFTER STATEMENT;\n\nEND trg_after_payment_lesson_check;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (1, '2023-01-01 10:00:00', 'Credit Card', 100.00)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (1, '2023-01-02 11:00:00', 'Debit Card', 150.00)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (2, '2023-01-03 12:00:00', 'Bank Transfer', 200.00)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (3, '2023-01-04 13:00:00', 'Credit Card', 50.00)",
      "INSERT INTO CUSTOMER_PAYMENTS (CUSTOMER_ID, DATETIME_PAYMENT, PAYMENT_METHOD_CODE, AMOUNT_PAYMENT) VALUES (1, '2023-01-05 14:00:00', 'Debit Card', 120.00)"
    ],
    "summary": "Create a compound trigger named TRG_AFTER_PAYMENT_LESSON_CHECK on the CUSTOMER_PAYMENTS table. In the AFTER EACH ROW section, accumulate payment totals and counts per customer into a collection. In the AFTER STATEMENT section, for each customer in the collection, calculate their lesson count and average payment. Update the CUSTOMERS table's CUSTOMER_STATUS_CODE for each customer based on these values: 'New Customer' if no lessons, 'Premium' if the latest payment is above average, 'Standard' if below, or 'Balanced' if equal.",
    "natural_language": "Build a compound trigger called TRG_AFTER_PAYMENT_LESSON_CHECK on the CUSTOMER_PAYMENTS table. In the AFTER EACH ROW section, gather payment totals and counts per customer into a collection. Then, in the AFTER STATEMENT section, for every customer in that collection, compute their lesson count and average payment. Finally, set the CUSTOMERS table's CUSTOMER_STATUS_CODE for each customer using these rules: assign 'New Customer' if there are no lessons, 'Premium' if the latest payment exceeds the average, 'Standard' if it is below average, or 'Balanced' if it matches.",
    "id": 28,
    "generated_ir": "Write an Oracle PL/SQL compound trigger named `trg_after_payment_lesson_check` that fires for each row inserted into the `CUSTOMER_PAYMENTS` table, first accumulating payment data per customer in a collection during the row-level phase and then processing that aggregated data to update customer statuses in a statement-level phase. The trigger defines a record type `customer_payment_rec` with fields for `customer_id` (matching the `CUSTOMER_ID%TYPE` from `CUSTOMER_PAYMENTS`), `amount_payment` (matching the `AMOUNT_PAYMENT%TYPE` from `CUSTOMER_PAYMENTS`), `total_payment` (a `NUMBER`), and `payment_count` (a `NUMBER`), and an associative array type `customer_payment_tab` indexed by `PLS_INTEGER` to hold these records, which is instantiated as a global package-level variable `g_customer_payments`. In the `AFTER EACH ROW` section, for each new row inserted, the trigger uses the new `CUSTOMER_ID` value as an index key `l_index` to check if an entry for that customer already exists in the `g_customer_payments` collection using the `EXISTS` method; if it does not exist, it initializes a new record at that index, setting the `customer_id` to `:NEW.CUSTOMER_ID`, the `amount_payment` to `:NEW.AMOUNT_PAYMENT`, the `total_payment` to `:NEW.AMOUNT_PAYMENT`, and the `payment_count` to 1; if it does exist, it updates the existing record by setting the `amount_payment` to the new `:NEW.AMOUNT_PAYMENT`, incrementing the `total_payment` by `:NEW.AMOUNT_PAYMENT`, and incrementing the `payment_count` by 1. In the `AFTER STATEMENT` section, after all rows are inserted and processed, the trigger iterates through every distinct `customer_id` stored in the `g_customer_payments` collection using the `FIRST` and `NEXT` collection methods, assigning each key to a variable `l_customer_id`; for each customer, it performs a `SELECT COUNT(*)` query on the `LESSONS` table into a local variable `v_lesson_count`, counting all rows where the `CUSTOMER_ID` column equals the current `l_customer_id`; it then calculates an average payment `v_avg_payment` by dividing the customer's accumulated `total_payment` from the collection by their `payment_count`; based on these values, it assigns a status string to a local variable `v_status` using conditional logic: if `v_lesson_count` equals 0, `v_status` is set to 'New Customer'; otherwise, if the most recent `amount_payment` (from the collection) for that customer is greater than `v_avg_payment`, `v_status` is set to 'Premium'; if the most recent `amount_payment` is less than `v_avg_payment`, `v_status` is set to 'Standard'; if neither greater nor less (implying equality), `v_status` is set to 'Balanced'; finally, for each customer, it executes an `UPDATE` statement on the `CUSTOMERS` table, setting the `CUSTOMER_STATUS_CODE` column to the derived `v_status` value for the row where the `CUSTOMER_ID` column matches the current `l_customer_id`."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_friend_before_delete that fires before a row is deleted from the FRIEND table, for each affected row, and declares local variables v_name as a VARCHAR2 with a maximum length of 255 characters and v_xml as an XMLTYPE; the trigger first selects the NAME column from the HIGHSCHOOLER table into v_name where the HIGHSCHOOLER.ID column matches the old value of the STUDENT_ID column from the FRIEND table being deleted, then constructs an XMLTYPE value v_xml by concatenating the string '<record><action>DELETE</action><student>' with the retrieved v_name and the closing string '</student></record>'; then, using a conditional IF statement, the trigger checks if the old STUDENT_ID value is equal to the old FRIEND_ID value from the FRIEND row, and if this condition is true, it executes a DELETE operation on the LIKES table where the LIKES.STUDENT_ID column equals the old STUDENT_ID value; if the condition is false, meaning the old STUDENT_ID and old FRIEND_ID are different, the trigger instead performs an INSERT into the LIKES table, specifying columns STUDENT_ID and LIKED_ID with values set to the old STUDENT_ID and old FRIEND_ID respectively, and then executes an UPDATE on the HIGHSCHOOLER table, decrementing the GRADE column by one for the row where the HIGHSCHOOLER.ID column equals the old STUDENT_ID value.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_friend_before_delete\nBEFORE DELETE ON FRIEND\nFOR EACH ROW\nDECLARE\n  v_name VARCHAR2(255);\n  v_xml XMLTYPE;\nBEGIN\n  SELECT NAME INTO v_name FROM HIGHSCHOOLER WHERE ID = :OLD.STUDENT_ID;\n  v_xml := XMLTYPE('<record><action>DELETE</action><student>' || v_name || '</student></record>');\n  IF :OLD.STUDENT_ID = :OLD.FRIEND_ID THEN\n    DELETE FROM LIKES WHERE STUDENT_ID = :OLD.STUDENT_ID;\n  ELSE\n    INSERT INTO LIKES (STUDENT_ID, LIKED_ID) VALUES (:OLD.STUDENT_ID, :OLD.FRIEND_ID);\n    UPDATE HIGHSCHOOLER SET GRADE = GRADE - 1 WHERE ID = :OLD.STUDENT_ID;\n  END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1101 AND FRIEND_ID = 1641",
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1247 AND FRIEND_ID = 1501",
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1381 AND FRIEND_ID = 1381",
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1510 AND FRIEND_ID = 1689",
      "DELETE FROM FRIEND WHERE STUDENT_ID = 1689 AND FRIEND_ID = 1510"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_friend_before_delete on the FRIEND table. For each deleted row, get the student's name from HIGHSCHOOLER and build an XML record. If the deleted STUDENT_ID equals the deleted FRIEND_ID, delete the student's records from LIKES. Otherwise, insert a new record into LIKES and decrement the student's grade in HIGHSCHOOLER.",
    "natural_language": "Please construct a BEFORE DELETE row-level trigger designated as trg_friend_before_delete on the FRIEND table. For each row that is deleted, one must retrieve the corresponding student name from the HIGHSCHOOLER table and assemble an XML record. In the event that the deleted STUDENT_ID is identical to the deleted FRIEND_ID, it is necessary to delete all records for that student from the LIKES table. Otherwise, a new record should be inserted into the LIKES table, and the student's grade in the HIGHSCHOOLER table must be decremented.",
    "id": 29,
    "generated_ir": "Write an Oracle PL/SQL BEFORE DELETE row-level trigger named `trg_friend_before_delete` on the `FRIEND` table. This trigger executes automatically before a DELETE operation is performed on each row in the `FRIEND` table. The trigger declares a local variable `v_student_name` of type `VARCHAR2(255)` to store a name retrieved from the `HIGHSCHOOLER` table. Upon activation for each row being deleted, the trigger first performs a SELECT operation to retrieve the `NAME` column from the `HIGHSCHOOLER` table where the `ID` column matches the `STUDENT_ID` value of the row currently being deleted (represented by the `:OLD.STUDENT_ID` pseudorecord). The retrieved name is stored in the `v_student_name` variable. Next, the trigger assembles an XML record. This XML record is constructed using the `XMLELEMENT` function, creating an XML element named \"DeletedFriend\". Within this element, the trigger includes two child XML elements: one named \"StudentID\" containing the value of `:OLD.STUDENT_ID`, and another named \"StudentName\" containing the value stored in `v_student_name`. The resulting XML document is not stored but is generated as part of the trigger's execution. Following this, the trigger evaluates a conditional IF-ELSE block based on the values of the deleted row. The condition checks if the `STUDENT_ID` of the row being deleted (`:OLD.STUDENT_ID`) is identical to the `FRIEND_ID` of the same row (`:OLD.FRIEND_ID`). If this condition is true, the trigger performs a DELETE operation on the `LIKES` table. Specifically, it deletes all rows from the `LIKES` table where the `STUDENT_ID` column matches the `:OLD.STUDENT_ID` value. If the condition is false (meaning `:OLD.STUDENT_ID` is not equal to `:OLD.FRIEND_ID`), the trigger performs two operations. First, it executes an INSERT operation into the `LIKES` table. This INSERT adds a new row with the `STUDENT_ID` column set to the value of `:OLD.STUDENT_ID` and the `LIKED_ID` column set to the value of `:OLD.FRIEND_ID`. Second, it performs an UPDATE operation on the `HIGHSCHOOLER` table. This UPDATE decrements the `GRADE` column by 1 for the row where the `ID` column matches the `:OLD.STUDENT_ID` value. The trigger does not return any value but executes these database operations as part of its logic."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_mission_delete that is defined to execute automatically before any row deletion operation on the MISSION table, and for each individual row being deleted, the trigger performs a delete operation on the SHIP table where the SHIP_ID column value in the SHIP table exactly matches the SHIP_ID column value from the row currently being deleted from the MISSION table, which is accessed via the :OLD.SHIP_ID bind variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_mission_delete\nBEFORE DELETE ON MISSION\nFOR EACH ROW\nBEGIN\n  DELETE FROM SHIP WHERE SHIP_ID = :OLD.SHIP_ID;\nEND;",
    "database_name": "ship_mission",
    "tables": [
      "MISSION",
      "SHIP"
    ],
    "call_sqls": [
      "DELETE FROM MISSION WHERE MISSION_ID = 1",
      "DELETE FROM MISSION WHERE SHIP_ID = 2",
      "DELETE FROM MISSION WHERE CODE = 'VMV-1'",
      "DELETE FROM MISSION WHERE LAUNCHED_YEAR = 1930",
      "DELETE FROM MISSION WHERE MISSION_ID IN (2, 4)"
    ],
    "summary": "Create a BEFORE DELETE FOR EACH ROW trigger named trg_mission_delete on the MISSION table. For each mission being deleted, delete the corresponding ship from the SHIP table where SHIP_ID matches the :OLD.SHIP_ID.",
    "natural_language": "Delete the corresponding ship from the SHIP table for each mission being deleted by creating a BEFORE DELETE FOR EACH ROW trigger named trg_mission_delete on the MISSION table, matching the SHIP_ID to the :OLD.SHIP_ID.",
    "id": 30,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_mission_delete that is defined to execute automatically before any row deletion operation on the MISSION table, and for each individual row being deleted, the trigger performs a delete operation on the SHIP table where the SHIP_ID column value in the SHIP table exactly matches the SHIP_ID column value from the row currently being deleted from the MISSION table, which is accessed via the :OLD.SHIP_ID bind variable."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_service that is executed automatically after a DELETE operation is performed on the SERVICES table. This trigger operates for each row that is deleted from the SERVICES table. Within the trigger's body, it performs a DELETE operation on the RESIDENTS_SERVICES table, specifically targeting rows where the SERVICE_ID column matches the SERVICE_ID of the row that was just deleted from the SERVICES table. The :OLD prefix is used to refer to the value of the SERVICE_ID column from the deleted row in the SERVICES table, ensuring that the deletion in the RESIDENTS_SERVICES table is directly linked to the corresponding SERVICE_ID of the deleted service.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_service\nAFTER DELETE ON SERVICES\nFOR EACH ROW\nBEGIN\n  DELETE FROM RESIDENTS_SERVICES\n  WHERE SERVICE_ID = :OLD.SERVICE_ID;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "RESIDENTS_SERVICES",
      "SERVICES"
    ],
    "call_sqls": [
      "DELETE FROM SERVICES WHERE SERVICE_ID = 10",
      "DELETE FROM SERVICES WHERE SERVICE_ID = 11",
      "DELETE FROM SERVICES WHERE SERVICE_ID = 13",
      "DELETE FROM SERVICES WHERE SERVICE_ID = 49",
      "DELETE FROM SERVICES WHERE SERVICE_ID = 41"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named trg_delete_service on the SERVICES table. For each deleted row, delete all related records from the RESIDENTS_SERVICES table where the SERVICE_ID matches the deleted service's ID.",
    "natural_language": "Please construct an AFTER DELETE row-level trigger designated as trg_delete_service on the SERVICES table. For every row that is deleted, the trigger must proceed to delete all associated records within the RESIDENTS_SERVICES table where the SERVICE_ID corresponds to the ID of the service that has been removed.",
    "id": 31,
    "generated_ir": "Write an Oracle PL/SQL AFTER DELETE trigger named trg_delete_service that fires for each row being deleted from the SERVICES table. The trigger is a row-level trigger, meaning it executes once for every row that is deleted. The trigger does not declare any local variables. Upon activation, after a row is deleted from the SERVICES table, the trigger executes a DELETE operation on the RESIDENTS_SERVICES table. This DELETE statement includes a WHERE clause that filters records in the RESIDENTS_SERVICES table where its SERVICE_ID column matches the SERVICE_ID value of the row that was just deleted from the SERVICES table. This SERVICE_ID value from the deleted row is accessed using the :OLD.SERVICE_ID pseudorecord. The operation ensures referential integrity by removing all dependent records in the RESIDENTS_SERVICES table that are associated with the deleted service, based on the foreign key relationship where RESIDENTS_SERVICES.SERVICE_ID equals SERVICES.SERVICE_ID. The trigger does not contain any conditional logic, calculations, or return values; it performs a cascading delete operation automatically after each deletion from the SERVICES table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_actor_age_calc that fires automatically before any row is inserted into the ACTOR table, and for each new row, it declares a local variable v_max_id of type NUMBER, then checks if the new value for the ACTOR_ID column is NULL, and if it is, the trigger queries the ACTOR table to find the current maximum ACTOR_ID value, uses the NVL function to return 0 if no maximum is found, adds 1 to that result, stores it in v_max_id, and assigns this calculated value to the :NEW.ACTOR_ID column for the row being inserted; subsequently, the trigger checks if the new value for the AGE column is NULL, and if it is, the trigger assigns a default value of 1 to the :NEW.AGE column for the row being inserted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_actor_age_calc\nBEFORE INSERT ON ACTOR\nFOR EACH ROW\nDECLARE\n  v_max_id NUMBER;\nBEGIN\n  -- Ensure ACTOR_ID is unique if not provided\n  IF :NEW.ACTOR_ID IS NULL THEN\n    SELECT NVL(MAX(ACTOR_ID), 0) + 1 INTO v_max_id FROM ACTOR;\n    :NEW.ACTOR_ID := v_max_id;\n  END IF;\n  \n  -- Set default age if not provided\n  IF :NEW.AGE IS NULL THEN\n    :NEW.AGE := 1;\n  END IF;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "INSERT INTO ACTOR (NAME, MUSICAL_ID, CHARACTER, DURATION, AGE) VALUES ('New Actor 1', 1, 'Character 1', '2020-', 30)",
      "INSERT INTO ACTOR (NAME, MUSICAL_ID, CHARACTER, DURATION) VALUES ('New Actor 2', 2, 'Character 2', '2021-')",
      "INSERT INTO ACTOR (ACTOR_ID, NAME, MUSICAL_ID, CHARACTER, DURATION, AGE) VALUES (100, 'New Actor 3', 1, 'Character 3', '2022-', 25)",
      "INSERT INTO ACTOR (NAME, MUSICAL_ID, CHARACTER, DURATION, AGE) VALUES ('New Actor 4', 2, 'Character 4', '2023-', NULL)",
      "INSERT INTO ACTOR (ACTOR_ID, NAME, MUSICAL_ID, CHARACTER, DURATION) VALUES (NULL, 'New Actor 5', 1, 'Character 5', '2024-')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_actor_age_calc on the ACTOR table. If NEW.ACTOR_ID IS NULL, set it to MAX(ACTOR_ID)+1 (default 0). If NEW.AGE IS NULL, set it to 1.",
    "natural_language": "Construct a BEFORE INSERT FOR EACH ROW trigger, which should be named trg_actor_age_calc, to be placed on the ACTOR table. This trigger must first check if the NEW.ACTOR_ID value is NULL; if this condition is met, it should be automatically set to the maximum existing ACTOR_ID value incremented by one, defaulting to 0 if no prior IDs exist. Subsequently, it should also verify if the NEW.AGE value is NULL and, in that specific case, assign it a default value of 1.",
    "id": 32,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_actor_age_calc that fires before each row is inserted into the ACTOR table. The trigger performs two sequential operations on the new row data, represented by the :NEW pseudo-record.\n\nFirst, the trigger checks if the ACTOR_ID column of the new row, referred to as :NEW.ACTOR_ID, is NULL. If this condition is true, the trigger executes a SELECT statement to retrieve the maximum existing ACTOR_ID value from the ACTOR table. This query uses the MAX aggregate function on the ACTOR_ID column. If the table is empty, the MAX function returns NULL. To handle this, the trigger uses the NVL function to convert a NULL result from the MAX function to 0. The trigger then adds 1 to this value and assigns the result to :NEW.ACTOR_ID, effectively generating the next sequential ID.\n\nSecond, the trigger checks if the AGE column of the new row, referred to as :NEW.AGE, is NULL. If this condition is true, the trigger assigns the integer value 1 to :NEW.AGE, setting a default age.\n\nThe trigger does not perform any operations involving the MUSICAL table or other columns in the ACTOR table, such as NAME, MUSICAL_ID, CHARACTER, or DURATION. The logic flow consists of two independent conditional checks, each followed by an assignment operation if its respective condition is met. No updates, deletes, or additional selects are performed, and the trigger does not involve any joins or complex calculations beyond the increment operation for the ID."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_details_sync that fires before each row is deleted from the SCHOOL_DETAILS table, and for each row being deleted, it declares two local NUMBER variables v_school_enrollment and v_performance_count, then retrieves the ENROLLMENT value from the SCHOOL table for the SCHOOL_ID matching the old row's SCHOOL_ID into v_school_enrollment, and also counts the number of rows in the SCHOOL_PERFORMANCE table for the same SCHOOL_ID into v_performance_count, then evaluates a conditional logic block: if the old row's DIVISION column equals the string 'Division 1', it updates the SCHOOL table by setting the ENROLLMENT column for that SCHOOL_ID to the result of rounding the retrieved v_school_enrollment multiplied by 1.1; otherwise, if the retrieved v_school_enrollment is less than 1500, it deletes all rows from the SCHOOL_PERFORMANCE table where the SCHOOL_ID matches the old row's SCHOOL_ID; otherwise, if the counted v_performance_count is greater than 2, it inserts a new row into the SCHOOL_PERFORMANCE table with the old SCHOOL_ID and a SCHOOL_YEAR value of 'Archive'; otherwise, for any other case, it deletes a single row from the PLAYER table where the SCHOOL_ID matches the old row's SCHOOL_ID and the ROWNUM pseudo-column equals 1.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_details_sync\nBEFORE DELETE ON SCHOOL_DETAILS\nFOR EACH ROW\nDECLARE\n    v_school_enrollment NUMBER;\n    v_performance_count NUMBER;\nBEGIN\n    SELECT ENROLLMENT INTO v_school_enrollment FROM SCHOOL WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    SELECT COUNT(*) INTO v_performance_count FROM SCHOOL_PERFORMANCE WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    \n    IF :OLD.DIVISION = 'Division 1' THEN\n        UPDATE SCHOOL SET ENROLLMENT = ROUND(v_school_enrollment * 1.1) WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    ELSIF v_school_enrollment < 1500 THEN\n        DELETE FROM SCHOOL_PERFORMANCE WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    ELSIF v_performance_count > 2 THEN\n        INSERT INTO SCHOOL_PERFORMANCE (SCHOOL_ID, SCHOOL_YEAR) VALUES (:OLD.SCHOOL_ID, 'Archive');\n    ELSE\n        DELETE FROM PLAYER WHERE SCHOOL_ID = :OLD.SCHOOL_ID AND ROWNUM = 1;\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 1",
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 2",
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 3",
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 4",
      "DELETE FROM SCHOOL_DETAILS WHERE SCHOOL_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named TRG_SCHOOL_DETAILS_SYNC on the SCHOOL_DETAILS table. For each deleted row, get the school's ENROLLMENT and count its SCHOOL_PERFORMANCE records. If the old DIVISION is 'Division 1', update SCHOOL.ENROLLMENT by increasing it 10%. Else if the enrollment < 1500, delete from SCHOOL_PERFORMANCE for that SCHOOL_ID. Else if the performance count > 2, insert an 'Archive' record into SCHOOL_PERFORMANCE. Otherwise, delete one arbitrary row from PLAYER for that SCHOOL_ID.",
    "natural_language": "Create trigger TRG_SCHOOL_DETAILS_SYNC. On SCHOOL_DETAILS row delete: if old DIVISION is 'Division 1', increase SCHOOL.ENROLLMENT by 10%. Else if ENROLLMENT < 1500, delete SCHOOL_PERFORMANCE for that SCHOOL_ID. Else if SCHOOL_PERFORMANCE count > 2, insert 'Archive' record. Otherwise, delete one PLAYER row for that SCHOOL_ID.",
    "id": 33,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_SCHOOL_DETAILS_SYNC`. This trigger is defined to execute `AFTER DELETE` operations on the `SCHOOL_DETAILS` table. It is a `FOR EACH ROW` trigger, meaning it will execute once for each row that is deleted from the `SCHOOL_DETAILS` table. The trigger's logic is a series of conditional statements that perform different database operations based on the values of the deleted row and related data in other tables.\n\nUpon activation for a deleted row, the trigger first checks the value of the `DIVISION` column from the deleted row, referenced as `:OLD.DIVISION`. If this value is exactly equal to the string `'Division 1'`, then the trigger executes an `UPDATE` statement on the `SCHOOL` table. This `UPDATE` statement increases the value of the `ENROLLMENT` column by 10 percent for the specific row in the `SCHOOL` table where the `SCHOOL_ID` matches the `SCHOOL_ID` from the deleted `SCHOOL_DETAILS` row (`:OLD.SCHOOL_ID`). The update is performed using the calculation `ENROLLMENT = ENROLLMENT * 1.10`.\n\nIf the first condition is not met (i.e., `:OLD.DIVISION` is not `'Division 1'`), the trigger proceeds to an `ELSE IF` condition. This condition involves a `SELECT` statement to retrieve the `ENROLLMENT` value from the `SCHOOL` table. The `SELECT` statement queries the `ENROLLMENT` column from the `SCHOOL` table where the `SCHOOL_ID` equals `:OLD.SCHOOL_ID`. If the retrieved `ENROLLMENT` value is less than `1500`, then the trigger executes a `DELETE` statement on the `SCHOOL_PERFORMANCE` table. This `DELETE` statement removes all rows from the `SCHOOL_PERFORMANCE` table where the `SCHOOL_ID` column matches `:OLD.SCHOOL_ID`.\n\nIf the second condition is also not met (i.e., `ENROLLMENT` is not less than `1500`), the trigger proceeds to another `ELSE IF` condition. This condition involves a `SELECT` statement with a `COUNT(*)` aggregation on the `SCHOOL_PERFORMANCE` table. The `SELECT COUNT(*)` statement counts all rows in the `SCHOOL_PERFORMANCE` table where the `SCHOOL_ID` equals `:OLD.SCHOOL_ID`. If this count is greater than `2`, then the trigger executes an `INSERT` statement into the `SCHOOL_PERFORMANCE` table. The `INSERT` statement creates a new row with the following values: the `SCHOOL_ID` column is set to `:OLD.SCHOOL_ID`, the `SCHOOL_YEAR` column is set to the literal string `'Archive'`, and the `CLASS_A` and `CLASS_AA` columns are set to `NULL`.\n\nIf none of the previous conditions are met, the trigger executes a final `ELSE` action. This action is a `DELETE` statement on the `PLAYER` table. The `DELETE` statement removes exactly one row from the `PLAYER` table where the `SCHOOL_ID` column matches `:OLD.SCHOOL_ID`. To ensure only one row is deleted, the statement uses a subquery with `ROWNUM = 1` in the `WHERE` clause, ordering by `PLAYER_ID` (or another deterministic column) to make the deletion predictable. The exact implementation would be `DELETE FROM PLAYER WHERE SCHOOL_ID = :OLD.SCHOOL_ID AND ROWNUM = 1`."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_calculate_density that fires before each row insertion into the COUNTRY table, declaring a local variable v_avg_speed of type NUMBER, then executing a SELECT statement that queries the ROLLER_COASTER table to calculate the average of the SPEED column values converted to NUMBER data type for all rows where the COUNTRY_ID matches the new COUNTRY_ID value from the inserting row, storing the result into v_avg_speed, subsequently updating the new POPULATION column value for the inserting row by adding to the original new POPULATION value the product of the tangent of v_avg_speed multiplied by 1000, and finally performing an INSERT operation into the ROLLER_COASTER table with specified literal values including a ROLLER_COASTER_ID of 999, a NAME of 'AutoGen', a PARK of 'System', the new COUNTRY_ID from the inserting row, a LENGTH of 1000, a HEIGHT of 50, a SPEED of '50', the current system date for OPENED, and a STATUS of 'Operating'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_calculate_density\nBEFORE INSERT ON COUNTRY\nFOR EACH ROW\nDECLARE\n  v_avg_speed NUMBER;\nBEGIN\n  SELECT AVG(TO_NUMBER(SPEED)) INTO v_avg_speed FROM ROLLER_COASTER WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n  :NEW.POPULATION := :NEW.POPULATION + TAN(v_avg_speed) * 1000;\n  INSERT INTO ROLLER_COASTER (ROLLER_COASTER_ID, NAME, PARK, COUNTRY_ID, LENGTH, HEIGHT, SPEED, OPENED, STATUS) VALUES (999, 'AutoGen', 'System', :NEW.COUNTRY_ID, 1000, 50, '50', SYSDATE, 'Operating');\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (4, 'Norway', 5378857, 385207, 'Norwegian')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (5, 'Denmark', 5818553, 42933, 'Danish')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (6, 'Iceland', 366425, 103000, 'Icelandic')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (7, 'Netherlands', 17407585, 41543, 'Dutch')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (8, 'Belgium', 11589623, 30528, 'Dutch French')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_calculate_density on the COUNTRY table. Calculate average SPEED from ROLLER_COASTER for the new COUNTRY_ID, update new POPULATION by adding TAN(average_speed) * 1000, then insert a new roller coaster record with predefined values including the new COUNTRY_ID.",
    "natural_language": "Before inserting a new record into the COUNTRY table, how can I create a trigger named trg_calculate_density that calculates the average SPEED from the ROLLER_COASTER table for the new COUNTRY_ID, then updates the new POPULATION by adding TAN(average_speed) * 1000, and finally inserts a new roller coaster record with predefined values including the new COUNTRY_ID?",
    "id": 34,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_calculate_density that fires before each row insertion into the COUNTRY table, declaring a local variable v_avg_speed of type NUMBER, then executing a SELECT statement that queries the ROLLER_COASTER table to calculate the average of the SPEED column values converted to NUMBER data type for all rows where the COUNTRY_ID matches the new COUNTRY_ID value from the inserting row, storing the result into v_avg_speed, subsequently updating the new POPULATION column value for the inserting row by adding to the original new POPULATION value the product of the tangent of v_avg_speed multiplied by 1000, and finally performing an INSERT operation into the ROLLER_COASTER table with specified literal values including a ROLLER_COASTER_ID of 999, a NAME of 'AutoGen', a PARK of 'System', the new COUNTRY_ID from the inserting row, a LENGTH of 1000, a HEIGHT of 50, a SPEED of '50', the current system date for OPENED, and a STATUS of 'Operating'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_trim_problem_description that is executed before an INSERT or UPDATE operation on the PROBLEMS table. This trigger operates on each row affected by the INSERT or UPDATE statement. The trigger modifies the value of the PROBLEM_DESCRIPTION column in the affected row by truncating its content to a maximum length of 100 characters. This is achieved by using the SUBSTR function, which extracts a substring from the PROBLEM_DESCRIPTION column starting at the first character and extending up to the 100th character. The :NEW keyword is used to reference the new value of the PROBLEM_DESCRIPTION column in the row being inserted or updated, ensuring that the modification is applied to the incoming data before it is committed to the table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_trim_problem_description\nBEFORE INSERT OR UPDATE ON PROBLEMS\nFOR EACH ROW\nBEGIN\n  :NEW.PROBLEM_DESCRIPTION := SUBSTR(:NEW.PROBLEM_DESCRIPTION, 1, 100);\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (1, 4, 2, '1978-06-26 19:10:17', 'This is a very long problem description that should be trimmed by the trigger to exactly 100 characters.')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (2, 8, 10, '1988-11-07 16:09:31', 'Short description.')",
      "UPDATE PROBLEMS SET PROBLEM_DESCRIPTION = 'Another extremely long problem description that will definitely exceed the 100 character limit and get trimmed.' WHERE PROBLEM_ID = 1",
      "UPDATE PROBLEMS SET PROBLEM_DESCRIPTION = 'A slightly longer but still within limits description for problem 2.' WHERE PROBLEM_ID = 2",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (3, 1, 1, '1995-05-14 08:32:56', 'This description is exactly one hundred characters long, so it should not be trimmed at all. This is a test.')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_trim_problem_description on the PROBLEMS table. Trim the PROBLEM_DESCRIPTION column value to a maximum of 100 characters.",
    "natural_language": "Hey, can you set up a trigger called trg_trim_problem_description for the PROBLEMS table? It should fire before any new row is added or an existing one is updated. What it needs to do is chop down whatever's in the PROBLEM_DESCRIPTION field so it's no more than 100 characters long.",
    "id": 35,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_trim_problem_description that executes automatically before each row insertion or update operation on the PROBLEMS table, for each individual row being inserted or updated. The trigger declares no local variables. For each row processed, the trigger modifies the value of the PROBLEM_DESCRIPTION column in the :NEW pseudorecord, which holds the incoming data for the row. Specifically, it applies the SUBSTR function to the :NEW.PROBLEM_DESCRIPTION value, extracting a substring starting from the first character and limited to a maximum length of 100 characters. This operation effectively truncates the PROBLEM_DESCRIPTION string to at most 100 characters if its original length exceeds 100, or leaves it unchanged if it is 100 characters or less. The trigger performs this trimming unconditionally for every row insertion or update, and does not raise any errors or produce any explicit return value, as its purpose is to silently enforce a length constraint on the PROBLEM_DESCRIPTION field within the row data before it is written to the database."
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT OR UPDATE` row-level trigger named `TRG_CUST_ADDR_BIU` on the `CUSTOMER_ADDRESSES` table. This trigger executes for each row affected by an `INSERT` or `UPDATE` statement on the `CUSTOMER_ADDRESSES` table, prior to the data being committed to the database. The trigger performs two main operations. First, it handles date validation: it compares the value of the `DATE_FROM` column in the new or updated row (`:NEW.DATE_FROM`) with the value of the `DATE_TO` column in the new or updated row (`:NEW.DATE_TO`). Both column values are explicitly converted to `DATE` data types using the `TO_DATE` function with the format mask `'YYYY-MM-DD HH24:MI:SS'` before comparison. If the converted `DATE_FROM` is found to be chronologically later than the converted `DATE_TO`, then the `DATE_TO` column in the new or updated row (`:NEW.DATE_TO`) is set to the value of the `DATE_FROM` column in the new or updated row (`:NEW.DATE_FROM`). Second, the trigger ensures that the `ADDRESS_ID` column always has a value: it checks if the `ADDRESS_ID` column in the new or updated row (`:NEW.ADDRESS_ID`) is `NULL`. If `ADDRESS_ID` is `NULL`, the trigger generates a new `ADDRESS_ID` by querying the `CUSTOMER_ADDRESSES` table. It selects the maximum existing `ADDRESS_ID` from the `CUSTOMER_ADDRESSES` table, uses the `NVL` function to treat a `NULL` result from `MAX(ADDRESS_ID)` as `0`, adds `1` to this value, and then assigns the resulting incremented value to the `ADDRESS_ID` column in the new or updated row (`:NEW.ADDRESS_ID`).",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CUST_ADDR_BIU\nBEFORE INSERT OR UPDATE ON CUSTOMER_ADDRESSES\nFOR EACH ROW\nBEGIN\n    -- Handle date validation\n    IF TO_DATE(:NEW.DATE_FROM, 'YYYY-MM-DD HH24:MI:SS') > TO_DATE(:NEW.DATE_TO, 'YYYY-MM-DD HH24:MI:SS') THEN\n        :NEW.DATE_TO := :NEW.DATE_FROM;\n    END IF;\n    \n    -- Always generate ADDRESS_ID if NULL\n    IF :NEW.ADDRESS_ID IS NULL THEN\n        SELECT NVL(MAX(ADDRESS_ID), 0) + 1 INTO :NEW.ADDRESS_ID FROM CUSTOMER_ADDRESSES;\n    END IF;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ADDRESSES"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, ADDRESS_ID, DATE_FROM, DATE_TO) VALUES (15, NULL, '2024-01-01 10:00:00', '2023-12-31 10:00:00')",
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM, DATE_TO) VALUES (20, '2024-05-01 08:30:00', '2024-05-10 18:45:00')",
      "UPDATE CUSTOMER_ADDRESSES SET DATE_FROM = '2024-06-15 12:00:00', DATE_TO = '2024-06-01 12:00:00' WHERE CUSTOMER_ID = 2 AND ADDRESS_ID = 9",
      "INSERT INTO CUSTOMER_ADDRESSES (CUSTOMER_ID, DATE_FROM) VALUES (25, '2024-07-01 00:00:00')",
      "UPDATE CUSTOMER_ADDRESSES SET DATE_TO = '2024-03-01 09:00:00' WHERE CUSTOMER_ID = 10 AND ADDRESS_ID = 8"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named TRG_CUST_ADDR_BIU on the CUSTOMER_ADDRESSES table. For each row: 1) If DATE_FROM (converted to DATE with format 'YYYY-MM-DD HH24:MI:SS') is later than DATE_TO (similarly converted), set DATE_TO equal to DATE_FROM. 2) If ADDRESS_ID is NULL, set it to the maximum existing ADDRESS_ID plus 1 (or 1 if the table is empty).",
    "natural_language": "Construct a row-level trigger called TRG_CUST_ADDR_BIU, which is designed to activate before any insert or update operation on the CUSTOMER_ADDRESSES table. For every individual row being processed, the trigger must perform two detailed checks: firstly, it should carefully compare the DATE_FROM and DATE_TO values, after converting each to a standard DATE format of 'YYYY-MM-DD HH24:MI:SS'. If it finds that the converted DATE_FROM is chronologically later than the converted DATE_TO, it must automatically correct this by setting the DATE_TO to be exactly equal to DATE_FROM. Secondly, it must thoroughly examine the ADDRESS_ID field; if this field is discovered to be NULL, the trigger should dynamically calculate a new value by taking the maximum ADDRESS_ID currently present in the entire table and incrementing it by one, or simply assigning the value 1 if the table is completely empty at that moment.",
    "id": 36,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT OR UPDATE` row-level trigger named `TRG_CUST_ADDR_BIU` on the `CUSTOMER_ADDRESSES` table. This trigger executes for each row affected by an `INSERT` or `UPDATE` statement on the `CUSTOMER_ADDRESSES` table, prior to the data being committed to the database. The trigger performs two main operations. First, it handles date validation: it compares the value of the `DATE_FROM` column in the new or updated row (`:NEW.DATE_FROM`) with the value of the `DATE_TO` column in the new or updated row (`:NEW.DATE_TO`). Both column values are explicitly converted to `DATE` data types using the `TO_DATE` function with the format mask `'YYYY-MM-DD HH24:MI:SS'` before comparison. If the converted `DATE_FROM` is found to be chronologically later than the converted `DATE_TO`, then the `DATE_TO` column in the new or updated row (`:NEW.DATE_TO`) is set to the value of the `DATE_FROM` column in the new or updated row (`:NEW.DATE_FROM`). Second, the trigger ensures that the `ADDRESS_ID` column always has a value: it checks if the `ADDRESS_ID` column in the new or updated row (`:NEW.ADDRESS_ID`) is `NULL`. If `ADDRESS_ID` is `NULL`, the trigger generates a new `ADDRESS_ID` by querying the `CUSTOMER_ADDRESSES` table. It selects the maximum existing `ADDRESS_ID` from the `CUSTOMER_ADDRESSES` table, uses the `NVL` function to treat a `NULL` result from `MAX(ADDRESS_ID)` as `0`, adds `1` to this value, and then assigns the resulting incremented value to the `ADDRESS_ID` column in the new or updated row (`:NEW.ADDRESS_ID`)."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named player_school_audit that is executed after an insert operation on the PLAYER table for each row affected by the insert. The trigger begins by declaring two local variables: v_school_name of type VARCHAR2(255) to store the name of the school, and v_count of type NUMBER to store the count of records. The trigger first attempts to select the SCHOOL column from the SCHOOL table where the SCHOOL_ID matches the SCHOOL_ID of the newly inserted row in the PLAYER table, storing the result in v_school_name. If no matching SCHOOL_ID is found, the NO_DATA_FOUND exception is raised, and the trigger exits without performing further actions. If the SCHOOL_ID exists, the trigger proceeds to count the number of records in the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the newly inserted row, storing the result in v_count. If v_count equals zero, indicating that the SCHOOL_ID does not already exist in the SCHOOL_DETAILS table, the trigger inserts a new record into the SCHOOL_DETAILS table with the SCHOOL_ID from the newly inserted row, and default values for the NICKNAME, COLORS, LEAGUE, CLASS, and DIVISION columns, specifically 'New Player Added', 'Audit Color', 'Audit League', 'Audit Class', and 'Audit Division'.",
    "plsql": "CREATE OR REPLACE TRIGGER player_school_audit\nAFTER INSERT ON PLAYER\nFOR EACH ROW\nDECLARE\n    v_school_name VARCHAR2(255);\n    v_count NUMBER;\nBEGIN\n    -- Check if the SCHOOL_ID exists in the SCHOOL table\n    BEGIN\n        SELECT SCHOOL INTO v_school_name FROM SCHOOL WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            -- If no matching SCHOOL_ID is found, exit the trigger\n            RETURN;\n    END;\n\n    -- Check if the SCHOOL_ID already exists in SCHOOL_DETAILS\n    SELECT COUNT(*) INTO v_count FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n    \n    IF v_count = 0 THEN\n        INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, NICKNAME, COLORS, LEAGUE, CLASS, DIVISION)\n        VALUES (:NEW.SCHOOL_ID, 'New Player Added', 'Audit Color', 'Audit League', 'Audit Class', 'Audit Division');\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (10, 'New Player 1', 'Team A', 18, 'Pitcher', 2)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (11, 'New Player 2', 'Team B', 19, 'Catcher', 3)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (12, 'New Player 3', 'Team C', 20, 'Outfielder', 4)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (13, 'New Player 4', 'Team D', 17, 'First Baseman', 1)",
      "INSERT INTO PLAYER (PLAYER_ID, PLAYER, TEAM, AGE, POSITION, SCHOOL_ID) VALUES (14, 'New Player 5', 'Team E', 16, 'Shortstop', 5)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named player_school_audit on the PLAYER table. For each new row, get the school name from the SCHOOL table using the new SCHOOL_ID. If the school exists, check if its ID is in the SCHOOL_DETAILS table. If not found, insert a default record into SCHOOL_DETAILS with the new SCHOOL_ID and preset values for NICKNAME, COLORS, LEAGUE, CLASS, and DIVISION. If the school does not exist, exit the trigger.",
    "natural_language": "Set up a trigger on the PLAYER table that runs after new entries are added. For each fresh entry, look up the associated school's name. If you find a school, see if its details are already properly recorded. If those details seem to be missing, go ahead and put in a standard set of details for that school, filling in the usual fields. If the school itself isn't there, then just stop and don't do anything further.",
    "id": 37,
    "generated_ir": "Write an Oracle PL/SQL trigger named player_school_audit that is executed after an insert operation on the PLAYER table for each row affected by the insert. The trigger begins by declaring two local variables: v_school_name of type VARCHAR2(255) to store the name of the school, and v_count of type NUMBER to store the count of records. The trigger first attempts to select the SCHOOL column from the SCHOOL table where the SCHOOL_ID matches the SCHOOL_ID of the newly inserted row in the PLAYER table, storing the result in v_school_name. If no matching SCHOOL_ID is found, the NO_DATA_FOUND exception is raised, and the trigger exits without performing further actions. If the SCHOOL_ID exists, the trigger proceeds to count the number of records in the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the newly inserted row, storing the result in v_count. If v_count equals zero, indicating that the SCHOOL_ID does not already exist in the SCHOOL_DETAILS table, the trigger inserts a new record into the SCHOOL_DETAILS table with the SCHOOL_ID from the newly inserted row, and default values for the NICKNAME, COLORS, LEAGUE, CLASS, and DIVISION columns, specifically 'New Player Added', 'Audit Color', 'Audit League', 'Audit Class', and 'Audit Division'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named songs_title_prefix_trigger that fires before any insert or update operation on the SONGS table for each affected row, declaring a local variable v_title_length of type NUMBER, then assigning to it the character length of the new value for the TITLE column from the :NEW pseudorecord, then checking if v_title_length is less than 9 and, if true, prepending the string literal 'PREFIX_' to the :NEW.TITLE value, or else checking if v_title_length is between 9 and 18 inclusive and, if true, prepending the string literal 'SUFFIX_' to the :NEW.TITLE value, or else for any other case where v_title_length is greater than 18, assigning to :NEW.TITLE a new string formed by concatenating the literal 'TRUNC_' with a substring extracted from the original :NEW.TITLE starting at the first character and spanning 15 characters.",
    "plsql": "CREATE OR REPLACE TRIGGER songs_title_prefix_trigger\nBEFORE INSERT OR UPDATE ON SONGS\nFOR EACH ROW\nDECLARE\n    v_title_length NUMBER;\nBEGIN\n    v_title_length := LENGTH(:NEW.TITLE);\n    IF v_title_length < 9 THEN\n        :NEW.TITLE := 'PREFIX_' || :NEW.TITLE;\n    ELSIF v_title_length BETWEEN 9 AND 18 THEN\n        :NEW.TITLE := 'SUFFIX_' || :NEW.TITLE;\n    ELSE\n        :NEW.TITLE := 'TRUNC_' || SUBSTR(:NEW.TITLE, 1, 15);\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS"
    ],
    "call_sqls": [
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (1, 'Short')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (2, 'MediumTitle')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (3, 'ThisIsAVeryLongTitle')",
      "UPDATE SONGS SET TITLE = 'Tiny' WHERE SONGID = 1",
      "UPDATE SONGS SET TITLE = 'AnotherLongTitleExample' WHERE SONGID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named SONGS_TITLE_PREFIX_TRIGGER on the SONGS table. For each row, modify the new TITLE value based on its length: if less than 9 characters, prepend 'PREFIX_'; if between 9 and 18 characters inclusive, prepend 'SUFFIX_'; if greater than 18 characters, replace it with 'TRUNC_' concatenated with the first 15 characters of the original title.",
    "natural_language": "Construct a row-level trigger to be executed before any insertion or update operation on the SONGS table, naming it SONGS_TITLE_PREFIX_TRIGGER. For every individual row being processed, you must carefully adjust the new TITLE value according to a detailed set of length-based rules: should the title contain fewer than nine characters, you are to add the specific string 'PREFIX_' to its beginning; if the title's length falls within the inclusive range of nine to eighteen characters, you must instead prepend the distinct label 'SUFFIX_'; however, in cases where the title exceeds eighteen characters in length, you are required to completely replace it by concatenating the fixed term 'TRUNC_' with precisely the first fifteen characters extracted from the original title.",
    "id": 38,
    "generated_ir": "Write an Oracle PL/SQL trigger named SONGS_TITLE_PREFIX_TRIGGER that executes before any insert or update operation on the SONGS table for each affected row. This trigger is designed to modify the new value of the TITLE column for the row being processed based on its character length. Within the trigger, the logic first determines the length of the new TITLE string value, referenced as :NEW.TITLE. It then applies a conditional rule set. If the length of :NEW.TITLE is less than 9 characters, the trigger modifies :NEW.TITLE by prepending the string literal 'PREFIX_' to its beginning, effectively setting :NEW.TITLE to 'PREFIX_' concatenated with the original title value. If the length of :NEW.TITLE is greater than or equal to 9 characters and simultaneously less than or equal to 18 characters, the trigger modifies :NEW.TITLE by prepending the string literal 'SUFFIX_', effectively setting :NEW.TITLE to 'SUFFIX_' concatenated with the original title value. If the length of :NEW.TITLE is greater than 18 characters, the trigger modifies :NEW.TITLE by first extracting a substring consisting of the first 15 characters from the original title value and then concatenating the string literal 'TRUNC_' to the beginning of this substring, effectively setting :NEW.TITLE to 'TRUNC_' concatenated with the first 15 characters of the original title. This modification of the :NEW.TITLE value occurs directly before the row is inserted or updated into the SONGS table, thereby ensuring the stored data adheres to the specified formatting rules."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_major_update`. This trigger is configured to execute `AFTER` an `UPDATE` operation is performed on the `MAJOR` table. It is a `FOR EACH ROW` trigger, meaning that the trigger body will execute once for every row that is updated in the `MAJOR` table. The trigger body performs a single operation: it executes a `DELETE` statement. This `DELETE` statement targets the `MAJOR_RANKING` table. The rows to be deleted from the `MAJOR_RANKING` table are determined by a `WHERE` clause. The condition in the `WHERE` clause specifies that the `MAJOR_ID` column in the `MAJOR_RANKING` table must be equal to the value of the `MAJOR_ID` column from the row that was just updated in the `MAJOR` table, as referenced by the `:OLD.MAJOR_ID` pseudorecord variable. The `:OLD` pseudorecord provides access to the column values of the row *before* the `UPDATE` operation occurred.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_major_update\nAFTER UPDATE ON MAJOR\nFOR EACH ROW\nBEGIN\n    DELETE FROM MAJOR_RANKING WHERE MAJOR_ID = :OLD.MAJOR_ID;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "UPDATE MAJOR SET MAJOR_NAME = 'Accounting Updated' WHERE MAJOR_ID = 1",
      "UPDATE MAJOR SET MAJOR_NAME = 'Advertising Updated' WHERE MAJOR_ID = 2",
      "UPDATE MAJOR SET MAJOR_NAME = 'Healthcare Management Updated' WHERE MAJOR_ID = 3",
      "UPDATE MAJOR SET MAJOR_CODE = 1055 WHERE MAJOR_ID = 1",
      "UPDATE MAJOR SET MAJOR_CODE = 1056 WHERE MAJOR_ID = 2"
    ],
    "summary": "Create a trigger named trg_major_update that fires AFTER UPDATE on the MAJOR table for each row. For each updated row, delete rows from the MAJOR_RANKING table where MAJOR_ID equals the old MAJOR_ID value from the updated row.",
    "natural_language": "Construct a trigger, which should be named trg_major_update, that is designed to activate automatically AFTER an UPDATE operation is performed on the MAJOR table, specifically for each individual row that is modified. For every row that has been successfully updated, the trigger must then proceed to meticulously delete all corresponding entries from the MAJOR_RANKING table where the MAJOR_ID column precisely matches the previous, or old, MAJOR_ID value that was associated with the recently updated row.",
    "id": 39,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_major_update` that is configured to execute automatically after an `UPDATE` operation is performed on any row within the `MAJOR` table. The trigger is a row-level trigger, meaning it fires once for each individual row that is updated. For each updated row, the trigger performs a `DELETE` operation on the `MAJOR_RANKING` table. The deletion condition is that the `MAJOR_ID` column in the `MAJOR_RANKING` table must exactly match the old value of the `MAJOR_ID` column from the updated row in the `MAJOR` table. This old value is accessed via the `:OLD.MAJOR_ID` pseudorecord within the trigger's body. The purpose of this operation is to remove all ranking records associated with the specific major identifier that existed prior to the update, effectively cleaning up related data in the `MAJOR_RANKING` table whenever a `MAJOR` row's `MAJOR_ID` is changed. The trigger does not return a value, as it is a database trigger that performs a side-effect operation."
  },
  {
    "ir": "Write an Oracle PL/SQL `AFTER UPDATE` row-level trigger named `trg_update_student_logon` that is automatically executed on the `STUDENTS` table. This trigger fires immediately after an `UPDATE` operation is performed on any row within the `STUDENTS` table. For each individual row that is updated, the trigger evaluates a conditional statement. The condition checks if the `DATE_OF_LATEST_LOGON` column in the newly updated row (`:NEW.DATE_OF_LATEST_LOGON`) has a value that is not `NULL`. If this condition evaluates to `TRUE`, meaning a value has been provided for `DATE_OF_LATEST_LOGON` in the updated row, then an `INSERT` operation is performed. This `INSERT` operation adds a new row into the `STUDENT_TESTS_TAKEN` table. The `REGISTRATION_ID` column of the new row in `STUDENT_TESTS_TAKEN` is populated with the value from the `STUDENT_ID` column of the newly updated row in the `STUDENTS` table (`:NEW.STUDENT_ID`). The `DATE_TEST_TAKEN` column of the new row in `STUDENT_TESTS_TAKEN` is populated with the current system timestamp, obtained by calling the `CURRENT_TIMESTAMP` function. The `TEST_RESULT` column of the new row in `STUDENT_TESTS_TAKEN` is populated with the literal string value `'Logon Updated'`. If the initial condition, checking if `:NEW.DATE_OF_LATEST_LOGON` is not `NULL`, evaluates to `FALSE`, then no `INSERT` operation is performed, and the trigger simply completes its execution for that row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_student_logon\nAFTER UPDATE ON STUDENTS\nFOR EACH ROW\nBEGIN\n    IF :NEW.DATE_OF_LATEST_LOGON IS NOT NULL THEN\n        INSERT INTO STUDENT_TESTS_TAKEN (REGISTRATION_ID, DATE_TEST_TAKEN, TEST_RESULT)\n        VALUES (:NEW.STUDENT_ID, CURRENT_TIMESTAMP, 'Logon Updated');\n    END IF;\nEND;",
    "database_name": "e_learning",
    "tables": [
      "COURSES",
      "COURSE_AUTHORS_AND_TUTORS",
      "STUDENTS",
      "STUDENT_COURSE_ENROLMENT",
      "STUDENT_TESTS_TAKEN",
      "SUBJECTS"
    ],
    "call_sqls": [
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-01-01 10:00:00' WHERE STUDENT_ID = 1",
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-02-15 11:30:00' WHERE STUDENT_ID = 2",
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-03-20 09:45:00' WHERE STUDENT_ID = 3",
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-04-05 14:00:00' WHERE STUDENT_ID = 1",
      "UPDATE STUDENTS SET DATE_OF_LATEST_LOGON = '2023-05-10 16:15:00' WHERE STUDENT_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_update_student_logon on the STUDENTS table. For each updated row, if :NEW.DATE_OF_LATEST_LOGON is not NULL, insert a new row into STUDENT_TESTS_TAKEN. Populate REGISTRATION_ID with :NEW.STUDENT_ID, DATE_TEST_TAKEN with CURRENT_TIMESTAMP, and TEST_RESULT with 'Logon Updated'.",
    "natural_language": "Set up a trigger on the STUDENTS table that runs after updates. For any student record that gets changed, if their latest logon date is filled in, then add a note about it to the student tests log. Use the student's ID for the registration, the current time for the date, and just mark the result as a logon update.",
    "id": 40,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_student_logon that is executed after an update operation on the STUDENTS table for each row affected by the update. The trigger begins by declaring a local variable v_registration_id of type NUMBER, which will store a registration ID from the STUDENT_COURSE_ENROLMENT table. The trigger logic first checks if the new value of DATE_OF_LATEST_LOGON in the updated row is not NULL, indicating that the student's latest logon date has been populated. If this condition is true, it proceeds to select a REGISTRATION_ID from the STUDENT_COURSE_ENROLMENT table into v_registration_id, specifically from the first row where the STUDENT_ID column matches the new STUDENT_ID of the updated student row, ordered by DATE_OF_ENROLMENT in ascending order to get the earliest enrolment. If no such registration is found, v_registration_id remains NULL. The trigger then inserts a new record into the STUDENT_TESTS_TAKEN table with the following values: v_registration_id for the REGISTRATION_ID column, the current system date and time for the DATE_TEST_TAKEN column, and the string 'Logon Update' for the TEST_RESULT column. This operation logs the student's logon update as an entry in the student tests log."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_station_year_validation that is executed before an INSERT or UPDATE operation on the GAS_STATION table for each row affected. The trigger begins by declaring two local variables: v_current_year and v_oldest_year, both of type NUMBER. It then retrieves the current year from the system date using the EXTRACT function and stores it in v_current_year. Next, it selects the minimum value from the OPEN_YEAR column of the GAS_STATION table and assigns it to v_oldest_year. The trigger then evaluates the OPEN_YEAR value of the new row being inserted or updated. If the OPEN_YEAR is greater than the current year, it sets OPEN_YEAR to the current year. If OPEN_YEAR is less than the oldest year found in the GAS_STATION table, it sets OPEN_YEAR to the oldest year. Additionally, if OPEN_YEAR is less than 1990, it sets OPEN_YEAR to 1990. The trigger ensures that the OPEN_YEAR value for any new or updated row in the GAS_STATION table is constrained to be no greater than the current year, no less than the oldest year in the table, and no less than 1990.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_station_year_validation\nBEFORE INSERT OR UPDATE ON GAS_STATION\nFOR EACH ROW\nDECLARE\n    v_current_year NUMBER;\n    v_oldest_year NUMBER;\nBEGIN\n    SELECT EXTRACT(YEAR FROM SYSDATE) INTO v_current_year FROM DUAL;\n    SELECT MIN(OPEN_YEAR) INTO v_oldest_year FROM GAS_STATION;\n    IF :NEW.OPEN_YEAR > v_current_year THEN\n        :NEW.OPEN_YEAR := v_current_year;\n    ELSIF :NEW.OPEN_YEAR < v_oldest_year THEN\n        :NEW.OPEN_YEAR := v_oldest_year;\n    END IF;\n    IF :NEW.OPEN_YEAR < 1990 THEN\n        :NEW.OPEN_YEAR := 1990;\n    END IF;\nEND;",
    "database_name": "gas_company",
    "tables": [
      "COMPANY",
      "GAS_STATION",
      "STATION_COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (100, 2025, 'Test Location 1', 'Manager 1', 'Vice Manager 1', 'Rep 1')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (101, 1980, 'Test Location 2', 'Manager 2', 'Vice Manager 2', 'Rep 2')",
      "INSERT INTO GAS_STATION (STATION_ID, OPEN_YEAR, LOCATION, MANAGER_NAME, VICE_MANAGER_NAME, REPRESENTATIVE_NAME) VALUES (102, 2005, 'Test Location 3', 'Manager 3', 'Vice Manager 3', 'Rep 3')",
      "UPDATE GAS_STATION SET OPEN_YEAR = 2030 WHERE STATION_ID = 1",
      "UPDATE GAS_STATION SET OPEN_YEAR = 1970 WHERE STATION_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_station_year_validation on the GAS_STATION table. For each new or modified row, constrain the OPEN_YEAR value: it must not be greater than the current year, not less than the oldest OPEN_YEAR in the table, and not less than 1990. Adjust the value to these boundaries if necessary.",
    "natural_language": "Hey, can you set up a trigger called trg_station_year_validation for the GAS_STATION table? It should fire before any new row is added or an existing one is updated. Basically, for each row, we need to keep the OPEN_YEAR in check: it shouldn't be later than this year, shouldn't be older than the earliest OPEN_YEAR we already have on file, and it's gotta be 1990 or later. If the value's out of bounds, just tweak it to fit within those limits.",
    "id": 41,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_station_year_validation that is executed before an INSERT or UPDATE operation on the GAS_STATION table for each row affected. The trigger begins by declaring two local variables: v_current_year and v_oldest_year, both of type NUMBER. It then retrieves the current year from the system date using the EXTRACT function and stores it in v_current_year. Next, it selects the minimum value from the OPEN_YEAR column of the GAS_STATION table and assigns it to v_oldest_year. The trigger then evaluates the OPEN_YEAR value of the new row being inserted or updated. If the OPEN_YEAR is greater than the current year, it sets OPEN_YEAR to the current year. If OPEN_YEAR is less than the oldest year found in the GAS_STATION table, it sets OPEN_YEAR to the oldest year. Additionally, if OPEN_YEAR is less than 1990, it sets OPEN_YEAR to 1990. The trigger ensures that the OPEN_YEAR value for any new or updated row in the GAS_STATION table is constrained to be no greater than the current year, no less than the oldest year in the table, and no less than 1990."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_box_contents that is executed before an update operation on the BOXES table. This trigger operates on each row that is being updated. The trigger modifies the value of the CONTENTS column in the row being updated. Specifically, it sets the CONTENTS column to the result of the INITCAP function applied to the new value of CONTENTS. The INITCAP function is a built-in Oracle function that converts the first letter of each word in a string to uppercase and the remaining letters to lowercase. The trigger uses the :NEW pseudorecord to access the new value of the CONTENTS column, which represents the value that will be stored in the database after the update operation. The trigger does not perform any conditional checks or additional operations beyond applying the INITCAP function to the CONTENTS column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_box_contents\nBEFORE UPDATE ON BOXES\nFOR EACH ROW\nBEGIN\n    :NEW.CONTENTS := INITCAP(:NEW.CONTENTS);\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "UPDATE BOXES SET CONTENTS = 'rocks' WHERE CODE = '0MN7'",
      "UPDATE BOXES SET CONTENTS = 'scissors' WHERE CODE = '4H8P'",
      "UPDATE BOXES SET CONTENTS = 'paper' WHERE CODE = '4RT3'",
      "UPDATE BOXES SET CONTENTS = 'sand' WHERE CODE = '0MN7'",
      "UPDATE BOXES SET CONTENTS = 'gravel' WHERE CODE = '4H8P'"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_update_box_contents on the BOXES table. For each updated row, set the :NEW.CONTENTS to INITCAP(:NEW.CONTENTS).",
    "natural_language": "Set up a trigger on the BOXES table that runs before any updates. For each row being changed, make sure the contents field gets a bit of formatting, like capitalizing the first letter of each word or something similar. Name the trigger something like trg_update_box_contents.",
    "id": 42,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_box_contents that fires before each update operation on the BOXES table. The trigger is a row-level trigger, executing once for each row being updated. The trigger declares a local variable v_formatted_contents of type VARCHAR2(255) to hold the intermediate formatted string. For each row, the trigger takes the current value of the CONTENTS column from the new row being updated, referenced as :NEW.CONTENTS, and applies a formatting transformation to it. Specifically, it capitalizes the first letter of each word in the string and converts the remaining letters to lowercase, effectively implementing proper case formatting. This transformation is achieved using a combination of the INITCAP function, which capitalizes the first letter of each word and lowercases the rest. The result of this function call is stored in the v_formatted_contents variable. Then, the trigger sets the :NEW.CONTENTS column to the value stored in v_formatted_contents, thereby updating the contents field with the formatted version before the row is persisted to the database. No additional SQL operations such as SELECT, INSERT, or UPDATE on other tables are performed, and no conditions or control flow logic beyond the inherent row-level execution are included. The trigger operates solely on the BOXES table, specifically the CONTENTS column, and does not involve the WAREHOUSES table or any other columns."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_major_ranking_del that is a compound trigger designed to execute on the DELETE operation of the MAJOR_RANKING table. This trigger uses two collections, university_ids and major_ids, both of which are of the type id_list, a nested table of NUMBER, to store the UNIVERSITY_ID and MAJOR_ID values of the rows being deleted. The trigger consists of three sections: BEFORE STATEMENT, AFTER EACH ROW, and AFTER STATEMENT. In the BEFORE STATEMENT section, the trigger initializes the university_ids and major_ids collections by deleting any existing elements. In the AFTER EACH ROW section, the trigger appends the UNIVERSITY_ID and MAJOR_ID of each deleted row to the university_ids and major_ids collections, respectively, using the EXTEND method to increase the size of the collections and the COUNT method to determine the current number of elements. In the AFTER STATEMENT section, the trigger iterates over each element in the university_ids collection using a FOR loop. For each university_id, it declares a local variable v_count of type NUMBER and executes a SELECT COUNT(*) query on the MAJOR_RANKING table to count the number of remaining rows with the same UNIVERSITY_ID. If v_count is zero, indicating no remaining rows with that UNIVERSITY_ID, the trigger deletes the corresponding row from the UNIVERSITY table. Similarly, the trigger iterates over each element in the major_ids collection, performs a SELECT COUNT(*) query to count the remaining rows with the same MAJOR_ID in the MAJOR_RANKING table, and deletes the corresponding row from the MAJOR table if v_count is zero. This ensures that orphaned records in the UNIVERSITY and MAJOR tables are removed when all associated entries in the MAJOR_RANKING table are deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_major_ranking_del\nFOR DELETE ON MAJOR_RANKING\nCOMPOUND TRIGGER\n\n  TYPE id_list IS TABLE OF NUMBER;\n  university_ids id_list := id_list();\n  major_ids id_list := id_list();\n\n  BEFORE STATEMENT IS\n  BEGIN\n    university_ids.DELETE;\n    major_ids.DELETE;\n  END BEFORE STATEMENT;\n\n  AFTER EACH ROW IS\n  BEGIN\n    university_ids.EXTEND;\n    university_ids(university_ids.COUNT) := :OLD.UNIVERSITY_ID;\n\n    major_ids.EXTEND;\n    major_ids(major_ids.COUNT) := :OLD.MAJOR_ID;\n  END AFTER EACH ROW;\n\n  AFTER STATEMENT IS\n  BEGIN\n    FOR i IN 1 .. university_ids.COUNT LOOP\n      DECLARE\n        v_count NUMBER;\n      BEGIN\n        SELECT COUNT(*) INTO v_count FROM MAJOR_RANKING WHERE UNIVERSITY_ID = university_ids(i);\n        IF v_count = 0 THEN\n          DELETE FROM UNIVERSITY WHERE UNIVERSITY_ID = university_ids(i);\n        END IF;\n      END;\n    END LOOP;\n\n    FOR i IN 1 .. major_ids.COUNT LOOP\n      DECLARE\n        v_count NUMBER;\n      BEGIN\n        SELECT COUNT(*) INTO v_count FROM MAJOR_RANKING WHERE MAJOR_ID = major_ids(i);\n        IF v_count = 0 THEN\n          DELETE FROM MAJOR WHERE MAJOR_ID = major_ids(i);\n        END IF;\n      END;\n    END LOOP;\n  END AFTER STATEMENT;\n\nEND trg_major_ranking_del;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "OVERALL_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 1 AND MAJOR_ID = 1",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 3 AND MAJOR_ID = 3",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 2 AND MAJOR_ID = 1",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 3 AND MAJOR_ID = 1",
      "DELETE FROM MAJOR_RANKING WHERE RANK = 1 AND UNIVERSITY_ID = 1 AND MAJOR_ID = 3"
    ],
    "summary": "Create a compound trigger named trg_major_ranking_del for DELETE operations on the MAJOR_RANKING table. In BEFORE STATEMENT, initialize two NUMBER collections. In AFTER EACH ROW, store deleted UNIVERSITY_ID and MAJOR_ID in the collections. In AFTER STATEMENT, for each stored UNIVERSITY_ID and MAJOR_ID, if no related rows remain in MAJOR_RANKING, delete the corresponding parent record from the UNIVERSITY or MAJOR table.",
    "natural_language": "Construct a compound trigger, which should be named trg_major_ranking_del, to specifically handle DELETE operations on the MAJOR_RANKING table. In the BEFORE STATEMENT section, you must carefully initialize two distinct NUMBER collections. Subsequently, in the AFTER EACH ROW section, you need to capture and securely store the deleted UNIVERSITY_ID and MAJOR_ID values within those previously initialized collections. Finally, in the AFTER STATEMENT section, for every single stored pair of UNIVERSITY_ID and MAJOR_ID, you must perform a thorough check to see if any related rows still persist in the MAJOR_RANKING table; if no such related rows remain, you are then required to delete the corresponding parent record from either the UNIVERSITY table or the MAJOR table.",
    "id": 43,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_major_ranking_del that is a compound trigger designed to execute on the DELETE operation of the MAJOR_RANKING table. This trigger uses two collections, university_ids and major_ids, both of which are of the type id_list, a nested table of NUMBER, to store the UNIVERSITY_ID and MAJOR_ID values of the rows being deleted. The trigger consists of three sections: BEFORE STATEMENT, AFTER EACH ROW, and AFTER STATEMENT. In the BEFORE STATEMENT section, the trigger initializes the university_ids and major_ids collections by deleting any existing elements. In the AFTER EACH ROW section, the trigger appends the UNIVERSITY_ID and MAJOR_ID of each deleted row to the university_ids and major_ids collections, respectively, using the EXTEND method to increase the size of the collections and the COUNT method to determine the current number of elements. In the AFTER STATEMENT section, the trigger iterates over each element in the university_ids collection using a FOR loop. For each university_id, it declares a local variable v_count of type NUMBER and executes a SELECT COUNT(*) query on the MAJOR_RANKING table to count the number of remaining rows with the same UNIVERSITY_ID. If v_count is zero, indicating no remaining rows with that UNIVERSITY_ID, the trigger deletes the corresponding row from the UNIVERSITY table. Similarly, the trigger iterates over each element in the major_ids collection, performs a SELECT COUNT(*) query to count the remaining rows with the same MAJOR_ID in the MAJOR_RANKING table, and deletes the corresponding row from the MAJOR table if v_count is zero. This ensures that orphaned records in the UNIVERSITY and MAJOR tables are removed when all associated entries in the MAJOR_RANKING table are deleted."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger that is executed automatically before an INSERT operation is performed on the DIRECTOR table. The trigger modifies the value of the NAME column in the row being inserted by converting the value to uppercase using the UPPER() function. The trigger uses the :NEW pseudo-record to access the NAME column of the row that is about to be inserted. Specifically, the :NEW.NAME reference represents the value of the NAME column in the new row being inserted into the DIRECTOR table. The UPPER() function is applied to this value, which converts all alphabetic characters in the NAME column to their uppercase equivalents. The modified uppercase value is then assigned back to :NEW.NAME, ensuring that the NAME column in the inserted row always contains an uppercase version of the original input. The trigger operates on each row being inserted into the DIRECTOR table, as indicated by the FOR EACH ROW clause, and does not include any conditional logic or additional operations beyond the uppercase conversion.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_director_name_uppercase\nBEFORE INSERT ON DIRECTOR\nFOR EACH ROW\nBEGIN\n  :NEW.NAME := UPPER(:NEW.NAME);\nEND;",
    "database_name": "imdb",
    "tables": [
      "TV_SERIES",
      "DIRECTED_BY",
      "DIRECTOR",
      "PRODUCER",
      "WRITER",
      "COMPANY"
    ],
    "call_sqls": [
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (1, 'Male', 'john doe', 'American', 'New York', 1970)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (2, 'Female', 'jane smith', 'British', 'London', 1985)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (3, 'Male', 'peter jones', 'Australian', 'Sydney', 1962)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (4, 'Female', 'maria garcia', 'Spanish', 'Madrid', 1978)",
      "INSERT INTO DIRECTOR (DID, GENDER, NAME, NATIONALITY, BIRTH_CITY, BIRTH_YEAR) VALUES (5, 'Male', 'li wei', 'Chinese', 'Beijing', 1990)"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger on the DIRECTOR table. Convert the new NAME value to uppercase before insertion.",
    "natural_language": "Set up a trigger on the DIRECTOR table that runs before any new row is added. It should do something to make the NAME data look more standardized, maybe by adjusting the letter case in a certain way before it gets saved.",
    "id": 44,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_insert_director_name_uppercase` that is activated on the `DIRECTOR` table before any new row is inserted. This trigger operates on each row individually before the insertion occurs.\n\nThe trigger's purpose is to standardize the data in the `NAME` column by converting its letter case. Specifically, the trigger performs an `UPDATE` operation on the new row's values before they are written to the table. It modifies the `:NEW.NAME` pseudorecord variable by applying the `UPPER` function to it. The `UPPER` function converts all alphabetic characters in the `:NEW.NAME` value to uppercase. This transformation ensures that the `NAME` data is stored in a standardized uppercase format, regardless of how it was originally provided in the insert statement. No other columns in the `DIRECTOR` table are altered by this trigger."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_audit that is executed before an insert or update operation on the SCHOOL table for each row affected. The trigger declares a local variable v_count of type NUMBER to store the count of records. It performs a SELECT operation to count the number of rows in the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the new row being inserted or updated. If the operation is an insert, the trigger checks if v_count is zero, indicating no existing record in SCHOOL_DETAILS for the given SCHOOL_ID. If true, it inserts a new row into SCHOOL_DETAILS with SCHOOL_ID set to the new row's SCHOOL_ID, NICKNAME set to the first 10 characters of the new row's SCHOOL column, and COLORS set to 'Unknown', while LEAGUE, CLASS, and DIVISION are set to NULL. If the operation is an update, the trigger checks if v_count is greater than zero, indicating an existing record in SCHOOL_DETAILS for the given SCHOOL_ID. If true, it updates the COLORS column in SCHOOL_DETAILS to the new row's SCHOOL_COLORS where SCHOOL_ID matches the new row's SCHOOL_ID. If v_count is zero, it inserts a new row into SCHOOL_DETAILS with SCHOOL_ID set to the new row's SCHOOL_ID, NICKNAME set to the first 10 characters of the new row's SCHOOL column, COLORS set to the new row's SCHOOL_COLORS, and LEAGUE, CLASS, and DIVISION set to NULL. The trigger includes an exception handler for the DUP_VAL_ON_INDEX exception, which does nothing when this exception occurs.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_audit\nBEFORE INSERT OR UPDATE ON SCHOOL\nFOR EACH ROW\nDECLARE\n   v_count NUMBER;\nBEGIN\n   SELECT COUNT(*) INTO v_count FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n   \n   IF INSERTING THEN\n      IF v_count = 0 THEN\n         INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, NICKNAME, COLORS, LEAGUE, CLASS, DIVISION) \n         VALUES (:NEW.SCHOOL_ID, SUBSTR(:NEW.SCHOOL, 1, 10), 'Unknown', NULL, NULL, NULL);\n      END IF;\n   ELSIF UPDATING THEN\n      IF v_count > 0 THEN\n         UPDATE SCHOOL_DETAILS \n         SET COLORS = :NEW.SCHOOL_COLORS \n         WHERE SCHOOL_ID = :NEW.SCHOOL_ID;\n      ELSE\n         INSERT INTO SCHOOL_DETAILS (SCHOOL_ID, NICKNAME, COLORS, LEAGUE, CLASS, DIVISION)\n         VALUES (:NEW.SCHOOL_ID, SUBSTR(:NEW.SCHOOL, 1, 10), :NEW.SCHOOL_COLORS, NULL, NULL, NULL);\n      END IF;\n   END IF;\nEXCEPTION\n   WHEN DUP_VAL_ON_INDEX THEN\n      NULL;\nEND;",
    "database_name": "school_player",
    "tables": [
      "SCHOOL",
      "SCHOOL_DETAILS"
    ],
    "call_sqls": [
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (10, 'New School A', 'Sydney', 500, 2000, 'Anglican', 'Co-ed', 'Day', 2010, 'Green & Gold')",
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (11, 'Another School B', 'Melbourne', 750, 1995, 'Catholic', 'Boys', 'Day & Boarding', 2005, 'Blue & White')",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Purple & Yellow' WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Orange & Black', ENROLLMENT = 1200 WHERE SCHOOL_ID = 3",
      "INSERT INTO SCHOOL (SCHOOL_ID, SCHOOL, LOCATION, ENROLLMENT, FOUNDED, DENOMINATION, BOYS_OR_GIRLS, DAY_OR_BOARDING, YEAR_ENTERED_COMPETITION, SCHOOL_COLORS) VALUES (12, 'Test School C', 'Brisbane', 300, 2015, 'Uniting Church', 'Girls', 'Day', 2018, 'Pink & Grey')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_school_audit on the SCHOOL table. It checks if a SCHOOL_DETAILS record exists for the NEW.SCHOOL_ID. For INSERTs with no existing record, it inserts a new SCHOOL_DETAILS row with default values. For UPDATEs, it updates the existing SCHOOL_DETAILS.COLORS or inserts a new row if none exists. Handle DUP_VAL_ON_INDEX by ignoring it.",
    "natural_language": "Create a row-level trigger named trg_school_audit on the SCHOOL table to fire BEFORE INSERT OR UPDATE. For each row, check if a SCHOOL_DETAILS record exists for the NEW.SCHOOL_ID. If it's an INSERT and no record exists, insert a new SCHOOL_DETAILS row with default values. If it's an UPDATE, update the existing SCHOOL_DETAILS.COLORS or insert a new row if none exists. Ignore any DUP_VAL_ON_INDEX exception.",
    "id": 45,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_school_audit` that is configured to execute `BEFORE` any `INSERT` or `UPDATE` operation on the `SCHOOL` table. This trigger is defined to execute `FOR EACH ROW` affected by the `INSERT` or `UPDATE` statement, meaning its logic will be applied individually to every new or modified row being processed.\n\nWithin the trigger's execution block, a local PL/SQL variable named `v_details_count` is declared, of data type `NUMBER`, to store the count of existing records. The trigger first performs a `SELECT COUNT(*)` query into the variable `v_details_count` from the `SCHOOL_DETAILS` table. The query uses a `WHERE` clause to check if the `SCHOOL_ID` column in `SCHOOL_DETAILS` matches the `SCHOOL_ID` value from the `NEW` pseudorecord of the current row in the `SCHOOL` table. The `NEW` pseudorecord refers to the data of the row as it will be after the `INSERT` or `UPDATE` operation.\n\nSubsequently, a conditional statement (`IF`) checks the type of operation being performed by evaluating the boolean condition `INSERTING`. If `INSERTING` is `TRUE`, indicating an `INSERT` operation on the `SCHOOL` table, the trigger enters a nested conditional block. Inside this block, it checks if the value stored in `v_details_count` is equal to the numeric literal `0`. If this condition evaluates to `TRUE`, meaning no corresponding record exists in the `SCHOOL_DETAILS` table for the new `SCHOOL_ID`, then the trigger executes an `INSERT` statement into the `SCHOOL_DETAILS` table. This `INSERT` statement provides values for the columns: it sets the `SCHOOL_ID` column to the `SCHOOL_ID` value from the `NEW` pseudorecord, sets the `NICKNAME` column to the string literal `'Default Nickname'`, sets the `COLORS` column to the string literal `'Default Colors'`, and sets the `LEAGUE`, `CLASS`, and `DIVISION` columns to the `NULL` value.\n\nIf the `INSERTING` condition is `FALSE`, indicating an `UPDATE` operation on the `SCHOOL` table, the trigger enters an alternative execution path (`ELSE` block). Within this block, another conditional statement (`IF`) checks if the value stored in `v_details_count` is greater than the numeric literal `0`. If this condition evaluates to `TRUE`, meaning at least one corresponding record exists in the `SCHOOL_DETAILS` table, then the trigger executes an `UPDATE` statement on the `SCHOOL_DETAILS` table. This `UPDATE` statement uses a `WHERE` clause to target the specific row where the `SCHOOL_ID` column matches the `SCHOOL_ID` value from the `NEW` pseudorecord. The statement sets the `COLORS` column in `SCHOOL_DETAILS` to the value of the `SCHOOL_COLORS` column from the `NEW` pseudorecord of the `SCHOOL` table.\n\nIf, during the `UPDATE` operation, the condition `v_details_count > 0` evaluates to `FALSE` (meaning no corresponding record exists), the trigger executes an `INSERT` statement into the `SCHOOL_DETAILS` table. This `INSERT` statement is identical to the one used for the `INSERT` operation case: it sets the `SCHOOL_ID` column to the `SCHOOL_ID` value from the `NEW` pseudorecord, sets the `NICKNAME` column to `'Default Nickname'`, sets the `COLORS` column to the value of the `SCHOOL_COLORS` column from the `NEW` pseudorecord, and sets the `LEAGUE`, `CLASS`, and `DIVISION` columns to `NULL`.\n\nThe entire block of code containing the `INSERT` and `UPDATE` statements on the `SCHOOL_DETAILS` table is enclosed within a `BEGIN ... EXCEPTION ... END` sub-block. An exception handler is defined to catch any `DUP_VAL_ON_INDEX` exception that might be raised. This exception typically occurs if an `INSERT` statement violates a primary key or unique constraint on the `SCHOOL_DETAILS` table (specifically on the `SCHOOL_ID` column, which is its primary key). The handler for this exception is empty, containing no executable statements, which means if such an exception is raised, it is silently ignored, and the trigger's execution continues without error."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_singer_net_worth that is executed before an insert or update operation on the SINGER table for each row affected. The trigger begins by declaring two local variables: v_song_count of type NUMBER, which will store the count of songs associated with a singer, and v_next_song_id of type NUMBER, which will be used to determine the next song ID for insertion. The trigger first checks if the NET_WORTH_MILLIONS column of the new row being inserted or updated is greater than 50. If this condition is true, it updates the SONG table by increasing the SALES column by 10,000 for all rows where the SINGER_ID matches the SINGER_ID of the new row. If the NET_WORTH_MILLIONS is not greater than 50, it deletes rows from the SONG table where the SINGER_ID matches the SINGER_ID of the new row and the SALES column is less than 200,000. The trigger then performs a SELECT COUNT(*) operation to count the number of songs associated with the SINGER_ID of the new row and stores this count in the v_song_count variable. If v_song_count is greater than 5, the trigger calculates the next song ID by selecting the maximum SONG_ID from the SONG table, using the NVL function to handle null values, and adding 1 to this maximum value, storing the result in v_next_song_id. It then inserts a new row into the SONG table with the calculated v_next_song_id, a TITLE of 'New Hit', the SINGER_ID from the new row, SALES set to 500,000, and HIGHEST_POSITION set to 1. Additionally, the trigger checks if the CITIZENSHIP column of the new row is 'Unknown'. If so, it updates the CITIZENSHIP column to 'International'. The trigger includes an exception handler that catches any errors during execution and raises an application error with the code -20001 and a message that includes the error description using SQLERRM.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_net_worth\nBEFORE INSERT OR UPDATE ON SINGER\nFOR EACH ROW\nDECLARE\n   v_song_count NUMBER;\n   v_next_song_id NUMBER;\nBEGIN\n   IF :NEW.NET_WORTH_MILLIONS > 50 THEN\n      UPDATE SONG SET SALES = SALES + 10000 WHERE SINGER_ID = :NEW.SINGER_ID;\n   ELSE\n      DELETE FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID AND SALES < 200000;\n   END IF;\n   \n   SELECT COUNT(*) INTO v_song_count FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID;\n   \n   IF v_song_count > 5 THEN\n      SELECT NVL(MAX(SONG_ID), 0) + 1 INTO v_next_song_id FROM SONG;\n      INSERT INTO SONG (SONG_ID, TITLE, SINGER_ID, SALES, HIGHEST_POSITION)\n      VALUES (v_next_song_id, 'New Hit', :NEW.SINGER_ID, 500000, 1);\n   END IF;\n   \n   IF :NEW.CITIZENSHIP = 'Unknown' THEN\n      :NEW.CITIZENSHIP := 'International';\n   END IF;\nEXCEPTION\n   WHEN OTHERS THEN\n      RAISE_APPLICATION_ERROR(-20001, 'Error in trigger: ' || SQLERRM);\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (10, 'New Singer 1', 1990, 60, 'USA')",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 70 WHERE SINGER_ID = 1",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (11, 'New Singer 2', 1985, 40, 'UK')",
      "UPDATE SINGER SET CITIZENSHIP = 'Unknown' WHERE SINGER_ID = 2",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (12, 'New Singer 3', 1995, 55, 'France')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named trg_singer_net_worth on the SINGER table. Declare local NUMBER variables v_song_count and v_next_song_id. If the new NET_WORTH_MILLIONS > 50, update the SONG table to increase SALES by 10,000 for all songs by this singer. Otherwise, delete songs by this singer where SALES < 200,000. Then, count the singer's songs. If the count > 5, calculate the next SONG_ID and insert a new song with TITLE='New Hit', the singer's SINGER_ID, SALES=500,000, and HIGHEST_POSITION=1. If the new CITIZENSHIP is 'Unknown', update it to 'International'. Include an exception handler to raise application error -20001 with the SQLERRM message.",
    "natural_language": "How can I create a BEFORE INSERT OR UPDATE row-level trigger called trg_singer_net_worth for the SINGER table? The trigger should declare local NUMBER variables v_song_count and v_next_song_id. If the new NET_WORTH_MILLIONS exceeds 50, how do I update the SONG table to increase SALES by 10,000 for all songs by this singer? Otherwise, how do I delete songs by this singer where SALES is below 200,000? After that, how do I count the singer's songs? If the count is greater than 5, how do I calculate the next SONG_ID and insert a new song with TITLE='New Hit', the singer's SINGER_ID, SALES=500,000, and HIGHEST_POSITION=1? Also, if the new CITIZENSHIP is 'Unknown', how do I update it to 'International'? Finally, how do I include an exception handler to raise application error -20001 with the SQLERRM message?",
    "id": 46,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_singer_net_worth that is executed before an insert or update operation on the SINGER table for each row affected. The trigger begins by declaring two local variables: v_song_count of type NUMBER, which will store the count of songs associated with a singer, and v_next_song_id of type NUMBER, which will be used to determine the next song ID for insertion. The trigger first checks if the NET_WORTH_MILLIONS column of the new row being inserted or updated is greater than 50. If this condition is true, it updates the SONG table by increasing the SALES column by 10,000 for all rows where the SINGER_ID matches the SINGER_ID of the new row. If the NET_WORTH_MILLIONS is not greater than 50, it deletes rows from the SONG table where the SINGER_ID matches the SINGER_ID of the new row and the SALES column is less than 200,000. The trigger then performs a SELECT COUNT(*) operation to count the number of songs associated with the SINGER_ID of the new row and stores this count in the v_song_count variable. If v_song_count is greater than 5, the trigger calculates the next song ID by selecting the maximum SONG_ID from the SONG table, using the NVL function to handle null values, and adding 1 to this maximum value, storing the result in v_next_song_id. It then inserts a new row into the SONG table with the calculated v_next_song_id, a TITLE of 'New Hit', the SINGER_ID from the new row, SALES set to 500,000, and HIGHEST_POSITION set to 1. Additionally, the trigger checks if the CITIZENSHIP column of the new row is 'Unknown'. If so, it updates the CITIZENSHIP column to 'International'. The trigger includes an exception handler that catches any errors during execution and raises an application error with the code -20001 and a message that includes the error description using SQLERRM."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_sync_manager_department` that is activated `AFTER` an `UPDATE` operation specifically on the `MANAGER_ID` column of the `DEPARTMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is affected by the `UPDATE` statement. Upon activation, the trigger first declares a local variable named `v_employee_count` of data type `NUMBER`. Subsequently, it executes a `SELECT` statement to `COUNT` the total number of rows in the `EMPLOYEES` table where the `DEPARTMENT_ID` column matches the `DEPARTMENT_ID` of the row currently being updated in the `DEPARTMENTS` table (referred to as `:NEW.DEPARTMENT_ID`). The result of this `COUNT` operation is then stored into the `v_employee_count` variable. Following this, the trigger performs an `UPDATE` operation on the `EMPLOYEES` table. In this `UPDATE` operation, it sets the value of the `MANAGER_ID` column for all rows in the `EMPLOYEES` table to the new `MANAGER_ID` value of the updated department (referred to as `:NEW.MANAGER_ID`). This `UPDATE` is applied only to those rows in the `EMPLOYEES` table where the `DEPARTMENT_ID` column matches the `DEPARTMENT_ID` of the row currently being updated in the `DEPARTMENTS` table (referred to as `:NEW.DEPARTMENT_ID`). The trigger concludes its execution after this `UPDATE` statement.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_manager_department\nAFTER UPDATE OF MANAGER_ID ON DEPARTMENTS\nFOR EACH ROW\nDECLARE\n  v_employee_count NUMBER;\nBEGIN\n  SELECT COUNT(*) INTO v_employee_count FROM EMPLOYEES WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;\n  UPDATE EMPLOYEES SET MANAGER_ID = :NEW.MANAGER_ID WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "UPDATE DEPARTMENTS SET MANAGER_ID = 200 WHERE DEPARTMENT_ID = 10",
      "UPDATE DEPARTMENTS SET MANAGER_ID = 201 WHERE DEPARTMENT_ID = 20",
      "UPDATE DEPARTMENTS SET MANAGER_ID = 114 WHERE DEPARTMENT_ID = 30",
      "UPDATE DEPARTMENTS SET MANAGER_ID = 100 WHERE DEPARTMENT_ID = 10",
      "UPDATE DEPARTMENTS SET MANAGER_ID = 200 WHERE DEPARTMENT_ID = 20"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_sync_manager_department on the DEPARTMENTS table that fires when MANAGER_ID is updated. The trigger should count employees in the matching department, then update all employees in that department to have the new manager ID.",
    "natural_language": "Create trigger trg_sync_manager_department on DEPARTMENTS after update of MANAGER_ID. For each row, count the department's employees and set their manager to the new ID.",
    "id": 47,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_sync_manager_department` that is activated `AFTER` an `UPDATE` operation specifically on the `MANAGER_ID` column of the `DEPARTMENTS` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is affected by the `UPDATE` statement. Upon activation, the trigger first declares a local variable named `v_employee_count` of data type `NUMBER`. Subsequently, it executes a `SELECT` statement to `COUNT` the total number of rows in the `EMPLOYEES` table where the `DEPARTMENT_ID` column matches the `DEPARTMENT_ID` of the row currently being updated in the `DEPARTMENTS` table (referred to as `:NEW.DEPARTMENT_ID`). The result of this `COUNT` operation is then stored into the `v_employee_count` variable. Following this, the trigger performs an `UPDATE` operation on the `EMPLOYEES` table. In this `UPDATE` operation, it sets the value of the `MANAGER_ID` column for all rows in the `EMPLOYEES` table to the new `MANAGER_ID` value of the updated department (referred to as `:NEW.MANAGER_ID`). This `UPDATE` is applied only to those rows in the `EMPLOYEES` table where the `DEPARTMENT_ID` column matches the `DEPARTMENT_ID` of the row currently being updated in the `DEPARTMENTS` table (referred to as `:NEW.DEPARTMENT_ID`). The trigger concludes its execution after this `UPDATE` statement."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named adjust_points_by_age that fires before any insert or update operation on the GYMNAST table for each affected row, which declares a local variable v_people_age of type NUMBER, then queries the AGE column from the PEOPLE table by selecting the row where the PEOPLE_ID column matches the new GYMNAST_ID value from the triggering row in the GYMNAST table, storing the result in v_people_age, and subsequently uses a conditional IF-ELSIF-ELSE block to adjust the new TOTAL_POINTS value in the GYMNAST row: if the retrieved age equals 18, the new TOTAL_POINTS is multiplied by 1.1; if the age equals 19, it is multiplied by 1.05; for any other age value, the new TOTAL_POINTS remains unchanged.",
    "plsql": "CREATE OR REPLACE TRIGGER adjust_points_by_age\nBEFORE INSERT OR UPDATE ON GYMNAST\nFOR EACH ROW\nDECLARE\n  v_people_age NUMBER;\nBEGIN\n  SELECT AGE INTO v_people_age FROM PEOPLE WHERE PEOPLE_ID = :NEW.GYMNAST_ID;\n  \n  IF v_people_age = 18 THEN\n    :NEW.TOTAL_POINTS := :NEW.TOTAL_POINTS * 1.1;\n  ELSIF v_people_age = 19 THEN\n    :NEW.TOTAL_POINTS := :NEW.TOTAL_POINTS * 1.05;\n  ELSE\n    :NEW.TOTAL_POINTS := :NEW.TOTAL_POINTS;\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) \nVALUES (1, 9.725, 9.737, 9.512, 9.575, 9.762, 9.75, 58.061)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) \nVALUES (2, 9.7, 9.625, 9.625, 9.65, 9.587, 9.737, 57.924)",
      "INSERT INTO GYMNAST (GYMNAST_ID, FLOOR_EXERCISE_POINTS, POMMEL_HORSE_POINTS, RINGS_POINTS, VAULT_POINTS, PARALLEL_BARS_POINTS, HORIZONTAL_BAR_POINTS, TOTAL_POINTS) \nVALUES (4, 8.987, 9.75, 9.75, 9.65, 9.787, 9.725, 57.649)",
      "UPDATE GYMNAST SET TOTAL_POINTS = 58.5 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET TOTAL_POINTS = 57.0 WHERE GYMNAST_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE row-level trigger named adjust_points_by_age on the GYMNAST table. For each row, retrieve the AGE from the PEOPLE table where PEOPLE_ID = :NEW.GYMNAST_ID. If the age is 18, multiply :NEW.TOTAL_POINTS by 1.1. If the age is 19, multiply it by 1.05. Otherwise, leave it unchanged.",
    "natural_language": "Alright, so we need a trigger that fires off before a new gymnast gets added or an existing one gets updated. Call it \"adjust_points_by_age\". Here's the deal: every time a row in the GYMNAST table is touched, you gotta look up that gymnast's age from the PEOPLE table using their ID. If they're 18, bump up their TOTAL_POINTS by 10% (just multiply by 1.1). If they're 19, give 'em a smaller boost, like 5% (multiply by 1.05). For any other age, don't change a thing, just leave the points as they are.",
    "id": 48,
    "generated_ir": "Write an Oracle PL/SQL trigger named adjust_points_by_age that fires before any insert or update operation on the GYMNAST table for each affected row, which declares a local variable v_people_age of type NUMBER, then queries the AGE column from the PEOPLE table by selecting the row where the PEOPLE_ID column matches the new GYMNAST_ID value from the triggering row in the GYMNAST table, storing the result in v_people_age, and subsequently uses a conditional IF-ELSIF-ELSE block to adjust the new TOTAL_POINTS value in the GYMNAST row: if the retrieved age equals 18, the new TOTAL_POINTS is multiplied by 1.1; if the age equals 19, it is multiplied by 1.05; for any other age value, the new TOTAL_POINTS remains unchanged."
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named trg_vehicle_status_check that fires for DELETE operations on the VEHICLES table, which first declares a record type vehicle_rec with fields vehicle_id of type NUMBER, vehicle_details of type VARCHAR2(255), and lesson_count of type NUMBER, then declares a nested table type vehicle_list of that record type, and initializes a global collection variable g_vehicles of that type; the trigger's BEFORE EACH ROW section, for each row being deleted, selects the count of related records from the LESSONS table where the LESSONS.VEHICLE_ID column equals the :OLD.VEHICLE_ID value from the deleted VEHICLES row, stores this count in a local variable v_lesson_count, extends the global collection g_vehicles, and populates the new collection element with the :OLD.VEHICLE_ID, :OLD.VEHICLE_DETAILS, and the calculated v_lesson_count, then conditionally deletes all rows from the LESSONS table where LESSONS.VEHICLE_ID equals :OLD.VEHICLE_ID if the v_lesson_count is zero and the :OLD.VEHICLE_DETAILS is not equal to the string 'Truck'; the trigger's AFTER STATEMENT section then iterates through all elements in the populated g_vehicles collection, and for each element, if the stored lesson_count is greater than zero, it inserts a new row into the VEHICLES table with the stored vehicle_id and the string 'Archived' for the VEHICLE_DETAILS column, else if the stored vehicle_details equals the string 'Truck', it inserts a new row into the VEHICLES table with the stored vehicle_id and the string 'Old Truck' for the VEHICLE_DETAILS column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_vehicle_status_check\nFOR DELETE ON VEHICLES\nCOMPOUND TRIGGER\n\n    TYPE vehicle_rec IS RECORD (\n        vehicle_id NUMBER,\n        vehicle_details VARCHAR2(255),\n        lesson_count NUMBER\n    );\n    \n    TYPE vehicle_list IS TABLE OF vehicle_rec;\n    g_vehicles vehicle_list := vehicle_list();\n    \nBEFORE EACH ROW IS\n    v_lesson_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_lesson_count FROM LESSONS WHERE VEHICLE_ID = :OLD.VEHICLE_ID;\n    \n    g_vehicles.EXTEND;\n    g_vehicles(g_vehicles.LAST).vehicle_id := :OLD.VEHICLE_ID;\n    g_vehicles(g_vehicles.LAST).vehicle_details := :OLD.VEHICLE_DETAILS;\n    g_vehicles(g_vehicles.LAST).lesson_count := v_lesson_count;\n    \n    IF v_lesson_count = 0 AND :OLD.VEHICLE_DETAILS != 'Truck' THEN\n        DELETE FROM LESSONS WHERE VEHICLE_ID = :OLD.VEHICLE_ID;\n    END IF;\nEND BEFORE EACH ROW;\n\nAFTER STATEMENT IS\nBEGIN\n    FOR i IN 1..g_vehicles.COUNT LOOP\n        IF g_vehicles(i).lesson_count > 0 THEN\n            INSERT INTO VEHICLES (VEHICLE_ID, VEHICLE_DETAILS) \n            VALUES (g_vehicles(i).vehicle_id, 'Archived');\n        ELSIF g_vehicles(i).vehicle_details = 'Truck' THEN\n            INSERT INTO VEHICLES (VEHICLE_ID, VEHICLE_DETAILS) \n            VALUES (g_vehicles(i).vehicle_id, 'Old Truck');\n        END IF;\n    END LOOP;\nEND AFTER STATEMENT;\n\nEND trg_vehicle_status_check;",
    "database_name": "driving_school",
    "tables": [
      "ADDRESSES",
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF",
      "VEHICLES"
    ],
    "call_sqls": [
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 1 AND VEHICLE_DETAILS = 'Van'",
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 2 AND VEHICLE_DETAILS = 'Truck'",
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 3 AND VEHICLE_DETAILS = 'Car'",
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 4 AND VEHICLE_DETAILS = 'Motorcycle'",
      "DELETE FROM VEHICLES WHERE VEHICLE_ID = 5 AND VEHICLE_DETAILS = 'Truck'"
    ],
    "summary": "Create a compound trigger named trg_vehicle_status_check for DELETE operations on the VEHICLES table. Declare a record type with vehicle_id, vehicle_details, and lesson_count fields, and a nested table type of that record. Initialize a global collection variable of that type. In the BEFORE EACH ROW section, for each deleted row, count related records in the LESSONS table. Store the count, extend the global collection, and populate it with the old vehicle data and the count. If the count is zero and the old vehicle_details is not 'Truck', delete related records from the LESSONS table. In the AFTER STATEMENT section, iterate through the collection. If lesson_count > 0, insert a new row into VEHICLES with the old vehicle_id and 'Archived' details. If vehicle_details equals 'Truck', insert a new row with the old vehicle_id and 'Old Truck' details.",
    "natural_language": "Set up a trigger for deletions on the VEHICLES table, maybe call it something like trg_vehicle_status_check. You'll need to define a record type with fields for the vehicle ID, its details, and a count of related lessons, and then a nested table based on that. Have a global collection variable ready. Before each row is deleted, check how many lessons are tied to that vehicle and stash the old vehicle info along with that count in the collection. If there aren't any lessons and the vehicle wasn't a Truck, go ahead and clear out any related lesson records. After the whole delete is done, look through the saved data. For entries with some lessons, put a new row back into VEHICLES marking it as 'Archived'. If the original details were for a Truck, add a new row calling it an 'Old Truck'.",
    "id": 49,
    "generated_ir": "Write an Oracle PL/SQL compound trigger named trg_vehicle_status_check that fires for DELETE operations on the VEHICLES table, which first declares a record type vehicle_rec with fields vehicle_id of type NUMBER, vehicle_details of type VARCHAR2(255), and lesson_count of type NUMBER, then declares a nested table type vehicle_list of that record type, and initializes a global collection variable g_vehicles of that type; the trigger's BEFORE EACH ROW section, for each row being deleted, selects the count of related records from the LESSONS table where the LESSONS.VEHICLE_ID column equals the :OLD.VEHICLE_ID value from the deleted VEHICLES row, stores this count in a local variable v_lesson_count, extends the global collection g_vehicles, and populates the new collection element with the :OLD.VEHICLE_ID, :OLD.VEHICLE_DETAILS, and the calculated v_lesson_count, then conditionally deletes all rows from the LESSONS table where LESSONS.VEHICLE_ID equals :OLD.VEHICLE_ID if the v_lesson_count is zero and the :OLD.VEHICLE_DETAILS is not equal to the string 'Truck'; the trigger's AFTER STATEMENT section then iterates through all elements in the populated g_vehicles collection, and for each element, if the stored lesson_count is greater than zero, it inserts a new row into the VEHICLES table with the stored vehicle_id and the string 'Archived' for the VEHICLE_DETAILS column, else if the stored vehicle_details equals the string 'Truck', it inserts a new row into the VEHICLES table with the stored vehicle_id and the string 'Old Truck' for the VEHICLE_DETAILS column."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_update_conference_location` that is activated `AFTER` an `UPDATE` operation on the `LOCATION` column of the `CONFERENCE` table. This trigger is defined to execute `FOR EACH ROW` that is affected by the `UPDATE` statement. Upon activation, for each row where the `LOCATION` column has been updated, the trigger performs a `DELETE` operation on the `CONFERENCE_PARTICIPATION` table. The `DELETE` operation targets rows in the `CONFERENCE_PARTICIPATION` table where the value in its `CONFERENCE_ID` column matches the value of the `CONFERENCE_ID` column from the row in the `CONFERENCE` table *before* the `UPDATE` operation occurred. This is referenced using the `:OLD.CONFERENCE_ID` pseudorecord variable, which provides access to the original values of the columns of the row being updated in the `CONFERENCE` table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_conference_location\nAFTER UPDATE OF LOCATION ON CONFERENCE\nFOR EACH ROW\nBEGIN\n  DELETE FROM CONFERENCE_PARTICIPATION\n  WHERE CONFERENCE_ID = :OLD.CONFERENCE_ID;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE CONFERENCE SET LOCATION = 'New York' WHERE CONFERENCE_ID = 1",
      "UPDATE CONFERENCE SET LOCATION = 'London' WHERE CONFERENCE_ID = 2",
      "UPDATE CONFERENCE SET LOCATION = 'Paris' WHERE CONFERENCE_ID = 3",
      "UPDATE CONFERENCE SET LOCATION = 'Berlin' WHERE CONFERENCE_ID = 1 AND YEAR = 2003",
      "UPDATE CONFERENCE SET LOCATION = 'Tokyo' WHERE CONFERENCE_NAME = 'Naccl'"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_update_conference_location on the CONFERENCE table, firing when the LOCATION column is updated. For each updated row, delete all rows from CONFERENCE_PARTICIPATION where CONFERENCE_ID equals the original (pre-update) CONFERENCE_ID.",
    "natural_language": "Set up a trigger on the conference table that runs after the location gets changed. When that happens, it should clean up any related participation records for those conferences.",
    "id": 50,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_conference_location that is executed after an update operation on the conference table. This trigger operates for each row affected by the update, specifically when the location column is modified. Within the trigger's body, a condition checks if the location value in the newly updated row, denoted by :NEW.location, is different from the location value in the original row before the update, denoted by :OLD.location. If this condition is true, the trigger performs a DELETE operation on the conference_participation table. The deletion targets rows where the conference_id column matches the conference_id value from the newly updated row in the conference table, represented by :NEW.conference_id. This logic ensures that whenever a conference's location is updated, all related participation records for that specific conference are removed from the conference_participation table, effectively cleaning up the participation data associated with the conference."
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_validate_teacher_classroom` on the `TEACHERS` table. This trigger executes before a new row is inserted into the `TEACHERS` table. For each row being inserted, it declares a local numeric variable `v_classroom_count` to store the count of matching classrooms. The trigger then performs a `SELECT COUNT(*)` operation on the `LIST` table to count the number of rows where the `CLASSROOM` column's value is equal to the `CLASSROOM` value of the new row being inserted into the `TEACHERS` table (referenced as `:NEW.CLASSROOM`). The result of this count is stored in the `v_classroom_count` variable. Following this, a conditional `IF` statement checks if the value of `v_classroom_count` is equal to `0`. If `v_classroom_count` is `0`, indicating that the `CLASSROOM` value specified for the new teacher does not exist in the `LIST` table, then the `CLASSROOM` column of the new row being inserted into the `TEACHERS` table (referenced as `:NEW.CLASSROOM`) is set to `NULL`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_validate_teacher_classroom\nBEFORE INSERT ON TEACHERS\nFOR EACH ROW\nDECLARE\n    v_classroom_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_classroom_count FROM LIST WHERE CLASSROOM = :NEW.CLASSROOM;\n    IF v_classroom_count = 0 THEN\n        :NEW.CLASSROOM := NULL;\n    END IF;\nEND;",
    "database_name": "student_1",
    "tables": [
      "LIST",
      "TEACHERS"
    ],
    "call_sqls": [
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Smith', 'John', 101)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Doe', 'Jane', 999)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Brown', 'Robert', 105)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Wilson', 'Emily', NULL)",
      "INSERT INTO TEACHERS (LASTNAME, FIRSTNAME, CLASSROOM) VALUES ('Taylor', 'Michael', 110)"
    ],
    "summary": "Create a BEFORE INSERT row trigger named trg_validate_teacher_classroom on the TEACHERS table. For each row, if the specified CLASSROOM does not exist in the LIST table, set the new CLASSROOM value to NULL.",
    "natural_language": "Please construct a BEFORE INSERT row trigger designated as trg_validate_teacher_classroom for the TEACHERS table. For each inserted row, if the provided CLASSROOM value is not present within the LIST table, the new CLASSROOM value should be assigned as NULL.",
    "id": 51,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_validate_teacher_classroom that is executed before each row is inserted into the TEACHERS table. The trigger checks if the value of the CLASSROOM column in the new row, referred to as :NEW.CLASSROOM, exists in the LIST table. It performs a SELECT COUNT(*) query on the LIST table, counting rows where the CLASSROOM column equals :NEW.CLASSROOM. If the count is zero, meaning the classroom value does not exist in the LIST table, the trigger sets :NEW.CLASSROOM to NULL. If the count is greater than zero, the trigger leaves :NEW.CLASSROOM unchanged. The trigger operates on the student_1 database and involves the TEACHERS and LIST tables, specifically their CLASSROOM columns."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_settlement_amount_check that fires before any row is updated on the SETTLEMENTS table, and for each row being updated, it declares a local variable v_max_claimed of type NUMBER, then executes a SELECT statement to query the CLAIMS and CUSTOMER_POLICIES tables, joining them on the condition that c.POLICY_ID equals cp.POLICY_ID, and filtering the result with a WHERE clause that requires cp.POLICY_ID to match the POLICY_ID obtained from a subquery that selects the POLICY_ID from the CLAIMS table where the CLAIM_ID equals the new CLAIM_ID value from the :NEW pseudorecord of the trigger, storing the maximum value of the c.AMOUNT_CLAIMED column from the result set into the v_max_claimed variable, and then uses an IF conditional statement to check if the new AMOUNT_SETTLED value from the :NEW pseudorecord is less than the retrieved v_max_claimed value, and if this condition is true, it assigns the value of v_max_claimed to the :NEW.AMOUNT_SETTLED column for the row being updated.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_settlement_amount_check\nBEFORE UPDATE ON SETTLEMENTS\nFOR EACH ROW\nDECLARE\n    v_max_claimed NUMBER;\nBEGIN\n    SELECT MAX(c.AMOUNT_CLAIMED)\n      INTO v_max_claimed\n      FROM CLAIMS c\n      JOIN CUSTOMER_POLICIES cp ON c.POLICY_ID = cp.POLICY_ID\n     WHERE cp.POLICY_ID = (SELECT POLICY_ID FROM CLAIMS WHERE CLAIM_ID = :NEW.CLAIM_ID);\n    \n    IF :NEW.AMOUNT_SETTLED < v_max_claimed THEN\n        :NEW.AMOUNT_SETTLED := v_max_claimed;\n    END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 5000 WHERE SETTLEMENT_ID = 357",
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 10000, DATE_CLAIM_SETTLED = '2023-12-01' WHERE CLAIM_ID = 486",
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 7500 WHERE SETTLEMENT_ID = 412",
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 2000, AMOUNT_CLAIMED = 25000 WHERE SETTLEMENT_ID = 476",
      "UPDATE SETTLEMENTS SET AMOUNT_SETTLED = 15000 WHERE CLAIM_ID = 621"
    ],
    "summary": "Create a BEFORE UPDATE row trigger named trg_settlement_amount_check on the SETTLEMENTS table. For each row, if the new AMOUNT_SETTLED is less than the maximum AMOUNT_CLAIMED for the claim's policy (from CLAIMS and CUSTOMER_POLICIES), set the new AMOUNT_SETTLED to that maximum value.",
    "natural_language": "Before updating a row in the SETTLEMENTS table, check the amount. For each row, if the new AMOUNT_SETTLED is less than the maximum AMOUNT_CLAIMED for the claim's policy, set the new AMOUNT_SETTLED to that maximum value. Name this row trigger trg_settlement_amount_check.",
    "id": 52,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_settlement_amount_check that is activated BEFORE an UPDATE operation occurs on the SETTLEMENTS table. This trigger is a FOR EACH ROW trigger, meaning it executes once for every row being updated in the SETTLEMENTS table. Upon activation, the trigger declares a local variable, v_max_claimed, of type NUMBER to store a calculated value. The trigger then performs a SELECT operation to query the database. This SELECT statement retrieves the maximum value from the AMOUNT_CLAIMED column in the CLAIMS table. The query uses a WHERE clause to filter rows, joining the CLAIMS table to the CUSTOMER_POLICIES table. The join condition is CLAIMS.POLICY_ID = CUSTOMER_POLICIES.POLICY_ID. A further filter is applied where CUSTOMER_POLICIES.POLICY_ID must equal the POLICY_ID associated with the claim being updated. To find this associated POLICY_ID, the trigger performs a subquery: it selects the POLICY_ID from the CLAIMS table where the CLAIM_ID matches the CLAIM_ID of the row currently being updated in the SETTLEMENTS table, referenced as :NEW.CLAIM_ID. The result of this SELECT MAX(AMOUNT_CLAIMED) operation is stored into the local variable v_max_claimed. Following this data retrieval, the trigger evaluates a conditional statement: IF :NEW.AMOUNT_SETTLED < v_max_claimed THEN. This condition checks if the new value intended for the AMOUNT_SETTLED column in the row being updated is less than the calculated maximum claimed amount for the associated policy. If this condition is true, the trigger performs an assignment operation: :NEW.AMOUNT_SETTLED := v_max_claimed;. This operation modifies the value of the AMOUNT_SETTLED column for the current row being updated, setting it to the value stored in v_max_claimed before the row is actually committed to the SETTLEMENTS table. If the initial IF condition is not met (i.e., :NEW.AMOUNT_SETTLED is greater than or equal to v_max_claimed), then no action is taken by the trigger for that specific row, and the AMOUNT_SETTLED column retains its original intended value from the UPDATE statement. The trigger concludes its execution for the current row after evaluating the IF statement."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_order_items_bi that executes automatically before any row is inserted into the ORDER_ITEMS table, and for each new row, it declares a local variable v_type of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT query on the PRODUCTS table to retrieve the PRODUCT_TYPE_CODE column value for the row where the PRODUCT_ID column matches the new incoming PRODUCT_ID value (referenced as :NEW.PRODUCT_ID) and stores that value into the v_type variable, and subsequently checks a conditional IF statement to see if the retrieved v_type value is exactly equal to the string literal 'Clothes', and if this condition is true, it modifies the new ORDER_ID value (referenced as :NEW.ORDER_ID) by adding 1000 to its original value before the row is finally inserted into the ORDER_ITEMS table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_order_items_bi\nBEFORE INSERT ON ORDER_ITEMS\nFOR EACH ROW\nDECLARE\n    v_type VARCHAR2(255);\nBEGIN\n    SELECT PRODUCT_TYPE_CODE INTO v_type FROM PRODUCTS WHERE PRODUCT_ID = :NEW.PRODUCT_ID;\n    IF v_type = 'Clothes' THEN\n        :NEW.ORDER_ID := :NEW.ORDER_ID + 1000;\n    END IF;\nEND;",
    "database_name": "department_store",
    "tables": [
      "ORDER_ITEMS",
      "PRODUCTS"
    ],
    "call_sqls": [
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (1, 100, 1)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (2, 200, 2)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (3, 300, 3)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (4, 400, 1)",
      "INSERT INTO ORDER_ITEMS (ORDER_ITEM_ID, ORDER_ID, PRODUCT_ID) VALUES (5, 500, 2)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_order_items_bi on the ORDER_ITEMS table. For each new row, retrieve the product type from the PRODUCTS table. If the type is 'Clothes', add 1000 to the new ORDER_ID value (:NEW.ORDER_ID) before insertion.",
    "natural_language": "Construct a BEFORE INSERT row-level trigger, which should be named trg_order_items_bi, specifically for the ORDER_ITEMS table. For every single new row that is about to be inserted, you must carefully retrieve the corresponding product type from the detailed PRODUCTS table. In the specific scenario where the retrieved type is precisely identified as 'Clothes', it is essential to programmatically add a value of 1000 to the new ORDER_ID value, referenced as :NEW.ORDER_ID, ensuring this modification occurs seamlessly just prior to the final insertion of the row.",
    "id": 53,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_order_items_bi that executes automatically before any row is inserted into the ORDER_ITEMS table, and for each new row, it declares a local variable v_type of type VARCHAR2 with a maximum length of 255 characters, then performs a SELECT query on the PRODUCTS table to retrieve the PRODUCT_TYPE_CODE column value for the row where the PRODUCT_ID column matches the new incoming PRODUCT_ID value (referenced as :NEW.PRODUCT_ID) and stores that value into the v_type variable, and subsequently checks a conditional IF statement to see if the retrieved v_type value is exactly equal to the string literal 'Clothes', and if this condition is true, it modifies the new ORDER_ID value (referenced as :NEW.ORDER_ID) by adding 1000 to its original value before the row is finally inserted into the ORDER_ITEMS table."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_MEMBER_AGE_ARCHIVE` that is activated `BEFORE` any `DELETE` operation is performed on the `MEMBER` table. This trigger is defined to execute `FOR EACH ROW` that is being deleted. Within the trigger's execution block, a local variable `v_max_ranking` of data type `NUMBER` is declared. The first operation performed is a `SELECT` statement that retrieves the maximum value from the `OVERALL_RANKING` column of the `CLUB` table and stores this value into the `v_max_ranking` variable. Following this, an `INSERT` operation is executed on the `CLUB_LEADER` table. This `INSERT` statement populates three columns: `CLUB_ID`, `MEMBER_ID`, and `YEAR_JOIN`. The `CLUB_ID` column is assigned a literal integer value of `1`. The `MEMBER_ID` column is assigned the value of the `MEMBER_ID` column from the row currently being deleted from the `MEMBER` table, referenced by `:OLD.MEMBER_ID`. The `YEAR_JOIN` column is assigned a substring of the `NAME` column from the row currently being deleted from the `MEMBER` table, referenced by `:OLD.NAME`. Specifically, the `SUBSTR` function extracts the first four characters (from position 1 for a length of 4) of the `:OLD.NAME` value.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MEMBER_AGE_ARCHIVE\nBEFORE DELETE ON MEMBER\nFOR EACH ROW\nDECLARE\n    v_max_ranking NUMBER;\nBEGIN\n    SELECT MAX(OVERALL_RANKING) INTO v_max_ranking FROM CLUB;\n    INSERT INTO CLUB_LEADER (CLUB_ID, MEMBER_ID, YEAR_JOIN) VALUES (1, :OLD.MEMBER_ID, SUBSTR(:OLD.NAME, 1, 4));\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1984",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1985",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1986",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1988",
      "DELETE FROM MEMBER WHERE MEMBER_ID = 1989"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named TRG_MEMBER_AGE_ARCHIVE on the MEMBER table. For each deleted row, find the maximum overall ranking from the CLUB table. Insert a row into CLUB_LEADER with CLUB_ID as 1, the deleted MEMBER_ID, and the first four characters of the deleted NAME as YEAR_JOIN.",
    "natural_language": "Create trigger TRG_MEMBER_AGE_ARCHIVE on MEMBER before delete. For each row, get max ranking from CLUB. Insert into CLUB_LEADER: CLUB_ID=1, deleted MEMBER_ID, first four chars of deleted NAME as YEAR_JOIN.",
    "id": 54,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_MEMBER_AGE_ARCHIVE` that is activated `BEFORE` any `DELETE` operation is performed on the `MEMBER` table. This trigger is defined to execute `FOR EACH ROW` that is being deleted. Within the trigger's execution block, a local variable `v_max_ranking` of data type `NUMBER` is declared. The first operation performed is a `SELECT` statement that retrieves the maximum value from the `OVERALL_RANKING` column of the `CLUB` table and stores this value into the `v_max_ranking` variable. Following this, an `INSERT` operation is executed on the `CLUB_LEADER` table. This `INSERT` statement populates three columns: `CLUB_ID`, `MEMBER_ID`, and `YEAR_JOIN`. The `CLUB_ID` column is assigned a literal integer value of `1`. The `MEMBER_ID` column is assigned the value of the `MEMBER_ID` column from the row currently being deleted from the `MEMBER` table, referenced by `:OLD.MEMBER_ID`. The `YEAR_JOIN` column is assigned a substring of the `NAME` column from the row currently being deleted from the `MEMBER` table, referenced by `:OLD.NAME`. Specifically, the `SUBSTR` function extracts the first four characters (from position 1 for a length of 4) of the `:OLD.NAME` value."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_country_validate that is executed before an insert or update operation on the COUNTRY table. This trigger operates for each row affected by the insert or update. It declares a local variable v_dummy of type NUMBER, which is used to temporarily store a value during the execution of a SELECT statement. The trigger performs a SELECT operation on the DUAL table, which is a special one-row, one-column table used for selecting a constant value. The SELECT statement checks if the new values being inserted or updated in the COUNTRY table have a POPULATION greater than 0 and an AREA greater than 0. If both conditions are true, the SELECT statement assigns the value 1 to the v_dummy variable. If either condition is false, the SELECT statement does not return any data, causing a NO_DATA_FOUND exception to be raised. The trigger handles this exception by invoking the RAISE_APPLICATION_ERROR procedure, which generates a custom error with the error code -20001 and the message 'Population and area must be positive'. This error prevents the insert or update operation from proceeding if the conditions are not met, ensuring that only rows with positive values for POPULATION and AREA are allowed in the COUNTRY table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_country_validate\nBEFORE INSERT OR UPDATE ON COUNTRY\nFOR EACH ROW\nDECLARE\n  v_dummy NUMBER;\nBEGIN\n  SELECT 1 INTO v_dummy FROM DUAL WHERE :NEW.POPULATION > 0 AND :NEW.AREA > 0;\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    RAISE_APPLICATION_ERROR(-20001, 'Population and area must be positive');\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (4, 'France', 65273511, 551695, 'French')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (5, 'Germany', 83019200, 357022, 'German')",
      "UPDATE COUNTRY SET POPULATION = 10000000, AREA = 100000 WHERE COUNTRY_ID = 1",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (6, 'Spain', 0, 505990, 'Spanish')",
      "UPDATE COUNTRY SET POPULATION = 50000000, AREA = 0 WHERE COUNTRY_ID = 2"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_country_validate on the COUNTRY table. Validate that the new POPULATION and AREA values are both greater than 0. If not, raise an application error with code -20001 and message 'Population and area must be positive'.",
    "natural_language": "Construct a BEFORE INSERT OR UPDATE FOR EACH ROW trigger, which should be named trg_country_validate, specifically for the COUNTRY table. This trigger must thoroughly validate that the newly provided POPULATION and AREA values are each distinctly greater than 0. Should either of these crucial values fail to meet this essential positive requirement, the trigger must promptly raise a detailed application error, utilizing the specific error code -20001 along with the clear and instructive message: 'Population and area must be positive'.",
    "id": 55,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_country_validate that is executed before an insert or update operation on the COUNTRY table. This trigger operates for each row affected by the insert or update. It declares a local variable v_dummy of type NUMBER, which is used to temporarily store a value during the execution of a SELECT statement. The trigger performs a SELECT operation on the DUAL table, which is a special one-row, one-column table used for selecting a constant value. The SELECT statement checks if the new values being inserted or updated in the COUNTRY table have a POPULATION greater than 0 and an AREA greater than 0. If both conditions are true, the SELECT statement assigns the value 1 to the v_dummy variable. If either condition is false, the SELECT statement does not return any data, causing a NO_DATA_FOUND exception to be raised. The trigger handles this exception by invoking the RAISE_APPLICATION_ERROR procedure, which generates a custom error with the error code -20001 and the message 'Population and area must be positive'. This error prevents the insert or update operation from proceeding if the conditions are not met, ensuring that only rows with positive values for POPULATION and AREA are allowed in the COUNTRY table."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_CLUB_LEADER_INSERT` that is activated `AFTER` a `DELETE` operation occurs on the `CLUB_LEADER` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is deleted from the `CLUB_LEADER` table. Upon activation, the trigger declares a local numeric variable named `v_min_age`. The trigger then performs a `SELECT` operation to retrieve the minimum value from the `AGE` column of the `MEMBER` table. This retrieved minimum age value is then stored into the `v_min_age` variable. Following this, the trigger executes an `INSERT` operation into the `MEMBER` table. For this `INSERT` operation, the `MEMBER_ID` column is populated with the value of the `MEMBER_ID` column from the row that was just deleted from the `CLUB_LEADER` table (referenced as `:OLD.MEMBER_ID`), to which the numeric value `2000` is added. The `NAME` column is populated with the literal string `'New Leader'`. The `AGE` column is populated with the value currently stored in the `v_min_age` variable, which represents the minimum age found in the `MEMBER` table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CLUB_LEADER_INSERT\nAFTER DELETE ON CLUB_LEADER\nFOR EACH ROW\nDECLARE\n    v_min_age NUMBER;\nBEGIN\n    SELECT MIN(AGE) INTO v_min_age FROM MEMBER;\n    INSERT INTO MEMBER (MEMBER_ID, NAME, AGE) VALUES (:OLD.MEMBER_ID + 2000, 'New Leader', v_min_age);\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 1 AND MEMBER_ID = 1988",
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 8 AND MEMBER_ID = 1984",
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 6 AND MEMBER_ID = 1985",
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 3 AND MEMBER_ID = 1990",
      "DELETE FROM CLUB_LEADER WHERE CLUB_ID = 4 AND MEMBER_ID = 1992"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named TRG_CLUB_LEADER_INSERT on the CLUB_LEADER table. For each deleted row, find the minimum age from the MEMBER table. Insert a new row into MEMBER using the deleted MEMBER_ID plus 2000, the name 'New Leader', and the minimum age.",
    "natural_language": "How can I create an AFTER DELETE row-level trigger called TRG_CLUB_LEADER_INSERT on the CLUB_LEADER table that, for each deleted row, finds the minimum age from the MEMBER table and inserts a new row into MEMBER with the deleted MEMBER_ID increased by 2000, the name 'New Leader', and that minimum age?",
    "id": 56,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_CLUB_LEADER_INSERT` that is activated `AFTER` a `DELETE` operation occurs on the `CLUB_LEADER` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is deleted from the `CLUB_LEADER` table. Upon activation, the trigger declares a local numeric variable named `v_min_age`. The trigger then performs a `SELECT` operation to retrieve the minimum value from the `AGE` column of the `MEMBER` table. This retrieved minimum age value is then stored into the `v_min_age` variable. Following this, the trigger executes an `INSERT` operation into the `MEMBER` table. For this `INSERT` operation, the `MEMBER_ID` column is populated with the value of the `MEMBER_ID` column from the row that was just deleted from the `CLUB_LEADER` table (referenced as `:OLD.MEMBER_ID`), to which the numeric value `2000` is added. The `NAME` column is populated with the literal string `'New Leader'`. The `AGE` column is populated with the value currently stored in the `v_min_age` variable, which represents the minimum age found in the `MEMBER` table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_MANAGEMENT_DEPT_EXISTS that fires automatically before any row insertion operation is performed on the MANAGEMENT table, for each individual row being inserted. The trigger declares a local variable v_dept_count of type NUMBER. For each new row, the trigger executes a SELECT statement that queries the DEPARTMENT table, counting the number of rows where the DEPARTMENT_ID column value equals the value of the DEPARTMENT_ID column from the new row (referenced as :NEW.DEPARTMENT_ID), and stores this count result into the variable v_dept_count. Immediately after this query, the trigger evaluates a conditional IF statement that checks if the value of v_dept_count is exactly equal to 0. If this condition is true, indicating that no corresponding department record exists in the DEPARTMENT table for the provided DEPARTMENT_ID, the trigger raises a custom application error with error number -20004 and the message 'Department does not exist.', which halts the insertion into the MANAGEMENT table. If the condition is false, meaning v_dept_count is greater than 0 and a matching department exists, the trigger completes without error, allowing the INSERT operation on the MANAGEMENT table to proceed.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MANAGEMENT_DEPT_EXISTS\nBEFORE INSERT ON MANAGEMENT\nFOR EACH ROW\nDECLARE\n    v_dept_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_dept_count FROM DEPARTMENT WHERE DEPARTMENT_ID = :NEW.DEPARTMENT_ID;\n    IF v_dept_count = 0 THEN\n        RAISE_APPLICATION_ERROR(-20004, 'Department does not exist.');\n    END IF;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (1, 5, 'No')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID) VALUES (2, 4)",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (3, 6, 'Yes')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID) VALUES (99, 1)",
      "INSERT INTO MANAGEMENT VALUES (15, 3, 'No')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_MANAGEMENT_DEPT_EXISTS on the MANAGEMENT table. Count rows in the DEPARTMENT table where DEPARTMENT_ID = :NEW.DEPARTMENT_ID. If the count is 0, raise application error -20004 with message 'Department does not exist.'.",
    "natural_language": "How can I create a BEFORE INSERT row-level trigger called TRG_MANAGEMENT_DEPT_EXISTS for the MANAGEMENT table that checks if the department exists? The trigger should count the rows in the DEPARTMENT table where the DEPARTMENT_ID matches the new DEPARTMENT_ID, and if the count is zero, raise application error -20004 with the message 'Department does not exist.'",
    "id": 57,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_MANAGEMENT_DEPT_EXISTS that is defined to execute automatically before any row is inserted into the MANAGEMENT table, and for each individual row that is inserted, the trigger performs a validation to ensure the referenced department exists in the DEPARTMENT table. The trigger declares a local variable v_dept_count of type NUMBER to store the count of matching departments. The trigger then executes a SELECT COUNT(*) operation on the DEPARTMENT table, counting all rows where the DEPARTMENT_ID column equals the new DEPARTMENT_ID value from the inserted row in the MANAGEMENT table, which is referenced as :NEW.DEPARTMENT_ID. The result of this count is stored in the variable v_dept_count. Following this, a conditional statement checks if v_dept_count is equal to zero. If this condition is true, the trigger raises an application error with error code -20004 and the error message 'Department does not exist.' This prevents the insertion of the row into the MANAGEMENT table. If v_dept_count is not zero, the trigger does nothing, allowing the insert operation to proceed normally."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_thing_service_sync that is defined to fire automatically after each row is updated on the THINGS table, and within its body, it executes a DELETE operation on the TIMED_LOCATIONS_OF_THINGS table where the condition requires that the THING_ID column value in the TIMED_LOCATIONS_OF_THINGS table matches the new THING_ID value from the updated row in the THINGS table, which is referenced as :NEW.THING_ID, and simultaneously requires that the LOCATION_CODE column value in the TIMED_LOCATIONS_OF_THINGS table begins with the string 'Temp' as enforced by the LIKE 'Temp%' operator.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_thing_service_sync\nAFTER UPDATE ON THINGS\nFOR EACH ROW\nBEGIN\n   -- The original INSERT statement relied on a sequence 'CUSTOMER_EVENT_NOTES_SEQ'\n   -- which is not defined in the provided schema.\n   -- Without a defined sequence or an alternative method to generate CUSTOMER_EVENT_NOTE_ID,\n   -- this insert will cause a compilation error.\n   -- For the purpose of fixing the ORA-04098, this statement is removed.\n   -- If a sequence is intended, it must be created first.\n   -- INSERT INTO CUSTOMER_EVENT_NOTES (CUSTOMER_EVENT_NOTE_ID, SERVICE_TYPE_CODE, DATE_MOVED_IN)\n   -- VALUES (CUSTOMER_EVENT_NOTES_SEQ.NEXTVAL, :NEW.SERVICE_TYPE_CODE, TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));\n\n   -- The v_service_json variable and its assignment were not used, so they are removed.\n\n   DELETE FROM TIMED_LOCATIONS_OF_THINGS WHERE THING_ID = :NEW.THING_ID AND LOCATION_CODE LIKE 'Temp%';\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_EVENTS",
      "CUSTOMER_EVENT_NOTES",
      "RESIDENTS",
      "THINGS",
      "TIMED_LOCATIONS_OF_THINGS"
    ],
    "call_sqls": [
      "UPDATE THINGS SET SERVICE_TYPE_CODE = 'Check' WHERE THING_ID = 1",
      "UPDATE THINGS SET SERVICE_DETAILS = 'Satisfied' WHERE THING_ID = 2",
      "UPDATE THINGS SET ORGANIZATION_ID = 9 WHERE THING_ID = 10",
      "UPDATE THINGS SET TYPE_OF_THING_CODE = 'Furniture' WHERE THING_ID = 14",
      "UPDATE THINGS SET SERVICE_TYPE_CODE = 'Cleanning' WHERE THING_ID = 80"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_thing_service_sync on the THINGS table. The trigger should delete records from the TIMED_LOCATIONS_OF_THINGS table where the THING_ID matches the updated thing and the LOCATION_CODE starts with 'Temp'.",
    "natural_language": "Set up a trigger on the THINGS table that runs after updates, named something like trg_thing_service_sync. It should generally clean up some old or temporary location records in the TIMED_LOCATIONS_OF_THINGS table for the updated item, specifically where the location code seems to be temporary or starts with something like 'Temp'.",
    "id": 58,
    "generated_ir": "Write an Oracle PL/SQL trigger named `trg_thing_service_sync` that is configured to execute automatically after any row in the `THINGS` table is updated, and for each individual row that is updated, it executes a single `DELETE` operation on the `TIMED_LOCATIONS_OF_THINGS` table. The trigger will delete rows from `TIMED_LOCATIONS_OF_THINGS` where the `THING_ID` column value matches the updated `THING_ID` value from the triggering row in the `THINGS` table, which is accessed via the `:NEW.THING_ID` bind variable. Additionally, the deletion is conditional: it only deletes rows where the `LOCATION_CODE` column in `TIMED_LOCATIONS_OF_THINGS` appears to be temporary. This condition is implemented by checking if the `LOCATION_CODE` starts with the string 'Temp' using the `LIKE` operator with the pattern 'Temp%'. The purpose is to clean up old or temporary location records associated with the specific thing that was just updated in the `THINGS` table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CUSTOMER_POLICY_CHECK that is executed before an insert operation on the CUSTOMER_POLICIES table for each row being inserted. The trigger declares a local variable v_customer_count of type NUMBER to store the count of customers. It performs a SELECT statement to count the number of rows in the CUSTOMERS table where the CUSTOMER_ID column matches the CUSTOMER_ID of the new row being inserted into the CUSTOMER_POLICIES table, using the :NEW.CUSTOMER_ID syntax to reference the new row's CUSTOMER_ID. The result of this count is stored in the v_customer_count variable. The trigger then evaluates a conditional statement: if v_customer_count is equal to 0, indicating that there are no existing customers with the given CUSTOMER_ID, it executes an INSERT statement to add a new row into the CUSTOMERS table with the CUSTOMER_ID set to the new row's CUSTOMER_ID and the CUSTOMER_DETAILS column set to the string 'New Customer'.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CUSTOMER_POLICY_CHECK\nBEFORE INSERT ON CUSTOMER_POLICIES\nFOR EACH ROW\nDECLARE\n    v_customer_count NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_customer_count FROM CUSTOMERS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    IF v_customer_count = 0 THEN\n        INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_DETAILS) VALUES (:NEW.CUSTOMER_ID, 'New Customer');\n    END IF;\nEND;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (100, 1, 'Car', '2023-01-01', '2024-01-01')",
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (101, 2, 'Life', '2023-02-01', '2025-02-01')",
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (102, 999, 'Home', '2023-03-01', '2026-03-01')",
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (103, 1000, 'Travel', '2023-04-01', '2023-05-01')",
      "INSERT INTO CUSTOMER_POLICIES (POLICY_ID, CUSTOMER_ID, POLICY_TYPE_CODE, START_DATE, END_DATE) VALUES (104, 3, 'Car', '2023-05-01', '2024-05-01')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_CUSTOMER_POLICY_CHECK on the CUSTOMER_POLICIES table. Declare a local variable v_customer_count. Count rows in the CUSTOMERS table where CUSTOMER_ID equals :NEW.CUSTOMER_ID and store the result in v_customer_count. If v_customer_count is 0, insert a new row into the CUSTOMERS table with CUSTOMER_ID set to :NEW.CUSTOMER_ID and CUSTOMER_DETAILS set to 'New Customer'.",
    "natural_language": "Create BEFORE INSERT trigger TRG_CUSTOMER_POLICY_CHECK on CUSTOMER_POLICIES. Count matching CUSTOMER_ID in CUSTOMERS. If zero, insert new customer.",
    "id": 59,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_CUSTOMER_POLICY_CHECK that is defined to execute automatically before any row insertion operation on the CUSTOMER_POLICIES table, and for each individual row being inserted, it performs a validation and conditional insertion. The trigger first declares a variable, typically named v_customer_count, of type NUMBER to store the result of a count query. It then executes a SELECT statement with the COUNT aggregate function on the CUSTOMERS table, specifically counting rows where the CUSTOMER_ID column in the CUSTOMERS table exactly matches the CUSTOMER_ID value from the new row being inserted into CUSTOMER_POLICIES, which is referenced using the :NEW.CUSTOMER_ID bind variable. The result of this count is stored into the v_customer_count variable. Following this, the trigger evaluates a condition using an IF statement: it checks if v_customer_count equals zero. If this condition is true, meaning no existing customer with that ID is found, the trigger performs an INSERT operation into the CUSTOMERS table. This INSERT statement specifies values for the CUSTOMERS table columns: it sets the CUSTOMER_ID column to the value from :NEW.CUSTOMER_ID, and for the CUSTOMER_DETAILS column, it inserts a default or placeholder value, which, based on common practice for such triggers, would typically be a NULL value or a string like 'New Customer' to indicate an automatically created record, as the natural language description does not specify a source for customer details. If the condition is false (v_customer_count is greater than zero), the trigger takes no additional action, allowing the original INSERT into CUSTOMER_POLICIES to proceed normally. The trigger does not return a value but modifies database state conditionally by potentially inserting a row into the CUSTOMERS table."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `TRG_NATIONALITY_CLEANUP` that is configured to execute automatically after an `UPDATE` operation is performed on any row within the `MEMBER` table. This trigger does not accept any explicit parameters. Upon activation, the trigger first declares two local PL/SQL variables: `v_total_clubs` of data type `NUMBER` and `v_avg_age` of data type `NUMBER`. The trigger then proceeds to execute a `SELECT` statement to count all rows in the `CLUB` table, storing the resulting total number of clubs into the `v_total_clubs` variable. Subsequently, another `SELECT` statement is executed to calculate the average value of the `AGE` column from all rows in the `MEMBER` table where the `NATIONALITY` column is exactly equal to the string literal 'Australia'. This calculated average age is then stored into the `v_avg_age` variable. Finally, the trigger performs a `DELETE` operation on the `CLUB` table, removing all rows where the value in the `OVERALL_RANKING` column is strictly greater than the value stored in the `v_avg_age` variable AND the value in the `CLUB_ID` column is strictly greater than the value stored in the `v_total_clubs` variable.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_NATIONALITY_CLEANUP\nAFTER UPDATE ON MEMBER\nDECLARE\n    v_total_clubs NUMBER;\n    v_avg_age NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_clubs FROM CLUB;\n    SELECT AVG(AGE) INTO v_avg_age FROM MEMBER WHERE NATIONALITY = 'Australia';\n    DELETE FROM CLUB WHERE OVERALL_RANKING > v_avg_age AND CLUB_ID > v_total_clubs;\nEND;",
    "database_name": "club_leader",
    "tables": [
      "CLUB",
      "CLUB_LEADER",
      "MEMBER"
    ],
    "call_sqls": [
      "UPDATE MEMBER SET AGE = 25 WHERE MEMBER_ID = 1984",
      "UPDATE MEMBER SET NATIONALITY = 'Australia' WHERE MEMBER_ID = 1985",
      "UPDATE MEMBER SET AGE = 30, NATIONALITY = 'Australia' WHERE MEMBER_ID = 1986",
      "UPDATE MEMBER SET AGE = AGE + 1 WHERE NATIONALITY = 'Australia'",
      "UPDATE MEMBER SET NAME = 'Updated Name' WHERE MEMBER_ID = 1984"
    ],
    "summary": "Create an AFTER UPDATE statement-level trigger named TRG_NATIONALITY_CLEANUP on the MEMBER table. Count the total clubs and calculate the average age of Australian members. Delete clubs where the OVERALL_RANKING is greater than the average age and the CLUB_ID is greater than the total club count.",
    "natural_language": "After updating the MEMBER table, what is the total number of clubs and the average age of Australian members? Then, which clubs should be deleted if their OVERALL_RANKING exceeds that average age and their CLUB_ID is greater than the total club count?",
    "id": 60,
    "generated_ir": "Write an Oracle PL/SQL database trigger named TRG_NATIONALITY_CLEANUP that is designed to execute automatically after an UPDATE operation on the MEMBER table for each row that is updated. The trigger is specifically activated only when the NATIONALITY column of the updated row is changed from a value that is not 'Australia' to 'Australia', or when the NATIONALITY column is changed from 'Australia' to a different value. The trigger performs a series of calculations and conditional operations to determine whether certain clubs should be deleted based on the updated member data.\n\nFirst, the trigger declares several local variables: v_total_clubs of type NUMBER to store the total count of distinct clubs, v_avg_age_australian of type NUMBER to store the average age of members whose nationality is 'Australia', and v_club_id_to_delete of type NUMBER to store the CLUB_ID of a club that meets the deletion criteria. It also declares a cursor named c_clubs_to_delete that is used to iterate through clubs that satisfy specific conditions.\n\nThe trigger begins by calculating the total number of distinct clubs. It performs a SELECT COUNT(DISTINCT CLUB_ID) query on the CLUB_LEADER table and stores the result into the variable v_total_clubs.\n\nNext, the trigger calculates the average age of members who have 'Australia' as their nationality. It performs a SELECT AVG(AGE) query on the MEMBER table where the NATIONALITY column equals 'Australia', and stores the result into the variable v_avg_age_australian. The NVL function is applied to handle cases where no Australian members exist, defaulting the average to 0.\n\nThe trigger then opens a cursor named c_clubs_to_delete. This cursor is defined by a SELECT statement that retrieves the CLUB_ID from the CLUB table where two conditions are met: the OVERALL_RANKING of the club is greater than the calculated average age of Australian members (v_avg_age_australian), and the CLUB_ID is greater than the total count of clubs (v_total_clubs). The cursor orders the results by CLUB_ID in ascending order.\n\nThe trigger enters a loop to process each club identified by the cursor. For each iteration, it fetches the CLUB_ID from the cursor into the variable v_club_id_to_delete. If no more rows are found, the loop exits.\n\nInside the loop, for each fetched CLUB_ID, the trigger performs a DELETE operation on the CLUB_LEADER table where the CLUB_ID matches v_club_id_to_delete. This removes all member associations with that club. Subsequently, the trigger performs another DELETE operation on the CLUB table where the CLUB_ID matches v_club_id_to_delete, thereby deleting the club record itself.\n\nAfter the loop completes, the trigger closes the cursor. The trigger does not return any value but performs the deletions as a side effect of the UPDATE operation on the MEMBER table, specifically when changes to the NATIONALITY column affect the composition of Australian members."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named photos_after_update_cleanup that is executed automatically after any update operation on the photos table. This trigger performs a delete operation on the same photos table, specifically removing any rows where the length of the value in the NAME column is less than 3 characters. The trigger does not take any parameters, and its sole purpose is to enforce a data integrity rule by ensuring that all entries in the photos table have a NAME column value with a minimum length of 3 characters. The LENGTH function is used to determine the number of characters in the NAME column for each row, and any row that does not meet the specified length condition is deleted from the table.",
    "plsql": "CREATE OR REPLACE TRIGGER photos_after_update_cleanup\nAFTER UPDATE ON photos\nBEGIN\n   DELETE FROM photos WHERE LENGTH(NAME) < 3;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "PHOTOS"
    ],
    "call_sqls": [
      "UPDATE photos SET name = 'ab' WHERE id = 1",
      "UPDATE photos SET color = 'RGB' WHERE mountain_id = 20",
      "UPDATE photos SET camera_lens_id = 5 WHERE name = 'grass'",
      "UPDATE photos SET name = 'x' WHERE id = 2",
      "UPDATE photos SET color = 'CMYK', name = 'y' WHERE id = 4"
    ],
    "summary": "Create an AFTER UPDATE statement-level trigger named PHOTOS_AFTER_UPDATE_CLEANUP on the PHOTOS table. After an update, delete any rows from PHOTOS where the LENGTH of the NAME column is less than 3.",
    "natural_language": "Alright, so we need a trigger that fires off after someone updates the PHOTOS table. Let's call it PHOTOS_AFTER_UPDATE_CLEANUP. Basically, right after any update happens, it should clean house by getting rid of any photo entries where the name's too shortlike, if the NAME is less than 3 characters long, just zap that row.",
    "id": 61,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `PHOTOS_AFTER_UPDATE_CLEANUP` that is activated `AFTER` any `UPDATE` operation occurs on the `PHOTOS` table. This trigger is defined to execute `FOR EACH ROW` that has been updated. Upon activation, the trigger performs a `DELETE` operation on the `PHOTOS` table. The `DELETE` operation targets the row where the `ID` column value matches the `ID` column value from the `NEW` pseudorecord of the updated row, but only if the length of the `NAME` column value from the `NEW` pseudorecord is less than `3` characters. The length of the `NAME` is determined using the `LENGTH` function. The condition is evaluated using an `IF` statement. If the condition is true, the `DELETE` operation is executed. If the condition is false, no action is taken. The trigger does not perform any other SQL operations, calculations, or transformations."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_tax_validation that fires before each row is inserted into the COUNCIL_TAX table, declaring local variables v_master_id of type NUMBER, v_source_code of type VARCHAR2 with a length of 255, and v_month_check of type NUMBER. The trigger begins by selecting the MASTER_CUSTOMER_ID and SOURCE_SYSTEM_CODE columns from the CMI_CROSS_REFERENCES table into the variables v_master_id and v_source_code, using a condition where the CMI_CROSS_REF_ID column in CMI_CROSS_REFERENCES matches the new value of the CMI_CROSS_REF_ID column being inserted into COUNCIL_TAX, represented by the bind variable :NEW.CMI_CROSS_REF_ID. It then calculates the variable v_month_check by calling the MONTHS_BETWEEN function with two arguments: the first argument is a date constructed by converting the string '2024-12-31' to a DATE type using the TO_DATE function with the format model 'YYYY-MM-DD', and the second argument is the current system date returned by the SYSDATE function. Following this, the trigger executes a conditional IF statement: if the value of v_source_code is exactly equal to the string 'Rent' and the calculated v_month_check is greater than 6, it performs an INSERT operation into the CMI_CROSS_REFERENCES table, specifying values for the columns CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, and SOURCE_SYSTEM_CODE, where the CMI_CROSS_REF_ID value is the new :NEW.CMI_CROSS_REF_ID value plus 5000, the MASTER_CUSTOMER_ID is the selected v_master_id, and the SOURCE_SYSTEM_CODE is the string 'Tax_Linked'. If the first condition is not met, the trigger checks an ELSIF condition where v_source_code is exactly equal to the string 'Parking', and if true, it executes a DELETE operation on the CUSTOMER_MASTER_INDEX table, removing any row where the MASTER_CUSTOMER_ID column equals the selected v_master_id. If neither the IF nor the ELSIF condition is satisfied, the trigger executes an ELSE block containing an INSERT operation into the CUSTOMER_MASTER_INDEX table, providing values for the MASTER_CUSTOMER_ID and CMI_DETAILS columns, where MASTER_CUSTOMER_ID is the selected v_master_id value increased by 200 and CMI_DETAILS is the string 'Alternate_Record'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_tax_validation\nBEFORE INSERT ON COUNCIL_TAX\nFOR EACH ROW\nDECLARE\n    v_master_id NUMBER;\n    v_source_code VARCHAR2(255);\n    v_month_check NUMBER;\nBEGIN\n    SELECT MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE INTO v_master_id, v_source_code\n    FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = :NEW.CMI_CROSS_REF_ID;\n    \n    v_month_check := MONTHS_BETWEEN(TO_DATE('2024-12-31', 'YYYY-MM-DD'), SYSDATE);\n    \n    IF v_source_code = 'Rent' AND v_month_check > 6 THEN\n        INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (:NEW.CMI_CROSS_REF_ID + 5000, v_master_id, 'Tax_Linked');\n    ELSIF v_source_code = 'Parking' THEN\n        DELETE FROM CUSTOMER_MASTER_INDEX WHERE MASTER_CUSTOMER_ID = v_master_id;\n    ELSE\n        INSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (v_master_id + 200, 'Alternate_Record');\n    END IF;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "COUNCIL_TAX"
    ],
    "call_sqls": [
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (101, 1, 'Rent');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (1, 101)",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (102, 2, 'Parking');\nINSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (2, 'Test Customer');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (2, 102)",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (103, 3, 'Other');\nINSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (3, 'Another Customer');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (3, 103)",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (104, 4, 'Rent');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (4, 104)",
      "INSERT INTO CMI_CROSS_REFERENCES (CMI_CROSS_REF_ID, MASTER_CUSTOMER_ID, SOURCE_SYSTEM_CODE) VALUES (105, 5, 'Parking');\nINSERT INTO CUSTOMER_MASTER_INDEX (MASTER_CUSTOMER_ID, CMI_DETAILS) VALUES (5, 'Yet Another Customer');\nINSERT INTO COUNCIL_TAX (COUNCIL_TAX_ID, CMI_CROSS_REF_ID) VALUES (5, 105)"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_tax_validation on the COUNCIL_TAX table. Retrieve MASTER_CUSTOMER_ID and SOURCE_SYSTEM_CODE from CMI_CROSS_REFERENCES using the new CMI_CROSS_REF_ID. Calculate months until Dec 31, 2024. If source is 'Rent' and months > 6, insert into CMI_CROSS_REFERENCES with ID+5000 and 'Tax_Linked'. Else if source is 'Parking', delete from CUSTOMER_MASTER_INDEX. Otherwise, insert into CUSTOMER_MASTER_INDEX with MASTER_CUSTOMER_ID+200 and 'Alternate_Record'.",
    "natural_language": "Create a BEFORE INSERT row-level trigger called trg_tax_validation for the COUNCIL_TAX table. For each new row, use the new CMI_CROSS_REF_ID to get the MASTER_CUSTOMER_ID and SOURCE_SYSTEM_CODE from CMI_CROSS_REFERENCES. Then, calculate the number of months remaining until December 31, 2024. If the source system is 'Rent' and the months calculated are greater than 6, insert a new record into CMI_CROSS_REFERENCES using the original ID plus 5000 and with 'Tax_Linked' as the source. However, if the source is 'Parking', delete the corresponding record from CUSTOMER_MASTER_INDEX. For any other source, insert a new record into CUSTOMER_MASTER_INDEX using the MASTER_CUSTOMER_ID plus 200 and with 'Alternate_Record' as the source.",
    "id": 62,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_tax_validation` on the `COUNCIL_TAX` table in the `local_govt_mdm` database. This trigger executes for each new row before it is inserted into the `COUNCIL_TAX` table.\n\nThe trigger begins by declaring three local variables:\n1. `v_master_customer_id` of type `NUMBER`, intended to store the `MASTER_CUSTOMER_ID` retrieved from the `CMI_CROSS_REFERENCES` table.\n2. `v_source_system_code` of type `VARCHAR2(255)`, intended to store the `SOURCE_SYSTEM_CODE` retrieved from the `CMI_CROSS_REFERENCES` table.\n3. `v_months_remaining` of type `NUMBER`, intended to store the calculated number of months remaining until December 31, 2024.\n\nThe trigger then proceeds with the following operations:\n1. It selects the `MASTER_CUSTOMER_ID` and `SOURCE_SYSTEM_CODE` from the `CMI_CROSS_REFERENCES` table where the `CMI_CROSS_REF_ID` column matches the `CMI_CROSS_REF_ID` value of the new row being inserted (`:NEW.CMI_CROSS_REF_ID`). The retrieved `MASTER_CUSTOMER_ID` is stored in `v_master_customer_id`, and the retrieved `SOURCE_SYSTEM_CODE` is stored in `v_source_system_code`.\n2. It calculates the number of months remaining until December 31, 2024, by using the `MONTHS_BETWEEN` function. The calculation is `MONTHS_BETWEEN(TO_DATE('2024-12-31', 'YYYY-MM-DD'), SYSDATE)`. The result is stored in the `v_months_remaining` variable.\n\nFollowing these initial data retrievals and calculations, the trigger executes conditional logic based on the value of `v_source_system_code`:\n\n**Case 1: `v_source_system_code` is equal to 'Rent' and `v_months_remaining` is greater than 6**\nIf the `v_source_system_code` is 'Rent' and the calculated `v_months_remaining` is greater than 6, the trigger performs an `INSERT` operation into the `CMI_CROSS_REFERENCES` table.\nThe new record is populated with the following values:\n    - `CMI_CROSS_REF_ID`: Set to the original `CMI_CROSS_REF_ID` of the new row (`:NEW.CMI_CROSS_REF_ID`) plus 5000.\n    - `MASTER_CUSTOMER_ID`: Set to the retrieved `v_master_customer_id`.\n    - `SOURCE_SYSTEM_CODE`: Set to the string literal `'Tax_Linked'`.\n\n**Case 2: `v_source_system_code` is equal to 'Parking'**\nIf the `v_source_system_code` is 'Parking', the trigger performs a `DELETE` operation on the `CUSTOMER_MASTER_INDEX` table.\nThe `DELETE` targets the record where the `MASTER_CUSTOMER_ID` column matches the retrieved `v_master_customer_id`.\n\n**Else Case (Default Action for any other `v_source_system_code` value)**\nIf the `v_source_system_code` is neither 'Rent' nor 'Parking', the trigger performs an `INSERT` operation into the `CUSTOMER_MASTER_INDEX` table.\nThe new record is populated with the following values:\n    - `MASTER_CUSTOMER_ID`: Set to the retrieved `v_master_customer_id` plus 200.\n    - `CMI_DETAILS`: Set to the string literal `'Alternate_Record'`."
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_delete_wedding` that is activated for `DELETE` operations on the `WEDDING` table. This trigger is designed to perform actions both before each row is deleted and after the entire `DELETE` statement has completed. It declares a nested table type `church_id_t` as a collection of `NUMBER` indexed by `PLS_INTEGER`, and a global variable `g_church_ids` of this type to store `CHURCH_ID` values.\n\nIn the `BEFORE EACH ROW` section, for every row being deleted from the `WEDDING` table, the trigger performs two `DELETE` operations on the `PEOPLE` table. First, it deletes a row from the `PEOPLE` table where the `PEOPLE_ID` column matches the `MALE_ID` column value of the `OLD` row being deleted from the `WEDDING` table. Second, it deletes another row from the `PEOPLE` table where the `PEOPLE_ID` column matches the `FEMALE_ID` column value of the `OLD` row being deleted from the `WEDDING` table. After these deletions, the `CHURCH_ID` column value of the `OLD` row being deleted from the `WEDDING` table is added to the `g_church_ids` collection. The `COUNT` attribute of `g_church_ids` is used to determine the next available index for insertion.\n\nIn the `AFTER STATEMENT` section, after all rows specified by the `DELETE` statement on the `WEDDING` table have been processed, the trigger declares a local variable `v_wedding_count` of type `NUMBER`. It then iterates through each `CHURCH_ID` stored in the `g_church_ids` collection. For each `CHURCH_ID` in the collection, it executes a `SELECT` statement to count the number of rows in the `WEDDING` table where the `CHURCH_ID` column matches the current `CHURCH_ID` from the `g_church_ids` collection, storing this count in `v_wedding_count`. Subsequently, it checks if `v_wedding_count` is equal to `0`. If `v_wedding_count` is `0`, indicating that there are no remaining weddings associated with that specific `CHURCH_ID`, it then performs a `DELETE` operation on the `CHURCH` table, removing the row where the `CHURCH_ID` column matches the current `CHURCH_ID` from the `g_church_ids` collection.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_wedding\nFOR DELETE ON WEDDING\nCOMPOUND TRIGGER\n  TYPE church_id_t IS TABLE OF NUMBER INDEX BY PLS_INTEGER;\n  g_church_ids church_id_t;\n  \n  BEFORE EACH ROW IS\n  BEGIN\n    DELETE FROM PEOPLE WHERE PEOPLE_ID = :OLD.MALE_ID;\n    DELETE FROM PEOPLE WHERE PEOPLE_ID = :OLD.FEMALE_ID;\n    g_church_ids(g_church_ids.COUNT + 1) := :OLD.CHURCH_ID;\n  END BEFORE EACH ROW;\n  \n  AFTER STATEMENT IS\n    v_wedding_count NUMBER;\n  BEGIN\n    FOR i IN 1..g_church_ids.COUNT LOOP\n      SELECT COUNT(*) INTO v_wedding_count\n      FROM WEDDING\n      WHERE CHURCH_ID = g_church_ids(i);\n      \n      IF v_wedding_count = 0 THEN\n        DELETE FROM CHURCH WHERE CHURCH_ID = g_church_ids(i);\n      END IF;\n    END LOOP;\n  END AFTER STATEMENT;\nEND trg_delete_wedding;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "DELETE FROM WEDDING WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "DELETE FROM WEDDING WHERE CHURCH_ID = 3 AND MALE_ID = 3 AND FEMALE_ID = 4",
      "DELETE FROM WEDDING WHERE CHURCH_ID = 5 AND MALE_ID = 5 AND FEMALE_ID = 6",
      "DELETE FROM WEDDING WHERE CHURCH_ID = 2",
      "DELETE FROM WEDDING WHERE YEAR = 2014"
    ],
    "summary": "Create a compound trigger named `trg_delete_wedding` for DELETE operations on the WEDDING table. Before each row deletion, delete from the PEOPLE table where PEOPLE_ID matches the OLD.MALE_ID and OLD.FEMALE_ID, then store the OLD.CHURCH_ID in a collection. After the statement completes, for each stored CHURCH_ID, if no weddings remain in the WEDDING table for that CHURCH_ID, delete the corresponding row from the CHURCH table.",
    "natural_language": "Please construct a compound trigger designated as `trg_delete_wedding` to manage DELETE operations on the WEDDING table. Prior to the deletion of each individual row, it is necessary to remove corresponding entries from the PEOPLE table where the PEOPLE_ID aligns with the OLD.MALE_ID and OLD.FEMALE_ID values. Subsequently, the OLD.CHURCH_ID should be recorded into a collection. Upon completion of the statement, for each CHURCH_ID retained in the collection, if no associated records remain in the WEDDING table for that specific CHURCH_ID, the corresponding entry must be deleted from the CHURCH table.",
    "id": 63,
    "generated_ir": "Write an Oracle PL/SQL compound trigger named trg_delete_wedding that manages DELETE operations on the WEDDING table. The trigger consists of multiple timing sections: BEFORE EACH ROW, AFTER EACH ROW, and AFTER STATEMENT.\n\nFirst, in the BEFORE EACH ROW section, for each row about to be deleted, the trigger executes two DELETE statements on the PEOPLE table. The first DELETE removes the row where the PEOPLE_ID matches the OLD.MALE_ID value from the WEDDING row being deleted. The second DELETE removes the row where the PEOPLE_ID matches the OLD.FEMALE_ID value from the WEDDING row being deleted.\n\nSecond, in the AFTER EACH ROW section, the trigger stores the OLD.CHURCH_ID value from the deleted WEDDING row into a collection variable. This collection is declared as a nested table of NUMBER at the trigger level to accumulate CHURCH_ID values across all deleted rows.\n\nThird, in the AFTER STATEMENT section, after all rows have been deleted, the trigger processes each CHURCH_ID stored in the collection. For each distinct CHURCH_ID, it checks if any records remain in the WEDDING table for that CHURCH_ID by executing a SELECT COUNT(*) query on the WEDDING table with a WHERE condition on CHURCH_ID. If the count is zero, indicating no associated records remain, the trigger executes a DELETE statement on the CHURCH table to remove the row where CHURCH_ID matches the current CHURCH_ID from the collection.\n\nThe trigger ensures that when a WEDDING record is deleted, the corresponding male and female entries are removed from the PEOPLE table, and if a CHURCH no longer has any associated WEDDING records after the deletions, that CHURCH is also deleted."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_maintain_ratio that is executed after an update operation on the LENGTH column of the ROLLER_COASTER table for each row affected by the update. The trigger begins by declaring a local variable v_country_area of type NUMBER. It then retrieves the AREA value from the COUNTRY table where the COUNTRY_ID matches the COUNTRY_ID of the updated row in the ROLLER_COASTER table, storing this AREA value into the v_country_area variable. The trigger proceeds to evaluate a conditional statement comparing the tangent of the new LENGTH value divided by 1000 with the tangent of the old LENGTH value divided by 1000. If the tangent of the new LENGTH is greater than the tangent of the old LENGTH, the trigger updates the COUNTRY table by increasing the POPULATION column by 100 for the row where the COUNTRY_ID matches the COUNTRY_ID of the updated row in the ROLLER_COASTER table. Conversely, if the tangent of the new LENGTH is not greater than the tangent of the old LENGTH, the trigger updates the COUNTRY table by decreasing the POPULATION column by 100 for the row where the COUNTRY_ID matches the COUNTRY_ID of the updated row in the ROLLER_COASTER table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_ratio\nAFTER UPDATE OF LENGTH ON ROLLER_COASTER\nFOR EACH ROW\nDECLARE\n  v_country_area NUMBER;\nBEGIN\n  SELECT AREA INTO v_country_area FROM COUNTRY WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n  IF TAN(:NEW.LENGTH / 1000) > TAN(:OLD.LENGTH / 1000) THEN\n    UPDATE COUNTRY SET POPULATION = POPULATION + 100 WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n  ELSE\n    UPDATE COUNTRY SET POPULATION = POPULATION - 100 WHERE COUNTRY_ID = :NEW.COUNTRY_ID;\n  END IF;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY",
      "ROLLER_COASTER"
    ],
    "call_sqls": [
      "UPDATE ROLLER_COASTER SET LENGTH = 4000 WHERE ROLLER_COASTER_ID = 1",
      "UPDATE ROLLER_COASTER SET LENGTH = 2500 WHERE ROLLER_COASTER_ID = 2",
      "UPDATE ROLLER_COASTER SET LENGTH = 5000, COUNTRY_ID = 2 WHERE ROLLER_COASTER_ID = 3",
      "UPDATE ROLLER_COASTER SET LENGTH = LENGTH + 1000 WHERE COUNTRY_ID = 1",
      "UPDATE ROLLER_COASTER SET LENGTH = 1000 WHERE NAME = 'Boardwalk Bullet'"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_maintain_ratio on the ROLLER_COASTER table's LENGTH column. For each updated row, retrieve the AREA from the COUNTRY table matching the row's COUNTRY_ID. If TAN(:NEW.LENGTH/1000) > TAN(:OLD.LENGTH/1000), increase the matching COUNTRY's POPULATION by 100. Otherwise, decrease it by 100.",
    "natural_language": "Please construct a row-level trigger designated as 'trg_maintain_ratio' to execute after updates on the LENGTH column of the ROLLER_COASTER table. For each row that is updated, it is necessary to acquire the AREA value from the COUNTRY table where the COUNTRY_ID matches that of the updated row. Subsequently, if the tangent of the new length divided by 1000 exceeds the tangent of the old length divided by 1000, then the POPULATION for the corresponding country record should be incremented by 100. Conversely, if this condition is not met, the POPULATION should be decremented by 100.",
    "id": 64,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_maintain_ratio that is executed after an update operation on the ROLLER_COASTER table for each row being updated. The trigger specifically fires only when the LENGTH column of the ROLLER_COASTER table is updated. The trigger declares a local variable v_area of type NUMBER to store the AREA value retrieved from the COUNTRY table. For each updated row, the trigger performs a SELECT operation on the COUNTRY table to retrieve the AREA column value where the COUNTRY_ID in the COUNTRY table matches the COUNTRY_ID of the updated row in the ROLLER_COASTER table (represented as :NEW.COUNTRY_ID). This SELECT statement uses an implicit cursor to fetch the AREA into the v_area variable. After obtaining the AREA, the trigger evaluates a conditional expression: it checks if the tangent of the new LENGTH value divided by 1000 (i.e., TAN(:NEW.LENGTH / 1000)) is greater than the tangent of the old LENGTH value divided by 1000 (i.e., TAN(:OLD.LENGTH / 1000)). If this condition is true, the trigger executes an UPDATE operation on the COUNTRY table, incrementing the POPULATION column by 100 for the record where the COUNTRY_ID matches :NEW.COUNTRY_ID. If the condition is false, the trigger executes an UPDATE operation on the COUNTRY table, decrementing the POPULATION column by 100 for the same matching record. The trigger does not include any explicit exception handling or logging. The operations are performed directly based on the comparison of trigonometric values derived from the LENGTH column changes."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_song_position_update that fires before any row is updated in the SONG table, and for each row being updated, it declares a local variable v_singer_count of type NUMBER, then checks if the new value for the SALES column in the SONG table is greater than 500000, and if this condition is true, it sets the new value for the HIGHEST_POSITION column in the SONG table to 1, then checks if the new value for the HIGHEST_POSITION column equals 1, and if this condition is true, it executes an update on the SINGER table, incrementing the NET_WORTH_MILLIONS column by 10 for the specific row where the SINGER_ID column matches the new SINGER_ID value from the SONG table, then performs a select statement on the SINGER table to count the number of rows where the SINGER_ID column matches the new SINGER_ID value from the SONG table, storing the result into the v_singer_count variable, then checks if the v_singer_count variable equals 0, and if this condition is true, it executes an insert into the SINGER table, providing values for the columns SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, and CITIZENSHIP, where the SINGER_ID is set to the new SINGER_ID value from the SONG table, the NAME is set to the literal string 'New Talent', the BIRTH_YEAR is calculated by extracting the year component from the current system date using the EXTRACT function with the YEAR argument and CURRENT_DATE, then subtracting 20 from that year, the NET_WORTH_MILLIONS is set to 0, and the CITIZENSHIP is set to the literal string 'Unknown'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_song_position_update\nBEFORE UPDATE ON SONG\nFOR EACH ROW\nDECLARE\n   v_singer_count NUMBER;\nBEGIN\n   IF :NEW.SALES > 500000 THEN\n      :NEW.HIGHEST_POSITION := 1;\n   END IF;\n\n   IF :NEW.HIGHEST_POSITION = 1 THEN\n      UPDATE SINGER SET NET_WORTH_MILLIONS = NET_WORTH_MILLIONS + 10 WHERE SINGER_ID = :NEW.SINGER_ID;\n   END IF;\n\n   SELECT COUNT(*) INTO v_singer_count FROM SINGER WHERE SINGER_ID = :NEW.SINGER_ID;\n\n   IF v_singer_count = 0 THEN\n      INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP)\n      VALUES (:NEW.SINGER_ID, 'New Talent', EXTRACT(YEAR FROM CURRENT_DATE) - 20, 0, 'Unknown');\n   END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SONG SET SALES = 600000 WHERE SONG_ID = 3",
      "UPDATE SONG SET SALES = 550000, SINGER_ID = 1 WHERE SONG_ID = 4",
      "UPDATE SONG SET HIGHEST_POSITION = 1 WHERE SONG_ID = 5",
      "UPDATE SONG SET SALES = 700000, SINGER_ID = 99 WHERE SONG_ID = 6",
      "UPDATE SONG SET SALES = 400000, HIGHEST_POSITION = 1, SINGER_ID = 100 WHERE SONG_ID = 7"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_song_position_update on the SONG table. Declare a local NUMBER variable v_singer_count. If the new SALES > 500,000, set the new HIGHEST_POSITION to 1. If the new HIGHEST_POSITION is 1, update the SINGER table to increase NET_WORTH_MILLIONS by 10 for the matching SINGER_ID. Then, check if this singer exists. If not (count = 0), insert a new singer with the SINGER_ID from the song, NAME='New Talent', BIRTH_YEAR as current year minus 20, NET_WORTH_MILLIONS=0, and CITIZENSHIP='Unknown'.",
    "natural_language": "Create a BEFORE UPDATE row-level trigger called trg_song_position_update for the SONG table. First, declare a local NUMBER variable named v_singer_count. If the new SALES value exceeds 500,000, set the new HIGHEST_POSITION to 1. Then, if the new HIGHEST_POSITION is 1, update the SINGER table to add 10 to the NET_WORTH_MILLIONS for the matching SINGER_ID. Next, check for the existence of this singer. If the singer does not exist (count is 0), insert a new singer record using the song's SINGER_ID, set the NAME to 'New Talent', the BIRTH_YEAR to the current year minus 20, NET_WORTH_MILLIONS to 0, and CITIZENSHIP to 'Unknown'.",
    "id": 65,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_song_position_update that fires before any row is updated in the SONG table, and for each row being updated, it declares a local variable v_singer_count of type NUMBER, then checks if the new value for the SALES column in the SONG table is greater than 500000, and if this condition is true, it sets the new value for the HIGHEST_POSITION column in the SONG table to 1, then checks if the new value for the HIGHEST_POSITION column equals 1, and if this condition is true, it executes an update on the SINGER table, incrementing the NET_WORTH_MILLIONS column by 10 for the specific row where the SINGER_ID column matches the new SINGER_ID value from the SONG table, then performs a select statement on the SINGER table to count the number of rows where the SINGER_ID column matches the new SINGER_ID value from the SONG table, storing the result into the v_singer_count variable, then checks if the v_singer_count variable equals 0, and if this condition is true, it executes an insert into the SINGER table, providing values for the columns SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, and CITIZENSHIP, where the SINGER_ID is set to the new SINGER_ID value from the SONG table, the NAME is set to the literal string 'New Talent', the BIRTH_YEAR is calculated by extracting the year component from the current system date using the EXTRACT function with the YEAR argument and CURRENT_DATE, then subtracting 20 from that year, the NET_WORTH_MILLIONS is set to 0, and the CITIZENSHIP is set to the literal string 'Unknown'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_audit_round_insert that is defined to execute automatically after a new row is inserted into the ROUND table, which declares a local variable v_total_rounds of type NUMBER, then performs a SELECT COUNT(*) operation on the ROUND table to retrieve the total number of rows currently in that table and stores the result into the variable v_total_rounds, and subsequently performs an INSERT operation into the MEMBER table, specifying values for the columns MEMBER_ID, NAME, COUNTRY, and COLLEGE_ID, where the MEMBER_ID value is calculated by adding 1000 to the value stored in v_total_rounds, the NAME column is set to the literal string 'Audit User', the COUNTRY column is set to the literal string 'Audit', and the COLLEGE_ID column is explicitly set to NULL.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_audit_round_insert\nAFTER INSERT ON ROUND\nDECLARE\n    v_total_rounds NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_total_rounds FROM ROUND;\n    INSERT INTO MEMBER (MEMBER_ID, NAME, COUNTRY, COLLEGE_ID) \n    VALUES (v_total_rounds + 1000, 'Audit User', 'Audit', NULL);\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (2, 1, 'Ocean Breeze', 3)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (3, 2, 'Forest Green', 1)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (4, 3, 'Sunset Glow', 2)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (5, 1, 'Winter Frost', 5)",
      "INSERT INTO ROUND (ROUND_ID, MEMBER_ID, DECORATION_THEME, RANK_IN_ROUND) VALUES (6, 2, 'Desert Sand', 4)"
    ],
    "summary": "Create an AFTER INSERT trigger named trg_audit_round_insert on ROUND table. After each insert, count total rows in ROUND table and insert a new row into MEMBER table with MEMBER_ID as (1000 + total count), NAME as 'Audit User', COUNTRY as 'Audit', and COLLEGE_ID as NULL.",
    "natural_language": "Alright, so we need to set up a trigger called trg_audit_round_insert for the ROUND table that fires off after any new row is added. When it runs, it should figure out how many rows are in ROUND, then pop a new record into the MEMBER table. For that new member, make the MEMBER_ID 1000 plus that total count, set the NAME to 'Audit User', the COUNTRY to 'Audit', and just leave COLLEGE_ID blank (null).",
    "id": 66,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_audit_round_insert that is defined to execute automatically after a new row is inserted into the ROUND table, and it executes once for each individual row that is inserted. The trigger declares a local variable v_total_rounds of type NUMBER. It then executes a SELECT statement to count the total number of rows currently in the ROUND table, storing the result into v_total_rounds. Following this, the trigger performs an INSERT operation into the MEMBER table, specifying values for the columns MEMBER_ID, NAME, COUNTRY, and COLLEGE_ID. The MEMBER_ID column is populated with the result of the calculation 1000 plus v_total_rounds. The NAME column is populated with the literal string 'Audit User'. The COUNTRY column is populated with the literal string 'Audit'. The COLLEGE_ID column is explicitly set to NULL."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_singer_worth_update that activates after an update to the NET_WORTH_MILLIONS column in the SINGER table for each row affected. The trigger declares two local variables: v_year of type NUMBER to store the current year extracted from the system date, and v_count of type NUMBER to store the count of songs associated with the singer whose net worth has been updated. It retrieves the count of songs from the SONG table where the SINGER_ID matches the updated row's SINGER_ID using a SELECT COUNT(*) statement and stores the result in v_count. The trigger then evaluates the updated NET_WORTH_MILLIONS value using conditional logic. If the updated net worth exceeds 50 million and the singer has one or more songs (v_count > 0), it appends '_GOLD' to the TITLE of each song associated with the singer by executing an UPDATE statement on the SONG table. If the net worth is less than 10 million and the singer has songs, it appends '_BRONZE' to the TITLE of each song. If the net worth is between 10 and 50 million inclusive and the singer has songs, it appends '_SILVER' to the TITLE of each song. If none of these conditions are met, specifically if the singer has no songs or the net worth does not fall within the specified ranges, it deletes songs from the SONG table where the SINGER_ID matches the updated row's SINGER_ID and the SALES column value is less than 1000, using a DELETE statement.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_worth_update\nAFTER UPDATE OF NET_WORTH_MILLIONS ON SINGER\nFOR EACH ROW\nDECLARE\n    v_year NUMBER;\n    v_count NUMBER;\nBEGIN\n    v_year := EXTRACT(YEAR FROM CURRENT_DATE);\n    SELECT COUNT(*) INTO v_count FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID;\n    IF :NEW.NET_WORTH_MILLIONS > 50 AND v_count > 0 THEN\n        UPDATE SONG SET TITLE = TITLE || '_GOLD' WHERE SINGER_ID = :NEW.SINGER_ID;\n    ELSIF :NEW.NET_WORTH_MILLIONS < 10 AND v_count > 0 THEN\n        UPDATE SONG SET TITLE = TITLE || '_BRONZE' WHERE SINGER_ID = :NEW.SINGER_ID;\n    ELSIF :NEW.NET_WORTH_MILLIONS BETWEEN 10 AND 50 AND v_count > 0 THEN\n        UPDATE SONG SET TITLE = TITLE || '_SILVER' WHERE SINGER_ID = :NEW.SINGER_ID;\n    ELSE\n        DELETE FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID AND SALES < 1000;\n    END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 60 WHERE SINGER_ID = 1",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 5 WHERE SINGER_ID = 2",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 25 WHERE SINGER_ID = 3",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 70 WHERE SINGER_ID = 4",
      "UPDATE SINGER SET NET_WORTH_MILLIONS = 8 WHERE SINGER_ID = 5"
    ],
    "summary": "Create a trigger named trg_singer_worth_update that fires after each row update on the SINGER table's NET_WORTH_MILLIONS column. For each row, count the singer's songs. If the new net worth is greater than 50 million and the song count is greater than 0, append '_GOLD' to all their song titles. If the net worth is less than 10 million and there are songs, append '_BRONZE'. If the net worth is between 10 and 50 million and there are songs, append '_SILVER'. Otherwise, if the conditions are not met, delete the singer's songs where sales are less than 1000.",
    "natural_language": "Construct a trigger, which should be named trg_singer_worth_update, that is meticulously designed to activate automatically after each individual row is updated specifically within the NET_WORTH_MILLIONS column of the SINGER table. For every updated singer record, you must first calculate the total number of songs associated with that particular artist. Subsequently, if the newly entered net worth figure substantially exceeds 50 million and, concurrently, the artist's song count is confirmed to be greater than zero, then you are required to systematically append the suffix '_GOLD' to the title of every single one of their songs. Conversely, if the net worth regrettably falls below 10 million while the artist still has songs listed, you must instead attach the suffix '_BRONZE' to all their song titles. In the scenario where the net worth is determined to be comfortably situated between 10 and 50 million inclusive and there are indeed songs present, the appropriate suffix to append becomes '_SILVER'. Finally, in all other cases where none of the aforementioned detailed conditions are satisfactorily met, you must proceed to delete any and all of that singer's songs for which the recorded sales are unfortunately less than 1000 units.",
    "id": 67,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_singer_worth_update that is executed after each row update operation on the SINGER table, specifically when the NET_WORTH_MILLIONS column is updated. The trigger operates on a per-row basis for each updated singer record.\n\nFirst, the trigger declares a local variable v_song_count of type NUMBER to store the total number of songs associated with the singer. It calculates this by executing a SELECT COUNT(*) statement against the SONG table where the SINGER_ID column equals the new SINGER_ID value from the updated row in the SINGER table, and stores the result in v_song_count.\n\nNext, the trigger evaluates conditions based on the new NET_WORTH_MILLIONS value and v_song_count. If the new NET_WORTH_MILLIONS is greater than 50 and v_song_count is greater than 0, the trigger updates the SONG table by setting the TITLE column to the concatenation of the original TITLE and the suffix '_GOLD' for all rows where SINGER_ID equals the new SINGER_ID.\n\nIf the new NET_WORTH_MILLIONS is less than 10 and v_song_count is greater than 0, the trigger updates the SONG table by setting the TITLE column to the concatenation of the original TITLE and the suffix '_BRONZE' for all rows where SINGER_ID equals the new SINGER_ID.\n\nIf the new NET_WORTH_MILLIONS is between 10 and 50 inclusive (i.e., greater than or equal to 10 and less than or equal to 50) and v_song_count is greater than 0, the trigger updates the SONG table by setting the TITLE column to the concatenation of the original TITLE and the suffix '_SILVER' for all rows where SINGER_ID equals the new SINGER_ID.\n\nIn all other cases where none of the above conditions are met (i.e., if v_song_count is 0, or if the conditions for suffix appending are not satisfied), the trigger executes a DELETE operation on the SONG table for rows where SINGER_ID equals the new SINGER_ID and the SALES column is less than 1000."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_clean_customer_email that is defined to fire automatically before any row insertion operation is performed on the CUSTOMERS table, and for each individual row being inserted, the trigger executes a block of code that performs a single operation: it assigns a new value to the EMAIL_ADDRESS column of the newly inserted row, represented by the :NEW.EMAIL_ADDRESS pseudorecord, by applying the RTRIM function to the original incoming value of :NEW.EMAIL_ADDRESS, which removes any trailing space characters from the end of the email address string.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_clean_customer_email\nBEFORE INSERT ON CUSTOMERS\nFOR EACH ROW\nBEGIN\n    :NEW.EMAIL_ADDRESS := RTRIM(:NEW.EMAIL_ADDRESS);\nEND;",
    "database_name": "customer_complaints",
    "tables": [
      "COMPLAINTS",
      "CUSTOMERS",
      "PRODUCTS",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (1, 'Good Credit Rating', '123 Main St', 'Apt 1A', 'Anytown', 'CA', 'test1@example.com   ', '555-1111')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (2, 'Good Credit Rating', '456 Oak Ave', NULL, 'Otherville', 'NY', 'test2@example.org  ', '555-2222')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (3, 'Good Credit Rating', '789 Pine Ln', 'Suite 200', 'Smalltown', 'TX', 'test3@example.net     ', '555-3333')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (4, 'Good Credit Rating', '101 Elm Rd', 'Unit B', 'Big City', 'FL', 'another.email@domain.com ', '555-4444')",
      "INSERT INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_TYPE_CODE, ADDRESS_LINE_1, ADDRESS_LINE_2, TOWN_CITY, STATE, EMAIL_ADDRESS, PHONE_NUMBER) VALUES (5, 'Good Credit Rating', '202 Maple Dr', NULL, 'Metropolis', 'GA', 'user.name@company.org   ', '555-5555')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_clean_customer_email on the CUSTOMERS table. For each row, trim trailing spaces from the new EMAIL_ADDRESS value.",
    "natural_language": "Hey, can you set up a trigger called trg_clean_customer_email for the CUSTOMERS table? It should fire before any new row is added and just clean up the EMAIL_ADDRESS by chopping off any extra spaces at the end.",
    "id": 68,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_clean_customer_email that is executed before an insert operation on the CUSTOMERS table for each row being inserted. The trigger does not declare any local variables. Upon activation, for each new row being inserted into the CUSTOMERS table, the trigger performs a single operation: it modifies the EMAIL_ADDRESS column of the new row. Specifically, it applies the RTRIM function to the value currently held in the :NEW.EMAIL_ADDRESS pseudorecord. The RTRIM function removes all trailing space characters from the right end of the string. The result of this trimming operation is then assigned back to the :NEW.EMAIL_ADDRESS pseudorecord, effectively updating the EMAIL_ADDRESS column for the row currently being inserted to a version with no trailing spaces."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_university_update that is defined to fire automatically after any row in the UNIVERSITY table is updated, and for each individual row that is updated, the trigger executes a DELETE operation on the MAJOR_RANKING table where the condition UNIVERSITY_ID = :OLD.UNIVERSITY_ID is met, using the OLD pseudorecord to reference the value of the UNIVERSITY_ID column from the row in the UNIVERSITY table before the update occurred.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_university_update\nAFTER UPDATE ON UNIVERSITY\nFOR EACH ROW\nBEGIN\n    DELETE FROM MAJOR_RANKING WHERE UNIVERSITY_ID = :OLD.UNIVERSITY_ID;\nEND;",
    "database_name": "university_rank",
    "tables": [
      "MAJOR",
      "MAJOR_RANKING",
      "UNIVERSITY"
    ],
    "call_sqls": [
      "UPDATE UNIVERSITY SET UNIVERSITY_NAME = 'Updated College' WHERE UNIVERSITY_ID = 1",
      "UPDATE UNIVERSITY SET CITY = 'New City' WHERE UNIVERSITY_ID = 2",
      "UPDATE UNIVERSITY SET ENROLLMENT = 3000 WHERE UNIVERSITY_ID = 3",
      "UPDATE UNIVERSITY SET STATE = 'California', TEAM_NAME = 'Golden Bears' WHERE UNIVERSITY_ID = 1",
      "UPDATE UNIVERSITY SET AFFILIATION = 'Public' WHERE UNIVERSITY_ID = 2"
    ],
    "summary": "Create a trigger named trg_university_update that fires AFTER UPDATE on the UNIVERSITY table for each row. For each updated row, delete rows from the MAJOR_RANKING table where UNIVERSITY_ID equals the old UNIVERSITY_ID value from the updated row.",
    "natural_language": "What trigger can be created to fire after an update on the UNIVERSITY table, deleting rows from the MAJOR_RANKING table where the UNIVERSITY_ID matches the old UNIVERSITY_ID from the updated row?",
    "id": 69,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_university_update that is executed after an update operation on the UNIVERSITY table. This trigger operates for each row that has been updated. The trigger's main function is to delete rows from the MAJOR_RANKING table where the UNIVERSITY_ID column matches the UNIVERSITY_ID value of the row from the UNIVERSITY table before it was updated. The trigger uses the :OLD pseudorecord to access the pre-update value of the UNIVERSITY_ID from the row that was modified. The DELETE statement within the trigger removes all records from the MAJOR_RANKING table that have a UNIVERSITY_ID value equal to the :OLD.UNIVERSITY_ID, effectively cleaning up ranking data associated with the university as identified by its original ID after the university record has been altered."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_country_uppercase` that is configured to execute `BEFORE` an `INSERT` operation is performed on the `COUNTRY` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row that is being inserted into the `COUNTRY` table. Within the `DECLARE` section, a local PL/SQL variable named `v_upper_name` is declared, which is of data type `VARCHAR2` with a maximum length of 255 characters. The `BEGIN` block of the trigger first assigns a value to `v_upper_name` by calling the `UPPER()` SQL function. The `UPPER()` function takes a single string argument and returns that string with all alphabetic characters converted to uppercase. The argument passed to `UPPER()` is `:NEW.NAME`, which represents the value of the `NAME` column for the row currently being inserted, as it exists `BEFORE` the insert operation is finalized. Subsequently, the trigger modifies the value of the `NAME` column for the row currently being inserted by assigning the value stored in the `v_upper_name` variable to `:NEW.NAME`. This effectively ensures that the `NAME` column of any new row inserted into the `COUNTRY` table will have its value automatically converted to uppercase before the row is permanently stored in the table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_country_uppercase\nBEFORE INSERT ON COUNTRY\nFOR EACH ROW\nDECLARE\n  v_upper_name VARCHAR2(255);\nBEGIN\n  v_upper_name := UPPER(:NEW.NAME);\n  :NEW.NAME := v_upper_name;\nEND;",
    "database_name": "roller_coaster",
    "tables": [
      "COUNTRY"
    ],
    "call_sqls": [
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (4, 'france', 67750000, 551695, 'French')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME) VALUES (5, 'germany')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION, AREA, LANGUAGES) VALUES (6, 'spain', 47450795, 505990, 'Spanish')",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, POPULATION) VALUES (7, 'italy', 60317116)",
      "INSERT INTO COUNTRY (COUNTRY_ID, NAME, AREA, LANGUAGES) VALUES (8, 'portugal', 92212, 'Portuguese')"
    ],
    "summary": "Create a BEFORE INSERT FOR EACH ROW trigger named trg_country_uppercase on the COUNTRY table. Convert the new NAME column value to uppercase before insertion.",
    "natural_language": "Please implement a BEFORE INSERT FOR EACH ROW trigger, designated as trg_country_uppercase, for the COUNTRY table. This trigger must convert the value of the incoming NAME column to uppercase prior to its insertion.",
    "id": 70,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_country_uppercase` that is configured to execute `BEFORE` an `INSERT` operation is performed on the `COUNTRY` table. This trigger is defined as a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row that is being inserted into the `COUNTRY` table. Within the `DECLARE` section, a local PL/SQL variable named `v_upper_name` is declared, which is of data type `VARCHAR2` with a maximum length of 255 characters. The `BEGIN` block of the trigger first assigns a value to `v_upper_name` by calling the `UPPER()` SQL function. The `UPPER()` function takes a single string argument and returns that string with all alphabetic characters converted to uppercase. The argument passed to `UPPER()` is `:NEW.NAME`, which represents the value of the `NAME` column for the row currently being inserted, as it exists `BEFORE` the insert operation is finalized. Subsequently, the trigger modifies the value of the `NAME` column for the row currently being inserted by assigning the value stored in the `v_upper_name` variable to `:NEW.NAME`. This effectively ensures that the `NAME` column of any new row inserted into the `COUNTRY` table will have its value automatically converted to uppercase before the row is permanently stored in the table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_school_colors_update that is executed after an update operation on the SCHOOL table for each row affected by the update. The trigger declares a local variable v_colors of type VARCHAR2 with a maximum length of 255 characters. It begins by selecting the COLORS column from the SCHOOL_DETAILS table where the SCHOOL_ID matches the SCHOOL_ID of the row before the update, referred to as :OLD.SCHOOL_ID, and stores the result in the v_colors variable. The trigger then checks if v_colors is not null, indicating that the COLORS column in SCHOOL_DETAILS has a value for the corresponding SCHOOL_ID. If this condition is true, the trigger proceeds to update the SCHOOL_DETAILS table by setting the COLORS column to the new value of SCHOOL_COLORS from the updated row in the SCHOOL table, identified by :NEW.SCHOOL_COLORS, for the same SCHOOL_ID that matches :OLD.SCHOOL_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_school_colors_update\nAFTER UPDATE ON SCHOOL\nFOR EACH ROW\nDECLARE\n    v_colors VARCHAR2(255);\nBEGIN\n    SELECT COLORS INTO v_colors FROM SCHOOL_DETAILS WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    IF v_colors IS NOT NULL THEN\n        UPDATE SCHOOL_DETAILS SET COLORS = :NEW.SCHOOL_COLORS WHERE SCHOOL_ID = :OLD.SCHOOL_ID;\n    END IF;\nEND;",
    "database_name": "school_player",
    "tables": [
      "PLAYER",
      "SCHOOL",
      "SCHOOL_DETAILS",
      "SCHOOL_PERFORMANCE"
    ],
    "call_sqls": [
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Green & Yellow' WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Purple & Gold' WHERE SCHOOL_ID = 3",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Orange & Black' WHERE SCHOOL_ID = 4",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Blue & White' WHERE SCHOOL_ID = 2",
      "UPDATE SCHOOL SET SCHOOL_COLORS = 'Maroon & Silver' WHERE SCHOOL_ID = 3"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_school_colors_update on the SCHOOL table. It retrieves the existing COLORS value from SCHOOL_DETAILS for the OLD.SCHOOL_ID. If a value exists, it updates the SCHOOL_DETAILS.COLORS with the NEW.SCHOOL_COLORS value for the same SCHOOL_ID.",
    "natural_language": "Create a row-level trigger called trg_school_colors_update that fires AFTER UPDATE on the SCHOOL table. For each updated row, fetch the current COLORS value from SCHOOL_DETAILS using the OLD.SCHOOL_ID. If a record is found, update the SCHOOL_DETAILS.COLORS value to match the NEW.SCHOOL_COLORS for that SCHOOL_ID.",
    "id": 71,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_school_colors_update` that is activated automatically after an `UPDATE` operation is performed on any row within the `SCHOOL` table. This trigger is a row-level trigger, meaning it executes once for each row that is updated in the `SCHOOL` table.\n\nUpon activation for a specific updated row, the trigger first declares a variable named `v_current_colors` of data type `VARCHAR2(255)`. This variable is intended to temporarily store the current value of the `COLORS` column from the `SCHOOL_DETAILS` table.\n\nThe trigger then executes a `SELECT` statement to query the `SCHOOL_DETAILS` table. The purpose of this query is to retrieve the current value of the `COLORS` column for a specific school. The `SELECT` statement targets the `COLORS` column from the `SCHOOL_DETAILS` table. It includes a `WHERE` clause with a single condition: the `SCHOOL_ID` column in the `SCHOOL_DETAILS` table must be equal to the value of the `SCHOOL_ID` column from the original, pre-update row in the `SCHOOL` table (referenced as `:OLD.SCHOOL_ID`). The result of this query is fetched into the previously declared variable `v_current_colors`.\n\nFollowing the `SELECT` operation, the trigger evaluates a conditional statement. The condition checks if a record was successfully found by the preceding `SELECT` query. In PL/SQL, this is typically done by checking the implicit cursor attribute `SQL%FOUND`, which returns `TRUE` if the `SELECT` statement retrieved at least one row. If this condition evaluates to `TRUE`, indicating that a corresponding record exists in the `SCHOOL_DETAILS` table for the given `:OLD.SCHOOL_ID`, the trigger then executes an `UPDATE` statement.\n\nThis `UPDATE` statement modifies the `SCHOOL_DETAILS` table. It sets the value of the `COLORS` column to a new value. The new value is the value of the `SCHOOL_COLORS` column from the newly updated row in the `SCHOOL` table (referenced as `:NEW.SCHOOL_COLORS`). The `UPDATE` statement includes a `WHERE` clause to specify which row(s) to update. The condition is that the `SCHOOL_ID` column in the `SCHOOL_DETAILS` table must be equal to the value of the `SCHOOL_ID` column from the newly updated row in the `SCHOOL` table (referenced as `:NEW.SCHOOL_ID`). This ensures the update targets the correct school's details record.\n\nIf the initial condition (`SQL%FOUND`) evaluates to `FALSE`, meaning no record was found in `SCHOOL_DETAILS` for the `:OLD.SCHOOL_ID`, the trigger takes no further action for that row. The trigger's logic is contained within a block that handles the `NO_DATA_FOUND` exception or checks the cursor attribute to prevent errors if the `SELECT` statement finds no data."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_after_customer_update_status that activates after an update to the AMOUNT_OUTSTANDING column in the CUSTOMERS table for each row affected. The trigger declares four local variables: v_total_payments of type NUMBER to store the sum of payments made by the customer, v_lesson_price_avg of type NUMBER to store the average price of lessons associated with the customer, v_staff_active of type NUMBER to count active staff members linked to the customer's lessons, and v_action of type VARCHAR2(255) to determine the status of the customer based on certain conditions. The trigger first executes a SELECT statement to calculate the total payments made by the customer by summing the AMOUNT_PAYMENT column from the CUSTOMER_PAYMENTS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID. It then calculates the average lesson price by selecting the AVG(PRICE) from the LESSONS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID. Next, it counts the number of active staff members by selecting COUNT(*) from the STAFF table where DATE_LEFT_STAFF is NULL and the STAFF_ID is present in the LESSONS table for the given CUSTOMER_ID. The trigger then evaluates several conditions: if the new AMOUNT_OUTSTANDING is greater than the total payments, it sets v_action to 'Overdue'; if the average lesson price exceeds 200 and there are active staff members, it sets v_action to 'VIP Service'; if the old AMOUNT_OUTSTANDING is less than the new AMOUNT_OUTSTANDING, it sets v_action to 'Increasing Debt'; otherwise, it sets v_action to 'Stable'. Finally, the trigger deletes rows from the LESSONS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID and the LESSON_STATUS_CODE is 'Cancelled'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_after_customer_update_status\nAFTER UPDATE OF AMOUNT_OUTSTANDING ON CUSTOMERS\nFOR EACH ROW\nDECLARE\n    v_total_payments NUMBER;\n    v_lesson_price_avg NUMBER;\n    v_staff_active NUMBER;\n    v_action VARCHAR2(255);\nBEGIN\n    SELECT SUM(AMOUNT_PAYMENT) INTO v_total_payments FROM CUSTOMER_PAYMENTS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    SELECT AVG(PRICE) INTO v_lesson_price_avg FROM LESSONS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID;\n    SELECT COUNT(*) INTO v_staff_active FROM STAFF WHERE DATE_LEFT_STAFF IS NULL AND STAFF_ID IN (SELECT STAFF_ID FROM LESSONS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID);\n    IF :NEW.AMOUNT_OUTSTANDING > v_total_payments THEN\n        v_action := 'Overdue';\n    ELSIF v_lesson_price_avg > 200 AND v_staff_active > 0 THEN\n        v_action := 'VIP Service';\n    ELSIF :OLD.AMOUNT_OUTSTANDING < :NEW.AMOUNT_OUTSTANDING THEN\n        v_action := 'Increasing Debt';\n    ELSE\n        v_action := 'Stable';\n    END IF;\n    DELETE FROM LESSONS WHERE CUSTOMER_ID = :NEW.CUSTOMER_ID AND LESSON_STATUS_CODE = 'Cancelled';\nEND;",
    "database_name": "driving_school",
    "tables": [
      "CUSTOMERS",
      "CUSTOMER_PAYMENTS",
      "LESSONS",
      "STAFF"
    ],
    "call_sqls": [
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 500 WHERE CUSTOMER_ID = 1",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 10000 WHERE CUSTOMER_ID = 3",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 2000, CUSTOMER_STATUS_CODE = 'Good Customer' WHERE CUSTOMER_ID = 4",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = AMOUNT_OUTSTANDING + 100 WHERE CUSTOMER_ID = 6",
      "UPDATE CUSTOMERS SET AMOUNT_OUTSTANDING = 0 WHERE CUSTOMER_ID = 8"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named TRG_AFTER_CUSTOMER_UPDATE_STATUS on the CUSTOMERS table, firing when the AMOUNT_OUTSTANDING column is updated. For each affected row, calculate the customer's total payments, average lesson price, and count of active staff. Based on these values and the old/new outstanding amounts, determine a status ('Overdue', 'VIP Service', 'Increasing Debt', or 'Stable'). Finally, delete any lessons for this customer with a status of 'Cancelled'.",
    "natural_language": "Set up a trigger on the CUSTOMERS table that runs after updates, specifically when the amount a customer owes changes. For each customer row that gets updated, figure out some general numbers about their payments, what they typically pay for lessons, and how many staff are currently helping them. Then, look at their old and new outstanding amounts along with those numbers to decide on a general status category, like if they're behind, deserve special treatment, are getting deeper in debt, or are just okay. After that, get rid of any of that customer's lessons that are marked as cancelled.",
    "id": 72,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_after_customer_update_status that activates after an update to the AMOUNT_OUTSTANDING column in the CUSTOMERS table for each row affected. The trigger declares four local variables: v_total_payments of type NUMBER to store the sum of payments made by the customer, v_lesson_price_avg of type NUMBER to store the average price of lessons associated with the customer, v_staff_active of type NUMBER to count active staff members linked to the customer's lessons, and v_action of type VARCHAR2(255) to determine the status of the customer based on certain conditions. The trigger first executes a SELECT statement to calculate the total payments made by the customer by summing the AMOUNT_PAYMENT column from the CUSTOMER_PAYMENTS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID. It then calculates the average lesson price by selecting the AVG(PRICE) from the LESSONS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID. Next, it counts the number of active staff members by selecting COUNT(*) from the STAFF table where DATE_LEFT_STAFF is NULL and the STAFF_ID is present in the LESSONS table for the given CUSTOMER_ID. The trigger then evaluates several conditions: if the new AMOUNT_OUTSTANDING is greater than the total payments, it sets v_action to 'Overdue'; if the average lesson price exceeds 200 and there are active staff members, it sets v_action to 'VIP Service'; if the old AMOUNT_OUTSTANDING is less than the new AMOUNT_OUTSTANDING, it sets v_action to 'Increasing Debt'; otherwise, it sets v_action to 'Stable'. Finally, the trigger deletes rows from the LESSONS table where the CUSTOMER_ID matches the updated row's CUSTOMER_ID and the LESSON_STATUS_CODE is 'Cancelled'."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_language_names that executes automatically before any update operation that modifies the NAME column on the LANGUAGES table, and it processes each affected row individually. The trigger declares a local variable v_country_count of type NUMBER. It performs a SELECT statement on the OFFICIAL_LANGUAGES table, counting all rows where the LANGUAGE_ID column matches the new ID value from the LANGUAGES row being updated, and stores the result in v_country_count. If this count is greater than zero, the trigger proceeds with two conditional checks. First, it checks if the length of the new NAME value exceeds 20 characters; if so, it modifies the new NAME value by using the SUBSTR function to truncate it to only the first 20 characters. Second, it compares the new NAME value to the old NAME value; if they are different, the trigger performs an INSERT operation into the LANGUAGES table, creating a new row where the ID column is set to the new ID value plus 1000 and the NAME column is set to the concatenation of the old NAME value and the string '_old'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_language_names\nBEFORE UPDATE OF NAME ON LANGUAGES\nFOR EACH ROW\nDECLARE\n    v_country_count NUMBER;\n    PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN\n    SELECT COUNT(*) INTO v_country_count FROM OFFICIAL_LANGUAGES WHERE LANGUAGE_ID = :NEW.ID;\n    IF v_country_count > 0 THEN\n        IF LENGTH(:NEW.NAME) > 20 THEN\n            :NEW.NAME := SUBSTR(:NEW.NAME, 1, 20);\n        END IF;\n        IF :NEW.NAME != :OLD.NAME THEN\n            INSERT INTO LANGUAGES (ID, NAME) VALUES (:NEW.ID + 1000, :OLD.NAME || '_old');\n            COMMIT;\n        END IF;\n    END IF;\nEND;",
    "database_name": "country_language",
    "tables": [
      "COUNTRIES",
      "LANGUAGES",
      "OFFICIAL_LANGUAGES"
    ],
    "call_sqls": [
      "UPDATE LANGUAGES SET NAME = 'English_Updated' WHERE ID = 3",
      "UPDATE LANGUAGES SET NAME = 'Swedish_Modified_Name' WHERE ID = 2",
      "UPDATE LANGUAGES SET NAME = 'A_very_long_language_name_exceeding_twenty_chars' WHERE ID = 1",
      "UPDATE LANGUAGES SET NAME = 'French' WHERE ID = 4",
      "UPDATE LANGUAGES SET NAME = 'German_New' WHERE ID = 5"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_sync_language_names on the LANGUAGES table that fires when the NAME column changes. Count how many countries use this language. If count > 0: truncate new NAME to 20 characters if longer, and if NAME changed, insert a new language row with ID = :NEW.ID + 1000 and NAME = :OLD.NAME || '_old'.",
    "natural_language": "Make a BEFORE UPDATE trigger trg_sync_language_names for LANGUAGES. On NAME change: count its countries. If any, cap new NAME at 20 chars. If NAME changed, also insert old copy with ID + 1000 and '_old' suffix.",
    "id": 73,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE UPDATE` row-level trigger named `trg_sync_language_names` that is automatically executed before any `UPDATE` operation is performed on a row in the `LANGUAGES` table. This trigger does not accept any explicit parameters. Upon activation for each updated row, it declares three local variables: `v_country_count` of type `NUMBER`, `v_old_name` of type `VARCHAR2(255)`, and `v_new_name` of type `VARCHAR2(255)`. The trigger first checks if the `NAME` column of the row being updated is being changed by comparing the old value (`:OLD.NAME`) and the new value (`:NEW.NAME`). If the values are different, the trigger proceeds with its logic; otherwise, it does nothing. When the name is changed, the trigger executes a `SELECT` statement to count the total number of rows in the `OFFICIAL_LANGUAGES` table and stores this count in the `v_country_count` variable, where the `LANGUAGE_ID` column in the `OFFICIAL_LANGUAGES` table matches the `ID` value of the row currently being updated in the `LANGUAGES` table (referenced as `:OLD.ID`). This count represents the number of countries where this language is official. If `v_country_count` is greater than zero, indicating the language is used in at least one country, the trigger modifies the new name value by applying a cap of 20 characters. Specifically, it sets `:NEW.NAME` to the substring of the original `:NEW.NAME` value, starting from the first character and limited to a maximum length of 20 characters. Regardless of the country count, the trigger then performs an `INSERT` operation into the `LANGUAGES` table. The inserted row uses the following values: the `ID` column is set to the sum of the old `ID` value (`:OLD.ID`) and 1000, the `NAME` column is set to the concatenation of the old `NAME` value (`:OLD.NAME`) and the literal string suffix `'_old'`."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_MANAGEMENT_AGE_VALIDATION that fires automatically before any row is inserted into the MANAGEMENT table, and for each individual row being inserted, the trigger declares a local variable v_head_age of the same data type as the AGE column in the HEAD table, then executes a SELECT statement to query the HEAD table, retrieving the AGE value from the row where the HEAD_ID column matches the new HEAD_ID value being inserted into the MANAGEMENT table (referenced as :NEW.HEAD_ID), and stores that retrieved age into the v_head_age variable, then evaluates a conditional IF statement to check if the value in v_head_age is less than 30, and if this condition is true, the trigger raises a custom application error with error number -20001 and the message 'Head must be at least 30 years old.', which prevents the insertion of the new row into the MANAGEMENT table.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MANAGEMENT_AGE_VALIDATION\nBEFORE INSERT ON MANAGEMENT\nFOR EACH ROW\nDECLARE\n    v_head_age HEAD.AGE%TYPE;\nBEGIN\n    SELECT AGE INTO v_head_age FROM HEAD WHERE HEAD_ID = :NEW.HEAD_ID;\n    IF v_head_age < 30 THEN\n        RAISE_APPLICATION_ERROR(-20001, 'Head must be at least 30 years old.');\n    END IF;\nEND;",
    "database_name": "department_management",
    "tables": [
      "DEPARTMENT",
      "HEAD",
      "MANAGEMENT"
    ],
    "call_sqls": [
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (1, 1, 'No')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (2, 2, 'Yes')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID) VALUES (3, 3)",
      "INSERT INTO MANAGEMENT VALUES (1, 4, 'No')",
      "INSERT INTO MANAGEMENT (DEPARTMENT_ID, HEAD_ID, TEMPORARY_ACTING) VALUES (2, 5, 'Yes')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_MANAGEMENT_AGE_VALIDATION on the MANAGEMENT table. Select the AGE from the HEAD table where HEAD_ID = :NEW.HEAD_ID. If the retrieved age is less than 30, raise application error -20001 with message 'Head must be at least 30 years old.'.",
    "natural_language": "Create trigger TRG_MANAGEMENT_AGE_VALIDATION on MANAGEMENT before insert. Check if HEAD.AGE for the new HEAD_ID is under 30. If so, raise error 'Head must be at least 30 years old.'.",
    "id": 74,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_MANAGEMENT_AGE_VALIDATION that is defined to execute automatically before each row is inserted into the MANAGEMENT table. This trigger operates at the row level. Within the trigger body, it performs a validation check on the age of the head associated with the new management record. Specifically, it queries the HEAD table to retrieve the AGE column value for the row where the HEAD_ID matches the HEAD_ID value from the newly inserted row in the MANAGEMENT table, using the :NEW qualifier to reference this value. The trigger then evaluates if the retrieved age is less than 30. If this condition is true, the trigger raises an application error with the message 'Head must be at least 30 years old.', which prevents the insertion of the new row into the MANAGEMENT table. If the age is 30 or greater, the trigger completes without error, allowing the insert operation to proceed normally."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_architect_update` that is activated `AFTER` an `UPDATE` operation is performed on the `ARCHITECT` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `ARCHITECT` table. Upon activation, the trigger evaluates the `GENDER` column of the newly updated row, referenced as `:NEW.GENDER`.\n\nThe trigger's logic proceeds as follows:\n1. **Conditional Branch 1 (Female Gender):** If the value of `:NEW.GENDER` is exactly equal to the string literal `'female'` (case-sensitive comparison), then an `UPDATE` statement is executed on the `BRIDGE` table. This `UPDATE` statement sets the `NAME` column of the `BRIDGE` table to the string literal `'Updated Bridge'`. The `WHERE` clause of this `UPDATE` statement specifies that only rows in the `BRIDGE` table where the `ARCHITECT_ID` column matches the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`) will be affected.\n\n2. **Conditional Branch 2 (Male Gender):** If the first condition is not met (i.e., `:NEW.GENDER` is not `'female'`), the trigger then checks if the value of `:NEW.GENDER` is exactly equal to the string literal `'male'` (case-sensitive comparison). If this condition is true, then an `UPDATE` statement is executed on the `MILL` table. This `UPDATE` statement sets the `TYPE` column of the `MILL` table to the string literal `'Updated Type'`. The `WHERE` clause of this `UPDATE` statement specifies that only rows in the `MILL` table where the `ARCHITECT_ID` column matches the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`) will be affected.\n\n3. **Conditional Branch 3 (Other Genders):** If neither of the preceding conditions is met (i.e., `:NEW.GENDER` is neither `'female'` nor `'male'`), then an `INSERT` statement is executed to add a new row into the `MILL` table. The values for the columns in the new row are provided as follows:\n    * `ARCHITECT_ID`: Set to the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`).\n    * `ID`: Set to a randomly generated integer value. This value is obtained by calling the `DBMS_RANDOM.VALUE` function, which generates a random number between 1000 (inclusive) and 2000 (exclusive). The `FLOOR` function is then applied to this random number to round it down to the nearest whole integer.\n    * `LOCATION`: Set to the string literal `'Unknown'`.\n    * `NAME`: Set to the string literal `'New Mill'`.\n    * `TYPE`: Set to the string literal `'Type A'`.\n    * `BUILT_YEAR`: Set to the integer literal `2023`.\n    * `NOTES`: Set to the string literal `'Notes'`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_architect_update\nAFTER UPDATE ON ARCHITECT\nFOR EACH ROW\nBEGIN\n  IF :NEW.GENDER = 'female' THEN\n    UPDATE BRIDGE SET NAME = 'Updated Bridge' WHERE ARCHITECT_ID = :NEW.ID;\n  ELSIF :NEW.GENDER = 'male' THEN\n    UPDATE MILL SET TYPE = 'Updated Type' WHERE ARCHITECT_ID = :NEW.ID;\n  ELSE\n    INSERT INTO MILL (ARCHITECT_ID, ID, LOCATION, NAME, TYPE, BUILT_YEAR, NOTES)\n    VALUES (:NEW.ID, FLOOR(DBMS_RANDOM.VALUE(1000, 2000)), 'Unknown', 'New Mill', 'Type A', 2023, 'Notes');\n  END IF;\nEND;",
    "database_name": "architecture",
    "tables": [
      "ARCHITECT",
      "BRIDGE",
      "MILL"
    ],
    "call_sqls": [
      "UPDATE ARCHITECT SET GENDER = 'female' WHERE ID = '1'",
      "UPDATE ARCHITECT SET GENDER = 'male' WHERE ID = '2'",
      "UPDATE ARCHITECT SET GENDER = 'unknown' WHERE ID = '3'",
      "UPDATE ARCHITECT SET GENDER = 'female' WHERE ID = '4'",
      "UPDATE ARCHITECT SET GENDER = 'male' WHERE ID = '5'"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_architect_update on the ARCHITECT table. If :NEW.GENDER is 'female', update the BRIDGE table's NAME to 'Updated Bridge' where ARCHITECT_ID = :NEW.ID. If :NEW.GENDER is 'male', update the MILL table's TYPE to 'Updated Type' where ARCHITECT_ID = :NEW.ID. Otherwise, insert a new row into the MILL table with ARCHITECT_ID = :NEW.ID, a random ID between 1000 and 2000, LOCATION as 'Unknown', NAME as 'New Mill', TYPE as 'Type A', BUILT_YEAR as 2023, and NOTES as 'Notes'.",
    "natural_language": "Alright, so set up a trigger called trg_architect_update on the ARCHITECT table that fires after each row gets updated. Here's the deal: if the new gender is 'female', then go ahead and change the NAME in the BRIDGE table to 'Updated Bridge' for any rows where the ARCHITECT_ID matches the new ID. If the new gender is 'male', then update the TYPE in the MILL table to 'Updated Type' where the ARCHITECT_ID matches. For any other gender, just pop a fresh row into the MILL table. For that new row, use the new ID for ARCHITECT_ID, whip up a random ID between 1000 and 2000, set LOCATION to 'Unknown', NAME to 'New Mill', TYPE to 'Type A', BUILT_YEAR to 2023, and NOTES to 'Notes'.",
    "id": 75,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_architect_update` that is activated `AFTER` an `UPDATE` operation is performed on the `ARCHITECT` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `ARCHITECT` table. Upon activation, the trigger evaluates the `GENDER` column of the newly updated row, referenced as `:NEW.GENDER`.\n\nThe trigger's logic proceeds as follows:\n1. **Conditional Branch 1 (Female Gender):** If the value of `:NEW.GENDER` is exactly equal to the string literal `'female'` (case-sensitive comparison), then an `UPDATE` statement is executed on the `BRIDGE` table. This `UPDATE` statement sets the `NAME` column of the `BRIDGE` table to the string literal `'Updated Bridge'`. The `WHERE` clause of this `UPDATE` statement specifies that only rows in the `BRIDGE` table where the `ARCHITECT_ID` column matches the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`) will be affected.\n\n2. **Conditional Branch 2 (Male Gender):** If the first condition is not met (i.e., `:NEW.GENDER` is not `'female'`), the trigger then checks if the value of `:NEW.GENDER` is exactly equal to the string literal `'male'` (case-sensitive comparison). If this condition is true, then an `UPDATE` statement is executed on the `MILL` table. This `UPDATE` statement sets the `TYPE` column of the `MILL` table to the string literal `'Updated Type'`. The `WHERE` clause of this `UPDATE` statement specifies that only rows in the `MILL` table where the `ARCHITECT_ID` column matches the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`) will be affected.\n\n3. **Conditional Branch 3 (Other Genders):** If neither of the preceding conditions is met (i.e., `:NEW.GENDER` is neither `'female'` nor `'male'`), then an `INSERT` statement is executed to add a new row into the `MILL` table. The values for the columns in the new row are provided as follows:\n    * `ARCHITECT_ID`: Set to the value of the `ID` column from the newly updated `ARCHITECT` row (referenced as `:NEW.ID`).\n    * `ID`: Set to a randomly generated integer value. This value is obtained by calling the `DBMS_RANDOM.VALUE` function, which generates a random number between 1000 (inclusive) and 2000 (exclusive). The `FLOOR` function is then applied to this random number to round it down to the nearest whole integer.\n    * `LOCATION`: Set to the string literal `'Unknown'`.\n    * `NAME`: Set to the string literal `'New Mill'`.\n    * `TYPE`: Set to the string literal `'Type A'`.\n    * `BUILT_YEAR`: Set to the integer literal `2023`.\n    * `NOTES`: Set to the string literal `'Notes'`."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `songs_title_format_trigger` that is configured to execute automatically `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `SONGS` table, and for `EACH ROW` affected by such an operation. This trigger declares a local numeric variable named `v_title_length` to store the length of the song title. Upon activation, the trigger first calculates the length of the `TITLE` column of the row currently being inserted or updated (referred to as `:NEW.TITLE`) using the `LENGTH` SQL function, and assigns this calculated value to the `v_title_length` variable. Subsequently, it evaluates a series of conditional statements based on the value of `v_title_length`. If `v_title_length` is less than 7, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by applying the `INITCAP` SQL function to its current value, which converts the first letter of each word in the title to uppercase and the rest to lowercase. If the first condition is false, the trigger then checks if `v_title_length` is `BETWEEN` 7 and 14 (inclusive). If this condition is true, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by replacing all occurrences of a single space character (' ') with an underscore character ('_') within its current value, using the `REPLACE` SQL function. If both preceding conditions are false, meaning `v_title_length` is greater than 14, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by extracting a substring from its current value, starting from the first character (position 1) and extending for a maximum of 25 characters, using the `SUBSTR` SQL function.",
    "plsql": "CREATE OR REPLACE TRIGGER songs_title_format_trigger\nBEFORE INSERT OR UPDATE ON SONGS\nFOR EACH ROW\nDECLARE\n    v_title_length NUMBER;\nBEGIN\n    v_title_length := LENGTH(:NEW.TITLE);\n    IF v_title_length < 7 THEN\n        :NEW.TITLE := INITCAP(:NEW.TITLE);\n    ELSIF v_title_length BETWEEN 7 AND 14 THEN\n        :NEW.TITLE := REPLACE(:NEW.TITLE, ' ', '_');\n    ELSE\n        :NEW.TITLE := SUBSTR(:NEW.TITLE, 1, 25);\n    END IF;\nEND;",
    "database_name": "music_2",
    "tables": [
      "SONGS"
    ],
    "call_sqls": [
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (1, 'short')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (2, 'medium length')",
      "INSERT INTO SONGS (SONGID, TITLE) VALUES (3, 'This is a very long title that exceeds the limit')",
      "UPDATE SONGS SET TITLE = 'tiny' WHERE SONGID = 1",
      "UPDATE SONGS SET TITLE = 'adequate length' WHERE SONGID = 2"
    ],
    "summary": "Create a trigger named `songs_title_format_trigger` that fires BEFORE INSERT or UPDATE on the `SONGS` table for each row. Based on the length of the new `TITLE`: if less than 7, apply `INITCAP`; if between 7 and 14 inclusive, replace spaces with underscores; if greater than 14, truncate to the first 25 characters.",
    "natural_language": "Set up a trigger called `songs_title_format_trigger` to run before adding or changing records in the `SONGS` table. For each new entry, adjust the `TITLE` in a certain way depending roughly on how long it is: for pretty short titles, make them proper case; for titles of a medium length, swap out spaces with underscores; and for the really long ones, just cut them off after a bunch of characters.",
    "id": 76,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `songs_title_format_trigger` that is configured to execute automatically `BEFORE` any `INSERT` or `UPDATE` operation is performed on the `SONGS` table, and for `EACH ROW` affected by such an operation. This trigger declares a local numeric variable named `v_title_length` to store the length of the song title. Upon activation, the trigger first calculates the length of the `TITLE` column of the row currently being inserted or updated (referred to as `:NEW.TITLE`) using the `LENGTH` SQL function, and assigns this calculated value to the `v_title_length` variable. Subsequently, it evaluates a series of conditional statements based on the value of `v_title_length`. If `v_title_length` is less than 7, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by applying the `INITCAP` SQL function to its current value, which converts the first letter of each word in the title to uppercase and the rest to lowercase. If the first condition is false, the trigger then checks if `v_title_length` is `BETWEEN` 7 and 14 (inclusive). If this condition is true, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by replacing all occurrences of a single space character (' ') with an underscore character ('_') within its current value, using the `REPLACE` SQL function. If both preceding conditions are false, meaning `v_title_length` is greater than 14, the trigger modifies the `TITLE` column of the new or updated row (`:NEW.TITLE`) by extracting a substring from its current value, starting from the first character (position 1) and extending for a maximum of 25 characters, using the `SUBSTR` SQL function."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_CMI_REF_DEL that is defined to execute BEFORE a DELETE operation on the CMI_CROSS_REFERENCES table for each affected row, and within this trigger, first declare three local NUMBER variables named v_benefits_count, v_council_tax_count, and v_rent_arrears_count, then perform a SELECT COUNT(*) query from the BENEFITS_OVERPAYMENTS table into the v_benefits_count variable where the CMI_CROSS_REF_ID column in BENEFITS_OVERPAYMENTS equals the OLD.CMI_CROSS_REF_ID value from the row being deleted from CMI_CROSS_REFERENCES, then perform a second SELECT COUNT(*) query from the COUNCIL_TAX table into the v_council_tax_count variable where the CMI_CROSS_REF_ID column in COUNCIL_TAX equals the OLD.CMI_CROSS_REF_ID value, then perform a third SELECT COUNT(*) query from the RENT_ARREARS table into the v_rent_arrears_count variable where the CMI_CROSS_REF_ID column in RENT_ARREARS equals the OLD.CMI_CROSS_REF_ID value, then execute a DELETE statement on the BENEFITS_OVERPAYMENTS table where the CMI_CROSS_REF_ID column equals the OLD.CMI_CROSS_REF_ID value and the condition v_benefits_count > 0 is true, then execute a DELETE statement on the COUNCIL_TAX table where the CMI_CROSS_REF_ID column equals the OLD.CMI_CROSS_REF_ID value and the condition v_council_tax_count > 0 is true, and finally execute a DELETE statement on the RENT_ARREARS table where the CMI_CROSS_REF_ID column equals the OLD.CMI_CROSS_REF_ID value and the condition v_rent_arrears_count > 0 is true.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_CMI_REF_DEL\nBEFORE DELETE ON CMI_CROSS_REFERENCES\nFOR EACH ROW\nDECLARE\n    v_benefits_count NUMBER;\n    v_council_tax_count NUMBER;\n    v_rent_arrears_count NUMBER;\nBEGIN\n    SELECT COUNT(*)\n    INTO v_benefits_count\n    FROM BENEFITS_OVERPAYMENTS\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n\n    SELECT COUNT(*)\n    INTO v_council_tax_count\n    FROM COUNCIL_TAX\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n\n    SELECT COUNT(*)\n    INTO v_rent_arrears_count\n    FROM RENT_ARREARS\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID;\n\n    DELETE FROM BENEFITS_OVERPAYMENTS\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID\n    AND v_benefits_count > 0;\n\n    DELETE FROM COUNCIL_TAX\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID\n    AND v_council_tax_count > 0;\n\n    DELETE FROM RENT_ARREARS\n    WHERE CMI_CROSS_REF_ID = :OLD.CMI_CROSS_REF_ID\n    AND v_rent_arrears_count > 0;\nEND;",
    "database_name": "local_govt_mdm",
    "tables": [
      "BENEFITS_OVERPAYMENTS",
      "COUNCIL_TAX",
      "CMI_CROSS_REFERENCES",
      "CUSTOMER_MASTER_INDEX",
      "RENT_ARREARS"
    ],
    "call_sqls": [
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 2",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 65",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 41",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 83",
      "DELETE FROM CMI_CROSS_REFERENCES WHERE CMI_CROSS_REF_ID = 100"
    ],
    "summary": "Create a BEFORE DELETE trigger named TRG_CMI_REF_DEL on the CMI_CROSS_REFERENCES table. For each row, count related records in BENEFITS_OVERPAYMENTS, COUNCIL_TAX, and RENT_ARREARS tables using :OLD.CMI_CROSS_REF_ID. Store counts in variables. Then, conditionally delete from each of those three tables where CMI_CROSS_REF_ID equals :OLD.CMI_CROSS_REF_ID, but only if its corresponding count variable is greater than 0.",
    "natural_language": "Alright, so we need a trigger called TRG_CMI_REF_DEL that fires before a row gets deleted from the CMI_CROSS_REFERENCES table. For each old row, we gotta check how many related records there are in the BENEFITS_OVERPAYMENTS, COUNCIL_TAX, and RENT_ARREARS tables using the old row's CMI_CROSS_REF_ID. We'll stash those counts in some variables. Then, only if a count for a specific table is more than zero, we go ahead and delete the matching records from that table where the CMI_CROSS_REF_ID matches the old one.",
    "id": 77,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_CMI_REF_DEL that is defined to execute before a DELETE operation on the CMI_CROSS_REFERENCES table, operating at the row level for each individual row that is deleted, which first declares three local variables: v_benefits_count of type NUMBER to store the count of related records in the BENEFITS_OVERPAYMENTS table, v_council_tax_count of type NUMBER to store the count of related records in the COUNCIL_TAX table, and v_rent_arrears_count of type NUMBER to store the count of related records in the RENT_ARREARS table. The trigger then performs three separate SELECT statements, each using the COUNT aggregate function. The first SELECT statement queries the BENEFITS_OVERPAYMENTS table to count the number of rows where the CMI_CROSS_REF_ID column matches the CMI_CROSS_REF_ID value of the row being deleted from the CMI_CROSS_REFERENCES table, referenced via the :OLD pseudorecord, and stores the result into the v_benefits_count variable. The second SELECT statement queries the COUNCIL_TAX table to count the number of rows where the CMI_CROSS_REF_ID column matches the :OLD.CMI_CROSS_REF_ID value and stores the result into the v_council_tax_count variable. The third SELECT statement queries the RENT_ARREARS table to count the number of rows where the CMI_CROSS_REF_ID column matches the :OLD.CMI_CROSS_REF_ID value and stores the result into the v_rent_arrears_count variable. Following these counts, the trigger implements conditional logic using IF statements. If the value of v_benefits_count is greater than zero, it executes a DELETE operation on the BENEFITS_OVERPAYMENTS table, removing all rows where the CMI_CROSS_REF_ID column equals the :OLD.CMI_CROSS_REF_ID value. If the value of v_council_tax_count is greater than zero, it executes a DELETE operation on the COUNCIL_TAX table, removing all rows where the CMI_CROSS_REF_ID column equals the :OLD.CMI_CROSS_REF_ID value. If the value of v_rent_arrears_count is greater than zero, it executes a DELETE operation on the RENT_ARREARS table, removing all rows where the CMI_CROSS_REF_ID column equals the :OLD.CMI_CROSS_REF_ID value. The trigger performs these operations within the local_govt_mdm database."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_order_status that is defined to fire automatically after any update operation on the ORDER_STATUS_CODE column of the CUSTOMER_ORDERS table, executing once for each row that is modified; within the trigger body, a conditional IF-THEN-ELSE statement evaluates the newly updated value of the ORDER_STATUS_CODE column, referenced as :NEW.ORDER_STATUS_CODE, and if this value is exactly equal to the string literal 'Completed', it executes an UPDATE statement on the ORDER_ITEMS table, setting the PRODUCT_ID column to the numeric value 0 for every row in ORDER_ITEMS where the ORDER_ID column matches the new ORDER_ID value from the updated CUSTOMER_ORDERS row, referenced as :NEW.ORDER_ID; conversely, if the :NEW.ORDER_STATUS_CODE is not equal to 'Completed', the trigger executes a DELETE statement on the ORDER_ITEMS table, removing all rows where the ORDER_ID column equals :NEW.ORDER_ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_order_status\nAFTER UPDATE OF ORDER_STATUS_CODE ON CUSTOMER_ORDERS\nFOR EACH ROW\nBEGIN\n    IF :NEW.ORDER_STATUS_CODE = 'Completed' THEN\n        UPDATE ORDER_ITEMS SET PRODUCT_ID = 0 WHERE ORDER_ID = :NEW.ORDER_ID;\n    ELSE\n        DELETE FROM ORDER_ITEMS WHERE ORDER_ID = :NEW.ORDER_ID;\n    END IF;\nEND;",
    "database_name": "department_store",
    "tables": [
      "CUSTOMER_ORDERS",
      "ORDER_ITEMS",
      "PRODUCT_SUPPLIERS",
      "SUPPLIERS",
      "SUPPLIER_ADDRESSES"
    ],
    "call_sqls": [
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'Completed' WHERE ORDER_ID = 1",
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'New' WHERE ORDER_ID = 2",
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'PartFilled' WHERE ORDER_ID = 3",
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'Completed' WHERE ORDER_ID = 4",
      "UPDATE CUSTOMER_ORDERS SET ORDER_STATUS_CODE = 'New' WHERE ORDER_ID = 5"
    ],
    "summary": "Create an AFTER UPDATE row trigger named trg_update_order_status on the CUSTOMER_ORDERS table that fires when ORDER_STATUS_CODE is updated. If :NEW.ORDER_STATUS_CODE equals 'Completed', update the ORDER_ITEMS table, setting PRODUCT_ID to 0 for all items matching :NEW.ORDER_ID. Otherwise, if the status is not 'Completed', delete all items from ORDER_ITEMS matching :NEW.ORDER_ID.",
    "natural_language": "Create trigger trg_update_order_status on CUSTOMER_ORDERS after update of ORDER_STATUS_CODE. If new status is 'Completed', set PRODUCT_ID to 0 in ORDER_ITEMS for that order. Otherwise, delete the order's items.",
    "id": 78,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_update_order_status that is defined to fire automatically after any update operation on the ORDER_STATUS_CODE column of the CUSTOMER_ORDERS table, executing once for each row that is modified; within the trigger body, a conditional IF-THEN-ELSE statement evaluates the newly updated value of the ORDER_STATUS_CODE column, referenced as :NEW.ORDER_STATUS_CODE, and if this value is exactly equal to the string literal 'Completed', it executes an UPDATE statement on the ORDER_ITEMS table, setting the PRODUCT_ID column to the numeric value 0 for every row in ORDER_ITEMS where the ORDER_ID column matches the new ORDER_ID value from the updated CUSTOMER_ORDERS row, referenced as :NEW.ORDER_ID; conversely, if the :NEW.ORDER_STATUS_CODE is not equal to 'Completed', the trigger executes a DELETE statement on the ORDER_ITEMS table, removing all rows where the ORDER_ID column equals :NEW.ORDER_ID."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named update_book_pages_trg that is automatically executed after any row in the REVIEW table is updated, but only when the specific column RATING is modified. For each individual REVIEW row affected by such an update, the trigger performs an UPDATE operation on the BOOK table. This update increases the value in the PAGES column of the BOOK table by exactly 10 for the single BOOK row where the BOOK_ID column value matches the new BOOK_ID value from the updated REVIEW row, which is accessed via the :NEW.BOOK_ID bind variable.",
    "plsql": "CREATE OR REPLACE TRIGGER update_book_pages_trg\nAFTER UPDATE OF RATING ON REVIEW\nFOR EACH ROW\nBEGIN\n    UPDATE BOOK\n    SET PAGES = PAGES + 10\n    WHERE BOOK_ID = :NEW.BOOK_ID;\nEND;",
    "database_name": "book_review",
    "tables": [
      "BOOK",
      "REVIEW"
    ],
    "call_sqls": [
      "UPDATE REVIEW SET RATING = 7.5 WHERE BOOK_ID = 1",
      "UPDATE REVIEW SET RATING = 8.2 WHERE REVIEW_ID = 2",
      "UPDATE REVIEW SET RATING = RATING + 1 WHERE BOOK_ID = 3",
      "UPDATE REVIEW SET RATING = 9.0, READERS_IN_MILLION = 3.5 WHERE BOOK_ID = 2",
      "UPDATE REVIEW SET RATING = 4.5 WHERE BOOK_ID = 4"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named update_book_pages_trg on the REVIEW table when RATING is updated. Update the BOOK table, increasing PAGES by 10 where BOOK_ID = NEW.BOOK_ID.",
    "natural_language": "When the RATING in the REVIEW table is updated, what trigger should be created to increase the PAGES by 10 in the BOOK table for the corresponding BOOK_ID?",
    "id": 79,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `update_book_pages_trg` that is defined to execute automatically after an `UPDATE` operation is performed on the `REVIEW` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every row that is updated in the `REVIEW` table. The purpose of this trigger is to modify the `PAGES` column in the `BOOK` table whenever the `RATING` column of a corresponding record in the `REVIEW` table is updated. Specifically, for each updated row in the `REVIEW` table, the trigger performs the following operations: it checks if the `RATING` column has been changed by comparing the old value (`:OLD.RATING`) and the new value (`:NEW.RATING`). If the `RATING` has been updated (i.e., `:OLD.RATING` is not equal to `:NEW.RATING`), then the trigger executes an `UPDATE` statement on the `BOOK` table. This `UPDATE` statement targets the row in the `BOOK` table where the `BOOK_ID` column matches the `BOOK_ID` value from the updated `REVIEW` row (`:NEW.BOOK_ID`). The `UPDATE` operation increases the current value of the `PAGES` column by 10, setting `PAGES` to `PAGES + 10`. The trigger uses the `:NEW` pseudorecord to access the column values of the `REVIEW` row after the update, and the `:OLD` pseudorecord to access the column values before the update. The condition ensures that the `PAGES` increment only occurs when the `RATING` is actually modified, not for other updates to the `REVIEW` table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_people that is executed automatically after a new row is inserted into the PEOPLE table. This trigger operates for each row that is inserted. Within the trigger's body, an INSERT operation is performed on the CHURCH table, adding a new row with specific values. The CHURCH_ID column is set to the value of the PEOPLE_ID column from the newly inserted row in the PEOPLE table, accessed using the :NEW pseudorecord. The NAME column is assigned the string 'New Church'. The ORGANIZED_BY column is given the value 'Unknown'. The OPEN_DATE column is set to the current year, extracted from the system's current date using the EXTRACT function with the YEAR parameter. The CONTINUATION_OF column is assigned the string 'None'. This trigger ensures that every time a new person is added to the PEOPLE table, a corresponding entry is automatically created in the CHURCH table with predefined values.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_people\nAFTER INSERT ON PEOPLE\nFOR EACH ROW\nBEGIN\n  INSERT INTO CHURCH (CHURCH_ID, NAME, ORGANIZED_BY, OPEN_DATE, CONTINUATION_OF)\n  VALUES (:NEW.PEOPLE_ID, 'New Church', 'Unknown', EXTRACT(YEAR FROM CURRENT_DATE), 'None');\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (10, 'John Doe', 'USA', 'T', 30)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (11, 'Jane Smith', 'Canada', 'F', 25)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (12, 'Peter Jones', 'UK', 'T', 45)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (13, 'Alice Brown', 'Australia', 'F', 38)",
      "INSERT INTO PEOPLE (PEOPLE_ID, NAME, COUNTRY, IS_MALE, AGE) VALUES (14, 'Bob White', 'Germany', 'T', 50)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_people on the PEOPLE table. For each new row, insert a record into the CHURCH table. Set CHURCH_ID to :NEW.PEOPLE_ID, NAME to 'New Church', ORGANIZED_BY to 'Unknown', OPEN_DATE to the current year, and CONTINUATION_OF to 'None'.",
    "natural_language": "Construct a detailed AFTER INSERT row-level trigger, which should be named trg_insert_people, specifically for the PEOPLE table. For every single new row that is successfully added, you must meticulously insert a corresponding new record directly into the CHURCH table. In this new church record, carefully assign the CHURCH_ID to precisely match the :NEW.PEOPLE_ID value, set the NAME field to the literal string 'New Church', define the ORGANIZED_BY field as 'Unknown', populate the OPEN_DATE with the exact current year, and finally, ensure the CONTINUATION_OF field is explicitly set to 'None'.",
    "id": 80,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_insert_people that is executed automatically after a new row is inserted into the PEOPLE table. This trigger operates for each row that is inserted. Within the trigger's body, an INSERT operation is performed on the CHURCH table, adding a new row with specific values. The CHURCH_ID column is set to the value of the PEOPLE_ID column from the newly inserted row in the PEOPLE table, accessed using the :NEW pseudorecord. The NAME column is assigned the string 'New Church'. The ORGANIZED_BY column is given the value 'Unknown'. The OPEN_DATE column is set to the current year, extracted from the system's current date using the EXTRACT function with the YEAR parameter. The CONTINUATION_OF column is assigned the string 'None'. This trigger ensures that every time a new person is added to the PEOPLE table, a corresponding entry is automatically created in the CHURCH table with predefined values."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_party_address that is executed after an update operation on the PARTY_ADDRESSES table for each row affected by the update. The trigger performs a delete operation on the ADDRESSES table, specifically removing the row where the ADDRESS_ID column matches the value of the ADDRESS_ID column in the newly updated row of the PARTY_ADDRESSES table. The trigger uses the :NEW pseudorecord to access the value of the ADDRESS_ID from the updated row in the PARTY_ADDRESSES table. There are no conditional statements or function calls involved in this trigger; it simply deletes the corresponding address record based on the updated address ID.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_party_address\nAFTER UPDATE ON PARTY_ADDRESSES\nFOR EACH ROW\nBEGIN\n  DELETE FROM ADDRESSES WHERE ADDRESS_ID = :NEW.ADDRESS_ID;\nEND;",
    "database_name": "e_government",
    "tables": [
      "PARTIES",
      "ADDRESSES",
      "PARTY_ADDRESSES",
      "PARTY_FORMS"
    ],
    "call_sqls": [
      "UPDATE PARTY_ADDRESSES SET DATE_ADDRESS_TO = '2023-01-01 00:00:00' WHERE PARTY_ID = 10 AND ADDRESS_ID = 8",
      "UPDATE PARTY_ADDRESSES SET ADDRESS_TYPE_CODE = 'Archived' WHERE PARTY_ID = 15 AND ADDRESS_ID = 5",
      "UPDATE PARTY_ADDRESSES SET DATE_ADDRESS_FROM = '2010-01-01 00:00:00' WHERE PARTY_ID = 4 AND ADDRESS_ID = 4",
      "UPDATE PARTY_ADDRESSES SET DATE_ADDRESS_TO = '2024-01-01 00:00:00' WHERE PARTY_ID = 10 AND ADDRESS_ID = 8",
      "UPDATE PARTY_ADDRESSES SET ADDRESS_TYPE_CODE = 'Previous' WHERE PARTY_ID = 15 AND ADDRESS_ID = 5"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_party_address on the PARTY_ADDRESSES table. For each updated row, delete from the ADDRESSES table where ADDRESS_ID equals the new ADDRESS_ID from the updated row.",
    "natural_language": "Construct a detailed AFTER UPDATE FOR EACH ROW trigger, which should be named trg_update_party_address, specifically for the PARTY_ADDRESSES table. For every individual row that is updated, this trigger must meticulously execute a deletion from the ADDRESSES table, targeting precisely those records where the ADDRESS_ID matches the new ADDRESS_ID value originating from the recently updated row.",
    "id": 81,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_update_party_address` that is activated `AFTER` an `UPDATE` operation occurs on the `PARTY_ADDRESSES` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every individual row that is updated within the `PARTY_ADDRESSES` table. Upon activation, for each updated row in `PARTY_ADDRESSES`, the trigger performs a `DELETE` operation on the `ADDRESSES` table. Specifically, it deletes a single row from the `ADDRESSES` table where the `ADDRESS_ID` column value matches the new `ADDRESS_ID` value from the updated row in `PARTY_ADDRESSES`. The new `ADDRESS_ID` value is accessed using the `:NEW.ADDRESS_ID` reference, which points to the value of the `ADDRESS_ID` column in the row after the update operation has been applied to the `PARTY_ADDRESSES` table. The trigger operates within the `e_government` database and is associated with the `PARTY_ADDRESSES` table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_insert_staff that is defined to execute automatically after a new row is successfully inserted into the STAFF table, and it executes once for each individual row that is inserted; the trigger performs a single operation, which is to insert a new record into the CONFERENCE_PARTICIPATION table; for this insertion, the trigger uses the literal constant value 1 for the CONFERENCE_ID column, uses the newly inserted STAFF_ID value from the :NEW pseudorecord for the STAFF_ID column, and uses the literal string constant 'Participant' for the ROLE column.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_insert_staff\nAFTER INSERT ON STAFF\nFOR EACH ROW\nBEGIN\n  INSERT INTO CONFERENCE_PARTICIPATION (CONFERENCE_ID, STAFF_ID, ROLE)\n  VALUES (1, :NEW.STAFF_ID, 'Participant');\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (1, 'Bobby Jackson', 24, 'United States', 1)",
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (2, 'Casey Jacobsen', 23, 'United Kindom', 2)",
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (3, 'Alexander Johnson', 42, 'United States', 3)",
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (4, 'Jane Doe', 30, 'Canada', 1)",
      "INSERT INTO STAFF (STAFF_ID, NAME, AGE, NATIONALITY, INSTITUTION_ID) VALUES (5, 'John Smith', 50, 'Australia', 2)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_insert_staff on the STAFF table. For each new staff row, insert a record into CONFERENCE_PARTICIPATION with CONFERENCE_ID=1, STAFF_ID from the new staff, and ROLE='Participant'.",
    "natural_language": "How can I create an AFTER INSERT row-level trigger called trg_insert_staff on the STAFF table so that for each new staff member added, a record is inserted into the CONFERENCE_PARTICIPATION table with CONFERENCE_ID set to 1, STAFF_ID taken from the new staff row, and ROLE set to 'Participant'?",
    "id": 82,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_insert_staff` that is activated `AFTER` an `INSERT` operation on the `STAFF` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for each new row inserted into the `STAFF` table.\n\nUpon activation, the trigger does not declare any local variables. It directly executes an `INSERT` statement into the `CONFERENCE_PARTICIPATION` table. The `INSERT` statement specifies three columns to be populated: `CONFERENCE_ID`, `STAFF_ID`, and `ROLE`. The value for the `CONFERENCE_ID` column is set to the literal number `1`. The value for the `STAFF_ID` column is taken from the `STAFF_ID` column of the newly inserted row in the `STAFF` table, referenced as `:NEW.STAFF_ID`. The value for the `ROLE` column is set to the literal string `'Participant'`. This operation ensures that for every new staff member added to the `STAFF` table, a corresponding participation record is automatically created in the `CONFERENCE_PARTICIPATION` table, linking them to the conference with `CONFERENCE_ID` equal to `1` and assigning them the role of `'Participant'`."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_adjust_capacity_on_delete that is defined to execute automatically after a row is deleted from the WAREHOUSES table, operating for each affected row, and within its body, it performs a delete operation on the BOXES table where the WAREHOUSE column value matches the CODE column value from the deleted WAREHOUSES row, which is accessed via the :OLD.CODE pseudorecord qualifier, and the trigger's logic originally contained an additional insert operation that was commented out, which attempted to insert a new row into the WAREHOUSES table using values derived from the deleted row, specifically adding 100 to the old CODE, and using the old LOCATION and CAPACITY values, but this insert statement was removed to prevent a mutating table error.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_adjust_capacity_on_delete\nAFTER DELETE ON WAREHOUSES\nFOR EACH ROW\nBEGIN\n    -- This DELETE statement is fine as it operates on a different table (BOXES).\n    DELETE FROM BOXES WHERE WAREHOUSE = :OLD.CODE;\n    -- The following INSERT statement caused the ORA-04091 mutating table error\n    -- because it attempts to modify the WAREHOUSES table (the triggering table)\n    -- within a row-level trigger on WAREHOUSES.\n    -- INSERT INTO WAREHOUSES (CODE, LOCATION, CAPACITY) VALUES (:OLD.CODE + 100, :OLD.LOCATION, :OLD.CAPACITY);\n    -- Removed the problematic INSERT statement to resolve the mutating table error.\nEND;",
    "database_name": "warehouse_1",
    "tables": [
      "BOXES",
      "WAREHOUSES"
    ],
    "call_sqls": [
      "DELETE FROM WAREHOUSES WHERE CODE = 1",
      "DELETE FROM WAREHOUSES WHERE CODE = 3",
      "DELETE FROM WAREHOUSES WHERE CODE = 2",
      "DELETE FROM WAREHOUSES WHERE CODE = 4",
      "DELETE FROM WAREHOUSES WHERE CODE = 5"
    ],
    "summary": "Create an AFTER DELETE trigger named trg_adjust_capacity_on_delete on the WAREHOUSES table. For each deleted row, delete rows from the BOXES table where the WAREHOUSE column equals the deleted row's :OLD.CODE value.",
    "natural_language": "Please implement an AFTER DELETE trigger designated as trg_adjust_capacity_on_delete on the WAREHOUSES table. This trigger shall, for each row that is deleted, proceed to delete corresponding rows from the BOXES table where the value in the WAREHOUSE column matches the :OLD.CODE value from the deleted row.",
    "id": 83,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_adjust_capacity_on_delete that is executed automatically after a row is deleted from the WAREHOUSES table. This trigger operates for each row that is deleted. The WAREHOUSES table has columns CODE, LOCATION, and CAPACITY, where CODE is the primary key. The BOXES table has columns CODE, CONTENTS, VALUE, and WAREHOUSE, where WAREHOUSE is a foreign key referencing WAREHOUSES.CODE. When a row is deleted from the WAREHOUSES table, the trigger performs a DELETE operation on the BOXES table. The deletion targets all rows in the BOXES table where the WAREHOUSE column value equals the CODE value of the deleted row from the WAREHOUSES table, accessed using the :OLD pseudo-record, which refers to the row before deletion. This ensures referential integrity by removing all boxes associated with the deleted warehouse. There are no conditional statements, calculations, or additional operations; the trigger executes the DELETE unconditionally after each deletion from the WAREHOUSES table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_actor_update that is defined to fire automatically after each row is updated on the ACTOR table, and within its declarative section it declares a local variable v_new_musical_id of type NUMBER; the trigger's execution block first checks a condition on the updated row's new AGE value, and if that AGE is greater than 30, it performs an update on the MUSICAL table, setting the RESULT column to the string 'Legendary' specifically for the row where the MUSICAL_ID column matches the new MUSICAL_ID value from the updated ACTOR row; if the AGE is not greater than 30 (i.e., 30 or less), it instead performs a delete operation on the MUSICAL table, removing the row where the MUSICAL_ID column matches the new MUSICAL_ID value from the updated ACTOR row; following this conditional logic, the trigger executes a SELECT statement that retrieves the maximum value from the MUSICAL_ID column in the MUSICAL table, adds 1 to it, and stores the result into the local variable v_new_musical_id; finally, the trigger performs an INSERT operation into the MUSICAL table, creating a new row with the following column values: the MUSICAL_ID column is set to the calculated v_new_musical_id, the NAME column is set to the string 'Future Musical', the YEAR column is set to the number 2025, the AWARD column is set to the string 'Future Award', the CATEGORY column is set to the string 'Future Category', the NOMINEE column is set to the string 'Future Nominee', and the RESULT column is set to the string 'Pending'.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_actor_update\nAFTER UPDATE ON ACTOR\nFOR EACH ROW\nDECLARE\n  v_new_musical_id NUMBER;\nBEGIN\n  IF :NEW.AGE > 30 THEN\n    UPDATE MUSICAL SET RESULT = 'Legendary' WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n  ELSE\n    DELETE FROM MUSICAL WHERE MUSICAL_ID = :NEW.MUSICAL_ID;\n  END IF;\n\n  SELECT MAX(MUSICAL_ID) + 1 INTO v_new_musical_id FROM MUSICAL;\n  \n  INSERT INTO MUSICAL (MUSICAL_ID, NAME, YEAR, AWARD, CATEGORY, NOMINEE, RESULT)\n  VALUES (v_new_musical_id, 'Future Musical', 2025, 'Future Award', 'Future Category', 'Future Nominee', 'Pending');\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "UPDATE ACTOR SET AGE = 31 WHERE ACTOR_ID = 1",
      "UPDATE ACTOR SET AGE = 32 WHERE ACTOR_ID = 2",
      "UPDATE ACTOR SET AGE = 33 WHERE ACTOR_ID = 3",
      "UPDATE ACTOR SET AGE = 25 WHERE ACTOR_ID = 1",
      "UPDATE ACTOR SET AGE = 29 WHERE ACTOR_ID = 2"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_actor_update on the ACTOR table. For each updated row: if the new AGE > 30, update the MUSICAL table's RESULT to 'Legendary' where MUSICAL_ID matches the new MUSICAL_ID; otherwise, delete that MUSICAL row. Then, insert a new row into MUSICAL with an auto-incremented MUSICAL_ID and preset values ('Future Musical', 2025, 'Future Award', 'Future Category', 'Future Nominee', 'Pending').",
    "natural_language": "Create trigger trg_actor_update on ACTOR. After updating a row: if new AGE > 30, set MUSICAL.RESULT to 'Legendary' for matching MUSICAL_ID; else delete that MUSICAL row. Then insert a new MUSICAL row with auto-incremented ID and preset values.",
    "id": 84,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_actor_update` that is activated `AFTER` an `UPDATE` operation occurs on the `ACTOR` table. This trigger is a `FOR EACH ROW` trigger, meaning it executes once for every row that is updated in the `ACTOR` table. Upon activation, the trigger evaluates a conditional statement based on the `AGE` column of the newly updated row, referenced as `:NEW.AGE`.\n\nThe first condition checks `IF :NEW.AGE > 30`. If this condition is true, the trigger executes an `UPDATE` statement on the `MUSICAL` table. This `UPDATE` statement sets the `RESULT` column to the string literal `'Legendary'`. This `UPDATE` operation on the `MUSICAL` table is applied only to the row where the `MUSICAL_ID` in the `MUSICAL` table matches the `:NEW.MUSICAL_ID` from the updated `ACTOR` row.\n\nIf the condition `:NEW.AGE > 30` is false, the trigger executes the `ELSE` block. This block contains a `DELETE` statement on the `MUSICAL` table. This `DELETE` operation removes the row from the `MUSICAL` table where the `MUSICAL_ID` in the `MUSICAL` table matches the `:NEW.MUSICAL_ID` from the updated `ACTOR` row.\n\nFollowing the conditional logic, regardless of which branch was taken, the trigger then executes an `INSERT` statement into the `MUSICAL` table. This `INSERT` statement creates a new row with the following column values:\n1.  `MUSICAL_ID` is set to a new, auto-incremented value. This is achieved by performing a `SELECT` query to find the maximum current `MUSICAL_ID` value from the `MUSICAL` table and then adding `1` to that value.\n2.  `NAME` is set to the string literal `'New Production'`.\n3.  `YEAR` is set to the current year, extracted from the system date (`SYSDATE`) using the `EXTRACT(YEAR FROM SYSDATE)` function.\n4.  `AWARD` is set to the string literal `'Pending'`.\n5.  `CATEGORY` is set to the string literal `'Uncategorized'`.\n6.  `NOMINEE` is set to the string literal `'TBD'`.\n7.  `RESULT` is set to the string literal `'Not Announced'`.\n\nThe trigger then concludes its execution for the current row."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_maintain_college_consistency` that is activated `BEFORE` any `DELETE` operation is performed on the `COLLEGE` table. This trigger is configured to execute `FOR EACH ROW` that is being deleted from the `COLLEGE` table. Upon activation, the trigger executes a `BEGIN` block containing two sequential `DELETE` statements. The `FIRST` operation is a `DELETE` statement targeting records in the `ROUND` table. This `DELETE` statement removes rows from the `ROUND` table where the `MEMBER_ID` column's value is present `IN` the result set of a subquery. The subquery `SELECT`s the `MEMBER_ID` column from the `MEMBER` table, filtering these `MEMBER` records where the `COLLEGE_ID` column matches the `COLLEGE_ID` of the `OLD` record (the record currently being deleted) from the `COLLEGE` table. This effectively deletes all `ROUND` records associated with members belonging to the college being deleted. The `THEN` `SECOND` operation is another `DELETE` statement, this time targeting records in the `MEMBER` table. This `DELETE` statement removes rows from the `MEMBER` table where the `COLLEGE_ID` column matches the `COLLEGE_ID` of the `OLD` record (the record currently being deleted) from the `COLLEGE` table. This effectively deletes all `MEMBER` records associated with the college being deleted. The trigger concludes its execution after these two `DELETE` operations.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_college_consistency\nBEFORE DELETE ON COLLEGE\nFOR EACH ROW\nBEGIN\n    -- First, delete dependent records from ROUND table\n    DELETE FROM ROUND\n    WHERE MEMBER_ID IN (SELECT MEMBER_ID FROM MEMBER WHERE COLLEGE_ID = :OLD.COLLEGE_ID);\n\n    -- Then, delete dependent records from MEMBER table\n    DELETE FROM MEMBER WHERE COLLEGE_ID = :OLD.COLLEGE_ID;\nEND;",
    "database_name": "decoration_competition",
    "tables": [
      "COLLEGE",
      "MEMBER",
      "ROUND"
    ],
    "call_sqls": [
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 1",
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 2",
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 3",
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 4",
      "DELETE FROM COLLEGE WHERE COLLEGE_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named trg_maintain_college_consistency on the COLLEGE table. When a college is deleted, first delete all ROUND records for members belonging to that college, then delete all MEMBER records for that college.",
    "natural_language": "Set up a trigger on the COLLEGE table that runs before deletions. When a college gets removed, it should first clear out the round records for people from that college, and then also get rid of the member entries for that college. Make sure the trigger handles this cleanup properly.",
    "id": 85,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_maintain_college_consistency` that is activated `BEFORE` a `DELETE` operation occurs on the `COLLEGE` table. This trigger executes `FOR EACH ROW` being deleted from the `COLLEGE` table. The trigger does not declare any local variables. The `BEGIN` block initiates by performing a `DELETE` operation on the `ROUND` table. This deletion uses a subquery in the `WHERE` clause to identify which rows to remove. The subquery selects the `MEMBER_ID` column from the `MEMBER` table where the `COLLEGE_ID` column matches the `COLLEGE_ID` of the college row being deleted, referenced as `:OLD.COLLEGE_ID`. The outer `DELETE` statement then removes all rows from the `ROUND` table where the `MEMBER_ID` column value is in the result set of this subquery. Following this, the trigger performs a second `DELETE` operation directly on the `MEMBER` table. This deletion is filtered by a `WHERE` clause that matches the `COLLEGE_ID` column in the `MEMBER` table with the `COLLEGE_ID` of the college row being deleted (`:OLD.COLLEGE_ID`). The purpose of these sequential deletions is to maintain referential integrity by first removing all dependent `ROUND` records associated with members of the college, and then removing the `MEMBER` records themselves, before the original `COLLEGE` row is deleted. The trigger does not contain an explicit `EXCEPTION` handling block."
  },
  {
    "ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_problem_report_insert` that automatically executes before a new row is inserted into the `PROBLEMS` table. This trigger declares two local `VARCHAR2` variables: `v_reporter_name` and `v_product_name`, both capable of storing up to 255 characters. The trigger first retrieves the full name of the staff member who reported the problem by concatenating the `STAFF_FIRST_NAME` and `STAFF_LAST_NAME` columns from the `STAFF` table, where the `STAFF_ID` in the `STAFF` table matches the `REPORTED_BY_STAFF_ID` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.REPORTED_BY_STAFF_ID`), and stores this concatenated name into the `v_reporter_name` variable. Next, it retrieves the `PRODUCT_NAME` from the `PRODUCT` table, where the `PRODUCT_ID` in the `PRODUCT` table matches the `PRODUCT_ID` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.PRODUCT_ID`), and stores this product name into the `v_product_name` variable. Following these retrievals, the trigger evaluates a conditional statement: if the `DATE_PROBLEM_REPORTED` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.DATE_PROBLEM_REPORTED`) is not null, then it proceeds to insert a new record into the `PROBLEM_LOG` table. For this insertion, the `PROBLEM_LOG_ID` column is populated by selecting the maximum existing `PROBLEM_LOG_ID` from the `PROBLEM_LOG` table, using `COALESCE` to default to 0 if no records exist, and then adding 1 to that value. The `PROBLEM_ID` column is populated with the `PROBLEM_ID` from the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.PROBLEM_ID`). The `PROBLEM_STATUS_CODE` column is set to the literal string 'Reported'. The `LOG_ENTRY_DATE` column is populated with the `DATE_PROBLEM_REPORTED` from the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.DATE_PROBLEM_REPORTED`). Finally, the `LOG_ENTRY_DESCRIPTION` column is populated with a concatenated string formed by the literal 'Problem reported by ', followed by the value of the `v_reporter_name` variable, followed by the literal ' for product ', and then followed by the value of the `v_product_name` variable.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_problem_report_insert\nBEFORE INSERT ON PROBLEMS\nFOR EACH ROW\nDECLARE\n    v_reporter_name VARCHAR2(255);\n    v_product_name VARCHAR2(255);\nBEGIN\n    SELECT STAFF_FIRST_NAME || ' ' || STAFF_LAST_NAME INTO v_reporter_name\n    FROM STAFF\n    WHERE STAFF_ID = :NEW.REPORTED_BY_STAFF_ID;\n\n    SELECT PRODUCT_NAME INTO v_product_name\n    FROM PRODUCT\n    WHERE PRODUCT_ID = :NEW.PRODUCT_ID;\n\n    IF :NEW.DATE_PROBLEM_REPORTED IS NOT NULL THEN\n        INSERT INTO PROBLEM_LOG (\n            PROBLEM_LOG_ID,\n            PROBLEM_ID,\n            PROBLEM_STATUS_CODE,\n            LOG_ENTRY_DATE,\n            LOG_ENTRY_DESCRIPTION\n        ) VALUES (\n            (SELECT COALESCE(MAX(PROBLEM_LOG_ID), 0) + 1 FROM PROBLEM_LOG),\n            :NEW.PROBLEM_ID,\n            'Reported',\n            :NEW.DATE_PROBLEM_REPORTED,\n            'Problem reported by ' || v_reporter_name || ' for product ' || v_product_name\n        );\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_LOG",
      "PROBLEM_STATUS_CODES",
      "PRODUCT",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (1, 1, 1, '2023-01-15 10:00:00', 'Login issue')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (2, 2, 2, '2023-01-16 11:30:00', 'Payment gateway error')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (3, 3, 3, '2023-01-17 14:00:00', 'Broken link on homepage')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (4, 1, 2, '2023-01-18 09:15:00', 'Slow loading times')",
      "INSERT INTO PROBLEMS (PROBLEM_ID, PRODUCT_ID, REPORTED_BY_STAFF_ID, DATE_PROBLEM_REPORTED, PROBLEM_DESCRIPTION) VALUES (5, 3, 1, '2023-01-19 16:45:00', 'Incorrect data display')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_problem_report_insert on the PROBLEMS table. For each new row, retrieve the reporter's full name from STAFF and product name from PRODUCT. If DATE_PROBLEM_REPORTED is not null, insert a record into PROBLEM_LOG with a generated PROBLEM_LOG_ID, the new PROBLEM_ID, status 'Reported', the report date, and description 'Problem reported by [reporter name] for product [product name]'.",
    "natural_language": "Define a BEFORE INSERT row-level trigger called trg_problem_report_insert for the PROBLEMS table. For every inserted row, fetch the reporter's full name from the STAFF table and the product name from the PRODUCT table. If DATE_PROBLEM_REPORTED is provided, then insert a new entry into the PROBLEM_LOG table. This entry should include an auto-generated PROBLEM_LOG_ID, the new PROBLEM_ID, the status 'Reported', the report date, and a description formatted as 'Problem reported by [reporter name] for product [product name]'.",
    "id": 86,
    "generated_ir": "Write an Oracle PL/SQL `BEFORE INSERT` row-level trigger named `trg_problem_report_insert` that automatically executes before a new row is inserted into the `PROBLEMS` table. This trigger declares two local `VARCHAR2` variables: `v_reporter_name` and `v_product_name`, both capable of storing up to 255 characters. The trigger first retrieves the full name of the staff member who reported the problem by concatenating the `STAFF_FIRST_NAME` and `STAFF_LAST_NAME` columns from the `STAFF` table, where the `STAFF_ID` in the `STAFF` table matches the `REPORTED_BY_STAFF_ID` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.REPORTED_BY_STAFF_ID`), and stores this concatenated name into the `v_reporter_name` variable. Next, it retrieves the `PRODUCT_NAME` from the `PRODUCT` table, where the `PRODUCT_ID` in the `PRODUCT` table matches the `PRODUCT_ID` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.PRODUCT_ID`), and stores this product name into the `v_product_name` variable. Following these retrievals, the trigger evaluates a conditional statement: if the `DATE_PROBLEM_REPORTED` column of the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.DATE_PROBLEM_REPORTED`) is not null, then it proceeds to insert a new record into the `PROBLEM_LOG` table. For this insertion, the `PROBLEM_LOG_ID` column is populated by selecting the maximum existing `PROBLEM_LOG_ID` from the `PROBLEM_LOG` table, using `COALESCE` to default to 0 if no records exist, and then adding 1 to that value. The `PROBLEM_ID` column is populated with the `PROBLEM_ID` from the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.PROBLEM_ID`). The `PROBLEM_STATUS_CODE` column is set to the literal string 'Reported'. The `LOG_ENTRY_DATE` column is populated with the `DATE_PROBLEM_REPORTED` from the new row being inserted into the `PROBLEMS` table (referenced as `:NEW.DATE_PROBLEM_REPORTED`). Finally, the `LOG_ENTRY_DESCRIPTION` column is populated with a concatenated string formed by the literal 'Problem reported by ', followed by the value of the `v_reporter_name` variable, followed by the literal ' for product ', and then followed by the value of the `v_product_name` variable."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_MUSICAL_DELETE that is executed before a delete operation on the MUSICAL table for each row being deleted. The trigger first updates the ACTOR table by setting the MUSICAL_ID column to NULL for all records where the MUSICAL_ID matches the MUSICAL_ID of the row being deleted from the MUSICAL table, effectively breaking any circular references between ACTOR records that may exist due to this MUSICAL_ID. After updating the ACTOR table, the trigger proceeds to delete all records from the ACTOR table where the MUSICAL_ID matches the MUSICAL_ID of the row being deleted from the MUSICAL table, ensuring that all associated ACTOR records are removed before the deletion of the MUSICAL record.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_MUSICAL_DELETE\nBEFORE DELETE ON MUSICAL\nFOR EACH ROW\nBEGIN\n    -- First, update any ACTOR records that reference other ACTOR records\n    -- to break the circular reference before deletion\n    UPDATE ACTOR \n    SET MUSICAL_ID = NULL \n    WHERE MUSICAL_ID = :OLD.MUSICAL_ID;\n    \n    -- Then delete the ACTOR records that have the matching MUSICAL_ID\n    DELETE FROM ACTOR WHERE MUSICAL_ID = :OLD.MUSICAL_ID;\nEND;",
    "database_name": "musical",
    "tables": [
      "ACTOR",
      "MUSICAL"
    ],
    "call_sqls": [
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 1",
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 2",
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 3",
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 4",
      "DELETE FROM MUSICAL WHERE MUSICAL_ID = 5"
    ],
    "summary": "Create a BEFORE DELETE row-level trigger named TRG_MUSICAL_DELETE on the MUSICAL table. For each deleted row, first set the MUSICAL_ID to NULL in the ACTOR table for matching records, then delete all ACTOR records with that MUSICAL_ID.",
    "natural_language": "How can I create a BEFORE DELETE row-level trigger named TRG_MUSICAL_DELETE on the MUSICAL table that, for each deleted row, first sets the MUSICAL_ID to NULL in the ACTOR table for matching records and then deletes all ACTOR records with that MUSICAL_ID?",
    "id": 87,
    "generated_ir": "Write an Oracle PL/SQL trigger named TRG_MUSICAL_DELETE that is executed before a delete operation on the MUSICAL table for each row being deleted. The trigger first updates the ACTOR table by setting the MUSICAL_ID column to NULL for all records where the MUSICAL_ID matches the MUSICAL_ID of the row being deleted from the MUSICAL table, effectively breaking any circular references between ACTOR records that may exist due to this MUSICAL_ID. After updating the ACTOR table, the trigger proceeds to delete all records from the ACTOR table where the MUSICAL_ID matches the MUSICAL_ID of the row being deleted from the MUSICAL table, ensuring that all associated ACTOR records are removed before the deletion of the MUSICAL record."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `normalize_gymnast_points` that is configured to execute `BEFORE` any `UPDATE` operation is performed on a row in the `GYMNAST` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed individually for every row that is being updated. The trigger's purpose is to enforce a business rule on the `TOTAL_POINTS` column of the `GYMNAST` table. Specifically, it contains a conditional statement (`IF :NEW.TOTAL_POINTS > 60 THEN`) that checks the value of the `TOTAL_POINTS` column for the row currently being updated. The `:NEW` pseudorecord refers to the new values that are attempting to be written to the row. If the value of `:NEW.TOTAL_POINTS` is found to be strictly greater than `60`, then the trigger modifies the value of `:NEW.TOTAL_POINTS` by setting it to `60` (`:NEW.TOTAL_POINTS := 60;`). This modification occurs before the actual update operation is committed to the database, effectively capping the `TOTAL_POINTS` value at `60` if an attempt is made to update it to a higher value.",
    "plsql": "CREATE OR REPLACE TRIGGER normalize_gymnast_points\nBEFORE UPDATE ON GYMNAST\nFOR EACH ROW\nBEGIN\n  IF :NEW.TOTAL_POINTS > 60 THEN\n    :NEW.TOTAL_POINTS := 60;\n  END IF;\nEND;",
    "database_name": "gymnast",
    "tables": [
      "GYMNAST",
      "PEOPLE"
    ],
    "call_sqls": [
      "UPDATE GYMNAST SET TOTAL_POINTS = 65 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET TOTAL_POINTS = 55 WHERE GYMNAST_ID = 2",
      "UPDATE GYMNAST SET TOTAL_POINTS = 70 WHERE GYMNAST_ID = 4",
      "UPDATE GYMNAST SET TOTAL_POINTS = 60.01 WHERE GYMNAST_ID = 1",
      "UPDATE GYMNAST SET TOTAL_POINTS = 59.99 WHERE GYMNAST_ID = 2"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named normalize_gymnast_points on the GYMNAST table. If :NEW.TOTAL_POINTS is greater than 60, set it to 60.",
    "natural_language": "Construct a BEFORE UPDATE FOR EACH ROW trigger, which should be named normalize_gymnast_points, specifically for the GYMNAST table. This trigger must carefully check the newly provided value; if the :NEW.TOTAL_POINTS value is found to be greater than the maximum allowable score of 60, it should then be explicitly and permanently capped at that precise upper limit of 60.",
    "id": 88,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `normalize_gymnast_points` that is configured to execute `BEFORE` any `UPDATE` operation is performed on a row in the `GYMNAST` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed individually for every row that is being updated. The trigger's purpose is to enforce a business rule on the `TOTAL_POINTS` column of the `GYMNAST` table. Specifically, it contains a conditional statement (`IF :NEW.TOTAL_POINTS > 60 THEN`) that checks the value of the `TOTAL_POINTS` column for the row currently being updated. The `:NEW` pseudorecord refers to the new values that are attempting to be written to the row. If the value of `:NEW.TOTAL_POINTS` is found to be strictly greater than `60`, then the trigger modifies the value of `:NEW.TOTAL_POINTS` by setting it to `60` (`:NEW.TOTAL_POINTS := 60;`). This modification occurs before the actual update operation is committed to the database, effectively capping the `TOTAL_POINTS` value at `60` if an attempt is made to update it to a higher value."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `course_arrange_delete_trigger` that is activated immediately after a `DELETE` operation is performed on the `COURSE_ARRANGE` table. This trigger is defined to execute for `EACH ROW` that is affected by the `DELETE` statement. Upon activation for each deleted row, the trigger performs a `DELETE` operation on the `TEACHER` table. The `DELETE` operation on the `TEACHER` table is conditional, targeting only those rows where the value in the `TEACHER_ID` column of the `TEACHER` table is equal to the value of the `TEACHER_ID` column from the row that was just deleted from the `COURSE_ARRANGE` table. The `:OLD` pseudorecord is used to access the `TEACHER_ID` value from the row that existed in the `COURSE_ARRANGE` table prior to its deletion.",
    "plsql": "CREATE OR REPLACE TRIGGER course_arrange_delete_trigger\nAFTER DELETE ON COURSE_ARRANGE\nFOR EACH ROW\nBEGIN\n    DELETE FROM TEACHER WHERE TEACHER_ID = :OLD.TEACHER_ID;\nEND;",
    "database_name": "course_teach",
    "tables": [
      "COURSE",
      "COURSE_ARRANGE",
      "TEACHER"
    ],
    "call_sqls": [
      "DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = 2 AND TEACHER_ID = 3 AND GRADE = 3",
      "DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = 3 AND TEACHER_ID = 5 AND GRADE = 1",
      "DELETE FROM COURSE_ARRANGE WHERE TEACHER_ID = 2",
      "DELETE FROM COURSE_ARRANGE WHERE COURSE_ID = 2",
      "DELETE FROM COURSE_ARRANGE"
    ],
    "summary": "Create an AFTER DELETE row-level trigger named course_arrange_delete_trigger on the COURSE_ARRANGE table. For each deleted row, delete from the TEACHER table where TEACHER_ID equals the old TEACHER_ID value (:OLD.TEACHER_ID).",
    "natural_language": "How can I create an AFTER DELETE row-level trigger named course_arrange_delete_trigger on the COURSE_ARRANGE table that, for each deleted row, deletes the corresponding record from the TEACHER table where TEACHER_ID matches the old TEACHER_ID value?",
    "id": 89,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `course_arrange_delete_trigger` that is activated immediately after a `DELETE` operation is performed on the `COURSE_ARRANGE` table. This trigger is defined to execute for `EACH ROW` that is affected by the `DELETE` statement. Upon activation for each deleted row, the trigger performs a `DELETE` operation on the `TEACHER` table. The `DELETE` operation on the `TEACHER` table is conditional, targeting only those rows where the value in the `TEACHER_ID` column of the `TEACHER` table is equal to the value of the `TEACHER_ID` column from the row that was just deleted from the `COURSE_ARRANGE` table. The `:OLD` pseudorecord is used to access the `TEACHER_ID` value from the row that existed in the `COURSE_ARRANGE` table prior to its deletion."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_update_wedding_year that is defined to fire automatically after any row in the WEDDING table is updated, and it executes once for each updated row. The trigger performs an UPDATE operation on the CHURCH table. It sets the OPEN_DATE column of the CHURCH table to the value of the :NEW.YEAR column from the updated WEDDING row. This update is applied only to the specific row in the CHURCH table where the CHURCH_ID column matches the value of the :NEW.CHURCH_ID column from the updated WEDDING row.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_wedding_year\nAFTER UPDATE ON WEDDING\nFOR EACH ROW\nBEGIN\n  UPDATE CHURCH\n  SET\n    OPEN_DATE = :NEW.YEAR\n  WHERE\n    CHURCH_ID = :NEW.CHURCH_ID;\nEND;",
    "database_name": "wedding",
    "tables": [
      "CHURCH",
      "PEOPLE",
      "WEDDING"
    ],
    "call_sqls": [
      "UPDATE WEDDING SET YEAR = 2024 WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "UPDATE WEDDING SET YEAR = 2023 WHERE CHURCH_ID = 3 AND MALE_ID = 3 AND FEMALE_ID = 4",
      "UPDATE WEDDING SET YEAR = 2025 WHERE CHURCH_ID = 5 AND MALE_ID = 5 AND FEMALE_ID = 6",
      "UPDATE WEDDING SET YEAR = 2022, CHURCH_ID = 2 WHERE CHURCH_ID = 1 AND MALE_ID = 1 AND FEMALE_ID = 2",
      "UPDATE WEDDING SET YEAR = 2021 WHERE CHURCH_ID = 2 AND MALE_ID = 7 AND FEMALE_ID = 8"
    ],
    "summary": "Create an AFTER UPDATE FOR EACH ROW trigger named trg_update_wedding_year on the WEDDING table. For each updated row, update the CHURCH table, setting OPEN_DATE to :NEW.YEAR where CHURCH_ID equals :NEW.CHURCH_ID.",
    "natural_language": "Please construct an AFTER UPDATE FOR EACH ROW trigger designated as trg_update_wedding_year on the WEDDING table. For every row that is updated, it is required to perform an update on the CHURCH table. Specifically, set the OPEN_DATE column to the value of :NEW.YEAR for the record where the CHURCH_ID matches :NEW.CHURCH_ID.",
    "id": 90,
    "generated_ir": "Write an Oracle PL/SQL trigger named `trg_update_wedding_year` that is activated after an `UPDATE` operation on the `WEDDING` table. This is a row-level trigger, meaning it executes once for each row that is updated in the `WEDDING` table.\n\nThe trigger does not declare any variables. It operates directly using the pseudo-records `:OLD` and `:NEW` which represent the state of the row before and after the update, respectively.\n\nFor each row updated in the `WEDDING` table, the trigger performs a single SQL operation. It executes an `UPDATE` statement on the `CHURCH` table. This `UPDATE` statement sets the value of the `OPEN_DATE` column in the `CHURCH` table to the value of the `:NEW.YEAR` from the updated `WEDDING` row. The `UPDATE` is conditional; it only affects the specific record in the `CHURCH` table where the `CHURCH_ID` column matches the value of `:NEW.CHURCH_ID` from the updated `WEDDING` row. This ensures the update is targeted to the correct church associated with the wedding.\n\nThe trigger does not contain any complex business logic, calculations, or control flow structures like `IF` statements or loops. Its sole purpose is to propagate a change from the `YEAR` column of an updated `WEDDING` record to the `OPEN_DATE` column of the corresponding `CHURCH` record, using `CHURCH_ID` as the linking key. The trigger does not return a value; it performs a side effect by modifying data in the `CHURCH` table."
  },
  {
    "ir": "Write an Oracle PL/SQL compound trigger named `trg_update_claim_amount` that is defined on the `CLAIMS` table and fires for `INSERT` operations. This trigger is designed to capture data from each newly inserted row into the `CLAIMS` table and then, after all rows in the statement have been processed, perform additional operations based on the collected data.\n\nThe trigger begins by declaring a record type named `claim_rec_type` which mirrors the structure of a claim record, containing fields for `claim_id` (of type `CLAIMS.CLAIM_ID%TYPE`), `policy_id` (of type `CLAIMS.POLICY_ID%TYPE`), `date_claim_made` (of type `CLAIMS.DATE_CLAIM_MADE%TYPE`), and `amount_claimed` (of type `CLAIMS.AMOUNT_CLAIMED%TYPE`). It then declares a nested table type named `claim_rec_tab_type` which is a table of `claim_rec_type` records. A variable `claim_rec_tab` of type `claim_rec_tab_type` is initialized as an empty nested table.\n\nThe `AFTER EACH ROW` section of the compound trigger executes for every row that is inserted into the `CLAIMS` table. Within this section, the `claim_rec_tab` nested table is extended by one element. The values from the newly inserted row, specifically `:NEW.CLAIM_ID`, `:NEW.POLICY_ID`, `:NEW.DATE_CLAIM_MADE`, and `:NEW.AMOUNT_CLAIMED`, are then assigned to the corresponding fields of the last element added to `claim_rec_tab`. This effectively collects the details of each inserted claim into the `claim_rec_tab` collection.\n\nThe `AFTER STATEMENT` section of the compound trigger executes once after all rows affected by the `INSERT` statement on the `CLAIMS` table have been processed. A local variable `v_avg_amount` of type `NUMBER` is declared within this section. The trigger then iterates through each record stored in the `claim_rec_tab` collection using a `FOR` loop, from the first element to the last (`1 .. claim_rec_tab.COUNT`). Inside the loop, for each collected claim record:\n1. A `SELECT` statement is executed to calculate the average `AMOUNT_CLAIMED` from the `CLAIMS` table. This average is determined for all claims that share the same `POLICY_ID` as the current claim record being processed from `claim_rec_tab(i).policy_id`. The calculated average amount is stored into the `v_avg_amount` variable.\n2. An `INSERT` statement is executed to add a new record into the `SETTLEMENTS` table. The values for the new record are derived as follows:\n    - `SETTLEMENT_ID`: This is generated by selecting the maximum `SETTLEMENT_ID` from the `SETTLEMENTS` table, using `NVL` to default to `0` if no records exist, and then adding `1` to that value.\n    - `CLAIM_ID`: This is set to the `claim_id` from the current collected claim record, `claim_rec_tab(i).claim_id`.\n    - `DATE_CLAIM_MADE`: This is set to the `date_claim_made` from the current collected claim record, `claim_rec_tab(i).date_claim_made`.\n    - `DATE_CLAIM_SETTLED`: This is set to `NULL`.\n    - `AMOUNT_CLAIMED`: This is set to the `amount_claimed` from the current collected claim record, `claim_rec_tab(i).amount_claimed`.\n    - `AMOUNT_SETTLED`: This is set to the `v_avg_amount` that was calculated in the previous step.\n    - `CUSTOMER_POLICY_ID`: This is set to the `policy_id` from the current collected claim record, `claim_rec_tab(i).policy_id`.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_update_claim_amount\nFOR INSERT ON CLAIMS\nCOMPOUND TRIGGER\n\n  TYPE claim_rec_type IS RECORD (\n    claim_id CLAIMS.CLAIM_ID%TYPE,\n    policy_id CLAIMS.POLICY_ID%TYPE,\n    date_claim_made CLAIMS.DATE_CLAIM_MADE%TYPE,\n    amount_claimed CLAIMS.AMOUNT_CLAIMED%TYPE\n  );\n\n  TYPE claim_rec_tab_type IS TABLE OF claim_rec_type;\n  claim_rec_tab claim_rec_tab_type := claim_rec_tab_type();\n\n  AFTER EACH ROW IS\n  BEGIN\n    claim_rec_tab.EXTEND;\n    claim_rec_tab(claim_rec_tab.LAST) := claim_rec_type(\n      :NEW.CLAIM_ID,\n      :NEW.POLICY_ID,\n      :NEW.DATE_CLAIM_MADE,\n      :NEW.AMOUNT_CLAIMED\n    );\n  END AFTER EACH ROW;\n\n  AFTER STATEMENT IS\n    v_avg_amount NUMBER;\n  BEGIN\n    FOR i IN 1 .. claim_rec_tab.COUNT LOOP\n      SELECT AVG(AMOUNT_CLAIMED) INTO v_avg_amount FROM CLAIMS WHERE POLICY_ID = claim_rec_tab(i).policy_id;\n\n      INSERT INTO SETTLEMENTS (SETTLEMENT_ID, CLAIM_ID, DATE_CLAIM_MADE, DATE_CLAIM_SETTLED, AMOUNT_CLAIMED, AMOUNT_SETTLED, CUSTOMER_POLICY_ID)\n      VALUES ((SELECT NVL(MAX(SETTLEMENT_ID), 0) + 1 FROM SETTLEMENTS), claim_rec_tab(i).claim_id, claim_rec_tab(i).date_claim_made, NULL, claim_rec_tab(i).amount_claimed, v_avg_amount, claim_rec_tab(i).policy_id);\n    END LOOP;\n  END AFTER STATEMENT;\n\nEND trg_update_claim_amount;",
    "database_name": "insurance_policies",
    "tables": [
      "CLAIMS",
      "CUSTOMERS",
      "CUSTOMER_POLICIES",
      "PAYMENTS",
      "SETTLEMENTS"
    ],
    "call_sqls": [
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (501, 744, '2023-10-01', 50000)",
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (502, 552, '2023-10-02', 60000)",
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (503, 473, '2023-10-03', 70000)",
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (504, 744, '2023-10-04', 80000)",
      "INSERT INTO CLAIMS (CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, AMOUNT_CLAIMED) VALUES (505, 552, '2023-10-05', 90000)"
    ],
    "summary": "Create a compound trigger named trg_update_claim_amount on the CLAIMS table for INSERT operations. In the AFTER EACH ROW section, collect each inserted row's CLAIM_ID, POLICY_ID, DATE_CLAIM_MADE, and AMOUNT_CLAIMED into a nested table. In the AFTER STATEMENT section, for each collected record: calculate the average AMOUNT_CLAIMED for claims with the same POLICY_ID, then insert a new record into SETTLEMENTS table with SETTLEMENT_ID as MAX+1, CLAIM_ID, DATE_CLAIM_MADE, NULL for DATE_CLAIM_SETTLED, AMOUNT_CLAIMED, the calculated average as AMOUNT_SETTLED, and POLICY_ID as CUSTOMER_POLICY_ID.",
    "natural_language": "Set up a compound trigger on the claims table for new entries. After each row goes in, gather some details like the claim ID, policy number, when it was made, and the claimed amount into a collection. Later, after everything's done, for each of those saved records: figure out the typical amount claimed for other claims under the same policy, then add a new settlement record. Use the next available ID, the original claim details, leave the settlement date blank for now, put in the claimed amount, use that typical figure as the settled amount, and include the policy ID.",
    "id": 91,
    "generated_ir": "Write an Oracle PL/SQL compound trigger named `trg_update_claim_amount` that is defined on the `CLAIMS` table and fires for `INSERT` operations. This trigger is designed to capture data from each newly inserted row into the `CLAIMS` table and then, after all rows in the statement have been processed, perform additional operations based on the collected data.\n\nThe trigger begins by declaring a record type named `claim_rec_type` which mirrors the structure of a claim record, containing fields for `claim_id` (of type `CLAIMS.CLAIM_ID%TYPE`), `policy_id` (of type `CLAIMS.POLICY_ID%TYPE`), `date_claim_made` (of type `CLAIMS.DATE_CLAIM_MADE%TYPE`), and `amount_claimed` (of type `CLAIMS.AMOUNT_CLAIMED%TYPE`). It then declares a nested table type named `claim_rec_tab_type` which is a table of `claim_rec_type` records. A variable `claim_rec_tab` of type `claim_rec_tab_type` is initialized as an empty nested table.\n\nThe `AFTER EACH ROW` section of the compound trigger executes for every row that is inserted into the `CLAIMS` table. Within this section, the `claim_rec_tab` nested table is extended by one element. The values from the newly inserted row, specifically `:NEW.CLAIM_ID`, `:NEW.POLICY_ID`, `:NEW.DATE_CLAIM_MADE`, and `:NEW.AMOUNT_CLAIMED`, are then assigned to the corresponding fields of the last element added to `claim_rec_tab`. This effectively collects the details of each inserted claim into the `claim_rec_tab` collection.\n\nThe `AFTER STATEMENT` section of the compound trigger executes once after all rows affected by the `INSERT` statement on the `CLAIMS` table have been processed. A local variable `v_avg_amount` of type `NUMBER` is declared within this section. The trigger then iterates through each record stored in the `claim_rec_tab` collection using a `FOR` loop, from the first element to the last (`1 .. claim_rec_tab.COUNT`). Inside the loop, for each collected claim record:\n1. A `SELECT` statement is executed to calculate the average `AMOUNT_CLAIMED` from the `CLAIMS` table. This average is determined for all claims that share the same `POLICY_ID` as the current claim record being processed from `claim_rec_tab(i).policy_id`. The calculated average amount is stored into the `v_avg_amount` variable.\n2. An `INSERT` statement is executed to add a new record into the `SETTLEMENTS` table. The values for the new record are derived as follows:\n    - `SETTLEMENT_ID`: This is generated by selecting the maximum `SETTLEMENT_ID` from the `SETTLEMENTS` table, using `NVL` to default to `0` if no records exist, and then adding `1` to that value.\n    - `CLAIM_ID`: This is set to the `claim_id` from the current collected claim record, `claim_rec_tab(i).claim_id`.\n    - `DATE_CLAIM_MADE`: This is set to the `date_claim_made` from the current collected claim record, `claim_rec_tab(i).date_claim_made`.\n    - `DATE_CLAIM_SETTLED`: This is set to `NULL`.\n    - `AMOUNT_CLAIMED`: This is set to the `amount_claimed` from the current collected claim record, `claim_rec_tab(i).amount_claimed`.\n    - `AMOUNT_SETTLED`: This is set to the `v_avg_amount` that was calculated in the previous step.\n    - `CUSTOMER_POLICY_ID`: This is set to the `policy_id` from the current collected claim record, `claim_rec_tab(i).policy_id`."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named TRG_PROBLEM_CATEGORY_INSERT that executes automatically before any row insertion operation on the table named PROBLEM_CATEGORY_CODES, and for each new row being inserted, the trigger logic checks a single condition: if the value being inserted into the column PROBLEM_CATEGORY_CODE for the new row, referenced as :NEW.PROBLEM_CATEGORY_CODE, is NULL, then the trigger performs an assignment operation to set that :NEW.PROBLEM_CATEGORY_CODE column value for the new row to the literal string 'Unknown'.",
    "plsql": "CREATE OR REPLACE TRIGGER TRG_PROBLEM_CATEGORY_INSERT\nBEFORE INSERT ON PROBLEM_CATEGORY_CODES\nFOR EACH ROW\nBEGIN\n    IF :NEW.PROBLEM_CATEGORY_CODE IS NULL THEN\n        :NEW.PROBLEM_CATEGORY_CODE := 'Unknown';\n    END IF;\nEND;",
    "database_name": "tracking_software_problems",
    "tables": [
      "PROBLEMS",
      "PROBLEM_LOG",
      "PROBLEM_CATEGORY_CODES",
      "PROBLEM_STATUS_CODES",
      "STAFF"
    ],
    "call_sqls": [
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Network issues')",
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Security vulnerabilities')",
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Performance bottlenecks')",
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Hardware failures')",
      "INSERT INTO PROBLEM_CATEGORY_CODES (PROBLEM_CATEGORY_DESCRIPTION) VALUES ('Software bugs')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named TRG_PROBLEM_CATEGORY_INSERT on the PROBLEM_CATEGORY_CODES table. If :NEW.PROBLEM_CATEGORY_CODE is NULL, set it to 'Unknown'.",
    "natural_language": "Please implement a BEFORE INSERT row-level trigger designated as TRG_PROBLEM_CATEGORY_INSERT on the PROBLEM_CATEGORY_CODES table. The trigger's function is to assign the value 'Unknown' to the :NEW.PROBLEM_CATEGORY_CODE column in the event that its value is found to be NULL.",
    "id": 92,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `TRG_PROBLEM_CATEGORY_INSERT` that is configured to execute `BEFORE` any `INSERT` operation is performed on the `PROBLEM_CATEGORY_CODES` table. This trigger is a `FOR EACH ROW` trigger, meaning its logic will be executed once for every individual row being inserted into the `PROBLEM_CATEGORY_CODES` table. The trigger's primary purpose is to ensure data integrity by providing a default value for the `PROBLEM_CATEGORY_CODE` column if the incoming value is missing. Specifically, for each new row being inserted, the trigger evaluates the value of the `PROBLEM_CATEGORY_CODE` column for the `NEW` row (the row as it will appear after the `INSERT` operation). If the value of `:NEW.PROBLEM_CATEGORY_CODE` is `NULL`, then the trigger assigns the string literal `'Unknown'` to the `:NEW.PROBLEM_CATEGORY_CODE` column. This assignment directly modifies the `PROBLEM_CATEGORY_CODE` column of the row before it is permanently stored in the `PROBLEM_CATEGORY_CODES` table. If the value of `:NEW.PROBLEM_CATEGORY_CODE` is not `NULL`, the trigger takes no action and the original value is retained. The trigger operates within the `tracking_software_problems` database."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_singer_age_calc` that is activated `BEFORE` an `INSERT` operation is performed on the `SINGER` table, and executes `FOR EACH ROW` being inserted. This trigger declares a local numeric variable `v_age_months` to store the calculated age in months. Within the trigger's execution block, it first calculates the age of the singer in months by determining the number of months between the current system date (`SYSDATE`) and the singer's birth date. The singer's birth date is constructed by concatenating the `BIRTH_YEAR` column value from the `NEW` pseudo-record (representing the row being inserted) with the literal string `'-01-01'`, and then converting this combined string into a date format using `TO_DATE` with the format mask `'YYYY-MM-DD'`. The result of this `MONTHS_BETWEEN` function call is assigned to the `v_age_months` variable. Subsequently, a conditional logic block is executed: `IF` the calculated `v_age_months` is `LESS THAN` `600` (representing 50 years), then the `NET_WORTH_MILLIONS` column of the `NEW` pseudo-record is updated by multiplying its current value by `0.9` (effectively reducing it by 10%). `ELSE IF` the calculated `v_age_months` is `GREATER THAN` `960` (representing 80 years), then the `NET_WORTH_MILLIONS` column of the `NEW` pseudo-record is updated by multiplying its current value by `1.1` (effectively increasing it by 10%). If neither of these conditions is met, the `NET_WORTH_MILLIONS` column remains unchanged.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_singer_age_calc\nBEFORE INSERT ON SINGER\nFOR EACH ROW\nDECLARE\n   v_age_months NUMBER;\nBEGIN\n   v_age_months := MONTHS_BETWEEN(SYSDATE, TO_DATE(:NEW.BIRTH_YEAR || '-01-01', 'YYYY-MM-DD'));\n   IF v_age_months < 600 THEN\n      :NEW.NET_WORTH_MILLIONS := :NEW.NET_WORTH_MILLIONS * 0.9;\n   ELSIF v_age_months > 960 THEN\n      :NEW.NET_WORTH_MILLIONS := :NEW.NET_WORTH_MILLIONS * 1.1;\n   END IF;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (10, 'Young Artist', 2010, 10, 'United States')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (11, 'Middle Aged Star', 1985, 50, 'United Kingdom')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (12, 'Senior Legend', 1940, 100, 'France')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (13, 'Teen Prodigy', 2008, 5, 'Canada')",
      "INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP) VALUES (14, 'Veteran Singer', 1935, 80, 'Italy')"
    ],
    "summary": "Create a BEFORE INSERT row-level trigger named trg_singer_age_calc on the SINGER table. Calculate the singer's age in months from their BIRTH_YEAR. If age < 600 months (50 years), reduce NET_WORTH_MILLIONS by 10%. If age > 960 months (80 years), increase NET_WORTH_MILLIONS by 10%.",
    "natural_language": "Formulate a BEFORE INSERT row-level trigger designated as trg_singer_age_calc for the SINGER table. The procedure shall compute the age of the singer in months based on the provided BIRTH_YEAR. Should the calculated age be less than 600 months (equating to 50 years), a reduction of 10% is to be applied to the NET_WORTH_MILLIONS field. Conversely, if the age exceeds 960 months (equating to 80 years), an increase of 10% is to be applied to the NET_WORTH_MILLIONS field.",
    "id": 93,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_singer_age_calc that is a BEFORE INSERT row-level trigger on the SINGER table. This trigger executes automatically for each new row being inserted into the SINGER table before the insertion occurs. The trigger first declares a local variable v_age_in_months of type NUMBER to store the calculated age. It calculates the age in months by subtracting the provided BIRTH_YEAR value from the current year, obtained using the EXTRACT(YEAR FROM SYSDATE) function, and then multiplying the result by 12. This calculated value is stored in v_age_in_months. The trigger then evaluates a conditional logic using IF-THEN-ELSIF statements. If v_age_in_months is less than 600, it applies a 10% reduction to the NET_WORTH_MILLIONS field of the new row by setting :NEW.NET_WORTH_MILLIONS to :NEW.NET_WORTH_MILLIONS multiplied by 0.9. If v_age_in_months is greater than 960, it applies a 10% increase to the NET_WORTH_MILLIONS field by setting :NEW.NET_WORTH_MILLIONS to :NEW.NET_WORTH_MILLIONS multiplied by 1.1. If the age is between 600 and 960 months inclusive, no modification is made to the NET_WORTH_MILLIONS field. The trigger modifies the :NEW.NET_WORTH_MILLIONS value directly, which will be used for the subsequent INSERT operation."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_delete_staff that is executed automatically after a DELETE operation is performed on the STAFF table. This trigger operates for each row affected by the DELETE statement. Within the trigger's body, it performs a DELETE operation on the CONFERENCE_PARTICIPATION table, specifically targeting rows where the STAFF_ID column matches the value of the STAFF_ID column from the deleted row in the STAFF table, which is accessed using the :OLD prefix to refer to the old values of the row being deleted. The purpose of this trigger is to ensure that any records in the CONFERENCE_PARTICIPATION table associated with the deleted staff member are also removed, maintaining referential integrity between the STAFF and CONFERENCE_PARTICIPATION tables by eliminating orphaned records that no longer have a corresponding staff member in the STAFF table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_delete_staff\nAFTER DELETE ON STAFF\nFOR EACH ROW\nBEGIN\n  DELETE FROM CONFERENCE_PARTICIPATION WHERE STAFF_ID = :OLD.STAFF_ID;\nEND;",
    "database_name": "conference",
    "tables": [
      "CONFERENCE",
      "CONFERENCE_PARTICIPATION",
      "INSTITUTION",
      "STAFF"
    ],
    "call_sqls": [
      "DELETE FROM STAFF WHERE STAFF_ID = 1",
      "DELETE FROM STAFF WHERE STAFF_ID = 2",
      "DELETE FROM STAFF WHERE STAFF_ID = 3",
      "DELETE FROM STAFF WHERE NAME = 'Bobby Jackson'",
      "DELETE FROM STAFF WHERE INSTITUTION_ID = 1"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_delete_staff on the STAFF table. For each deleted row, delete from the CONFERENCE_PARTICIPATION table where STAFF_ID = :OLD.STAFF_ID to maintain referential integrity.",
    "natural_language": "Construct an AFTER DELETE FOR EACH ROW trigger, which should be named trg_delete_staff, on the STAFF table. For every single row that is subsequently removed, it is essential to meticulously delete any corresponding entries from the CONFERENCE_PARTICIPATION table precisely where the STAFF_ID matches the :OLD.STAFF_ID value, thereby ensuring that referential integrity is consistently and reliably maintained.",
    "id": 94,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_delete_staff that is executed after a row is deleted from the STAFF table. This trigger operates for each row that is deleted. The trigger does not declare any local variables. Upon execution, it performs a DELETE operation on the CONFERENCE_PARTICIPATION table. The deletion condition is that the STAFF_ID column in the CONFERENCE_PARTICIPATION table must exactly match the STAFF_ID value from the deleted row in the STAFF table, which is accessed via the :OLD.STAFF_ID pseudorecord. This action ensures that any participation records associated with the deleted staff member are also removed, maintaining referential integrity by preventing orphaned records in the CONFERENCE_PARTICIPATION table. The trigger does not return any value and completes after the deletion operation."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_maintain_location_city that is executed after an insert operation on the DEPARTMENTS table for each row affected by the insert. The trigger begins by declaring three local variables: v_city of type VARCHAR2(255), v_location_exists of type NUMBER, and v_new_location_id of type NUMBER. The trigger first performs a SELECT COUNT(*) operation to determine if a location with the LOCATION_ID matching the newly inserted department's LOCATION_ID already exists in the LOCATIONS table, storing the result in v_location_exists. If v_location_exists equals 0, indicating that the location does not exist, the trigger proceeds to create a new city name by concatenating the first five characters of the newly inserted department's DEPARTMENT_NAME with the string '_LOC', storing this result in v_city. The trigger then checks if the LOCATION_ID from the newly inserted department is NULL. If it is NULL, the trigger generates a new unique LOCATION_ID by selecting the maximum LOCATION_ID from the LOCATIONS table, adding 1 to it, and storing the result in v_new_location_id. If the LOCATION_ID is not NULL, the trigger assigns the department's LOCATION_ID to v_new_location_id. Subsequently, the trigger inserts a new row into the LOCATIONS table with the following values: v_new_location_id for LOCATION_ID, 'AUTO_GEN' for STREET_ADDRESS, '00000' for POSTAL_CODE, v_city for CITY, NULL for STATE_PROVINCE, and 'US' for COUNTRY_ID. The trigger includes an exception handler for the DUP_VAL_ON_INDEX exception, which occurs if there is a duplicate key issue during the insert operation, and handles this exception silently by doing nothing.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_maintain_location_city\nAFTER INSERT ON DEPARTMENTS\nFOR EACH ROW\nDECLARE\n  v_city VARCHAR2(255);\n  v_location_exists NUMBER;\n  v_new_location_id NUMBER;\nBEGIN\n  -- Check if the location already exists\n  SELECT COUNT(*)\n  INTO v_location_exists\n  FROM LOCATIONS\n  WHERE LOCATION_ID = :NEW.LOCATION_ID;\n  \n  -- Only insert if location doesn't exist\n  IF v_location_exists = 0 THEN\n    v_city := SUBSTR(:NEW.DEPARTMENT_NAME, 1, 5) || '_LOC';\n    \n    -- Generate a new unique location ID if the one from department is null or conflicts\n    IF :NEW.LOCATION_ID IS NULL THEN\n      SELECT NVL(MAX(LOCATION_ID), 0) + 1\n      INTO v_new_location_id\n      FROM LOCATIONS;\n    ELSE\n      v_new_location_id := :NEW.LOCATION_ID;\n    END IF;\n    \n    INSERT INTO LOCATIONS (LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID)\n    VALUES (v_new_location_id, 'AUTO_GEN', '00000', v_city, NULL, 'US');\n  END IF;\nEXCEPTION\n  WHEN DUP_VAL_ON_INDEX THEN\n    -- Handle any remaining duplicate key issues silently\n    NULL;\nEND;",
    "database_name": "hr_1",
    "tables": [
      "DEPARTMENTS",
      "EMPLOYEES",
      "JOBS",
      "JOB_HISTORY",
      "LOCATIONS"
    ],
    "call_sqls": [
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES (40, 'Human Resources', 2000)",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES (50, 'Research', NULL)",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME) VALUES (60, 'Development')",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES (70, 'Quality Assurance', 1700)",
      "INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES (80, 'Sales', 9999)"
    ],
    "summary": "Create an AFTER INSERT row-level trigger named trg_maintain_location_city on the DEPARTMENTS table. For each new row: check if its LOCATION_ID exists in the LOCATIONS table. If not, create a city name from the first five characters of DEPARTMENT_NAME plus '_LOC'. If the department's LOCATION_ID is NULL, generate a new ID as max(LOCATION_ID)+1; otherwise, use it. Insert a new location into LOCATIONS with the generated/found ID, 'AUTO_GEN' street, '00000' postal code, the created city, NULL state, and 'US' country. Handle duplicate key errors silently.",
    "natural_language": "Create a row-level trigger named trg_maintain_location_city that fires AFTER INSERT on the DEPARTMENTS table. For each new row, first check if its LOCATION_ID exists in the LOCATIONS table. If it does not exist, construct a city name by taking the first five characters of the DEPARTMENT_NAME and appending '_LOC'. If the department's LOCATION_ID is NULL, generate a new ID by taking the maximum existing LOCATION_ID and adding one; otherwise, use the provided LOCATION_ID. Then, insert a new row into the LOCATIONS table using the generated or existing LOCATION_ID, with 'AUTO_GEN' for the street address, '00000' for the postal code, the constructed city name, NULL for the state, and 'US' for the country ID. Ensure any duplicate key errors are handled silently without raising an exception.",
    "id": 95,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_maintain_location_city that is defined to fire after any insert operation on the DEPARTMENTS table for each affected row. The trigger is designed to automatically maintain corresponding records in the LOCATIONS table. Upon insertion of a new department row, the trigger first checks whether the LOCATION_ID value from the new department row exists in the LOCATIONS table by performing a SELECT COUNT(*) query on the LOCATIONS table where the LOCATION_ID column matches the :NEW.LOCATION_ID from the inserted department row. If the count returns zero, indicating the location does not exist, the trigger proceeds to construct a city name by extracting the first five characters from the :NEW.DEPARTMENT_NAME column and appending the string literal '_LOC' to it. Next, the trigger evaluates the :NEW.LOCATION_ID value; if it is NULL, the trigger generates a new location ID by executing a SELECT MAX(LOCATION_ID) query on the LOCATIONS table to retrieve the highest existing LOCATION_ID, then adds one to this maximum value to create a new unique ID; if the :NEW.LOCATION_ID is not NULL, the trigger uses that provided value as the location ID. The trigger then attempts to insert a new row into the LOCATIONS table with the following column values: the generated or existing LOCATION_ID as the LOCATION_ID column, the string literal 'AUTO_GEN' for the STREET_ADDRESS column, the string literal '00000' for the POSTAL_CODE column, the constructed city name for the CITY column, NULL for the STATE_PROVINCE column, and the string literal 'US' for the COUNTRY_ID column. To handle any potential duplicate key errors that might arise if the LOCATION_ID already exists in the LOCATIONS table due to concurrent operations, the trigger includes an exception handling section that catches the DUP_VAL_ON_INDEX exception and silently ignores it without raising any error, allowing the trigger to complete without interrupting the original insert operation on the DEPARTMENTS table."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_sync_move_dates that fires before any update operation on the DATE_MOVED_IN column of the RESIDENTS table for each affected row, and within its execution block, it first declares three local variables: v_customer_count of type NUMBER, v_property_type of type VARCHAR2 with a length of 255, and v_max_event_id of type NUMBER; then it performs a sequence of operations starting with a SELECT statement that counts rows from the CUSTOMER_EVENTS table where the RESIDENT_ID column equals the new RESIDENT_ID value from the triggering row and the PROPERTY_ID column equals the new PROPERTY_ID value, storing the result into v_customer_count, followed by a SELECT statement that retrieves the PROPERTY_TYPE_CODE column from the PROPERTIES table for the row where PROPERTY_ID equals the new PROPERTY_ID value, storing the result into v_property_type, and then a SELECT statement that uses the NVL function to find the maximum value of the CUSTOMER_EVENT_ID column from the CUSTOMER_EVENTS table, returning 0 if the maximum is null, and stores this into v_max_event_id; after these queries, it evaluates a conditional IF-ELSIF-ELSIF-ELSE block where if v_customer_count equals 0, it executes an INSERT statement into the CUSTOMER_EVENTS table, specifying columns CUSTOMER_EVENT_ID with value v_max_event_id plus 1, CUSTOMER_ID with value 1, DATE_MOVED_IN with the new DATE_MOVED_IN value, PROPERTY_ID with the new PROPERTY_ID value, RESIDENT_ID with the new RESIDENT_ID value, and THING_ID with value 1, but if v_customer_count is not 0 and v_property_type equals the string 'house', it executes an UPDATE statement on the CUSTOMER_EVENTS table, setting the DATE_MOVED_IN column to the new DATE_MOVED_IN value for rows where the RESIDENT_ID column equals the new RESIDENT_ID value and the PROPERTY_ID column equals the new PROPERTY_ID value, but if v_customer_count is not 0 and v_property_type equals the string 'apartment', it executes a DELETE statement on the CUSTOMER_EVENTS table for rows where the RESIDENT_ID column equals the new RESIDENT_ID value and the PROPERTY_ID column equals the new PROPERTY_ID value and the DATE_MOVED_IN column equals the old DATE_MOVED_IN value from before the update, and for any other case where the preceding conditions are false, it executes an INSERT statement into the CUSTOMER_EVENTS table, specifying columns CUSTOMER_EVENT_ID with value v_max_event_id plus 2, CUSTOMER_ID with value 2, DATE_MOVED_IN with the new DATE_MOVED_IN value, PROPERTY_ID with the new PROPERTY_ID value, RESIDENT_ID with the new RESIDENT_ID value, and THING_ID with value 2.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_sync_move_dates\nBEFORE UPDATE OF DATE_MOVED_IN ON RESIDENTS\nFOR EACH ROW\nDECLARE\n    v_customer_count NUMBER;\n    v_property_type VARCHAR2(255);\n    v_max_event_id NUMBER;\nBEGIN\n    SELECT COUNT(*) INTO v_customer_count FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :NEW.RESIDENT_ID AND PROPERTY_ID = :NEW.PROPERTY_ID;\n    SELECT PROPERTY_TYPE_CODE INTO v_property_type FROM PROPERTIES WHERE PROPERTY_ID = :NEW.PROPERTY_ID;\n    SELECT NVL(MAX(CUSTOMER_EVENT_ID), 0) INTO v_max_event_id FROM CUSTOMER_EVENTS;\n    IF v_customer_count = 0 THEN\n        INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (v_max_event_id + 1, 1, :NEW.DATE_MOVED_IN, :NEW.PROPERTY_ID, :NEW.RESIDENT_ID, 1);\n    ELSIF v_property_type = 'house' THEN\n        UPDATE CUSTOMER_EVENTS SET DATE_MOVED_IN = :NEW.DATE_MOVED_IN WHERE RESIDENT_ID = :NEW.RESIDENT_ID AND PROPERTY_ID = :NEW.PROPERTY_ID;\n    ELSIF v_property_type = 'apartment' THEN\n        DELETE FROM CUSTOMER_EVENTS WHERE RESIDENT_ID = :NEW.RESIDENT_ID AND PROPERTY_ID = :NEW.PROPERTY_ID AND DATE_MOVED_IN = :OLD.DATE_MOVED_IN;\n    ELSE\n        INSERT INTO CUSTOMER_EVENTS (CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, THING_ID) VALUES (v_max_event_id + 2, 2, :NEW.DATE_MOVED_IN, :NEW.PROPERTY_ID, :NEW.RESIDENT_ID, 2);\n    END IF;\nEND;",
    "database_name": "local_govt_and_lot",
    "tables": [
      "CUSTOMER_EVENTS",
      "RESIDENTS",
      "PROPERTIES"
    ],
    "call_sqls": [
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-01-15 10:00:00' WHERE RESIDENT_ID = 10 AND PROPERTY_ID = 605 AND DATE_MOVED_IN = '2015-03-27 12:00:00'",
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-02-01 09:30:00' WHERE RESIDENT_ID = 23 AND PROPERTY_ID = 879 AND DATE_MOVED_IN = '2017-06-17 15:43:33'",
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-03-10 14:15:00' WHERE RESIDENT_ID = 28 AND PROPERTY_ID = 629 AND DATE_MOVED_IN = '2017-11-14 06:28:48'",
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-04-20 16:45:00' WHERE RESIDENT_ID = 6 AND PROPERTY_ID = 954 AND DATE_MOVED_IN = '2017-12-18 03:46:04'",
      "UPDATE RESIDENTS SET DATE_MOVED_IN = '2024-05-05 11:20:00' WHERE RESIDENT_ID = 10 AND PROPERTY_ID = 605 AND DATE_MOVED_IN = '2024-01-15 10:00:00'"
    ],
    "summary": "Create a BEFORE UPDATE FOR EACH ROW trigger named trg_sync_move_dates on the RESIDENTS table when DATE_MOVED_IN is updated. Declare variables for count, property type, and max event ID. Query CUSTOMER_EVENTS and PROPERTIES tables. If count = 0, insert a new event with ID = max+1, CUSTOMER_ID=1, THING_ID=1. Else if property type is 'house', update DATE_MOVED_IN in existing events. Else if property type is 'apartment', delete events with old DATE_MOVED_IN. Otherwise, insert a new event with ID = max+2, CUSTOMER_ID=2, THING_ID=2.",
    "natural_language": "Alright, so we need a trigger called trg_sync_move_dates that fires off before any update to a row in the RESIDENTS table, specifically when the DATE_MOVED_IN field gets changed. Gotta set up some variables to hold a count, the property type, and the highest event ID we've got. Then, we'll have to check some stuff in the CUSTOMER_EVENTS and PROPERTIES tables. If the count comes back as zero, we just add a brand new event, making its ID one more than the max, and set CUSTOMER_ID and THING_ID to 1. If the count isn't zero, we check the property type. If it's a 'house', we go ahead and update the DATE_MOVED_IN in the existing events. If it's an 'apartment', we gotta delete any events that still have the old move-in date. And if it's anything else, we just insert another new event, this time with an ID of max+2 and CUSTOMER_ID and THING_ID set to 2.",
    "id": 96,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_sync_move_dates that is defined to fire automatically before each row is updated in the RESIDENTS table, and only when the DATE_MOVED_IN column of the row being updated is changed. This is a FOR EACH ROW trigger. Within the trigger's execution block, the trigger declares three local variables: v_count of type NUMBER, v_property_type of type VARCHAR2 with a maximum length of 255 characters, and v_max_event_id of type NUMBER.\n\nFirst, the trigger performs a SELECT operation that uses the COUNT aggregate function on the CUSTOMER_EVENTS table, joining it with the RESIDENTS table using the condition that CUSTOMER_EVENTS.PROPERTY_ID equals the new value of the RESIDENTS.PROPERTY_ID column from the updated row, and CUSTOMER_EVENTS.RESIDENT_ID equals the new value of the RESIDENTS.RESIDENT_ID column from the updated row, and CUSTOMER_EVENTS.DATE_MOVED_IN equals the old value of the RESIDENTS.DATE_MOVED_IN column from the row before the update. The result of this count is stored into the local variable v_count.\n\nSecond, the trigger performs another SELECT operation to retrieve the PROPERTY_TYPE_CODE column from the PROPERTIES table, where the PROPERTIES.PROPERTY_ID equals the new value of the RESIDENTS.PROPERTY_ID column from the updated row. This value is stored into the local variable v_property_type.\n\nThird, the trigger performs a SELECT operation that uses the MAX aggregate function on the CUSTOMER_EVENT_ID column of the CUSTOMER_EVENTS table, and stores this value into the local variable v_max_event_id. If the result is NULL, it is treated as 0.\n\nFollowing these data retrieval steps, the trigger evaluates the value of v_count. If v_count equals 0, the trigger performs an INSERT operation into the CUSTOMER_EVENTS table, specifying values for the columns CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, and THING_ID. Here, CUSTOMER_EVENT_ID is set to the value of v_max_event_id plus 1, CUSTOMER_ID is set to the literal numeric value 1, DATE_MOVED_IN is set to the new value of the RESIDENTS.DATE_MOVED_IN column from the updated row, PROPERTY_ID is set to the new value of the RESIDENTS.PROPERTY_ID column from the updated row, RESIDENT_ID is set to the new value of the RESIDENTS.RESIDENT_ID column from the updated row, and THING_ID is set to the literal numeric value 1.\n\nIf v_count is not equal to 0, the trigger then evaluates the value of v_property_type. If v_property_type equals the string literal 'house', the trigger performs an UPDATE operation on the CUSTOMER_EVENTS table, setting the DATE_MOVED_IN column to the new value of the RESIDENTS.DATE_MOVED_IN column from the updated row, where the CUSTOMER_EVENTS.PROPERTY_ID equals the new value of the RESIDENTS.PROPERTY_ID column from the updated row, and CUSTOMER_EVENTS.RESIDENT_ID equals the new value of the RESIDENTS.RESIDENT_ID column from the updated row, and CUSTOMER_EVENTS.DATE_MOVED_IN equals the old value of the RESIDENTS.DATE_MOVED_IN column from the row before the update.\n\nIf v_property_type equals the string literal 'apartment', the trigger performs a DELETE operation on the CUSTOMER_EVENTS table, where the CUSTOMER_EVENTS.PROPERTY_ID equals the new value of the RESIDENTS.PROPERTY_ID column from the updated row, and CUSTOMER_EVENTS.RESIDENT_ID equals the new value of the RESIDENTS.RESIDENT_ID column from the updated row, and CUSTOMER_EVENTS.DATE_MOVED_IN equals the old value of the RESIDENTS.DATE_MOVED_IN column from the row before the update.\n\nFor any other value of v_property_type (i.e., not 'house' and not 'apartment'), the trigger performs an INSERT operation into the CUSTOMER_EVENTS table, specifying values for the columns CUSTOMER_EVENT_ID, CUSTOMER_ID, DATE_MOVED_IN, PROPERTY_ID, RESIDENT_ID, and THING_ID. Here, CUSTOMER_EVENT_ID is set to the value of v_max_event_id plus 2, CUSTOMER_ID is set to the literal numeric value 2, DATE_MOVED_IN is set to the new value of the RESIDENTS.DATE_MOVED_IN column from the updated row, PROPERTY_ID is set to the new value of the RESIDENTS.PROPERTY_ID column from the updated row, RESIDENT_ID is set to the new value of the RESIDENTS.RESIDENT_ID column from the updated row, and THING_ID is set to the literal numeric value 2."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_song_sales_update that activates after an update operation on the SONG table for each row affected. The trigger begins by declaring a local variable v_count of type NUMBER. It includes a PRAGMA AUTONOMOUS_TRANSACTION directive to allow independent transaction control within the trigger. The trigger logic first checks if the updated SALES column value in the SONG table exceeds 500,000. If true, it attempts to insert a new record into the SINGER table with the columns SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, and CITIZENSHIP, using the updated SINGER_ID from the SONG table, a fixed NAME value 'New Star', a calculated BIRTH_YEAR as the current year minus 30, a NET_WORTH_MILLIONS value derived from dividing the updated SALES by 1,000,000, and a fixed CITIZENSHIP value 'Unknown'. If a duplicate value on a unique index is encountered during insertion, the exception is caught and ignored. If the updated SALES value is between 300,000 and 500,000 inclusive, the trigger updates the SINGER table by increasing the NET_WORTH_MILLIONS column by 5 for the row where SINGER_ID matches the updated SINGER_ID from the SONG table. The trigger then performs a SELECT COUNT(*) operation into the v_count variable to count the number of rows in the SONG table where SINGER_ID matches the updated SINGER_ID. If v_count exceeds 10, the trigger updates the SINGER table to set the CITIZENSHIP column to 'Global' for the row where SINGER_ID matches the updated SINGER_ID from the SONG table.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_song_sales_update\nAFTER UPDATE ON SONG\nFOR EACH ROW\nDECLARE\n   v_count NUMBER;\n   PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN\n   IF :NEW.SALES > 500000 THEN\n      BEGIN\n         INSERT INTO SINGER (SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, CITIZENSHIP)\n         VALUES (:NEW.SINGER_ID, 'New Star', EXTRACT(YEAR FROM CURRENT_DATE) - 30, :NEW.SALES / 1000000, 'Unknown');\n      EXCEPTION\n         WHEN DUP_VAL_ON_INDEX THEN\n            NULL; -- Singer already exists, ignore\n      END;\n   ELSIF :NEW.SALES BETWEEN 300000 AND 500000 THEN\n      UPDATE SINGER SET NET_WORTH_MILLIONS = NET_WORTH_MILLIONS + 5 WHERE SINGER_ID = :NEW.SINGER_ID;\n   END IF;\n   \n   SELECT COUNT(*) INTO v_count FROM SONG WHERE SINGER_ID = :NEW.SINGER_ID;\n   IF v_count > 10 THEN\n      UPDATE SINGER SET CITIZENSHIP = 'Global' WHERE SINGER_ID = :NEW.SINGER_ID;\n   END IF;\n   \n   COMMIT;\nEND;",
    "database_name": "singer",
    "tables": [
      "SINGER",
      "SONG"
    ],
    "call_sqls": [
      "UPDATE SONG SET SALES = 600000 WHERE SONG_ID = 3",
      "UPDATE SONG SET SALES = 450000 WHERE SONG_ID = 4",
      "UPDATE SONG SET SALES = 320000 WHERE SONG_ID = 5",
      "UPDATE SONG SET SALES = 700000 WHERE SONG_ID = 3",
      "UPDATE SONG SET SALES = 480000 WHERE SONG_ID = 4"
    ],
    "summary": "Create an AFTER UPDATE row-level trigger named trg_song_sales_update on the SONG table. Declare a local NUMBER variable v_count and use PRAGMA AUTONOMOUS_TRANSACTION. If the updated SALES > 500,000, insert a new singer into the SINGER table using the updated SINGER_ID, with NAME='New Star', BIRTH_YEAR as current year minus 30, NET_WORTH_MILLIONS as SALES/1,000,000, and CITIZENSHIP='Unknown'. Ignore duplicate value errors. If SALES is between 300,000 and 500,000 inclusive, update the SINGER table to increase NET_WORTH_MILLIONS by 5 for the matching SINGER_ID. Then, count the songs for this singer. If the count exceeds 10, update the singer's CITIZENSHIP to 'Global'.",
    "natural_language": "Set up a trigger on the SONG table for after updates. It should have a local number variable and use that autonomous transaction pragma. If the sales figure gets bumped up past a really high threshold, like over half a million, then add a new singer entry. Use the singer ID from the update, set the name to something like 'New Star', make the birth year roughly 30 years back from now, calculate the net worth from the sales in a simple way, and mark citizenship as 'Unknown'. Don't worry if it tries to add a duplicate. If the sales are in that pretty good range, say from 300k up to 500k, then give the existing singer's net worth a decent boost. After that, check how many songs that singer has. If it's a lot, more than ten, then update their citizenship to something like 'Global'.",
    "id": 97,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_song_sales_update that activates after an update operation on the SONG table for each row affected. The trigger begins by declaring a local variable v_count of type NUMBER. It includes a PRAGMA AUTONOMOUS_TRANSACTION directive to allow independent transaction control within the trigger. The trigger logic first checks if the updated SALES column value in the SONG table exceeds 500,000. If true, it attempts to insert a new record into the SINGER table with the columns SINGER_ID, NAME, BIRTH_YEAR, NET_WORTH_MILLIONS, and CITIZENSHIP, using the updated SINGER_ID from the SONG table, a fixed NAME value 'New Star', a calculated BIRTH_YEAR as the current year minus 30, a NET_WORTH_MILLIONS value derived from dividing the updated SALES by 1,000,000, and a fixed CITIZENSHIP value 'Unknown'. If a duplicate value on a unique index is encountered during insertion, the exception is caught and ignored. If the updated SALES value is between 300,000 and 500,000 inclusive, the trigger updates the SINGER table by increasing the NET_WORTH_MILLIONS column by 5 for the row where SINGER_ID matches the updated SINGER_ID from the SONG table. The trigger then performs a SELECT COUNT(*) operation into the v_count variable to count the number of rows in the SONG table where SINGER_ID matches the updated SINGER_ID. If v_count exceeds 10, the trigger updates the SINGER table to set the CITIZENSHIP column to 'Global' for the row where SINGER_ID matches the updated SINGER_ID from the SONG table."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_likes_before_update` that is activated `BEFORE` any `UPDATE` operation occurs on the `LIKES` table, and executes `FOR EACH ROW` that is being updated. This trigger first declares two local `NUMBER` variables: `v_old_grade` and `v_new_grade`. It then performs a `SELECT` operation to retrieve the `GRADE` from the `HIGHSCHOOLER` table, specifically for the highschooler whose `ID` matches the `STUDENT_ID` value of the row `BEFORE` the update (`:OLD.STUDENT_ID`), and stores this retrieved grade into the `v_old_grade` variable. Subsequently, it performs another `SELECT` operation to retrieve the `GRADE` from the `HIGHSCHOOLER` table, specifically for the highschooler whose `ID` matches the `STUDENT_ID` value of the row `AFTER` the update (`:NEW.STUDENT_ID`), and stores this retrieved grade into the `v_new_grade` variable. Following these data retrievals, the trigger evaluates a conditional `IF-THEN-ELSIF-ELSE` block. If the value of `v_old_grade` is `EQUAL` to the value of `v_new_grade`, then an `INSERT` operation is performed into the `FRIEND` table, adding a new record where the `STUDENT_ID` column is set to the `STUDENT_ID` value of the row `BEFORE` the update (`:OLD.STUDENT_ID`) and the `FRIEND_ID` column is set to the `STUDENT_ID` value of the row `AFTER` the update (`:NEW.STUDENT_ID`). If the first condition is not met, and the value of `v_old_grade` is `GREATER THAN` the value of `v_new_grade`, then a `DELETE` operation is performed on the `FRIEND` table, removing any records where the `STUDENT_ID` column matches the `STUDENT_ID` value of the row `BEFORE` the update (`:OLD.STUDENT_ID`) `AND` the `FRIEND_ID` column matches the `STUDENT_ID` value of the row `AFTER` the update (`:NEW.STUDENT_ID`). If neither of the preceding conditions is met, then an `UPDATE` operation is performed on the `HIGHSCHOOLER` table, setting the `GRADE` column to the value of `v_new_grade` for the highschooler whose `ID` matches the `STUDENT_ID` value of the row `BEFORE` the update (`:OLD.STUDENT_ID`).",
    "plsql": "CREATE OR REPLACE TRIGGER trg_likes_before_update\nBEFORE UPDATE ON LIKES\nFOR EACH ROW\nDECLARE\n  v_old_grade NUMBER;\n  v_new_grade NUMBER;\nBEGIN\n  SELECT GRADE INTO v_old_grade FROM HIGHSCHOOLER WHERE ID = :OLD.STUDENT_ID;\n  SELECT GRADE INTO v_new_grade FROM HIGHSCHOOLER WHERE ID = :NEW.STUDENT_ID;\n  IF v_old_grade = v_new_grade THEN\n    INSERT INTO FRIEND (STUDENT_ID, FRIEND_ID) VALUES (:OLD.STUDENT_ID, :NEW.STUDENT_ID);\n  ELSIF v_old_grade > v_new_grade THEN\n    DELETE FROM FRIEND WHERE STUDENT_ID = :OLD.STUDENT_ID AND FRIEND_ID = :NEW.STUDENT_ID;\n  ELSE\n    UPDATE HIGHSCHOOLER SET GRADE = v_new_grade WHERE ID = :OLD.STUDENT_ID;\n  END IF;\nEND;",
    "database_name": "network_1",
    "tables": [
      "FRIEND",
      "HIGHSCHOOLER",
      "LIKES"
    ],
    "call_sqls": [
      "UPDATE LIKES SET STUDENT_ID = 1025 WHERE STUDENT_ID = 1247 AND LIKED_ID = 1101",
      "UPDATE LIKES SET STUDENT_ID = 1316 WHERE STUDENT_ID = 1025 AND LIKED_ID = 1468",
      "UPDATE LIKES SET LIKED_ID = 1304 WHERE STUDENT_ID = 1247 AND LIKED_ID = 1101",
      "UPDATE LIKES SET STUDENT_ID = 1025, LIKED_ID = 1468 WHERE STUDENT_ID = 1316 AND LIKED_ID = 1304",
      "UPDATE LIKES SET STUDENT_ID = 1247 WHERE STUDENT_ID = 1025 AND LIKED_ID = 1468"
    ],
    "summary": "Create a BEFORE UPDATE row-level trigger named trg_likes_before_update on the LIKES table. For each updated row, get the grades for the old and new STUDENT_ID from HIGHSCHOOLER. If the grades are equal, insert a new friend record. If the old grade is greater than the new grade, delete the corresponding friend record. Otherwise, update the old student's grade in HIGHSCHOOLER to the new grade.",
    "natural_language": "Alright, so we need a trigger called trg_likes_before_update for the LIKES table, and it's gotta fire for each row before an update. Here's the deal: grab the grades for the old and new STUDENT_ID from the HIGHSCHOOLER table. If the grades are the same, just go ahead and add a new friend record. If the old grade is higher than the new one, you'll wanna delete that friend record. Otherwise, if none of that fits, just update the old student's grade in HIGHSCHOOLER to match the new one.",
    "id": 98,
    "generated_ir": "Write an Oracle PL/SQL database trigger named `trg_likes_before_update` that is activated `BEFORE` an `UPDATE` operation on the `LIKES` table. This trigger executes `FOR EACH ROW` that is affected by the update.\n\nUpon activation, the trigger first declares two local numeric variables: `v_old_grade` and `v_new_grade`. These variables will store the grade values for the students involved in the update.\n\nThe trigger then performs two `SELECT` operations to retrieve the grades from the `HIGHSCHOOLER` table. The first `SELECT` statement queries the `HIGHSCHOOLER` table to obtain the `GRADE` for the student whose `ID` matches the `STUDENT_ID` value from the `:OLD` pseudo-record, which represents the original values of the row being updated in the `LIKES` table. This retrieved grade is stored in the `v_old_grade` variable. The second `SELECT` statement queries the `HIGHSCHOOLER` table to obtain the `GRADE` for the student whose `ID` matches the `STUDENT_ID` value from the `:NEW` pseudo-record, which represents the new values of the row being updated in the `LIKES` table. This retrieved grade is stored in the `v_new_grade` variable.\n\nFollowing the grade retrieval, the trigger implements a conditional logic block using an `IF` statement to compare the values of `v_old_grade` and `v_new_grade`.\n\nIf the condition `v_old_grade = v_new_grade` evaluates to `TRUE`, indicating the grades are equal, the trigger performs an `INSERT` operation into the `FRIEND` table. The `INSERT` statement populates the `STUDENT_ID` column with the `STUDENT_ID` value from the `:NEW` pseudo-record and the `FRIEND_ID` column with the `LIKED_ID` value from the `:NEW` pseudo-record, thereby creating a new friend relationship based on the updated `LIKES` row.\n\nIf the condition `v_old_grade > v_new_grade` evaluates to `TRUE`, indicating the old grade is higher than the new grade, the trigger performs a `DELETE` operation on the `FRIEND` table. The `DELETE` statement targets rows where the `STUDENT_ID` column matches the `STUDENT_ID` value from the `:OLD` pseudo-record and the `FRIEND_ID` column matches the `LIKED_ID` value from the `:OLD` pseudo-record, thereby removing the friend relationship that existed prior to the update.\n\nIf neither of the above conditions is met (i.e., the old grade is less than the new grade), the trigger performs an `UPDATE` operation on the `HIGHSCHOOLER` table. The `UPDATE` statement modifies the `GRADE` column for the row where the `ID` matches the `STUDENT_ID` value from the `:OLD` pseudo-record. It sets this `GRADE` to the value stored in the `v_new_grade` variable, thereby updating the old student's grade to match the new student's grade."
  },
  {
    "ir": "Write an Oracle PL/SQL database trigger named `trg_photos_cleanup` that is activated after a `DELETE` operation is performed on the `PHOTOS` table. This trigger is a row-level trigger, meaning it executes once for each individual row that is deleted from the `PHOTOS` table. Upon the deletion of a row from the `PHOTOS` table, the trigger performs an `UPDATE` operation on the `MOUNTAIN` table. Specifically, it increments the value in the `PROMINENCE` column of the `MOUNTAIN` table by `100`. This update is applied only to the row in the `MOUNTAIN` table where the `ID` column matches the value of the `MOUNTAIN_ID` column from the row that was just deleted from the `PHOTOS` table. The `:OLD.MOUNTAIN_ID` refers to the value of the `MOUNTAIN_ID` column in the row of the `PHOTOS` table *before* it was deleted.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_photos_cleanup\nAFTER DELETE ON PHOTOS\nFOR EACH ROW\nBEGIN\n    UPDATE MOUNTAIN \n    SET PROMINENCE = PROMINENCE + 100 \n    WHERE ID = :OLD.MOUNTAIN_ID;\nEND;",
    "database_name": "mountain_photos",
    "tables": [
      "CAMERA_LENS",
      "MOUNTAIN",
      "PHOTOS"
    ],
    "call_sqls": [
      "DELETE FROM PHOTOS WHERE ID = 1",
      "DELETE FROM PHOTOS WHERE MOUNTAIN_ID = 20",
      "DELETE FROM PHOTOS WHERE NAME = 'monkey'",
      "DELETE FROM PHOTOS WHERE CAMERA_LENS_ID = 10",
      "DELETE FROM PHOTOS WHERE COLOR = 'RBG'"
    ],
    "summary": "Create an AFTER DELETE FOR EACH ROW trigger named trg_photos_cleanup on the PHOTOS table. For each deleted row, update the MOUNTAIN table, incrementing the PROMINENCE column by 100 where the MOUNTAIN.ID equals :OLD.MOUNTAIN_ID.",
    "natural_language": "Construct an AFTER DELETE FOR EACH ROW trigger, which should be named trg_photos_cleanup, specifically on the PHOTOS table. For every single row that is subsequently deleted, you must carefully update the MOUNTAIN table by precisely incrementing the value in its PROMINENCE column by a full 100 units, but only in those specific records where the MOUNTAIN.ID column matches exactly the :OLD.MOUNTAIN_ID value from the recently removed row.",
    "id": 99,
    "generated_ir": "Write an Oracle PL/SQL trigger named `trg_photos_cleanup` that is configured to execute automatically `AFTER` a `DELETE` operation occurs on each row of the `PHOTOS` table. This trigger does not accept any explicit parameters. Upon activation for a deleted row, the trigger performs an `UPDATE` operation on the `MOUNTAIN` table. The update specifically targets rows in the `MOUNTAIN` table where the value in the `MOUNTAIN.ID` column is exactly equal to the value that was in the `PHOTOS.MOUNTAIN_ID` column of the row just deleted, which is accessed via the `:OLD.MOUNTAIN_ID` pseudorecord. For each matching row in the `MOUNTAIN` table, the trigger increments the current numerical value in the `PROMINENCE` column by exactly 100 units, setting the column to this new calculated value. No other columns in the `MOUNTAIN` table are modified. The trigger does not declare any local variables, perform any `SELECT` operations, or produce any direct console output. Its sole function is to conditionally update the `PROMINENCE` of the related mountain record following the deletion of a photo."
  },
  {
    "ir": "Write an Oracle PL/SQL trigger named trg_standardize_zip_code that fires before any INSERT or UPDATE operation on the OWNERS table for each affected row, and within the trigger body, it modifies the new value for the ZIP_CODE column by applying the LPAD function to it, which pads the left side of the original :NEW.ZIP_CODE value with the character '0' until the resulting string reaches a total length of 5 characters, thereby standardizing the ZIP_CODE format to a 5-digit zero-padded string for the data being inserted or updated.",
    "plsql": "CREATE OR REPLACE TRIGGER trg_standardize_zip_code\nBEFORE INSERT OR UPDATE ON OWNERS\nFOR EACH ROW\nBEGIN\n    :NEW.ZIP_CODE := LPAD(:NEW.ZIP_CODE, 5, '0');\nEND;",
    "database_name": "dog_kennels",
    "tables": [
      "DOGS",
      "OWNERS",
      "BREEDS",
      "SIZES",
      "TREATMENTS",
      "TREATMENT_TYPES"
    ],
    "call_sqls": [
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (5, 'John', 'Doe', '123 Main St', 'Anytown', 'Anystate', '123', 'john.doe@example.com', '123-456-7890', '098-765-4321')",
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (6, 'Jane', 'Smith', '456 Elm St', 'Othertown', 'Otherstate', '45', 'jane.smith@example.com', '234-567-8901', '987-654-3210')",
      "UPDATE OWNERS SET ZIP_CODE = '789' WHERE OWNER_ID = 1",
      "UPDATE OWNERS SET ZIP_CODE = '12' WHERE OWNER_ID = 3",
      "INSERT INTO OWNERS (OWNER_ID, FIRST_NAME, LAST_NAME, STREET, CITY, STATE, ZIP_CODE, EMAIL_ADDRESS, HOME_PHONE, CELL_NUMBER) VALUES (7, 'Alice', 'Johnson', '789 Pine St', 'Sometown', 'Somestate', '6789', 'alice.johnson@example.com', '345-678-9012', '876-543-2109')"
    ],
    "summary": "Create a BEFORE INSERT OR UPDATE FOR EACH ROW trigger named trg_standardize_zip_code on the OWNERS table. For each row, set :NEW.ZIP_CODE to LPAD(:NEW.ZIP_CODE, 5, '0').",
    "natural_language": "Set up a BEFORE INSERT OR UPDATE FOR EACH ROW trigger called trg_standardize_zip_code on the OWNERS table. For each new or updated row, pad the :NEW.ZIP_CODE value with leading zeros to ensure it is five characters long.",
    "id": 100,
    "generated_ir": "Write an Oracle PL/SQL trigger named trg_standardize_zip_code that executes before any insert or update operation on the OWNERS table, firing individually for each row being inserted or updated. The trigger declares no local variables. For each row, it performs a transformation on the :NEW.ZIP_CODE value by using the LPAD function to pad the string with leading zeros on the left side until it reaches a total length of five characters. Specifically, it sets :NEW.ZIP_CODE to LPAD(:NEW.ZIP_CODE, 5, '0'). This operation ensures that every ZIP_CODE value in the OWNERS table is standardized to a five-character string, regardless of the original input length, by adding zeros to the beginning if the original value has fewer than five characters."
  }
]